{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Introducing Ultralytics YOLOv8, the latest version of the acclaimed real-time object detection and image segmentation model. YOLOv8 is built on cutting-edge advancements in deep learning and computer vision, offering unparalleled performance in terms of speed and accuracy. Its streamlined design makes it suitable for various applications and easily adaptable to different hardware platforms, from edge devices to cloud APIs.</p> <p>Explore the YOLOv8 Docs, a comprehensive resource designed to help you understand and utilize its features and capabilities. Whether you are a seasoned machine learning practitioner or new to the field, this hub aims to maximize YOLOv8's potential in your projects</p>"},{"location":"#where-to-start","title":"Where to Start","text":"<ul> <li>Install <code>ultralytics</code> with pip and get up and running in minutes \u00a0  Get Started</li> <li>Predict new images and videos with YOLOv8 \u00a0  Predict on Images</li> <li>Train a new YOLOv8 model on your own custom dataset \u00a0  Train a Model</li> <li>Tasks YOLOv8 tasks like segment, classify, pose and track \u00a0  Explore Tasks</li> <li>NEW \ud83d\ude80 Explore datasets with advanced semantic and SQL search \u00a0  Explore a Dataset</li> </ul> <p> Watch: How to Train a YOLOv8 model on Your Custom Dataset in Google Colab. </p>"},{"location":"#yolo-a-brief-history","title":"YOLO: A Brief History","text":"<p>YOLO (You Only Look Once), a popular object detection and image segmentation model, was developed by Joseph Redmon and Ali Farhadi at the University of Washington. Launched in 2015, YOLO quickly gained popularity for its high speed and accuracy.</p> <ul> <li>YOLOv2, released in 2016, improved the original model by incorporating batch normalization, anchor boxes, and dimension clusters.</li> <li>YOLOv3, launched in 2018, further enhanced the model's performance using a more efficient backbone network, multiple anchors and spatial pyramid pooling.</li> <li>YOLOv4 was released in 2020, introducing innovations like Mosaic data augmentation, a new anchor-free detection head, and a new loss function.</li> <li>YOLOv5 further improved the model's performance and added new features such as hyperparameter optimization, integrated experiment tracking and automatic export to popular export formats.</li> <li>YOLOv6 was open-sourced by Meituan in 2022 and is in use in many of the company's autonomous delivery robots.</li> <li>YOLOv7 added additional tasks such as pose estimation on the COCO keypoints dataset.</li> <li>YOLOv8 is the latest version of YOLO by Ultralytics. As a cutting-edge, state-of-the-art (SOTA) model, YOLOv8 builds on the success of previous versions, introducing new features and improvements for enhanced performance, flexibility, and efficiency. YOLOv8 supports a full range of vision AI tasks, including detection, segmentation, pose estimation, tracking, and classification. This versatility allows users to leverage YOLOv8's capabilities across diverse applications and domains.</li> </ul>"},{"location":"#yolo-licenses-how-is-ultralytics-yolo-licensed","title":"YOLO Licenses: How is Ultralytics YOLO licensed?","text":"<p>Ultralytics offers two licensing options to accommodate diverse use cases:</p> <ul> <li>AGPL-3.0 License: This OSI-approved open-source license is ideal for students and enthusiasts, promoting open collaboration and knowledge sharing. See the LICENSE file for more details.</li> <li>Enterprise License: Designed for commercial use, this license permits seamless integration of Ultralytics software and AI models into commercial goods and services, bypassing the open-source requirements of AGPL-3.0. If your scenario involves embedding our solutions into a commercial offering, reach out through Ultralytics Licensing.</li> </ul> <p>Our licensing strategy is designed to ensure that any improvements to our open-source projects are returned to the community. We hold the principles of open source close to our hearts \u2764\ufe0f, and our mission is to guarantee that our contributions can be utilized and expanded upon in ways that are beneficial to all.</p>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#install-ultralytics","title":"Install Ultralytics","text":"<p>Ultralytics provides various installation methods including pip, conda, and Docker. Install YOLOv8 via the <code>ultralytics</code> pip package for the latest stable release or by cloning the Ultralytics GitHub repository for the most up-to-date version. Docker can be used to execute the package in an isolated container, avoiding local installation.</p> <p> Watch: Ultralytics YOLO Quick Start Guide </p> <p>Install</p> Pip install (recommended)Conda installGit cloneDocker <p>Install the <code>ultralytics</code> package using pip, or update an existing installation by running <code>pip install -U ultralytics</code>. Visit the Python Package Index (PyPI) for more details on the <code>ultralytics</code> package: https://pypi.org/project/ultralytics/.</p> <p> </p> <pre><code># Install the ultralytics package from PyPI\npip install ultralytics\n</code></pre> <p>You can also install the <code>ultralytics</code> package directly from the GitHub repository. This might be useful if you want the latest development version. Make sure to have the Git command-line tool installed on your system. The <code>@main</code> command installs the <code>main</code> branch and may be modified to another branch, i.e. <code>@my-branch</code>, or removed entirely to default to <code>main</code> branch.</p> <pre><code># Install the ultralytics package from GitHub\npip install git+https://github.com/ultralytics/ultralytics.git@main\n</code></pre> <p>Conda is an alternative package manager to pip which may also be used for installation. Visit Anaconda for more details at https://anaconda.org/conda-forge/ultralytics. Ultralytics feedstock repository for updating the conda package is at https://github.com/conda-forge/ultralytics-feedstock/.</p> <p> </p> <pre><code># Install the ultralytics package using conda\nconda install -c conda-forge ultralytics\n</code></pre> <p>Note</p> <p>If you are installing in a CUDA environment best practice is to install <code>ultralytics</code>, <code>pytorch</code> and <code>pytorch-cuda</code> in the same command to allow the conda package manager to resolve any conflicts, or else to install <code>pytorch-cuda</code> last to allow it override the CPU-specific <code>pytorch</code> package if necessary. <pre><code># Install all packages together using conda\nconda install -c pytorch -c nvidia -c conda-forge pytorch torchvision pytorch-cuda=11.8 ultralytics\n</code></pre></p> <p>Clone the <code>ultralytics</code> repository if you are interested in contributing to the development or wish to experiment with the latest source code. After cloning, navigate into the directory and install the package in editable mode <code>-e</code> using pip. <pre><code># Clone the ultralytics repository\ngit clone https://github.com/ultralytics/ultralytics\n\n# Navigate to the cloned directory\ncd ultralytics\n\n# Install the package in editable mode for development\npip install -e .\n</code></pre></p> <p>Utilize Docker to effortlessly execute the <code>ultralytics</code> package in an isolated container, ensuring consistent and smooth performance across various environments. By choosing one of the official <code>ultralytics</code> images from Docker Hub, you not only avoid the complexity of local installation but also benefit from access to a verified working environment. Ultralytics offers 5 main supported Docker images, each designed to provide high compatibility and efficiency for different platforms and use cases:</p> <p></p> <ul> <li>Dockerfile: GPU image recommended for training.</li> <li>Dockerfile-arm64: Optimized for ARM64 architecture, allowing deployment on devices like Raspberry Pi and other ARM64-based platforms.</li> <li>Dockerfile-cpu: Ubuntu-based CPU-only version suitable for inference and environments without GPUs.</li> <li>Dockerfile-jetson: Tailored for NVIDIA Jetson devices, integrating GPU support optimized for these platforms.</li> <li>Dockerfile-python: Minimal image with just Python and necessary dependencies, ideal for lightweight applications and development.</li> <li>Dockerfile-conda: Based on Miniconda3 with conda installation of ultralytics package.</li> </ul> <p>Below are the commands to get the latest image and execute it:</p> <pre><code># Set image name as a variable\nt=ultralytics/ultralytics:latest\n\n# Pull the latest ultralytics image from Docker Hub\nsudo docker pull $t\n\n# Run the ultralytics image in a container with GPU support\nsudo docker run -it --ipc=host --gpus all $t  # all GPUs\nsudo docker run -it --ipc=host --gpus '\"device=2,3\"' $t  # specify GPUs\n</code></pre> <p>The above command initializes a Docker container with the latest <code>ultralytics</code> image. The <code>-it</code> flag assigns a pseudo-TTY and maintains stdin open, enabling you to interact with the container. The <code>--ipc=host</code> flag sets the IPC (Inter-Process Communication) namespace to the host, which is essential for sharing memory between processes. The <code>--gpus all</code> flag enables access to all available GPUs inside the container, which is crucial for tasks that require GPU computation.</p> <p>Note: To work with files on your local machine within the container, use Docker volumes for mounting a local directory into the container:</p> <pre><code># Mount local directory to a directory inside the container\nsudo docker run -it --ipc=host --gpus all -v /path/on/host:/path/in/container $t\n</code></pre> <p>Alter <code>/path/on/host</code> with the directory path on your local machine, and <code>/path/in/container</code> with the desired path inside the Docker container for accessibility.</p> <p>For advanced Docker usage, feel free to explore the Ultralytics Docker Guide.</p> <p>See the <code>ultralytics</code> requirements.txt file for a list of dependencies. Note that all examples above install all required dependencies.</p> <p>Tip</p> <p>PyTorch requirements vary by operating system and CUDA requirements, so it's recommended to install PyTorch first following instructions at https://pytorch.org/get-started/locally.</p> <p> </p>"},{"location":"quickstart/#conda-docker-image","title":"Conda Docker Image","text":"<p>Ultralytics Conda Docker images are also available from DockerHub. These images are based on Miniconda3 and are an simple way to start using <code>ultralytics</code> in a Conda environment.</p> <pre><code># Set image name as a variable\nt=ultralytics/ultralytics:latest-conda\n\n# Pull the latest ultralytics image from Docker Hub\nsudo docker pull $t\n\n# Run the ultralytics image in a container with GPU support\nsudo docker run -it --ipc=host --gpus all $t  # all GPUs\nsudo docker run -it --ipc=host --gpus '\"device=2,3\"' $t  # specify GPUs\n</code></pre>"},{"location":"quickstart/#use-ultralytics-with-cli","title":"Use Ultralytics with CLI","text":"<p>The Ultralytics command line interface (CLI) allows for simple single-line commands without the need for a Python environment. CLI requires no customization or Python code. You can simply run all tasks from the terminal with the <code>yolo</code> command. Check out the CLI Guide to learn more about using YOLOv8 from the command line.</p> <p>Example</p> SyntaxTrainPredictValExportSpecial <p>Ultralytics <code>yolo</code> commands use the following syntax: <pre><code>yolo TASK MODE ARGS\n</code></pre></p> <ul> <li><code>TASK</code> (optional) is one of (detect, segment, classify, pose)</li> <li><code>MODE</code> (required) is one of (train, val, predict, export, track)</li> <li><code>ARGS</code> (optional) are <code>arg=value</code> pairs like <code>imgsz=640</code> that override defaults.</li> </ul> <p>See all <code>ARGS</code> in the full Configuration Guide or with the <code>yolo cfg</code> CLI command.</p> <p>Train a detection model for 10 epochs with an initial learning_rate of 0.01 <pre><code>yolo train data=coco128.yaml model=yolov8n.pt epochs=10 lr0=0.01\n</code></pre></p> <p>Predict a YouTube video using a pretrained segmentation model at image size 320: <pre><code>yolo predict model=yolov8n-seg.pt source='https://youtu.be/LNwODJXcvt4' imgsz=320\n</code></pre></p> <p>Val a pretrained detection model at batch-size 1 and image size 640: <pre><code>yolo val model=yolov8n.pt data=coco128.yaml batch=1 imgsz=640\n</code></pre></p> <p>Export a YOLOv8n classification model to ONNX format at image size 224 by 128 (no TASK required) <pre><code>yolo export model=yolov8n-cls.pt format=onnx imgsz=224,128\n</code></pre></p> <p>Run special commands to see version, view settings, run checks and more: <pre><code>yolo help\nyolo checks\nyolo version\nyolo settings\nyolo copy-cfg\nyolo cfg\n</code></pre></p> <p>Warning</p> <p>Arguments must be passed as <code>arg=val</code> pairs, split by an equals <code>=</code> sign and delimited by spaces between pairs. Do not use <code>--</code> argument prefixes or commas <code>,</code> between arguments.</p> <ul> <li><code>yolo predict model=yolov8n.pt imgsz=640 conf=0.25</code>  \u2705</li> <li><code>yolo predict model yolov8n.pt imgsz 640 conf 0.25</code>  \u274c (missing <code>=</code>)</li> <li><code>yolo predict model=yolov8n.pt, imgsz=640, conf=0.25</code>  \u274c (do not use <code>,</code>)</li> <li><code>yolo predict --model yolov8n.pt --imgsz 640 --conf 0.25</code>  \u274c (do not use <code>--</code>)</li> </ul> <p>CLI Guide</p>"},{"location":"quickstart/#use-ultralytics-with-python","title":"Use Ultralytics with Python","text":"<p>YOLOv8's Python interface allows for seamless integration into your Python projects, making it easy to load, run, and process the model's output. Designed with simplicity and ease of use in mind, the Python interface enables users to quickly implement object detection, segmentation, and classification in their projects. This makes YOLOv8's Python interface an invaluable tool for anyone looking to incorporate these functionalities into their Python projects.</p> <p>For example, users can load a model, train it, evaluate its performance on a validation set, and even export it to ONNX format with just a few lines of code. Check out the Python Guide to learn more about using YOLOv8 within your Python projects.</p> <p>Example</p> <pre><code>from ultralytics import YOLO\n\n# Create a new YOLO model from scratch\nmodel = YOLO('yolov8n.yaml')\n\n# Load a pretrained YOLO model (recommended for training)\nmodel = YOLO('yolov8n.pt')\n\n# Train the model using the 'coco128.yaml' dataset for 3 epochs\nresults = model.train(data='coco128.yaml', epochs=3)\n\n# Evaluate the model's performance on the validation set\nresults = model.val()\n\n# Perform object detection on an image using the model\nresults = model('https://ultralytics.com/images/bus.jpg')\n\n# Export the model to ONNX format\nsuccess = model.export(format='onnx')\n</code></pre> <p>Python Guide</p>"},{"location":"quickstart/#ultralytics-settings","title":"Ultralytics Settings","text":"<p>The Ultralytics library provides a powerful settings management system to enable fine-grained control over your experiments. By making use of the <code>SettingsManager</code> housed within the <code>ultralytics.utils</code> module, users can readily access and alter their settings. These are stored in a YAML file and can be viewed or modified either directly within the Python environment or via the Command-Line Interface (CLI).</p>"},{"location":"quickstart/#inspecting-settings","title":"Inspecting Settings","text":"<p>To gain insight into the current configuration of your settings, you can view them directly:</p> <p>View settings</p> PythonCLI <p>You can use Python to view your settings. Start by importing the <code>settings</code> object from the <code>ultralytics</code> module. Print and return settings using the following commands: <pre><code>from ultralytics import settings\n\n# View all settings\nprint(settings)\n\n# Return a specific setting\nvalue = settings['runs_dir']\n</code></pre></p> <p>Alternatively, the command-line interface allows you to check your settings with a simple command: <pre><code>yolo settings\n</code></pre></p>"},{"location":"quickstart/#modifying-settings","title":"Modifying Settings","text":"<p>Ultralytics allows users to easily modify their settings. Changes can be performed in the following ways:</p> <p>Update settings</p> PythonCLI <p>Within the Python environment, call the <code>update</code> method on the <code>settings</code> object to change your settings: <pre><code>from ultralytics import settings\n\n# Update a setting\nsettings.update({'runs_dir': '/path/to/runs'})\n\n# Update multiple settings\nsettings.update({'runs_dir': '/path/to/runs', 'tensorboard': False})\n\n# Reset settings to default values\nsettings.reset()\n</code></pre></p> <p>If you prefer using the command-line interface, the following commands will allow you to modify your settings: <pre><code># Update a setting\nyolo settings runs_dir='/path/to/runs'\n\n# Update multiple settings\nyolo settings runs_dir='/path/to/runs' tensorboard=False\n\n# Reset settings to default values\nyolo settings reset\n</code></pre></p>"},{"location":"quickstart/#understanding-settings","title":"Understanding Settings","text":"<p>The table below provides an overview of the settings available for adjustment within Ultralytics. Each setting is outlined along with an example value, the data type, and a brief description.</p> Name Example Value Data Type Description <code>settings_version</code> <code>'0.0.4'</code> <code>str</code> Ultralytics settings version (different from Ultralytics pip version) <code>datasets_dir</code> <code>'/path/to/datasets'</code> <code>str</code> The directory where the datasets are stored <code>weights_dir</code> <code>'/path/to/weights'</code> <code>str</code> The directory where the model weights are stored <code>runs_dir</code> <code>'/path/to/runs'</code> <code>str</code> The directory where the experiment runs are stored <code>uuid</code> <code>'a1b2c3d4'</code> <code>str</code> The unique identifier for the current settings <code>sync</code> <code>True</code> <code>bool</code> Whether to sync analytics and crashes to HUB <code>api_key</code> <code>''</code> <code>str</code> Ultralytics HUB API Key <code>clearml</code> <code>True</code> <code>bool</code> Whether to use ClearML logging <code>comet</code> <code>True</code> <code>bool</code> Whether to use Comet ML for experiment tracking and visualization <code>dvc</code> <code>True</code> <code>bool</code> Whether to use DVC for experiment tracking and version control <code>hub</code> <code>True</code> <code>bool</code> Whether to use Ultralytics HUB integration <code>mlflow</code> <code>True</code> <code>bool</code> Whether to use MLFlow for experiment tracking <code>neptune</code> <code>True</code> <code>bool</code> Whether to use Neptune for experiment tracking <code>raytune</code> <code>True</code> <code>bool</code> Whether to use Ray Tune for hyperparameter tuning <code>tensorboard</code> <code>True</code> <code>bool</code> Whether to use TensorBoard for visualization <code>wandb</code> <code>True</code> <code>bool</code> Whether to use Weights &amp; Biases logging <p>As you navigate through your projects or experiments, be sure to revisit these settings to ensure that they are optimally configured for your needs.</p>"},{"location":"datasets/","title":"Datasets Overview","text":"<p>Ultralytics provides support for various datasets to facilitate computer vision tasks such as detection, instance segmentation, pose estimation, classification, and multi-object tracking. Below is a list of the main Ultralytics datasets, followed by a summary of each computer vision task and the respective datasets.</p>"},{"location":"datasets/#new-ultralytics-explorer","title":"\ud83c\udf1f New: Ultralytics Explorer \ud83c\udf1f","text":"<p>Create embeddings for your dataset, search for similar images, run SQL queries, perform semantic search and even search using natural language! You can get started with our GUI app or build your own using the API. Learn more here.</p> <p> </p> <ul> <li>Try the GUI Demo</li> <li>Learn more about the Explorer API</li> </ul>"},{"location":"datasets/#detection-datasets","title":"Detection Datasets","text":"<p>Bounding box object detection is a computer vision technique that involves detecting and localizing objects in an image by drawing a bounding box around each object.</p> <ul> <li>Argoverse: A dataset containing 3D tracking and motion forecasting data from urban environments with rich annotations.</li> <li>COCO: A large-scale dataset designed for object detection, segmentation, and captioning with over 200K labeled images.</li> <li>COCO8: Contains the first 4 images from COCO train and COCO val, suitable for quick tests.</li> <li>Global Wheat 2020: A dataset of wheat head images collected from around the world for object detection and localization tasks.</li> <li>Objects365: A high-quality, large-scale dataset for object detection with 365 object categories and over 600K annotated images.</li> <li>OpenImagesV7: A comprehensive dataset by Google with 1.7M train images and 42k validation images.</li> <li>SKU-110K: A dataset featuring dense object detection in retail environments with over 11K images and 1.7 million bounding boxes.</li> <li>VisDrone: A dataset containing object detection and multi-object tracking data from drone-captured imagery with over 10K images and video sequences.</li> <li>VOC: The Pascal Visual Object Classes (VOC) dataset for object detection and segmentation with 20 object classes and over 11K images.</li> <li>xView: A dataset for object detection in overhead imagery with 60 object categories and over 1 million annotated objects.</li> </ul>"},{"location":"datasets/#instance-segmentation-datasets","title":"Instance Segmentation Datasets","text":"<p>Instance segmentation is a computer vision technique that involves identifying and localizing objects in an image at the pixel level.</p> <ul> <li>COCO: A large-scale dataset designed for object detection, segmentation, and captioning tasks with over 200K labeled images.</li> <li>COCO8-seg: A smaller dataset for instance segmentation tasks, containing a subset of 8 COCO images with segmentation annotations.</li> </ul>"},{"location":"datasets/#pose-estimation","title":"Pose Estimation","text":"<p>Pose estimation is a technique used to determine the pose of the object relative to the camera or the world coordinate system.</p> <ul> <li>COCO: A large-scale dataset with human pose annotations designed for pose estimation tasks.</li> <li>COCO8-pose: A smaller dataset for pose estimation tasks, containing a subset of 8 COCO images with human pose annotations.</li> <li>Tiger-pose: A compact dataset consisting of 263 images focused on tigers, annotated with 12 keypoints per tiger for pose estimation tasks.</li> </ul>"},{"location":"datasets/#classification","title":"Classification","text":"<p>Image classification is a computer vision task that involves categorizing an image into one or more predefined classes or categories based on its visual content.</p> <ul> <li>Caltech 101: A dataset containing images of 101 object categories for image classification tasks.</li> <li>Caltech 256: An extended version of Caltech 101 with 256 object categories and more challenging images.</li> <li>CIFAR-10: A dataset of 60K 32x32 color images in 10 classes, with 6K images per class.</li> <li>CIFAR-100: An extended version of CIFAR-10 with 100 object categories and 600 images per class.</li> <li>Fashion-MNIST: A dataset consisting of 70,000 grayscale images of 10 fashion categories for image classification tasks.</li> <li>ImageNet: A large-scale dataset for object detection and image classification with over 14 million images and 20,000 categories.</li> <li>ImageNet-10: A smaller subset of ImageNet with 10 categories for faster experimentation and testing.</li> <li>Imagenette: A smaller subset of ImageNet that contains 10 easily distinguishable classes for quicker training and testing.</li> <li>Imagewoof: A more challenging subset of ImageNet containing 10 dog breed categories for image classification tasks.</li> <li>MNIST: A dataset of 70,000 grayscale images of handwritten digits for image classification tasks.</li> </ul>"},{"location":"datasets/#oriented-bounding-boxes-obb","title":"Oriented Bounding Boxes (OBB)","text":"<p>Oriented Bounding Boxes (OBB) is a method in computer vision for detecting angled objects in images using rotated bounding boxes, often applied to aerial and satellite imagery.</p> <ul> <li>DOTAv2: A popular OBB aerial imagery dataset with 1.7 million instances and 11,268 images.</li> </ul>"},{"location":"datasets/#multi-object-tracking","title":"Multi-Object Tracking","text":"<p>Multi-object tracking is a computer vision technique that involves detecting and tracking multiple objects over time in a video sequence.</p> <ul> <li>Argoverse: A dataset containing 3D tracking and motion forecasting data from urban environments with rich annotations for multi-object tracking tasks.</li> <li>VisDrone: A dataset containing object detection and multi-object tracking data from drone-captured imagery with over 10K images and video sequences.</li> </ul>"},{"location":"datasets/#contribute-new-datasets","title":"Contribute New Datasets","text":"<p>Contributing a new dataset involves several steps to ensure that it aligns well with the existing infrastructure. Below are the necessary steps:</p>"},{"location":"datasets/#steps-to-contribute-a-new-dataset","title":"Steps to Contribute a New Dataset","text":"<ol> <li> <p>Collect Images: Gather the images that belong to the dataset. These could be collected from various sources, such as public databases or your own collection.</p> </li> <li> <p>Annotate Images: Annotate these images with bounding boxes, segments, or keypoints, depending on the task.</p> </li> <li> <p>Export Annotations: Convert these annotations into the YOLO *.txt file format which Ultralytics supports.</p> </li> <li> <p>Organize Dataset: Arrange your dataset into the correct folder structure. You should have <code>train/</code> and <code>val/</code> top-level directories, and within each, an <code>images/</code> and <code>labels/</code> subdirectory.</p> <pre><code>dataset/\n\u251c\u2500\u2500 train/\n\u2502   \u251c\u2500\u2500 images/\n\u2502   \u2514\u2500\u2500 labels/\n\u2514\u2500\u2500 val/\n    \u251c\u2500\u2500 images/\n    \u2514\u2500\u2500 labels/\n</code></pre> </li> <li> <p>Create a <code>data.yaml</code> File: In your dataset's root directory, create a <code>data.yaml</code> file that describes the dataset, classes, and other necessary information.</p> </li> <li> <p>Optimize Images (Optional): If you want to reduce the size of the dataset for more efficient processing, you can optimize the images using the code below. This is not required, but recommended for smaller dataset sizes and faster download speeds.</p> </li> <li> <p>Zip Dataset: Compress the entire dataset folder into a zip file.</p> </li> <li> <p>Document and PR: Create a documentation page describing your dataset and how it fits into the existing framework. After that, submit a Pull Request (PR). Refer to Ultralytics Contribution Guidelines for more details on how to submit a PR.</p> </li> </ol>"},{"location":"datasets/#example-code-to-optimize-and-zip-a-dataset","title":"Example Code to Optimize and Zip a Dataset","text":"<p>Optimize and Zip a Dataset</p> Python <pre><code>from pathlib import Path\nfrom ultralytics.data.utils import compress_one_image\nfrom ultralytics.utils.downloads import zip_directory\n\n# Define dataset directory\npath = Path('path/to/dataset')\n\n# Optimize images in dataset (optional)\nfor f in path.rglob('*.jpg'):\n    compress_one_image(f)\n\n# Zip dataset into 'path/to/dataset.zip'\nzip_directory(path)\n</code></pre> <p>By following these steps, you can contribute a new dataset that integrates well with Ultralytics' existing structure.</p>"},{"location":"datasets/classify/","title":"Image Classification Datasets Overview","text":""},{"location":"datasets/classify/#dataset-format","title":"Dataset format","text":"<p>The folder structure for classification datasets in torchvision typically follows a standard format:</p> <pre><code>root/\n|-- class1/\n|   |-- img1.jpg\n|   |-- img2.jpg\n|   |-- ...\n|\n|-- class2/\n|   |-- img1.jpg\n|   |-- img2.jpg\n|   |-- ...\n|\n|-- class3/\n|   |-- img1.jpg\n|   |-- img2.jpg\n|   |-- ...\n|\n|-- ...\n</code></pre> <p>In this folder structure, the <code>root</code> directory contains one subdirectory for each class in the dataset. Each subdirectory is named after the corresponding class and contains all the images for that class. Each image file is named uniquely and is typically in a common image file format such as JPEG or PNG.</p> <p>** Example **</p> <p>For example, in the CIFAR10 dataset, the folder structure would look like this:</p> <pre><code>cifar-10-/\n|\n|-- train/\n|   |-- airplane/\n|   |   |-- 10008_airplane.png\n|   |   |-- 10009_airplane.png\n|   |   |-- ...\n|   |\n|   |-- automobile/\n|   |   |-- 1000_automobile.png\n|   |   |-- 1001_automobile.png\n|   |   |-- ...\n|   |\n|   |-- bird/\n|   |   |-- 10014_bird.png\n|   |   |-- 10015_bird.png\n|   |   |-- ...\n|   |\n|   |-- ...\n|\n|-- test/\n|   |-- airplane/\n|   |   |-- 10_airplane.png\n|   |   |-- 11_airplane.png\n|   |   |-- ...\n|   |\n|   |-- automobile/\n|   |   |-- 100_automobile.png\n|   |   |-- 101_automobile.png\n|   |   |-- ...\n|   |\n|   |-- bird/\n|   |   |-- 1000_bird.png\n|   |   |-- 1001_bird.png\n|   |   |-- ...\n|   |\n|   |-- ...\n</code></pre> <p>In this example, the <code>train</code> directory contains subdirectories for each class in the dataset, and each class subdirectory contains all the images for that class. The <code>test</code> directory has a similar structure. The <code>root</code> directory also contains other files that are part of the CIFAR10 dataset.</p>"},{"location":"datasets/classify/#usage","title":"Usage","text":"<p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-cls.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='path/to/dataset', epochs=100, imgsz=640)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\nyolo detect train data=path/to/data model=yolov8n-cls.pt epochs=100 imgsz=640\n</code></pre>"},{"location":"datasets/classify/#supported-datasets","title":"Supported Datasets","text":"<p>Ultralytics supports the following datasets with automatic download:</p> <ul> <li>Caltech 101: A dataset containing images of 101 object categories for image classification tasks.</li> <li>Caltech 256: An extended version of Caltech 101 with 256 object categories and more challenging images.</li> <li>CIFAR-10: A dataset of 60K 32x32 color images in 10 classes, with 6K images per class.</li> <li>CIFAR-100: An extended version of CIFAR-10 with 100 object categories and 600 images per class.</li> <li>Fashion-MNIST: A dataset consisting of 70,000 grayscale images of 10 fashion categories for image classification tasks.</li> <li>ImageNet: A large-scale dataset for object detection and image classification with over 14 million images and 20,000 categories.</li> <li>ImageNet-10: A smaller subset of ImageNet with 10 categories for faster experimentation and testing.</li> <li>Imagenette: A smaller subset of ImageNet that contains 10 easily distinguishable classes for quicker training and testing.</li> <li>Imagewoof: A more challenging subset of ImageNet containing 10 dog breed categories for image classification tasks.</li> <li>MNIST: A dataset of 70,000 grayscale images of handwritten digits for image classification tasks.</li> </ul>"},{"location":"datasets/classify/#adding-your-own-dataset","title":"Adding your own dataset","text":"<p>If you have your own dataset and would like to use it for training classification models with Ultralytics, ensure that it follows the format specified above under \"Dataset format\" and then point your <code>data</code> argument to the dataset directory.</p>"},{"location":"datasets/classify/caltech101/","title":"Caltech-101 Dataset","text":"<p>The Caltech-101 dataset is a widely used dataset for object recognition tasks, containing around 9,000 images from 101 object categories. The categories were chosen to reflect a variety of real-world objects, and the images themselves were carefully selected and annotated to provide a challenging benchmark for object recognition algorithms.</p>"},{"location":"datasets/classify/caltech101/#key-features","title":"Key Features","text":"<ul> <li>The Caltech-101 dataset comprises around 9,000 color images divided into 101 categories.</li> <li>The categories encompass a wide variety of objects, including animals, vehicles, household items, and people.</li> <li>The number of images per category varies, with about 40 to 800 images in each category.</li> <li>Images are of variable sizes, with most images being medium resolution.</li> <li>Caltech-101 is widely used for training and testing in the field of machine learning, particularly for object recognition tasks.</li> </ul>"},{"location":"datasets/classify/caltech101/#dataset-structure","title":"Dataset Structure","text":"<p>Unlike many other datasets, the Caltech-101 dataset is not formally split into training and testing sets. Users typically create their own splits based on their specific needs. However, a common practice is to use a random subset of images for training (e.g., 30 images per category) and the remaining images for testing.</p>"},{"location":"datasets/classify/caltech101/#applications","title":"Applications","text":"<p>The Caltech-101 dataset is extensively used for training and evaluating deep learning models in object recognition tasks, such as Convolutional Neural Networks (CNNs), Support Vector Machines (SVMs), and various other machine learning algorithms. Its wide variety of categories and high-quality images make it an excellent dataset for research and development in the field of machine learning and computer vision.</p>"},{"location":"datasets/classify/caltech101/#usage","title":"Usage","text":"<p>To train a YOLO model on the Caltech-101 dataset for 100 epochs, you can use the following code snippets. For a comprehensive list of available arguments, refer to the model Training page.</p> <p>Train Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-cls.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='caltech101', epochs=100, imgsz=416)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\nyolo detect train data=caltech101 model=yolov8n-cls.pt epochs=100 imgsz=416\n</code></pre>"},{"location":"datasets/classify/caltech101/#sample-images-and-annotations","title":"Sample Images and Annotations","text":"<p>The Caltech-101 dataset contains high-quality color images of various objects, providing a well-structured dataset for object recognition tasks. Here are some examples of images from the dataset:</p> <p></p> <p>The example showcases the variety and complexity of the objects in the Caltech-101 dataset, emphasizing the significance of a diverse dataset for training robust object recognition models.</p>"},{"location":"datasets/classify/caltech101/#citations-and-acknowledgments","title":"Citations and Acknowledgments","text":"<p>If you use the Caltech-101 dataset in your research or development work, please cite the following paper:</p> BibTeX <pre><code>@article{fei2007learning,\n  title={Learning generative visual models from few training examples: An incremental Bayesian approach tested on 101 object categories},\n  author={Fei-Fei, Li and Fergus, Rob and Perona, Pietro},\n  journal={Computer vision and Image understanding},\n  volume={106},\n  number={1},\n  pages={59--70},\n  year={2007},\n  publisher={Elsevier}\n}\n</code></pre> <p>We would like to acknowledge Li Fei-Fei, Rob Fergus, and Pietro Perona for creating and maintaining the Caltech-101 dataset as a valuable resource for the machine learning and computer vision research community. For more information about the Caltech-101 dataset and its creators, visit the Caltech-101 dataset website.</p>"},{"location":"datasets/classify/caltech256/","title":"Caltech-256 Dataset","text":"<p>The Caltech-256 dataset is an extensive collection of images used for object classification tasks. It contains around 30,000 images divided into 257 categories (256 object categories and 1 background category). The images are carefully curated and annotated to provide a challenging and diverse benchmark for object recognition algorithms.</p>"},{"location":"datasets/classify/caltech256/#key-features","title":"Key Features","text":"<ul> <li>The Caltech-256 dataset comprises around 30,000 color images divided into 257 categories.</li> <li>Each category contains a minimum of 80 images.</li> <li>The categories encompass a wide variety of real-world objects, including animals, vehicles, household items, and people.</li> <li>Images are of variable sizes and resolutions.</li> <li>Caltech-256 is widely used for training and testing in the field of machine learning, particularly for object recognition tasks.</li> </ul>"},{"location":"datasets/classify/caltech256/#dataset-structure","title":"Dataset Structure","text":"<p>Like Caltech-101, the Caltech-256 dataset does not have a formal split between training and testing sets. Users typically create their own splits according to their specific needs. A common practice is to use a random subset of images for training and the remaining images for testing.</p>"},{"location":"datasets/classify/caltech256/#applications","title":"Applications","text":"<p>The Caltech-256 dataset is extensively used for training and evaluating deep learning models in object recognition tasks, such as Convolutional Neural Networks (CNNs), Support Vector Machines (SVMs), and various other machine learning algorithms. Its diverse set of categories and high-quality images make it an invaluable dataset for research and development in the field of machine learning and computer vision.</p>"},{"location":"datasets/classify/caltech256/#usage","title":"Usage","text":"<p>To train a YOLO model on the Caltech-256 dataset for 100 epochs, you can use the following code snippets. For a comprehensive list of available arguments, refer to the model Training page.</p> <p>Train Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-cls.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='caltech256', epochs=100, imgsz=416)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\nyolo detect train data=caltech256 model=yolov8n-cls.pt epochs=100 imgsz=416\n</code></pre>"},{"location":"datasets/classify/caltech256/#sample-images-and-annotations","title":"Sample Images and Annotations","text":"<p>The Caltech-256 dataset contains high-quality color images of various objects, providing a comprehensive dataset for object recognition tasks. Here are some examples of images from the dataset (credit):</p> <p></p> <p>The example showcases the diversity and complexity of the objects in the Caltech-256 dataset, emphasizing the importance of a varied dataset for training robust object recognition models.</p>"},{"location":"datasets/classify/caltech256/#citations-and-acknowledgments","title":"Citations and Acknowledgments","text":"<p>If you use the Caltech-256 dataset in your research or development work, please cite the following paper:</p> BibTeX <pre><code>@article{griffin2007caltech,\n         title={Caltech-256 object category dataset},\n         author={Griffin, Gregory and Holub, Alex and Perona, Pietro},\n         year={2007}\n}\n</code></pre> <p>We would like to acknowledge Gregory Griffin, Alex Holub, and Pietro Perona for creating and maintaining the Caltech-256 dataset as a valuable resource for the machine learning and computer vision research community. For more information about the</p> <p>Caltech-256 dataset and its creators, visit the Caltech-256 dataset website.</p>"},{"location":"datasets/classify/cifar10/","title":"CIFAR-10 Dataset","text":"<p>The CIFAR-10 (Canadian Institute For Advanced Research) dataset is a collection of images used widely for machine learning and computer vision algorithms. It was developed by researchers at the CIFAR institute and consists of 60,000 32x32 color images in 10 different classes.</p>"},{"location":"datasets/classify/cifar10/#key-features","title":"Key Features","text":"<ul> <li>The CIFAR-10 dataset consists of 60,000 images, divided into 10 classes.</li> <li>Each class contains 6,000 images, split into 5,000 for training and 1,000 for testing.</li> <li>The images are colored and of size 32x32 pixels.</li> <li>The 10 different classes represent airplanes, cars, birds, cats, deer, dogs, frogs, horses, ships, and trucks.</li> <li>CIFAR-10 is commonly used for training and testing in the field of machine learning and computer vision.</li> </ul>"},{"location":"datasets/classify/cifar10/#dataset-structure","title":"Dataset Structure","text":"<p>The CIFAR-10 dataset is split into two subsets:</p> <ol> <li>Training Set: This subset contains 50,000 images used for training machine learning models.</li> <li>Testing Set: This subset consists of 10,000 images used for testing and benchmarking the trained models.</li> </ol>"},{"location":"datasets/classify/cifar10/#applications","title":"Applications","text":"<p>The CIFAR-10 dataset is widely used for training and evaluating deep learning models in image classification tasks, such as Convolutional Neural Networks (CNNs), Support Vector Machines (SVMs), and various other machine learning algorithms. The diversity of the dataset in terms of classes and the presence of color images make it a well-rounded dataset for research and development in the field of machine learning and computer vision.</p>"},{"location":"datasets/classify/cifar10/#usage","title":"Usage","text":"<p>To train a YOLO model on the CIFAR-10 dataset for 100 epochs with an image size of 32x32, you can use the following code snippets. For a comprehensive list of available arguments, refer to the model Training page.</p> <p>Train Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-cls.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='cifar10', epochs=100, imgsz=32)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\nyolo detect train data=cifar10 model=yolov8n-cls.pt epochs=100 imgsz=32\n</code></pre>"},{"location":"datasets/classify/cifar10/#sample-images-and-annotations","title":"Sample Images and Annotations","text":"<p>The CIFAR-10 dataset contains color images of various objects, providing a well-structured dataset for image classification tasks. Here are some examples of images from the dataset:</p> <p></p> <p>The example showcases the variety and complexity of the objects in the CIFAR-10 dataset, highlighting the importance of a diverse dataset for training robust image classification models.</p>"},{"location":"datasets/classify/cifar10/#citations-and-acknowledgments","title":"Citations and Acknowledgments","text":"<p>If you use the CIFAR-10 dataset in your research or development work, please cite the following paper:</p> BibTeX <pre><code>@TECHREPORT{Krizhevsky09learningmultiple,\n            author={Alex Krizhevsky},\n            title={Learning multiple layers of features from tiny images},\n            institution={},\n            year={2009}\n}\n</code></pre> <p>We would like to acknowledge Alex Krizhevsky for creating and maintaining the CIFAR-10 dataset as a valuable resource for the machine learning and computer vision research community. For more information about the CIFAR-10 dataset and its creator, visit the CIFAR-10 dataset website.</p>"},{"location":"datasets/classify/cifar100/","title":"CIFAR-100 Dataset","text":"<p>The CIFAR-100 (Canadian Institute For Advanced Research) dataset is a significant extension of the CIFAR-10 dataset, composed of 60,000 32x32 color images in 100 different classes. It was developed by researchers at the CIFAR institute, offering a more challenging dataset for more complex machine learning and computer vision tasks.</p>"},{"location":"datasets/classify/cifar100/#key-features","title":"Key Features","text":"<ul> <li>The CIFAR-100 dataset consists of 60,000 images, divided into 100 classes.</li> <li>Each class contains 600 images, split into 500 for training and 100 for testing.</li> <li>The images are colored and of size 32x32 pixels.</li> <li>The 100 different classes are grouped into 20 coarse categories for higher level classification.</li> <li>CIFAR-100 is commonly used for training and testing in the field of machine learning and computer vision.</li> </ul>"},{"location":"datasets/classify/cifar100/#dataset-structure","title":"Dataset Structure","text":"<p>The CIFAR-100 dataset is split into two subsets:</p> <ol> <li>Training Set: This subset contains 50,000 images used for training machine learning models.</li> <li>Testing Set: This subset consists of 10,000 images used for testing and benchmarking the trained models.</li> </ol>"},{"location":"datasets/classify/cifar100/#applications","title":"Applications","text":"<p>The CIFAR-100 dataset is extensively used for training and evaluating deep learning models in image classification tasks, such as Convolutional Neural Networks (CNNs), Support Vector Machines (SVMs), and various other machine learning algorithms. The diversity of the dataset in terms of classes and the presence of color images make it a more challenging and comprehensive dataset for research and development in the field of machine learning and computer vision.</p>"},{"location":"datasets/classify/cifar100/#usage","title":"Usage","text":"<p>To train a YOLO model on the CIFAR-100 dataset for 100 epochs with an image size of 32x32, you can use the following code snippets. For a comprehensive list of available arguments, refer to the model Training page.</p> <p>Train Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-cls.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='cifar100', epochs=100, imgsz=32)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\nyolo detect train data=cifar100 model=yolov8n-cls.pt epochs=100 imgsz=32\n</code></pre>"},{"location":"datasets/classify/cifar100/#sample-images-and-annotations","title":"Sample Images and Annotations","text":"<p>The CIFAR-100 dataset contains color images of various objects, providing a well-structured dataset for image classification tasks. Here are some examples of images from the dataset:</p> <p></p> <p>The example showcases the variety and complexity of the objects in the CIFAR-100 dataset, highlighting the importance of a diverse dataset for training robust image classification models.</p>"},{"location":"datasets/classify/cifar100/#citations-and-acknowledgments","title":"Citations and Acknowledgments","text":"<p>If you use the CIFAR-100 dataset in your research or development work, please cite the following paper:</p> BibTeX <pre><code>@TECHREPORT{Krizhevsky09learningmultiple,\n            author={Alex Krizhevsky},\n            title={Learning multiple layers of features from tiny images},\n            institution={},\n            year={2009}\n}\n</code></pre> <p>We would like to acknowledge Alex Krizhevsky for creating and maintaining the CIFAR-100 dataset as a valuable resource for the machine learning and computer vision research community. For more information about the CIFAR-100 dataset and its creator, visit the CIFAR-100 dataset website.</p>"},{"location":"datasets/classify/fashion-mnist/","title":"Fashion-MNIST Dataset","text":"<p>The Fashion-MNIST dataset is a database of Zalando's article images\u2014consisting of a training set of 60,000 examples and a test set of 10,000 examples. Each example is a 28x28 grayscale image, associated with a label from 10 classes. Fashion-MNIST is intended to serve as a direct drop-in replacement for the original MNIST dataset for benchmarking machine learning algorithms.</p>"},{"location":"datasets/classify/fashion-mnist/#key-features","title":"Key Features","text":"<ul> <li>Fashion-MNIST contains 60,000 training images and 10,000 testing images of Zalando's article images.</li> <li>The dataset comprises grayscale images of size 28x28 pixels.</li> <li>Each pixel has a single pixel-value associated with it, indicating the lightness or darkness of that pixel, with higher numbers meaning darker. This pixel-value is an integer between 0 and 255.</li> <li>Fashion-MNIST is widely used for training and testing in the field of machine learning, especially for image classification tasks.</li> </ul>"},{"location":"datasets/classify/fashion-mnist/#dataset-structure","title":"Dataset Structure","text":"<p>The Fashion-MNIST dataset is split into two subsets:</p> <ol> <li>Training Set: This subset contains 60,000 images used for training machine learning models.</li> <li>Testing Set: This subset consists of 10,000 images used for testing and benchmarking the trained models.</li> </ol>"},{"location":"datasets/classify/fashion-mnist/#labels","title":"Labels","text":"<p>Each training and test example is assigned to one of the following labels:</p> <ol> <li>T-shirt/top</li> <li>Trouser</li> <li>Pullover</li> <li>Dress</li> <li>Coat</li> <li>Sandal</li> <li>Shirt</li> <li>Sneaker</li> <li>Bag</li> <li>Ankle boot</li> </ol>"},{"location":"datasets/classify/fashion-mnist/#applications","title":"Applications","text":"<p>The Fashion-MNIST dataset is widely used for training and evaluating deep learning models in image classification tasks, such as Convolutional Neural Networks (CNNs), Support Vector Machines (SVMs), and various other machine learning algorithms. The dataset's simple and well-structured format makes it an essential resource for researchers and practitioners in the field of machine learning and computer vision.</p>"},{"location":"datasets/classify/fashion-mnist/#usage","title":"Usage","text":"<p>To train a CNN model on the Fashion-MNIST dataset for 100 epochs with an image size of 28x28, you can use the following code snippets. For a comprehensive list of available arguments, refer to the model Training page.</p> <p>Train Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-cls.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='fashion-mnist', epochs=100, imgsz=28)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\nyolo detect train data=fashion-mnist model=yolov8n-cls.pt epochs=100 imgsz=28\n</code></pre>"},{"location":"datasets/classify/fashion-mnist/#sample-images-and-annotations","title":"Sample Images and Annotations","text":"<p>The Fashion-MNIST dataset contains grayscale images of Zalando's article images, providing a well-structured dataset for image classification tasks. Here are some examples of images from the dataset:</p> <p></p> <p>The example showcases the variety and complexity of the images in the Fashion-MNIST dataset, highlighting the importance of a diverse dataset for training robust image classification models.</p>"},{"location":"datasets/classify/fashion-mnist/#acknowledgments","title":"Acknowledgments","text":"<p>If you use the Fashion-MNIST dataset in your research or development work, please acknowledge the dataset by linking to the GitHub repository. This dataset was made available by Zalando Research.</p>"},{"location":"datasets/classify/imagenet/","title":"ImageNet Dataset","text":"<p>ImageNet is a large-scale database of annotated images designed for use in visual object recognition research. It contains over 14 million images, with each image annotated using WordNet synsets, making it one of the most extensive resources available for training deep learning models in computer vision tasks.</p>"},{"location":"datasets/classify/imagenet/#key-features","title":"Key Features","text":"<ul> <li>ImageNet contains over 14 million high-resolution images spanning thousands of object categories.</li> <li>The dataset is organized according to the WordNet hierarchy, with each synset representing a category.</li> <li>ImageNet is widely used for training and benchmarking in the field of computer vision, particularly for image classification and object detection tasks.</li> <li>The annual ImageNet Large Scale Visual Recognition Challenge (ILSVRC) has been instrumental in advancing computer vision research.</li> </ul>"},{"location":"datasets/classify/imagenet/#dataset-structure","title":"Dataset Structure","text":"<p>The ImageNet dataset is organized using the WordNet hierarchy. Each node in the hierarchy represents a category, and each category is described by a synset (a collection of synonymous terms). The images in ImageNet are annotated with one or more synsets, providing a rich resource for training models to recognize various objects and their relationships.</p>"},{"location":"datasets/classify/imagenet/#imagenet-large-scale-visual-recognition-challenge-ilsvrc","title":"ImageNet Large Scale Visual Recognition Challenge (ILSVRC)","text":"<p>The annual ImageNet Large Scale Visual Recognition Challenge (ILSVRC) has been an important event in the field of computer vision. It has provided a platform for researchers and developers to evaluate their algorithms and models on a large-scale dataset with standardized evaluation metrics. The ILSVRC has led to significant advancements in the development of deep learning models for image classification, object detection, and other computer vision tasks.</p>"},{"location":"datasets/classify/imagenet/#applications","title":"Applications","text":"<p>The ImageNet dataset is widely used for training and evaluating deep learning models in various computer vision tasks, such as image classification, object detection, and object localization. Some popular deep learning architectures, such as AlexNet, VGG, and ResNet, were developed and benchmarked using the ImageNet dataset.</p>"},{"location":"datasets/classify/imagenet/#usage","title":"Usage","text":"<p>To train a deep learning model on the ImageNet dataset for 100 epochs with an image size of 224x224, you can use the following code snippets. For a comprehensive list of available arguments, refer to the model Training page.</p> <p>Train Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-cls.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='imagenet', epochs=100, imgsz=224)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\nyolo train data=imagenet model=yolov8n-cls.pt epochs=100 imgsz=224\n</code></pre>"},{"location":"datasets/classify/imagenet/#sample-images-and-annotations","title":"Sample Images and Annotations","text":"<p>The ImageNet dataset contains high-resolution images spanning thousands of object categories, providing a diverse and extensive dataset for training and evaluating computer vision models. Here are some examples of images from the dataset:</p> <p></p> <p>The example showcases the variety and complexity of the images in the ImageNet dataset, highlighting the importance of a diverse dataset for training robust computer vision models.</p>"},{"location":"datasets/classify/imagenet/#citations-and-acknowledgments","title":"Citations and Acknowledgments","text":"<p>If you use the ImageNet dataset in your research or development work, please cite the following paper:</p> BibTeX <pre><code>@article{ILSVRC15,\n         author = {Olga Russakovsky and Jia Deng and Hao Su and Jonathan Krause and Sanjeev Satheesh and Sean Ma and Zhiheng Huang and Andrej Karpathy and Aditya Khosla and Michael Bernstein and Alexander C. Berg and Li Fei-Fei},\n         title={ImageNet Large Scale Visual Recognition Challenge},\n         year={2015},\n         journal={International Journal of Computer Vision (IJCV)},\n         volume={115},\n         number={3},\n         pages={211-252}\n}\n</code></pre> <p>We would like to acknowledge the ImageNet team, led by Olga Russakovsky, Jia Deng, and Li Fei-Fei, for creating and maintaining the ImageNet dataset as a valuable resource for the machine learning and computer vision research community. For more information about the ImageNet dataset and its creators, visit the ImageNet website.</p>"},{"location":"datasets/classify/imagenet10/","title":"ImageNet10 Dataset","text":"<p>The ImageNet10 dataset is a small-scale subset of the ImageNet database, developed by Ultralytics and designed for CI tests, sanity checks, and fast testing of training pipelines. This dataset is composed of the first image in the training set and the first image from the validation set of the first 10 classes in ImageNet. Although significantly smaller, it retains the structure and diversity of the original ImageNet dataset.</p>"},{"location":"datasets/classify/imagenet10/#key-features","title":"Key Features","text":"<ul> <li>ImageNet10 is a compact version of ImageNet, with 20 images representing the first 10 classes of the original dataset.</li> <li>The dataset is organized according to the WordNet hierarchy, mirroring the structure of the full ImageNet dataset.</li> <li>It is ideally suited for CI tests, sanity checks, and rapid testing of training pipelines in computer vision tasks.</li> <li>Although not designed for model benchmarking, it can provide a quick indication of a model's basic functionality and correctness.</li> </ul>"},{"location":"datasets/classify/imagenet10/#dataset-structure","title":"Dataset Structure","text":"<p>The ImageNet10 dataset, like the original ImageNet, is organized using the WordNet hierarchy. Each of the 10 classes in ImageNet10 is described by a synset (a collection of synonymous terms). The images in ImageNet10 are annotated with one or more synsets, providing a compact resource for testing models to recognize various objects and their relationships.</p>"},{"location":"datasets/classify/imagenet10/#applications","title":"Applications","text":"<p>The ImageNet10 dataset is useful for quickly testing and debugging computer vision models and pipelines. Its small size allows for rapid iteration, making it ideal for continuous integration tests and sanity checks. It can also be used for fast preliminary testing of new models or changes to existing models before moving on to full-scale testing with the complete ImageNet dataset.</p>"},{"location":"datasets/classify/imagenet10/#usage","title":"Usage","text":"<p>To test a deep learning model on the ImageNet10 dataset with an image size of 224x224, you can use the following code snippets. For a comprehensive list of available arguments, refer to the model Training page.</p> <p>Test Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-cls.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='imagenet10', epochs=5, imgsz=224)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\nyolo train data=imagenet10 model=yolov8n-cls.pt epochs=5 imgsz=224\n</code></pre>"},{"location":"datasets/classify/imagenet10/#sample-images-and-annotations","title":"Sample Images and Annotations","text":"<p>The ImageNet10 dataset contains a subset of images from the original ImageNet dataset. These images are chosen to represent the first 10 classes in the dataset, providing a diverse yet compact dataset for quick testing and evaluation.</p> <p> The example showcases the variety and complexity of the images in the ImageNet10 dataset, highlighting its usefulness for sanity checks and quick testing of computer vision models.</p>"},{"location":"datasets/classify/imagenet10/#citations-and-acknowledgments","title":"Citations and Acknowledgments","text":"<p>If you use the ImageNet10 dataset in your research or development work, please cite the original ImageNet paper:</p> BibTeX <pre><code>@article{ILSVRC15,\n         author = {Olga Russakovsky and Jia Deng and Hao Su and Jonathan Krause and Sanjeev Satheesh and Sean Ma and Zhiheng Huang and Andrej Karpathy and Aditya Khosla and Michael Bernstein and Alexander C. Berg and Li Fei-Fei},\n         title={ImageNet Large Scale Visual Recognition Challenge},\n         year={2015},\n         journal={International Journal of Computer Vision (IJCV)},\n         volume={115},\n         number={3},\n         pages={211-252}\n}\n</code></pre> <p>We would like to acknowledge the ImageNet team, led by Olga Russakovsky, Jia Deng, and Li Fei-Fei, for creating and maintaining the ImageNet dataset. The ImageNet10 dataset, while a compact subset, is a valuable resource for quick testing and debugging in the machine learning and computer vision research community. For more information about the ImageNet dataset and its creators, visit the ImageNet website.</p>"},{"location":"datasets/classify/imagenette/","title":"ImageNette Dataset","text":"<p>The ImageNette dataset is a subset of the larger Imagenet dataset, but it only includes 10 easily distinguishable classes. It was created to provide a quicker, easier-to-use version of Imagenet for software development and education.</p>"},{"location":"datasets/classify/imagenette/#key-features","title":"Key Features","text":"<ul> <li>ImageNette contains images from 10 different classes such as tench, English springer, cassette player, chain saw, church, French horn, garbage truck, gas pump, golf ball, parachute.</li> <li>The dataset comprises colored images of varying dimensions.</li> <li>ImageNette is widely used for training and testing in the field of machine learning, especially for image classification tasks.</li> </ul>"},{"location":"datasets/classify/imagenette/#dataset-structure","title":"Dataset Structure","text":"<p>The ImageNette dataset is split into two subsets:</p> <ol> <li>Training Set: This subset contains several thousands of images used for training machine learning models. The exact number varies per class.</li> <li>Validation Set: This subset consists of several hundreds of images used for validating and benchmarking the trained models. Again, the exact number varies per class.</li> </ol>"},{"location":"datasets/classify/imagenette/#applications","title":"Applications","text":"<p>The ImageNette dataset is widely used for training and evaluating deep learning models in image classification tasks, such as Convolutional Neural Networks (CNNs), and various other machine learning algorithms. The dataset's straightforward format and well-chosen classes make it a handy resource for both beginner and experienced practitioners in the field of machine learning and computer vision.</p>"},{"location":"datasets/classify/imagenette/#usage","title":"Usage","text":"<p>To train a model on the ImageNette dataset for 100 epochs with a standard image size of 224x224, you can use the following code snippets. For a comprehensive list of available arguments, refer to the model Training page.</p> <p>Train Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-cls.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='imagenette', epochs=100, imgsz=224)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\nyolo detect train data=imagenette model=yolov8n-cls.pt epochs=100 imgsz=224\n</code></pre>"},{"location":"datasets/classify/imagenette/#sample-images-and-annotations","title":"Sample Images and Annotations","text":"<p>The ImageNette dataset contains colored images of various objects and scenes, providing a diverse dataset for image classification tasks. Here are some examples of images from the dataset:</p> <p></p> <p>The example showcases the variety and complexity of the images in the ImageNette dataset, highlighting the importance of a diverse dataset for training robust image classification models.</p>"},{"location":"datasets/classify/imagenette/#imagenette160-and-imagenette320","title":"ImageNette160 and ImageNette320","text":"<p>For faster prototyping and training, the ImageNette dataset is also available in two reduced sizes: ImageNette160 and ImageNette320. These datasets maintain the same classes and structure as the full ImageNette dataset, but the images are resized to a smaller dimension. As such, these versions of the dataset are particularly useful for preliminary model testing, or when computational resources are limited.</p> <p>To use these datasets, simply replace 'imagenette' with 'imagenette160' or 'imagenette320' in the training command. The following code snippets illustrate this:</p> <p>Train Example with ImageNette160</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-cls.pt')  # load a pretrained model (recommended for training)\n\n# Train the model with ImageNette160\nresults = model.train(data='imagenette160', epochs=100, imgsz=160)\n</code></pre> <pre><code># Start training from a pretrained *.pt model with ImageNette160\nyolo detect train data=imagenette160 model=yolov8n-cls.pt epochs=100 imgsz=160\n</code></pre> <p>Train Example with ImageNette320</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-cls.pt')  # load a pretrained model (recommended for training)\n\n# Train the model with ImageNette320\nresults = model.train(data='imagenette320', epochs=100, imgsz=320)\n</code></pre> <pre><code># Start training from a pretrained *.pt model with ImageNette320\nyolo detect train data=imagenette320 model=yolov8n-cls.pt epochs=100 imgsz=320\n</code></pre> <p>These smaller versions of the dataset allow for rapid iterations during the development process while still providing valuable and realistic image classification tasks.</p>"},{"location":"datasets/classify/imagenette/#citations-and-acknowledgments","title":"Citations and Acknowledgments","text":"<p>If you use the ImageNette dataset in your research or development work, please acknowledge it appropriately. For more information about the ImageNette dataset, visit the ImageNette dataset GitHub page.</p>"},{"location":"datasets/classify/imagewoof/","title":"ImageWoof Dataset","text":"<p>The ImageWoof dataset is a subset of the ImageNet consisting of 10 classes that are challenging to classify, since they're all dog breeds. It was created as a more difficult task for image classification algorithms to solve, aiming at encouraging development of more advanced models.</p>"},{"location":"datasets/classify/imagewoof/#key-features","title":"Key Features","text":"<ul> <li>ImageWoof contains images of 10 different dog breeds: Australian terrier, Border terrier, Samoyed, Beagle, Shih-Tzu, English foxhound, Rhodesian ridgeback, Dingo, Golden retriever, and Old English sheepdog.</li> <li>The dataset provides images at various resolutions (full size, 320px, 160px), accommodating for different computational capabilities and research needs.</li> <li>It also includes a version with noisy labels, providing a more realistic scenario where labels might not always be reliable.</li> </ul>"},{"location":"datasets/classify/imagewoof/#dataset-structure","title":"Dataset Structure","text":"<p>The ImageWoof dataset structure is based on the dog breed classes, with each breed having its own directory of images.</p>"},{"location":"datasets/classify/imagewoof/#applications","title":"Applications","text":"<p>The ImageWoof dataset is widely used for training and evaluating deep learning models in image classification tasks, especially when it comes to more complex and similar classes. The dataset's challenge lies in the subtle differences between the dog breeds, pushing the limits of model's performance and generalization.</p>"},{"location":"datasets/classify/imagewoof/#usage","title":"Usage","text":"<p>To train a CNN model on the ImageWoof dataset for 100 epochs with an image size of 224x224, you can use the following code snippets. For a comprehensive list of available arguments, refer to the model Training page.</p> <p>Train Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-cls.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='imagewoof', epochs=100, imgsz=224)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\nyolo detect train data=imagewoof model=yolov8n-cls.pt epochs=100 imgsz=224\n</code></pre>"},{"location":"datasets/classify/imagewoof/#dataset-variants","title":"Dataset Variants","text":"<p>ImageWoof dataset comes in three different sizes to accommodate various research needs and computational capabilities:</p> <ol> <li> <p>Full Size (imagewoof): This is the original version of the ImageWoof dataset. It contains full-sized images and is ideal for final training and performance benchmarking.</p> </li> <li> <p>Medium Size (imagewoof320): This version contains images resized to have a maximum edge length of 320 pixels. It's suitable for faster training without significantly sacrificing model performance.</p> </li> <li> <p>Small Size (imagewoof160): This version contains images resized to have a maximum edge length of 160 pixels. It's designed for rapid prototyping and experimentation where training speed is a priority.</p> </li> </ol> <p>To use these variants in your training, simply replace 'imagewoof' in the dataset argument with 'imagewoof320' or 'imagewoof160'. For example:</p> <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-cls.pt')  # load a pretrained model (recommended for training)\n\n# For medium-sized dataset\nmodel.train(data='imagewoof320', epochs=100, imgsz=224)\n\n# For small-sized dataset\nmodel.train(data='imagewoof160', epochs=100, imgsz=224)\n</code></pre> <p>It's important to note that using smaller images will likely yield lower performance in terms of classification accuracy. However, it's an excellent way to iterate quickly in the early stages of model development and prototyping.</p>"},{"location":"datasets/classify/imagewoof/#sample-images-and-annotations","title":"Sample Images and Annotations","text":"<p>The ImageWoof dataset contains colorful images of various dog breeds, providing a challenging dataset for image classification tasks. Here are some examples of images from the dataset:</p> <p></p> <p>The example showcases the subtle differences and similarities among the different dog breeds in the ImageWoof dataset, highlighting the complexity and difficulty of the classification task.</p>"},{"location":"datasets/classify/imagewoof/#citations-and-acknowledgments","title":"Citations and Acknowledgments","text":"<p>If you use the ImageWoof dataset in your research or development work, please make sure to acknowledge the creators of the dataset by linking to the official dataset repository.</p> <p>We would like to acknowledge the FastAI team for creating and maintaining the ImageWoof dataset as a valuable resource for the machine learning and computer vision research community. For more information about the ImageWoof dataset, visit the ImageWoof dataset repository.</p>"},{"location":"datasets/classify/mnist/","title":"MNIST Dataset","text":"<p>The MNIST (Modified National Institute of Standards and Technology) dataset is a large database of handwritten digits that is commonly used for training various image processing systems and machine learning models. It was created by \"re-mixing\" the samples from NIST's original datasets and has become a benchmark for evaluating the performance of image classification algorithms.</p>"},{"location":"datasets/classify/mnist/#key-features","title":"Key Features","text":"<ul> <li>MNIST contains 60,000 training images and 10,000 testing images of handwritten digits.</li> <li>The dataset comprises grayscale images of size 28x28 pixels.</li> <li>The images are normalized to fit into a 28x28 pixel bounding box and anti-aliased, introducing grayscale levels.</li> <li>MNIST is widely used for training and testing in the field of machine learning, especially for image classification tasks.</li> </ul>"},{"location":"datasets/classify/mnist/#dataset-structure","title":"Dataset Structure","text":"<p>The MNIST dataset is split into two subsets:</p> <ol> <li>Training Set: This subset contains 60,000 images of handwritten digits used for training machine learning models.</li> <li>Testing Set: This subset consists of 10,000 images used for testing and benchmarking the trained models.</li> </ol>"},{"location":"datasets/classify/mnist/#extended-mnist-emnist","title":"Extended MNIST (EMNIST)","text":"<p>Extended MNIST (EMNIST) is a newer dataset developed and released by NIST to be the successor to MNIST. While MNIST included images only of handwritten digits, EMNIST includes all the images from NIST Special Database 19, which is a large database of handwritten uppercase and lowercase letters as well as digits. The images in EMNIST were converted into the same 28x28 pixel format, by the same process, as were the MNIST images. Accordingly, tools that work with the older, smaller MNIST dataset will likely work unmodified with EMNIST.</p>"},{"location":"datasets/classify/mnist/#applications","title":"Applications","text":"<p>The MNIST dataset is widely used for training and evaluating deep learning models in image classification tasks, such as Convolutional Neural Networks (CNNs), Support Vector Machines (SVMs), and various other machine learning algorithms. The dataset's simple and well-structured format makes it an essential resource for researchers and practitioners in the field of machine learning and computer vision.</p>"},{"location":"datasets/classify/mnist/#usage","title":"Usage","text":"<p>To train a CNN model on the MNIST dataset for 100 epochs with an image size of 32x32, you can use the following code snippets. For a comprehensive list of available arguments, refer to the model Training page.</p> <p>Train Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-cls.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='mnist', epochs=100, imgsz=32)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\ncnn detect train data=mnist model=yolov8n-cls.pt epochs=100 imgsz=28\n</code></pre>"},{"location":"datasets/classify/mnist/#sample-images-and-annotations","title":"Sample Images and Annotations","text":"<p>The MNIST dataset contains grayscale images of handwritten digits, providing a well-structured dataset for image classification tasks. Here are some examples of images from the dataset:</p> <p></p> <p>The example showcases the variety and complexity of the handwritten digits in the MNIST dataset, highlighting the importance of a diverse dataset for training robust image classification models.</p>"},{"location":"datasets/classify/mnist/#citations-and-acknowledgments","title":"Citations and Acknowledgments","text":"<p>If you use the MNIST dataset in your</p> <p>research or development work, please cite the following paper:</p> BibTeX <pre><code>@article{lecun2010mnist,\n         title={MNIST handwritten digit database},\n         author={LeCun, Yann and Cortes, Corinna and Burges, CJ},\n         journal={ATT Labs [Online]. Available: http://yann.lecun.com/exdb/mnist},\n         volume={2},\n         year={2010}\n}\n</code></pre> <p>We would like to acknowledge Yann LeCun, Corinna Cortes, and Christopher J.C. Burges for creating and maintaining the MNIST dataset as a valuable resource for the machine learning and computer vision research community. For more information about the MNIST dataset and its creators, visit the MNIST dataset website.</p>"},{"location":"datasets/detect/","title":"Object Detection Datasets Overview","text":"<p>Training a robust and accurate object detection model requires a comprehensive dataset. This guide introduces various formats of datasets that are compatible with the Ultralytics YOLO model and provides insights into their structure, usage, and how to convert between different formats.</p>"},{"location":"datasets/detect/#supported-dataset-formats","title":"Supported Dataset Formats","text":""},{"location":"datasets/detect/#ultralytics-yolo-format","title":"Ultralytics YOLO format","text":"<p>The Ultralytics YOLO format is a dataset configuration format that allows you to define the dataset root directory, the relative paths to training/validation/testing image directories or *.txt files containing image paths, and a dictionary of class names. Here is an example:</p> <pre><code># Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]\npath: ../datasets/coco8  # dataset root dir\ntrain: images/train  # train images (relative to 'path') 4 images\nval: images/val  # val images (relative to 'path') 4 images\ntest:  # test images (optional)\n\n# Classes (80 COCO classes)\nnames:\n  0: person\n  1: bicycle\n  2: car\n  # ...\n  77: teddy bear\n  78: hair drier\n  79: toothbrush\n</code></pre> <p>Labels for this format should be exported to YOLO format with one <code>*.txt</code> file per image. If there are no objects in an image, no <code>*.txt</code> file is required. The <code>*.txt</code> file should be formatted with one row per object in <code>class x_center y_center width height</code> format. Box coordinates must be in normalized xywh format (from 0 to 1). If your boxes are in pixels, you should divide <code>x_center</code> and <code>width</code> by image width, and <code>y_center</code> and <code>height</code> by image height. Class numbers should be zero-indexed (start with 0).</p> <p></p> <p>The label file corresponding to the above image contains 2 persons (class <code>0</code>) and a tie (class <code>27</code>):</p> <p></p> <p>When using the Ultralytics YOLO format, organize your training and validation images and labels as shown in the example below.</p> <p></p>"},{"location":"datasets/detect/#usage","title":"Usage","text":"<p>Here's how you can use these formats to train your model:</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='coco8.yaml', epochs=100, imgsz=640)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\nyolo detect train data=coco8.yaml model=yolov8n.pt epochs=100 imgsz=640\n</code></pre>"},{"location":"datasets/detect/#supported-datasets","title":"Supported Datasets","text":"<p>Here is a list of the supported datasets and a brief description for each:</p> <ul> <li>Argoverse: A collection of sensor data collected from autonomous vehicles. It contains 3D tracking annotations for car objects.</li> <li>COCO: Common Objects in Context (COCO) is a large-scale object detection, segmentation, and captioning dataset with 80 object categories.</li> <li>COCO8: A smaller subset of the COCO dataset, COCO8 is more lightweight and faster to train.</li> <li>GlobalWheat2020: A dataset containing images of wheat heads for the Global Wheat Challenge 2020.</li> <li>Objects365: A large-scale object detection dataset with 365 object categories and 600k images, aimed at advancing object detection research.</li> <li>OpenImagesV7: A comprehensive dataset by Google with 1.7M train images and 42k validation images.</li> <li>SKU-110K: A dataset containing images of densely packed retail products, intended for retail environment object detection.</li> <li>VisDrone: A dataset focusing on drone-based images, containing various object categories like cars, pedestrians, and cyclists.</li> <li>VOC: PASCAL VOC is a popular object detection dataset with 20 object categories including vehicles, animals, and furniture.</li> <li>xView: A dataset containing high-resolution satellite imagery, designed for the detection of various object classes in overhead views.</li> </ul>"},{"location":"datasets/detect/#adding-your-own-dataset","title":"Adding your own dataset","text":"<p>If you have your own dataset and would like to use it for training detection models with Ultralytics YOLO format, ensure that it follows the format specified above under \"Ultralytics YOLO format\". Convert your annotations to the required format and specify the paths, number of classes, and class names in the YAML configuration file.</p>"},{"location":"datasets/detect/#port-or-convert-label-formats","title":"Port or Convert Label Formats","text":""},{"location":"datasets/detect/#coco-dataset-format-to-yolo-format","title":"COCO Dataset Format to YOLO Format","text":"<p>You can easily convert labels from the popular COCO dataset format to the YOLO format using the following code snippet:</p> <p>Example</p> Python <pre><code>from ultralytics.data.converter import convert_coco\n\nconvert_coco(labels_dir='path/to/coco/annotations/')\n</code></pre> <p>This conversion tool can be used to convert the COCO dataset or any dataset in the COCO format to the Ultralytics YOLO format.</p> <p>Remember to double-check if the dataset you want to use is compatible with your model and follows the necessary format conventions. Properly formatted datasets are crucial for training successful object detection models.</p>"},{"location":"datasets/detect/argoverse/","title":"Argoverse Dataset","text":"<p>The Argoverse dataset is a collection of data designed to support research in autonomous driving tasks, such as 3D tracking, motion forecasting, and stereo depth estimation. Developed by Argo AI, the dataset provides a wide range of high-quality sensor data, including high-resolution images, LiDAR point clouds, and map data.</p> <p>Note</p> <p>The Argoverse dataset *.zip file required for training was removed from Amazon S3 after the shutdown of Argo AI by Ford, but we have made it available for manual download on Google Drive.</p>"},{"location":"datasets/detect/argoverse/#key-features","title":"Key Features","text":"<ul> <li>Argoverse contains over 290K labeled 3D object tracks and 5 million object instances across 1,263 distinct scenes.</li> <li>The dataset includes high-resolution camera images, LiDAR point clouds, and richly annotated HD maps.</li> <li>Annotations include 3D bounding boxes for objects, object tracks, and trajectory information.</li> <li>Argoverse provides multiple subsets for different tasks, such as 3D tracking, motion forecasting, and stereo depth estimation.</li> </ul>"},{"location":"datasets/detect/argoverse/#dataset-structure","title":"Dataset Structure","text":"<p>The Argoverse dataset is organized into three main subsets:</p> <ol> <li>Argoverse 3D Tracking: This subset contains 113 scenes with over 290K labeled 3D object tracks, focusing on 3D object tracking tasks. It includes LiDAR point clouds, camera images, and sensor calibration information.</li> <li>Argoverse Motion Forecasting: This subset consists of 324K vehicle trajectories collected from 60 hours of driving data, suitable for motion forecasting tasks.</li> <li>Argoverse Stereo Depth Estimation: This subset is designed for stereo depth estimation tasks and includes over 10K stereo image pairs with corresponding LiDAR point clouds for ground truth depth estimation.</li> </ol>"},{"location":"datasets/detect/argoverse/#applications","title":"Applications","text":"<p>The Argoverse dataset is widely used for training and evaluating deep learning models in autonomous driving tasks such as 3D object tracking, motion forecasting, and stereo depth estimation. The dataset's diverse set of sensor data, object annotations, and map information make it a valuable resource for researchers and practitioners in the field of autonomous driving.</p>"},{"location":"datasets/detect/argoverse/#dataset-yaml","title":"Dataset YAML","text":"<p>A YAML (Yet Another Markup Language) file is used to define the dataset configuration. It contains information about the dataset's paths, classes, and other relevant information. For the case of the Argoverse dataset, the <code>Argoverse.yaml</code> file is maintained at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/cfg/datasets/Argoverse.yaml.</p> <p>ultralytics/cfg/datasets/Argoverse.yaml</p> <pre><code># Ultralytics YOLO \ud83d\ude80, AGPL-3.0 license\n# Argoverse-HD dataset (ring-front-center camera) http://www.cs.cmu.edu/~mengtial/proj/streaming/ by Argo AI\n# Documentation: https://docs.ultralytics.com/datasets/detect/argoverse/\n# Example usage: yolo train data=Argoverse.yaml\n# parent\n# \u251c\u2500\u2500 ultralytics\n# \u2514\u2500\u2500 datasets\n#     \u2514\u2500\u2500 Argoverse  \u2190 downloads here (31.5 GB)\n\n\n# Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]\npath: ../datasets/Argoverse  # dataset root dir\ntrain: Argoverse-1.1/images/train/  # train images (relative to 'path') 39384 images\nval: Argoverse-1.1/images/val/  # val images (relative to 'path') 15062 images\ntest: Argoverse-1.1/images/test/  # test images (optional) https://eval.ai/web/challenges/challenge-page/800/overview\n\n# Classes\nnames:\n  0: person\n  1: bicycle\n  2: car\n  3: motorcycle\n  4: bus\n  5: truck\n  6: traffic_light\n  7: stop_sign\n\n\n# Download script/URL (optional) ---------------------------------------------------------------------------------------\ndownload: |\n  import json\n  from tqdm import tqdm\n  from ultralytics.utils.downloads import download\n  from pathlib import Path\n\n  def argoverse2yolo(set):\n      labels = {}\n      a = json.load(open(set, \"rb\"))\n      for annot in tqdm(a['annotations'], desc=f\"Converting {set} to YOLOv5 format...\"):\n          img_id = annot['image_id']\n          img_name = a['images'][img_id]['name']\n          img_label_name = f'{img_name[:-3]}txt'\n\n          cls = annot['category_id']  # instance class id\n          x_center, y_center, width, height = annot['bbox']\n          x_center = (x_center + width / 2) / 1920.0  # offset and scale\n          y_center = (y_center + height / 2) / 1200.0  # offset and scale\n          width /= 1920.0  # scale\n          height /= 1200.0  # scale\n\n          img_dir = set.parents[2] / 'Argoverse-1.1' / 'labels' / a['seq_dirs'][a['images'][annot['image_id']]['sid']]\n          if not img_dir.exists():\n              img_dir.mkdir(parents=True, exist_ok=True)\n\n          k = str(img_dir / img_label_name)\n          if k not in labels:\n              labels[k] = []\n          labels[k].append(f\"{cls} {x_center} {y_center} {width} {height}\\n\")\n\n      for k in labels:\n          with open(k, \"w\") as f:\n              f.writelines(labels[k])\n\n\n  # Download 'https://argoverse-hd.s3.us-east-2.amazonaws.com/Argoverse-HD-Full.zip' (deprecated S3 link)\n  dir = Path(yaml['path'])  # dataset root dir\n  urls = ['https://drive.google.com/file/d/1st9qW3BeIwQsnR0t8mRpvbsSWIo16ACi/view?usp=drive_link']\n  download(urls, dir=dir)\n\n  # Convert\n  annotations_dir = 'Argoverse-HD/annotations/'\n  (dir / 'Argoverse-1.1' / 'tracking').rename(dir / 'Argoverse-1.1' / 'images')  # rename 'tracking' to 'images'\n  for d in \"train.json\", \"val.json\":\n      argoverse2yolo(dir / annotations_dir / d)  # convert Argoverse annotations to YOLO labels\n</code></pre>"},{"location":"datasets/detect/argoverse/#usage","title":"Usage","text":"<p>To train a YOLOv8n model on the Argoverse dataset for 100 epochs with an image size of 640, you can use the following code snippets. For a comprehensive list of available arguments, refer to the model Training page.</p> <p>Train Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='Argoverse.yaml', epochs=100, imgsz=640)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\nyolo detect train data=Argoverse.yaml model=yolov8n.pt epochs=100 imgsz=640\n</code></pre>"},{"location":"datasets/detect/argoverse/#sample-data-and-annotations","title":"Sample Data and Annotations","text":"<p>The Argoverse dataset contains a diverse set of sensor data, including camera images, LiDAR point clouds, and HD map information, providing rich context for autonomous driving tasks. Here are some examples of data from the dataset, along with their corresponding annotations:</p> <p></p> <ul> <li>Argoverse 3D Tracking: This image demonstrates an example of 3D object tracking, where objects are annotated with 3D bounding boxes. The dataset provides LiDAR point clouds and camera images to facilitate the development of models for this task.</li> </ul> <p>The example showcases the variety and complexity of the data in the Argoverse dataset and highlights the importance of high-quality sensor data for autonomous driving tasks.</p>"},{"location":"datasets/detect/argoverse/#citations-and-acknowledgments","title":"Citations and Acknowledgments","text":"<p>If you use the Argoverse dataset in your research or development work, please cite the following paper:</p> BibTeX <pre><code>@inproceedings{chang2019argoverse,\n  title={Argoverse: 3D Tracking and Forecasting with Rich Maps},\n  author={Chang, Ming-Fang and Lambert, John and Sangkloy, Patsorn and Singh, Jagjeet and Bak, Slawomir and Hartnett, Andrew and Wang, Dequan and Carr, Peter and Lucey, Simon and Ramanan, Deva and others},\n  booktitle={Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition},\n  pages={8748--8757},\n  year={2019}\n}\n</code></pre> <p>We would like to acknowledge Argo AI for creating and maintaining the Argoverse dataset as a valuable resource for the autonomous driving research community. For more information about the Argoverse dataset and its creators, visit the Argoverse dataset website.</p>"},{"location":"datasets/detect/coco/","title":"COCO Dataset","text":"<p>The COCO (Common Objects in Context) dataset is a large-scale object detection, segmentation, and captioning dataset. It is designed to encourage research on a wide variety of object categories and is commonly used for benchmarking computer vision models. It is an essential dataset for researchers and developers working on object detection, segmentation, and pose estimation tasks.</p>"},{"location":"datasets/detect/coco/#key-features","title":"Key Features","text":"<ul> <li>COCO contains 330K images, with 200K images having annotations for object detection, segmentation, and captioning tasks.</li> <li>The dataset comprises 80 object categories, including common objects like cars, bicycles, and animals, as well as more specific categories such as umbrellas, handbags, and sports equipment.</li> <li>Annotations include object bounding boxes, segmentation masks, and captions for each image.</li> <li>COCO provides standardized evaluation metrics like mean Average Precision (mAP) for object detection, and mean Average Recall (mAR) for segmentation tasks, making it suitable for comparing model performance.</li> </ul>"},{"location":"datasets/detect/coco/#dataset-structure","title":"Dataset Structure","text":"<p>The COCO dataset is split into three subsets:</p> <ol> <li>Train2017: This subset contains 118K images for training object detection, segmentation, and captioning models.</li> <li>Val2017: This subset has 5K images used for validation purposes during model training.</li> <li>Test2017: This subset consists of 20K images used for testing and benchmarking the trained models. Ground truth annotations for this subset are not publicly available, and the results are submitted to the COCO evaluation server for performance evaluation.</li> </ol>"},{"location":"datasets/detect/coco/#applications","title":"Applications","text":"<p>The COCO dataset is widely used for training and evaluating deep learning models in object detection (such as YOLO, Faster R-CNN, and SSD), instance segmentation (such as Mask R-CNN), and keypoint detection (such as OpenPose). The dataset's diverse set of object categories, large number of annotated images, and standardized evaluation metrics make it an essential resource for computer vision researchers and practitioners.</p>"},{"location":"datasets/detect/coco/#dataset-yaml","title":"Dataset YAML","text":"<p>A YAML (Yet Another Markup Language) file is used to define the dataset configuration. It contains information about the dataset's paths, classes, and other relevant information. In the case of the COCO dataset, the <code>coco.yaml</code> file is maintained at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/cfg/datasets/coco.yaml.</p> <p>ultralytics/cfg/datasets/coco.yaml</p> <pre><code># Ultralytics YOLO \ud83d\ude80, AGPL-3.0 license\n# COCO 2017 dataset http://cocodataset.org by Microsoft\n# Documentation: https://docs.ultralytics.com/datasets/detect/coco/\n# Example usage: yolo train data=coco.yaml\n# parent\n# \u251c\u2500\u2500 ultralytics\n# \u2514\u2500\u2500 datasets\n#     \u2514\u2500\u2500 coco  \u2190 downloads here (20.1 GB)\n\n\n# Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]\npath: ../datasets/coco  # dataset root dir\ntrain: train2017.txt  # train images (relative to 'path') 118287 images\nval: val2017.txt  # val images (relative to 'path') 5000 images\ntest: test-dev2017.txt  # 20288 of 40670 images, submit to https://competitions.codalab.org/competitions/20794\n\n# Classes\nnames:\n  0: person\n  1: bicycle\n  2: car\n  3: motorcycle\n  4: airplane\n  5: bus\n  6: train\n  7: truck\n  8: boat\n  9: traffic light\n  10: fire hydrant\n  11: stop sign\n  12: parking meter\n  13: bench\n  14: bird\n  15: cat\n  16: dog\n  17: horse\n  18: sheep\n  19: cow\n  20: elephant\n  21: bear\n  22: zebra\n  23: giraffe\n  24: backpack\n  25: umbrella\n  26: handbag\n  27: tie\n  28: suitcase\n  29: frisbee\n  30: skis\n  31: snowboard\n  32: sports ball\n  33: kite\n  34: baseball bat\n  35: baseball glove\n  36: skateboard\n  37: surfboard\n  38: tennis racket\n  39: bottle\n  40: wine glass\n  41: cup\n  42: fork\n  43: knife\n  44: spoon\n  45: bowl\n  46: banana\n  47: apple\n  48: sandwich\n  49: orange\n  50: broccoli\n  51: carrot\n  52: hot dog\n  53: pizza\n  54: donut\n  55: cake\n  56: chair\n  57: couch\n  58: potted plant\n  59: bed\n  60: dining table\n  61: toilet\n  62: tv\n  63: laptop\n  64: mouse\n  65: remote\n  66: keyboard\n  67: cell phone\n  68: microwave\n  69: oven\n  70: toaster\n  71: sink\n  72: refrigerator\n  73: book\n  74: clock\n  75: vase\n  76: scissors\n  77: teddy bear\n  78: hair drier\n  79: toothbrush\n\n\n# Download script/URL (optional)\ndownload: |\n  from ultralytics.utils.downloads import download\n  from pathlib import Path\n\n  # Download labels\n  segments = True  # segment or box labels\n  dir = Path(yaml['path'])  # dataset root dir\n  url = 'https://github.com/ultralytics/yolov5/releases/download/v1.0/'\n  urls = [url + ('coco2017labels-segments.zip' if segments else 'coco2017labels.zip')]  # labels\n  download(urls, dir=dir.parent)\n  # Download data\n  urls = ['http://images.cocodataset.org/zips/train2017.zip',  # 19G, 118k images\n          'http://images.cocodataset.org/zips/val2017.zip',  # 1G, 5k images\n          'http://images.cocodataset.org/zips/test2017.zip']  # 7G, 41k images (optional)\n  download(urls, dir=dir / 'images', threads=3)\n</code></pre>"},{"location":"datasets/detect/coco/#usage","title":"Usage","text":"<p>To train a YOLOv8n model on the COCO dataset for 100 epochs with an image size of 640, you can use the following code snippets. For a comprehensive list of available arguments, refer to the model Training page.</p> <p>Train Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='coco.yaml', epochs=100, imgsz=640)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\nyolo detect train data=coco.yaml model=yolov8n.pt epochs=100 imgsz=640\n</code></pre>"},{"location":"datasets/detect/coco/#sample-images-and-annotations","title":"Sample Images and Annotations","text":"<p>The COCO dataset contains a diverse set of images with various object categories and complex scenes. Here are some examples of images from the dataset, along with their corresponding annotations:</p> <p></p> <ul> <li>Mosaiced Image: This image demonstrates a training batch composed of mosaiced dataset images. Mosaicing is a technique used during training that combines multiple images into a single image to increase the variety of objects and scenes within each training batch. This helps improve the model's ability to generalize to different object sizes, aspect ratios, and contexts.</li> </ul> <p>The example showcases the variety and complexity of the images in the COCO dataset and the benefits of using mosaicing during the training process.</p>"},{"location":"datasets/detect/coco/#citations-and-acknowledgments","title":"Citations and Acknowledgments","text":"<p>If you use the COCO dataset in your research or development work, please cite the following paper:</p> BibTeX <pre><code>@misc{lin2015microsoft,\n      title={Microsoft COCO: Common Objects in Context},\n      author={Tsung-Yi Lin and Michael Maire and Serge Belongie and Lubomir Bourdev and Ross Girshick and James Hays and Pietro Perona and Deva Ramanan and C. Lawrence Zitnick and Piotr Doll\u00e1r},\n      year={2015},\n      eprint={1405.0312},\n      archivePrefix={arXiv},\n      primaryClass={cs.CV}\n}\n</code></pre> <p>We would like to acknowledge the COCO Consortium for creating and maintaining this valuable resource for the computer vision community. For more information about the COCO dataset and its creators, visit the COCO dataset website.</p>"},{"location":"datasets/detect/coco8/","title":"COCO8 Dataset","text":""},{"location":"datasets/detect/coco8/#introduction","title":"Introduction","text":"<p>Ultralytics COCO8 is a small, but versatile object detection dataset composed of the first 8 images of the COCO train 2017 set, 4 for training and 4 for validation. This dataset is ideal for testing and debugging object detection models, or for experimenting with new detection approaches. With 8 images, it is small enough to be easily manageable, yet diverse enough to test training pipelines for errors and act as a sanity check before training larger datasets.</p> <p>This dataset is intended for use with Ultralytics HUB and YOLOv8.</p>"},{"location":"datasets/detect/coco8/#dataset-yaml","title":"Dataset YAML","text":"<p>A YAML (Yet Another Markup Language) file is used to define the dataset configuration. It contains information about the dataset's paths, classes, and other relevant information. In the case of the COCO8 dataset, the <code>coco8.yaml</code> file is maintained at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/cfg/datasets/coco8.yaml.</p> <p>ultralytics/cfg/datasets/coco8.yaml</p> <pre><code># Ultralytics YOLO \ud83d\ude80, AGPL-3.0 license\n# COCO8 dataset (first 8 images from COCO train2017) by Ultralytics\n# Documentation: https://docs.ultralytics.com/datasets/detect/coco8/\n# Example usage: yolo train data=coco8.yaml\n# parent\n# \u251c\u2500\u2500 ultralytics\n# \u2514\u2500\u2500 datasets\n#     \u2514\u2500\u2500 coco8  \u2190 downloads here (1 MB)\n\n\n# Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]\npath: ../datasets/coco8  # dataset root dir\ntrain: images/train  # train images (relative to 'path') 4 images\nval: images/val  # val images (relative to 'path') 4 images\ntest:  # test images (optional)\n\n# Classes\nnames:\n  0: person\n  1: bicycle\n  2: car\n  3: motorcycle\n  4: airplane\n  5: bus\n  6: train\n  7: truck\n  8: boat\n  9: traffic light\n  10: fire hydrant\n  11: stop sign\n  12: parking meter\n  13: bench\n  14: bird\n  15: cat\n  16: dog\n  17: horse\n  18: sheep\n  19: cow\n  20: elephant\n  21: bear\n  22: zebra\n  23: giraffe\n  24: backpack\n  25: umbrella\n  26: handbag\n  27: tie\n  28: suitcase\n  29: frisbee\n  30: skis\n  31: snowboard\n  32: sports ball\n  33: kite\n  34: baseball bat\n  35: baseball glove\n  36: skateboard\n  37: surfboard\n  38: tennis racket\n  39: bottle\n  40: wine glass\n  41: cup\n  42: fork\n  43: knife\n  44: spoon\n  45: bowl\n  46: banana\n  47: apple\n  48: sandwich\n  49: orange\n  50: broccoli\n  51: carrot\n  52: hot dog\n  53: pizza\n  54: donut\n  55: cake\n  56: chair\n  57: couch\n  58: potted plant\n  59: bed\n  60: dining table\n  61: toilet\n  62: tv\n  63: laptop\n  64: mouse\n  65: remote\n  66: keyboard\n  67: cell phone\n  68: microwave\n  69: oven\n  70: toaster\n  71: sink\n  72: refrigerator\n  73: book\n  74: clock\n  75: vase\n  76: scissors\n  77: teddy bear\n  78: hair drier\n  79: toothbrush\n\n\n# Download script/URL (optional)\ndownload: https://ultralytics.com/assets/coco8.zip\n</code></pre>"},{"location":"datasets/detect/coco8/#usage","title":"Usage","text":"<p>To train a YOLOv8n model on the COCO8 dataset for 100 epochs with an image size of 640, you can use the following code snippets. For a comprehensive list of available arguments, refer to the model Training page.</p> <p>Train Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='coco8.yaml', epochs=100, imgsz=640)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\nyolo detect train data=coco8.yaml model=yolov8n.pt epochs=100 imgsz=640\n</code></pre>"},{"location":"datasets/detect/coco8/#sample-images-and-annotations","title":"Sample Images and Annotations","text":"<p>Here are some examples of images from the COCO8 dataset, along with their corresponding annotations:</p> <p></p> <ul> <li>Mosaiced Image: This image demonstrates a training batch composed of mosaiced dataset images. Mosaicing is a technique used during training that combines multiple images into a single image to increase the variety of objects and scenes within each training batch. This helps improve the model's ability to generalize to different object sizes, aspect ratios, and contexts.</li> </ul> <p>The example showcases the variety and complexity of the images in the COCO8 dataset and the benefits of using mosaicing during the training process.</p>"},{"location":"datasets/detect/coco8/#citations-and-acknowledgments","title":"Citations and Acknowledgments","text":"<p>If you use the COCO dataset in your research or development work, please cite the following paper:</p> BibTeX <pre><code>@misc{lin2015microsoft,\n      title={Microsoft COCO: Common Objects in Context},\n      author={Tsung-Yi Lin and Michael Maire and Serge Belongie and Lubomir Bourdev and Ross Girshick and James Hays and Pietro Perona and Deva Ramanan and C. Lawrence Zitnick and Piotr Doll\u00e1r},\n      year={2015},\n      eprint={1405.0312},\n      archivePrefix={arXiv},\n      primaryClass={cs.CV}\n}\n</code></pre> <p>We would like to acknowledge the COCO Consortium for creating and maintaining this valuable resource for the computer vision community. For more information about the COCO dataset and its creators, visit the COCO dataset website.</p>"},{"location":"datasets/detect/globalwheat2020/","title":"Global Wheat Head Dataset","text":"<p>The Global Wheat Head Dataset is a collection of images designed to support the development of accurate wheat head detection models for applications in wheat phenotyping and crop management. Wheat heads, also known as spikes, are the grain-bearing parts of the wheat plant. Accurate estimation of wheat head density and size is essential for assessing crop health, maturity, and yield potential. The dataset, created by a collaboration of nine research institutes from seven countries, covers multiple growing regions to ensure models generalize well across different environments.</p>"},{"location":"datasets/detect/globalwheat2020/#key-features","title":"Key Features","text":"<ul> <li>The dataset contains over 3,000 training images from Europe (France, UK, Switzerland) and North America (Canada).</li> <li>It includes approximately 1,000 test images from Australia, Japan, and China.</li> <li>Images are outdoor field images, capturing the natural variability in wheat head appearances.</li> <li>Annotations include wheat head bounding boxes to support object detection tasks.</li> </ul>"},{"location":"datasets/detect/globalwheat2020/#dataset-structure","title":"Dataset Structure","text":"<p>The Global Wheat Head Dataset is organized into two main subsets:</p> <ol> <li>Training Set: This subset contains over 3,000 images from Europe and North America. The images are labeled with wheat head bounding boxes, providing ground truth for training object detection models.</li> <li>Test Set: This subset consists of approximately 1,000 images from Australia, Japan, and China. These images are used for evaluating the performance of trained models on unseen genotypes, environments, and observational conditions.</li> </ol>"},{"location":"datasets/detect/globalwheat2020/#applications","title":"Applications","text":"<p>The Global Wheat Head Dataset is widely used for training and evaluating deep learning models in wheat head detection tasks. The dataset's diverse set of images, capturing a wide range of appearances, environments, and conditions, make it a valuable resource for researchers and practitioners in the field of plant phenotyping and crop management.</p>"},{"location":"datasets/detect/globalwheat2020/#dataset-yaml","title":"Dataset YAML","text":"<p>A YAML (Yet Another Markup Language) file is used to define the dataset configuration. It contains information about the dataset's paths, classes, and other relevant information. For the case of the Global Wheat Head Dataset, the <code>GlobalWheat2020.yaml</code> file is maintained at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/cfg/datasets/GlobalWheat2020.yaml.</p> <p>ultralytics/cfg/datasets/GlobalWheat2020.yaml</p> <pre><code># Ultralytics YOLO \ud83d\ude80, AGPL-3.0 license\n# Global Wheat 2020 dataset http://www.global-wheat.com/ by University of Saskatchewan\n# Documentation: https://docs.ultralytics.com/datasets/detect/globalwheat2020/\n# Example usage: yolo train data=GlobalWheat2020.yaml\n# parent\n# \u251c\u2500\u2500 ultralytics\n# \u2514\u2500\u2500 datasets\n#     \u2514\u2500\u2500 GlobalWheat2020  \u2190 downloads here (7.0 GB)\n\n\n# Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]\npath: ../datasets/GlobalWheat2020  # dataset root dir\ntrain: # train images (relative to 'path') 3422 images\n  - images/arvalis_1\n  - images/arvalis_2\n  - images/arvalis_3\n  - images/ethz_1\n  - images/rres_1\n  - images/inrae_1\n  - images/usask_1\nval: # val images (relative to 'path') 748 images (WARNING: train set contains ethz_1)\n  - images/ethz_1\ntest: # test images (optional) 1276 images\n  - images/utokyo_1\n  - images/utokyo_2\n  - images/nau_1\n  - images/uq_1\n\n# Classes\nnames:\n  0: wheat_head\n\n\n# Download script/URL (optional) ---------------------------------------------------------------------------------------\ndownload: |\n  from ultralytics.utils.downloads import download\n  from pathlib import Path\n\n  # Download\n  dir = Path(yaml['path'])  # dataset root dir\n  urls = ['https://zenodo.org/record/4298502/files/global-wheat-codalab-official.zip',\n          'https://github.com/ultralytics/yolov5/releases/download/v1.0/GlobalWheat2020_labels.zip']\n  download(urls, dir=dir)\n\n  # Make Directories\n  for p in 'annotations', 'images', 'labels':\n      (dir / p).mkdir(parents=True, exist_ok=True)\n\n  # Move\n  for p in 'arvalis_1', 'arvalis_2', 'arvalis_3', 'ethz_1', 'rres_1', 'inrae_1', 'usask_1', \\\n           'utokyo_1', 'utokyo_2', 'nau_1', 'uq_1':\n      (dir / 'global-wheat-codalab-official' / p).rename(dir / 'images' / p)  # move to /images\n      f = (dir / 'global-wheat-codalab-official' / p).with_suffix('.json')  # json file\n      if f.exists():\n          f.rename((dir / 'annotations' / p).with_suffix('.json'))  # move to /annotations\n</code></pre>"},{"location":"datasets/detect/globalwheat2020/#usage","title":"Usage","text":"<p>To train a YOLOv8n model on the Global Wheat Head Dataset for 100 epochs with an image size of 640, you can use the following code snippets. For a comprehensive list of available arguments, refer to the model Training page.</p> <p>Train Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='GlobalWheat2020.yaml', epochs=100, imgsz=640)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\nyolo detect train data=GlobalWheat2020.yaml model=yolov8n.pt epochs=100 imgsz=640\n</code></pre>"},{"location":"datasets/detect/globalwheat2020/#sample-data-and-annotations","title":"Sample Data and Annotations","text":"<p>The Global Wheat Head Dataset contains a diverse set of outdoor field images, capturing the natural variability in wheat head appearances, environments, and conditions. Here are some examples of data from the dataset, along with their corresponding annotations:</p> <p></p> <ul> <li>Wheat Head Detection: This image demonstrates an example of wheat head detection, where wheat heads are annotated with bounding boxes. The dataset provides a variety of images to facilitate the development of models for this task.</li> </ul> <p>The example showcases the variety and complexity of the data in the Global Wheat Head Dataset and highlights the importance of accurate wheat head detection for applications in wheat phenotyping and crop management.</p>"},{"location":"datasets/detect/globalwheat2020/#citations-and-acknowledgments","title":"Citations and Acknowledgments","text":"<p>If you use the Global Wheat Head Dataset in your research or development work, please cite the following paper:</p> BibTeX <pre><code>@article{david2020global,\n         title={Global Wheat Head Detection (GWHD) Dataset: A Large and Diverse Dataset of High-Resolution RGB-Labelled Images to Develop and Benchmark Wheat Head Detection Methods},\n         author={David, Etienne and Madec, Simon and Sadeghi-Tehran, Pouria and Aasen, Helge and Zheng, Bangyou and Liu, Shouyang and Kirchgessner, Norbert and Ishikawa, Goro and Nagasawa, Koichi and Badhon, Minhajul and others},\n         journal={arXiv preprint arXiv:2005.02162},\n         year={2020}\n}\n</code></pre> <p>We would like to acknowledge the researchers and institutions that contributed to the creation and maintenance of the Global Wheat Head Dataset as a valuable resource for the plant phenotyping and crop management research community. For more information about the dataset and its creators, visit the Global Wheat Head Dataset website.</p>"},{"location":"datasets/detect/objects365/","title":"Objects365 Dataset","text":"<p>The Objects365 dataset is a large-scale, high-quality dataset designed to foster object detection research with a focus on diverse objects in the wild. Created by a team of Megvii researchers, the dataset offers a wide range of high-resolution images with a comprehensive set of annotated bounding boxes covering 365 object categories.</p>"},{"location":"datasets/detect/objects365/#key-features","title":"Key Features","text":"<ul> <li>Objects365 contains 365 object categories, with 2 million images and over 30 million bounding boxes.</li> <li>The dataset includes diverse objects in various scenarios, providing a rich and challenging benchmark for object detection tasks.</li> <li>Annotations include bounding boxes for objects, making it suitable for training and evaluating object detection models.</li> <li>Objects365 pre-trained models significantly outperform ImageNet pre-trained models, leading to better generalization on various tasks.</li> </ul>"},{"location":"datasets/detect/objects365/#dataset-structure","title":"Dataset Structure","text":"<p>The Objects365 dataset is organized into a single set of images with corresponding annotations:</p> <ul> <li>Images: The dataset includes 2 million high-resolution images, each containing a variety of objects across 365 categories.</li> <li>Annotations: The images are annotated with over 30 million bounding boxes, providing comprehensive ground truth information for object detection tasks.</li> </ul>"},{"location":"datasets/detect/objects365/#applications","title":"Applications","text":"<p>The Objects365 dataset is widely used for training and evaluating deep learning models in object detection tasks. The dataset's diverse set of object categories and high-quality annotations make it a valuable resource for researchers and practitioners in the field of computer vision.</p>"},{"location":"datasets/detect/objects365/#dataset-yaml","title":"Dataset YAML","text":"<p>A YAML (Yet Another Markup Language) file is used to define the dataset configuration. It contains information about the dataset's paths, classes, and other relevant information. For the case of the Objects365 Dataset, the <code>Objects365.yaml</code> file is maintained at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/cfg/datasets/Objects365.yaml.</p> <p>ultralytics/cfg/datasets/Objects365.yaml</p> <pre><code># Ultralytics YOLO \ud83d\ude80, AGPL-3.0 license\n# Objects365 dataset https://www.objects365.org/ by Megvii\n# Documentation: https://docs.ultralytics.com/datasets/detect/objects365/\n# Example usage: yolo train data=Objects365.yaml\n# parent\n# \u251c\u2500\u2500 ultralytics\n# \u2514\u2500\u2500 datasets\n#     \u2514\u2500\u2500 Objects365  \u2190 downloads here (712 GB = 367G data + 345G zips)\n\n\n# Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]\npath: ../datasets/Objects365  # dataset root dir\ntrain: images/train  # train images (relative to 'path') 1742289 images\nval: images/val # val images (relative to 'path') 80000 images\ntest:  # test images (optional)\n\n# Classes\nnames:\n  0: Person\n  1: Sneakers\n  2: Chair\n  3: Other Shoes\n  4: Hat\n  5: Car\n  6: Lamp\n  7: Glasses\n  8: Bottle\n  9: Desk\n  10: Cup\n  11: Street Lights\n  12: Cabinet/shelf\n  13: Handbag/Satchel\n  14: Bracelet\n  15: Plate\n  16: Picture/Frame\n  17: Helmet\n  18: Book\n  19: Gloves\n  20: Storage box\n  21: Boat\n  22: Leather Shoes\n  23: Flower\n  24: Bench\n  25: Potted Plant\n  26: Bowl/Basin\n  27: Flag\n  28: Pillow\n  29: Boots\n  30: Vase\n  31: Microphone\n  32: Necklace\n  33: Ring\n  34: SUV\n  35: Wine Glass\n  36: Belt\n  37: Monitor/TV\n  38: Backpack\n  39: Umbrella\n  40: Traffic Light\n  41: Speaker\n  42: Watch\n  43: Tie\n  44: Trash bin Can\n  45: Slippers\n  46: Bicycle\n  47: Stool\n  48: Barrel/bucket\n  49: Van\n  50: Couch\n  51: Sandals\n  52: Basket\n  53: Drum\n  54: Pen/Pencil\n  55: Bus\n  56: Wild Bird\n  57: High Heels\n  58: Motorcycle\n  59: Guitar\n  60: Carpet\n  61: Cell Phone\n  62: Bread\n  63: Camera\n  64: Canned\n  65: Truck\n  66: Traffic cone\n  67: Cymbal\n  68: Lifesaver\n  69: Towel\n  70: Stuffed Toy\n  71: Candle\n  72: Sailboat\n  73: Laptop\n  74: Awning\n  75: Bed\n  76: Faucet\n  77: Tent\n  78: Horse\n  79: Mirror\n  80: Power outlet\n  81: Sink\n  82: Apple\n  83: Air Conditioner\n  84: Knife\n  85: Hockey Stick\n  86: Paddle\n  87: Pickup Truck\n  88: Fork\n  89: Traffic Sign\n  90: Balloon\n  91: Tripod\n  92: Dog\n  93: Spoon\n  94: Clock\n  95: Pot\n  96: Cow\n  97: Cake\n  98: Dinning Table\n  99: Sheep\n  100: Hanger\n  101: Blackboard/Whiteboard\n  102: Napkin\n  103: Other Fish\n  104: Orange/Tangerine\n  105: Toiletry\n  106: Keyboard\n  107: Tomato\n  108: Lantern\n  109: Machinery Vehicle\n  110: Fan\n  111: Green Vegetables\n  112: Banana\n  113: Baseball Glove\n  114: Airplane\n  115: Mouse\n  116: Train\n  117: Pumpkin\n  118: Soccer\n  119: Skiboard\n  120: Luggage\n  121: Nightstand\n  122: Tea pot\n  123: Telephone\n  124: Trolley\n  125: Head Phone\n  126: Sports Car\n  127: Stop Sign\n  128: Dessert\n  129: Scooter\n  130: Stroller\n  131: Crane\n  132: Remote\n  133: Refrigerator\n  134: Oven\n  135: Lemon\n  136: Duck\n  137: Baseball Bat\n  138: Surveillance Camera\n  139: Cat\n  140: Jug\n  141: Broccoli\n  142: Piano\n  143: Pizza\n  144: Elephant\n  145: Skateboard\n  146: Surfboard\n  147: Gun\n  148: Skating and Skiing shoes\n  149: Gas stove\n  150: Donut\n  151: Bow Tie\n  152: Carrot\n  153: Toilet\n  154: Kite\n  155: Strawberry\n  156: Other Balls\n  157: Shovel\n  158: Pepper\n  159: Computer Box\n  160: Toilet Paper\n  161: Cleaning Products\n  162: Chopsticks\n  163: Microwave\n  164: Pigeon\n  165: Baseball\n  166: Cutting/chopping Board\n  167: Coffee Table\n  168: Side Table\n  169: Scissors\n  170: Marker\n  171: Pie\n  172: Ladder\n  173: Snowboard\n  174: Cookies\n  175: Radiator\n  176: Fire Hydrant\n  177: Basketball\n  178: Zebra\n  179: Grape\n  180: Giraffe\n  181: Potato\n  182: Sausage\n  183: Tricycle\n  184: Violin\n  185: Egg\n  186: Fire Extinguisher\n  187: Candy\n  188: Fire Truck\n  189: Billiards\n  190: Converter\n  191: Bathtub\n  192: Wheelchair\n  193: Golf Club\n  194: Briefcase\n  195: Cucumber\n  196: Cigar/Cigarette\n  197: Paint Brush\n  198: Pear\n  199: Heavy Truck\n  200: Hamburger\n  201: Extractor\n  202: Extension Cord\n  203: Tong\n  204: Tennis Racket\n  205: Folder\n  206: American Football\n  207: earphone\n  208: Mask\n  209: Kettle\n  210: Tennis\n  211: Ship\n  212: Swing\n  213: Coffee Machine\n  214: Slide\n  215: Carriage\n  216: Onion\n  217: Green beans\n  218: Projector\n  219: Frisbee\n  220: Washing Machine/Drying Machine\n  221: Chicken\n  222: Printer\n  223: Watermelon\n  224: Saxophone\n  225: Tissue\n  226: Toothbrush\n  227: Ice cream\n  228: Hot-air balloon\n  229: Cello\n  230: French Fries\n  231: Scale\n  232: Trophy\n  233: Cabbage\n  234: Hot dog\n  235: Blender\n  236: Peach\n  237: Rice\n  238: Wallet/Purse\n  239: Volleyball\n  240: Deer\n  241: Goose\n  242: Tape\n  243: Tablet\n  244: Cosmetics\n  245: Trumpet\n  246: Pineapple\n  247: Golf Ball\n  248: Ambulance\n  249: Parking meter\n  250: Mango\n  251: Key\n  252: Hurdle\n  253: Fishing Rod\n  254: Medal\n  255: Flute\n  256: Brush\n  257: Penguin\n  258: Megaphone\n  259: Corn\n  260: Lettuce\n  261: Garlic\n  262: Swan\n  263: Helicopter\n  264: Green Onion\n  265: Sandwich\n  266: Nuts\n  267: Speed Limit Sign\n  268: Induction Cooker\n  269: Broom\n  270: Trombone\n  271: Plum\n  272: Rickshaw\n  273: Goldfish\n  274: Kiwi fruit\n  275: Router/modem\n  276: Poker Card\n  277: Toaster\n  278: Shrimp\n  279: Sushi\n  280: Cheese\n  281: Notepaper\n  282: Cherry\n  283: Pliers\n  284: CD\n  285: Pasta\n  286: Hammer\n  287: Cue\n  288: Avocado\n  289: Hamimelon\n  290: Flask\n  291: Mushroom\n  292: Screwdriver\n  293: Soap\n  294: Recorder\n  295: Bear\n  296: Eggplant\n  297: Board Eraser\n  298: Coconut\n  299: Tape Measure/Ruler\n  300: Pig\n  301: Showerhead\n  302: Globe\n  303: Chips\n  304: Steak\n  305: Crosswalk Sign\n  306: Stapler\n  307: Camel\n  308: Formula 1\n  309: Pomegranate\n  310: Dishwasher\n  311: Crab\n  312: Hoverboard\n  313: Meat ball\n  314: Rice Cooker\n  315: Tuba\n  316: Calculator\n  317: Papaya\n  318: Antelope\n  319: Parrot\n  320: Seal\n  321: Butterfly\n  322: Dumbbell\n  323: Donkey\n  324: Lion\n  325: Urinal\n  326: Dolphin\n  327: Electric Drill\n  328: Hair Dryer\n  329: Egg tart\n  330: Jellyfish\n  331: Treadmill\n  332: Lighter\n  333: Grapefruit\n  334: Game board\n  335: Mop\n  336: Radish\n  337: Baozi\n  338: Target\n  339: French\n  340: Spring Rolls\n  341: Monkey\n  342: Rabbit\n  343: Pencil Case\n  344: Yak\n  345: Red Cabbage\n  346: Binoculars\n  347: Asparagus\n  348: Barbell\n  349: Scallop\n  350: Noddles\n  351: Comb\n  352: Dumpling\n  353: Oyster\n  354: Table Tennis paddle\n  355: Cosmetics Brush/Eyeliner Pencil\n  356: Chainsaw\n  357: Eraser\n  358: Lobster\n  359: Durian\n  360: Okra\n  361: Lipstick\n  362: Cosmetics Mirror\n  363: Curling\n  364: Table Tennis\n\n\n# Download script/URL (optional) ---------------------------------------------------------------------------------------\ndownload: |\n  from tqdm import tqdm\n\n  from ultralytics.utils.checks import check_requirements\n  from ultralytics.utils.downloads import download\n  from ultralytics.utils.ops import xyxy2xywhn\n\n  import numpy as np\n  from pathlib import Path\n\n  check_requirements(('pycocotools&gt;=2.0',))\n  from pycocotools.coco import COCO\n\n  # Make Directories\n  dir = Path(yaml['path'])  # dataset root dir\n  for p in 'images', 'labels':\n      (dir / p).mkdir(parents=True, exist_ok=True)\n      for q in 'train', 'val':\n          (dir / p / q).mkdir(parents=True, exist_ok=True)\n\n  # Train, Val Splits\n  for split, patches in [('train', 50 + 1), ('val', 43 + 1)]:\n      print(f\"Processing {split} in {patches} patches ...\")\n      images, labels = dir / 'images' / split, dir / 'labels' / split\n\n      # Download\n      url = f\"https://dorc.ks3-cn-beijing.ksyun.com/data-set/2020Objects365%E6%95%B0%E6%8D%AE%E9%9B%86/{split}/\"\n      if split == 'train':\n          download([f'{url}zhiyuan_objv2_{split}.tar.gz'], dir=dir)  # annotations json\n          download([f'{url}patch{i}.tar.gz' for i in range(patches)], dir=images, curl=True, threads=8)\n      elif split == 'val':\n          download([f'{url}zhiyuan_objv2_{split}.json'], dir=dir)  # annotations json\n          download([f'{url}images/v1/patch{i}.tar.gz' for i in range(15 + 1)], dir=images, curl=True, threads=8)\n          download([f'{url}images/v2/patch{i}.tar.gz' for i in range(16, patches)], dir=images, curl=True, threads=8)\n\n      # Move\n      for f in tqdm(images.rglob('*.jpg'), desc=f'Moving {split} images'):\n          f.rename(images / f.name)  # move to /images/{split}\n\n      # Labels\n      coco = COCO(dir / f'zhiyuan_objv2_{split}.json')\n      names = [x[\"name\"] for x in coco.loadCats(coco.getCatIds())]\n      for cid, cat in enumerate(names):\n          catIds = coco.getCatIds(catNms=[cat])\n          imgIds = coco.getImgIds(catIds=catIds)\n          for im in tqdm(coco.loadImgs(imgIds), desc=f'Class {cid + 1}/{len(names)} {cat}'):\n              width, height = im[\"width\"], im[\"height\"]\n              path = Path(im[\"file_name\"])  # image filename\n              try:\n                  with open(labels / path.with_suffix('.txt').name, 'a') as file:\n                      annIds = coco.getAnnIds(imgIds=im[\"id\"], catIds=catIds, iscrowd=None)\n                      for a in coco.loadAnns(annIds):\n                          x, y, w, h = a['bbox']  # bounding box in xywh (xy top-left corner)\n                          xyxy = np.array([x, y, x + w, y + h])[None]  # pixels(1,4)\n                          x, y, w, h = xyxy2xywhn(xyxy, w=width, h=height, clip=True)[0]  # normalized and clipped\n                          file.write(f\"{cid} {x:.5f} {y:.5f} {w:.5f} {h:.5f}\\n\")\n              except Exception as e:\n                  print(e)\n</code></pre>"},{"location":"datasets/detect/objects365/#usage","title":"Usage","text":"<p>To train a YOLOv8n model on the Objects365 dataset for 100 epochs with an image size of 640, you can use the following code snippets. For a comprehensive list of available arguments, refer to the model Training page.</p> <p>Train Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='Objects365.yaml', epochs=100, imgsz=640)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\nyolo detect train data=Objects365.yaml model=yolov8n.pt epochs=100 imgsz=640\n</code></pre>"},{"location":"datasets/detect/objects365/#sample-data-and-annotations","title":"Sample Data and Annotations","text":"<p>The Objects365 dataset contains a diverse set of high-resolution images with objects from 365 categories, providing rich context for object detection tasks. Here are some examples of the images in the dataset:</p> <p></p> <ul> <li>Objects365: This image demonstrates an example of object detection, where objects are annotated with bounding boxes. The dataset provides a wide range of images to facilitate the development of models for this task.</li> </ul> <p>The example showcases the variety and complexity of the data in the Objects365 dataset and highlights the importance of accurate object detection for computer vision applications.</p>"},{"location":"datasets/detect/objects365/#citations-and-acknowledgments","title":"Citations and Acknowledgments","text":"<p>If you use the Objects365 dataset in your research or development work, please cite the following paper:</p> BibTeX <pre><code>@inproceedings{shao2019objects365,\n  title={Objects365: A Large-scale, High-quality Dataset for Object Detection},\n  author={Shao, Shuai and Li, Zeming and Zhang, Tianyuan and Peng, Chao and Yu, Gang and Li, Jing and Zhang, Xiangyu and Sun, Jian},\n  booktitle={Proceedings of the IEEE/CVF International Conference on Computer Vision},\n  pages={8425--8434},\n  year={2019}\n}\n</code></pre> <p>We would like to acknowledge the team of researchers who created and maintain the Objects365 dataset as a valuable resource for the computer vision research community. For more information about the Objects365 dataset and its creators, visit the Objects365 dataset website.</p>"},{"location":"datasets/detect/open-images-v7/","title":"Open Images V7 Dataset","text":"<p>Open Images V7 is a versatile and expansive dataset championed by Google. Aimed at propelling research in the realm of computer vision, it boasts a vast collection of images annotated with a plethora of data, including image-level labels, object bounding boxes, object segmentation masks, visual relationships, and localized narratives.</p> <p></p>"},{"location":"datasets/detect/open-images-v7/#key-features","title":"Key Features","text":"<ul> <li>Encompasses ~9M images annotated in various ways to suit multiple computer vision tasks.</li> <li>Houses a staggering 16M bounding boxes across 600 object classes in 1.9M images. These boxes are primarily hand-drawn by experts ensuring high precision.</li> <li>Visual relationship annotations totaling 3.3M are available, detailing 1,466 unique relationship triplets, object properties, and human activities.</li> <li>V5 introduced segmentation masks for 2.8M objects across 350 classes.</li> <li>V6 introduced 675k localized narratives that amalgamate voice, text, and mouse traces highlighting described objects.</li> <li>V7 introduced 66.4M point-level labels on 1.4M images, spanning 5,827 classes.</li> <li>Encompasses 61.4M image-level labels across a diverse set of 20,638 classes.</li> <li>Provides a unified platform for image classification, object detection, relationship detection, instance segmentation, and multimodal image descriptions.</li> </ul>"},{"location":"datasets/detect/open-images-v7/#dataset-structure","title":"Dataset Structure","text":"<p>Open Images V7 is structured in multiple components catering to varied computer vision challenges:</p> <ul> <li>Images: About 9 million images, often showcasing intricate scenes with an average of 8.3 objects per image.</li> <li>Bounding Boxes: Over 16 million boxes that demarcate objects across 600 categories.</li> <li>Segmentation Masks: These detail the exact boundary of 2.8M objects across 350 classes.</li> <li>Visual Relationships: 3.3M annotations indicating object relationships, properties, and actions.</li> <li>Localized Narratives: 675k descriptions combining voice, text, and mouse traces.</li> <li>Point-Level Labels: 66.4M labels across 1.4M images, suitable for zero/few-shot semantic segmentation.</li> </ul>"},{"location":"datasets/detect/open-images-v7/#applications","title":"Applications","text":"<p>Open Images V7 is a cornerstone for training and evaluating state-of-the-art models in various computer vision tasks. The dataset's broad scope and high-quality annotations make it indispensable for researchers and developers specializing in computer vision.</p>"},{"location":"datasets/detect/open-images-v7/#dataset-yaml","title":"Dataset YAML","text":"<p>Typically, datasets come with a YAML (Yet Another Markup Language) file that delineates the dataset's configuration. For the case of Open Images V7, a hypothetical <code>OpenImagesV7.yaml</code> might exist. For accurate paths and configurations, one should refer to the dataset's official repository or documentation.</p> <p>OpenImagesV7.yaml</p> <pre><code># Ultralytics YOLO \ud83d\ude80, AGPL-3.0 license\n# Open Images v7 dataset https://storage.googleapis.com/openimages/web/index.html by Google\n# Documentation: https://docs.ultralytics.com/datasets/detect/open-images-v7/\n# Example usage: yolo train data=open-images-v7.yaml\n# parent\n# \u251c\u2500\u2500 ultralytics\n# \u2514\u2500\u2500 datasets\n#     \u2514\u2500\u2500 open-images-v7  \u2190 downloads here (561 GB)\n\n\n# Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]\npath: ../datasets/open-images-v7  # dataset root dir\ntrain: images/train  # train images (relative to 'path') 1743042 images\nval: images/val  # val images (relative to 'path') 41620 images\ntest:  # test images (optional)\n\n# Classes\nnames:\n  0: Accordion\n  1: Adhesive tape\n  2: Aircraft\n  3: Airplane\n  4: Alarm clock\n  5: Alpaca\n  6: Ambulance\n  7: Animal\n  8: Ant\n  9: Antelope\n  10: Apple\n  11: Armadillo\n  12: Artichoke\n  13: Auto part\n  14: Axe\n  15: Backpack\n  16: Bagel\n  17: Baked goods\n  18: Balance beam\n  19: Ball\n  20: Balloon\n  21: Banana\n  22: Band-aid\n  23: Banjo\n  24: Barge\n  25: Barrel\n  26: Baseball bat\n  27: Baseball glove\n  28: Bat (Animal)\n  29: Bathroom accessory\n  30: Bathroom cabinet\n  31: Bathtub\n  32: Beaker\n  33: Bear\n  34: Bed\n  35: Bee\n  36: Beehive\n  37: Beer\n  38: Beetle\n  39: Bell pepper\n  40: Belt\n  41: Bench\n  42: Bicycle\n  43: Bicycle helmet\n  44: Bicycle wheel\n  45: Bidet\n  46: Billboard\n  47: Billiard table\n  48: Binoculars\n  49: Bird\n  50: Blender\n  51: Blue jay\n  52: Boat\n  53: Bomb\n  54: Book\n  55: Bookcase\n  56: Boot\n  57: Bottle\n  58: Bottle opener\n  59: Bow and arrow\n  60: Bowl\n  61: Bowling equipment\n  62: Box\n  63: Boy\n  64: Brassiere\n  65: Bread\n  66: Briefcase\n  67: Broccoli\n  68: Bronze sculpture\n  69: Brown bear\n  70: Building\n  71: Bull\n  72: Burrito\n  73: Bus\n  74: Bust\n  75: Butterfly\n  76: Cabbage\n  77: Cabinetry\n  78: Cake\n  79: Cake stand\n  80: Calculator\n  81: Camel\n  82: Camera\n  83: Can opener\n  84: Canary\n  85: Candle\n  86: Candy\n  87: Cannon\n  88: Canoe\n  89: Cantaloupe\n  90: Car\n  91: Carnivore\n  92: Carrot\n  93: Cart\n  94: Cassette deck\n  95: Castle\n  96: Cat\n  97: Cat furniture\n  98: Caterpillar\n  99: Cattle\n  100: Ceiling fan\n  101: Cello\n  102: Centipede\n  103: Chainsaw\n  104: Chair\n  105: Cheese\n  106: Cheetah\n  107: Chest of drawers\n  108: Chicken\n  109: Chime\n  110: Chisel\n  111: Chopsticks\n  112: Christmas tree\n  113: Clock\n  114: Closet\n  115: Clothing\n  116: Coat\n  117: Cocktail\n  118: Cocktail shaker\n  119: Coconut\n  120: Coffee\n  121: Coffee cup\n  122: Coffee table\n  123: Coffeemaker\n  124: Coin\n  125: Common fig\n  126: Common sunflower\n  127: Computer keyboard\n  128: Computer monitor\n  129: Computer mouse\n  130: Container\n  131: Convenience store\n  132: Cookie\n  133: Cooking spray\n  134: Corded phone\n  135: Cosmetics\n  136: Couch\n  137: Countertop\n  138: Cowboy hat\n  139: Crab\n  140: Cream\n  141: Cricket ball\n  142: Crocodile\n  143: Croissant\n  144: Crown\n  145: Crutch\n  146: Cucumber\n  147: Cupboard\n  148: Curtain\n  149: Cutting board\n  150: Dagger\n  151: Dairy Product\n  152: Deer\n  153: Desk\n  154: Dessert\n  155: Diaper\n  156: Dice\n  157: Digital clock\n  158: Dinosaur\n  159: Dishwasher\n  160: Dog\n  161: Dog bed\n  162: Doll\n  163: Dolphin\n  164: Door\n  165: Door handle\n  166: Doughnut\n  167: Dragonfly\n  168: Drawer\n  169: Dress\n  170: Drill (Tool)\n  171: Drink\n  172: Drinking straw\n  173: Drum\n  174: Duck\n  175: Dumbbell\n  176: Eagle\n  177: Earrings\n  178: Egg (Food)\n  179: Elephant\n  180: Envelope\n  181: Eraser\n  182: Face powder\n  183: Facial tissue holder\n  184: Falcon\n  185: Fashion accessory\n  186: Fast food\n  187: Fax\n  188: Fedora\n  189: Filing cabinet\n  190: Fire hydrant\n  191: Fireplace\n  192: Fish\n  193: Flag\n  194: Flashlight\n  195: Flower\n  196: Flowerpot\n  197: Flute\n  198: Flying disc\n  199: Food\n  200: Food processor\n  201: Football\n  202: Football helmet\n  203: Footwear\n  204: Fork\n  205: Fountain\n  206: Fox\n  207: French fries\n  208: French horn\n  209: Frog\n  210: Fruit\n  211: Frying pan\n  212: Furniture\n  213: Garden Asparagus\n  214: Gas stove\n  215: Giraffe\n  216: Girl\n  217: Glasses\n  218: Glove\n  219: Goat\n  220: Goggles\n  221: Goldfish\n  222: Golf ball\n  223: Golf cart\n  224: Gondola\n  225: Goose\n  226: Grape\n  227: Grapefruit\n  228: Grinder\n  229: Guacamole\n  230: Guitar\n  231: Hair dryer\n  232: Hair spray\n  233: Hamburger\n  234: Hammer\n  235: Hamster\n  236: Hand dryer\n  237: Handbag\n  238: Handgun\n  239: Harbor seal\n  240: Harmonica\n  241: Harp\n  242: Harpsichord\n  243: Hat\n  244: Headphones\n  245: Heater\n  246: Hedgehog\n  247: Helicopter\n  248: Helmet\n  249: High heels\n  250: Hiking equipment\n  251: Hippopotamus\n  252: Home appliance\n  253: Honeycomb\n  254: Horizontal bar\n  255: Horse\n  256: Hot dog\n  257: House\n  258: Houseplant\n  259: Human arm\n  260: Human beard\n  261: Human body\n  262: Human ear\n  263: Human eye\n  264: Human face\n  265: Human foot\n  266: Human hair\n  267: Human hand\n  268: Human head\n  269: Human leg\n  270: Human mouth\n  271: Human nose\n  272: Humidifier\n  273: Ice cream\n  274: Indoor rower\n  275: Infant bed\n  276: Insect\n  277: Invertebrate\n  278: Ipod\n  279: Isopod\n  280: Jacket\n  281: Jacuzzi\n  282: Jaguar (Animal)\n  283: Jeans\n  284: Jellyfish\n  285: Jet ski\n  286: Jug\n  287: Juice\n  288: Kangaroo\n  289: Kettle\n  290: Kitchen &amp; dining room table\n  291: Kitchen appliance\n  292: Kitchen knife\n  293: Kitchen utensil\n  294: Kitchenware\n  295: Kite\n  296: Knife\n  297: Koala\n  298: Ladder\n  299: Ladle\n  300: Ladybug\n  301: Lamp\n  302: Land vehicle\n  303: Lantern\n  304: Laptop\n  305: Lavender (Plant)\n  306: Lemon\n  307: Leopard\n  308: Light bulb\n  309: Light switch\n  310: Lighthouse\n  311: Lily\n  312: Limousine\n  313: Lion\n  314: Lipstick\n  315: Lizard\n  316: Lobster\n  317: Loveseat\n  318: Luggage and bags\n  319: Lynx\n  320: Magpie\n  321: Mammal\n  322: Man\n  323: Mango\n  324: Maple\n  325: Maracas\n  326: Marine invertebrates\n  327: Marine mammal\n  328: Measuring cup\n  329: Mechanical fan\n  330: Medical equipment\n  331: Microphone\n  332: Microwave oven\n  333: Milk\n  334: Miniskirt\n  335: Mirror\n  336: Missile\n  337: Mixer\n  338: Mixing bowl\n  339: Mobile phone\n  340: Monkey\n  341: Moths and butterflies\n  342: Motorcycle\n  343: Mouse\n  344: Muffin\n  345: Mug\n  346: Mule\n  347: Mushroom\n  348: Musical instrument\n  349: Musical keyboard\n  350: Nail (Construction)\n  351: Necklace\n  352: Nightstand\n  353: Oboe\n  354: Office building\n  355: Office supplies\n  356: Orange\n  357: Organ (Musical Instrument)\n  358: Ostrich\n  359: Otter\n  360: Oven\n  361: Owl\n  362: Oyster\n  363: Paddle\n  364: Palm tree\n  365: Pancake\n  366: Panda\n  367: Paper cutter\n  368: Paper towel\n  369: Parachute\n  370: Parking meter\n  371: Parrot\n  372: Pasta\n  373: Pastry\n  374: Peach\n  375: Pear\n  376: Pen\n  377: Pencil case\n  378: Pencil sharpener\n  379: Penguin\n  380: Perfume\n  381: Person\n  382: Personal care\n  383: Personal flotation device\n  384: Piano\n  385: Picnic basket\n  386: Picture frame\n  387: Pig\n  388: Pillow\n  389: Pineapple\n  390: Pitcher (Container)\n  391: Pizza\n  392: Pizza cutter\n  393: Plant\n  394: Plastic bag\n  395: Plate\n  396: Platter\n  397: Plumbing fixture\n  398: Polar bear\n  399: Pomegranate\n  400: Popcorn\n  401: Porch\n  402: Porcupine\n  403: Poster\n  404: Potato\n  405: Power plugs and sockets\n  406: Pressure cooker\n  407: Pretzel\n  408: Printer\n  409: Pumpkin\n  410: Punching bag\n  411: Rabbit\n  412: Raccoon\n  413: Racket\n  414: Radish\n  415: Ratchet (Device)\n  416: Raven\n  417: Rays and skates\n  418: Red panda\n  419: Refrigerator\n  420: Remote control\n  421: Reptile\n  422: Rhinoceros\n  423: Rifle\n  424: Ring binder\n  425: Rocket\n  426: Roller skates\n  427: Rose\n  428: Rugby ball\n  429: Ruler\n  430: Salad\n  431: Salt and pepper shakers\n  432: Sandal\n  433: Sandwich\n  434: Saucer\n  435: Saxophone\n  436: Scale\n  437: Scarf\n  438: Scissors\n  439: Scoreboard\n  440: Scorpion\n  441: Screwdriver\n  442: Sculpture\n  443: Sea lion\n  444: Sea turtle\n  445: Seafood\n  446: Seahorse\n  447: Seat belt\n  448: Segway\n  449: Serving tray\n  450: Sewing machine\n  451: Shark\n  452: Sheep\n  453: Shelf\n  454: Shellfish\n  455: Shirt\n  456: Shorts\n  457: Shotgun\n  458: Shower\n  459: Shrimp\n  460: Sink\n  461: Skateboard\n  462: Ski\n  463: Skirt\n  464: Skull\n  465: Skunk\n  466: Skyscraper\n  467: Slow cooker\n  468: Snack\n  469: Snail\n  470: Snake\n  471: Snowboard\n  472: Snowman\n  473: Snowmobile\n  474: Snowplow\n  475: Soap dispenser\n  476: Sock\n  477: Sofa bed\n  478: Sombrero\n  479: Sparrow\n  480: Spatula\n  481: Spice rack\n  482: Spider\n  483: Spoon\n  484: Sports equipment\n  485: Sports uniform\n  486: Squash (Plant)\n  487: Squid\n  488: Squirrel\n  489: Stairs\n  490: Stapler\n  491: Starfish\n  492: Stationary bicycle\n  493: Stethoscope\n  494: Stool\n  495: Stop sign\n  496: Strawberry\n  497: Street light\n  498: Stretcher\n  499: Studio couch\n  500: Submarine\n  501: Submarine sandwich\n  502: Suit\n  503: Suitcase\n  504: Sun hat\n  505: Sunglasses\n  506: Surfboard\n  507: Sushi\n  508: Swan\n  509: Swim cap\n  510: Swimming pool\n  511: Swimwear\n  512: Sword\n  513: Syringe\n  514: Table\n  515: Table tennis racket\n  516: Tablet computer\n  517: Tableware\n  518: Taco\n  519: Tank\n  520: Tap\n  521: Tart\n  522: Taxi\n  523: Tea\n  524: Teapot\n  525: Teddy bear\n  526: Telephone\n  527: Television\n  528: Tennis ball\n  529: Tennis racket\n  530: Tent\n  531: Tiara\n  532: Tick\n  533: Tie\n  534: Tiger\n  535: Tin can\n  536: Tire\n  537: Toaster\n  538: Toilet\n  539: Toilet paper\n  540: Tomato\n  541: Tool\n  542: Toothbrush\n  543: Torch\n  544: Tortoise\n  545: Towel\n  546: Tower\n  547: Toy\n  548: Traffic light\n  549: Traffic sign\n  550: Train\n  551: Training bench\n  552: Treadmill\n  553: Tree\n  554: Tree house\n  555: Tripod\n  556: Trombone\n  557: Trousers\n  558: Truck\n  559: Trumpet\n  560: Turkey\n  561: Turtle\n  562: Umbrella\n  563: Unicycle\n  564: Van\n  565: Vase\n  566: Vegetable\n  567: Vehicle\n  568: Vehicle registration plate\n  569: Violin\n  570: Volleyball (Ball)\n  571: Waffle\n  572: Waffle iron\n  573: Wall clock\n  574: Wardrobe\n  575: Washing machine\n  576: Waste container\n  577: Watch\n  578: Watercraft\n  579: Watermelon\n  580: Weapon\n  581: Whale\n  582: Wheel\n  583: Wheelchair\n  584: Whisk\n  585: Whiteboard\n  586: Willow\n  587: Window\n  588: Window blind\n  589: Wine\n  590: Wine glass\n  591: Wine rack\n  592: Winter melon\n  593: Wok\n  594: Woman\n  595: Wood-burning stove\n  596: Woodpecker\n  597: Worm\n  598: Wrench\n  599: Zebra\n  600: Zucchini\n\n\n# Download script/URL (optional) ---------------------------------------------------------------------------------------\ndownload: |\n  from ultralytics.utils import LOGGER, SETTINGS, Path, is_ubuntu, get_ubuntu_version\n  from ultralytics.utils.checks import check_requirements, check_version\n\n  check_requirements('fiftyone')\n  if is_ubuntu() and check_version(get_ubuntu_version(), '&gt;=22.04'):\n      # Ubuntu&gt;=22.04 patch https://github.com/voxel51/fiftyone/issues/2961#issuecomment-1666519347\n      check_requirements('fiftyone-db-ubuntu2204')\n\n  import fiftyone as fo\n  import fiftyone.zoo as foz\n  import warnings\n\n  name = 'open-images-v7'\n  fraction = 1.0  # fraction of full dataset to use\n  LOGGER.warning('WARNING \u26a0\ufe0f Open Images V7 dataset requires at least **561 GB of free space. Starting download...')\n  for split in 'train', 'validation':  # 1743042 train, 41620 val images\n      train = split == 'train'\n\n      # Load Open Images dataset\n      dataset = foz.load_zoo_dataset(name,\n                                     split=split,\n                                     label_types=['detections'],\n                                     dataset_dir=Path(SETTINGS['datasets_dir']) / 'fiftyone' / name,\n                                     max_samples=round((1743042 if train else 41620) * fraction))\n\n      # Define classes\n      if train:\n          classes = dataset.default_classes  # all classes\n          # classes = dataset.distinct('ground_truth.detections.label')  # only observed classes\n\n      # Export to YOLO format\n      with warnings.catch_warnings():\n          warnings.filterwarnings(\"ignore\", category=UserWarning, module=\"fiftyone.utils.yolo\")\n          dataset.export(export_dir=str(Path(SETTINGS['datasets_dir']) / name),\n                         dataset_type=fo.types.YOLOv5Dataset,\n                         label_field='ground_truth',\n                         split='val' if split == 'validation' else split,\n                         classes=classes,\n                         overwrite=train)\n</code></pre>"},{"location":"datasets/detect/open-images-v7/#usage","title":"Usage","text":"<p>To train a YOLOv8n model on the Open Images V7 dataset for 100 epochs with an image size of 640, you can use the following code snippets. For a comprehensive list of available arguments, refer to the model Training page.</p> <p>Warning</p> <p>The complete Open Images V7 dataset comprises 1,743,042 training images and 41,620 validation images, requiring approximately 561 GB of storage space upon download.</p> <p>Executing the commands provided below will trigger an automatic download of the full dataset if it's not already present locally. Before running the below example it's crucial to:</p> <ul> <li>Verify that your device has enough storage capacity.</li> <li>Ensure a robust and speedy internet connection.</li> </ul> <p>Train Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a COCO-pretrained YOLOv8n model\nmodel = YOLO('yolov8n.pt')\n\n# Train the model on the Open Images V7 dataset\nresults = model.train(data='open-images-v7.yaml', epochs=100, imgsz=640)\n</code></pre> <pre><code># Train a COCO-pretrained YOLOv8n model on the Open Images V7 dataset\nyolo detect train data=open-images-v7.yaml model=yolov8n.pt epochs=100 imgsz=640\n</code></pre>"},{"location":"datasets/detect/open-images-v7/#sample-data-and-annotations","title":"Sample Data and Annotations","text":"<p>Illustrations of the dataset help provide insights into its richness:</p> <p></p> <ul> <li>Open Images V7: This image exemplifies the depth and detail of annotations available, including bounding boxes, relationships, and segmentation masks.</li> </ul> <p>Researchers can gain invaluable insights into the array of computer vision challenges that the dataset addresses, from basic object detection to intricate relationship identification.</p>"},{"location":"datasets/detect/open-images-v7/#citations-and-acknowledgments","title":"Citations and Acknowledgments","text":"<p>For those employing Open Images V7 in their work, it's prudent to cite the relevant papers and acknowledge the creators:</p> BibTeX <pre><code>@article{OpenImages,\n  author = {Alina Kuznetsova and Hassan Rom and Neil Alldrin and Jasper Uijlings and Ivan Krasin and Jordi Pont-Tuset and Shahab Kamali and Stefan Popov and Matteo Malloci and Alexander Kolesnikov and Tom Duerig and Vittorio Ferrari},\n  title = {The Open Images Dataset V4: Unified image classification, object detection, and visual relationship detection at scale},\n  year = {2020},\n  journal = {IJCV}\n}\n</code></pre> <p>A heartfelt acknowledgment goes out to the Google AI team for creating and maintaining the Open Images V7 dataset. For a deep dive into the dataset and its offerings, navigate to the official Open Images V7 website.</p>"},{"location":"datasets/detect/sku-110k/","title":"SKU-110k Dataset","text":"<p>The SKU-110k dataset is a collection of densely packed retail shelf images, designed to support research in object detection tasks. Developed by Eran Goldman et al., the dataset contains over 110,000 unique store keeping unit (SKU) categories with densely packed objects, often looking similar or even identical, positioned in close proximity.</p> <p></p>"},{"location":"datasets/detect/sku-110k/#key-features","title":"Key Features","text":"<ul> <li>SKU-110k contains images of store shelves from around the world, featuring densely packed objects that pose challenges for state-of-the-art object detectors.</li> <li>The dataset includes over 110,000 unique SKU categories, providing a diverse range of object appearances.</li> <li>Annotations include bounding boxes for objects and SKU category labels.</li> </ul>"},{"location":"datasets/detect/sku-110k/#dataset-structure","title":"Dataset Structure","text":"<p>The SKU-110k dataset is organized into three main subsets:</p> <ol> <li>Training set: This subset contains images and annotations used for training object detection models.</li> <li>Validation set: This subset consists of images and annotations used for model validation during training.</li> <li>Test set: This subset is designed for the final evaluation of trained object detection models.</li> </ol>"},{"location":"datasets/detect/sku-110k/#applications","title":"Applications","text":"<p>The SKU-110k dataset is widely used for training and evaluating deep learning models in object detection tasks, especially in densely packed scenes such as retail shelf displays. The dataset's diverse set of SKU categories and densely packed object arrangements make it a valuable resource for researchers and practitioners in the field of computer vision.</p>"},{"location":"datasets/detect/sku-110k/#dataset-yaml","title":"Dataset YAML","text":"<p>A YAML (Yet Another Markup Language) file is used to define the dataset configuration. It contains information about the dataset's paths, classes, and other relevant information. For the case of the SKU-110K dataset, the <code>SKU-110K.yaml</code> file is maintained at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/cfg/datasets/SKU-110K.yaml.</p> <p>ultralytics/cfg/datasets/SKU-110K.yaml</p> <pre><code># Ultralytics YOLO \ud83d\ude80, AGPL-3.0 license\n# SKU-110K retail items dataset https://github.com/eg4000/SKU110K_CVPR19 by Trax Retail\n# Documentation: https://docs.ultralytics.com/datasets/detect/sku-110k/\n# Example usage: yolo train data=SKU-110K.yaml\n# parent\n# \u251c\u2500\u2500 ultralytics\n# \u2514\u2500\u2500 datasets\n#     \u2514\u2500\u2500 SKU-110K  \u2190 downloads here (13.6 GB)\n\n\n# Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]\npath: ../datasets/SKU-110K  # dataset root dir\ntrain: train.txt  # train images (relative to 'path')  8219 images\nval: val.txt  # val images (relative to 'path')  588 images\ntest: test.txt  # test images (optional)  2936 images\n\n# Classes\nnames:\n  0: object\n\n\n# Download script/URL (optional) ---------------------------------------------------------------------------------------\ndownload: |\n  import shutil\n  from pathlib import Path\n\n  import numpy as np\n  import pandas as pd\n  from tqdm import tqdm\n\n  from ultralytics.utils.downloads import download\n  from ultralytics.utils.ops import xyxy2xywh\n\n  # Download\n  dir = Path(yaml['path'])  # dataset root dir\n  parent = Path(dir.parent)  # download dir\n  urls = ['http://trax-geometry.s3.amazonaws.com/cvpr_challenge/SKU110K_fixed.tar.gz']\n  download(urls, dir=parent)\n\n  # Rename directories\n  if dir.exists():\n      shutil.rmtree(dir)\n  (parent / 'SKU110K_fixed').rename(dir)  # rename dir\n  (dir / 'labels').mkdir(parents=True, exist_ok=True)  # create labels dir\n\n  # Convert labels\n  names = 'image', 'x1', 'y1', 'x2', 'y2', 'class', 'image_width', 'image_height'  # column names\n  for d in 'annotations_train.csv', 'annotations_val.csv', 'annotations_test.csv':\n      x = pd.read_csv(dir / 'annotations' / d, names=names).values  # annotations\n      images, unique_images = x[:, 0], np.unique(x[:, 0])\n      with open((dir / d).with_suffix('.txt').__str__().replace('annotations_', ''), 'w') as f:\n          f.writelines(f'./images/{s}\\n' for s in unique_images)\n      for im in tqdm(unique_images, desc=f'Converting {dir / d}'):\n          cls = 0  # single-class dataset\n          with open((dir / 'labels' / im).with_suffix('.txt'), 'a') as f:\n              for r in x[images == im]:\n                  w, h = r[6], r[7]  # image width, height\n                  xywh = xyxy2xywh(np.array([[r[1] / w, r[2] / h, r[3] / w, r[4] / h]]))[0]  # instance\n                  f.write(f\"{cls} {xywh[0]:.5f} {xywh[1]:.5f} {xywh[2]:.5f} {xywh[3]:.5f}\\n\")  # write label\n</code></pre>"},{"location":"datasets/detect/sku-110k/#usage","title":"Usage","text":"<p>To train a YOLOv8n model on the SKU-110K dataset for 100 epochs with an image size of 640, you can use the following code snippets. For a comprehensive list of available arguments, refer to the model Training page.</p> <p>Train Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='SKU-110K.yaml', epochs=100, imgsz=640)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\nyolo detect train data=SKU-110K.yaml model=yolov8n.pt epochs=100 imgsz=640\n</code></pre>"},{"location":"datasets/detect/sku-110k/#sample-data-and-annotations","title":"Sample Data and Annotations","text":"<p>The SKU-110k dataset contains a diverse set of retail shelf images with densely packed objects, providing rich context for object detection tasks. Here are some examples of data from the dataset, along with their corresponding annotations:</p> <p></p> <ul> <li>Densely packed retail shelf image: This image demonstrates an example of densely packed objects in a retail shelf setting. Objects are annotated with bounding boxes and SKU category labels.</li> </ul> <p>The example showcases the variety and complexity of the data in the SKU-110k dataset and highlights the importance of high-quality data for object detection tasks.</p>"},{"location":"datasets/detect/sku-110k/#citations-and-acknowledgments","title":"Citations and Acknowledgments","text":"<p>If you use the SKU-110k dataset in your research or development work, please cite the following paper:</p> BibTeX <pre><code>@inproceedings{goldman2019dense,\n author    = {Eran Goldman and Roei Herzig and Aviv Eisenschtat and Jacob Goldberger and Tal Hassner},\n title     = {Precise Detection in Densely Packed Scenes},\n booktitle = {Proc. Conf. Comput. Vision Pattern Recognition (CVPR)},\n year      = {2019}\n}\n</code></pre> <p>We would like to acknowledge Eran Goldman et al. for creating and maintaining the SKU-110k dataset as a valuable resource for the computer vision research community. For more information about the SKU-110k dataset and its creators, visit the SKU-110k dataset GitHub repository.</p>"},{"location":"datasets/detect/visdrone/","title":"VisDrone Dataset","text":"<p>The VisDrone Dataset is a large-scale benchmark created by the AISKYEYE team at the Lab of Machine Learning and Data Mining, Tianjin University, China. It contains carefully annotated ground truth data for various computer vision tasks related to drone-based image and video analysis.</p> <p>VisDrone is composed of 288 video clips with 261,908 frames and 10,209 static images, captured by various drone-mounted cameras. The dataset covers a wide range of aspects, including location (14 different cities across China), environment (urban and rural), objects (pedestrians, vehicles, bicycles, etc.), and density (sparse and crowded scenes). The dataset was collected using various drone platforms under different scenarios and weather and lighting conditions. These frames are manually annotated with over 2.6 million bounding boxes of targets such as pedestrians, cars, bicycles, and tricycles. Attributes like scene visibility, object class, and occlusion are also provided for better data utilization.</p>"},{"location":"datasets/detect/visdrone/#dataset-structure","title":"Dataset Structure","text":"<p>The VisDrone dataset is organized into five main subsets, each focusing on a specific task:</p> <ol> <li>Task 1: Object detection in images</li> <li>Task 2: Object detection in videos</li> <li>Task 3: Single-object tracking</li> <li>Task 4: Multi-object tracking</li> <li>Task 5: Crowd counting</li> </ol>"},{"location":"datasets/detect/visdrone/#applications","title":"Applications","text":"<p>The VisDrone dataset is widely used for training and evaluating deep learning models in drone-based computer vision tasks such as object detection, object tracking, and crowd counting. The dataset's diverse set of sensor data, object annotations, and attributes make it a valuable resource for researchers and practitioners in the field of drone-based computer vision.</p>"},{"location":"datasets/detect/visdrone/#dataset-yaml","title":"Dataset YAML","text":"<p>A YAML (Yet Another Markup Language) file is used to define the dataset configuration. It contains information about the dataset's paths, classes, and other relevant information. In the case of the Visdrone dataset, the <code>VisDrone.yaml</code> file is maintained at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/cfg/datasets/VisDrone.yaml.</p> <p>ultralytics/cfg/datasets/VisDrone.yaml</p> <pre><code># Ultralytics YOLO \ud83d\ude80, AGPL-3.0 license\n# VisDrone2019-DET dataset https://github.com/VisDrone/VisDrone-Dataset by Tianjin University\n# Documentation: https://docs.ultralytics.com/datasets/detect/visdrone/\n# Example usage: yolo train data=VisDrone.yaml\n# parent\n# \u251c\u2500\u2500 ultralytics\n# \u2514\u2500\u2500 datasets\n#     \u2514\u2500\u2500 VisDrone  \u2190 downloads here (2.3 GB)\n\n\n# Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]\npath: ../datasets/VisDrone  # dataset root dir\ntrain: VisDrone2019-DET-train/images  # train images (relative to 'path')  6471 images\nval: VisDrone2019-DET-val/images  # val images (relative to 'path')  548 images\ntest: VisDrone2019-DET-test-dev/images  # test images (optional)  1610 images\n\n# Classes\nnames:\n  0: pedestrian\n  1: people\n  2: bicycle\n  3: car\n  4: van\n  5: truck\n  6: tricycle\n  7: awning-tricycle\n  8: bus\n  9: motor\n\n\n# Download script/URL (optional) ---------------------------------------------------------------------------------------\ndownload: |\n  import os\n  from pathlib import Path\n\n  from ultralytics.utils.downloads import download\n\n  def visdrone2yolo(dir):\n      from PIL import Image\n      from tqdm import tqdm\n\n      def convert_box(size, box):\n          # Convert VisDrone box to YOLO xywh box\n          dw = 1. / size[0]\n          dh = 1. / size[1]\n          return (box[0] + box[2] / 2) * dw, (box[1] + box[3] / 2) * dh, box[2] * dw, box[3] * dh\n\n      (dir / 'labels').mkdir(parents=True, exist_ok=True)  # make labels directory\n      pbar = tqdm((dir / 'annotations').glob('*.txt'), desc=f'Converting {dir}')\n      for f in pbar:\n          img_size = Image.open((dir / 'images' / f.name).with_suffix('.jpg')).size\n          lines = []\n          with open(f, 'r') as file:  # read annotation.txt\n              for row in [x.split(',') for x in file.read().strip().splitlines()]:\n                  if row[4] == '0':  # VisDrone 'ignored regions' class 0\n                      continue\n                  cls = int(row[5]) - 1\n                  box = convert_box(img_size, tuple(map(int, row[:4])))\n                  lines.append(f\"{cls} {' '.join(f'{x:.6f}' for x in box)}\\n\")\n                  with open(str(f).replace(f'{os.sep}annotations{os.sep}', f'{os.sep}labels{os.sep}'), 'w') as fl:\n                      fl.writelines(lines)  # write label.txt\n\n\n  # Download\n  dir = Path(yaml['path'])  # dataset root dir\n  urls = ['https://github.com/ultralytics/yolov5/releases/download/v1.0/VisDrone2019-DET-train.zip',\n          'https://github.com/ultralytics/yolov5/releases/download/v1.0/VisDrone2019-DET-val.zip',\n          'https://github.com/ultralytics/yolov5/releases/download/v1.0/VisDrone2019-DET-test-dev.zip',\n          'https://github.com/ultralytics/yolov5/releases/download/v1.0/VisDrone2019-DET-test-challenge.zip']\n  download(urls, dir=dir, curl=True, threads=4)\n\n  # Convert\n  for d in 'VisDrone2019-DET-train', 'VisDrone2019-DET-val', 'VisDrone2019-DET-test-dev':\n      visdrone2yolo(dir / d)  # convert VisDrone annotations to YOLO labels\n</code></pre>"},{"location":"datasets/detect/visdrone/#usage","title":"Usage","text":"<p>To train a YOLOv8n model on the VisDrone dataset for 100 epochs with an image size of 640, you can use the following code snippets. For a comprehensive list of available arguments, refer to the model Training page.</p> <p>Train Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='VisDrone.yaml', epochs=100, imgsz=640)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\nyolo detect train data=VisDrone.yaml model=yolov8n.pt epochs=100 imgsz=640\n</code></pre>"},{"location":"datasets/detect/visdrone/#sample-data-and-annotations","title":"Sample Data and Annotations","text":"<p>The VisDrone dataset contains a diverse set of images and videos captured by drone-mounted cameras. Here are some examples of data from the dataset, along with their corresponding annotations:</p> <p></p> <ul> <li>Task 1: Object detection in images - This image demonstrates an example of object detection in images, where objects are annotated with bounding boxes. The dataset provides a wide variety of images taken from different locations, environments, and densities to facilitate the development of models for this task.</li> </ul> <p>The example showcases the variety and complexity of the data in the VisDrone dataset and highlights the importance of high-quality sensor data for drone-based computer vision tasks.</p>"},{"location":"datasets/detect/visdrone/#citations-and-acknowledgments","title":"Citations and Acknowledgments","text":"<p>If you use the VisDrone dataset in your research or development work, please cite the following paper:</p> BibTeX <pre><code>@ARTICLE{9573394,\n  author={Zhu, Pengfei and Wen, Longyin and Du, Dawei and Bian, Xiao and Fan, Heng and Hu, Qinghua and Ling, Haibin},\n  journal={IEEE Transactions on Pattern Analysis and Machine Intelligence},\n  title={Detection and Tracking Meet Drones Challenge},\n  year={2021},\n  volume={},\n  number={},\n  pages={1-1},\n  doi={10.1109/TPAMI.2021.3119563}}\n</code></pre> <p>We would like to acknowledge the AISKYEYE team at the Lab of Machine Learning and Data Mining, Tianjin University, China, for creating and maintaining the VisDrone dataset as a valuable resource for the drone-based computer vision research community. For more information about the VisDrone dataset and its creators, visit the VisDrone Dataset GitHub repository.</p>"},{"location":"datasets/detect/voc/","title":"VOC Dataset","text":"<p>The PASCAL VOC (Visual Object Classes) dataset is a well-known object detection, segmentation, and classification dataset. It is designed to encourage research on a wide variety of object categories and is commonly used for benchmarking computer vision models. It is an essential dataset for researchers and developers working on object detection, segmentation, and classification tasks.</p>"},{"location":"datasets/detect/voc/#key-features","title":"Key Features","text":"<ul> <li>VOC dataset includes two main challenges: VOC2007 and VOC2012.</li> <li>The dataset comprises 20 object categories, including common objects like cars, bicycles, and animals, as well as more specific categories such as boats, sofas, and dining tables.</li> <li>Annotations include object bounding boxes and class labels for object detection and classification tasks, and segmentation masks for the segmentation tasks.</li> <li>VOC provides standardized evaluation metrics like mean Average Precision (mAP) for object detection and classification, making it suitable for comparing model performance.</li> </ul>"},{"location":"datasets/detect/voc/#dataset-structure","title":"Dataset Structure","text":"<p>The VOC dataset is split into three subsets:</p> <ol> <li>Train: This subset contains images for training object detection, segmentation, and classification models.</li> <li>Validation: This subset has images used for validation purposes during model training.</li> <li>Test: This subset consists of images used for testing and benchmarking the trained models. Ground truth annotations for this subset are not publicly available, and the results are submitted to the PASCAL VOC evaluation server for performance evaluation.</li> </ol>"},{"location":"datasets/detect/voc/#applications","title":"Applications","text":"<p>The VOC dataset is widely used for training and evaluating deep learning models in object detection (such as YOLO, Faster R-CNN, and SSD), instance segmentation (such as Mask R-CNN), and image classification. The dataset's diverse set of object categories, large number of annotated images, and standardized evaluation metrics make it an essential resource for computer vision researchers and practitioners.</p>"},{"location":"datasets/detect/voc/#dataset-yaml","title":"Dataset YAML","text":"<p>A YAML (Yet Another Markup Language) file is used to define the dataset configuration. It contains information about the dataset's paths, classes, and other relevant information. In the case of the VOC dataset, the <code>VOC.yaml</code> file is maintained at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/cfg/datasets/VOC.yaml.</p> <p>ultralytics/cfg/datasets/VOC.yaml</p> <pre><code># Ultralytics YOLO \ud83d\ude80, AGPL-3.0 license\n# PASCAL VOC dataset http://host.robots.ox.ac.uk/pascal/VOC by University of Oxford\n# Documentation: # Documentation: https://docs.ultralytics.com/datasets/detect/voc/\n# Example usage: yolo train data=VOC.yaml\n# parent\n# \u251c\u2500\u2500 ultralytics\n# \u2514\u2500\u2500 datasets\n#     \u2514\u2500\u2500 VOC  \u2190 downloads here (2.8 GB)\n\n\n# Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]\npath: ../datasets/VOC\ntrain: # train images (relative to 'path')  16551 images\n  - images/train2012\n  - images/train2007\n  - images/val2012\n  - images/val2007\nval: # val images (relative to 'path')  4952 images\n  - images/test2007\ntest: # test images (optional)\n  - images/test2007\n\n# Classes\nnames:\n  0: aeroplane\n  1: bicycle\n  2: bird\n  3: boat\n  4: bottle\n  5: bus\n  6: car\n  7: cat\n  8: chair\n  9: cow\n  10: diningtable\n  11: dog\n  12: horse\n  13: motorbike\n  14: person\n  15: pottedplant\n  16: sheep\n  17: sofa\n  18: train\n  19: tvmonitor\n\n\n# Download script/URL (optional) ---------------------------------------------------------------------------------------\ndownload: |\n  import xml.etree.ElementTree as ET\n\n  from tqdm import tqdm\n  from ultralytics.utils.downloads import download\n  from pathlib import Path\n\n  def convert_label(path, lb_path, year, image_id):\n      def convert_box(size, box):\n          dw, dh = 1. / size[0], 1. / size[1]\n          x, y, w, h = (box[0] + box[1]) / 2.0 - 1, (box[2] + box[3]) / 2.0 - 1, box[1] - box[0], box[3] - box[2]\n          return x * dw, y * dh, w * dw, h * dh\n\n      in_file = open(path / f'VOC{year}/Annotations/{image_id}.xml')\n      out_file = open(lb_path, 'w')\n      tree = ET.parse(in_file)\n      root = tree.getroot()\n      size = root.find('size')\n      w = int(size.find('width').text)\n      h = int(size.find('height').text)\n\n      names = list(yaml['names'].values())  # names list\n      for obj in root.iter('object'):\n          cls = obj.find('name').text\n          if cls in names and int(obj.find('difficult').text) != 1:\n              xmlbox = obj.find('bndbox')\n              bb = convert_box((w, h), [float(xmlbox.find(x).text) for x in ('xmin', 'xmax', 'ymin', 'ymax')])\n              cls_id = names.index(cls)  # class id\n              out_file.write(\" \".join(str(a) for a in (cls_id, *bb)) + '\\n')\n\n\n  # Download\n  dir = Path(yaml['path'])  # dataset root dir\n  url = 'https://github.com/ultralytics/yolov5/releases/download/v1.0/'\n  urls = [f'{url}VOCtrainval_06-Nov-2007.zip',  # 446MB, 5012 images\n          f'{url}VOCtest_06-Nov-2007.zip',  # 438MB, 4953 images\n          f'{url}VOCtrainval_11-May-2012.zip']  # 1.95GB, 17126 images\n  download(urls, dir=dir / 'images', curl=True, threads=3, exist_ok=True)  # download and unzip over existing paths (required)\n\n  # Convert\n  path = dir / 'images/VOCdevkit'\n  for year, image_set in ('2012', 'train'), ('2012', 'val'), ('2007', 'train'), ('2007', 'val'), ('2007', 'test'):\n      imgs_path = dir / 'images' / f'{image_set}{year}'\n      lbs_path = dir / 'labels' / f'{image_set}{year}'\n      imgs_path.mkdir(exist_ok=True, parents=True)\n      lbs_path.mkdir(exist_ok=True, parents=True)\n\n      with open(path / f'VOC{year}/ImageSets/Main/{image_set}.txt') as f:\n          image_ids = f.read().strip().split()\n      for id in tqdm(image_ids, desc=f'{image_set}{year}'):\n          f = path / f'VOC{year}/JPEGImages/{id}.jpg'  # old img path\n          lb_path = (lbs_path / f.name).with_suffix('.txt')  # new label path\n          f.rename(imgs_path / f.name)  # move image\n          convert_label(path, lb_path, year, id)  # convert labels to YOLO format\n</code></pre>"},{"location":"datasets/detect/voc/#usage","title":"Usage","text":"<p>To train a YOLOv8n model on the VOC dataset for 100 epochs with an image size of 640, you can use the following code snippets. For a comprehensive list of available arguments, refer to the model Training page.</p> <p>Train Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='VOC.yaml', epochs=100, imgsz=640)\n</code></pre> <pre><code># Start training from\na pretrained *.pt model\nyolo detect train data=VOC.yaml model=yolov8n.pt epochs=100 imgsz=640\n</code></pre>"},{"location":"datasets/detect/voc/#sample-images-and-annotations","title":"Sample Images and Annotations","text":"<p>The VOC dataset contains a diverse set of images with various object categories and complex scenes. Here are some examples of images from the dataset, along with their corresponding annotations:</p> <p></p> <ul> <li>Mosaiced Image: This image demonstrates a training batch composed of mosaiced dataset images. Mosaicing is a technique used during training that combines multiple images into a single image to increase the variety of objects and scenes within each training batch. This helps improve the model's ability to generalize to different object sizes, aspect ratios, and contexts.</li> </ul> <p>The example showcases the variety and complexity of the images in the VOC dataset and the benefits of using mosaicing during the training process.</p>"},{"location":"datasets/detect/voc/#citations-and-acknowledgments","title":"Citations and Acknowledgments","text":"<p>If you use the VOC dataset in your research or development work, please cite the following paper:</p> BibTeX <pre><code>@misc{everingham2010pascal,\n      title={The PASCAL Visual Object Classes (VOC) Challenge},\n      author={Mark Everingham and Luc Van Gool and Christopher K. I. Williams and John Winn and Andrew Zisserman},\n      year={2010},\n      eprint={0909.5206},\n      archivePrefix={arXiv},\n      primaryClass={cs.CV}\n}\n</code></pre> <p>We would like to acknowledge the PASCAL VOC Consortium for creating and maintaining this valuable resource for the computer vision community. For more information about the VOC dataset and its creators, visit the PASCAL VOC dataset website.</p>"},{"location":"datasets/detect/xview/","title":"xView Dataset","text":"<p>The xView dataset is one of the largest publicly available datasets of overhead imagery, containing images from complex scenes around the world annotated using bounding boxes. The goal of the xView dataset is to accelerate progress in four computer vision frontiers:</p> <ol> <li>Reduce minimum resolution for detection.</li> <li>Improve learning efficiency.</li> <li>Enable discovery of more object classes.</li> <li>Improve detection of fine-grained classes.</li> </ol> <p>xView builds on the success of challenges like Common Objects in Context (COCO) and aims to leverage computer vision to analyze the growing amount of available imagery from space in order to understand the visual world in new ways and address a range of important applications.</p>"},{"location":"datasets/detect/xview/#key-features","title":"Key Features","text":"<ul> <li>xView contains over 1 million object instances across 60 classes.</li> <li>The dataset has a resolution of 0.3 meters, providing higher resolution imagery than most public satellite imagery datasets.</li> <li>xView features a diverse collection of small, rare, fine-grained, and multi-type objects with bounding box annotation.</li> <li>Comes with a pre-trained baseline model using the TensorFlow object detection API and an example for PyTorch.</li> </ul>"},{"location":"datasets/detect/xview/#dataset-structure","title":"Dataset Structure","text":"<p>The xView dataset is composed of satellite images collected from WorldView-3 satellites at a 0.3m ground sample distance. It contains over 1 million objects across 60 classes in over 1,400 km\u00b2 of imagery.</p>"},{"location":"datasets/detect/xview/#applications","title":"Applications","text":"<p>The xView dataset is widely used for training and evaluating deep learning models for object detection in overhead imagery. The dataset's diverse set of object classes and high-resolution imagery make it a valuable resource for researchers and practitioners in the field of computer vision, especially for satellite imagery analysis.</p>"},{"location":"datasets/detect/xview/#dataset-yaml","title":"Dataset YAML","text":"<p>A YAML (Yet Another Markup Language) file is used to define the dataset configuration. It contains information about the dataset's paths, classes, and other relevant information. In the case of the xView dataset, the <code>xView.yaml</code> file is maintained at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/cfg/datasets/xView.yaml.</p> <p>ultralytics/cfg/datasets/xView.yaml</p> <pre><code># Ultralytics YOLO \ud83d\ude80, AGPL-3.0 license\n# DIUx xView 2018 Challenge https://challenge.xviewdataset.org by U.S. National Geospatial-Intelligence Agency (NGA)\n# --------  DOWNLOAD DATA MANUALLY and jar xf val_images.zip to 'datasets/xView' before running train command!  --------\n# Documentation: https://docs.ultralytics.com/datasets/detect/xview/\n# Example usage: yolo train data=xView.yaml\n# parent\n# \u251c\u2500\u2500 ultralytics\n# \u2514\u2500\u2500 datasets\n#     \u2514\u2500\u2500 xView  \u2190 downloads here (20.7 GB)\n\n\n# Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]\npath: ../datasets/xView  # dataset root dir\ntrain: images/autosplit_train.txt  # train images (relative to 'path') 90% of 847 train images\nval: images/autosplit_val.txt  # train images (relative to 'path') 10% of 847 train images\n\n# Classes\nnames:\n  0: Fixed-wing Aircraft\n  1: Small Aircraft\n  2: Cargo Plane\n  3: Helicopter\n  4: Passenger Vehicle\n  5: Small Car\n  6: Bus\n  7: Pickup Truck\n  8: Utility Truck\n  9: Truck\n  10: Cargo Truck\n  11: Truck w/Box\n  12: Truck Tractor\n  13: Trailer\n  14: Truck w/Flatbed\n  15: Truck w/Liquid\n  16: Crane Truck\n  17: Railway Vehicle\n  18: Passenger Car\n  19: Cargo Car\n  20: Flat Car\n  21: Tank car\n  22: Locomotive\n  23: Maritime Vessel\n  24: Motorboat\n  25: Sailboat\n  26: Tugboat\n  27: Barge\n  28: Fishing Vessel\n  29: Ferry\n  30: Yacht\n  31: Container Ship\n  32: Oil Tanker\n  33: Engineering Vehicle\n  34: Tower crane\n  35: Container Crane\n  36: Reach Stacker\n  37: Straddle Carrier\n  38: Mobile Crane\n  39: Dump Truck\n  40: Haul Truck\n  41: Scraper/Tractor\n  42: Front loader/Bulldozer\n  43: Excavator\n  44: Cement Mixer\n  45: Ground Grader\n  46: Hut/Tent\n  47: Shed\n  48: Building\n  49: Aircraft Hangar\n  50: Damaged Building\n  51: Facility\n  52: Construction Site\n  53: Vehicle Lot\n  54: Helipad\n  55: Storage Tank\n  56: Shipping container lot\n  57: Shipping Container\n  58: Pylon\n  59: Tower\n\n\n# Download script/URL (optional) ---------------------------------------------------------------------------------------\ndownload: |\n  import json\n  import os\n  from pathlib import Path\n\n  import numpy as np\n  from PIL import Image\n  from tqdm import tqdm\n\n  from ultralytics.data.utils import autosplit\n  from ultralytics.utils.ops import xyxy2xywhn\n\n\n  def convert_labels(fname=Path('xView/xView_train.geojson')):\n      # Convert xView geoJSON labels to YOLO format\n      path = fname.parent\n      with open(fname) as f:\n          print(f'Loading {fname}...')\n          data = json.load(f)\n\n      # Make dirs\n      labels = Path(path / 'labels' / 'train')\n      os.system(f'rm -rf {labels}')\n      labels.mkdir(parents=True, exist_ok=True)\n\n      # xView classes 11-94 to 0-59\n      xview_class2index = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, -1, 3, -1, 4, 5, 6, 7, 8, -1, 9, 10, 11,\n                           12, 13, 14, 15, -1, -1, 16, 17, 18, 19, 20, 21, 22, -1, 23, 24, 25, -1, 26, 27, -1, 28, -1,\n                           29, 30, 31, 32, 33, 34, 35, 36, 37, -1, 38, 39, 40, 41, 42, 43, 44, 45, -1, -1, -1, -1, 46,\n                           47, 48, 49, -1, 50, 51, -1, 52, -1, -1, -1, 53, 54, -1, 55, -1, -1, 56, -1, 57, -1, 58, 59]\n\n      shapes = {}\n      for feature in tqdm(data['features'], desc=f'Converting {fname}'):\n          p = feature['properties']\n          if p['bounds_imcoords']:\n              id = p['image_id']\n              file = path / 'train_images' / id\n              if file.exists():  # 1395.tif missing\n                  try:\n                      box = np.array([int(num) for num in p['bounds_imcoords'].split(\",\")])\n                      assert box.shape[0] == 4, f'incorrect box shape {box.shape[0]}'\n                      cls = p['type_id']\n                      cls = xview_class2index[int(cls)]  # xView class to 0-60\n                      assert 59 &gt;= cls &gt;= 0, f'incorrect class index {cls}'\n\n                      # Write YOLO label\n                      if id not in shapes:\n                          shapes[id] = Image.open(file).size\n                      box = xyxy2xywhn(box[None].astype(np.float), w=shapes[id][0], h=shapes[id][1], clip=True)\n                      with open((labels / id).with_suffix('.txt'), 'a') as f:\n                          f.write(f\"{cls} {' '.join(f'{x:.6f}' for x in box[0])}\\n\")  # write label.txt\n                  except Exception as e:\n                      print(f'WARNING: skipping one label for {file}: {e}')\n\n\n  # Download manually from https://challenge.xviewdataset.org\n  dir = Path(yaml['path'])  # dataset root dir\n  # urls = ['https://d307kc0mrhucc3.cloudfront.net/train_labels.zip',  # train labels\n  #         'https://d307kc0mrhucc3.cloudfront.net/train_images.zip',  # 15G, 847 train images\n  #         'https://d307kc0mrhucc3.cloudfront.net/val_images.zip']  # 5G, 282 val images (no labels)\n  # download(urls, dir=dir)\n\n  # Convert labels\n  convert_labels(dir / 'xView_train.geojson')\n\n  # Move images\n  images = Path(dir / 'images')\n  images.mkdir(parents=True, exist_ok=True)\n  Path(dir / 'train_images').rename(dir / 'images' / 'train')\n  Path(dir / 'val_images').rename(dir / 'images' / 'val')\n\n  # Split\n  autosplit(dir / 'images' / 'train')\n</code></pre>"},{"location":"datasets/detect/xview/#usage","title":"Usage","text":"<p>To train a model on the xView dataset for 100 epochs with an image size of 640, you can use the following code snippets. For a comprehensive list of available arguments, refer to the model Training page.</p> <p>Train Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='xView.yaml', epochs=100, imgsz=640)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\nyolo detect train data=xView.yaml model=yolov8n.pt epochs=100 imgsz=640\n</code></pre>"},{"location":"datasets/detect/xview/#sample-data-and-annotations","title":"Sample Data and Annotations","text":"<p>The xView dataset contains high-resolution satellite images with a diverse set of objects annotated using bounding boxes. Here are some examples of data from the dataset, along with their corresponding annotations:</p> <p></p> <ul> <li>Overhead Imagery: This image demonstrates an example of object detection in overhead imagery, where objects are annotated with bounding boxes. The dataset provides high-resolution satellite images to facilitate the development of models for this task.</li> </ul> <p>The example showcases the variety and complexity of the data in the xView dataset and highlights the importance of high-quality satellite imagery for object detection tasks.</p>"},{"location":"datasets/detect/xview/#citations-and-acknowledgments","title":"Citations and Acknowledgments","text":"<p>If you use the xView dataset in your research or development work, please cite the following paper:</p> BibTeX <pre><code>@misc{lam2018xview,\n      title={xView: Objects in Context in Overhead Imagery},\n      author={Darius Lam and Richard Kuzma and Kevin McGee and Samuel Dooley and Michael Laielli and Matthew Klaric and Yaroslav Bulatov and Brendan McCord},\n      year={2018},\n      eprint={1802.07856},\n      archivePrefix={arXiv},\n      primaryClass={cs.CV}\n}\n</code></pre> <p>We would like to acknowledge the Defense Innovation Unit (DIU) and the creators of the xView dataset for their valuable contribution to the computer vision research community. For more information about the xView dataset and its creators, visit the xView dataset website.</p>"},{"location":"datasets/explorer/","title":"Ultralytics Explorer","text":"<p>Ultralytics Explorer is a tool for exploring CV datasets using semantic search, SQL queries, vector similarity search and even using natural language. It is also a Python API for accessing the same functionality.</p>"},{"location":"datasets/explorer/#installation-of-optional-dependencies","title":"Installation of optional dependencies","text":"<p>Explorer depends on external libraries for some of its functionality. These are automatically installed on usage. To manually install these dependencies, use the following command:</p> <pre><code>pip install ultralytics[explorer]\n</code></pre>"},{"location":"datasets/explorer/#explorer-api","title":"Explorer API","text":"<p>This is a Python API for Exploring your datasets. It also powers the GUI Explorer. You can use this to create your own exploratory notebooks or scripts to get insights into your datasets.</p> <p>Learn more about the Explorer API here.</p>"},{"location":"datasets/explorer/#gui-explorer-usage","title":"GUI Explorer Usage","text":"<p>The GUI demo runs in your browser allowing you to create embeddings for your dataset and search for similar images, run SQL queries and perform semantic search. It can be run using the following command:</p> <pre><code>yolo explorer\n</code></pre> <p>Note</p> <p>Ask AI feature works using OpenAI, so you'll be prompted to set the api key for OpenAI when you first run the GUI. You can set it like this - <code>yolo settings openai_api_key=\"...\"</code></p>"},{"location":"datasets/explorer/api/","title":"Ultralytics Explorer API","text":""},{"location":"datasets/explorer/api/#introduction","title":"Introduction","text":"<p>The Explorer API is a Python API for exploring your datasets. It supports filtering and searching your dataset using SQL queries, vector similarity search and semantic search.</p>"},{"location":"datasets/explorer/api/#installation","title":"Installation","text":"<p>Explorer depends on external libraries for some of its functionality. These are automatically installed on usage. To manually install these dependencies, use the following command:</p> <pre><code>pip install ultralytics[explorer]\n</code></pre>"},{"location":"datasets/explorer/api/#usage","title":"Usage","text":"<pre><code>from ultralytics import Explorer\n\n# Create an Explorer object\nexplorer = Explorer(data='coco128.yaml', model='yolov8n.pt')\n\n# Create embeddings for your dataset\nexplorer.create_embeddings_table()\n\n# Search for similar images to a given image/images\ndataframe = explorer.get_similar(img='path/to/image.jpg')\n\n# Or search for similar images to a given index/indices\ndataframe = explorer.get_similar()(idx=0)\n</code></pre>"},{"location":"datasets/explorer/api/#1-similarity-search","title":"1. Similarity Search","text":"<p>Similarity search is a technique for finding similar images to a given image. It is based on the idea that similar images will have similar embeddings. Once the embeddings table is built, you can get run semantic search in any of the following ways:</p> <ul> <li>On a given index or list of indices in the dataset: <code>exp.get_similar(idx=[1,10], limit=10)</code></li> <li>On any image or list of images not in the dataset: <code>exp.get_similar(img=[\"path/to/img1\", \"path/to/img2\"], limit=10)</code></li> </ul> <p>In case of multiple inputs, the aggregate of their embeddings is used.</p> <p>You get a pandas dataframe with the <code>limit</code> number of most similar data points to the input, along with their distance in the embedding space. You can use this dataset to perform further filtering</p> <p>Semantic Search</p> Using ImagesUsing Dataset Indices <pre><code>from ultralytics import Explorer\n\n# create an Explorer object\nexp = Explorer(data='coco128.yaml', model='yolov8n.pt')\nexp.create_embeddings_table()\n\nsimilar = exp.get_similar(img='https://ultralytics.com/images/bus.jpg', limit=10)\nprint(similar.head())\n\n# Search using multiple indices\nsimilar = exp.get_similar(\n                        img=['https://ultralytics.com/images/bus.jpg',\n                             'https://ultralytics.com/images/bus.jpg'],\n                        limit=10\n                        )\nprint(similar.head())\n</code></pre> <pre><code>from ultralytics import Explorer\n\n# create an Explorer object\nexp = Explorer(data='coco128.yaml', model='yolov8n.pt')\nexp.create_embeddings_table()\n\nsimilar = exp.get_similar(idx=1, limit=10)\nprint(similar.head())\n\n# Search using multiple indices\nsimilar = exp.get_similar(idx=[1,10], limit=10)\nprint(similar.head())\n</code></pre>"},{"location":"datasets/explorer/api/#plotting-similar-images","title":"Plotting Similar Images","text":"<p>You can also plot the similar images using the <code>plot_similar</code> method. This method takes the same arguments as <code>get_similar</code> and plots the similar images in a grid.</p> <p>Plotting Similar Images</p> Using ImagesUsing Dataset Indices <pre><code>from ultralytics import Explorer\n\n# create an Explorer object\nexp = Explorer(data='coco128.yaml', model='yolov8n.pt')\nexp.create_embeddings_table()\n\nplt = exp.plot_similar(img='https://ultralytics.com/images/bus.jpg', limit=10)\nplt.show()\n</code></pre> <pre><code>from ultralytics import Explorer\n\n# create an Explorer object\nexp = Explorer(data='coco128.yaml', model='yolov8n.pt')\nexp.create_embeddings_table()\n\nplt = exp.plot_similar(idx=1, limit=10)\nplt.show()\n</code></pre>"},{"location":"datasets/explorer/api/#2-ask-ai-natural-language-querying","title":"2. Ask AI (Natural Language Querying)","text":"<p>This allows you to write how you want to filter your dataset using natural language. You don't have to be proficient in writing SQL queries. Our AI powered query generator will automatically do that under the hood. For example - you can say - \"show me 100 images with exactly one person and 2 dogs. There can be other objects too\" and it'll internally generate the query and show you those results. Note: This works using LLMs under the hood so the results are probabilistic and might get things wrong sometimes</p> <p>Ask AI</p> <pre><code>from ultralytics import Explorer\nfrom ultralytics.data.explorer import plot_query_result\n\n\n# create an Explorer object\nexp = Explorer(data='coco128.yaml', model='yolov8n.pt')\nexp.create_embeddings_table()\n\ndf = exp.ask_ai(\"show me 100 images with exactly one person and 2 dogs. There can be other objects too\")\nprint(df.head())\n\n# plot the results\nplt = plot_query_result(df)\nplt.show()\n</code></pre>"},{"location":"datasets/explorer/api/#3-sql-querying","title":"3. SQL Querying","text":"<p>You can run SQL queries on your dataset using the <code>sql_query</code> method. This method takes a SQL query as input and returns a pandas dataframe with the results.</p> <p>SQL Query</p> <pre><code>from ultralytics import Explorer\n\n# create an Explorer object\nexp = Explorer(data='coco128.yaml', model='yolov8n.pt')\nexp.create_embeddings_table()\n\ndf = exp.sql_query(\"WHERE labels LIKE '%person%' AND labels LIKE '%dog%'\")\nprint(df.head())\n</code></pre>"},{"location":"datasets/explorer/api/#plotting-sql-query-results","title":"Plotting SQL Query Results","text":"<p>You can also plot the results of a SQL query using the <code>plot_sql_query</code> method. This method takes the same arguments as <code>sql_query</code> and plots the results in a grid.</p> <p>Plotting SQL Query Results</p> <pre><code>from ultralytics import Explorer\n\n# create an Explorer object\nexp = Explorer(data='coco128.yaml', model='yolov8n.pt')\nexp.create_embeddings_table()\n\ndf = exp.sql_query(\"WHERE labels LIKE '%person%' AND labels LIKE '%dog%'\")\nprint(df.head())\n</code></pre>"},{"location":"datasets/explorer/api/#4-working-with-embeddings-table-advanced","title":"4. Working with embeddings Table (Advanced)","text":"<p>You can also work with the embeddings table directly. Once the embeddings table is created, you can access it using the <code>Explorer.table</code></p> <p>Explorer works on LanceDB tables internally. You can access this table directly, using <code>Explorer.table</code> object and run raw queries, push down pre- and post-filters, etc.</p> <pre><code>from ultralytics import Explorer\n\nexp = Explorer()\nexp.create_embeddings_table()\ntable = exp.table\n</code></pre> <p>Here are some examples of what you can do with the table:</p>"},{"location":"datasets/explorer/api/#get-raw-embeddings","title":"Get raw Embeddings","text":"<p>Example</p> <pre><code>from ultralytics import Explorer\n\nexp = Explorer()\nexp.create_embeddings_table()\ntable = exp.table\n\nembeddings = table.to_pandas()[\"vector\"]\nprint(embeddings)\n</code></pre>"},{"location":"datasets/explorer/api/#advanced-querying-with-pre-and-post-filters","title":"Advanced Querying with pre and post filters","text":"<p>Example</p> <pre><code>from ultralytics import Explorer\n\nexp = Explorer(model=\"yolov8n.pt\")\nexp.create_embeddings_table()\ntable = exp.table\n\n# Dummy embedding\nembedding = [i for i in range(256)]\nrs = table.search(embedding).metric(\"cosine\").where(\"\").limit(10)\n</code></pre>"},{"location":"datasets/explorer/api/#create-vector-index","title":"Create Vector Index","text":"<p>When using large datasets, you can also create a dedicated vector index for faster querying. This is done using the <code>create_index</code> method on LanceDB table.</p> <pre><code>    table.create_index(num_partitions=..., num_sub_vectors=...)\n</code></pre> <p>Find more details on the type vector indices available and parameters here In the future, we will add support for creating vector indices directly from Explorer API.</p>"},{"location":"datasets/explorer/api/#5-embeddings-applications","title":"5. Embeddings Applications","text":"<p>You can use the embeddings table to perform a variety of exploratory analysis. Here are some examples:</p>"},{"location":"datasets/explorer/api/#similarity-index","title":"Similarity Index","text":"<p>Explorer comes with a <code>similarity_index</code> operation:</p> <ul> <li>It tries to estimate how similar each data point is with the rest of the dataset.</li> <li>It does that by counting how many image embeddings lie closer than <code>max_dist</code> to the current image in the generated embedding space, considering <code>top_k</code> similar images at a time.</li> </ul> <p>It returns a pandas dataframe with the following columns:</p> <ul> <li><code>idx</code>: Index of the image in the dataset</li> <li><code>im_file</code>: Path to the image file</li> <li><code>count</code>: Number of images in the dataset that are closer than <code>max_dist</code> to the current image</li> <li><code>sim_im_files</code>: List of paths to the <code>count</code> similar images</li> </ul> <p>Tip</p> <p>For a given dataset, model, <code>max_dist</code> &amp; <code>top_k</code> the similarity index once generated will be reused. In case, your dataset has changed, or you simply need to regenerate the similarity index, you can pass <code>force=True</code>.</p> <p>Similarity Index</p> <pre><code>from ultralytics import Explorer\n\nexp = Explorer()\nexp.create_embeddings_table()\n\nsim_idx = exp.similarity_index()\n</code></pre> <p>You can use similarity index to build custom conditions to filter out the dataset. For example, you can filter out images that are not similar to any other image in the dataset using the following code:</p> <pre><code>import numpy as np\n\nsim_count = np.array(sim_idx[\"count\"])\nsim_idx['im_file'][sim_count &gt; 30]\n</code></pre>"},{"location":"datasets/explorer/api/#visualize-embedding-space","title":"Visualize Embedding Space","text":"<p>You can also visualize the embedding space using the plotting tool of your choice. For example here is a simple example using matplotlib:</p> <pre><code>import numpy as np\nfrom sklearn.decomposition import PCA\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\n# Reduce dimensions using PCA to 3 components for visualization in 3D\npca = PCA(n_components=3)\nreduced_data = pca.fit_transform(embeddings)\n\n# Create a 3D scatter plot using Matplotlib Axes3D\nfig = plt.figure(figsize=(8, 6))\nax = fig.add_subplot(111, projection='3d')\n\n# Scatter plot\nax.scatter(reduced_data[:, 0], reduced_data[:, 1], reduced_data[:, 2], alpha=0.5)\nax.set_title('3D Scatter Plot of Reduced 256-Dimensional Data (PCA)')\nax.set_xlabel('Component 1')\nax.set_ylabel('Component 2')\nax.set_zlabel('Component 3')\n\nplt.show()\n</code></pre> <p>Start creating your own CV dataset exploration reports using the Explorer API. For inspiration, check out the</p>"},{"location":"datasets/explorer/api/#apps-built-using-ultralytics-explorer","title":"Apps Built Using Ultralytics Explorer","text":"<p>Try our GUI Demo based on Explorer API</p>"},{"location":"datasets/explorer/api/#coming-soon","title":"Coming Soon","text":"<ul> <li>[ ] Merge specific labels from datasets. Example - Import all <code>person</code> labels from COCO and <code>car</code> labels from Cityscapes</li> <li>[ ] Remove images that have a higher similarity index than the given threshold</li> <li>[ ] Automatically persist new datasets after merging/removing entries</li> <li>[ ] Advanced Dataset Visualizations</li> </ul>"},{"location":"datasets/explorer/dashboard/","title":"Explorer GUI","text":"<p>Explorer GUI is like a playground build using Ultralytics Explorer API. It allows you to run semantic/vector similarity search, SQL queries and even search using natural language using our ask AI feature powered by LLMs.</p>"},{"location":"datasets/explorer/dashboard/#installation","title":"Installation","text":"<pre><code>pip install ultralytics[explorer]\n</code></pre> <p>Note</p> <p>Ask AI feature works using OpenAI, so you'll be prompted to set the api key for OpenAI when you first run the GUI. You can set it like this - <code>yolo settings openai_api_key=\"...\"</code></p>"},{"location":"datasets/explorer/dashboard/#semantic-search-vector-similarity-search","title":"Semantic Search / Vector Similarity Search","text":"<p>Semantic search is a technique for finding similar images to a given image. It is based on the idea that similar images will have similar embeddings. In the UI, you can select one of more images and search for the images similar to them. This can be useful when you want to find images similar to a given image or a set of images that don't perform as expected.</p> <p>For example: In this VOC Exploration dashboard, user selects a couple aeroplane images like this:</p> <p> </p> <p>On performing similarity search, you should see a similar result:</p> <p> </p>"},{"location":"datasets/explorer/dashboard/#ask-ai","title":"Ask AI","text":"<p>This allows you to write how you want to filter your dataset using natural language. You don't have to be proficient in writing SQL queries. Our AI powered query generator will automatically do that under the hood. For example - you can say - \"show me 100 images with exactly one person and 2 dogs. There can be other objects too\" and it'll internally generate the query and show you those results. Here's an example output when asked to \"Show 10 images with exactly 5 persons\" and you'll see a result like this:</p> <p> </p> <p>Note: This works using LLMs under the hood so the results are probabilistic and might get things wrong sometimes</p>"},{"location":"datasets/explorer/dashboard/#run-sql-queries-on-your-cv-datasets","title":"Run SQL queries on your CV datasets","text":"<p>You can run SQL queries on your dataset to filter it. It also works if you only provide the WHERE clause. Example SQL query would show only the images that have at least one 1 person and 1 dog in them:</p> <pre><code>WHERE labels LIKE '%person%' AND labels LIKE '%dog%'\n</code></pre> <p> </p> <p>This is a Demo build using the Explorer API. You can use the API to build your own exploratory notebooks or scripts to get insights into your datasets. Learn more about the Explorer API here.</p>"},{"location":"datasets/explorer/explorer/","title":"VOC Exploration Example","text":"In\u00a0[\u00a0]: Copied! <pre>%pip install ultralytics\nultralytics.checks()\n</pre> %pip install ultralytics ultralytics.checks() In\u00a0[\u00a0]: Copied! <pre>from ultralytics import Explorer\n</pre> from ultralytics import Explorer In\u00a0[\u00a0]: Copied! <pre>exp = Explorer(\"VOC.yaml\", model=\"yolov8n.pt\")\nexp.create_embeddings_table()\n</pre> exp = Explorer(\"VOC.yaml\", model=\"yolov8n.pt\") exp.create_embeddings_table() <p>One the embeddings table is built, you can get run semantic search in any of the following ways:</p> <ul> <li>On a given index / list of indices in the dataset like - <code>exp.get_similar(idx=[1,10], limit=10)</code></li> <li>On any image/ list of images not in the dataset  - <code>exp.get_similar(img=[\"path/to/img1\", \"path/to/img2\"], limit=10)</code> In case of multiple inputs, the aggregade of their embeddings is used.</li> </ul> <p>You get a pandas dataframe with the <code>limit</code> number of most similar data points to the input, along with their distance in the embedding space. You can use this dataset to perform further filtering </p> In\u00a0[\u00a0]: Copied! <pre>similar = exp.get_similar(idx=1, limit=10)\nsimilar.head()\n</pre> similar = exp.get_similar(idx=1, limit=10) similar.head() <p>You can use the also plot the similar samples directly using the <code>plot_similar</code> util</p> <p> <p></p> </p> In\u00a0[\u00a0]: Copied! <pre>exp.plot_similar(idx=6500, limit=20)\n#exp.plot_similar(idx=[100,101], limit=10) # Can also pass list of idxs or imgs\n</pre> exp.plot_similar(idx=6500, limit=20) #exp.plot_similar(idx=[100,101], limit=10) # Can also pass list of idxs or imgs  In\u00a0[\u00a0]: Copied! <pre>exp.plot_similar(img=\"https://ultralytics.com/images/bus.jpg\", limit=10, labels=False) # Can also pass any external images\n</pre> exp.plot_similar(img=\"https://ultralytics.com/images/bus.jpg\", limit=10, labels=False) # Can also pass any external images  <p> </p> In\u00a0[\u00a0]: Copied! <pre>df = exp.ask_ai(\"show me images containing more than 10 objects with at least 2 persons\")\ndf.head(5)\n</pre> df = exp.ask_ai(\"show me images containing more than 10 objects with at least 2 persons\") df.head(5) <p>for plotting these results you can use <code>plot_query_result</code> util Example:</p> <pre><code>plt = plot_query_result(exp.ask_ai(\"show me 10 images containing exactly 2 persons\"))\nImage.fromarray(plt)\n</code></pre> <p> </p> In\u00a0[\u00a0]: Copied! <pre># plot\nfrom ultralytics.data.explorer import plot_query_result\nfrom PIL import Image\n\nplt = plot_query_result(exp.ask_ai(\"show me 10 images containing exactly 2 persons\"))\nImage.fromarray(plt)\n</pre> # plot from ultralytics.data.explorer import plot_query_result from PIL import Image  plt = plot_query_result(exp.ask_ai(\"show me 10 images containing exactly 2 persons\")) Image.fromarray(plt) In\u00a0[\u00a0]: Copied! <pre>table = exp.sql_query(\"WHERE labels LIKE '%person, person%' AND labels LIKE '%dog%' LIMIT 10\")\ntable\n</pre> table = exp.sql_query(\"WHERE labels LIKE '%person, person%' AND labels LIKE '%dog%' LIMIT 10\") table <p>Just like similarity search, you also get a util to directly plot the sql queries using <code>exp.plot_sql_query</code> </p> In\u00a0[\u00a0]: Copied! <pre>exp.plot_sql_query(\"WHERE labels LIKE '%person, person%' AND labels LIKE '%dog%' LIMIT 10\", labels=True)\n</pre> exp.plot_sql_query(\"WHERE labels LIKE '%person, person%' AND labels LIKE '%dog%' LIMIT 10\", labels=True) In\u00a0[\u00a0]: Copied! <pre>table = exp.table\ntable.schema\n</pre> table = exp.table table.schema In\u00a0[\u00a0]: Copied! <pre>dummy_img_embedding = [i for i in range(256)] \ntable.search(dummy_img_embedding).limit(5).to_pandas()\n</pre> dummy_img_embedding = [i for i in range(256)]  table.search(dummy_img_embedding).limit(5).to_pandas() In\u00a0[\u00a0]: Copied! <pre>df = table.to_pandas()\npa_table = table.to_arrow()\n</pre> df = table.to_pandas() pa_table = table.to_arrow()  In\u00a0[\u00a0]: Copied! <pre>import numpy as np\n\nembeddings = table.to_pandas()[\"vector\"].tolist()\nembeddings = np.array(embeddings)\n</pre> import numpy as np  embeddings = table.to_pandas()[\"vector\"].tolist() embeddings = np.array(embeddings) In\u00a0[\u00a0]: Copied! <pre>!pip install scikit-learn --q\n</pre> !pip install scikit-learn --q In\u00a0[\u00a0]: Copied! <pre>%matplotlib inline\nimport numpy as np\nfrom sklearn.decomposition import PCA\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\n# Reduce dimensions using PCA to 3 components for visualization in 3D\npca = PCA(n_components=3)\nreduced_data = pca.fit_transform(embeddings)\n\n# Create a 3D scatter plot using Matplotlib's Axes3D\nfig = plt.figure(figsize=(8, 6))\nax = fig.add_subplot(111, projection='3d')\n\n# Scatter plot\nax.scatter(reduced_data[:, 0], reduced_data[:, 1], reduced_data[:, 2], alpha=0.5)\nax.set_title('3D Scatter Plot of Reduced 256-Dimensional Data (PCA)')\nax.set_xlabel('Component 1')\nax.set_ylabel('Component 2')\nax.set_zlabel('Component 3')\n\nplt.show()\n</pre> %matplotlib inline import numpy as np from sklearn.decomposition import PCA import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D  # Reduce dimensions using PCA to 3 components for visualization in 3D pca = PCA(n_components=3) reduced_data = pca.fit_transform(embeddings)  # Create a 3D scatter plot using Matplotlib's Axes3D fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d')  # Scatter plot ax.scatter(reduced_data[:, 0], reduced_data[:, 1], reduced_data[:, 2], alpha=0.5) ax.set_title('3D Scatter Plot of Reduced 256-Dimensional Data (PCA)') ax.set_xlabel('Component 1') ax.set_ylabel('Component 2') ax.set_zlabel('Component 3')  plt.show() In\u00a0[\u00a0]: Copied! <pre>exp.plot_similarity_index(max_dist=0.2, top_k=0.01)\n</pre> exp.plot_similarity_index(max_dist=0.2, top_k=0.01) <p>Now let's look at the output of the operation</p> In\u00a0[\u00a0]: Copied! <pre>import numpy as np\n\nsim_idx = exp.similarity_index(max_dist=0.2, top_k=0.01, force=False)\n</pre> import numpy as np  sim_idx = exp.similarity_index(max_dist=0.2, top_k=0.01, force=False) In\u00a0[\u00a0]: Copied! <pre>sim_idx\n</pre> sim_idx <p>Let's create a query to see what data points have similarity count of more than 30 and plot images similar to them.</p> In\u00a0[\u00a0]: Copied! <pre>import numpy as np\n\nsim_count = np.array(sim_idx[\"count\"])\nsim_idx['im_file'][sim_count &gt; 30]\n</pre> import numpy as np  sim_count = np.array(sim_idx[\"count\"]) sim_idx['im_file'][sim_count &gt; 30] <p>You should see something like this </p> In\u00a0[\u00a0]: Copied! <pre>exp.plot_similar(idx=[7146, 14035]) # Using avg embeddings of 2 images\n</pre> exp.plot_similar(idx=[7146, 14035]) # Using avg embeddings of 2 images"},{"location":"datasets/explorer/explorer/#voc-exploration-example","title":"VOC Exploration Example\u00b6","text":"<p>\u4e2d\u6587 | \ud55c\uad6d\uc5b4 | \u65e5\u672c\u8a9e | \u0420\u0443\u0441\u0441\u043a\u0438\u0439 | Deutsch | Fran\u00e7ais | Espa\u00f1ol | Portugu\u00eas | \u0939\u093f\u0928\u094d\u0926\u0940 | \u0627\u0644\u0639\u0631\u0628\u064a\u0629</p> <p> </p> <p>Welcome to the Ultralytics Explorer API notebook!  This notebook serves as the starting point for exploring the various resources available to help you get started with using Ultralytics to explore your datasets using with the power of semantic search. You can utilities out of the box that allow you to examine specific types of labels using vector search or even SQL queries.</p> <p>We hope that the resources in this notebook will help you get the most out of Ultralytics. Please browse the Explorer Docs for details, raise an issue on GitHub for support, and join our Discord community for questions and discussions!</p> <p>Try <code>yolo explorer</code> powered by Exlorer API</p> <p>Simply <code>pip install ultralytics</code> and run <code>yolo explorer</code> in your terminal to run custom queries and semantic search on your datasets right inside your browser!</p>"},{"location":"datasets/explorer/explorer/#setup","title":"Setup\u00b6","text":"<p>Pip install <code>ultralytics</code> and dependencies and check software and hardware.</p>"},{"location":"datasets/explorer/explorer/#similarity-search","title":"Similarity search\u00b6","text":"<p>Utilize the power of vector similarity search to find the similar data points in your dataset along with their distance in the embedding space. Simply create an embeddings table for the given dataset-model pair. It is only needed once and it is reused automatically.</p>"},{"location":"datasets/explorer/explorer/#2-ask-ai-search-or-filter-with-natural-language","title":"2. Ask AI: Search or filter with Natural Language\u00b6","text":"<p>You can prompt the Explorer object with the kind of data points you want to see and it'll try to return a dataframe with those. Because it is powered by LLMs, it doesn't always get it right. In that case, it'll return None.</p> <p> </p>"},{"location":"datasets/explorer/explorer/#3-run-sql-queries-on-your-dataset","title":"3. Run SQL queries on your Dataset!\u00b6","text":"<p>Sometimes you might want to investigate a certain type of entries in your dataset. For this Explorer allows you to execute SQL queries. It accepts either of the formats:</p> <ul> <li>Queries beginning with \"WHERE\" will automatically select all columns. This can be thought of as a short-hand query</li> <li>You can also write full queries where you can specify which columns to select</li> </ul> <p>This can be used to investigate model performance and specific data points. For example:</p> <ul> <li>let's say your model struggles on images that have humans and dogs. You can write a query like this to select the points that have at least 2 humans AND at least one dog.</li> </ul> <p>You can combine SQL query and semantic search to filter down to specific type of results </p>"},{"location":"datasets/explorer/explorer/#3-working-with-embeddings-table-advanced","title":"3. Working with embeddings Table (Advanced)\u00b6","text":"<p>Explorer works on LanceDB tables internally. You can access this table directly, using <code>Explorer.table</code> object and run raw queries, push down pre and post filters, etc.</p>"},{"location":"datasets/explorer/explorer/#run-raw-queries","title":"Run raw queries\u00b6","text":"<p>Vector Search finds the nearest vectors from the database. In a recommendation system or search engine, you can find similar products from the one you searched. In LLM and other AI applications, each data point can be presented by the embeddings generated from some models, it returns the most relevant features.</p> <p>A search in high-dimensional vector space, is to find K-Nearest-Neighbors (KNN) of the query vector.</p> <p>Metric In LanceDB, a Metric is the way to describe the distance between a pair of vectors. Currently, it supports the following metrics:</p> <ul> <li>L2</li> <li>Cosine</li> <li>Dot Explorer's similarity search uses L2 by default. You can run queries on tables directly, or use the lance format to build custom utilities to manage datasets. More details on available LanceDB table ops in the docs</li> </ul>"},{"location":"datasets/explorer/explorer/#inter-conversion-to-popular-data-formats","title":"Inter-conversion to popular data formats\u00b6","text":""},{"location":"datasets/explorer/explorer/#work-with-embeddings","title":"Work with Embeddings\u00b6","text":"<p>You can access the raw embedding from lancedb Table and analyse it. The image embeddings are stored in column <code>vector</code></p>"},{"location":"datasets/explorer/explorer/#scatterplot","title":"Scatterplot\u00b6","text":"<p>One of the preliminary steps in analysing embeddings is by plotting them in 2D space via dimensionality reduction. Let's try an example</p>"},{"location":"datasets/explorer/explorer/#4-similarity-index","title":"4. Similarity Index\u00b6","text":"<p>Here's a simple example of an operation powered by the embeddings table. Explorer comes with a <code>similarity_index</code> operation-</p> <ul> <li>It tries to estimate how similar each data point is with the rest of the dataset.</li> <li>It does that by counting how many image embeddings lie closer than <code>max_dist</code> to the current image in the generated embedding space, considering <code>top_k</code> similar images at a time.</li> </ul> <p>For a given dataset, model, <code>max_dist</code> &amp; <code>top_k</code> the similarity index once generated will be reused. In case, your dataset has changed, or you simply need to regenerate the similarity index, you can pass <code>force=True</code>. Similar to vector and SQL search, this also comes with a util to directly plot it. Let's look at the plot first </p>"},{"location":"datasets/obb/","title":"Oriented Bounding Box (OBB) Datasets Overview","text":"<p>Training a precise object detection model with oriented bounding boxes (OBB) requires a thorough dataset. This guide explains the various OBB dataset formats compatible with Ultralytics YOLO models, offering insights into their structure, application, and methods for format conversions.</p>"},{"location":"datasets/obb/#supported-obb-dataset-formats","title":"Supported OBB Dataset Formats","text":""},{"location":"datasets/obb/#yolo-obb-format","title":"YOLO OBB Format","text":"<p>The YOLO OBB format designates bounding boxes by their four corner points with coordinates normalized between 0 and 1. It follows this format:</p> <pre><code>class_index, x1, y1, x2, y2, x3, y3, x4, y4\n</code></pre> <p>Internally, YOLO processes losses and outputs in the <code>xywhr</code> format, which represents the bounding box's center point (xy), width, height, and rotation.</p> <p></p> <p>An example of a <code>*.txt</code> label file for the above image, which contains an object of class <code>0</code> in OBB format, could look like:</p> <pre><code>0 0.780811 0.743961 0.782371 0.74686 0.777691 0.752174 0.776131 0.749758\n</code></pre>"},{"location":"datasets/obb/#usage","title":"Usage","text":"<p>To train a model using these OBB formats:</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Create a new YOLOv8n-OBB model from scratch\nmodel = YOLO('yolov8n-obb.yaml')\n\n# Train the model on the DOTAv2 dataset\nresults = model.train(data='DOTAv1.yaml', epochs=100, imgsz=640)\n</code></pre> <pre><code># Train a new YOLOv8n-OBB model on the DOTAv2 dataset\nyolo detect train data=DOTAv1.yaml model=yolov8n.pt epochs=100 imgsz=640\n</code></pre>"},{"location":"datasets/obb/#supported-datasets","title":"Supported Datasets","text":"<p>Currently, the following datasets with Oriented Bounding Boxes are supported:</p> <ul> <li>DOTA v2: DOTA (A Large-scale Dataset for Object Detection in Aerial Images) version 2, emphasizes detection from aerial perspectives and contains oriented bounding boxes with 1.7 million instances and 11,268 images.</li> </ul>"},{"location":"datasets/obb/#incorporating-your-own-obb-dataset","title":"Incorporating your own OBB dataset","text":"<p>For those looking to introduce their own datasets with oriented bounding boxes, ensure compatibility with the \"YOLO OBB format\" mentioned above. Convert your annotations to this required format and detail the paths, classes, and class names in a corresponding YAML configuration file.</p>"},{"location":"datasets/obb/#convert-label-formats","title":"Convert Label Formats","text":""},{"location":"datasets/obb/#dota-dataset-format-to-yolo-obb-format","title":"DOTA Dataset Format to YOLO OBB Format","text":"<p>Transitioning labels from the DOTA dataset format to the YOLO OBB format can be achieved with this script:</p> <p>Example</p> Python <pre><code>from ultralytics.data.converter import convert_dota_to_yolo_obb\n\nconvert_dota_to_yolo_obb('path/to/DOTA')\n</code></pre> <p>This conversion mechanism is instrumental for datasets in the DOTA format, ensuring alignment with the Ultralytics YOLO OBB format.</p> <p>It's imperative to validate the compatibility of the dataset with your model and adhere to the necessary format conventions. Properly structured datasets are pivotal for training efficient object detection models with oriented bounding boxes.</p>"},{"location":"datasets/obb/dota-v2/","title":"DOTA Dataset with OBB","text":"<p>DOTA stands as a specialized dataset, emphasizing object detection in aerial images. Originating from the DOTA series of datasets, it offers annotated images capturing a diverse array of aerial scenes with Oriented Bounding Boxes (OBB).</p> <p></p>"},{"location":"datasets/obb/dota-v2/#key-features","title":"Key Features","text":"<ul> <li>Collection from various sensors and platforms, with image sizes ranging from 800 \u00d7 800 to 20,000 \u00d7 20,000 pixels.</li> <li>Features more than 1.7M Oriented Bounding Boxes across 18 categories.</li> <li>Encompasses multiscale object detection.</li> <li>Instances are annotated by experts using arbitrary (8 d.o.f.) quadrilateral, capturing objects of different scales, orientations, and shapes.</li> </ul>"},{"location":"datasets/obb/dota-v2/#dataset-versions","title":"Dataset Versions","text":""},{"location":"datasets/obb/dota-v2/#dota-v10","title":"DOTA-v1.0","text":"<ul> <li>Contains 15 common categories.</li> <li>Comprises 2,806 images with 188,282 instances.</li> <li>Split ratios: 1/2 for training, 1/6 for validation, and 1/3 for testing.</li> </ul>"},{"location":"datasets/obb/dota-v2/#dota-v15","title":"DOTA-v1.5","text":"<ul> <li>Incorporates the same images as DOTA-v1.0.</li> <li>Very small instances (less than 10 pixels) are also annotated.</li> <li>Addition of a new category: \"container crane\".</li> <li>A total of 403,318 instances.</li> <li>Released for the DOAI Challenge 2019 on Object Detection in Aerial Images.</li> </ul>"},{"location":"datasets/obb/dota-v2/#dota-v20","title":"DOTA-v2.0","text":"<ul> <li>Collections from Google Earth, GF-2 Satellite, and other aerial images.</li> <li>Contains 18 common categories.</li> <li>Comprises 11,268 images with a whopping 1,793,658 instances.</li> <li>New categories introduced: \"airport\" and \"helipad\".</li> <li>Image splits:<ul> <li>Training: 1,830 images with 268,627 instances.</li> <li>Validation: 593 images with 81,048 instances.</li> <li>Test-dev: 2,792 images with 353,346 instances.</li> <li>Test-challenge: 6,053 images with 1,090,637 instances.</li> </ul> </li> </ul>"},{"location":"datasets/obb/dota-v2/#dataset-structure","title":"Dataset Structure","text":"<p>DOTA exhibits a structured layout tailored for OBB object detection challenges:</p> <ul> <li>Images: A vast collection of high-resolution aerial images capturing diverse terrains and structures.</li> <li>Oriented Bounding Boxes: Annotations in the form of rotated rectangles encapsulating objects irrespective of their orientation, ideal for capturing objects like airplanes, ships, and buildings.</li> </ul>"},{"location":"datasets/obb/dota-v2/#applications","title":"Applications","text":"<p>DOTA serves as a benchmark for training and evaluating models specifically tailored for aerial image analysis. With the inclusion of OBB annotations, it provides a unique challenge, enabling the development of specialized object detection models that cater to aerial imagery's nuances.</p>"},{"location":"datasets/obb/dota-v2/#dataset-yaml","title":"Dataset YAML","text":"<p>Typically, datasets incorporate a YAML (Yet Another Markup Language) file detailing the dataset's configuration. For DOTA v1 and DOTA v1.5, Ultralytics provides <code>DOTAv1.yaml</code> and <code>DOTAv1.5.yaml</code> files. For additional details on these as well as DOTA v2 please consult DOTA's official repository and documentation.</p> <p>DOTAv1.yaml</p> <pre><code># Ultralytics YOLO \ud83d\ude80, AGPL-3.0 license\n# DOTA 1.0 dataset https://captain-whu.github.io/DOTA/index.html for object detection in aerial images by Wuhan University\n# Documentation: https://docs.ultralytics.com/datasets/obb/dota-v2/\n# Example usage: yolo train model=yolov8n-obb.pt data=DOTAv1.yaml\n# parent\n# \u251c\u2500\u2500 ultralytics\n# \u2514\u2500\u2500 datasets\n#     \u2514\u2500\u2500 dota1  \u2190 downloads here (2GB)\n\n# Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]\npath: ../datasets/DOTAv1  # dataset root dir\ntrain: images/train  # train images (relative to 'path') 1411 images\nval: images/val  # val images (relative to 'path') 458 images\ntest: images/test  # test images (optional) 937 images\n\n# Classes for DOTA 1.0\nnames:\n  0: plane\n  1: ship\n  2: storage tank\n  3: baseball diamond\n  4: tennis court\n  5: basketball court\n  6: ground track field\n  7: harbor\n  8: bridge\n  9: large vehicle\n  10: small vehicle\n  11: helicopter\n  12: roundabout\n  13: soccer ball field\n  14: swimming pool\n\n# Download script/URL (optional)\ndownload: https://github.com/ultralytics/yolov5/releases/download/v1.0/DOTAv1.zip\n</code></pre>"},{"location":"datasets/obb/dota-v2/#split-dota-images","title":"Split DOTA images","text":"<p>To train DOTA dataset, We split original DOTA images with high-resolution into images with 1024x1024 resolution in multi-scale way.</p> <p>Split images</p> Python <pre><code>from ultralytics.data.split_dota import split_trainval, split_test\n\n# split train and val set, with labels.\nsplit_trainval(\n    data_root='path/to/DOTAv1.0/',\n    save_dir='path/to/DOTAv1.0-split/',\n    rates=[0.5, 1.0, 1.5],    # multi-scale\n    gap=500\n)\n# split test set, without labels.\nsplit_test(\n    data_root='path/to/DOTAv1.0/',\n    save_dir='path/to/DOTAv1.0-split/',\n    rates=[0.5, 1.0, 1.5],    # multi-scale\n    gap=500\n)\n</code></pre>"},{"location":"datasets/obb/dota-v2/#usage","title":"Usage","text":"<p>To train a model on the DOTA v1 dataset, you can utilize the following code snippets. Always refer to your model's documentation for a thorough list of available arguments.</p> <p>Warning</p> <p>Please note that all images and associated annotations in the DOTAv1 dataset can be used for academic purposes, but commercial use is prohibited. Your understanding and respect for the dataset creators' wishes are greatly appreciated!</p> <p>Train Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Create a new YOLOv8n-OBB model from scratch\nmodel = YOLO('yolov8n-obb.yaml')\n\n# Train the model on the DOTAv2 dataset\nresults = model.train(data='DOTAv1.yaml', epochs=100, imgsz=640)\n</code></pre> <pre><code># Train a new YOLOv8n-OBB model on the DOTAv2 dataset\nyolo detect train data=DOTAv1.yaml model=yolov8n.pt epochs=100 imgsz=640\n</code></pre>"},{"location":"datasets/obb/dota-v2/#sample-data-and-annotations","title":"Sample Data and Annotations","text":"<p>Having a glance at the dataset illustrates its depth:</p> <p></p> <ul> <li>DOTA examples: This snapshot underlines the complexity of aerial scenes and the significance of Oriented Bounding Box annotations, capturing objects in their natural orientation.</li> </ul> <p>The dataset's richness offers invaluable insights into object detection challenges exclusive to aerial imagery.</p>"},{"location":"datasets/obb/dota-v2/#citations-and-acknowledgments","title":"Citations and Acknowledgments","text":"<p>For those leveraging DOTA in their endeavors, it's pertinent to cite the relevant research papers:</p> BibTeX <pre><code>@article{9560031,\n  author={Ding, Jian and Xue, Nan and Xia, Gui-Song and Bai, Xiang and Yang, Wen and Yang, Michael and Belongie, Serge and Luo, Jiebo and Datcu, Mihai and Pelillo, Marcello and Zhang, Liangpei},\n  journal={IEEE Transactions on Pattern Analysis and Machine Intelligence},\n  title={Object Detection in Aerial Images: A Large-Scale Benchmark and Challenges},\n  year={2021},\n  volume={},\n  number={},\n  pages={1-1},\n  doi={10.1109/TPAMI.2021.3117983}\n}\n</code></pre> <p>A special note of gratitude to the team behind the DOTA datasets for their commendable effort in curating this dataset. For an exhaustive understanding of the dataset and its nuances, please visit the official DOTA website.</p>"},{"location":"datasets/obb/dota8/","title":"DOTA8 Dataset","text":""},{"location":"datasets/obb/dota8/#introduction","title":"Introduction","text":"<p>Ultralytics DOTA8 is a small, but versatile oriented object detection dataset composed of the first 8 images of 8 images of the split DOTAv1 set, 4 for training and 4 for validation. This dataset is ideal for testing and debugging object detection models, or for experimenting with new detection approaches. With 8 images, it is small enough to be easily manageable, yet diverse enough to test training pipelines for errors and act as a sanity check before training larger datasets.</p> <p>This dataset is intended for use with Ultralytics HUB and YOLOv8.</p>"},{"location":"datasets/obb/dota8/#dataset-yaml","title":"Dataset YAML","text":"<p>A YAML (Yet Another Markup Language) file is used to define the dataset configuration. It contains information about the dataset's paths, classes, and other relevant information. In the case of the DOTA8 dataset, the <code>dota8.yaml</code> file is maintained at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/cfg/datasets/dota8.yaml.</p> <p>ultralytics/cfg/datasets/dota8.yaml</p> <pre><code># Ultralytics YOLO \ud83d\ude80, AGPL-3.0 license\n# DOTA8 dataset 8 images from split DOTAv1 dataset by Ultralytics\n# Documentation: https://docs.ultralytics.com/datasets/obb/dota8/\n# Example usage: yolo train model=yolov8n-obb.pt data=dota8.yaml\n# parent\n# \u251c\u2500\u2500 ultralytics\n# \u2514\u2500\u2500 datasets\n#     \u2514\u2500\u2500 dota8  \u2190 downloads here (1MB)\n\n# Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]\npath: ../datasets/dota8  # dataset root dir\ntrain: images/train  # train images (relative to 'path') 4 images\nval: images/val  # val images (relative to 'path') 4 images\n\n# Classes for DOTA 1.0\nnames:\n  0: plane\n  1: ship\n  2: storage tank\n  3: baseball diamond\n  4: tennis court\n  5: basketball court\n  6: ground track field\n  7: harbor\n  8: bridge\n  9: large vehicle\n  10: small vehicle\n  11: helicopter\n  12: roundabout\n  13: soccer ball field\n  14: swimming pool\n\n# Download script/URL (optional)\ndownload: https://github.com/ultralytics/yolov5/releases/download/v1.0/dota8.zip\n</code></pre>"},{"location":"datasets/obb/dota8/#usage","title":"Usage","text":"<p>To train a YOLOv8n-obb model on the DOTA8 dataset for 100 epochs with an image size of 640, you can use the following code snippets. For a comprehensive list of available arguments, refer to the model Training page.</p> <p>Train Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-obb.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='dota8.yaml', epochs=100, imgsz=640)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\nyolo obb train data=dota8.yaml model=yolov8n-obb.pt epochs=100 imgsz=640\n</code></pre>"},{"location":"datasets/obb/dota8/#sample-images-and-annotations","title":"Sample Images and Annotations","text":"<p>Here are some examples of images from the DOTA8 dataset, along with their corresponding annotations:</p> <p></p> <ul> <li>Mosaiced Image: This image demonstrates a training batch composed of mosaiced dataset images. Mosaicing is a technique used during training that combines multiple images into a single image to increase the variety of objects and scenes within each training batch. This helps improve the model's ability to generalize to different object sizes, aspect ratios, and contexts.</li> </ul> <p>The example showcases the variety and complexity of the images in the DOTA8 dataset and the benefits of using mosaicing during the training process.</p>"},{"location":"datasets/obb/dota8/#citations-and-acknowledgments","title":"Citations and Acknowledgments","text":"<p>If you use the DOTA dataset in your research or development work, please cite the following paper:</p> BibTeX <pre><code>@article{9560031,\n  author={Ding, Jian and Xue, Nan and Xia, Gui-Song and Bai, Xiang and Yang, Wen and Yang, Michael and Belongie, Serge and Luo, Jiebo and Datcu, Mihai and Pelillo, Marcello and Zhang, Liangpei},\n  journal={IEEE Transactions on Pattern Analysis and Machine Intelligence},\n  title={Object Detection in Aerial Images: A Large-Scale Benchmark and Challenges},\n  year={2021},\n  volume={},\n  number={},\n  pages={1-1},\n  doi={10.1109/TPAMI.2021.3117983}\n}\n</code></pre> <p>A special note of gratitude to the team behind the DOTA datasets for their commendable effort in curating this dataset. For an exhaustive understanding of the dataset and its nuances, please visit the official DOTA website.</p>"},{"location":"datasets/pose/","title":"Pose Estimation Datasets Overview","text":""},{"location":"datasets/pose/#supported-dataset-formats","title":"Supported Dataset Formats","text":""},{"location":"datasets/pose/#ultralytics-yolo-format","title":"Ultralytics YOLO format","text":"<p>The dataset label format used for training YOLO pose models is as follows:</p> <ol> <li>One text file per image: Each image in the dataset has a corresponding text file with the same name as the image file and the \".txt\" extension.</li> <li>One row per object: Each row in the text file corresponds to one object instance in the image.</li> <li>Object information per row: Each row contains the following information about the object instance:<ul> <li>Object class index: An integer representing the class of the object (e.g., 0 for person, 1 for car, etc.).</li> <li>Object center coordinates: The x and y coordinates of the center of the object, normalized to be between 0 and 1.</li> <li>Object width and height: The width and height of the object, normalized to be between 0 and 1.</li> <li>Object keypoint coordinates: The keypoints of the object, normalized to be between 0 and 1.</li> </ul> </li> </ol> <p>Here is an example of the label format for pose estimation task:</p> <p>Format with Dim = 2</p> <pre><code>&lt;class-index&gt; &lt;x&gt; &lt;y&gt; &lt;width&gt; &lt;height&gt; &lt;px1&gt; &lt;py1&gt; &lt;px2&gt; &lt;py2&gt; ... &lt;pxn&gt; &lt;pyn&gt;\n</code></pre> <p>Format with Dim = 3</p> <pre><code>&lt;class-index&gt; &lt;x&gt; &lt;y&gt; &lt;width&gt; &lt;height&gt; &lt;px1&gt; &lt;py1&gt; &lt;p1-visibility&gt; &lt;px2&gt; &lt;py2&gt; &lt;p2-visibility&gt; &lt;pxn&gt; &lt;pyn&gt; &lt;p2-visibility&gt;\n</code></pre> <p>In this format, <code>&lt;class-index&gt;</code> is the index of the class for the object,<code>&lt;x&gt; &lt;y&gt; &lt;width&gt; &lt;height&gt;</code> are coordinates of bounding box, and <code>&lt;px1&gt; &lt;py1&gt; &lt;px2&gt; &lt;py2&gt; ... &lt;pxn&gt; &lt;pyn&gt;</code> are the pixel coordinates of the keypoints. The coordinates are separated by spaces.</p>"},{"location":"datasets/pose/#dataset-yaml-format","title":"Dataset YAML format","text":"<p>The Ultralytics framework uses a YAML file format to define the dataset and model configuration for training Detection Models. Here is an example of the YAML format used for defining a detection dataset:</p> <pre><code># Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]\npath: ../datasets/coco8-pose  # dataset root dir\ntrain: images/train  # train images (relative to 'path') 4 images\nval: images/val  # val images (relative to 'path') 4 images\ntest:  # test images (optional)\n\n# Keypoints\nkpt_shape: [17, 3]  # number of keypoints, number of dims (2 for x,y or 3 for x,y,visible)\nflip_idx: [0, 2, 1, 4, 3, 6, 5, 8, 7, 10, 9, 12, 11, 14, 13, 16, 15]\n\n# Classes dictionary\nnames:\n  0: person\n</code></pre> <p>The <code>train</code> and <code>val</code> fields specify the paths to the directories containing the training and validation images, respectively.</p> <p><code>names</code> is a dictionary of class names. The order of the names should match the order of the object class indices in the YOLO dataset files.</p> <p>(Optional) if the points are symmetric then need flip_idx, like left-right side of human or face. For example if we assume five keypoints of facial landmark: [left eye, right eye, nose, left mouth, right mouth], and the original index is [0, 1, 2, 3, 4], then flip_idx is [1, 0, 2, 4, 3] (just exchange the left-right index, i.e. 0-1 and 3-4, and do not modify others like nose in this example).</p>"},{"location":"datasets/pose/#usage","title":"Usage","text":"<p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-pose.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='coco128-pose.yaml', epochs=100, imgsz=640)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\nyolo detect train data=coco128-pose.yaml model=yolov8n-pose.pt epochs=100 imgsz=640\n</code></pre>"},{"location":"datasets/pose/#supported-datasets","title":"Supported Datasets","text":"<p>This section outlines the datasets that are compatible with Ultralytics YOLO format and can be used for training pose estimation models:</p>"},{"location":"datasets/pose/#coco-pose","title":"COCO-Pose","text":"<ul> <li>Description: COCO-Pose is a large-scale object detection, segmentation, and pose estimation dataset. It is a subset of the popular COCO dataset and focuses on human pose estimation. COCO-Pose includes multiple keypoints for each human instance.</li> <li>Label Format: Same as Ultralytics YOLO format as described above, with keypoints for human poses.</li> <li>Number of Classes: 1 (Human).</li> <li>Keypoints: 17 keypoints including nose, eyes, ears, shoulders, elbows, wrists, hips, knees, and ankles.</li> <li>Usage: Suitable for training human pose estimation models.</li> <li>Additional Notes: The dataset is rich and diverse, containing over 200k labeled images.</li> <li>Read more about COCO-Pose</li> </ul>"},{"location":"datasets/pose/#coco8-pose","title":"COCO8-Pose","text":"<ul> <li>Description: Ultralytics COCO8-Pose is a small, but versatile pose detection dataset composed of the first 8 images of the COCO train 2017 set, 4 for training and 4 for validation.</li> <li>Label Format: Same as Ultralytics YOLO format as described above, with keypoints for human poses.</li> <li>Number of Classes: 1 (Human).</li> <li>Keypoints: 17 keypoints including nose, eyes, ears, shoulders, elbows, wrists, hips, knees, and ankles.</li> <li>Usage: Suitable for testing and debugging object detection models, or for experimenting with new detection approaches.</li> <li>Additional Notes: COCO8-Pose is ideal for sanity checks and CI checks.</li> <li>Read more about COCO8-Pose</li> </ul>"},{"location":"datasets/pose/#tiger-pose","title":"Tiger-Pose","text":"<ul> <li>Description: Ultralytics This animal pose dataset comprises 263 images sourced from a YouTube Video, with 210 images allocated for training and 53 for validation.</li> <li>Label Format: Same as Ultralytics YOLO format as described above, with 12 keypoints for animal pose and no visible dimension.</li> <li>Number of Classes: 1 (Tiger).</li> <li>Keypoints: 12 keypoints.</li> <li>Usage: Great for animal pose or any other pose that is not human-based.</li> <li>Read more about Tiger-Pose</li> </ul>"},{"location":"datasets/pose/#adding-your-own-dataset","title":"Adding your own dataset","text":"<p>If you have your own dataset and would like to use it for training pose estimation models with Ultralytics YOLO format, ensure that it follows the format specified above under \"Ultralytics YOLO format\". Convert your annotations to the required format and specify the paths, number of classes, and class names in the YAML configuration file.</p>"},{"location":"datasets/pose/#conversion-tool","title":"Conversion Tool","text":"<p>Ultralytics provides a convenient conversion tool to convert labels from the popular COCO dataset format to YOLO format:</p> <p>Example</p> Python <pre><code>from ultralytics.data.converter import convert_coco\n\nconvert_coco(labels_dir='path/to/coco/annotations/', use_keypoints=True)\n</code></pre> <p>This conversion tool can be used to convert the COCO dataset or any dataset in the COCO format to the Ultralytics YOLO format. The <code>use_keypoints</code> parameter specifies whether to include keypoints (for pose estimation) in the converted labels.</p>"},{"location":"datasets/pose/coco/","title":"COCO-Pose Dataset","text":"<p>The COCO-Pose dataset is a specialized version of the COCO (Common Objects in Context) dataset, designed for pose estimation tasks. It leverages the COCO Keypoints 2017 images and labels to enable the training of models like YOLO for pose estimation tasks.</p> <p></p>"},{"location":"datasets/pose/coco/#key-features","title":"Key Features","text":"<ul> <li>COCO-Pose builds upon the COCO Keypoints 2017 dataset which contains 200K images labeled with keypoints for pose estimation tasks.</li> <li>The dataset supports 17 keypoints for human figures, facilitating detailed pose estimation.</li> <li>Like COCO, it provides standardized evaluation metrics, including Object Keypoint Similarity (OKS) for pose estimation tasks, making it suitable for comparing model performance.</li> </ul>"},{"location":"datasets/pose/coco/#dataset-structure","title":"Dataset Structure","text":"<p>The COCO-Pose dataset is split into three subsets:</p> <ol> <li>Train2017: This subset contains a portion of the 118K images from the COCO dataset, annotated for training pose estimation models.</li> <li>Val2017: This subset has a selection of images used for validation purposes during model training.</li> <li>Test2017: This subset consists of images used for testing and benchmarking the trained models. Ground truth annotations for this subset are not publicly available, and the results are submitted to the COCO evaluation server for performance evaluation.</li> </ol>"},{"location":"datasets/pose/coco/#applications","title":"Applications","text":"<p>The COCO-Pose dataset is specifically used for training and evaluating deep learning models in keypoint detection and pose estimation tasks, such as OpenPose. The dataset's large number of annotated images and standardized evaluation metrics make it an essential resource for computer vision researchers and practitioners focused on pose estimation.</p>"},{"location":"datasets/pose/coco/#dataset-yaml","title":"Dataset YAML","text":"<p>A YAML (Yet Another Markup Language) file is used to define the dataset configuration. It contains information about the dataset's paths, classes, and other relevant information. In the case of the COCO-Pose dataset, the <code>coco-pose.yaml</code> file is maintained at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/cfg/datasets/coco-pose.yaml.</p> <p>ultralytics/cfg/datasets/coco-pose.yaml</p> <pre><code># Ultralytics YOLO \ud83d\ude80, AGPL-3.0 license\n# COCO 2017 dataset http://cocodataset.org by Microsoft\n# Documentation: https://docs.ultralytics.com/datasets/pose/coco/\n# Example usage: yolo train data=coco-pose.yaml\n# parent\n# \u251c\u2500\u2500 ultralytics\n# \u2514\u2500\u2500 datasets\n#     \u2514\u2500\u2500 coco-pose  \u2190 downloads here (20.1 GB)\n\n\n# Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]\npath: ../datasets/coco-pose  # dataset root dir\ntrain: train2017.txt  # train images (relative to 'path') 118287 images\nval: val2017.txt  # val images (relative to 'path') 5000 images\ntest: test-dev2017.txt  # 20288 of 40670 images, submit to https://competitions.codalab.org/competitions/20794\n\n# Keypoints\nkpt_shape: [17, 3]  # number of keypoints, number of dims (2 for x,y or 3 for x,y,visible)\nflip_idx: [0, 2, 1, 4, 3, 6, 5, 8, 7, 10, 9, 12, 11, 14, 13, 16, 15]\n\n# Classes\nnames:\n  0: person\n\n# Download script/URL (optional)\ndownload: |\n  from ultralytics.utils.downloads import download\n  from pathlib import Path\n\n  # Download labels\n  dir = Path(yaml['path'])  # dataset root dir\n  url = 'https://github.com/ultralytics/yolov5/releases/download/v1.0/'\n  urls = [url + 'coco2017labels-pose.zip']  # labels\n  download(urls, dir=dir.parent)\n  # Download data\n  urls = ['http://images.cocodataset.org/zips/train2017.zip',  # 19G, 118k images\n          'http://images.cocodataset.org/zips/val2017.zip',  # 1G, 5k images\n          'http://images.cocodataset.org/zips/test2017.zip']  # 7G, 41k images (optional)\n  download(urls, dir=dir / 'images', threads=3)\n</code></pre>"},{"location":"datasets/pose/coco/#usage","title":"Usage","text":"<p>To train a YOLOv8n-pose model on the COCO-Pose dataset for 100 epochs with an image size of 640, you can use the following code snippets. For a comprehensive list of available arguments, refer to the model Training page.</p> <p>Train Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-pose.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='coco-pose.yaml', epochs=100, imgsz=640)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\nyolo detect train data=coco-pose.yaml model=yolov8n.pt epochs=100 imgsz=640\n</code></pre>"},{"location":"datasets/pose/coco/#sample-images-and-annotations","title":"Sample Images and Annotations","text":"<p>The COCO-Pose dataset contains a diverse set of images with human figures annotated with keypoints. Here are some examples of images from the dataset, along with their corresponding annotations:</p> <p></p> <ul> <li>Mosaiced Image: This image demonstrates a training batch composed of mosaiced dataset images. Mosaicing is a technique used during training that combines multiple images into a single image to increase the variety of objects and scenes within each training batch. This helps improve the model's ability to generalize to different object sizes, aspect ratios, and contexts.</li> </ul> <p>The example showcases the variety and complexity of the images in the COCO-Pose dataset and the benefits of using mosaicing during the training process.</p>"},{"location":"datasets/pose/coco/#citations-and-acknowledgments","title":"Citations and Acknowledgments","text":"<p>If you use the COCO-Pose dataset in your research or development work, please cite the following paper:</p> BibTeX <pre><code>@misc{lin2015microsoft,\n      title={Microsoft COCO: Common Objects in Context},\n      author={Tsung-Yi Lin and Michael Maire and Serge Belongie and Lubomir Bourdev and Ross Girshick and James Hays and Pietro Perona and Deva Ramanan and C. Lawrence Zitnick and Piotr Doll\u00e1r},\n      year={2015},\n      eprint={1405.0312},\n      archivePrefix={arXiv},\n      primaryClass={cs.CV}\n}\n</code></pre> <p>We would like to acknowledge the COCO Consortium for creating and maintaining this valuable resource for the computer vision community. For more information about the COCO-Pose dataset and its creators, visit the COCO dataset website.</p>"},{"location":"datasets/pose/coco8-pose/","title":"COCO8-Pose Dataset","text":""},{"location":"datasets/pose/coco8-pose/#introduction","title":"Introduction","text":"<p>Ultralytics COCO8-Pose is a small, but versatile pose detection dataset composed of the first 8 images of the COCO train 2017 set, 4 for training and 4 for validation. This dataset is ideal for testing and debugging object detection models, or for experimenting with new detection approaches. With 8 images, it is small enough to be easily manageable, yet diverse enough to test training pipelines for errors and act as a sanity check before training larger datasets.</p> <p>This dataset is intended for use with Ultralytics HUB and YOLOv8.</p>"},{"location":"datasets/pose/coco8-pose/#dataset-yaml","title":"Dataset YAML","text":"<p>A YAML (Yet Another Markup Language) file is used to define the dataset configuration. It contains information about the dataset's paths, classes, and other relevant information. In the case of the COCO8-Pose dataset, the <code>coco8-pose.yaml</code> file is maintained at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/cfg/datasets/coco8-pose.yaml.</p> <p>ultralytics/cfg/datasets/coco8-pose.yaml</p> <pre><code># Ultralytics YOLO \ud83d\ude80, AGPL-3.0 license\n# COCO8-pose dataset (first 8 images from COCO train2017) by Ultralytics\n# Documentation: https://docs.ultralytics.com/datasets/pose/coco8-pose/\n# Example usage: yolo train data=coco8-pose.yaml\n# parent\n# \u251c\u2500\u2500 ultralytics\n# \u2514\u2500\u2500 datasets\n#     \u2514\u2500\u2500 coco8-pose  \u2190 downloads here (1 MB)\n\n\n# Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]\npath: ../datasets/coco8-pose  # dataset root dir\ntrain: images/train  # train images (relative to 'path') 4 images\nval: images/val  # val images (relative to 'path') 4 images\ntest:  # test images (optional)\n\n# Keypoints\nkpt_shape: [17, 3]  # number of keypoints, number of dims (2 for x,y or 3 for x,y,visible)\nflip_idx: [0, 2, 1, 4, 3, 6, 5, 8, 7, 10, 9, 12, 11, 14, 13, 16, 15]\n\n# Classes\nnames:\n  0: person\n\n# Download script/URL (optional)\ndownload: https://ultralytics.com/assets/coco8-pose.zip\n</code></pre>"},{"location":"datasets/pose/coco8-pose/#usage","title":"Usage","text":"<p>To train a YOLOv8n-pose model on the COCO8-Pose dataset for 100 epochs with an image size of 640, you can use the following code snippets. For a comprehensive list of available arguments, refer to the model Training page.</p> <p>Train Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-pose.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='coco8-pose.yaml', epochs=100, imgsz=640)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\nyolo detect train data=coco8-pose.yaml model=yolov8n.pt epochs=100 imgsz=640\n</code></pre>"},{"location":"datasets/pose/coco8-pose/#sample-images-and-annotations","title":"Sample Images and Annotations","text":"<p>Here are some examples of images from the COCO8-Pose dataset, along with their corresponding annotations:</p> <p></p> <ul> <li>Mosaiced Image: This image demonstrates a training batch composed of mosaiced dataset images. Mosaicing is a technique used during training that combines multiple images into a single image to increase the variety of objects and scenes within each training batch. This helps improve the model's ability to generalize to different object sizes, aspect ratios, and contexts.</li> </ul> <p>The example showcases the variety and complexity of the images in the COCO8-Pose dataset and the benefits of using mosaicing during the training process.</p>"},{"location":"datasets/pose/coco8-pose/#citations-and-acknowledgments","title":"Citations and Acknowledgments","text":"<p>If you use the COCO dataset in your research or development work, please cite the following paper:</p> BibTeX <pre><code>@misc{lin2015microsoft,\n      title={Microsoft COCO: Common Objects in Context},\n      author={Tsung-Yi Lin and Michael Maire and Serge Belongie and Lubomir Bourdev and Ross Girshick and James Hays and Pietro Perona and Deva Ramanan and C. Lawrence Zitnick and Piotr Doll\u00e1r},\n      year={2015},\n      eprint={1405.0312},\n      archivePrefix={arXiv},\n      primaryClass={cs.CV}\n}\n</code></pre> <p>We would like to acknowledge the COCO Consortium for creating and maintaining this valuable resource for the computer vision community. For more information about the COCO dataset and its creators, visit the COCO dataset website.</p>"},{"location":"datasets/pose/tiger-pose/","title":"Tiger-Pose Dataset","text":""},{"location":"datasets/pose/tiger-pose/#introduction","title":"Introduction","text":"<p>Ultralytics introduces the Tiger-Pose dataset, a versatile collection designed for pose estimation tasks. This dataset comprises 263 images sourced from a YouTube Video, with 210 images allocated for training and 53 for validation. It serves as an excellent resource for testing and troubleshooting pose estimation algorithm.</p> <p>Despite its manageable size of 210 images, tiger-pose dataset offers diversity, making it suitable for assessing training pipelines, identifying potential errors, and serving as a valuable preliminary step before working with larger datasets for pose estimation.</p> <p>This dataset is intended for use with Ultralytics HUB and YOLOv8.</p> <p> Watch: Train YOLOv8 Pose Model on Tiger-Pose Dataset Using Ultralytics HUB </p>"},{"location":"datasets/pose/tiger-pose/#dataset-yaml","title":"Dataset YAML","text":"<p>A YAML (Yet Another Markup Language) file serves as the means to specify the configuration details of a dataset. It encompasses crucial data such as file paths, class definitions, and other pertinent information. Specifically, for the <code>tiger-pose.yaml</code> file, you can check Ultralytics Tiger-Pose Dataset Configuration File.</p> <p>ultralytics/cfg/datasets/tiger-pose.yaml</p> <pre><code># Ultralytics YOLO \ud83d\ude80, AGPL-3.0 license\n# Tiger Pose dataset by Ultralytics\n# Documentation: https://docs.ultralytics.com/datasets/pose/tiger-pose/\n# Example usage: yolo train data=tiger-pose.yaml\n# parent\n# \u251c\u2500\u2500 ultralytics\n# \u2514\u2500\u2500 datasets\n#     \u2514\u2500\u2500 tiger-pose  \u2190 downloads here (75.3 MB)\n\n\n# Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]\npath: ../datasets/tiger-pose  # dataset root dir\ntrain: train  # train images (relative to 'path') 210 images\nval: val  # val images (relative to 'path') 53 images\n\n# Keypoints\nkpt_shape: [12, 2]  # number of keypoints, number of dims (2 for x,y or 3 for x,y,visible)\nflip_idx: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n\n# Classes\nnames:\n  0: tiger\n\n# Download script/URL (optional)\ndownload: https://ultralytics.com/assets/tiger-pose.zip\n</code></pre>"},{"location":"datasets/pose/tiger-pose/#usage","title":"Usage","text":"<p>To train a YOLOv8n-pose model on the Tiger-Pose dataset for 100 epochs with an image size of 640, you can use the following code snippets. For a comprehensive list of available arguments, refer to the model Training page.</p> <p>Train Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-pose.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='tiger-pose.yaml', epochs=100, imgsz=640)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\nyolo task=pose mode=train data=tiger-pose.yaml model=yolov8n.pt epochs=100 imgsz=640\n</code></pre>"},{"location":"datasets/pose/tiger-pose/#sample-images-and-annotations","title":"Sample Images and Annotations","text":"<p>Here are some examples of images from the Tiger-Pose dataset, along with their corresponding annotations:</p> <p></p> <ul> <li>Mosaiced Image: This image demonstrates a training batch composed of mosaiced dataset images. Mosaicing is a technique used during training that combines multiple images into a single image to increase the variety of objects and scenes within each training batch. This helps improve the model's ability to generalize to different object sizes, aspect ratios, and contexts.</li> </ul> <p>The example showcases the variety and complexity of the images in the Tiger-Pose dataset and the benefits of using mosaicing during the training process.</p>"},{"location":"datasets/pose/tiger-pose/#inference-example","title":"Inference Example","text":"<p>Inference Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('path/to/best.pt')  # load a tiger-pose trained model\n\n# Run inference\nresults = model.predict(source=\"https://www.youtube.com/watch?v=MIBAT6BGE6U&amp;pp=ygUYdGlnZXIgd2Fsa2luZyByZWZlcmVuY2Ug\" show=True)\n</code></pre> <pre><code># Run inference using a tiger-pose trained model\nyolo task=pose mode=predict source=\"https://www.youtube.com/watch?v=MIBAT6BGE6U&amp;pp=ygUYdGlnZXIgd2Fsa2luZyByZWZlcmVuY2Ug\" show=True model=\"path/to/best.pt\"\n</code></pre>"},{"location":"datasets/pose/tiger-pose/#citations-and-acknowledgments","title":"Citations and Acknowledgments","text":"<p>The dataset has been released available under the AGPL-3.0 License.</p>"},{"location":"datasets/segment/","title":"Instance Segmentation Datasets Overview","text":""},{"location":"datasets/segment/#supported-dataset-formats","title":"Supported Dataset Formats","text":""},{"location":"datasets/segment/#ultralytics-yolo-format","title":"Ultralytics YOLO format","text":"<p>The dataset label format used for training YOLO segmentation models is as follows:</p> <ol> <li>One text file per image: Each image in the dataset has a corresponding text file with the same name as the image file and the \".txt\" extension.</li> <li>One row per object: Each row in the text file corresponds to one object instance in the image.</li> <li>Object information per row: Each row contains the following information about the object instance:<ul> <li>Object class index: An integer representing the class of the object (e.g., 0 for person, 1 for car, etc.).</li> <li>Object bounding coordinates: The bounding coordinates around the mask area, normalized to be between 0 and 1.</li> </ul> </li> </ol> <p>The format for a single row in the segmentation dataset file is as follows:</p> <pre><code>&lt;class-index&gt; &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; ... &lt;xn&gt; &lt;yn&gt;\n</code></pre> <p>In this format, <code>&lt;class-index&gt;</code> is the index of the class for the object, and <code>&lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; ... &lt;xn&gt; &lt;yn&gt;</code> are the bounding coordinates of the object's segmentation mask. The coordinates are separated by spaces.</p> <p>Here is an example of the YOLO dataset format for a single image with two objects made up of a 3-point segment and a 5-point segment.</p> <pre><code>0 0.681 0.485 0.670 0.487 0.676 0.487\n1 0.504 0.000 0.501 0.004 0.498 0.004 0.493 0.010 0.492 0.0104\n</code></pre> <p>Tip</p> <ul> <li>The length of each row does not have to be equal.</li> <li>Each segmentation label must have a minimum of 3 xy points: <code>&lt;class-index&gt; &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; &lt;x3&gt; &lt;y3&gt;</code></li> </ul>"},{"location":"datasets/segment/#dataset-yaml-format","title":"Dataset YAML format","text":"<p>The Ultralytics framework uses a YAML file format to define the dataset and model configuration for training Detection Models. Here is an example of the YAML format used for defining a detection dataset:</p> <pre><code># Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]\npath: ../datasets/coco8-seg  # dataset root dir\ntrain: images/train  # train images (relative to 'path') 4 images\nval: images/val  # val images (relative to 'path') 4 images\ntest:  # test images (optional)\n\n# Classes (80 COCO classes)\nnames:\n  0: person\n  1: bicycle\n  2: car\n  # ...\n  77: teddy bear\n  78: hair drier\n  79: toothbrush\n</code></pre> <p>The <code>train</code> and <code>val</code> fields specify the paths to the directories containing the training and validation images, respectively.</p> <p><code>names</code> is a dictionary of class names. The order of the names should match the order of the object class indices in the YOLO dataset files.</p>"},{"location":"datasets/segment/#usage","title":"Usage","text":"<p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-seg.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='coco128-seg.yaml', epochs=100, imgsz=640)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\nyolo detect train data=coco128-seg.yaml model=yolov8n-seg.pt epochs=100 imgsz=640\n</code></pre>"},{"location":"datasets/segment/#supported-datasets","title":"Supported Datasets","text":"<ul> <li>COCO: A large-scale dataset designed for object detection, segmentation, and captioning tasks with over 200K labeled images.</li> <li>COCO8-seg: A smaller dataset for instance segmentation tasks, containing a subset of 8 COCO images with segmentation annotations.</li> </ul>"},{"location":"datasets/segment/#adding-your-own-dataset","title":"Adding your own dataset","text":"<p>If you have your own dataset and would like to use it for training segmentation models with Ultralytics YOLO format, ensure that it follows the format specified above under \"Ultralytics YOLO format\". Convert your annotations to the required format and specify the paths, number of classes, and class names in the YAML configuration file.</p>"},{"location":"datasets/segment/#port-or-convert-label-formats","title":"Port or Convert Label Formats","text":""},{"location":"datasets/segment/#coco-dataset-format-to-yolo-format","title":"COCO Dataset Format to YOLO Format","text":"<p>You can easily convert labels from the popular COCO dataset format to the YOLO format using the following code snippet:</p> <p>Example</p> Python <pre><code>from ultralytics.data.converter import convert_coco\n\nconvert_coco(labels_dir='path/to/coco/annotations/', use_segments=True)\n</code></pre> <p>This conversion tool can be used to convert the COCO dataset or any dataset in the COCO format to the Ultralytics YOLO format.</p> <p>Remember to double-check if the dataset you want to use is compatible with your model and follows the necessary format conventions. Properly formatted datasets are crucial for training successful object detection models.</p>"},{"location":"datasets/segment/#auto-annotation","title":"Auto-Annotation","text":"<p>Auto-annotation is an essential feature that allows you to generate a segmentation dataset using a pre-trained detection model. It enables you to quickly and accurately annotate a large number of images without the need for manual labeling, saving time and effort.</p>"},{"location":"datasets/segment/#generate-segmentation-dataset-using-a-detection-model","title":"Generate Segmentation Dataset Using a Detection Model","text":"<p>To auto-annotate your dataset using the Ultralytics framework, you can use the <code>auto_annotate</code> function as shown below:</p> <p>Example</p> Python <pre><code>from ultralytics.data.annotator import auto_annotate\n\nauto_annotate(data=\"path/to/images\", det_model=\"yolov8x.pt\", sam_model='sam_b.pt')\n</code></pre> <p>Certainly, here is the table updated with code snippets:</p> Argument Type Description Default <code>data</code> <code>str</code> Path to a folder containing images to be annotated. <code>None</code> <code>det_model</code> <code>str, optional</code> Pre-trained YOLO detection model. Defaults to <code>'yolov8x.pt'</code>. <code>'yolov8x.pt'</code> <code>sam_model</code> <code>str, optional</code> Pre-trained SAM segmentation model. Defaults to <code>'sam_b.pt'</code>. <code>'sam_b.pt'</code> <code>device</code> <code>str, optional</code> Device to run the models on. Defaults to an empty string (CPU or GPU, if available). <code>''</code> <code>output_dir</code> <code>str or None, optional</code> Directory to save the annotated results. Defaults to a <code>'labels'</code> folder in the same directory as <code>'data'</code>. <code>None</code> <p>The <code>auto_annotate</code> function takes the path to your images, along with optional arguments for specifying the pre-trained detection and SAM segmentation models, the device to run the models on, and the output directory for saving the annotated results.</p> <p>By leveraging the power of pre-trained models, auto-annotation can significantly reduce the time and effort required for creating high-quality segmentation datasets. This feature is particularly useful for researchers and developers working with large image collections, as it allows them to focus on model development and evaluation rather than manual annotation.</p>"},{"location":"datasets/segment/coco/","title":"COCO-Seg Dataset","text":"<p>The COCO-Seg dataset, an extension of the COCO (Common Objects in Context) dataset, is specially designed to aid research in object instance segmentation. It uses the same images as COCO but introduces more detailed segmentation annotations. This dataset is a crucial resource for researchers and developers working on instance segmentation tasks, especially for training YOLO models.</p>"},{"location":"datasets/segment/coco/#key-features","title":"Key Features","text":"<ul> <li>COCO-Seg retains the original 330K images from COCO.</li> <li>The dataset consists of the same 80 object categories found in the original COCO dataset.</li> <li>Annotations now include more detailed instance segmentation masks for each object in the images.</li> <li>COCO-Seg provides standardized evaluation metrics like mean Average Precision (mAP) for object detection, and mean Average Recall (mAR) for instance segmentation tasks, enabling effective comparison of model performance.</li> </ul>"},{"location":"datasets/segment/coco/#dataset-structure","title":"Dataset Structure","text":"<p>The COCO-Seg dataset is partitioned into three subsets:</p> <ol> <li>Train2017: This subset contains 118K images for training instance segmentation models.</li> <li>Val2017: This subset includes 5K images used for validation purposes during model training.</li> <li>Test2017: This subset encompasses 20K images used for testing and benchmarking the trained models. Ground truth annotations for this subset are not publicly available, and the results are submitted to the COCO evaluation server for performance evaluation.</li> </ol>"},{"location":"datasets/segment/coco/#applications","title":"Applications","text":"<p>COCO-Seg is widely used for training and evaluating deep learning models in instance segmentation, such as the YOLO models. The large number of annotated images, the diversity of object categories, and the standardized evaluation metrics make it an indispensable resource for computer vision researchers and practitioners.</p>"},{"location":"datasets/segment/coco/#dataset-yaml","title":"Dataset YAML","text":"<p>A YAML (Yet Another Markup Language) file is used to define the dataset configuration. It contains information about the dataset's paths, classes, and other relevant information. In the case of the COCO-Seg dataset, the <code>coco.yaml</code> file is maintained at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/cfg/datasets/coco.yaml.</p> <p>ultralytics/cfg/datasets/coco.yaml</p> <pre><code># Ultralytics YOLO \ud83d\ude80, AGPL-3.0 license\n# COCO 2017 dataset http://cocodataset.org by Microsoft\n# Documentation: https://docs.ultralytics.com/datasets/detect/coco/\n# Example usage: yolo train data=coco.yaml\n# parent\n# \u251c\u2500\u2500 ultralytics\n# \u2514\u2500\u2500 datasets\n#     \u2514\u2500\u2500 coco  \u2190 downloads here (20.1 GB)\n\n\n# Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]\npath: ../datasets/coco  # dataset root dir\ntrain: train2017.txt  # train images (relative to 'path') 118287 images\nval: val2017.txt  # val images (relative to 'path') 5000 images\ntest: test-dev2017.txt  # 20288 of 40670 images, submit to https://competitions.codalab.org/competitions/20794\n\n# Classes\nnames:\n  0: person\n  1: bicycle\n  2: car\n  3: motorcycle\n  4: airplane\n  5: bus\n  6: train\n  7: truck\n  8: boat\n  9: traffic light\n  10: fire hydrant\n  11: stop sign\n  12: parking meter\n  13: bench\n  14: bird\n  15: cat\n  16: dog\n  17: horse\n  18: sheep\n  19: cow\n  20: elephant\n  21: bear\n  22: zebra\n  23: giraffe\n  24: backpack\n  25: umbrella\n  26: handbag\n  27: tie\n  28: suitcase\n  29: frisbee\n  30: skis\n  31: snowboard\n  32: sports ball\n  33: kite\n  34: baseball bat\n  35: baseball glove\n  36: skateboard\n  37: surfboard\n  38: tennis racket\n  39: bottle\n  40: wine glass\n  41: cup\n  42: fork\n  43: knife\n  44: spoon\n  45: bowl\n  46: banana\n  47: apple\n  48: sandwich\n  49: orange\n  50: broccoli\n  51: carrot\n  52: hot dog\n  53: pizza\n  54: donut\n  55: cake\n  56: chair\n  57: couch\n  58: potted plant\n  59: bed\n  60: dining table\n  61: toilet\n  62: tv\n  63: laptop\n  64: mouse\n  65: remote\n  66: keyboard\n  67: cell phone\n  68: microwave\n  69: oven\n  70: toaster\n  71: sink\n  72: refrigerator\n  73: book\n  74: clock\n  75: vase\n  76: scissors\n  77: teddy bear\n  78: hair drier\n  79: toothbrush\n\n\n# Download script/URL (optional)\ndownload: |\n  from ultralytics.utils.downloads import download\n  from pathlib import Path\n\n  # Download labels\n  segments = True  # segment or box labels\n  dir = Path(yaml['path'])  # dataset root dir\n  url = 'https://github.com/ultralytics/yolov5/releases/download/v1.0/'\n  urls = [url + ('coco2017labels-segments.zip' if segments else 'coco2017labels.zip')]  # labels\n  download(urls, dir=dir.parent)\n  # Download data\n  urls = ['http://images.cocodataset.org/zips/train2017.zip',  # 19G, 118k images\n          'http://images.cocodataset.org/zips/val2017.zip',  # 1G, 5k images\n          'http://images.cocodataset.org/zips/test2017.zip']  # 7G, 41k images (optional)\n  download(urls, dir=dir / 'images', threads=3)\n</code></pre>"},{"location":"datasets/segment/coco/#usage","title":"Usage","text":"<p>To train a YOLOv8n-seg model on the COCO-Seg dataset for 100 epochs with an image size of 640, you can use the following code snippets. For a comprehensive list of available arguments, refer to the model Training page.</p> <p>Train Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-seg.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='coco-seg.yaml', epochs=100, imgsz=640)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\nyolo detect train data=coco-seg.yaml model=yolov8n.pt epochs=100 imgsz=640\n</code></pre>"},{"location":"datasets/segment/coco/#sample-images-and-annotations","title":"Sample Images and Annotations","text":"<p>COCO-Seg, like its predecessor COCO, contains a diverse set of images with various object categories and complex scenes. However, COCO-Seg introduces more detailed instance segmentation masks for each object in the images. Here are some examples of images from the dataset, along with their corresponding instance segmentation masks:</p> <p></p> <ul> <li>Mosaiced Image: This image demonstrates a training batch composed of mosaiced dataset images. Mosaicing is a technique used during training that combines multiple images into a single image to increase the variety of objects and scenes within each training batch. This aids the model's ability to generalize to different object sizes, aspect ratios, and contexts.</li> </ul> <p>The example showcases the variety and complexity of the images in the COCO-Seg dataset and the benefits of using mosaicing during the training process.</p>"},{"location":"datasets/segment/coco/#citations-and-acknowledgments","title":"Citations and Acknowledgments","text":"<p>If you use the COCO-Seg dataset in your research or development work, please cite the original COCO paper and acknowledge the extension to COCO-Seg:</p> BibTeX <pre><code>@misc{lin2015microsoft,\n      title={Microsoft COCO: Common Objects in Context},\n      author={Tsung-Yi Lin and Michael Maire and Serge Belongie and Lubomir Bourdev and Ross Girshick and James Hays and Pietro Perona and Deva Ramanan and C. Lawrence Zitnick and Piotr Doll\u00e1r},\n      year={2015},\n      eprint={1405.0312},\n      archivePrefix={arXiv},\n      primaryClass={cs.CV}\n}\n</code></pre> <p>We extend our thanks to the COCO Consortium for creating and maintaining this invaluable resource for the computer vision community. For more information about the COCO dataset and its creators, visit the COCO dataset website.</p>"},{"location":"datasets/segment/coco8-seg/","title":"COCO8-Seg Dataset","text":""},{"location":"datasets/segment/coco8-seg/#introduction","title":"Introduction","text":"<p>Ultralytics COCO8-Seg is a small, but versatile instance segmentation dataset composed of the first 8 images of the COCO train 2017 set, 4 for training and 4 for validation. This dataset is ideal for testing and debugging segmentation models, or for experimenting with new detection approaches. With 8 images, it is small enough to be easily manageable, yet diverse enough to test training pipelines for errors and act as a sanity check before training larger datasets.</p> <p>This dataset is intended for use with Ultralytics HUB and YOLOv8.</p>"},{"location":"datasets/segment/coco8-seg/#dataset-yaml","title":"Dataset YAML","text":"<p>A YAML (Yet Another Markup Language) file is used to define the dataset configuration. It contains information about the dataset's paths, classes, and other relevant information. In the case of the COCO8-Seg dataset, the <code>coco8-seg.yaml</code> file is maintained at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/cfg/datasets/coco8-seg.yaml.</p> <p>ultralytics/cfg/datasets/coco8-seg.yaml</p> <pre><code># Ultralytics YOLO \ud83d\ude80, AGPL-3.0 license\n# COCO8-seg dataset (first 8 images from COCO train2017) by Ultralytics\n# Documentation: https://docs.ultralytics.com/datasets/segment/coco8-seg/\n# Example usage: yolo train data=coco8-seg.yaml\n# parent\n# \u251c\u2500\u2500 ultralytics\n# \u2514\u2500\u2500 datasets\n#     \u2514\u2500\u2500 coco8-seg  \u2190 downloads here (1 MB)\n\n\n# Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]\npath: ../datasets/coco8-seg  # dataset root dir\ntrain: images/train  # train images (relative to 'path') 4 images\nval: images/val  # val images (relative to 'path') 4 images\ntest:  # test images (optional)\n\n# Classes\nnames:\n  0: person\n  1: bicycle\n  2: car\n  3: motorcycle\n  4: airplane\n  5: bus\n  6: train\n  7: truck\n  8: boat\n  9: traffic light\n  10: fire hydrant\n  11: stop sign\n  12: parking meter\n  13: bench\n  14: bird\n  15: cat\n  16: dog\n  17: horse\n  18: sheep\n  19: cow\n  20: elephant\n  21: bear\n  22: zebra\n  23: giraffe\n  24: backpack\n  25: umbrella\n  26: handbag\n  27: tie\n  28: suitcase\n  29: frisbee\n  30: skis\n  31: snowboard\n  32: sports ball\n  33: kite\n  34: baseball bat\n  35: baseball glove\n  36: skateboard\n  37: surfboard\n  38: tennis racket\n  39: bottle\n  40: wine glass\n  41: cup\n  42: fork\n  43: knife\n  44: spoon\n  45: bowl\n  46: banana\n  47: apple\n  48: sandwich\n  49: orange\n  50: broccoli\n  51: carrot\n  52: hot dog\n  53: pizza\n  54: donut\n  55: cake\n  56: chair\n  57: couch\n  58: potted plant\n  59: bed\n  60: dining table\n  61: toilet\n  62: tv\n  63: laptop\n  64: mouse\n  65: remote\n  66: keyboard\n  67: cell phone\n  68: microwave\n  69: oven\n  70: toaster\n  71: sink\n  72: refrigerator\n  73: book\n  74: clock\n  75: vase\n  76: scissors\n  77: teddy bear\n  78: hair drier\n  79: toothbrush\n\n\n# Download script/URL (optional)\ndownload: https://ultralytics.com/assets/coco8-seg.zip\n</code></pre>"},{"location":"datasets/segment/coco8-seg/#usage","title":"Usage","text":"<p>To train a YOLOv8n-seg model on the COCO8-Seg dataset for 100 epochs with an image size of 640, you can use the following code snippets. For a comprehensive list of available arguments, refer to the model Training page.</p> <p>Train Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-seg.pt')  # load a pretrained model (recommended for training)\n\n# Train the model\nresults = model.train(data='coco8-seg.yaml', epochs=100, imgsz=640)\n</code></pre> <pre><code># Start training from a pretrained *.pt model\nyolo detect train data=coco8-seg.yaml model=yolov8n.pt epochs=100 imgsz=640\n</code></pre>"},{"location":"datasets/segment/coco8-seg/#sample-images-and-annotations","title":"Sample Images and Annotations","text":"<p>Here are some examples of images from the COCO8-Seg dataset, along with their corresponding annotations:</p> <p></p> <ul> <li>Mosaiced Image: This image demonstrates a training batch composed of mosaiced dataset images. Mosaicing is a technique used during training that combines multiple images into a single image to increase the variety of objects and scenes within each training batch. This helps improve the model's ability to generalize to different object sizes, aspect ratios, and contexts.</li> </ul> <p>The example showcases the variety and complexity of the images in the COCO8-Seg dataset and the benefits of using mosaicing during the training process.</p>"},{"location":"datasets/segment/coco8-seg/#citations-and-acknowledgments","title":"Citations and Acknowledgments","text":"<p>If you use the COCO dataset in your research or development work, please cite the following paper:</p> BibTeX <pre><code>@misc{lin2015microsoft,\n      title={Microsoft COCO: Common Objects in Context},\n      author={Tsung-Yi Lin and Michael Maire and Serge Belongie and Lubomir Bourdev and Ross Girshick and James Hays and Pietro Perona and Deva Ramanan and C. Lawrence Zitnick and Piotr Doll\u00e1r},\n      year={2015},\n      eprint={1405.0312},\n      archivePrefix={arXiv},\n      primaryClass={cs.CV}\n}\n</code></pre> <p>We would like to acknowledge the COCO Consortium for creating and maintaining this valuable resource for the computer vision community. For more information about the COCO dataset and its creators, visit the COCO dataset website.</p>"},{"location":"datasets/track/","title":"Multi-object Tracking Datasets Overview","text":""},{"location":"datasets/track/#dataset-format-coming-soon","title":"Dataset Format (Coming Soon)","text":"<p>Multi-Object Detector doesn't need standalone training and directly supports pre-trained detection, segmentation or Pose models. Support for training trackers alone is coming soon</p>"},{"location":"datasets/track/#usage","title":"Usage","text":"<p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\nmodel = YOLO('yolov8n.pt')\nresults = model.track(source=\"https://youtu.be/LNwODJXcvt4\", conf=0.3, iou=0.5, show=True)\n</code></pre> <pre><code>yolo track model=yolov8n.pt source=\"https://youtu.be/LNwODJXcvt4\" conf=0.3, iou=0.5 show\n</code></pre>"},{"location":"guides/","title":"Comprehensive Tutorials to Ultralytics YOLO","text":"<p>Welcome to the Ultralytics' YOLO \ud83d\ude80 Guides! Our comprehensive tutorials cover various aspects of the YOLO object detection model, ranging from training and prediction to deployment. Built on PyTorch, YOLO stands out for its exceptional speed and accuracy in real-time object detection tasks.</p> <p>Whether you're a beginner or an expert in deep learning, our tutorials offer valuable insights into the implementation and optimization of YOLO for your computer vision projects. Let's dive in!</p>"},{"location":"guides/#guides","title":"Guides","text":"<p>Here's a compilation of in-depth guides to help you master different aspects of Ultralytics YOLO.</p> <ul> <li>YOLO Common Issues \u2b50 RECOMMENDED: Practical solutions and troubleshooting tips to the most frequently encountered issues when working with Ultralytics YOLO models.</li> <li>YOLO Performance Metrics \u2b50 ESSENTIAL: Understand the key metrics like mAP, IoU, and F1 score used to evaluate the performance of your YOLO models. Includes practical examples and tips on how to improve detection accuracy and speed.</li> <li>Model Deployment Options: Overview of YOLO model deployment formats like ONNX, OpenVINO, and TensorRT, with pros and cons for each to inform your deployment strategy.</li> <li>K-Fold Cross Validation \ud83d\ude80 NEW: Learn how to improve model generalization using K-Fold cross-validation technique.</li> <li>Hyperparameter Tuning \ud83d\ude80 NEW: Discover how to optimize your YOLO models by fine-tuning hyperparameters using the Tuner class and genetic evolution algorithms.</li> <li>SAHI Tiled Inference \ud83d\ude80 NEW: Comprehensive guide on leveraging SAHI's sliced inference capabilities with YOLOv8 for object detection in high-resolution images.</li> <li>AzureML Quickstart \ud83d\ude80 NEW: Get up and running with Ultralytics YOLO models on Microsoft's Azure Machine Learning platform. Learn how to train, deploy, and scale your object detection projects in the cloud.</li> <li>Conda Quickstart \ud83d\ude80 NEW: Step-by-step guide to setting up a Conda environment for Ultralytics. Learn how to install and start using the Ultralytics package efficiently with Conda.</li> <li>Docker Quickstart \ud83d\ude80 NEW: Complete guide to setting up and using Ultralytics YOLO models with Docker. Learn how to install Docker, manage GPU support, and run YOLO models in isolated containers for consistent development and deployment.</li> <li>Raspberry Pi \ud83d\ude80 NEW: Quickstart tutorial to run YOLO models to the latest Raspberry Pi hardware.</li> <li>Triton Inference Server Integration \ud83d\ude80 NEW: Dive into the integration of Ultralytics YOLOv8 with NVIDIA's Triton Inference Server for scalable and efficient deep learning inference deployments.</li> <li>YOLO Thread-Safe Inference \ud83d\ude80 NEW: Guidelines for performing inference with YOLO models in a thread-safe manner. Learn the importance of thread safety and best practices to prevent race conditions and ensure consistent predictions.</li> <li>Isolating Segmentation Objects \ud83d\ude80 NEW: Step-by-step recipe and explanation on how to extract and/or isolate objects from images using Ultralytics Segmentation.</li> </ul>"},{"location":"guides/#real-world-projects","title":"Real-World Projects","text":"<ul> <li>Object Counting \ud83d\ude80 NEW: Explore the process of real-time object counting with Ultralytics YOLOv8 and acquire the knowledge to effectively count objects in a live video stream.</li> <li>Object Cropping \ud83d\ude80 NEW: Explore object cropping using YOLOv8 for precise extraction of objects from images and videos.</li> <li>Object Blurring \ud83d\ude80 NEW: Apply object blurring with YOLOv8 for privacy protection in image and video processing.</li> <li>Workouts Monitoring \ud83d\ude80 NEW: Discover the comprehensive approach to monitoring workouts with Ultralytics YOLOv8. Acquire the skills and insights necessary to effectively use YOLOv8 for tracking and analyzing various aspects of fitness routines in real time.</li> <li>Objects Counting in Regions \ud83d\ude80 NEW: Explore counting objects in specific regions with Ultralytics YOLOv8 for precise and efficient object detection in varied areas.</li> <li>Security Alarm System \ud83d\ude80 NEW: Discover the process of creating a security alarm system with Ultralytics YOLOv8. This system triggers alerts upon detecting new objects in the frame. Subsequently, you can customize the code to align with your specific use case.</li> <li>Heatmaps \ud83d\ude80 NEW: Elevate your understanding of data with our Detection Heatmaps! These intuitive visual tools use vibrant color gradients to vividly illustrate the intensity of data values across a matrix. Essential in computer vision, heatmaps are skillfully designed to highlight areas of interest, providing an immediate, impactful way to interpret spatial information.</li> <li>Instance Segmentation with Object Tracking \ud83d\ude80 NEW: Explore our feature on Object Segmentation in Bounding Boxes Shape, providing a visual representation of precise object boundaries for enhanced understanding and analysis.</li> <li>VisionEye View Objects Mapping \ud83d\ude80 NEW: This feature aim computers to discern and focus on specific objects, much like the way the human eye observes details from a particular viewpoint.</li> <li>Speed Estimation \ud83d\ude80 NEW: Speed estimation in computer vision relies on analyzing object motion through techniques like object tracking, crucial for applications like autonomous vehicles and traffic monitoring.</li> <li>Distance Calculation \ud83d\ude80 NEW: Distance calculation, which involves measuring the separation between two objects within a defined space, is a crucial aspect. In the context of Ultralytics YOLOv8, the method employed for this involves using the bounding box centroid to determine the distance associated with user-highlighted bounding boxes.</li> </ul>"},{"location":"guides/#contribute-to-our-guides","title":"Contribute to Our Guides","text":"<p>We welcome contributions from the community! If you've mastered a particular aspect of Ultralytics YOLO that's not yet covered in our guides, we encourage you to share your expertise. Writing a guide is a great way to give back to the community and help us make our documentation more comprehensive and user-friendly.</p> <p>To get started, please read our Contributing Guide for guidelines on how to open up a Pull Request (PR) \ud83d\udee0\ufe0f. We look forward to your contributions!</p> <p>Let's work together to make the Ultralytics YOLO ecosystem more robust and versatile \ud83d\ude4f!</p>"},{"location":"guides/azureml-quickstart/","title":"YOLOv8 \ud83d\ude80 on AzureML","text":""},{"location":"guides/azureml-quickstart/#what-is-azure","title":"What is Azure?","text":"<p>Azure is Microsoft's cloud computing platform, designed to help organizations move their workloads to the cloud from on-premises data centers. With the full spectrum of cloud services including those for computing, databases, analytics, machine learning, and networking, users can pick and choose from these services to develop and scale new applications, or run existing applications, in the public cloud.</p>"},{"location":"guides/azureml-quickstart/#what-is-azure-machine-learning-azureml","title":"What is Azure Machine Learning (AzureML)?","text":"<p>Azure Machine Learning, commonly referred to as AzureML, is a fully managed cloud service that enables data scientists and developers to efficiently embed predictive analytics into their applications, helping organizations use massive data sets and bring all the benefits of the cloud to machine learning. AzureML offers a variety of services and capabilities aimed at making machine learning accessible, easy to use, and scalable. It provides capabilities like automated machine learning, drag-and-drop model training, as well as a robust Python SDK so that developers can make the most out of their machine learning models.</p>"},{"location":"guides/azureml-quickstart/#how-does-azureml-benefit-yolo-users","title":"How Does AzureML Benefit YOLO Users?","text":"<p>For users of YOLO (You Only Look Once), AzureML provides a robust, scalable, and efficient platform to both train and deploy machine learning models. Whether you are looking to run quick prototypes or scale up to handle more extensive data, AzureML's flexible and user-friendly environment offers various tools and services to fit your needs. You can leverage AzureML to:</p> <ul> <li>Easily manage large datasets and computational resources for training.</li> <li>Utilize built-in tools for data preprocessing, feature selection, and model training.</li> <li>Collaborate more efficiently with capabilities for MLOps (Machine Learning Operations), including but not limited to monitoring, auditing, and versioning of models and data.</li> </ul> <p>In the subsequent sections, you will find a quickstart guide detailing how to run YOLOv8 object detection models using AzureML, either from a compute terminal or a notebook.</p>"},{"location":"guides/azureml-quickstart/#prerequisites","title":"Prerequisites","text":"<p>Before you can get started, make sure you have access to an AzureML workspace. If you don't have one, you can create a new AzureML workspace by following Azure's official documentation. This workspace acts as a centralized place to manage all AzureML resources.</p>"},{"location":"guides/azureml-quickstart/#create-a-compute-instance","title":"Create a compute instance","text":"<p>From your AzureML workspace, select Compute &gt; Compute instances &gt; New, select the instance with the resources you need.</p> <p> </p>"},{"location":"guides/azureml-quickstart/#quickstart-from-terminal","title":"Quickstart from Terminal","text":"<p>Start your compute and open a Terminal:</p> <p> </p>"},{"location":"guides/azureml-quickstart/#create-virtualenv","title":"Create virtualenv","text":"<p>Create your conda virtualenv and install pip in it:</p> <pre><code>conda create --name yolov8env -y\nconda activate yolov8env\nconda install pip -y\n</code></pre> <p>Install the required dependencies:</p> <pre><code>cd ultralytics\npip install -r requirements.txt\npip install ultralytics\npip install onnx&gt;=1.12.0\n</code></pre>"},{"location":"guides/azureml-quickstart/#perform-yolov8-tasks","title":"Perform YOLOv8 tasks","text":"<p>Predict:</p> <pre><code>yolo predict model=yolov8n.pt source='https://ultralytics.com/images/bus.jpg'\n</code></pre> <p>Train a detection model for 10 epochs with an initial learning_rate of 0.01:</p> <pre><code>yolo train data=coco128.yaml model=yolov8n.pt epochs=10 lr0=0.01\n</code></pre> <p>You can find more instructions to use the Ultralytics CLI here.</p>"},{"location":"guides/azureml-quickstart/#quickstart-from-a-notebook","title":"Quickstart from a Notebook","text":""},{"location":"guides/azureml-quickstart/#create-a-new-ipython-kernel","title":"Create a new IPython kernel","text":"<p>Open the compute Terminal.</p> <p> </p> <p>From your compute terminal, you need to create a new ipykernel that will be used by your notebook to manage your dependencies:</p> <pre><code>conda create --name yolov8env -y\nconda activate yolov8env\nconda install pip -y\nconda install ipykernel -y\npython -m ipykernel install --user --name yolov8env --display-name \"yolov8env\"\n</code></pre> <p>Close your terminal and create a new notebook. From your Notebook, you can select the new kernel.</p> <p>Then you can open a Notebook cell and install the required dependencies:</p> <pre><code>%%bash\nsource activate yolov8env\ncd ultralytics\npip install -r requirements.txt\npip install ultralytics\npip install onnx&gt;=1.12.0\n</code></pre> <p>Note that we need to use the <code>source activate yolov8env</code> for all the %%bash cells, to make sure that the %%bash cell uses environment we want.</p> <p>Run some predictions using the Ultralytics CLI:</p> <pre><code>%%bash\nsource activate yolov8env\nyolo predict model=yolov8n.pt source='https://ultralytics.com/images/bus.jpg'\n</code></pre> <p>Or with the Ultralytics Python interface, for example to train the model:</p> <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO(\"yolov8n.pt\")  # load an official YOLOv8n model\n\n# Use the model\nmodel.train(data=\"coco128.yaml\", epochs=3)  # train the model\nmetrics = model.val()  # evaluate model performance on the validation set\nresults = model(\"https://ultralytics.com/images/bus.jpg\")  # predict on an image\npath = model.export(format=\"onnx\")  # export the model to ONNX format\n</code></pre> <p>You can use either the Ultralytics CLI or Python interface for running YOLOv8 tasks, as described in the terminal section above.</p> <p>By following these steps, you should be able to get YOLOv8 running quickly on AzureML for quick trials. For more advanced uses, you may refer to the full AzureML documentation linked at the beginning of this guide.</p>"},{"location":"guides/azureml-quickstart/#explore-more-with-azureml","title":"Explore More with AzureML","text":"<p>This guide serves as an introduction to get you up and running with YOLOv8 on AzureML. However, it only scratches the surface of what AzureML can offer. To delve deeper and unlock the full potential of AzureML for your machine learning projects, consider exploring the following resources:</p> <ul> <li>Create a Data Asset: Learn how to set up and manage your data assets effectively within the AzureML environment.</li> <li>Initiate an AzureML Job: Get a comprehensive understanding of how to kickstart your machine learning training jobs on AzureML.</li> <li>Register a Model: Familiarize yourself with model management practices including registration, versioning, and deployment.</li> <li>Train YOLOv8 with AzureML Python SDK: Explore a step-by-step guide on using the AzureML Python SDK to train your YOLOv8 models.</li> <li>Train YOLOv8 with AzureML CLI: Discover how to utilize the command-line interface for streamlined training and management of YOLOv8 models on AzureML.</li> </ul>"},{"location":"guides/conda-quickstart/","title":"Conda Quickstart Guide for Ultralytics","text":"<p>This guide provides a comprehensive introduction to setting up a Conda environment for your Ultralytics projects. Conda is an open-source package and environment management system that offers an excellent alternative to pip for installing packages and dependencies. Its isolated environments make it particularly well-suited for data science and machine learning endeavors. For more details, visit the Ultralytics Conda package on Anaconda and check out the Ultralytics feedstock repository for package updates on GitHub.</p> <p> </p>"},{"location":"guides/conda-quickstart/#what-you-will-learn","title":"What You Will Learn","text":"<ul> <li>Setting up a Conda environment</li> <li>Installing Ultralytics via Conda</li> <li>Initializing Ultralytics in your environment</li> <li>Using Ultralytics Docker images with Conda</li> </ul>"},{"location":"guides/conda-quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>You should have Anaconda or Miniconda installed on your system. If not, download and install it from Anaconda or Miniconda.</li> </ul>"},{"location":"guides/conda-quickstart/#setting-up-a-conda-environment","title":"Setting up a Conda Environment","text":"<p>First, let's create a new Conda environment. Open your terminal and run the following command:</p> <pre><code>conda create --name ultralytics-env python=3.8 -y\n</code></pre> <p>Activate the new environment:</p> <pre><code>conda activate ultralytics-env\n</code></pre>"},{"location":"guides/conda-quickstart/#installing-ultralytics","title":"Installing Ultralytics","text":"<p>You can install the Ultralytics package from the conda-forge channel. Execute the following command:</p> <pre><code>conda install -c conda-forge ultralytics\n</code></pre>"},{"location":"guides/conda-quickstart/#note-on-cuda-environment","title":"Note on CUDA Environment","text":"<p>If you're working in a CUDA-enabled environment, it's a good practice to install <code>ultralytics</code>, <code>pytorch</code>, and <code>pytorch-cuda</code> together to resolve any conflicts:</p> <pre><code>conda install -c pytorch -c nvidia -c conda-forge pytorch torchvision pytorch-cuda=11.8 ultralytics\n</code></pre>"},{"location":"guides/conda-quickstart/#using-ultralytics","title":"Using Ultralytics","text":"<p>With Ultralytics installed, you can now start using its robust features for object detection, instance segmentation, and more. For example, to predict an image, you can run:</p> <pre><code>from ultralytics import YOLO\n\nmodel = YOLO('yolov8n.pt')  # initialize model\nresults = model('path/to/image.jpg')  # perform inference\nresults.show()  # display results\n</code></pre>"},{"location":"guides/conda-quickstart/#ultralytics-conda-docker-image","title":"Ultralytics Conda Docker Image","text":"<p>If you prefer using Docker, Ultralytics offers Docker images with a Conda environment included. You can pull these images from DockerHub.</p> <p>Pull the latest Ultralytics image:</p> <pre><code># Set image name as a variable\nt=ultralytics/ultralytics:latest-conda\n\n# Pull the latest Ultralytics image from Docker Hub\nsudo docker pull $t\n</code></pre> <p>Run the image:</p> <pre><code># Run the Ultralytics image in a container with GPU support\nsudo docker run -it --ipc=host --gpus all $t  # all GPUs\nsudo docker run -it --ipc=host --gpus '\"device=2,3\"' $t  # specify GPUs\n</code></pre> <p>Certainly, you can include the following section in your Conda guide to inform users about speeding up installation using <code>libmamba</code>:</p>"},{"location":"guides/conda-quickstart/#speeding-up-installation-with-libmamba","title":"Speeding Up Installation with Libmamba","text":"<p>If you're looking to speed up the package installation process in Conda, you can opt to use <code>libmamba</code>, a fast, cross-platform, and dependency-aware package manager that serves as an alternative solver to Conda's default.</p>"},{"location":"guides/conda-quickstart/#how-to-enable-libmamba","title":"How to Enable Libmamba","text":"<p>To enable <code>libmamba</code> as the solver for Conda, you can perform the following steps:</p> <ol> <li> <p>First, install the <code>conda-libmamba-solver</code> package. This can be skipped if your Conda version is 4.11 or above, as <code>libmamba</code> is included by default.</p> <pre><code>conda install conda-libmamba-solver\n</code></pre> </li> <li> <p>Next, configure Conda to use <code>libmamba</code> as the solver:</p> <pre><code>conda config --set solver libmamba\n</code></pre> </li> </ol> <p>And that's it! Your Conda installation will now use <code>libmamba</code> as the solver, which should result in a faster package installation process.</p> <p>Congratulations! You have successfully set up a Conda environment, installed the Ultralytics package, and are now ready to explore its rich functionalities. Feel free to dive deeper into the Ultralytics documentation for more advanced tutorials and examples.</p>"},{"location":"guides/distance-calculation/","title":"Distance Calculation using Ultralytics YOLOv8 \ud83d\ude80","text":""},{"location":"guides/distance-calculation/#what-is-distance-calculation","title":"What is Distance Calculation?","text":"<p>Measuring the gap between two objects is known as distance calculation within a specified space. In the case of Ultralytics YOLOv8, the bounding box centroid is employed to calculate the distance for bounding boxes highlighted by the user.</p>"},{"location":"guides/distance-calculation/#advantages-of-distance-calculation","title":"Advantages of Distance Calculation?","text":"<ul> <li>Localization Precision: Enhances accurate spatial positioning in computer vision tasks.</li> <li>Size Estimation: Allows estimation of physical sizes for better contextual understanding.</li> <li>Scene Understanding: Contributes to a 3D understanding of the environment for improved decision-making.</li> </ul> Distance Calculation <ul> <li>Click on any two bounding boxes with Left Mouse click for distance calculation</li> </ul> <p>Distance Calculation using YOLOv8 Example</p> Video Stream <pre><code>from ultralytics import YOLO\nfrom ultralytics.solutions import distance_calculation\nimport cv2\n\nmodel = YOLO(\"yolov8n.pt\")\nnames = model.model.names\n\ncap = cv2.VideoCapture(\"path/to/video/file.mp4\")\nassert cap.isOpened(), \"Error reading video file\"\nw, h, fps = (int(cap.get(x)) for x in (cv2.CAP_PROP_FRAME_WIDTH, cv2.CAP_PROP_FRAME_HEIGHT, cv2.CAP_PROP_FPS))\n\n# Video writer\nvideo_writer = cv2.VideoWriter(\"distance_calculation.avi\",\n                               cv2.VideoWriter_fourcc(*'mp4v'),\n                               fps,\n                               (w, h))\n\n# Init distance-calculation obj\ndist_obj = distance_calculation.DistanceCalculation()\ndist_obj.set_args(names=names, view_img=True)\n\nwhile cap.isOpened():\n    success, im0 = cap.read()\n    if not success:\n        print(\"Video frame is empty or video processing has been successfully completed.\")\n        break\n\n    tracks = model.track(im0, persist=True, show=False)\n    im0 = dist_obj.start_process(im0, tracks)\n    video_writer.write(im0)\n\ncap.release()\nvideo_writer.release()\ncv2.destroyAllWindows()\n</code></pre> Note <ul> <li>Mouse Right Click will delete all drawn points</li> <li>Mouse Left Click can be used to draw points</li> </ul>"},{"location":"guides/distance-calculation/#optional-arguments-set_args","title":"Optional Arguments <code>set_args</code>","text":"Name Type Default Description names <code>dict</code> <code>None</code> Classes names view_img <code>bool</code> <code>False</code> Display frames with counts line_thickness <code>int</code> <code>2</code> Increase bounding boxes thickness line_color <code>RGB</code> <code>(255, 255, 0)</code> Line Color for centroids mapping on two bounding boxes centroid_color <code>RGB</code> <code>(255, 0, 255)</code> Centroid color for each bounding box"},{"location":"guides/distance-calculation/#arguments-modeltrack","title":"Arguments <code>model.track</code>","text":"Name Type Default Description <code>source</code> <code>im0</code> <code>None</code> source directory for images or videos <code>persist</code> <code>bool</code> <code>False</code> persisting tracks between frames <code>tracker</code> <code>str</code> <code>botsort.yaml</code> Tracking method 'bytetrack' or 'botsort' <code>conf</code> <code>float</code> <code>0.3</code> Confidence Threshold <code>iou</code> <code>float</code> <code>0.5</code> IOU Threshold <code>classes</code> <code>list</code> <code>None</code> filter results by class, i.e. classes=0, or classes=[0,2,3] <code>verbose</code> <code>bool</code> <code>True</code> Display the object tracking results"},{"location":"guides/docker-quickstart/","title":"Docker Quickstart Guide for Ultralytics","text":"<p>This guide serves as a comprehensive introduction to setting up a Docker environment for your Ultralytics projects. Docker is a platform for developing, shipping, and running applications in containers. It is particularly beneficial for ensuring that the software will always run the same, regardless of where it's deployed. For more details, visit the Ultralytics Docker repository on Docker Hub.</p> <p></p>"},{"location":"guides/docker-quickstart/#what-you-will-learn","title":"What You Will Learn","text":"<ul> <li>Setting up Docker with NVIDIA support</li> <li>Installing Ultralytics Docker images</li> <li>Running Ultralytics in a Docker container</li> <li>Mounting local directories into the container</li> </ul>"},{"location":"guides/docker-quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Make sure Docker is installed on your system. If not, you can download and install it from Docker's website.</li> <li>Ensure that your system has an NVIDIA GPU and NVIDIA drivers are installed.</li> </ul>"},{"location":"guides/docker-quickstart/#setting-up-docker-with-nvidia-support","title":"Setting up Docker with NVIDIA Support","text":"<p>First, verify that the NVIDIA drivers are properly installed by running:</p> <pre><code>nvidia-smi\n</code></pre>"},{"location":"guides/docker-quickstart/#installing-nvidia-docker-runtime","title":"Installing NVIDIA Docker Runtime","text":"<p>Now, let's install the NVIDIA Docker runtime to enable GPU support in Docker containers:</p> <pre><code># Add NVIDIA package repositories\ncurl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -\ndistribution=$(lsb_release -cs)\ncurl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list\n\n# Install NVIDIA Docker runtime\nsudo apt-get update\nsudo apt-get install -y nvidia-docker2\n\n# Restart Docker service to apply changes\nsudo systemctl restart docker\n</code></pre>"},{"location":"guides/docker-quickstart/#verify-nvidia-runtime-with-docker","title":"Verify NVIDIA Runtime with Docker","text":"<p>Run <code>docker info | grep -i runtime</code> to ensure that <code>nvidia</code> appears in the list of runtimes:</p> <pre><code>docker info | grep -i runtime\n</code></pre>"},{"location":"guides/docker-quickstart/#installing-ultralytics-docker-images","title":"Installing Ultralytics Docker Images","text":"<p>Ultralytics offers several Docker images optimized for various platforms and use-cases:</p> <ul> <li>Dockerfile: GPU image, ideal for training.</li> <li>Dockerfile-arm64: For ARM64 architecture, suitable for devices like Raspberry Pi.</li> <li>Dockerfile-cpu: CPU-only version for inference and non-GPU environments.</li> <li>Dockerfile-jetson: Optimized for NVIDIA Jetson devices.</li> <li>Dockerfile-python: Minimal Python environment for lightweight applications.</li> <li>Dockerfile-conda: Includes Miniconda3 and Ultralytics package installed via Conda.</li> </ul> <p>To pull the latest image:</p> <pre><code># Set image name as a variable\nt=ultralytics/ultralytics:latest\n\n# Pull the latest Ultralytics image from Docker Hub\nsudo docker pull $t\n</code></pre>"},{"location":"guides/docker-quickstart/#running-ultralytics-in-docker-container","title":"Running Ultralytics in Docker Container","text":"<p>Here's how to execute the Ultralytics Docker container:</p> <pre><code># Run with all GPUs\nsudo docker run -it --ipc=host --gpus all $t\n\n# Run specifying which GPUs to use\nsudo docker run -it --ipc=host --gpus '\"device=2,3\"' $t\n</code></pre> <p>The <code>-it</code> flag assigns a pseudo-TTY and keeps stdin open, allowing you to interact with the container. The <code>--ipc=host</code> flag enables sharing of host's IPC namespace, essential for sharing memory between processes. The <code>--gpus</code> flag allows the container to access the host's GPUs.</p>"},{"location":"guides/docker-quickstart/#note-on-file-accessibility","title":"Note on File Accessibility","text":"<p>To work with files on your local machine within the container, you can use Docker volumes:</p> <pre><code># Mount a local directory into the container\nsudo docker run -it --ipc=host --gpus all -v /path/on/host:/path/in/container $t\n</code></pre> <p>Replace <code>/path/on/host</code> with the directory path on your local machine and <code>/path/in/container</code> with the desired path inside the Docker container.</p> <p>Congratulations! You're now set up to use Ultralytics with Docker and ready to take advantage of its powerful capabilities. For alternate installation methods, feel free to explore the Ultralytics quickstart documentation.</p>"},{"location":"guides/heatmaps/","title":"Advanced Data Visualization: Heatmaps using Ultralytics YOLOv8 \ud83d\ude80","text":""},{"location":"guides/heatmaps/#introduction-to-heatmaps","title":"Introduction to Heatmaps","text":"<p>A heatmap generated with Ultralytics YOLOv8 transforms complex data into a vibrant, color-coded matrix. This visual tool employs a spectrum of colors to represent varying data values, where warmer hues indicate higher intensities and cooler tones signify lower values. Heatmaps excel in visualizing intricate data patterns, correlations, and anomalies, offering an accessible and engaging approach to data interpretation across diverse domains.</p> <p> Watch: Heatmaps using Ultralytics YOLOv8 </p>"},{"location":"guides/heatmaps/#why-choose-heatmaps-for-data-analysis","title":"Why Choose Heatmaps for Data Analysis?","text":"<ul> <li>Intuitive Data Distribution Visualization: Heatmaps simplify the comprehension of data concentration and distribution, converting complex datasets into easy-to-understand visual formats.</li> <li>Efficient Pattern Detection: By visualizing data in heatmap format, it becomes easier to spot trends, clusters, and outliers, facilitating quicker analysis and insights.</li> <li>Enhanced Spatial Analysis and Decision-Making: Heatmaps are instrumental in illustrating spatial relationships, aiding in decision-making processes in sectors such as business intelligence, environmental studies, and urban planning.</li> </ul>"},{"location":"guides/heatmaps/#real-world-applications","title":"Real World Applications","text":"Transportation Retail Ultralytics YOLOv8 Transportation Heatmap Ultralytics YOLOv8 Retail Heatmap <p>Heatmap Configuration</p> <ul> <li><code>heatmap_alpha</code>: Ensure this value is within the range (0.0 - 1.0).</li> <li><code>decay_factor</code>: Used for removing heatmap after an object is no longer in the frame, its value should also be in the range (0.0 - 1.0).</li> </ul> <p>Heatmaps using Ultralytics YOLOv8 Example</p> HeatmapLine CountingRegion CountingIm0Specific Classes <pre><code>from ultralytics import YOLO\nfrom ultralytics.solutions import heatmap\nimport cv2\n\nmodel = YOLO(\"yolov8n.pt\")\ncap = cv2.VideoCapture(\"path/to/video/file.mp4\")\nassert cap.isOpened(), \"Error reading video file\"\nw, h, fps = (int(cap.get(x)) for x in (cv2.CAP_PROP_FRAME_WIDTH, cv2.CAP_PROP_FRAME_HEIGHT, cv2.CAP_PROP_FPS))\n\n# Video writer\nvideo_writer = cv2.VideoWriter(\"heatmap_output.avi\",\n                               cv2.VideoWriter_fourcc(*'mp4v'),\n                               fps,\n                               (w, h))\n\n# Init heatmap\nheatmap_obj = heatmap.Heatmap()\nheatmap_obj.set_args(colormap=cv2.COLORMAP_PARULA,\n                     imw=w,\n                     imh=h,\n                     view_img=True,\n                     shape=\"circle\")\n\nwhile cap.isOpened():\n    success, im0 = cap.read()\n    if not success:\n        print(\"Video frame is empty or video processing has been successfully completed.\")\n        break\n    tracks = model.track(im0, persist=True, show=False)\n\n    im0 = heatmap_obj.generate_heatmap(im0, tracks)\n    video_writer.write(im0)\n\ncap.release()\nvideo_writer.release()\ncv2.destroyAllWindows()\n</code></pre> <pre><code>from ultralytics import YOLO\nfrom ultralytics.solutions import heatmap\nimport cv2\n\nmodel = YOLO(\"yolov8n.pt\")\ncap = cv2.VideoCapture(\"path/to/video/file.mp4\")\nassert cap.isOpened(), \"Error reading video file\"\nw, h, fps = (int(cap.get(x)) for x in (cv2.CAP_PROP_FRAME_WIDTH, cv2.CAP_PROP_FRAME_HEIGHT, cv2.CAP_PROP_FPS))\n\n# Video writer\nvideo_writer = cv2.VideoWriter(\"heatmap_output.avi\",\n                               cv2.VideoWriter_fourcc(*'mp4v'),\n                               fps,\n                               (w, h))\n\nline_points = [(20, 400), (1080, 404)]  # line for object counting\n\n# Init heatmap\nheatmap_obj = heatmap.Heatmap()\nheatmap_obj.set_args(colormap=cv2.COLORMAP_PARULA,\n                     imw=w,\n                     imh=h,\n                     view_img=True,\n                     shape=\"circle\",\n                     count_reg_pts=line_points)\n\nwhile cap.isOpened():\n    success, im0 = cap.read()\n    if not success:\n        print(\"Video frame is empty or video processing has been successfully completed.\")\n        break\n    tracks = model.track(im0, persist=True, show=False)\n\n    im0 = heatmap_obj.generate_heatmap(im0, tracks)\n    video_writer.write(im0)\n\ncap.release()\nvideo_writer.release()\ncv2.destroyAllWindows()\n</code></pre> <pre><code>from ultralytics import YOLO\nfrom ultralytics.solutions import heatmap\nimport cv2\n\nmodel = YOLO(\"yolov8n.pt\")\ncap = cv2.VideoCapture(\"path/to/video/file.mp4\")\nassert cap.isOpened(), \"Error reading video file\"\nw, h, fps = (int(cap.get(x)) for x in (cv2.CAP_PROP_FRAME_WIDTH, cv2.CAP_PROP_FRAME_HEIGHT, cv2.CAP_PROP_FPS))\n\n# Video writer\nvideo_writer = cv2.VideoWriter(\"heatmap_output.avi\",\n                               cv2.VideoWriter_fourcc(*'mp4v'),\n                               fps,\n                               (w, h))\n\n# Define region points\nregion_points = [(20, 400), (1080, 404), (1080, 360), (20, 360)]\n\n# Init heatmap\nheatmap_obj = heatmap.Heatmap()\nheatmap_obj.set_args(colormap=cv2.COLORMAP_PARULA,\n                     imw=w,\n                     imh=h,\n                     view_img=True,\n                     shape=\"circle\",\n                     count_reg_pts=region_points)\n\nwhile cap.isOpened():\n    success, im0 = cap.read()\n    if not success:\n        print(\"Video frame is empty or video processing has been successfully completed.\")\n        break\n    tracks = model.track(im0, persist=True, show=False)\n\n    im0 = heatmap_obj.generate_heatmap(im0, tracks)\n    video_writer.write(im0)\n\ncap.release()\nvideo_writer.release()\ncv2.destroyAllWindows()\n</code></pre> <pre><code>from ultralytics import YOLO\nfrom ultralytics.solutions import heatmap\nimport cv2\n\nmodel = YOLO(\"yolov8s.pt\")   # YOLOv8 custom/pretrained model\n\nim0 = cv2.imread(\"path/to/image.png\")  # path to image file\n\n# Heatmap Init\nheatmap_obj = heatmap.Heatmap()\nheatmap_obj.set_args(colormap=cv2.COLORMAP_PARULA,\n                             imw=im0.shape[0],  # should same as im0 width\n                             imh=im0.shape[1],  # should same as im0 height\n                             view_img=True,\n                             shape=\"circle\")\n\n\nresults = model.track(im0, persist=True)\nim0 = heatmap_obj.generate_heatmap(im0, tracks=results)\ncv2.imwrite(\"ultralytics_output.png\", im0)\n</code></pre> <pre><code>from ultralytics import YOLO\nfrom ultralytics.solutions import heatmap\nimport cv2\n\nmodel = YOLO(\"yolov8n.pt\")\ncap = cv2.VideoCapture(\"path/to/video/file.mp4\")\nassert cap.isOpened(), \"Error reading video file\"\nw, h, fps = (int(cap.get(x)) for x in (cv2.CAP_PROP_FRAME_WIDTH, cv2.CAP_PROP_FRAME_HEIGHT, cv2.CAP_PROP_FPS))\n\n# Video writer\nvideo_writer = cv2.VideoWriter(\"heatmap_output.avi\",\n                               cv2.VideoWriter_fourcc(*'mp4v'),\n                               fps,\n                               (w, h))\n\nclasses_for_heatmap = [0, 2]  # classes for heatmap\n\n# Init heatmap\nheatmap_obj = heatmap.Heatmap()\nheatmap_obj.set_args(colormap=cv2.COLORMAP_PARULA,\n                     imw=w,\n                     imh=h,\n                     view_img=True,\n                     shape=\"circle\")\n\nwhile cap.isOpened():\n    success, im0 = cap.read()\n    if not success:\n        print(\"Video frame is empty or video processing has been successfully completed.\")\n        break\n    tracks = model.track(im0, persist=True, show=False,\n                         classes=classes_for_heatmap)\n\n    im0 = heatmap_obj.generate_heatmap(im0, tracks)\n    video_writer.write(im0)\n\ncap.release()\nvideo_writer.release()\ncv2.destroyAllWindows()\n</code></pre>"},{"location":"guides/heatmaps/#arguments-set_args","title":"Arguments <code>set_args</code>","text":"Name Type Default Description view_img <code>bool</code> <code>False</code> Display the frame with heatmap colormap <code>cv2.COLORMAP</code> <code>None</code> cv2.COLORMAP for heatmap imw <code>int</code> <code>None</code> Width of Heatmap imh <code>int</code> <code>None</code> Height of Heatmap heatmap_alpha <code>float</code> <code>0.5</code> Heatmap alpha value count_reg_pts <code>list</code> <code>None</code> Object counting region points count_txt_thickness <code>int</code> <code>2</code> Count values text size count_txt_color <code>RGB Color</code> <code>(0, 0, 0)</code> Foreground color for Object counts text count_color <code>RGB Color</code> <code>(255, 255, 255)</code> Background color for Object counts text count_reg_color <code>RGB Color</code> <code>(255, 0, 255)</code> Counting region color region_thickness <code>int</code> <code>5</code> Counting region thickness value decay_factor <code>float</code> <code>0.99</code> Decay factor for heatmap area removal after specific time shape <code>str</code> <code>circle</code> Heatmap shape for display \"rect\" or \"circle\" supported line_dist_thresh <code>int</code> <code>15</code> Euclidean Distance threshold for line counter"},{"location":"guides/heatmaps/#arguments-modeltrack","title":"Arguments <code>model.track</code>","text":"Name Type Default Description <code>source</code> <code>im0</code> <code>None</code> source directory for images or videos <code>persist</code> <code>bool</code> <code>False</code> persisting tracks between frames <code>tracker</code> <code>str</code> <code>botsort.yaml</code> Tracking method 'bytetrack' or 'botsort' <code>conf</code> <code>float</code> <code>0.3</code> Confidence Threshold <code>iou</code> <code>float</code> <code>0.5</code> IOU Threshold <code>classes</code> <code>list</code> <code>None</code> filter results by class, i.e. classes=0, or classes=[0,2,3]"},{"location":"guides/heatmaps/#heatmap-colormaps","title":"Heatmap COLORMAPs","text":"Colormap Name Description <code>cv::COLORMAP_AUTUMN</code> Autumn color map <code>cv::COLORMAP_BONE</code> Bone color map <code>cv::COLORMAP_JET</code> Jet color map <code>cv::COLORMAP_WINTER</code> Winter color map <code>cv::COLORMAP_RAINBOW</code> Rainbow color map <code>cv::COLORMAP_OCEAN</code> Ocean color map <code>cv::COLORMAP_SUMMER</code> Summer color map <code>cv::COLORMAP_SPRING</code> Spring color map <code>cv::COLORMAP_COOL</code> Cool color map <code>cv::COLORMAP_HSV</code> HSV (Hue, Saturation, Value) color map <code>cv::COLORMAP_PINK</code> Pink color map <code>cv::COLORMAP_HOT</code> Hot color map <code>cv::COLORMAP_PARULA</code> Parula color map <code>cv::COLORMAP_MAGMA</code> Magma color map <code>cv::COLORMAP_INFERNO</code> Inferno color map <code>cv::COLORMAP_PLASMA</code> Plasma color map <code>cv::COLORMAP_VIRIDIS</code> Viridis color map <code>cv::COLORMAP_CIVIDIS</code> Cividis color map <code>cv::COLORMAP_TWILIGHT</code> Twilight color map <code>cv::COLORMAP_TWILIGHT_SHIFTED</code> Shifted Twilight color map <code>cv::COLORMAP_TURBO</code> Turbo color map <code>cv::COLORMAP_DEEPGREEN</code> Deep Green color map <p>These colormaps are commonly used for visualizing data with different color representations.</p>"},{"location":"guides/hyperparameter-tuning/","title":"Ultralytics YOLO Hyperparameter Tuning Guide","text":""},{"location":"guides/hyperparameter-tuning/#introduction","title":"Introduction","text":"<p>Hyperparameter tuning is not just a one-time set-up but an iterative process aimed at optimizing the machine learning model's performance metrics, such as accuracy, precision, and recall. In the context of Ultralytics YOLO, these hyperparameters could range from learning rate to architectural details, such as the number of layers or types of activation functions used.</p>"},{"location":"guides/hyperparameter-tuning/#what-are-hyperparameters","title":"What are Hyperparameters?","text":"<p>Hyperparameters are high-level, structural settings for the algorithm. They are set prior to the training phase and remain constant during it. Here are some commonly tuned hyperparameters in Ultralytics YOLO:</p> <ul> <li>Learning Rate <code>lr0</code>: Determines the step size at each iteration while moving towards a minimum in the loss function.</li> <li>Batch Size <code>batch</code>: Number of images processed simultaneously in a forward pass.</li> <li>Number of Epochs <code>epochs</code>: An epoch is one complete forward and backward pass of all the training examples.</li> <li>Architecture Specifics: Such as channel counts, number of layers, types of activation functions, etc.</li> </ul> <p> </p> <p>For a full list of augmentation hyperparameters used in YOLOv8 please refer to the configurations page.</p>"},{"location":"guides/hyperparameter-tuning/#genetic-evolution-and-mutation","title":"Genetic Evolution and Mutation","text":"<p>Ultralytics YOLO uses genetic algorithms to optimize hyperparameters. Genetic algorithms are inspired by the mechanism of natural selection and genetics.</p> <ul> <li>Mutation: In the context of Ultralytics YOLO, mutation helps in locally searching the hyperparameter space by applying small, random changes to existing hyperparameters, producing new candidates for evaluation.</li> <li>Crossover: Although crossover is a popular genetic algorithm technique, it is not currently used in Ultralytics YOLO for hyperparameter tuning. The focus is mainly on mutation for generating new hyperparameter sets.</li> </ul>"},{"location":"guides/hyperparameter-tuning/#preparing-for-hyperparameter-tuning","title":"Preparing for Hyperparameter Tuning","text":"<p>Before you begin the tuning process, it's important to:</p> <ol> <li>Identify the Metrics: Determine the metrics you will use to evaluate the model's performance. This could be AP50, F1-score, or others.</li> <li>Set the Tuning Budget: Define how much computational resources you're willing to allocate. Hyperparameter tuning can be computationally intensive.</li> </ol>"},{"location":"guides/hyperparameter-tuning/#steps-involved","title":"Steps Involved","text":""},{"location":"guides/hyperparameter-tuning/#initialize-hyperparameters","title":"Initialize Hyperparameters","text":"<p>Start with a reasonable set of initial hyperparameters. This could either be the default hyperparameters set by Ultralytics YOLO or something based on your domain knowledge or previous experiments.</p>"},{"location":"guides/hyperparameter-tuning/#mutate-hyperparameters","title":"Mutate Hyperparameters","text":"<p>Use the <code>_mutate</code> method to produce a new set of hyperparameters based on the existing set.</p>"},{"location":"guides/hyperparameter-tuning/#train-model","title":"Train Model","text":"<p>Training is performed using the mutated set of hyperparameters. The training performance is then assessed.</p>"},{"location":"guides/hyperparameter-tuning/#evaluate-model","title":"Evaluate Model","text":"<p>Use metrics like AP50, F1-score, or custom metrics to evaluate the model's performance.</p>"},{"location":"guides/hyperparameter-tuning/#log-results","title":"Log Results","text":"<p>It's crucial to log both the performance metrics and the corresponding hyperparameters for future reference.</p>"},{"location":"guides/hyperparameter-tuning/#repeat","title":"Repeat","text":"<p>The process is repeated until either the set number of iterations is reached or the performance metric is satisfactory.</p>"},{"location":"guides/hyperparameter-tuning/#usage-example","title":"Usage Example","text":"<p>Here's how to use the <code>model.tune()</code> method to utilize the <code>Tuner</code> class for hyperparameter tuning of YOLOv8n on COCO8 for 30 epochs with an AdamW optimizer and skipping plotting, checkpointing and validation other than on final epoch for faster Tuning.</p> <p>Example</p> Python <pre><code>from ultralytics import YOLO\n\n# Initialize the YOLO model\nmodel = YOLO('yolov8n.pt')\n\n# Tune hyperparameters on COCO8 for 30 epochs\nmodel.tune(data='coco8.yaml', epochs=30, iterations=300, optimizer='AdamW', plots=False, save=False, val=False)\n</code></pre>"},{"location":"guides/hyperparameter-tuning/#results","title":"Results","text":"<p>After you've successfully completed the hyperparameter tuning process, you will obtain several files and directories that encapsulate the results of the tuning. The following describes each:</p>"},{"location":"guides/hyperparameter-tuning/#file-structure","title":"File Structure","text":"<p>Here's what the directory structure of the results will look like. Training directories like <code>train1/</code> contain individual tuning iterations, i.e. one model trained with one set of hyperparameters. The <code>tune/</code> directory contains tuning results from all the individual model trainings:</p> <pre><code>runs/\n\u2514\u2500\u2500 detect/\n    \u251c\u2500\u2500 train1/\n    \u251c\u2500\u2500 train2/\n    \u251c\u2500\u2500 ...\n    \u2514\u2500\u2500 tune/\n        \u251c\u2500\u2500 best_hyperparameters.yaml\n        \u251c\u2500\u2500 best_fitness.png\n        \u251c\u2500\u2500 tune_results.csv\n        \u251c\u2500\u2500 tune_scatter_plots.png\n        \u2514\u2500\u2500 weights/\n            \u251c\u2500\u2500 last.pt\n            \u2514\u2500\u2500 best.pt\n</code></pre>"},{"location":"guides/hyperparameter-tuning/#file-descriptions","title":"File Descriptions","text":""},{"location":"guides/hyperparameter-tuning/#best_hyperparametersyaml","title":"best_hyperparameters.yaml","text":"<p>This YAML file contains the best-performing hyperparameters found during the tuning process. You can use this file to initialize future trainings with these optimized settings.</p> <ul> <li>Format: YAML</li> <li>Usage: Hyperparameter results</li> <li>Example:     <pre><code>  # 558/900 iterations complete \u2705 (45536.81s)\n  # Results saved to /usr/src/ultralytics/runs/detect/tune\n  # Best fitness=0.64297 observed at iteration 498\n  # Best fitness metrics are {'metrics/precision(B)': 0.87247, 'metrics/recall(B)': 0.71387, 'metrics/mAP50(B)': 0.79106, 'metrics/mAP50-95(B)': 0.62651, 'val/box_loss': 2.79884, 'val/cls_loss': 2.72386, 'val/dfl_loss': 0.68503, 'fitness': 0.64297}\n  # Best fitness model is /usr/src/ultralytics/runs/detect/train498\n  # Best fitness hyperparameters are printed below.\n\n  lr0: 0.00269\n  lrf: 0.00288\n  momentum: 0.73375\n  weight_decay: 0.00015\n  warmup_epochs: 1.22935\n  warmup_momentum: 0.1525\n  box: 18.27875\n  cls: 1.32899\n  dfl: 0.56016\n  hsv_h: 0.01148\n  hsv_s: 0.53554\n  hsv_v: 0.13636\n  degrees: 0.0\n  translate: 0.12431\n  scale: 0.07643\n  shear: 0.0\n  perspective: 0.0\n  flipud: 0.0\n  fliplr: 0.08631\n  mosaic: 0.42551\n  mixup: 0.0\n  copy_paste: 0.0\n</code></pre></li> </ul>"},{"location":"guides/hyperparameter-tuning/#best_fitnesspng","title":"best_fitness.png","text":"<p>This is a plot displaying fitness (typically a performance metric like AP50) against the number of iterations. It helps you visualize how well the genetic algorithm performed over time.</p> <ul> <li>Format: PNG</li> <li>Usage: Performance visualization</li> </ul> <p> </p>"},{"location":"guides/hyperparameter-tuning/#tune_resultscsv","title":"tune_results.csv","text":"<p>A CSV file containing detailed results of each iteration during the tuning. Each row in the file represents one iteration, and it includes metrics like fitness score, precision, recall, as well as the hyperparameters used.</p> <ul> <li>Format: CSV</li> <li>Usage: Per-iteration results tracking.</li> <li>Example:     <pre><code>  fitness,lr0,lrf,momentum,weight_decay,warmup_epochs,warmup_momentum,box,cls,dfl,hsv_h,hsv_s,hsv_v,degrees,translate,scale,shear,perspective,flipud,fliplr,mosaic,mixup,copy_paste\n  0.05021,0.01,0.01,0.937,0.0005,3.0,0.8,7.5,0.5,1.5,0.015,0.7,0.4,0.0,0.1,0.5,0.0,0.0,0.0,0.5,1.0,0.0,0.0\n  0.07217,0.01003,0.00967,0.93897,0.00049,2.79757,0.81075,7.5,0.50746,1.44826,0.01503,0.72948,0.40658,0.0,0.0987,0.4922,0.0,0.0,0.0,0.49729,1.0,0.0,0.0\n  0.06584,0.01003,0.00855,0.91009,0.00073,3.42176,0.95,8.64301,0.54594,1.72261,0.01503,0.59179,0.40658,0.0,0.0987,0.46955,0.0,0.0,0.0,0.49729,0.80187,0.0,0.0\n</code></pre></li> </ul>"},{"location":"guides/hyperparameter-tuning/#tune_scatter_plotspng","title":"tune_scatter_plots.png","text":"<p>This file contains scatter plots generated from <code>tune_results.csv</code>, helping you visualize relationships between different hyperparameters and performance metrics. Note that hyperparameters initialized to 0 will not be tuned, such as <code>degrees</code> and <code>shear</code> below.</p> <ul> <li>Format: PNG</li> <li>Usage: Exploratory data analysis</li> </ul> <p> </p>"},{"location":"guides/hyperparameter-tuning/#weights","title":"weights/","text":"<p>This directory contains the saved PyTorch models for the last and the best iterations during the hyperparameter tuning process.</p> <ul> <li><code>last.pt</code>: The last.pt are the weights from the last epoch of training.</li> <li><code>best.pt</code>: The best.pt weights for the iteration that achieved the best fitness score.</li> </ul> <p>Using these results, you can make more informed decisions for your future model trainings and analyses. Feel free to consult these artifacts to understand how well your model performed and how you might improve it further.</p>"},{"location":"guides/hyperparameter-tuning/#conclusion","title":"Conclusion","text":"<p>The hyperparameter tuning process in Ultralytics YOLO is simplified yet powerful, thanks to its genetic algorithm-based approach focused on mutation. Following the steps outlined in this guide will assist you in systematically tuning your model to achieve better performance.</p>"},{"location":"guides/hyperparameter-tuning/#further-reading","title":"Further Reading","text":"<ol> <li>Hyperparameter Optimization in Wikipedia</li> <li>YOLOv5 Hyperparameter Evolution Guide</li> <li>Efficient Hyperparameter Tuning with Ray Tune and YOLOv8</li> </ol> <p>For deeper insights, you can explore the <code>Tuner</code> class source code and accompanying documentation. Should you have any questions, feature requests, or need further assistance, feel free to reach out to us on GitHub or Discord.</p>"},{"location":"guides/instance-segmentation-and-tracking/","title":"Instance Segmentation and Tracking using Ultralytics YOLOv8 \ud83d\ude80","text":""},{"location":"guides/instance-segmentation-and-tracking/#what-is-instance-segmentation","title":"What is Instance Segmentation?","text":"<p>Ultralytics YOLOv8 instance segmentation involves identifying and outlining individual objects in an image, providing a detailed understanding of spatial distribution. Unlike semantic segmentation, it uniquely labels and precisely delineates each object, crucial for tasks like object detection and medical imaging.</p> <p>There are two types of instance segmentation tracking available in the Ultralytics package:</p> <ul> <li> <p>Instance Segmentation with Class Objects: Each class object is assigned a unique color for clear visual separation.</p> </li> <li> <p>Instance Segmentation with Object Tracks: Every track is represented by a distinct color, facilitating easy identification and tracking.</p> </li> </ul>"},{"location":"guides/instance-segmentation-and-tracking/#samples","title":"Samples","text":"Instance Segmentation Instance Segmentation + Object Tracking Ultralytics Instance Segmentation \ud83d\ude0d Ultralytics Instance Segmentation with Object Tracking \ud83d\udd25 <p>Instance Segmentation and Tracking</p> Instance SegmentationInstance Segmentation with Object Tracking <pre><code>import cv2\nfrom ultralytics import YOLO\nfrom ultralytics.utils.plotting import Annotator, colors\n\nmodel = YOLO(\"yolov8n-seg.pt\")  # segmentation model\nnames = model.model.names\ncap = cv2.VideoCapture(\"path/to/video/file.mp4\")\nw, h, fps = (int(cap.get(x)) for x in (cv2.CAP_PROP_FRAME_WIDTH, cv2.CAP_PROP_FRAME_HEIGHT, cv2.CAP_PROP_FPS))\n\nout = cv2.VideoWriter('instance-segmentation.avi', cv2.VideoWriter_fourcc(*'MJPG'), fps, (w, h))\n\nwhile True:\n    ret, im0 = cap.read()\n    if not ret:\n        print(\"Video frame is empty or video processing has been successfully completed.\")\n        break\n\n    results = model.predict(im0)\n    annotator = Annotator(im0, line_width=2)\n\n    if results[0].masks is not None:\n        clss = results[0].boxes.cls.cpu().tolist()\n        masks = results[0].masks.xy\n        for mask, cls in zip(masks, clss):\n            annotator.seg_bbox(mask=mask,\n                               mask_color=colors(int(cls), True),\n                               det_label=names[int(cls)])\n\n    out.write(im0)\n    cv2.imshow(\"instance-segmentation\", im0)\n\n    if cv2.waitKey(1) &amp; 0xFF == ord('q'):\n        break\n\nout.release()\ncap.release()\ncv2.destroyAllWindows()\n</code></pre> <pre><code>import cv2\nfrom ultralytics import YOLO\nfrom ultralytics.utils.plotting import Annotator, colors\n\nfrom collections import defaultdict\n\ntrack_history = defaultdict(lambda: [])\n\nmodel = YOLO(\"yolov8n-seg.pt\")   # segmentation model\ncap = cv2.VideoCapture(\"path/to/video/file.mp4\")\nw, h, fps = (int(cap.get(x)) for x in (cv2.CAP_PROP_FRAME_WIDTH, cv2.CAP_PROP_FRAME_HEIGHT, cv2.CAP_PROP_FPS))\n\nout = cv2.VideoWriter('instance-segmentation-object-tracking.avi', cv2.VideoWriter_fourcc(*'MJPG'), fps, (w, h))\n\nwhile True:\n    ret, im0 = cap.read()\n    if not ret:\n        print(\"Video frame is empty or video processing has been successfully completed.\")\n        break\n\n    annotator = Annotator(im0, line_width=2)\n\n    results = model.track(im0, persist=True)\n\n    if results[0].boxes.id is not None and results[0].masks is not None:\n        masks = results[0].masks.xy\n        track_ids = results[0].boxes.id.int().cpu().tolist()\n\n        for mask, track_id in zip(masks, track_ids):\n            annotator.seg_bbox(mask=mask,\n                               mask_color=colors(track_id, True),\n                               track_label=str(track_id))\n\n    out.write(im0)\n    cv2.imshow(\"instance-segmentation-object-tracking\", im0)\n\n    if cv2.waitKey(1) &amp; 0xFF == ord('q'):\n        break\n\nout.release()\ncap.release()\ncv2.destroyAllWindows()\n</code></pre>"},{"location":"guides/instance-segmentation-and-tracking/#seg_bbox-arguments","title":"<code>seg_bbox</code> Arguments","text":"Name Type Default Description <code>mask</code> <code>array</code> <code>None</code> Segmentation mask coordinates <code>mask_color</code> <code>tuple</code> <code>(255, 0, 255)</code> Mask color for every segmented box <code>det_label</code> <code>str</code> <code>None</code> Label for segmented object <code>track_label</code> <code>str</code> <code>None</code> Label for segmented and tracked object"},{"location":"guides/instance-segmentation-and-tracking/#note","title":"Note","text":"<p>For any inquiries, feel free to post your questions in the Ultralytics Issue Section or the discussion section mentioned below.</p>"},{"location":"guides/isolating-segmentation-objects/","title":"Isolating Segmentation Objects","text":"<p>After performing the Segment Task, it's sometimes desirable to extract the isolated objects from the inference results. This guide provides a generic recipe on how to accomplish this using the Ultralytics Predict Mode.</p> <p> </p>"},{"location":"guides/isolating-segmentation-objects/#recipe-walk-through","title":"Recipe Walk Through","text":"<ol> <li> <p>Begin with the necessary imports</p> <pre><code>from pathlib import Path\n\nimport cv2 as cv\nimport numpy as np\nfrom ultralytics import YOLO\n</code></pre> Ultralytics Install <p>See the Ultralytics Quickstart Installation section for a quick walkthrough on installing the required libraries.</p> </li> <li> <p>Load a model and run <code>predict()</code> method on a source.</p> <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-seg.pt')\n\n# Run inference\nresult = model.predict()\n</code></pre> No Prediction Arguments? <p>Without specifying a source, the example images from the library will be used:</p> <pre><code>'ultralytics/assets/bus.jpg'\n'ultralytics/assets/zidane.jpg'\n</code></pre> <p>This is helpful for rapid testing with the <code>predict()</code> method.</p> <p>For additional information about Segmentation Models, visit the Segment Task page. To learn more about <code>predict()</code> method, see Predict Mode section of the Documentation.</p> </li> <li> <p>Now iterate over the results and the contours. For workflows that want to save an image to file, the source image <code>base-name</code> and the detection <code>class-label</code> are retrieved for later use (optional).</p> <pre><code># (2) Iterate detection results (helpful for multiple images)\nfor r in res:\n    img = np.copy(r.orig_img)\n    img_name = Path(r.path).stem # source image base-name\n\n    # Iterate each object contour (multiple detections)\n    for ci,c in enumerate(r):\n        # (1) Get detection class name\n        label = c.names[c.boxes.cls.tolist().pop()]\n</code></pre> <ol> <li>To learn more about working with detection results, see Boxes Section for Predict Mode.</li> <li>To learn more about <code>predict()</code> results see Working with Results for Predict Mode</li> </ol> For-Loop <p>A single image will only iterate the first loop once. A single image with only a single detection will iterate each loop only once.</p> </li> <li> <p>Start with generating a binary mask from the source image and then draw a filled contour onto the mask. This will allow the object to be isolated from the other parts of the image. An example from <code>bus.jpg</code> for one of the detected <code>person</code> class objects is shown on the right.</p> <p></p> <pre><code># Create binary mask\nb_mask = np.zeros(img.shape[:2], np.uint8)\n\n# (1) Extract contour result\ncontour = c.masks.xy.pop()\n# (2) Changing the type\ncontour = contour.astype(np.int32)\n# (3) Reshaping\ncontour = contour.reshape(-1, 1, 2)\n\n\n# Draw contour onto mask\n_ = cv.drawContours(b_mask,\n                    [contour],\n                    -1,\n                    (255, 255, 255),\n                    cv.FILLED)\n</code></pre> <ol> <li> <p>For more info on <code>c.masks.xy</code> see Masks Section from Predict Mode.</p> </li> <li> <p>Here, the values are cast into <code>np.int32</code> for compatibility with <code>drawContours()</code> function from OpenCV.</p> </li> <li> <p>The OpenCV <code>drawContours()</code> function expects contours to have a shape of <code>[N, 1, 2]</code> expand section below for more details.</p> </li> </ol> <p>  Expand to understand what is happening when defining the <code>contour</code> variable. <p></p> <ul> <li> <p><code>c.masks.xy</code> :: Provides the coordinates of the mask contour points in the format  <code>(x, y)</code>. For more details, refer to the Masks Section from Predict Mode.</p> </li> <li> <p><code>.pop()</code> :: As <code>masks.xy</code> is a list containing a single element, this element is extracted using the <code>pop()</code> method.</p> </li> <li> <p><code>.astype(np.int32)</code> :: Using <code>masks.xy</code> will return with a data type of <code>float32</code>, but this won't be compatible with the OpenCV <code>drawContours()</code> function, so this will change the data type to <code>int32</code> for compatibility.</p> </li> <li> <p><code>.reshape(-1, 1, 2)</code> :: Reformats the data into the required shape of <code>[N, 1, 2]</code> where <code>N</code> is the number of contour points, with each point represented by a single entry <code>1</code>, and the entry is composed of <code>2</code> values. The <code>-1</code> denotes that the number of values along this dimension is flexible.</p> </li> </ul> <p> <p></p>  Expand for an explanation of the <code>drawContours()</code> configuration. <p></p> <ul> <li> <p>Encapsulating the <code>contour</code> variable within square brackets, <code>[contour]</code>, was found to effectively generate the desired contour mask during testing.</p> </li> <li> <p>The value <code>-1</code> specified for the <code>drawContours()</code> parameter instructs the function to draw all contours present in the image.</p> </li> <li> <p>The <code>tuple</code> <code>(255, 255, 255)</code> represents the color white, which is the desired color for drawing the contour in this binary mask.</p> </li> <li> <p>The addition of <code>cv.FILLED</code> will color all pixels enclosed by the contour boundary the same, in this case, all enclosed pixels will be white.</p> </li> <li> <p>See OpenCV Documentation on <code>drawContours()</code> for more information.</p> </li> </ul> <p> <p></p></p> <li> <p>Next the there are 2 options for how to move forward with the image from this point and a subsequent option for each.</p> </li> <li> <p>What to do next is entirely left to you as the developer. A basic example of one possible next step (saving the image to file for future use) is shown.</p> <ul> <li>NOTE: this step is optional and can be skipped if not required for your specific use case.</li> </ul> Example Final Step <pre><code># Save isolated object to file\n_ = cv.imwrite(f'{img_name}_{label}-{ci}.png', iso_crop)\n</code></pre> <ul> <li>In this example, the <code>img_name</code> is the base-name of the source image file, <code>label</code> is the detected class-name, and <code>ci</code> is the index of the object detection (in case of multiple instances with the same class name).</li> </ul> </li>"},{"location":"guides/isolating-segmentation-objects/#object-isolation-options","title":"Object Isolation Options","text":"Black Background PixelsTransparent Background Pixels <pre><code># Create 3-channel mask\nmask3ch = cv.cvtColor(b_mask, cv.COLOR_GRAY2BGR)\n\n# Isolate object with binary mask\nisolated = cv.bitwise_and(mask3ch, img)\n</code></pre> How does this work? <ul> <li> <p>First, the binary mask is first converted from a single-channel image to a three-channel image. This conversion is necessary for the subsequent step where the mask and the original image are combined. Both images must have the same number of channels to be compatible with the blending operation.</p> </li> <li> <p>The original image and the three-channel binary mask are merged using the OpenCV function <code>bitwise_and()</code>. This operation retains only pixel values that are greater than zero <code>(&gt; 0)</code> from both images. Since the mask pixels are greater than zero <code>(&gt; 0)</code> only within the contour region, the pixels remaining from the original image are those that overlap with the contour.</p> </li> </ul> <pre><code># Isolate object with transparent background (when saved as PNG)\nisolated = np.dstack([img, b_mask])\n</code></pre> How does this work? <ul> <li>Using the NumPy <code>dstack()</code> function (array stacking along depth-axis) in conjunction with the binary mask generated, will create an image with four channels. This allows for all pixels outside of the object contour to be transparent when saving as a <code>PNG</code> file.</li> </ul> What if I want the cropped object including the background? <p>This is a built in feature for the Ultralytics library. See the <code>save_crop</code> argument for  Predict Mode Inference Arguments for details.</p>"},{"location":"guides/isolating-segmentation-objects/#isolate-with-black-pixels-sub-options","title":"Isolate with Black Pixels: Sub-options","text":"Full-size Image <p>There are no additional steps required if keeping full size image.</p> <p> Example full-size output </p> Cropped object Image <p>Additional steps required to crop image to only include object region.</p> <p> <pre><code># (1) Bounding box coordinates\nx1, y1, x2, y2 = c.boxes.xyxy.cpu().numpy().squeeze().astype(np.int32)\n# Crop image to object region\niso_crop = isolated[y1:y2, x1:x2]\n</code></pre></p> <ol> <li>For more information on bounding box results, see Boxes Section from Predict Mode</li> </ol> What does this code do? <ul> <li> <p>The <code>c.boxes.xyxy.cpu().numpy()</code> call retrieves the bounding boxes as a NumPy array in the <code>xyxy</code> format, where <code>xmin</code>, <code>ymin</code>, <code>xmax</code>, and <code>ymax</code> represent the coordinates of the bounding box rectangle. See Boxes Section from Predict Mode for more details.</p> </li> <li> <p>The <code>squeeze()</code> operation removes any unnecessary dimensions from the NumPy array, ensuring it has the expected shape.</p> </li> <li> <p>Converting the coordinate values using <code>.astype(np.int32)</code> changes the box coordinates data type from <code>float32</code> to <code>int32</code>, making them compatible for image cropping using index slices.</p> </li> <li> <p>Finally, the bounding box region is cropped from the image using index slicing. The bounds are defined by the <code>[ymin:ymax, xmin:xmax]</code> coordinates of the detection bounding box.</p> </li> </ul>"},{"location":"guides/isolating-segmentation-objects/#isolate-with-transparent-pixels-sub-options","title":"Isolate with Transparent Pixels: Sub-options","text":"Full-size Image <p>There are no additional steps required if keeping full size image.</p> <p> Example full-size output + transparent background </p> Cropped object Image <p>Additional steps required to crop image to only include object region.</p> <p> <pre><code># (1) Bounding box coordinates\nx1, y1, x2, y2 = c.boxes.xyxy.cpu().numpy().squeeze().astype(np.int32)\n# Crop image to object region\niso_crop = isolated[y1:y2, x1:x2]\n</code></pre></p> <ol> <li>For more information on bounding box results, see Boxes Section from Predict Mode</li> </ol> What does this code do? <ul> <li> <p>When using <code>c.boxes.xyxy.cpu().numpy()</code>, the bounding boxes are returned as a NumPy array, using the <code>xyxy</code> box coordinates format, which correspond to the points <code>xmin, ymin, xmax, ymax</code> for the bounding box (rectangle), see Boxes Section from Predict Mode for more information.</p> </li> <li> <p>Adding <code>squeeze()</code> ensures that any extraneous dimensions are removed from the NumPy array.</p> </li> <li> <p>Converting the coordinate values using <code>.astype(np.int32)</code> changes the box coordinates data type from <code>float32</code> to <code>int32</code> which will be compatible when cropping the image using index slices.</p> </li> <li> <p>Finally the image region for the bounding box is cropped using index slicing, where the bounds are set using the <code>[ymin:ymax, xmin:xmax]</code> coordinates of the detection bounding box.</p> </li> </ul>"},{"location":"guides/isolating-segmentation-objects/#full-example-code","title":"Full Example code","text":"<p>Here, all steps from the previous section are combined into a single block of code. For repeated use, it would be optimal to define a function to do some or all commands contained in the <code>for</code>-loops, but that is an exercise left to the reader.</p> <pre><code>from pathlib import Path\n\nimport cv2 as cv\nimport numpy as np\nfrom ultralytics import YOLO\n\nm = YOLO('yolov8n-seg.pt')#(4)!\nres = m.predict()#(3)!\n\n# iterate detection results (5)\nfor r in res:\n    img = np.copy(r.orig_img)\n    img_name = Path(r.path).stem\n\n    # iterate each object contour (6)\n    for ci,c in enumerate(r):\n        label = c.names[c.boxes.cls.tolist().pop()]\n\n        b_mask = np.zeros(img.shape[:2], np.uint8)\n\n        # Create contour mask (1)\n        contour = c.masks.xy.pop().astype(np.int32).reshape(-1, 1, 2)\n        _ = cv.drawContours(b_mask, [contour], -1, (255, 255, 255), cv.FILLED)\n\n        # Choose one:\n\n        # OPTION-1: Isolate object with black background\n        mask3ch = cv.cvtColor(b_mask, cv.COLOR_GRAY2BGR)\n        isolated = cv.bitwise_and(mask3ch, img)\n\n        # OPTION-2: Isolate object with transparent background (when saved as PNG)\n        isolated = np.dstack([img, b_mask])\n\n        # OPTIONAL: detection crop (from either OPT1 or OPT2)\n        x1, y1, x2, y2 = c.boxes.xyxy.cpu().numpy().squeeze().astype(np.int32)\n        iso_crop = isolated[y1:y2, x1:x2]\n\n        # TODO your actions go here (2)\n</code></pre> <ol> <li>The line populating <code>contour</code> is combined into a single line here, where it was split to multiple above.</li> <li>What goes here is up to you!</li> <li>See Predict Mode for additional information.</li> <li>See Segment Task for more information.</li> <li>Learn more about Working with Results</li> <li>Learn more about Segmentation Mask Results</li> </ol>"},{"location":"guides/kfold-cross-validation/","title":"K-Fold Cross Validation with Ultralytics","text":""},{"location":"guides/kfold-cross-validation/#introduction","title":"Introduction","text":"<p>This comprehensive guide illustrates the implementation of K-Fold Cross Validation for object detection datasets within the Ultralytics ecosystem. We'll leverage the YOLO detection format and key Python libraries such as sklearn, pandas, and PyYaml to guide you through the necessary setup, the process of generating feature vectors, and the execution of a K-Fold dataset split.</p> <p> </p> <p>Whether your project involves the Fruit Detection dataset or a custom data source, this tutorial aims to help you comprehend and apply K-Fold Cross Validation to bolster the reliability and robustness of your machine learning models. While we're applying <code>k=5</code> folds for this tutorial, keep in mind that the optimal number of folds can vary depending on your dataset and the specifics of your project.</p> <p>Without further ado, let's dive in!</p>"},{"location":"guides/kfold-cross-validation/#setup","title":"Setup","text":"<ul> <li> <p>Your annotations should be in the YOLO detection format.</p> </li> <li> <p>This guide assumes that annotation files are locally available.</p> </li> <li> <p>For our demonstration, we use the Fruit Detection dataset.</p> <ul> <li>This dataset contains a total of 8479 images.</li> <li>It includes 6 class labels, each with its total instance counts listed below.</li> </ul> </li> </ul> Class Label Instance Count Apple 7049 Grapes 7202 Pineapple 1613 Orange 15549 Banana 3536 Watermelon 1976 <ul> <li> <p>Necessary Python packages include:</p> <ul> <li><code>ultralytics</code></li> <li><code>sklearn</code></li> <li><code>pandas</code></li> <li><code>pyyaml</code></li> </ul> </li> <li> <p>This tutorial operates with <code>k=5</code> folds. However, you should determine the best number of folds for your specific dataset.</p> </li> <li> <p>Initiate a new Python virtual environment (<code>venv</code>) for your project and activate it. Use <code>pip</code> (or your preferred package manager) to install:</p> <ul> <li>The Ultralytics library: <code>pip install -U ultralytics</code>. Alternatively, you can clone the official repo.</li> <li>Scikit-learn, pandas, and PyYAML: <code>pip install -U scikit-learn pandas pyyaml</code>.</li> </ul> </li> <li> <p>Verify that your annotations are in the YOLO detection format.</p> <ul> <li>For this tutorial, all annotation files are found in the <code>Fruit-Detection/labels</code> directory.</li> </ul> </li> </ul>"},{"location":"guides/kfold-cross-validation/#generating-feature-vectors-for-object-detection-dataset","title":"Generating Feature Vectors for Object Detection Dataset","text":"<ol> <li> <p>Start by creating a new Python file and import the required libraries.</p> <pre><code>import datetime\nimport shutil\nfrom pathlib import Path\nfrom collections import Counter\n\nimport yaml\nimport numpy as np\nimport pandas as pd\nfrom ultralytics import YOLO\nfrom sklearn.model_selection import KFold\n</code></pre> </li> <li> <p>Proceed to retrieve all label files for your dataset.</p> <pre><code>dataset_path = Path('./Fruit-detection') # replace with 'path/to/dataset' for your custom data\nlabels = sorted(dataset_path.rglob(\"*labels/*.txt\")) # all data in 'labels'\n</code></pre> </li> <li> <p>Now, read the contents of the dataset YAML file and extract the indices of the class labels.</p> <pre><code>yaml_file = 'path/to/data.yaml'  # your data YAML with data directories and names dictionary\nwith open(yaml_file, 'r', encoding=\"utf8\") as y:\n    classes = yaml.safe_load(y)['names']\ncls_idx = sorted(classes.keys())\n</code></pre> </li> <li> <p>Initialize an empty <code>pandas</code> DataFrame.</p> <pre><code>indx = [l.stem for l in labels] # uses base filename as ID (no extension)\nlabels_df = pd.DataFrame([], columns=cls_idx, index=indx)\n</code></pre> </li> <li> <p>Count the instances of each class-label present in the annotation files.</p> <pre><code>for label in labels:\n    lbl_counter = Counter()\n\n    with open(label,'r') as lf:\n        lines = lf.readlines()\n\n    for l in lines:\n        # classes for YOLO label uses integer at first position of each line\n        lbl_counter[int(l.split(' ')[0])] += 1\n\n    labels_df.loc[label.stem] = lbl_counter\n\nlabels_df = labels_df.fillna(0.0) # replace `nan` values with `0.0`\n</code></pre> </li> <li> <p>The following is a sample view of the populated DataFrame:</p> <pre><code>                                                       0    1    2    3    4    5\n'0000a16e4b057580_jpg.rf.00ab48988370f64f5ca8ea4...'  0.0  0.0  0.0  0.0  0.0  7.0\n'0000a16e4b057580_jpg.rf.7e6dce029fb67f01eb19aa7...'  0.0  0.0  0.0  0.0  0.0  7.0\n'0000a16e4b057580_jpg.rf.bc4d31cdcbe229dd022957a...'  0.0  0.0  0.0  0.0  0.0  7.0\n'00020ebf74c4881c_jpg.rf.508192a0a97aa6c4a3b6882...'  0.0  0.0  0.0  1.0  0.0  0.0\n'00020ebf74c4881c_jpg.rf.5af192a2254c8ecc4188a25...'  0.0  0.0  0.0  1.0  0.0  0.0\n ...                                                  ...  ...  ...  ...  ...  ...\n'ff4cd45896de38be_jpg.rf.c4b5e967ca10c7ced3b9e97...'  0.0  0.0  0.0  0.0  0.0  2.0\n'ff4cd45896de38be_jpg.rf.ea4c1d37d2884b3e3cbce08...'  0.0  0.0  0.0  0.0  0.0  2.0\n'ff5fd9c3c624b7dc_jpg.rf.bb519feaa36fc4bf630a033...'  1.0  0.0  0.0  0.0  0.0  0.0\n'ff5fd9c3c624b7dc_jpg.rf.f0751c9c3aa4519ea3c9d6a...'  1.0  0.0  0.0  0.0  0.0  0.0\n'fffe28b31f2a70d4_jpg.rf.7ea16bd637ba0711c53b540...'  0.0  6.0  0.0  0.0  0.0  0.0\n</code></pre> </li> </ol> <p>The rows index the label files, each corresponding to an image in your dataset, and the columns correspond to your class-label indices. Each row represents a pseudo feature-vector, with the count of each class-label present in your dataset. This data structure enables the application of K-Fold Cross Validation to an object detection dataset.</p>"},{"location":"guides/kfold-cross-validation/#k-fold-dataset-split","title":"K-Fold Dataset Split","text":"<ol> <li> <p>Now we will use the <code>KFold</code> class from <code>sklearn.model_selection</code> to generate <code>k</code> splits of the dataset.</p> <ul> <li>Important:<ul> <li>Setting <code>shuffle=True</code> ensures a randomized distribution of classes in your splits.</li> <li>By setting <code>random_state=M</code> where <code>M</code> is a chosen integer, you can obtain repeatable results.</li> </ul> </li> </ul> <pre><code>ksplit = 5\nkf = KFold(n_splits=ksplit, shuffle=True, random_state=20)   # setting random_state for repeatable results\n\nkfolds = list(kf.split(labels_df))\n</code></pre> </li> <li> <p>The dataset has now been split into <code>k</code> folds, each having a list of <code>train</code> and <code>val</code> indices. We will construct a DataFrame to display these results more clearly.</p> <pre><code>folds = [f'split_{n}' for n in range(1, ksplit + 1)]\nfolds_df = pd.DataFrame(index=indx, columns=folds)\n\nfor idx, (train, val) in enumerate(kfolds, start=1):\n    folds_df[f'split_{idx}'].loc[labels_df.iloc[train].index] = 'train'\n    folds_df[f'split_{idx}'].loc[labels_df.iloc[val].index] = 'val'\n</code></pre> </li> <li> <p>Now we will calculate the distribution of class labels for each fold as a ratio of the classes present in <code>val</code> to those present in <code>train</code>.</p> <pre><code>fold_lbl_distrb = pd.DataFrame(index=folds, columns=cls_idx)\n\nfor n, (train_indices, val_indices) in enumerate(kfolds, start=1):\n    train_totals = labels_df.iloc[train_indices].sum()\n    val_totals = labels_df.iloc[val_indices].sum()\n\n    # To avoid division by zero, we add a small value (1E-7) to the denominator\n    ratio = val_totals / (train_totals + 1E-7)\n    fold_lbl_distrb.loc[f'split_{n}'] = ratio\n</code></pre> </li> </ol> <p>The ideal scenario is for all class ratios to be reasonably similar for each split and across classes. This, however, will be subject to the specifics of your dataset.</p> <ol> <li> <p>Next, we create the directories and dataset YAML files for each split.</p> <pre><code>supported_extensions = ['.jpg', '.jpeg', '.png']\n\n# Initialize an empty list to store image file paths\nimages = []\n\n# Loop through supported extensions and gather image files\nfor ext in supported_extensions:\n    images.extend(sorted((dataset_path / 'images').rglob(f\"*{ext}\")))\n\n# Create the necessary directories and dataset YAML files (unchanged)\nsave_path = Path(dataset_path / f'{datetime.date.today().isoformat()}_{ksplit}-Fold_Cross-val')\nsave_path.mkdir(parents=True, exist_ok=True)\nds_yamls = []\n\nfor split in folds_df.columns:\n    # Create directories\n    split_dir = save_path / split\n    split_dir.mkdir(parents=True, exist_ok=True)\n    (split_dir / 'train' / 'images').mkdir(parents=True, exist_ok=True)\n    (split_dir / 'train' / 'labels').mkdir(parents=True, exist_ok=True)\n    (split_dir / 'val' / 'images').mkdir(parents=True, exist_ok=True)\n    (split_dir / 'val' / 'labels').mkdir(parents=True, exist_ok=True)\n\n    # Create dataset YAML files\n    dataset_yaml = split_dir / f'{split}_dataset.yaml'\n    ds_yamls.append(dataset_yaml)\n\n    with open(dataset_yaml, 'w') as ds_y:\n        yaml.safe_dump({\n            'path': split_dir.as_posix(),\n            'train': 'train',\n            'val': 'val',\n            'names': classes\n        }, ds_y)\n</code></pre> </li> <li> <p>Lastly, copy images and labels into the respective directory ('train' or 'val') for each split.</p> <ul> <li>NOTE: The time required for this portion of the code will vary based on the size of your dataset and your system hardware.</li> </ul> <pre><code>for image, label in zip(images, labels):\n    for split, k_split in folds_df.loc[image.stem].items():\n        # Destination directory\n        img_to_path = save_path / split / k_split / 'images'\n        lbl_to_path = save_path / split / k_split / 'labels'\n\n        # Copy image and label files to new directory (SamefileError if file already exists)\n        shutil.copy(image, img_to_path / image.name)\n        shutil.copy(label, lbl_to_path / label.name)\n</code></pre> </li> </ol>"},{"location":"guides/kfold-cross-validation/#save-records-optional","title":"Save Records (Optional)","text":"<p>Optionally, you can save the records of the K-Fold split and label distribution DataFrames as CSV files for future reference.</p> <pre><code>folds_df.to_csv(save_path / \"kfold_datasplit.csv\")\nfold_lbl_distrb.to_csv(save_path / \"kfold_label_distribution.csv\")\n</code></pre>"},{"location":"guides/kfold-cross-validation/#train-yolo-using-k-fold-data-splits","title":"Train YOLO using K-Fold Data Splits","text":"<ol> <li> <p>First, load the YOLO model.</p> <pre><code>weights_path = 'path/to/weights.pt'\nmodel = YOLO(weights_path, task='detect')\n</code></pre> </li> <li> <p>Next, iterate over the dataset YAML files to run training. The results will be saved to a directory specified by the <code>project</code> and <code>name</code> arguments. By default, this directory is 'exp/runs#' where # is an integer index.</p> <pre><code>results = {}\n\n# Define your additional arguments here\nbatch = 16\nproject = 'kfold_demo'\nepochs = 100\n\nfor k in range(ksplit):\n    dataset_yaml = ds_yamls[k]\n    model.train(data=dataset_yaml,epochs=epochs, batch=batch, project=project)  # include any train arguments\n    results[k] = model.metrics  # save output metrics for further analysis\n</code></pre> </li> </ol>"},{"location":"guides/kfold-cross-validation/#conclusion","title":"Conclusion","text":"<p>In this guide, we have explored the process of using K-Fold cross-validation for training the YOLO object detection model. We learned how to split our dataset into K partitions, ensuring a balanced class distribution across the different folds.</p> <p>We also explored the procedure for creating report DataFrames to visualize the data splits and label distributions across these splits, providing us a clear insight into the structure of our training and validation sets.</p> <p>Optionally, we saved our records for future reference, which could be particularly useful in large-scale projects or when troubleshooting model performance.</p> <p>Finally, we implemented the actual model training using each split in a loop, saving our training results for further analysis and comparison.</p> <p>This technique of K-Fold cross-validation is a robust way of making the most out of your available data, and it helps to ensure that your model performance is reliable and consistent across different data subsets. This results in a more generalizable and reliable model that is less likely to overfit to specific data patterns.</p> <p>Remember that although we used YOLO in this guide, these steps are mostly transferable to other machine learning models. Understanding these steps allows you to apply cross-validation effectively in your own machine learning projects. Happy coding!</p>"},{"location":"guides/model-deployment-options/","title":"Understanding YOLOv8\u2019s Deployment Options","text":""},{"location":"guides/model-deployment-options/#introduction","title":"Introduction","text":"<p>Setting the Scene: You've come a long way on your journey with YOLOv8. You've diligently collected data, meticulously annotated it, and put in the hours to train and rigorously evaluate your custom YOLOv8 model. Now, it\u2019s time to put your model to work for your specific application, use case, or project. But there's a critical decision that stands before you: how to export and deploy your model effectively.</p> <p>This guide walks you through YOLOv8\u2019s deployment options and the essential factors to consider to choose the right option for your project.</p>"},{"location":"guides/model-deployment-options/#how-to-select-the-right-deployment-option-for-your-yolov8-model","title":"How to Select the Right Deployment Option for Your YOLOv8 Model","text":"<p>When it's time to deploy your YOLOv8 model, selecting a suitable export format is very important. As outlined in the Ultralytics YOLOv8 Modes documentation, the model.export() function allows for converting your trained model into a variety of formats tailored to diverse environments and performance requirements.</p> <p>The ideal format depends on your model's intended operational context, balancing speed, hardware constraints, and ease of integration. In the following section, we'll take a closer look at each export option, understanding when to choose each one.</p>"},{"location":"guides/model-deployment-options/#yolov8s-deployment-options","title":"YOLOv8\u2019s Deployment Options","text":"<p>Let\u2019s walk through the different YOLOv8 deployment options. For a detailed walkthrough of the export process, visit the Ultralytics documentation page on exporting.</p>"},{"location":"guides/model-deployment-options/#pytorch","title":"PyTorch","text":"<p>PyTorch is an open-source machine learning library widely used for applications in deep learning and artificial intelligence. It provides a high level of flexibility and speed, which has made it a favorite among researchers and developers.</p> <ul> <li> <p>Performance Benchmarks: PyTorch is known for its ease of use and flexibility, which may result in a slight trade-off in raw performance when compared to other frameworks that are more specialized and optimized.</p> </li> <li> <p>Compatibility and Integration: Offers excellent compatibility with various data science and machine learning libraries in Python.</p> </li> <li> <p>Community Support and Ecosystem: One of the most vibrant communities, with extensive resources for learning and troubleshooting.</p> </li> <li> <p>Case Studies: Commonly used in research prototypes, many academic papers reference models deployed in PyTorch.</p> </li> <li> <p>Maintenance and Updates: Regular updates with active development and support for new features.</p> </li> <li> <p>Security Considerations: Regular patches for security issues, but security is largely dependent on the overall environment it\u2019s deployed in.</p> </li> <li> <p>Hardware Acceleration: Supports CUDA for GPU acceleration, essential for speeding up model training and inference.</p> </li> </ul>"},{"location":"guides/model-deployment-options/#torchscript","title":"TorchScript","text":"<p>TorchScript extends PyTorch\u2019s capabilities by allowing the exportation of models to be run in a C++ runtime environment. This makes it suitable for production environments where Python is unavailable.</p> <ul> <li> <p>Performance Benchmarks: Can offer improved performance over native PyTorch, especially in production environments.</p> </li> <li> <p>Compatibility and Integration: Designed for seamless transition from PyTorch to C++ production environments, though some advanced features might not translate perfectly.</p> </li> <li> <p>Community Support and Ecosystem: Benefits from PyTorch\u2019s large community but has a narrower scope of specialized developers.</p> </li> <li> <p>Case Studies: Widely used in industry settings where Python\u2019s performance overhead is a bottleneck.</p> </li> <li> <p>Maintenance and Updates: Maintained alongside PyTorch with consistent updates.</p> </li> <li> <p>Security Considerations: Offers improved security by enabling the running of models in environments without full Python installations.</p> </li> <li> <p>Hardware Acceleration: Inherits PyTorch\u2019s CUDA support, ensuring efficient GPU utilization.</p> </li> </ul>"},{"location":"guides/model-deployment-options/#onnx","title":"ONNX","text":"<p>The Open Neural Network Exchange (ONNX) is a format that allows for model interoperability across different frameworks, which can be critical when deploying to various platforms.</p> <ul> <li> <p>Performance Benchmarks: ONNX models may experience a variable performance depending on the specific runtime they are deployed on.</p> </li> <li> <p>Compatibility and Integration: High interoperability across multiple platforms and hardware due to its framework-agnostic nature.</p> </li> <li> <p>Community Support and Ecosystem: Supported by many organizations, leading to a broad ecosystem and a variety of tools for optimization.</p> </li> <li> <p>Case Studies: Frequently used to move models between different machine learning frameworks, demonstrating its flexibility.</p> </li> <li> <p>Maintenance and Updates: As an open standard, ONNX is regularly updated to support new operations and models.</p> </li> <li> <p>Security Considerations: As with any cross-platform tool, it's essential to ensure secure practices in the conversion and deployment pipeline.</p> </li> <li> <p>Hardware Acceleration: With ONNX Runtime, models can leverage various hardware optimizations.</p> </li> </ul>"},{"location":"guides/model-deployment-options/#openvino","title":"OpenVINO","text":"<p>OpenVINO is an Intel toolkit designed to facilitate the deployment of deep learning models across Intel hardware, enhancing performance and speed.</p> <ul> <li> <p>Performance Benchmarks: Specifically optimized for Intel CPUs, GPUs, and VPUs, offering significant performance boosts on compatible hardware.</p> </li> <li> <p>Compatibility and Integration: Works best within the Intel ecosystem but also supports a range of other platforms.</p> </li> <li> <p>Community Support and Ecosystem: Backed by Intel, with a solid user base especially in the computer vision domain.</p> </li> <li> <p>Case Studies: Often utilized in IoT and edge computing scenarios where Intel hardware is prevalent.</p> </li> <li> <p>Maintenance and Updates: Intel regularly updates OpenVINO to support the latest deep learning models and Intel hardware.</p> </li> <li> <p>Security Considerations: Provides robust security features suitable for deployment in sensitive applications.</p> </li> <li> <p>Hardware Acceleration: Tailored for acceleration on Intel hardware, leveraging dedicated instruction sets and hardware features.</p> </li> </ul> <p>For more details on deployment using OpenVINO, refer to the Ultralytics Integration documentation: Intel OpenVINO Export.</p>"},{"location":"guides/model-deployment-options/#tensorrt","title":"TensorRT","text":"<p>TensorRT is a high-performance deep learning inference optimizer and runtime from NVIDIA, ideal for applications needing speed and efficiency.</p> <ul> <li> <p>Performance Benchmarks: Delivers top-tier performance on NVIDIA GPUs with support for high-speed inference.</p> </li> <li> <p>Compatibility and Integration: Best suited for NVIDIA hardware, with limited support outside this environment.</p> </li> <li> <p>Community Support and Ecosystem: Strong support network through NVIDIA\u2019s developer forums and documentation.</p> </li> <li> <p>Case Studies: Widely adopted in industries requiring real-time inference on video and image data.</p> </li> <li> <p>Maintenance and Updates: NVIDIA maintains TensorRT with frequent updates to enhance performance and support new GPU architectures.</p> </li> <li> <p>Security Considerations: Like many NVIDIA products, it has a strong emphasis on security, but specifics depend on the deployment environment.</p> </li> <li> <p>Hardware Acceleration: Exclusively designed for NVIDIA GPUs, providing deep optimization and acceleration.</p> </li> </ul>"},{"location":"guides/model-deployment-options/#coreml","title":"CoreML","text":"<p>CoreML is Apple\u2019s machine learning framework, optimized for on-device performance in the Apple ecosystem, including iOS, macOS, watchOS, and tvOS.</p> <ul> <li> <p>Performance Benchmarks: Optimized for on-device performance on Apple hardware with minimal battery usage.</p> </li> <li> <p>Compatibility and Integration: Exclusively for Apple's ecosystem, providing a streamlined workflow for iOS and macOS applications.</p> </li> <li> <p>Community Support and Ecosystem: Strong support from Apple and a dedicated developer community, with extensive documentation and tools.</p> </li> <li> <p>Case Studies: Commonly used in applications that require on-device machine learning capabilities on Apple products.</p> </li> <li> <p>Maintenance and Updates: Regularly updated by Apple to support the latest machine learning advancements and Apple hardware.</p> </li> <li> <p>Security Considerations: Benefits from Apple's focus on user privacy and data security.</p> </li> <li> <p>Hardware Acceleration: Takes full advantage of Apple's neural engine and GPU for accelerated machine learning tasks.</p> </li> </ul>"},{"location":"guides/model-deployment-options/#tf-savedmodel","title":"TF SavedModel","text":"<p>TF SavedModel is TensorFlow\u2019s format for saving and serving machine learning models, particularly suited for scalable server environments.</p> <ul> <li> <p>Performance Benchmarks: Offers scalable performance in server environments, especially when used with TensorFlow Serving.</p> </li> <li> <p>Compatibility and Integration: Wide compatibility across TensorFlow's ecosystem, including cloud and enterprise server deployments.</p> </li> <li> <p>Community Support and Ecosystem: Large community support due to TensorFlow's popularity, with a vast array of tools for deployment and optimization.</p> </li> <li> <p>Case Studies: Extensively used in production environments for serving deep learning models at scale.</p> </li> <li> <p>Maintenance and Updates: Supported by Google and the TensorFlow community, ensuring regular updates and new features.</p> </li> <li> <p>Security Considerations: Deployment using TensorFlow Serving includes robust security features for enterprise-grade applications.</p> </li> <li> <p>Hardware Acceleration: Supports various hardware accelerations through TensorFlow's backends.</p> </li> </ul>"},{"location":"guides/model-deployment-options/#tf-graphdef","title":"TF GraphDef","text":"<p>TF GraphDef is a TensorFlow format that represents the model as a graph, which is beneficial for environments where a static computation graph is required.</p> <ul> <li> <p>Performance Benchmarks: Provides stable performance for static computation graphs, with a focus on consistency and reliability.</p> </li> <li> <p>Compatibility and Integration: Easily integrates within TensorFlow's infrastructure but less flexible compared to SavedModel.</p> </li> <li> <p>Community Support and Ecosystem: Good support from TensorFlow's ecosystem, with many resources available for optimizing static graphs.</p> </li> <li> <p>Case Studies: Useful in scenarios where a static graph is necessary, such as in certain embedded systems.</p> </li> <li> <p>Maintenance and Updates: Regular updates alongside TensorFlow's core updates.</p> </li> <li> <p>Security Considerations: Ensures safe deployment with TensorFlow's established security practices.</p> </li> <li> <p>Hardware Acceleration: Can utilize TensorFlow's hardware acceleration options, though not as flexible as SavedModel.</p> </li> </ul>"},{"location":"guides/model-deployment-options/#tf-lite","title":"TF Lite","text":"<p>TF Lite is TensorFlow\u2019s solution for mobile and embedded device machine learning, providing a lightweight library for on-device inference.</p> <ul> <li> <p>Performance Benchmarks: Designed for speed and efficiency on mobile and embedded devices.</p> </li> <li> <p>Compatibility and Integration: Can be used on a wide range of devices due to its lightweight nature.</p> </li> <li> <p>Community Support and Ecosystem: Backed by Google, it has a robust community and a growing number of resources for developers.</p> </li> <li> <p>Case Studies: Popular in mobile applications that require on-device inference with minimal footprint.</p> </li> <li> <p>Maintenance and Updates: Regularly updated to include the latest features and optimizations for mobile devices.</p> </li> <li> <p>Security Considerations: Provides a secure environment for running models on end-user devices.</p> </li> <li> <p>Hardware Acceleration: Supports a variety of hardware acceleration options, including GPU and DSP.</p> </li> </ul>"},{"location":"guides/model-deployment-options/#tf-edge-tpu","title":"TF Edge TPU","text":"<p>TF Edge TPU is designed for high-speed, efficient computing on Google's Edge TPU hardware, perfect for IoT devices requiring real-time processing.</p> <ul> <li> <p>Performance Benchmarks: Specifically optimized for high-speed, efficient computing on Google's Edge TPU hardware.</p> </li> <li> <p>Compatibility and Integration: Works exclusively with TensorFlow Lite models on Edge TPU devices.</p> </li> <li> <p>Community Support and Ecosystem: Growing support with resources provided by Google and third-party developers.</p> </li> <li> <p>Case Studies: Used in IoT devices and applications that require real-time processing with low latency.</p> </li> <li> <p>Maintenance and Updates: Continually improved upon to leverage the capabilities of new Edge TPU hardware releases.</p> </li> <li> <p>Security Considerations: Integrates with Google's robust security for IoT and edge devices.</p> </li> <li> <p>Hardware Acceleration: Custom-designed to take full advantage of Google Coral devices.</p> </li> </ul>"},{"location":"guides/model-deployment-options/#tfjs","title":"TF.js","text":"<p>TensorFlow.js (TF.js) is a library that brings machine learning capabilities directly to the browser, offering a new realm of possibilities for web developers and users alike. It allows for the integration of machine learning models in web applications without the need for back-end infrastructure.</p> <ul> <li> <p>Performance Benchmarks: Enables machine learning directly in the browser with reasonable performance, depending on the client device.</p> </li> <li> <p>Compatibility and Integration: High compatibility with web technologies, allowing for easy integration into web applications.</p> </li> <li> <p>Community Support and Ecosystem: Support from a community of web and Node.js developers, with a variety of tools for deploying ML models in browsers.</p> </li> <li> <p>Case Studies: Ideal for interactive web applications that benefit from client-side machine learning without the need for server-side processing.</p> </li> <li> <p>Maintenance and Updates: Maintained by the TensorFlow team with contributions from the open-source community.</p> </li> <li> <p>Security Considerations: Runs within the browser's secure context, utilizing the security model of the web platform.</p> </li> <li> <p>Hardware Acceleration: Performance can be enhanced with web-based APIs that access hardware acceleration like WebGL.</p> </li> </ul>"},{"location":"guides/model-deployment-options/#paddlepaddle","title":"PaddlePaddle","text":"<p>PaddlePaddle is an open-source deep learning framework developed by Baidu. It is designed to be both efficient for researchers and easy to use for developers. It's particularly popular in China and offers specialized support for Chinese language processing.</p> <ul> <li> <p>Performance Benchmarks: Offers competitive performance with a focus on ease of use and scalability.</p> </li> <li> <p>Compatibility and Integration: Well-integrated within Baidu's ecosystem and supports a wide range of applications.</p> </li> <li> <p>Community Support and Ecosystem: While the community is smaller globally, it's rapidly growing, especially in China.</p> </li> <li> <p>Case Studies: Commonly used in Chinese markets and by developers looking for alternatives to other major frameworks.</p> </li> <li> <p>Maintenance and Updates: Regularly updated with a focus on serving Chinese language AI applications and services.</p> </li> <li> <p>Security Considerations: Emphasizes data privacy and security, catering to Chinese data governance standards.</p> </li> <li> <p>Hardware Acceleration: Supports various hardware accelerations, including Baidu's own Kunlun chips.</p> </li> </ul>"},{"location":"guides/model-deployment-options/#ncnn","title":"ncnn","text":"<p>ncnn is a high-performance neural network inference framework optimized for the mobile platform. It stands out for its lightweight nature and efficiency, making it particularly well-suited for mobile and embedded devices where resources are limited.</p> <ul> <li> <p>Performance Benchmarks: Highly optimized for mobile platforms, offering efficient inference on ARM-based devices.</p> </li> <li> <p>Compatibility and Integration: Suitable for applications on mobile phones and embedded systems with ARM architecture.</p> </li> <li> <p>Community Support and Ecosystem: Supported by a niche but active community focused on mobile and embedded ML applications.</p> </li> <li> <p>Case Studies: Favoured for mobile applications where efficiency and speed are critical on Android and other ARM-based systems.</p> </li> <li> <p>Maintenance and Updates: Continuously improved to maintain high performance on a range of ARM devices.</p> </li> <li> <p>Security Considerations: Focuses on running locally on the device, leveraging the inherent security of on-device processing.</p> </li> <li> <p>Hardware Acceleration: Tailored for ARM CPUs and GPUs, with specific optimizations for these architectures.</p> </li> </ul>"},{"location":"guides/model-deployment-options/#comparative-analysis-of-yolov8-deployment-options","title":"Comparative Analysis of YOLOv8 Deployment Options","text":"<p>The following table provides a snapshot of the various deployment options available for YOLOv8 models, helping you to assess which may best fit your project needs based on several critical criteria. For an in-depth look at each deployment option's format, please see the Ultralytics documentation page on export formats.</p> Deployment Option Performance Benchmarks Compatibility and Integration Community Support and Ecosystem Case Studies Maintenance and Updates Security Considerations Hardware Acceleration PyTorch Good flexibility; may trade off raw performance Excellent with Python libraries Extensive resources and community Research and prototypes Regular, active development Dependent on deployment environment CUDA support for GPU acceleration TorchScript Better for production than PyTorch Smooth transition from PyTorch to C++ Specialized but narrower than PyTorch Industry where Python is a bottleneck Consistent updates with PyTorch Improved security without full Python Inherits CUDA support from PyTorch ONNX Variable depending on runtime High across different frameworks Broad ecosystem, supported by many orgs Flexibility across ML frameworks Regular updates for new operations Ensure secure conversion and deployment practices Various hardware optimizations OpenVINO Optimized for Intel hardware Best within Intel ecosystem Solid in computer vision domain IoT and edge with Intel hardware Regular updates for Intel hardware Robust features for sensitive applications Tailored for Intel hardware TensorRT Top-tier on NVIDIA GPUs Best for NVIDIA hardware Strong network through NVIDIA Real-time video and image inference Frequent updates for new GPUs Emphasis on security Designed for NVIDIA GPUs CoreML Optimized for on-device Apple hardware Exclusive to Apple ecosystem Strong Apple and developer support On-device ML on Apple products Regular Apple updates Focus on privacy and security Apple neural engine and GPU TF SavedModel Scalable in server environments Wide compatibility in TensorFlow ecosystem Large support due to TensorFlow popularity Serving models at scale Regular updates by Google and community Robust features for enterprise Various hardware accelerations TF GraphDef Stable for static computation graphs Integrates well with TensorFlow infrastructure Resources for optimizing static graphs Scenarios requiring static graphs Updates alongside TensorFlow core Established TensorFlow security practices TensorFlow acceleration options TF Lite Speed and efficiency on mobile/embedded Wide range of device support Robust community, Google backed Mobile applications with minimal footprint Latest features for mobile Secure environment on end-user devices GPU and DSP among others TF Edge TPU Optimized for Google's Edge TPU hardware Exclusive to Edge TPU devices Growing with Google and third-party resources IoT devices requiring real-time processing Improvements for new Edge TPU hardware Google's robust IoT security Custom-designed for Google Coral TF.js Reasonable in-browser performance High with web technologies Web and Node.js developers support Interactive web applications TensorFlow team and community contributions Web platform security model Enhanced with WebGL and other APIs PaddlePaddle Competitive, easy to use and scalable Baidu ecosystem, wide application support Rapidly growing, especially in China Chinese market and language processing Focus on Chinese AI applications Emphasizes data privacy and security Including Baidu's Kunlun chips ncnn Optimized for mobile ARM-based devices Mobile and embedded ARM systems Niche but active mobile/embedded ML community Android and ARM systems efficiency High performance maintenance on ARM On-device security advantages ARM CPUs and GPUs optimizations <p>This comparative analysis gives you a high-level overview. For deployment, it's essential to consider the specific requirements and constraints of your project, and consult the detailed documentation and resources available for each option.</p>"},{"location":"guides/model-deployment-options/#community-and-support","title":"Community and Support","text":"<p>When you're getting started with YOLOv8, having a helpful community and support can make a significant impact. Here's how to connect with others who share your interests and get the assistance you need.</p>"},{"location":"guides/model-deployment-options/#engage-with-the-broader-community","title":"Engage with the Broader Community","text":"<ul> <li> <p>GitHub Discussions: The YOLOv8 repository on GitHub has a \"Discussions\" section where you can ask questions, report issues, and suggest improvements.</p> </li> <li> <p>Ultralytics Discord Server: Ultralytics has a Discord server where you can interact with other users and developers.</p> </li> </ul>"},{"location":"guides/model-deployment-options/#official-documentation-and-resources","title":"Official Documentation and Resources","text":"<ul> <li>Ultralytics YOLOv8 Docs: The official documentation provides a comprehensive overview of YOLOv8, along with guides on installation, usage, and troubleshooting.</li> </ul> <p>These resources will help you tackle challenges and stay updated on the latest trends and best practices in the YOLOv8 community.</p>"},{"location":"guides/model-deployment-options/#conclusion","title":"Conclusion","text":"<p>In this guide, we've explored the different deployment options for YOLOv8. We've also discussed the important factors to consider when making your choice. These options allow you to customize your model for various environments and performance requirements, making it suitable for real-world applications.</p> <p>Don't forget that the YOLOv8 and Ultralytics community is a valuable source of help. Connect with other developers and experts to learn unique tips and solutions you might not find in regular documentation. Keep seeking knowledge, exploring new ideas, and sharing your experiences.</p> <p>Happy deploying!</p>"},{"location":"guides/object-blurring/","title":"Object Blurring using Ultralytics YOLOv8 \ud83d\ude80","text":""},{"location":"guides/object-blurring/#what-is-object-blurring","title":"What is Object Blurring?","text":"<p>Object blurring with Ultralytics YOLOv8  involves applying a blurring effect to specific detected objects in an image or video. This can be achieved using the YOLOv8 model capabilities to identify and manipulate objects within a given scene.</p>"},{"location":"guides/object-blurring/#advantages-of-object-blurring","title":"Advantages of Object Blurring?","text":"<ul> <li>Privacy Protection: Object blurring is an effective tool for safeguarding privacy by concealing sensitive or personally identifiable information in images or videos.</li> <li>Selective Focus: YOLOv8 allows for selective blurring, enabling users to target specific objects, ensuring a balance between privacy and retaining relevant visual information.</li> <li>Real-time Processing: YOLOv8's efficiency enables object blurring in real-time, making it suitable for applications requiring on-the-fly privacy enhancements in dynamic environments.</li> </ul> <p>Object Blurring using YOLOv8 Example</p> Object Blurring <pre><code>from ultralytics import YOLO\nfrom ultralytics.utils.plotting import Annotator, colors\nimport cv2\n\nmodel = YOLO(\"yolov8n.pt\")\nnames = model.names\n\ncap = cv2.VideoCapture(\"path/to/video/file.mp4\")\nassert cap.isOpened(), \"Error reading video file\"\nw, h, fps = (int(cap.get(x)) for x in (cv2.CAP_PROP_FRAME_WIDTH, cv2.CAP_PROP_FRAME_HEIGHT, cv2.CAP_PROP_FPS))\n\n# Blur ratio\nblur_ratio = 50\n\n# Video writer\nvideo_writer = cv2.VideoWriter(\"object_blurring_output.avi\",\n                               cv2.VideoWriter_fourcc(*'mp4v'),\n                               fps, (w, h))\n\nwhile cap.isOpened():\n    success, im0 = cap.read()\n    if not success:\n        print(\"Video frame is empty or video processing has been successfully completed.\")\n        break\n\n    results = model.predict(im0, show=False)\n    boxes = results[0].boxes.xyxy.cpu().tolist()\n    clss = results[0].boxes.cls.cpu().tolist()\n    annotator = Annotator(im0, line_width=2, example=names)\n\n    if boxes is not None:\n        for box, cls in zip(boxes, clss):\n            annotator.box_label(box, color=colors(int(cls), True), label=names[int(cls)])\n\n            obj = im0[int(box[1]):int(box[3]), int(box[0]):int(box[2])]\n            blur_obj = cv2.blur(obj, (blur_ratio, blur_ratio))\n\n            im0[int(box[1]):int(box[3]), int(box[0]):int(box[2])] = blur_obj\n\n    cv2.imshow(\"ultralytics\", im0)\n    video_writer.write(im0)\n    if cv2.waitKey(1) &amp; 0xFF == ord('q'):\n        break\n\ncap.release()\nvideo_writer.release()\ncv2.destroyAllWindows()\n</code></pre>"},{"location":"guides/object-blurring/#arguments-modelpredict","title":"Arguments <code>model.predict</code>","text":"Name Type Default Description <code>source</code> <code>str</code> <code>'ultralytics/assets'</code> source directory for images or videos <code>conf</code> <code>float</code> <code>0.25</code> object confidence threshold for detection <code>iou</code> <code>float</code> <code>0.7</code> intersection over union (IoU) threshold for NMS <code>imgsz</code> <code>int or tuple</code> <code>640</code> image size as scalar or (h, w) list, i.e. (640, 480) <code>half</code> <code>bool</code> <code>False</code> use half precision (FP16) <code>device</code> <code>None or str</code> <code>None</code> device to run on, i.e. cuda device=0/1/2/3 or device=cpu <code>max_det</code> <code>int</code> <code>300</code> maximum number of detections per image <code>vid_stride</code> <code>bool</code> <code>False</code> video frame-rate stride <code>stream_buffer</code> <code>bool</code> <code>False</code> buffer all streaming frames (True) or return the most recent frame (False) <code>visualize</code> <code>bool</code> <code>False</code> visualize model features <code>augment</code> <code>bool</code> <code>False</code> apply image augmentation to prediction sources <code>agnostic_nms</code> <code>bool</code> <code>False</code> class-agnostic NMS <code>classes</code> <code>list[int]</code> <code>None</code> filter results by class, i.e. classes=0, or classes=[0,2,3] <code>retina_masks</code> <code>bool</code> <code>False</code> use high-resolution segmentation masks <code>embed</code> <code>list[int]</code> <code>None</code> return feature vectors/embeddings from given layers"},{"location":"guides/object-counting/","title":"Object Counting using Ultralytics YOLOv8 \ud83d\ude80","text":""},{"location":"guides/object-counting/#what-is-object-counting","title":"What is Object Counting?","text":"<p>Object counting with Ultralytics YOLOv8 involves accurate identification and counting of specific objects in videos and camera streams. YOLOv8 excels in real-time applications, providing efficient and precise object counting for various scenarios like crowd analysis and surveillance, thanks to its state-of-the-art algorithms and deep learning capabilities.</p> <p> Watch: Object Counting using Ultralytics YOLOv8 </p>"},{"location":"guides/object-counting/#advantages-of-object-counting","title":"Advantages of Object Counting?","text":"<ul> <li>Resource Optimization: Object counting facilitates efficient resource management by providing accurate counts, and optimizing resource allocation in applications like inventory management.</li> <li>Enhanced Security: Object counting enhances security and surveillance by accurately tracking and counting entities, aiding in proactive threat detection.</li> <li>Informed Decision-Making: Object counting offers valuable insights for decision-making, optimizing processes in retail, traffic management, and various other domains.</li> </ul>"},{"location":"guides/object-counting/#real-world-applications","title":"Real World Applications","text":"Logistics Aquaculture Conveyor Belt Packets Counting Using Ultralytics YOLOv8 Fish Counting in Sea using Ultralytics YOLOv8 <p>Object Counting using YOLOv8 Example</p> RegionLineSpecific Classes <pre><code>from ultralytics import YOLO\nfrom ultralytics.solutions import object_counter\nimport cv2\n\nmodel = YOLO(\"yolov8n.pt\")\ncap = cv2.VideoCapture(\"path/to/video/file.mp4\")\nassert cap.isOpened(), \"Error reading video file\"\nw, h, fps = (int(cap.get(x)) for x in (cv2.CAP_PROP_FRAME_WIDTH, cv2.CAP_PROP_FRAME_HEIGHT, cv2.CAP_PROP_FPS))\n\n# Define region points\nregion_points = [(20, 400), (1080, 404), (1080, 360), (20, 360)]\n\n# Video writer\nvideo_writer = cv2.VideoWriter(\"object_counting_output.avi\",\n                       cv2.VideoWriter_fourcc(*'mp4v'),\n                       fps,\n                       (w, h))\n\n# Init Object Counter\ncounter = object_counter.ObjectCounter()\ncounter.set_args(view_img=True,\n                 reg_pts=region_points,\n                 classes_names=model.names,\n                 draw_tracks=True)\n\nwhile cap.isOpened():\n    success, im0 = cap.read()\n    if not success:\n        print(\"Video frame is empty or video processing has been successfully completed.\")\n        break\n    tracks = model.track(im0, persist=True, show=False)\n\n    im0 = counter.start_counting(im0, tracks)\n    video_writer.write(im0)\n\ncap.release()\nvideo_writer.release()\ncv2.destroyAllWindows()\n</code></pre> <pre><code>from ultralytics import YOLO\nfrom ultralytics.solutions import object_counter\nimport cv2\n\nmodel = YOLO(\"yolov8n.pt\")\ncap = cv2.VideoCapture(\"path/to/video/file.mp4\")\nassert cap.isOpened(), \"Error reading video file\"\nw, h, fps = (int(cap.get(x)) for x in (cv2.CAP_PROP_FRAME_WIDTH, cv2.CAP_PROP_FRAME_HEIGHT, cv2.CAP_PROP_FPS))\n\n# Define line points\nline_points = [(20, 400), (1080, 400)]\n\n# Video writer\nvideo_writer = cv2.VideoWriter(\"object_counting_output.avi\",\n                       cv2.VideoWriter_fourcc(*'mp4v'),\n                       fps,\n                       (w, h))\n\n# Init Object Counter\ncounter = object_counter.ObjectCounter()\ncounter.set_args(view_img=True,\n                 reg_pts=line_points,\n                 classes_names=model.names,\n                 draw_tracks=True)\n\nwhile cap.isOpened():\n    success, im0 = cap.read()\n    if not success:\n        print(\"Video frame is empty or video processing has been successfully completed.\")\n        break\n    tracks = model.track(im0, persist=True, show=False)\n\n    im0 = counter.start_counting(im0, tracks)\n    video_writer.write(im0)\n\ncap.release()\nvideo_writer.release()\ncv2.destroyAllWindows()\n</code></pre> <pre><code>from ultralytics import YOLO\nfrom ultralytics.solutions import object_counter\nimport cv2\n\nmodel = YOLO(\"yolov8n.pt\")\ncap = cv2.VideoCapture(\"path/to/video/file.mp4\")\nassert cap.isOpened(), \"Error reading video file\"\nw, h, fps = (int(cap.get(x)) for x in (cv2.CAP_PROP_FRAME_WIDTH, cv2.CAP_PROP_FRAME_HEIGHT, cv2.CAP_PROP_FPS))\n\nline_points = [(20, 400), (1080, 400)]  # line or region points\nclasses_to_count = [0, 2]  # person and car classes for count\n\n# Video writer\nvideo_writer = cv2.VideoWriter(\"object_counting_output.avi\",\n                       cv2.VideoWriter_fourcc(*'mp4v'),\n                       fps,\n                       (w, h))\n\n# Init Object Counter\ncounter = object_counter.ObjectCounter()\ncounter.set_args(view_img=True,\n                 reg_pts=line_points,\n                 classes_names=model.names,\n                 draw_tracks=True)\n\nwhile cap.isOpened():\n    success, im0 = cap.read()\n    if not success:\n        print(\"Video frame is empty or video processing has been successfully completed.\")\n        break\n    tracks = model.track(im0, persist=True, show=False,\n                         classes=classes_to_count)\n\n    im0 = counter.start_counting(im0, tracks)\n    video_writer.write(im0)\n\ncap.release()\nvideo_writer.release()\ncv2.destroyAllWindows()\n</code></pre> Region is Movable <p>You can move the region anywhere in the frame by clicking on its edges</p>"},{"location":"guides/object-counting/#optional-arguments-set_args","title":"Optional Arguments <code>set_args</code>","text":"Name Type Default Description view_img <code>bool</code> <code>False</code> Display frames with counts view_in_counts <code>bool</code> <code>True</code> Display incounts only on video frame view_out_counts <code>bool</code> <code>True</code> Display outcounts only on video frame line_thickness <code>int</code> <code>2</code> Increase bounding boxes thickness reg_pts <code>list</code> <code>[(20, 400), (1260, 400)]</code> Points defining the Region Area classes_names <code>dict</code> <code>model.model.names</code> Dictionary of Class Names region_color <code>RGB Color</code> <code>(255, 0, 255)</code> Color of the Object counting Region or Line track_thickness <code>int</code> <code>2</code> Thickness of Tracking Lines draw_tracks <code>bool</code> <code>False</code> Enable drawing Track lines track_color <code>RGB Color</code> <code>(0, 255, 0)</code> Color for each track line line_dist_thresh <code>int</code> <code>15</code> Euclidean Distance threshold for line counter count_txt_thickness <code>int</code> <code>2</code> Thickness of Object counts text count_txt_color <code>RGB Color</code> <code>(0, 0, 0)</code> Foreground color for Object counts text count_color <code>RGB Color</code> <code>(255, 255, 255)</code> Background color for Object counts text region_thickness <code>int</code> <code>5</code> Thickness for object counter region or line"},{"location":"guides/object-counting/#arguments-modeltrack","title":"Arguments <code>model.track</code>","text":"Name Type Default Description <code>source</code> <code>im0</code> <code>None</code> source directory for images or videos <code>persist</code> <code>bool</code> <code>False</code> persisting tracks between frames <code>tracker</code> <code>str</code> <code>botsort.yaml</code> Tracking method 'bytetrack' or 'botsort' <code>conf</code> <code>float</code> <code>0.3</code> Confidence Threshold <code>iou</code> <code>float</code> <code>0.5</code> IOU Threshold <code>classes</code> <code>list</code> <code>None</code> filter results by class, i.e. classes=0, or classes=[0,2,3] <code>verbose</code> <code>bool</code> <code>True</code> Display the object tracking results"},{"location":"guides/object-cropping/","title":"Object Cropping using Ultralytics YOLOv8 \ud83d\ude80","text":""},{"location":"guides/object-cropping/#what-is-object-cropping","title":"What is Object Cropping?","text":"<p>Object cropping with Ultralytics YOLOv8 involves isolating and extracting specific detected objects from an image or video. The YOLOv8 model capabilities are utilized to accurately identify and delineate objects, enabling precise cropping for further analysis or manipulation.</p>"},{"location":"guides/object-cropping/#advantages-of-object-cropping","title":"Advantages of Object Cropping?","text":"<ul> <li>Focused Analysis: YOLOv8 facilitates targeted object cropping, allowing for in-depth examination or processing of individual items within a scene.</li> <li>Reduced Data Volume: By extracting only relevant objects, object cropping helps in minimizing data size, making it efficient for storage, transmission, or subsequent computational tasks.</li> <li>Enhanced Precision: YOLOv8's object detection accuracy ensures that the cropped objects maintain their spatial relationships, preserving the integrity of the visual information for detailed analysis.</li> </ul> <p>Object Cropping using YOLOv8 Example</p> Object Cropping <pre><code>from ultralytics import YOLO\nfrom ultralytics.utils.plotting import Annotator, colors\nimport cv2\nimport os\n\nmodel = YOLO(\"yolov8n.pt\")\nnames = model.names\n\ncap = cv2.VideoCapture(\"path/to/video/file.mp4\")\nassert cap.isOpened(), \"Error reading video file\"\nw, h, fps = (int(cap.get(x)) for x in (cv2.CAP_PROP_FRAME_WIDTH, cv2.CAP_PROP_FRAME_HEIGHT, cv2.CAP_PROP_FPS))\n\ncrop_dir_name = \"ultralytics_crop\"\nif not os.path.exists(crop_dir_name):\n    os.mkdir(crop_dir_name)\n\n# Video writer\nvideo_writer = cv2.VideoWriter(\"object_cropping_output.avi\",\n                               cv2.VideoWriter_fourcc(*'mp4v'),\n                               fps, (w, h))\n\nidx = 0\nwhile cap.isOpened():\n    success, im0 = cap.read()\n    if not success:\n        print(\"Video frame is empty or video processing has been successfully completed.\")\n        break\n\n    results = model.predict(im0, show=False)\n    boxes = results[0].boxes.xyxy.cpu().tolist()\n    clss = results[0].boxes.cls.cpu().tolist()\n    annotator = Annotator(im0, line_width=2, example=names)\n\n    if boxes is not None:\n        for box, cls in zip(boxes, clss):\n            idx += 1\n            annotator.box_label(box, color=colors(int(cls), True), label=names[int(cls)])\n\n            crop_obj = im0[int(box[1]):int(box[3]), int(box[0]):int(box[2])]\n\n            cv2.imwrite(os.path.join(crop_dir_name, str(idx)+\".png\"), crop_obj)\n\n    cv2.imshow(\"ultralytics\", im0)\n    video_writer.write(im0)\n\n    if cv2.waitKey(1) &amp; 0xFF == ord('q'):\n        break\n\ncap.release()\nvideo_writer.release()\ncv2.destroyAllWindows()\n</code></pre>"},{"location":"guides/object-cropping/#arguments-modelpredict","title":"Arguments <code>model.predict</code>","text":"Name Type Default Description <code>source</code> <code>str</code> <code>'ultralytics/assets'</code> source directory for images or videos <code>conf</code> <code>float</code> <code>0.25</code> object confidence threshold for detection <code>iou</code> <code>float</code> <code>0.7</code> intersection over union (IoU) threshold for NMS <code>imgsz</code> <code>int or tuple</code> <code>640</code> image size as scalar or (h, w) list, i.e. (640, 480) <code>half</code> <code>bool</code> <code>False</code> use half precision (FP16) <code>device</code> <code>None or str</code> <code>None</code> device to run on, i.e. cuda device=0/1/2/3 or device=cpu <code>max_det</code> <code>int</code> <code>300</code> maximum number of detections per image <code>vid_stride</code> <code>bool</code> <code>False</code> video frame-rate stride <code>stream_buffer</code> <code>bool</code> <code>False</code> buffer all streaming frames (True) or return the most recent frame (False) <code>visualize</code> <code>bool</code> <code>False</code> visualize model features <code>augment</code> <code>bool</code> <code>False</code> apply image augmentation to prediction sources <code>agnostic_nms</code> <code>bool</code> <code>False</code> class-agnostic NMS <code>classes</code> <code>list[int]</code> <code>None</code> filter results by class, i.e. classes=0, or classes=[0,2,3] <code>retina_masks</code> <code>bool</code> <code>False</code> use high-resolution segmentation masks <code>embed</code> <code>list[int]</code> <code>None</code> return feature vectors/embeddings from given layers"},{"location":"guides/raspberry-pi/","title":"Quick Start Guide: Raspberry Pi and Pi Camera with YOLOv5 and YOLOv8","text":"<p>This comprehensive guide aims to expedite your journey with YOLO object detection models on a Raspberry Pi using a Pi Camera. Whether you're a student, hobbyist, or a professional, this guide is designed to get you up and running in less than 30 minutes. The instructions here are rigorously tested to minimize setup issues, allowing you to focus on utilizing YOLO for your specific projects.</p> <p> Watch: Raspberry Pi 5 updates and improvements. </p>"},{"location":"guides/raspberry-pi/#prerequisites","title":"Prerequisites","text":"<ul> <li>Raspberry Pi 3, 4 or 5</li> <li>Pi Camera</li> <li>64-bit Raspberry Pi Operating System</li> </ul> <p>Connect the Pi Camera to your Raspberry Pi via a CSI cable and install the 64-bit Raspberry Pi Operating System. Verify your camera with the following command:</p> <pre><code>libcamera-hello\n</code></pre> <p>You should see a video feed from your camera.</p>"},{"location":"guides/raspberry-pi/#choose-your-yolo-version-yolov5-or-yolov8","title":"Choose Your YOLO Version: YOLOv5 or YOLOv8","text":"<p>This guide offers you the flexibility to start with either YOLOv5 or YOLOv8. Both versions have their unique advantages and use-cases. The choice is yours, but remember, the guide's aim is not just quick setup but also a robust foundation for your future work in object detection.</p>"},{"location":"guides/raspberry-pi/#hardware-specifics-at-a-glance","title":"Hardware Specifics: At a Glance","text":"<p>To assist you in making an informed hardware decision, we've summarized the key hardware specifics of Raspberry Pi 3, 4, and 5 in the table below:</p> Feature Raspberry Pi 3 Raspberry Pi 4 Raspberry Pi 5 CPU 1.2GHz Quad-Core ARM Cortex-A53 1.5GHz Quad-core 64-bit ARM Cortex-A72 2.4GHz Quad-core 64-bit Arm Cortex-A76 RAM 1GB LPDDR2 2GB, 4GB or 8GB LPDDR4 Details not yet available USB Ports 4 x USB 2.0 2 x USB 2.0, 2 x USB 3.0 2 x USB 3.0, 2 x USB 2.0 Network Ethernet &amp; Wi-Fi 802.11n Gigabit Ethernet &amp; Wi-Fi 802.11ac Gigabit Ethernet with PoE+ support, Dual-band 802.11ac Wi-Fi\u00ae Performance Slower, may require lighter YOLO models Faster, can run complex YOLO models Details not yet available Power Requirement 2.5A power supply 3.0A USB-C power supply Details not yet available Official Documentation Link Link Link <p>Please make sure to follow the instructions specific to your Raspberry Pi model to ensure a smooth setup process.</p>"},{"location":"guides/raspberry-pi/#quick-start-with-yolov5","title":"Quick Start with YOLOv5","text":"<p>This section outlines how to set up YOLOv5 on a Raspberry Pi with a Pi Camera. These steps are designed to be compatible with the libcamera camera stack introduced in Raspberry Pi OS Bullseye.</p>"},{"location":"guides/raspberry-pi/#install-necessary-packages","title":"Install Necessary Packages","text":"<ol> <li> <p>Update the Raspberry Pi:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade -y\nsudo apt-get autoremove -y\n</code></pre> </li> <li> <p>Clone the YOLOv5 repository:</p> <pre><code>cd ~\ngit clone https://github.com/Ultralytics/yolov5.git\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>cd ~/yolov5\npip3 install -r requirements.txt\n</code></pre> </li> <li> <p>For Raspberry Pi 3, install compatible versions of PyTorch and Torchvision (skip for Raspberry Pi 4):</p> <pre><code>pip3 uninstall torch torchvision\npip3 install torch==1.11.0 torchvision==0.12.0\n</code></pre> </li> </ol>"},{"location":"guides/raspberry-pi/#modify-detectpy","title":"Modify <code>detect.py</code>","text":"<p>To enable TCP streams via SSH or the CLI, minor modifications are needed in <code>detect.py</code>.</p> <ol> <li> <p>Open <code>detect.py</code>:</p> <pre><code>sudo nano ~/yolov5/detect.py\n</code></pre> </li> <li> <p>Find and modify the <code>is_url</code> line to accept TCP streams:</p> <pre><code>is_url = source.lower().startswith(('rtsp://', 'rtmp://', 'http://', 'https://', 'tcp://'))\n</code></pre> </li> <li> <p>Comment out the <code>view_img</code> line:</p> <pre><code># view_img = check_imshow(warn=True)\n</code></pre> </li> <li> <p>Save and exit:</p> <pre><code>CTRL + O -&gt; ENTER -&gt; CTRL + X\n</code></pre> </li> </ol>"},{"location":"guides/raspberry-pi/#initiate-tcp-stream-with-libcamera","title":"Initiate TCP Stream with Libcamera","text":"<ol> <li> <p>Start the TCP stream:</p> <pre><code>libcamera-vid -n -t 0 --width 1280 --height 960 --framerate 1 --inline --listen -o tcp://127.0.0.1:8888\n</code></pre> </li> </ol> <p>Keep this terminal session running for the next steps.</p>"},{"location":"guides/raspberry-pi/#perform-yolov5-inference","title":"Perform YOLOv5 Inference","text":"<ol> <li> <p>Run the YOLOv5 detection:</p> <pre><code>cd ~/yolov5\npython3 detect.py --source=tcp://127.0.0.1:8888\n</code></pre> </li> </ol>"},{"location":"guides/raspberry-pi/#quick-start-with-yolov8","title":"Quick Start with YOLOv8","text":"<p>Follow this section if you are interested in setting up YOLOv8 instead. The steps are quite similar but are tailored for YOLOv8's specific needs.</p>"},{"location":"guides/raspberry-pi/#install-necessary-packages_1","title":"Install Necessary Packages","text":"<ol> <li> <p>Update the Raspberry Pi:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade -y\nsudo apt-get autoremove -y\n</code></pre> </li> <li> <p>Install the <code>ultralytics</code> Python package:</p> <pre><code>pip3 install ultralytics\n</code></pre> </li> <li> <p>Reboot:</p> <pre><code>sudo reboot\n</code></pre> </li> </ol>"},{"location":"guides/raspberry-pi/#initiate-tcp-stream-with-libcamera_1","title":"Initiate TCP Stream with Libcamera","text":"<ol> <li> <p>Start the TCP stream:</p> <pre><code>libcamera-vid -n -t 0 --width 1280 --height 960 --framerate 1 --inline --listen -o tcp://127.0.0.1:8888\n</code></pre> </li> </ol>"},{"location":"guides/raspberry-pi/#perform-yolov8-inference","title":"Perform YOLOv8 Inference","text":"<p>To perform inference with YOLOv8, you can use the following Python code snippet:</p> <pre><code>from ultralytics import YOLO\n\nmodel = YOLO('yolov8n.pt')\nresults = model('tcp://127.0.0.1:8888', stream=True)\n\nwhile True:\n    for result in results:\n        boxes = result.boxes\n        probs = result.probs\n</code></pre>"},{"location":"guides/raspberry-pi/#next-steps","title":"Next Steps","text":"<p>Congratulations on successfully setting up YOLO on your Raspberry Pi! For further learning and support, visit Ultralytics and Kashmir World Foundation.</p>"},{"location":"guides/raspberry-pi/#acknowledgements-and-citations","title":"Acknowledgements and Citations","text":"<p>This guide was initially created by Daan Eeltink for Kashmir World Foundation, an organization dedicated to the use of YOLO for the conservation of endangered species. We acknowledge their pioneering work and educational focus in the realm of object detection technologies.</p> <p>For more information about Kashmir World Foundation's activities, you can visit their website.</p>"},{"location":"guides/region-counting/","title":"Object Counting in Different Regions using Ultralytics YOLOv8 \ud83d\ude80","text":""},{"location":"guides/region-counting/#what-is-object-counting-in-regions","title":"What is Object Counting in Regions?","text":"<p>Object counting in regions with Ultralytics YOLOv8 involves precisely determining the number of objects within specified areas using advanced computer vision. This approach is valuable for optimizing processes, enhancing security, and improving efficiency in various applications.</p> <p> Watch: Ultralytics YOLOv8 Object Counting in Multiple &amp; Movable Regions </p>"},{"location":"guides/region-counting/#advantages-of-object-counting-in-regions","title":"Advantages of Object Counting in Regions?","text":"<ul> <li>Precision and Accuracy: Object counting in regions with advanced computer vision ensures precise and accurate counts, minimizing errors often associated with manual counting.</li> <li>Efficiency Improvement: Automated object counting enhances operational efficiency, providing real-time results and streamlining processes across different applications.</li> <li>Versatility and Application: The versatility of object counting in regions makes it applicable across various domains, from manufacturing and surveillance to traffic monitoring, contributing to its widespread utility and effectiveness.</li> </ul>"},{"location":"guides/region-counting/#real-world-applications","title":"Real World Applications","text":"Retail Market Streets People Counting in Different Region using Ultralytics YOLOv8 Crowd Counting in Different Region using Ultralytics YOLOv8"},{"location":"guides/region-counting/#steps-to-run","title":"Steps to Run","text":""},{"location":"guides/region-counting/#step-1-install-required-libraries","title":"Step 1: Install Required Libraries","text":"<p>Begin by cloning the Ultralytics repository, installing dependencies, and navigating to the local directory using the provided commands in Step 2.</p> <pre><code># Clone Ultralytics repo\ngit clone https://github.com/ultralytics/ultralytics\n\n# Navigate to the local directory\ncd ultralytics/examples/YOLOv8-Region-Counter\n</code></pre>"},{"location":"guides/region-counting/#step-2-run-region-counting-using-ultralytics-yolov8","title":"Step 2: Run Region Counting Using Ultralytics YOLOv8","text":"<p>Execute the following basic commands for inference.</p> Region is Movable <p>During video playback, you can interactively move the region within the video by clicking and dragging using the left mouse button.</p> <pre><code># Save results\npython yolov8_region_counter.py --source \"path/to/video.mp4\" --save-img\n\n# Run model on CPU\npython yolov8_region_counter.py --source \"path/to/video.mp4\" --device cpu\n\n# Change model file\npython yolov8_region_counter.py --source \"path/to/video.mp4\" --weights \"path/to/model.pt\"\n\n# Detect specific classes (e.g., first and third classes)\npython yolov8_region_counter.py --source \"path/to/video.mp4\" --classes 0 2\n\n# View results without saving\npython yolov8_region_counter.py --source \"path/to/video.mp4\" --view-img\n</code></pre>"},{"location":"guides/region-counting/#optional-arguments","title":"Optional Arguments","text":"Name Type Default Description <code>--source</code> <code>str</code> <code>None</code> Path to video file, for webcam 0 <code>--line_thickness</code> <code>int</code> <code>2</code> Bounding Box thickness <code>--save-img</code> <code>bool</code> <code>False</code> Save the predicted video/image <code>--weights</code> <code>str</code> <code>yolov8n.pt</code> Weights file path <code>--classes</code> <code>list</code> <code>None</code> Detect specific classes i.e. --classes 0 2 <code>--region-thickness</code> <code>int</code> <code>2</code> Region Box thickness <code>--track-thickness</code> <code>int</code> <code>2</code> Tracking line thickness"},{"location":"guides/sahi-tiled-inference/","title":"Ultralytics Docs: Using YOLOv8 with SAHI for Sliced Inference","text":"<p>Welcome to the Ultralytics documentation on how to use YOLOv8 with SAHI (Slicing Aided Hyper Inference). This comprehensive guide aims to furnish you with all the essential knowledge you'll need to implement SAHI alongside YOLOv8. We'll deep-dive into what SAHI is, why sliced inference is critical for large-scale applications, and how to integrate these functionalities with YOLOv8 for enhanced object detection performance.</p> <p> </p>"},{"location":"guides/sahi-tiled-inference/#introduction-to-sahi","title":"Introduction to SAHI","text":"<p>SAHI (Slicing Aided Hyper Inference) is an innovative library designed to optimize object detection algorithms for large-scale and high-resolution imagery. Its core functionality lies in partitioning images into manageable slices, running object detection on each slice, and then stitching the results back together. SAHI is compatible with a range of object detection models, including the YOLO series, thereby offering flexibility while ensuring optimized use of computational resources.</p>"},{"location":"guides/sahi-tiled-inference/#key-features-of-sahi","title":"Key Features of SAHI","text":"<ul> <li>Seamless Integration: SAHI integrates effortlessly with YOLO models, meaning you can start slicing and detecting without a lot of code modification.</li> <li>Resource Efficiency: By breaking down large images into smaller parts, SAHI optimizes the memory usage, allowing you to run high-quality detection on hardware with limited resources.</li> <li>High Accuracy: SAHI maintains the detection accuracy by employing smart algorithms to merge overlapping detection boxes during the stitching process.</li> </ul>"},{"location":"guides/sahi-tiled-inference/#what-is-sliced-inference","title":"What is Sliced Inference?","text":"<p>Sliced Inference refers to the practice of subdividing a large or high-resolution image into smaller segments (slices), conducting object detection on these slices, and then recompiling the slices to reconstruct the object locations on the original image. This technique is invaluable in scenarios where computational resources are limited or when working with extremely high-resolution images that could otherwise lead to memory issues.</p>"},{"location":"guides/sahi-tiled-inference/#benefits-of-sliced-inference","title":"Benefits of Sliced Inference","text":"<ul> <li> <p>Reduced Computational Burden: Smaller image slices are faster to process, and they consume less memory, enabling smoother operation on lower-end hardware.</p> </li> <li> <p>Preserved Detection Quality: Since each slice is treated independently, there is no reduction in the quality of object detection, provided the slices are large enough to capture the objects of interest.</p> </li> <li> <p>Enhanced Scalability: The technique allows for object detection to be more easily scaled across different sizes and resolutions of images, making it ideal for a wide range of applications from satellite imagery to medical diagnostics.</p> </li> </ul> YOLOv8 without SAHI YOLOv8 with SAHI"},{"location":"guides/sahi-tiled-inference/#installation-and-preparation","title":"Installation and Preparation","text":""},{"location":"guides/sahi-tiled-inference/#installation","title":"Installation","text":"<p>To get started, install the latest versions of SAHI and Ultralytics:</p> <pre><code>pip install -U ultralytics sahi\n</code></pre>"},{"location":"guides/sahi-tiled-inference/#import-modules-and-download-resources","title":"Import Modules and Download Resources","text":"<p>Here's how to import the necessary modules and download a YOLOv8 model and some test images:</p> <pre><code>from sahi.utils.yolov8 import download_yolov8s_model\nfrom sahi import AutoDetectionModel\nfrom sahi.utils.cv import read_image\nfrom sahi.utils.file import download_from_url\nfrom sahi.predict import get_prediction, get_sliced_prediction, predict\nfrom pathlib import Path\nfrom IPython.display import Image\n\n# Download YOLOv8 model\nyolov8_model_path = \"models/yolov8s.pt\"\ndownload_yolov8s_model(yolov8_model_path)\n\n# Download test images\ndownload_from_url('https://raw.githubusercontent.com/obss/sahi/main/demo/demo_data/small-vehicles1.jpeg', 'demo_data/small-vehicles1.jpeg')\ndownload_from_url('https://raw.githubusercontent.com/obss/sahi/main/demo/demo_data/terrain2.png', 'demo_data/terrain2.png')\n</code></pre>"},{"location":"guides/sahi-tiled-inference/#standard-inference-with-yolov8","title":"Standard Inference with YOLOv8","text":""},{"location":"guides/sahi-tiled-inference/#instantiate-the-model","title":"Instantiate the Model","text":"<p>You can instantiate a YOLOv8 model for object detection like this:</p> <pre><code>detection_model = AutoDetectionModel.from_pretrained(\n    model_type='yolov8',\n    model_path=yolov8_model_path,\n    confidence_threshold=0.3,\n    device=\"cpu\",  # or 'cuda:0'\n)\n</code></pre>"},{"location":"guides/sahi-tiled-inference/#perform-standard-prediction","title":"Perform Standard Prediction","text":"<p>Perform standard inference using an image path or a numpy image.</p> <pre><code># With an image path\nresult = get_prediction(\"demo_data/small-vehicles1.jpeg\", detection_model)\n\n# With a numpy image\nresult = get_prediction(read_image(\"demo_data/small-vehicles1.jpeg\"), detection_model)\n</code></pre>"},{"location":"guides/sahi-tiled-inference/#visualize-results","title":"Visualize Results","text":"<p>Export and visualize the predicted bounding boxes and masks:</p> <pre><code>result.export_visuals(export_dir=\"demo_data/\")\nImage(\"demo_data/prediction_visual.png\")\n</code></pre>"},{"location":"guides/sahi-tiled-inference/#sliced-inference-with-yolov8","title":"Sliced Inference with YOLOv8","text":"<p>Perform sliced inference by specifying the slice dimensions and overlap ratios:</p> <pre><code>result = get_sliced_prediction(\n    \"demo_data/small-vehicles1.jpeg\",\n    detection_model,\n    slice_height=256,\n    slice_width=256,\n    overlap_height_ratio=0.2,\n    overlap_width_ratio=0.2\n)\n</code></pre>"},{"location":"guides/sahi-tiled-inference/#handling-prediction-results","title":"Handling Prediction Results","text":"<p>SAHI provides a <code>PredictionResult</code> object, which can be converted into various annotation formats:</p> <pre><code># Access the object prediction list\nobject_prediction_list = result.object_prediction_list\n\n# Convert to COCO annotation, COCO prediction, imantics, and fiftyone formats\nresult.to_coco_annotations()[:3]\nresult.to_coco_predictions(image_id=1)[:3]\nresult.to_imantics_annotations()[:3]\nresult.to_fiftyone_detections()[:3]\n</code></pre>"},{"location":"guides/sahi-tiled-inference/#batch-prediction","title":"Batch Prediction","text":"<p>For batch prediction on a directory of images:</p> <pre><code>predict(\n    model_type=\"yolov8\",\n    model_path=\"path/to/yolov8n.pt\",\n    model_device=\"cpu\",  # or 'cuda:0'\n    model_confidence_threshold=0.4,\n    source=\"path/to/dir\",\n    slice_height=256,\n    slice_width=256,\n    overlap_height_ratio=0.2,\n    overlap_width_ratio=0.2,\n)\n</code></pre> <p>That's it! Now you're equipped to use YOLOv8 with SAHI for both standard and sliced inference.</p>"},{"location":"guides/sahi-tiled-inference/#citations-and-acknowledgments","title":"Citations and Acknowledgments","text":"<p>If you use SAHI in your research or development work, please cite the original SAHI paper and acknowledge the authors:</p> BibTeX <pre><code>@article{akyon2022sahi,\n  title={Slicing Aided Hyper Inference and Fine-tuning for Small Object Detection},\n  author={Akyon, Fatih Cagatay and Altinuc, Sinan Onur and Temizel, Alptekin},\n  journal={2022 IEEE International Conference on Image Processing (ICIP)},\n  doi={10.1109/ICIP46576.2022.9897990},\n  pages={966-970},\n  year={2022}\n}\n</code></pre> <p>We extend our thanks to the SAHI research group for creating and maintaining this invaluable resource for the computer vision community. For more information about SAHI and its creators, visit the SAHI GitHub repository.</p>"},{"location":"guides/security-alarm-system/","title":"Security Alarm System Project Using Ultralytics YOLOv8","text":"<p>The Security Alarm System Project utilizing Ultralytics YOLOv8 integrates advanced computer vision capabilities to enhance security measures. YOLOv8, developed by Ultralytics, provides real-time object detection, allowing the system to identify and respond to potential security threats promptly. This project offers several advantages:</p> <ul> <li>Real-time Detection: YOLOv8's efficiency enables the Security Alarm System to detect and respond to security incidents in real-time, minimizing response time.</li> <li>Accuracy: YOLOv8 is known for its accuracy in object detection, reducing false positives and enhancing the reliability of the security alarm system.</li> <li>Integration Capabilities: The project can be seamlessly integrated with existing security infrastructure, providing an upgraded layer of intelligent surveillance.</li> </ul> <p> Watch: Security Alarm System Project with Ultralytics YOLOv8 Object Detection </p>"},{"location":"guides/security-alarm-system/#code","title":"Code","text":""},{"location":"guides/security-alarm-system/#import-libraries","title":"Import Libraries","text":"<pre><code>import torch\nimport numpy as np\nimport cv2\nfrom time import time\nfrom ultralytics import YOLO\nfrom ultralytics.utils.plotting import Annotator, colors\nimport smtplib\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\n</code></pre>"},{"location":"guides/security-alarm-system/#set-up-the-parameters-of-the-message","title":"Set up the parameters of the message","text":"Note <p>App Password Generation is necessary</p> <ul> <li>Navigate to App Password Generator, designate an app name such as \"security project,\" and obtain a 16-digit password. Copy this password and paste it into the designated password field as instructed.</li> </ul> <pre><code>password = \"\"\nfrom_email = \"\"  # must match the email used to generate the password\nto_email = \"\"  # receiver email\n</code></pre>"},{"location":"guides/security-alarm-system/#server-creation-and-authentication","title":"Server creation and authentication","text":"<pre><code>server = smtplib.SMTP('smtp.gmail.com: 587')\nserver.starttls()\nserver.login(from_email, password)\n</code></pre>"},{"location":"guides/security-alarm-system/#email-send-function","title":"Email Send Function","text":"<pre><code>def send_email(to_email, from_email, object_detected=1):\n    message = MIMEMultipart()\n    message['From'] = from_email\n    message['To'] = to_email\n    message['Subject'] = \"Security Alert\"\n    # Add in the message body\n    message_body = f'ALERT - {object_detected} objects has been detected!!'\n\n    message.attach(MIMEText(message_body, 'plain'))\n    server.sendmail(from_email, to_email, message.as_string())\n</code></pre>"},{"location":"guides/security-alarm-system/#object-detection-and-alert-sender","title":"Object Detection and Alert Sender","text":"<pre><code>class ObjectDetection:\n    def __init__(self, capture_index):\n        # default parameters\n        self.capture_index = capture_index\n        self.email_sent = False\n\n        # model information\n        self.model = YOLO(\"yolov8n.pt\")\n\n        # visual information\n        self.annotator = None\n        self.start_time = 0\n        self.end_time = 0\n\n        # device information\n        self.device = 'cuda' if torch.cuda.is_available() else 'cpu'\n\n    def predict(self, im0):\n        results = self.model(im0)\n        return results\n\n    def display_fps(self, im0):\n        self.end_time = time()\n        fps = 1 / np.round(self.end_time - self.start_time, 2)\n        text = f'FPS: {int(fps)}'\n        text_size = cv2.getTextSize(text, cv2.FONT_HERSHEY_SIMPLEX, 1.0, 2)[0]\n        gap = 10\n        cv2.rectangle(im0, (20 - gap, 70 - text_size[1] - gap), (20 + text_size[0] + gap, 70 + gap), (255, 255, 255), -1)\n        cv2.putText(im0, text, (20, 70), cv2.FONT_HERSHEY_SIMPLEX, 1.0, (0, 0, 0), 2)\n\n    def plot_bboxes(self, results, im0):\n        class_ids = []\n        self.annotator = Annotator(im0, 3, results[0].names)\n        boxes = results[0].boxes.xyxy.cpu()\n        clss = results[0].boxes.cls.cpu().tolist()\n        names = results[0].names\n        for box, cls in zip(boxes, clss):\n            class_ids.append(cls)\n            self.annotator.box_label(box, label=names[int(cls)], color=colors(int(cls), True))\n        return im0, class_ids\n\n    def __call__(self):\n        cap = cv2.VideoCapture(self.capture_index)\n        assert cap.isOpened()\n        cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)\n        cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)\n        frame_count = 0\n        while True:\n            self.start_time = time()\n            ret, im0 = cap.read()\n            assert ret\n            results = self.predict(im0)\n            im0, class_ids = self.plot_bboxes(results, im0)\n\n            if len(class_ids) &gt; 0:  # Only send email If not sent before\n                if not self.email_sent:\n                    send_email(to_email, from_email, len(class_ids))\n                    self.email_sent = True\n            else:\n                self.email_sent = False\n\n            self.display_fps(im0)\n            cv2.imshow('YOLOv8 Detection', im0)\n            frame_count += 1\n            if cv2.waitKey(5) &amp; 0xFF == 27:\n                break\n        cap.release()\n        cv2.destroyAllWindows()\n        server.quit()\n</code></pre>"},{"location":"guides/security-alarm-system/#call-the-object-detection-class-and-run-the-inference","title":"Call the Object Detection class and Run the Inference","text":"<pre><code>detector = ObjectDetection(capture_index=0)\ndetector()\n</code></pre> <p>That's it! When you execute the code, you'll receive a single notification on your email if any object is detected. The notification is sent immediately, not repeatedly. However, feel free to customize the code to suit your project requirements.</p>"},{"location":"guides/security-alarm-system/#email-received-sample","title":"Email Received Sample","text":""},{"location":"guides/speed-estimation/","title":"Speed Estimation using Ultralytics YOLOv8 \ud83d\ude80","text":""},{"location":"guides/speed-estimation/#what-is-speed-estimation","title":"What is Speed Estimation?","text":"<p>Speed estimation is the process of calculating the rate of movement of an object within a given context, often employed in computer vision applications. Using Ultralytics YOLOv8 you can now calculate the speed of object using object tracking alongside distance and time data, crucial for tasks like traffic and surveillance. The accuracy of speed estimation directly influences the efficiency and reliability of various applications, making it a key component in the advancement of intelligent systems and real-time decision-making processes.</p>"},{"location":"guides/speed-estimation/#advantages-of-speed-estimation","title":"Advantages of Speed Estimation?","text":"<ul> <li>Efficient Traffic Control: Accurate speed estimation aids in managing traffic flow, enhancing safety, and reducing congestion on roadways.</li> <li>Precise Autonomous Navigation: In autonomous systems like self-driving cars, reliable speed estimation ensures safe and accurate vehicle navigation.</li> <li>Enhanced Surveillance Security: Speed estimation in surveillance analytics helps identify unusual behaviors or potential threats, improving the effectiveness of security measures.</li> </ul>"},{"location":"guides/speed-estimation/#real-world-applications","title":"Real World Applications","text":"Transportation Transportation Speed Estimation on Road using Ultralytics YOLOv8 Speed Estimation on Bridge using Ultralytics YOLOv8 <p>Speed Estimation using YOLOv8 Example</p> Speed Estimation <pre><code>from ultralytics import YOLO\nfrom ultralytics.solutions import speed_estimation\nimport cv2\n\nmodel = YOLO(\"yolov8n.pt\")\nnames = model.model.names\n\ncap = cv2.VideoCapture(\"path/to/video/file.mp4\")\nassert cap.isOpened(), \"Error reading video file\"\nw, h, fps = (int(cap.get(x)) for x in (cv2.CAP_PROP_FRAME_WIDTH, cv2.CAP_PROP_FRAME_HEIGHT, cv2.CAP_PROP_FPS))\n\n# Video writer\nvideo_writer = cv2.VideoWriter(\"speed_estimation.avi\",\n                               cv2.VideoWriter_fourcc(*'mp4v'),\n                               fps,\n                               (w, h))\n\nline_pts = [(0, 360), (1280, 360)]\n\n# Init speed-estimation obj\nspeed_obj = speed_estimation.SpeedEstimator()\nspeed_obj.set_args(reg_pts=line_pts,\n                   names=names,\n                   view_img=True)\n\nwhile cap.isOpened():\n\n    success, im0 = cap.read()\n    if not success:\n        print(\"Video frame is empty or video processing has been successfully completed.\")\n        break\n\n    tracks = model.track(im0, persist=True, show=False)\n\n    im0 = speed_obj.estimate_speed(im0, tracks)\n    video_writer.write(im0)\n\ncap.release()\nvideo_writer.release()\ncv2.destroyAllWindows()\n</code></pre> Speed is Estimate <p>Speed will be an estimate and may not be completely accurate. Additionally, the estimation can vary depending on GPU speed.</p>"},{"location":"guides/speed-estimation/#optional-arguments-set_args","title":"Optional Arguments <code>set_args</code>","text":"Name Type Default Description reg_pts <code>list</code> <code>[(20, 400), (1260, 400)]</code> Points defining the Region Area names <code>dict</code> <code>None</code> Classes names view_img <code>bool</code> <code>False</code> Display frames with counts line_thickness <code>int</code> <code>2</code> Increase bounding boxes thickness region_thickness <code>int</code> <code>5</code> Thickness for object counter region or line spdl_dist_thresh <code>int</code> <code>10</code> Euclidean Distance threshold for speed check line"},{"location":"guides/speed-estimation/#arguments-modeltrack","title":"Arguments <code>model.track</code>","text":"Name Type Default Description <code>source</code> <code>im0</code> <code>None</code> source directory for images or videos <code>persist</code> <code>bool</code> <code>False</code> persisting tracks between frames <code>tracker</code> <code>str</code> <code>botsort.yaml</code> Tracking method 'bytetrack' or 'botsort' <code>conf</code> <code>float</code> <code>0.3</code> Confidence Threshold <code>iou</code> <code>float</code> <code>0.5</code> IOU Threshold <code>classes</code> <code>list</code> <code>None</code> filter results by class, i.e. classes=0, or classes=[0,2,3] <code>verbose</code> <code>bool</code> <code>True</code> Display the object tracking results"},{"location":"guides/triton-inference-server/","title":"Triton Inference Server with Ultralytics YOLOv8","text":"<p>The Triton Inference Server (formerly known as TensorRT Inference Server) is an open-source software solution developed by NVIDIA. It provides a cloud inference solution optimized for NVIDIA GPUs. Triton simplifies the deployment of AI models at scale in production. Integrating Ultralytics YOLOv8 with Triton Inference Server allows you to deploy scalable, high-performance deep learning inference workloads. This guide provides steps to set up and test the integration.</p> <p> Watch: Getting Started with NVIDIA Triton Inference Server. </p>"},{"location":"guides/triton-inference-server/#what-is-triton-inference-server","title":"What is Triton Inference Server?","text":"<p>Triton Inference Server is designed to deploy a variety of AI models in production. It supports a wide range of deep learning and machine learning frameworks, including TensorFlow, PyTorch, ONNX Runtime, and many others. Its primary use cases are:</p> <ul> <li>Serving multiple models from a single server instance.</li> <li>Dynamic model loading and unloading without server restart.</li> <li>Ensemble inference, allowing multiple models to be used together to achieve results.</li> <li>Model versioning for A/B testing and rolling updates.</li> </ul>"},{"location":"guides/triton-inference-server/#prerequisites","title":"Prerequisites","text":"<p>Ensure you have the following prerequisites before proceeding:</p> <ul> <li>Docker installed on your machine.</li> <li>Install <code>tritonclient</code>:     <pre><code>pip install tritonclient[all]\n</code></pre></li> </ul>"},{"location":"guides/triton-inference-server/#exporting-yolov8-to-onnx-format","title":"Exporting YOLOv8 to ONNX Format","text":"<p>Before deploying the model on Triton, it must be exported to the ONNX format. ONNX (Open Neural Network Exchange) is a format that allows models to be transferred between different deep learning frameworks. Use the <code>export</code> function from the <code>YOLO</code> class:</p> <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n.pt')  # load an official model\n\n# Export the model\nonnx_file = model.export(format='onnx', dynamic=True)\n</code></pre>"},{"location":"guides/triton-inference-server/#setting-up-triton-model-repository","title":"Setting Up Triton Model Repository","text":"<p>The Triton Model Repository is a storage location where Triton can access and load models.</p> <ol> <li> <p>Create the necessary directory structure:</p> <pre><code>from pathlib import Path\n\n# Define paths\ntriton_repo_path = Path('tmp') / 'triton_repo'\ntriton_model_path = triton_repo_path / 'yolo'\n\n# Create directories\n(triton_model_path / '1').mkdir(parents=True, exist_ok=True)\n</code></pre> </li> <li> <p>Move the exported ONNX model to the Triton repository:</p> <pre><code>from pathlib import Path\n\n# Move ONNX model to Triton Model path\nPath(onnx_file).rename(triton_model_path / '1' / 'model.onnx')\n\n# Create config file\n(triton_model_path / 'config.pbtxt').touch()\n</code></pre> </li> </ol>"},{"location":"guides/triton-inference-server/#running-triton-inference-server","title":"Running Triton Inference Server","text":"<p>Run the Triton Inference Server using Docker:</p> <pre><code>import subprocess\nimport time\n\nfrom tritonclient.http import InferenceServerClient\n\n# Define image https://catalog.ngc.nvidia.com/orgs/nvidia/containers/tritonserver\ntag = 'nvcr.io/nvidia/tritonserver:23.09-py3'  # 6.4 GB\n\n# Pull the image\nsubprocess.call(f'docker pull {tag}', shell=True)\n\n# Run the Triton server and capture the container ID\ncontainer_id = subprocess.check_output(\n    f'docker run -d --rm -v {triton_repo_path}:/models -p 8000:8000 {tag} tritonserver --model-repository=/models',\n    shell=True).decode('utf-8').strip()\n\n# Wait for the Triton server to start\ntriton_client = InferenceServerClient(url='localhost:8000', verbose=False, ssl=False)\n\n# Wait until model is ready\nfor _ in range(10):\n    with contextlib.suppress(Exception):\n        assert triton_client.is_model_ready(model_name)\n        break\n    time.sleep(1)\n</code></pre> <p>Then run inference using the Triton Server model:</p> <pre><code>from ultralytics import YOLO\n\n# Load the Triton Server model\nmodel = YOLO(f'http://localhost:8000/yolo', task='detect')\n\n# Run inference on the server\nresults = model('path/to/image.jpg')\n</code></pre> <p>Cleanup the container:</p> <pre><code># Kill and remove the container at the end of the test\nsubprocess.call(f'docker kill {container_id}', shell=True)\n</code></pre> <p>By following the above steps, you can deploy and run Ultralytics YOLOv8 models efficiently on Triton Inference Server, providing a scalable and high-performance solution for deep learning inference tasks. If you face any issues or have further queries, refer to the official Triton documentation or reach out to the Ultralytics community for support.</p>"},{"location":"guides/vision-eye/","title":"VisionEye View Object Mapping using Ultralytics YOLOv8 \ud83d\ude80","text":""},{"location":"guides/vision-eye/#what-is-visioneye-object-mapping","title":"What is VisionEye Object Mapping?","text":"<p>Ultralytics YOLOv8 VisionEye offers the capability for computers to identify and pinpoint objects, simulating the observational precision of the human eye. This functionality enables computers to discern and focus on specific objects, much like the way the human eye observes details from a particular viewpoint.</p>"},{"location":"guides/vision-eye/#samples","title":"Samples","text":"VisionEye View VisionEye View With Object Tracking VisionEye View Object Mapping using Ultralytics YOLOv8 VisionEye View Object Mapping with Object Tracking using Ultralytics YOLOv8 <p>VisionEye Object Mapping using YOLOv8</p> VisionEye Object MappingVisionEye Object Mapping with Object Tracking <pre><code>import cv2\nfrom ultralytics import YOLO\nfrom ultralytics.utils.plotting import colors, Annotator\n\nmodel = YOLO(\"yolov8n.pt\")\nnames = model.model.names\ncap = cv2.VideoCapture(\"path/to/video/file.mp4\")\nw, h, fps = (int(cap.get(x)) for x in (cv2.CAP_PROP_FRAME_WIDTH, cv2.CAP_PROP_FRAME_HEIGHT, cv2.CAP_PROP_FPS))\n\nout = cv2.VideoWriter('visioneye-pinpoint.avi', cv2.VideoWriter_fourcc(*'MJPG'), fps, (w, h))\n\ncenter_point = (-10, h)\n\nwhile True:\n    ret, im0 = cap.read()\n    if not ret:\n        print(\"Video frame is empty or video processing has been successfully completed.\")\n        break\n\n    results = model.predict(im0)\n    boxes = results[0].boxes.xyxy.cpu()\n    clss = results[0].boxes.cls.cpu().tolist()\n\n    annotator = Annotator(im0, line_width=2)\n\n    for box, cls in zip(boxes, clss):\n        annotator.box_label(box, label=names[int(cls)], color=colors(int(cls)))\n        annotator.visioneye(box, center_point)\n\n    out.write(im0)\n    cv2.imshow(\"visioneye-pinpoint\", im0)\n\n    if cv2.waitKey(1) &amp; 0xFF == ord('q'):\n        break\n\nout.release()\ncap.release()\ncv2.destroyAllWindows()\n</code></pre> <pre><code>import cv2\nfrom ultralytics import YOLO\nfrom ultralytics.utils.plotting import colors, Annotator\n\nmodel = YOLO(\"yolov8n.pt\")\ncap = cv2.VideoCapture(\"path/to/video/file.mp4\")\nw, h, fps = (int(cap.get(x)) for x in (cv2.CAP_PROP_FRAME_WIDTH, cv2.CAP_PROP_FRAME_HEIGHT, cv2.CAP_PROP_FPS))\n\nout = cv2.VideoWriter('visioneye-pinpoint.avi', cv2.VideoWriter_fourcc(*'MJPG'), fps, (w, h))\n\ncenter_point = (-10, h)\n\nwhile True:\n    ret, im0 = cap.read()\n    if not ret:\n        print(\"Video frame is empty or video processing has been successfully completed.\")\n        break\n\n    annotator = Annotator(im0, line_width=2)\n\n    results = model.track(im0, persist=True)\n    boxes = results[0].boxes.xyxy.cpu()\n\n    if results[0].boxes.id is not None:\n        track_ids = results[0].boxes.id.int().cpu().tolist()\n\n        for box, track_id in zip(boxes, track_ids):\n            annotator.box_label(box, label=str(track_id), color=colors(int(track_id)))\n            annotator.visioneye(box, center_point)\n\n    out.write(im0)\n    cv2.imshow(\"visioneye-pinpoint\", im0)\n\n    if cv2.waitKey(1) &amp; 0xFF == ord('q'):\n        break\n\nout.release()\ncap.release()\ncv2.destroyAllWindows()\n</code></pre>"},{"location":"guides/vision-eye/#visioneye-arguments","title":"<code>visioneye</code> Arguments","text":"Name Type Default Description <code>color</code> <code>tuple</code> <code>(235, 219, 11)</code> Line and object centroid color <code>pin_color</code> <code>tuple</code> <code>(255, 0, 255)</code> VisionEye pinpoint color <code>thickness</code> <code>int</code> <code>2</code> pinpoint to object line thickness <code>pins_radius</code> <code>int</code> <code>10</code> Pinpoint and object centroid point circle radius"},{"location":"guides/vision-eye/#note","title":"Note","text":"<p>For any inquiries, feel free to post your questions in the Ultralytics Issue Section or the discussion section mentioned below.</p>"},{"location":"guides/workouts-monitoring/","title":"Workouts Monitoring using Ultralytics YOLOv8 \ud83d\ude80","text":"<p>Monitoring workouts through pose estimation with Ultralytics YOLOv8 enhances exercise assessment by accurately tracking key body landmarks and joints in real-time. This technology provides instant feedback on exercise form, tracks workout routines, and measures performance metrics, optimizing training sessions for users and trainers alike.</p>"},{"location":"guides/workouts-monitoring/#advantages-of-workouts-monitoring","title":"Advantages of Workouts Monitoring?","text":"<ul> <li>Optimized Performance: Tailoring workouts based on monitoring data for better results.</li> <li>Goal Achievement: Track and adjust fitness goals for measurable progress.</li> <li>Personalization: Customized workout plans based on individual data for effectiveness.</li> <li>Health Awareness: Early detection of patterns indicating health issues or overtraining.</li> <li>Informed Decisions: Data-driven decisions for adjusting routines and setting realistic goals.</li> </ul>"},{"location":"guides/workouts-monitoring/#real-world-applications","title":"Real World Applications","text":"Workouts Monitoring Workouts Monitoring PushUps Counting PullUps Counting <p>Workouts Monitoring Example</p> Workouts MonitoringWorkouts Monitoring with Save Output <pre><code>from ultralytics import YOLO\nfrom ultralytics.solutions import ai_gym\nimport cv2\n\nmodel = YOLO(\"yolov8n-pose.pt\")\ncap = cv2.VideoCapture(\"path/to/video/file.mp4\")\nassert cap.isOpened(), \"Error reading video file\"\nw, h, fps = (int(cap.get(x)) for x in (cv2.CAP_PROP_FRAME_WIDTH, cv2.CAP_PROP_FRAME_HEIGHT, cv2.CAP_PROP_FPS))\n\ngym_object = ai_gym.AIGym()  # init AI GYM module\ngym_object.set_args(line_thickness=2,\n                    view_img=True,\n                    pose_type=\"pushup\",\n                    kpts_to_check=[6, 8, 10])\n\nframe_count = 0\nwhile cap.isOpened():\n    success, im0 = cap.read()\n    if not success:\n      print(\"Video frame is empty or video processing has been successfully completed.\")\n      break\n    frame_count += 1\n    results = model.predict(im0, verbose=False)\n    im0 = gym_object.start_counting(im0, results, frame_count)\n\ncv2.destroyAllWindows()\n</code></pre> <pre><code>from ultralytics import YOLO\nfrom ultralytics.solutions import ai_gym\nimport cv2\n\nmodel = YOLO(\"yolov8n-pose.pt\")\ncap = cv2.VideoCapture(\"path/to/video/file.mp4\")\nassert cap.isOpened(), \"Error reading video file\"\nw, h, fps = (int(cap.get(x)) for x in (cv2.CAP_PROP_FRAME_WIDTH, cv2.CAP_PROP_FRAME_HEIGHT, cv2.CAP_PROP_FPS))\n\nvideo_writer = cv2.VideoWriter(\"workouts.avi\",\n                                cv2.VideoWriter_fourcc(*'mp4v'),\n                                fps,\n                                (w, h))\n\ngym_object = ai_gym.AIGym()  # init AI GYM module\ngym_object.set_args(line_thickness=2,\n                    view_img=True,\n                    pose_type=\"pushup\",\n                    kpts_to_check=[6, 8, 10])\n\nframe_count = 0\nwhile cap.isOpened():\n    success, im0 = cap.read()\n    if not success:\n      print(\"Video frame is empty or video processing has been successfully completed.\")\n      break\n    frame_count += 1\n    results = model.predict(im0, verbose=False)\n    im0 = gym_object.start_counting(im0, results, frame_count)\n    video_writer.write(im0)\n\ncv2.destroyAllWindows()\nvideo_writer.release()\n</code></pre> Support <p>\"pushup\", \"pullup\" and \"abworkout\" supported</p>"},{"location":"guides/workouts-monitoring/#keypoints-map","title":"KeyPoints Map","text":""},{"location":"guides/workouts-monitoring/#arguments-set_args","title":"Arguments <code>set_args</code>","text":"Name Type Default Description kpts_to_check <code>list</code> <code>None</code> List of three keypoints index, for counting specific workout, followed by keypoint Map view_img <code>bool</code> <code>False</code> Display the frame with counts line_thickness <code>int</code> <code>2</code> Increase the thickness of count value pose_type <code>str</code> <code>pushup</code> Pose that need to be monitored, \"pullup\" and \"abworkout\" also supported pose_up_angle <code>int</code> <code>145</code> Pose Up Angle value pose_down_angle <code>int</code> <code>90</code> Pose Down Angle value"},{"location":"guides/workouts-monitoring/#arguments-modelpredict","title":"Arguments <code>model.predict</code>","text":"Name Type Default Description <code>source</code> <code>str</code> <code>'ultralytics/assets'</code> source directory for images or videos <code>conf</code> <code>float</code> <code>0.25</code> object confidence threshold for detection <code>iou</code> <code>float</code> <code>0.7</code> intersection over union (IoU) threshold for NMS <code>imgsz</code> <code>int or tuple</code> <code>640</code> image size as scalar or (h, w) list, i.e. (640, 480) <code>half</code> <code>bool</code> <code>False</code> use half precision (FP16) <code>device</code> <code>None or str</code> <code>None</code> device to run on, i.e. cuda device=0/1/2/3 or device=cpu <code>max_det</code> <code>int</code> <code>300</code> maximum number of detections per image <code>vid_stride</code> <code>bool</code> <code>False</code> video frame-rate stride <code>stream_buffer</code> <code>bool</code> <code>False</code> buffer all streaming frames (True) or return the most recent frame (False) <code>visualize</code> <code>bool</code> <code>False</code> visualize model features <code>augment</code> <code>bool</code> <code>False</code> apply image augmentation to prediction sources <code>agnostic_nms</code> <code>bool</code> <code>False</code> class-agnostic NMS <code>classes</code> <code>list[int]</code> <code>None</code> filter results by class, i.e. classes=0, or classes=[0,2,3] <code>retina_masks</code> <code>bool</code> <code>False</code> use high-resolution segmentation masks <code>embed</code> <code>list[int]</code> <code>None</code> return feature vectors/embeddings from given layers"},{"location":"guides/yolo-common-issues/","title":"Troubleshooting Common YOLO Issues","text":""},{"location":"guides/yolo-common-issues/#introduction","title":"Introduction","text":"<p>This guide serves as a comprehensive aid for troubleshooting common issues encountered while working with YOLOv8 on your Ultralytics projects. Navigating through these issues can be a breeze with the right guidance, ensuring your projects remain on track without unnecessary delays.</p>"},{"location":"guides/yolo-common-issues/#common-issues","title":"Common Issues","text":""},{"location":"guides/yolo-common-issues/#installation-errors","title":"Installation Errors","text":"<p>Installation errors can arise due to various reasons, such as incompatible versions, missing dependencies, or incorrect environment setups. First, check to make sure you are doing the following:</p> <ul> <li> <p>You're using Python 3.8 or later as recommended.</p> </li> <li> <p>Ensure that you have the correct version of PyTorch (1.8 or later) installed.</p> </li> <li> <p>Consider using virtual environments to avoid conflicts.</p> </li> <li> <p>Follow the official installation guide step by step.</p> </li> </ul> <p>Additionally, here are some common installation issues users have encountered, along with their respective solutions:</p> <ul> <li> <p>Import Errors or Dependency Issues - If you're getting errors during the import of YOLOv8, or you're having issues related to dependencies, consider the following troubleshooting steps:</p> <ul> <li> <p>Fresh Installation: Sometimes, starting with a fresh installation can resolve unexpected issues. Especially with libraries like Ultralytics, where updates might introduce changes to the file tree structure or functionalities.</p> </li> <li> <p>Update Regularly: Ensure you're using the latest version of the library. Older versions might not be compatible with recent updates, leading to potential conflicts or issues.</p> </li> <li> <p>Check Dependencies: Verify that all required dependencies are correctly installed and are of the compatible versions.</p> </li> <li> <p>Review Changes: If you initially cloned or installed an older version, be aware that significant updates might affect the library's structure or functionalities. Always refer to the official documentation or changelogs to understand any major changes.</p> </li> <li> <p>Remember, keeping your libraries and dependencies up-to-date is crucial for a smooth and error-free experience.</p> </li> </ul> </li> <li> <p>Running YOLOv8 on GPU - If you're having trouble running YOLOv8 on GPU, consider the following troubleshooting steps:</p> <ul> <li> <p>Verify CUDA Compatibility and Installation: Ensure your GPU is CUDA compatible and that CUDA is correctly installed. Use the <code>nvidia-smi</code> command to check the status of your NVIDIA GPU and CUDA version.</p> </li> <li> <p>Check PyTorch and CUDA Integration: Ensure PyTorch can utilize CUDA by running <code>import torch; print(torch.cuda.is_available())</code> in a Python terminal. If it returns 'True', PyTorch is set up to use CUDA.</p> </li> <li> <p>Environment Activation: Ensure you're in the correct environment where all necessary packages are installed.</p> </li> <li> <p>Update Your Packages: Outdated packages might not be compatible with your GPU. Keep them updated.</p> </li> <li> <p>Program Configuration: Check if the program or code specifies GPU usage. In YOLOv8, this might be in the settings or configuration.</p> </li> </ul> </li> </ul>"},{"location":"guides/yolo-common-issues/#model-training-issues","title":"Model Training Issues","text":"<p>This section will address common issues faced while training and their respective explanations and solutions.</p>"},{"location":"guides/yolo-common-issues/#verification-of-configuration-settings","title":"Verification of Configuration Settings","text":"<p>Issue: You are unsure whether the configuration settings in the <code>.yaml</code> file are being applied correctly during model training.</p> <p>Solution: The configuration settings in the <code>.yaml</code> file should be applied when using the <code>model.train()</code> function. To ensure that these settings are correctly applied, follow these steps:</p> <ul> <li>Confirm that the path to your <code>.yaml</code> configuration file is correct.</li> <li>Make sure you pass the path to your <code>.yaml</code> file as the <code>data</code> argument when calling <code>model.train()</code>, as shown below:</li> </ul> <pre><code>model.train(data='/path/to/your/data.yaml', batch=4)\n</code></pre>"},{"location":"guides/yolo-common-issues/#accelerating-training-with-multiple-gpus","title":"Accelerating Training with Multiple GPUs","text":"<p>Issue: Training is slow on a single GPU, and you want to speed up the process using multiple GPUs.</p> <p>Solution: Increasing the batch size can accelerate training, but it's essential to consider GPU memory capacity. To speed up training with multiple GPUs, follow these steps:</p> <ul> <li> <p>Ensure that you have multiple GPUs available.</p> </li> <li> <p>Modify your .yaml configuration file to specify the number of GPUs to use, e.g., gpus: 4.</p> </li> <li> <p>Increase the batch size accordingly to fully utilize the multiple GPUs without exceeding memory limits.</p> </li> <li> <p>Modify your training command to utilize multiple GPUs:</p> </li> </ul> <pre><code># Adjust the batch size and other settings as needed to optimize training speed\nmodel.train(data='/path/to/your/data.yaml', batch=32, multi_scale=True)\n</code></pre>"},{"location":"guides/yolo-common-issues/#continuous-monitoring-parameters","title":"Continuous Monitoring Parameters","text":"<p>Issue: You want to know which parameters should be continuously monitored during training, apart from loss.</p> <p>Solution: While loss is a crucial metric to monitor, it's also essential to track other metrics for model performance optimization. Some key metrics to monitor during training include:</p> <ul> <li>Precision</li> <li>Recall</li> <li>Mean Average Precision (mAP)</li> </ul> <p>You can access these metrics from the training logs or by using tools like TensorBoard or wandb for visualization. Implementing early stopping based on these metrics can help you achieve better results.</p>"},{"location":"guides/yolo-common-issues/#tools-for-tracking-training-progress","title":"Tools for Tracking Training Progress","text":"<p>Issue: You are looking for recommendations on tools to track training progress.</p> <p>Solution: To track and visualize training progress, you can consider using the following tools:</p> <ul> <li>TensorBoard: TensorBoard is a popular choice for visualizing training metrics, including loss, accuracy, and more. You can integrate it with your YOLOv8 training process.</li> <li>Comet: Comet provides an extensive toolkit for experiment tracking and comparison. It allows you to track metrics, hyperparameters, and even model weights. Integration with YOLO models is also straightforward, providing you with a complete overview of your experiment cycle.</li> <li>Ultralytics HUB: Ultralytics HUB offers a specialized environment for tracking YOLO models, giving you a one-stop platform to manage metrics, datasets, and even collaborate with your team. Given its tailored focus on YOLO, it offers more customized tracking options.</li> </ul> <p>Each of these tools offers its own set of advantages, so you may want to consider the specific needs of your project when making a choice.</p>"},{"location":"guides/yolo-common-issues/#how-to-check-if-training-is-happening-on-the-gpu","title":"How to Check if Training is Happening on the GPU","text":"<p>Issue: The 'device' value in the training logs is 'null,' and you're unsure if training is happening on the GPU.</p> <p>Solution: The 'device' value being 'null' typically means that the training process is set to automatically use an available GPU, which is the default behavior. To ensure training occurs on a specific GPU, you can manually set the 'device' value to the GPU index (e.g., '0' for the first GPU) in your .yaml configuration file:</p> <pre><code>device: 0\n</code></pre> <p>This will explicitly assign the training process to the specified GPU. If you wish to train on the CPU, set 'device' to 'cpu'.</p> <p>Keep an eye on the 'runs' folder for logs and metrics to monitor training progress effectively.</p>"},{"location":"guides/yolo-common-issues/#key-considerations-for-effective-model-training","title":"Key Considerations for Effective Model Training","text":"<p>Here are some things to keep in mind, if you are facing issues related to model training.</p> <p>Dataset Format and Labels</p> <ul> <li> <p>Importance: The foundation of any machine learning model lies in the quality and format of the data it is trained on.</p> </li> <li> <p>Recommendation: Ensure that your custom dataset and its associated labels adhere to the expected format. It's crucial to verify that annotations are accurate and of high quality. Incorrect or subpar annotations can derail the model's learning process, leading to unpredictable outcomes.</p> </li> </ul> <p>Model Convergence</p> <ul> <li> <p>Importance: Achieving model convergence ensures that the model has sufficiently learned from the training data.</p> </li> <li> <p>Recommendation: When training a model 'from scratch', it's vital to ensure that the model reaches a satisfactory level of convergence. This might necessitate a longer training duration, with more epochs, compared to when you're fine-tuning an existing model.</p> </li> </ul> <p>Learning Rate and Batch Size</p> <ul> <li> <p>Importance: These hyperparameters play a pivotal role in determining how the model updates its weights during training.</p> </li> <li> <p>Recommendation: Regularly evaluate if the chosen learning rate and batch size are optimal for your specific dataset. Parameters that are not in harmony with the dataset's characteristics can hinder the model's performance.</p> </li> </ul> <p>Class Distribution</p> <ul> <li> <p>Importance: The distribution of classes in your dataset can influence the model's prediction tendencies.</p> </li> <li> <p>Recommendation: Regularly assess the distribution of classes within your dataset. If there's a class imbalance, there's a risk that the model will develop a bias towards the more prevalent class. This bias can be evident in the confusion matrix, where the model might predominantly predict the majority class.</p> </li> </ul> <p>Cross-Check with Pretrained Weights</p> <ul> <li> <p>Importance: Leveraging pretrained weights can provide a solid starting point for model training, especially when data is limited.</p> </li> <li> <p>Recommendation: As a diagnostic step, consider training your model using the same data but initializing it with pretrained weights. If this approach yields a well-formed confusion matrix, it could suggest that the 'from scratch' model might require further training or adjustments.</p> </li> </ul>"},{"location":"guides/yolo-common-issues/#issues-related-to-model-predictions","title":"Issues Related to Model Predictions","text":"<p>This section will address common issues faced during model prediction.</p>"},{"location":"guides/yolo-common-issues/#getting-bounding-box-predictions-with-your-yolov8-custom-model","title":"Getting Bounding Box Predictions With Your YOLOv8 Custom Model","text":"<p>Issue: When running predictions with a custom YOLOv8 model, there are challenges with the format and visualization of the bounding box coordinates.</p> <p>Solution:</p> <ul> <li>Coordinate Format: YOLOv8 provides bounding box coordinates in absolute pixel values. To convert these to relative coordinates (ranging from 0 to 1), you need to divide by the image dimensions. For example, let\u2019s say your image size is 640x640. Then you would do the following:</li> </ul> <pre><code># Convert absolute coordinates to relative coordinates\nx1 = x1 / 640  # Divide x-coordinates by image width\nx2 = x2 / 640\ny1 = y1 / 640  # Divide y-coordinates by image height\ny2 = y2 / 640\n</code></pre> <ul> <li>File Name: To obtain the file name of the image you're predicting on, access the image file path directly from the result object within your prediction loop.</li> </ul>"},{"location":"guides/yolo-common-issues/#filtering-objects-in-yolov8-predictions","title":"Filtering Objects in YOLOv8 Predictions","text":"<p>Issue: Facing issues with how to filter and display only specific objects in the prediction results when running YOLOv8 using the Ultralytics library.</p> <p>Solution: To detect specific classes use the classes argument to specify the classes you want to include in the output. For instance, to detect only cars (assuming 'cars' have class index 2):</p> <pre><code>yolo task=detect mode=segment model=yolov8n-seg.pt source='path/to/car.mp4' show=True classes=2\n</code></pre>"},{"location":"guides/yolo-common-issues/#understanding-precision-metrics-in-yolov8","title":"Understanding Precision Metrics in YOLOv8","text":"<p>Issue: Confusion regarding the difference between box precision, mask precision, and confusion matrix precision in YOLOv8.</p> <p>Solution: Box precision measures the accuracy of predicted bounding boxes compared to the actual ground truth boxes using IoU (Intersection over Union) as the metric. Mask precision assesses the agreement between predicted segmentation masks and ground truth masks in pixel-wise object classification. Confusion matrix precision, on the other hand, focuses on overall classification accuracy across all classes and does not consider the geometric accuracy of predictions. It's important to note that a bounding box can be geometrically accurate (true positive) even if the class prediction is wrong, leading to differences between box precision and confusion matrix precision. These metrics evaluate distinct aspects of a model's performance, reflecting the need for different evaluation metrics in various tasks.</p>"},{"location":"guides/yolo-common-issues/#extracting-object-dimensions-in-yolov8","title":"Extracting Object Dimensions in YOLOv8","text":"<p>Issue: Difficulty in retrieving the length and height of detected objects in YOLOv8, especially when multiple objects are detected in an image.</p> <p>Solution: To retrieve the bounding box dimensions, first use the Ultralytics YOLOv8 model to predict objects in an image. Then, extract the width and height information of bounding boxes from the prediction results.</p> <pre><code>from ultralytics import YOLO\n\n# Load a pre-trained YOLOv8 model\nmodel = YOLO('yolov8n.pt')\n\n# Specify the source image\nsource = 'https://ultralytics.com/images/bus.jpg'\n\n# Make predictions\nresults = model.predict(source, save=True, imgsz=320, conf=0.5)\n\n# Extract bounding box dimensions\nboxes = results[0].boxes.xywh.cpu()\nfor box in boxes:\n    x, y, w, h = box\n    print(f\"Width of Box: {w}, Height of Box: {h}\")\n</code></pre>"},{"location":"guides/yolo-common-issues/#deployment-challenges","title":"Deployment Challenges","text":""},{"location":"guides/yolo-common-issues/#gpu-deployment-issues","title":"GPU Deployment Issues","text":"<p>Issue: Deploying models in a multi-GPU environment can sometimes lead to unexpected behaviors like unexpected memory usage, inconsistent results across GPUs, etc.</p> <p>Solution: Check for default GPU initialization. Some frameworks, like PyTorch, might initialize CUDA operations on a default GPU before transitioning to the designated GPUs. To bypass unexpected default initializations, specify the GPU directly during deployment and prediction. Then, use tools to monitor GPU utilization and memory usage to identify any anomalies in real-time. Also, ensure you're using the latest version of the framework or library.</p>"},{"location":"guides/yolo-common-issues/#model-conversionexporting-issues","title":"Model Conversion/Exporting Issues","text":"<p>Issue: During the process of converting or exporting machine learning models to different formats or platforms, users might encounter errors or unexpected behaviors.</p> <p>Solution:</p> <ul> <li> <p>Compatibility Check: Ensure that you are using versions of libraries and frameworks that are compatible with each other. Mismatched versions can lead to unexpected errors during conversion.</p> </li> <li> <p>Environment Reset: If you're using an interactive environment like Jupyter or Colab, consider restarting your environment after making significant changes or installations. A fresh start can sometimes resolve underlying issues.</p> </li> <li> <p>Official Documentation: Always refer to the official documentation of the tool or library you are using for conversion. It often contains specific guidelines and best practices for model exporting.</p> </li> <li> <p>Community Support: Check the library or framework's official repository for similar issues reported by other users. The maintainers or community might have provided solutions or workarounds in discussion threads.</p> </li> <li> <p>Update Regularly: Ensure that you are using the latest version of the tool or library. Developers frequently release updates that fix known bugs or improve functionality.</p> </li> <li> <p>Test Incrementally: Before performing a full conversion, test the process with a smaller model or dataset to identify potential issues early on.</p> </li> </ul>"},{"location":"guides/yolo-common-issues/#community-and-support","title":"Community and Support","text":"<p>Engaging with a community of like-minded individuals can significantly enhance your experience and success in working with YOLOv8. Below are some channels and resources you may find helpful.</p>"},{"location":"guides/yolo-common-issues/#forums-and-channels-for-getting-help","title":"Forums and Channels for Getting Help","text":"<p>GitHub Issues: The YOLOv8 repository on GitHub has an Issues tab where you can ask questions, report bugs, and suggest new features. The community and maintainers are active here, and it\u2019s a great place to get help with specific problems.</p> <p>Ultralytics Discord Server: Ultralytics has a Discord server where you can interact with other users and the developers.</p>"},{"location":"guides/yolo-common-issues/#official-documentation-and-resources","title":"Official Documentation and Resources","text":"<p>Ultralytics YOLOv8 Docs: The official documentation provides a comprehensive overview of YOLOv8, along with guides on installation, usage, and troubleshooting.</p> <p>These resources should provide a solid foundation for troubleshooting and improving your YOLOv8 projects, as well as connecting with others in the YOLOv8 community.</p>"},{"location":"guides/yolo-common-issues/#conclusion","title":"Conclusion","text":"<p>Troubleshooting is an integral part of any development process, and being equipped with the right knowledge can significantly reduce the time and effort spent in resolving issues. This guide aimed to address the most common challenges faced by users of the YOLOv8 model within the Ultralytics ecosystem. By understanding and addressing these common issues, you can ensure smoother project progress and achieve better results with your computer vision tasks.</p> <p>Remember, the Ultralytics community is a valuable resource. Engaging with fellow developers and experts can provide additional insights and solutions that might not be covered in standard documentation. Always keep learning, experimenting, and sharing your experiences to contribute to the collective knowledge of the community.</p> <p>Happy troubleshooting!</p>"},{"location":"guides/yolo-performance-metrics/","title":"Performance Metrics Deep Dive","text":""},{"location":"guides/yolo-performance-metrics/#introduction","title":"Introduction","text":"<p>Performance metrics are key tools to evaluate the accuracy and efficiency of object detection models. They shed light on how effectively a model can identify and localize objects within images. Additionally, they help in understanding the model's handling of false positives and false negatives. These insights are crucial for evaluating and enhancing the model's performance. In this guide, we will explore various performance metrics associated with YOLOv8, their significance, and how to interpret them.</p>"},{"location":"guides/yolo-performance-metrics/#object-detection-metrics","title":"Object Detection Metrics","text":"<p>Let\u2019s start by discussing some metrics that are not only important to YOLOv8 but are broadly applicable across different object detection models.</p> <ul> <li> <p>Intersection over Union (IoU): IoU is a measure that quantifies the overlap between a predicted bounding box and a ground truth bounding box. It plays a fundamental role in evaluating the accuracy of object localization.</p> </li> <li> <p>Average Precision (AP): AP computes the area under the precision-recall curve, providing a single value that encapsulates the model's precision and recall performance.</p> </li> <li> <p>Mean Average Precision (mAP): mAP extends the concept of AP by calculating the average AP values across multiple object classes. This is useful in multi-class object detection scenarios to provide a comprehensive evaluation of the model's performance.</p> </li> <li> <p>Precision and Recall: Precision quantifies the proportion of true positives among all positive predictions, assessing the model's capability to avoid false positives. On the other hand, Recall calculates the proportion of true positives among all actual positives, measuring the model's ability to detect all instances of a class.</p> </li> <li> <p>F1 Score: The F1 Score is the harmonic mean of precision and recall, providing a balanced assessment of a model's performance while considering both false positives and false negatives.</p> </li> </ul>"},{"location":"guides/yolo-performance-metrics/#how-to-calculate-metrics-for-yolov8-model","title":"How to Calculate Metrics for YOLOv8 Model","text":"<p>Now, we can explore YOLOv8's Validation mode that can be used to compute the above discussed evaluation metrics.</p> <p>Using the validation mode is simple. Once you have a trained model, you can invoke the model.val() function. This function will then process the validation dataset and return a variety of performance metrics. But what do these metrics mean? And how should you interpret them?</p>"},{"location":"guides/yolo-performance-metrics/#interpreting-the-output","title":"Interpreting the Output","text":"<p>Let's break down the output of the model.val() function and understand each segment of the output.</p>"},{"location":"guides/yolo-performance-metrics/#class-wise-metrics","title":"Class-wise Metrics","text":"<p>One of the sections of the output is the class-wise breakdown of performance metrics. This granular information is useful when you are trying to understand how well the model is doing for each specific class, especially in datasets with a diverse range of object categories. For each class in the dataset the following is provided:</p> <ul> <li> <p>Class: This denotes the name of the object class, such as \"person\", \"car\", or \"dog\".</p> </li> <li> <p>Images: This metric tells you the number of images in the validation set that contain the object class.</p> </li> <li> <p>Instances: This provides the count of how many times the class appears across all images in the validation set.</p> </li> <li> <p>Box(P, R, mAP50, mAP50-95): This metric provides insights into the model's performance in detecting objects:</p> <ul> <li> <p>P (Precision): The accuracy of the detected objects, indicating how many detections were correct.</p> </li> <li> <p>R (Recall): The ability of the model to identify all instances of objects in the images.</p> </li> <li> <p>mAP50: Mean average precision calculated at an intersection over union (IoU) threshold of 0.50. It's a measure of the model's accuracy considering only the \"easy\" detections.</p> </li> <li> <p>mAP50-95: The average of the mean average precision calculated at varying IoU thresholds, ranging from 0.50 to 0.95. It gives a comprehensive view of the model's performance across different levels of detection difficulty.</p> </li> </ul> </li> </ul>"},{"location":"guides/yolo-performance-metrics/#speed-metrics","title":"Speed Metrics","text":"<p>The speed of inference can be as critical as accuracy, especially in real-time object detection scenarios. This section breaks down the time taken for various stages of the validation process, from preprocessing to post-processing.</p>"},{"location":"guides/yolo-performance-metrics/#coco-metrics-evaluation","title":"COCO Metrics Evaluation","text":"<p>For users validating on the COCO dataset, additional metrics are calculated using the COCO evaluation script. These metrics give insights into precision and recall at different IoU thresholds and for objects of different sizes.</p>"},{"location":"guides/yolo-performance-metrics/#visual-outputs","title":"Visual Outputs","text":"<p>The model.val() function, apart from producing numeric metrics, also yields visual outputs that can provide a more intuitive understanding of the model's performance. Here's a breakdown of the visual outputs you can expect:</p> <ul> <li> <p>F1 Score Curve (<code>F1_curve.png</code>): This curve represents the F1 score across various thresholds. Interpreting this curve can offer insights into the model's balance between false positives and false negatives over different thresholds.</p> </li> <li> <p>Precision-Recall Curve (<code>PR_curve.png</code>): An integral visualization for any classification problem, this curve showcases the trade-offs between precision and recall at varied thresholds. It becomes especially significant when dealing with imbalanced classes.</p> </li> <li> <p>Precision Curve (<code>P_curve.png</code>): A graphical representation of precision values at different thresholds. This curve helps in understanding how precision varies as the threshold changes.</p> </li> <li> <p>Recall Curve (<code>R_curve.png</code>): Correspondingly, this graph illustrates how the recall values change across different thresholds.</p> </li> <li> <p>Confusion Matrix (<code>confusion_matrix.png</code>): The confusion matrix provides a detailed view of the outcomes, showcasing the counts of true positives, true negatives, false positives, and false negatives for each class.</p> </li> <li> <p>Normalized Confusion Matrix (<code>confusion_matrix_normalized.png</code>): This visualization is a normalized version of the confusion matrix. It represents the data in proportions rather than raw counts. This format makes it simpler to compare the performance across classes.</p> </li> <li> <p>Validation Batch Labels (<code>val_batchX_labels.jpg</code>): These images depict the ground truth labels for distinct batches from the validation dataset. They provide a clear picture of what the objects are and their respective locations as per the dataset.</p> </li> <li> <p>Validation Batch Predictions (<code>val_batchX_pred.jpg</code>): Contrasting the label images, these visuals display the predictions made by the YOLOv8 model for the respective batches. By comparing these to the label images, you can easily assess how well the model detects and classifies objects visually.</p> </li> </ul>"},{"location":"guides/yolo-performance-metrics/#results-storage","title":"Results Storage","text":"<p>For future reference, the results are saved to a directory, typically named runs/detect/val.</p>"},{"location":"guides/yolo-performance-metrics/#choosing-the-right-metrics","title":"Choosing the Right Metrics","text":"<p>Choosing the right metrics to evaluate often depends on the specific application.</p> <ul> <li> <p>mAP: Suitable for a broad assessment of model performance.</p> </li> <li> <p>IoU: Essential when precise object location is crucial.</p> </li> <li> <p>Precision: Important when minimizing false detections is a priority.</p> </li> <li> <p>Recall: Vital when it's important to detect every instance of an object.</p> </li> <li> <p>F1 Score: Useful when a balance between precision and recall is needed.</p> </li> </ul> <p>For real-time applications, speed metrics like FPS (Frames Per Second) and latency are crucial to ensure timely results.</p>"},{"location":"guides/yolo-performance-metrics/#interpretation-of-results","title":"Interpretation of Results","text":"<p>It\u2019s important to understand the metrics. Here's what some of the commonly observed lower scores might suggest:</p> <ul> <li> <p>Low mAP: Indicates the model may need general refinements.</p> </li> <li> <p>Low IoU: The model might be struggling to pinpoint objects accurately. Different bounding box methods could help.</p> </li> <li> <p>Low Precision: The model may be detecting too many non-existent objects. Adjusting confidence thresholds might reduce this.</p> </li> <li> <p>Low Recall: The model could be missing real objects. Improving feature extraction or using more data might help.</p> </li> <li> <p>Imbalanced F1 Score: There's a disparity between precision and recall.</p> </li> <li> <p>Class-specific AP: Low scores here can highlight classes the model struggles with.</p> </li> </ul>"},{"location":"guides/yolo-performance-metrics/#case-studies","title":"Case Studies","text":"<p>Real-world examples can help clarify how these metrics work in practice.</p>"},{"location":"guides/yolo-performance-metrics/#case-1","title":"Case 1","text":"<ul> <li> <p>Situation: mAP and F1 Score are suboptimal, but while Recall is good, Precision isn't.</p> </li> <li> <p>Interpretation &amp; Action: There might be too many incorrect detections. Tightening confidence thresholds could reduce these, though it might also slightly decrease recall.</p> </li> </ul>"},{"location":"guides/yolo-performance-metrics/#case-2","title":"Case 2","text":"<ul> <li> <p>Situation: mAP and Recall are acceptable, but IoU is lacking.</p> </li> <li> <p>Interpretation &amp; Action: The model detects objects well but might not be localizing them precisely. Refining bounding box predictions might help.</p> </li> </ul>"},{"location":"guides/yolo-performance-metrics/#case-3","title":"Case 3","text":"<ul> <li> <p>Situation: Some classes have a much lower AP than others, even with a decent overall mAP.</p> </li> <li> <p>Interpretation &amp; Action: These classes might be more challenging for the model. Using more data for these classes or adjusting class weights during training could be beneficial.</p> </li> </ul>"},{"location":"guides/yolo-performance-metrics/#connect-and-collaborate","title":"Connect and Collaborate","text":"<p>Tapping into a community of enthusiasts and experts can amplify your journey with YOLOv8. Here are some avenues that can facilitate learning, troubleshooting, and networking.</p>"},{"location":"guides/yolo-performance-metrics/#engage-with-the-broader-community","title":"Engage with the Broader Community","text":"<ul> <li> <p>GitHub Issues: The YOLOv8 repository on GitHub has an Issues tab where you can ask questions, report bugs, and suggest new features. The community and maintainers are active here, and it\u2019s a great place to get help with specific problems.</p> </li> <li> <p>Ultralytics Discord Server: Ultralytics has a Discord server where you can interact with other users and the developers.</p> </li> </ul>"},{"location":"guides/yolo-performance-metrics/#official-documentation-and-resources","title":"Official Documentation and Resources:","text":"<ul> <li>Ultralytics YOLOv8 Docs: The official documentation provides a comprehensive overview of YOLOv8, along with guides on installation, usage, and troubleshooting.</li> </ul> <p>Using these resources will not only guide you through any challenges but also keep you updated with the latest trends and best practices in the YOLOv8 community.</p>"},{"location":"guides/yolo-performance-metrics/#conclusion","title":"Conclusion","text":"<p>In this guide, we've taken a close look at the essential performance metrics for YOLOv8. These metrics are key to understanding how well a model is performing and are vital for anyone aiming to fine-tune their models. They offer the necessary insights for improvements and to make sure the model works effectively in real-life situations.</p> <p>Remember, the YOLOv8 and Ultralytics community is an invaluable asset. Engaging with fellow developers and experts can open doors to insights and solutions not found in standard documentation. As you journey through object detection, keep the spirit of learning alive, experiment with new strategies, and share your findings. By doing so, you contribute to the community's collective wisdom and ensure its growth.</p> <p>Happy object detecting!</p>"},{"location":"guides/yolo-thread-safe-inference/","title":"Thread-Safe Inference with YOLO Models","text":"<p>Running YOLO models in a multi-threaded environment requires careful consideration to ensure thread safety. Python's <code>threading</code> module allows you to run several threads concurrently, but when it comes to using YOLO models across these threads, there are important safety issues to be aware of. This page will guide you through creating thread-safe YOLO model inference.</p>"},{"location":"guides/yolo-thread-safe-inference/#understanding-python-threading","title":"Understanding Python Threading","text":"<p>Python threads are a form of parallelism that allow your program to run multiple operations at once. However, Python's Global Interpreter Lock (GIL) means that only one thread can execute Python bytecode at a time.</p> <p> </p> <p>While this sounds like a limitation, threads can still provide concurrency, especially for I/O-bound operations or when using operations that release the GIL, like those performed by YOLO's underlying C libraries.</p>"},{"location":"guides/yolo-thread-safe-inference/#the-danger-of-shared-model-instances","title":"The Danger of Shared Model Instances","text":"<p>Instantiating a YOLO model outside your threads and sharing this instance across multiple threads can lead to race conditions, where the internal state of the model is inconsistently modified due to concurrent accesses. This is particularly problematic when the model or its components hold state that is not designed to be thread-safe.</p>"},{"location":"guides/yolo-thread-safe-inference/#non-thread-safe-example-single-model-instance","title":"Non-Thread-Safe Example: Single Model Instance","text":"<p>When using threads in Python, it's important to recognize patterns that can lead to concurrency issues. Here is what you should avoid: sharing a single YOLO model instance across multiple threads.</p> <pre><code># Unsafe: Sharing a single model instance across threads\nfrom ultralytics import YOLO\nfrom threading import Thread\n\n# Instantiate the model outside the thread\nshared_model = YOLO(\"yolov8n.pt\")\n\n\ndef predict(image_path):\n    results = shared_model.predict(image_path)\n    # Process results\n\n\n# Starting threads that share the same model instance\nThread(target=predict, args=(\"image1.jpg\",)).start()\nThread(target=predict, args=(\"image2.jpg\",)).start()\n</code></pre> <p>In the example above, the <code>shared_model</code> is used by multiple threads, which can lead to unpredictable results because <code>predict</code> could be executed simultaneously by multiple threads.</p>"},{"location":"guides/yolo-thread-safe-inference/#non-thread-safe-example-multiple-model-instances","title":"Non-Thread-Safe Example: Multiple Model Instances","text":"<p>Similarly, here is an unsafe pattern with multiple YOLO model instances:</p> <pre><code># Unsafe: Sharing multiple model instances across threads can still lead to issues\nfrom ultralytics import YOLO\nfrom threading import Thread\n\n# Instantiate multiple models outside the thread\nshared_model_1 = YOLO(\"yolov8n_1.pt\")\nshared_model_2 = YOLO(\"yolov8n_2.pt\")\n\n\ndef predict(model, image_path):\n    results = model.predict(image_path)\n    # Process results\n\n\n# Starting threads with individual model instances\nThread(target=predict, args=(shared_model_1, \"image1.jpg\")).start()\nThread(target=predict, args=(shared_model_2, \"image2.jpg\")).start()\n</code></pre> <p>Even though there are two separate model instances, the risk of concurrency issues still exists. If the internal implementation of <code>YOLO</code> is not thread-safe, using separate instances might not prevent race conditions, especially if these instances share any underlying resources or states that are not thread-local.</p>"},{"location":"guides/yolo-thread-safe-inference/#thread-safe-inference","title":"Thread-Safe Inference","text":"<p>To perform thread-safe inference, you should instantiate a separate YOLO model within each thread. This ensures that each thread has its own isolated model instance, eliminating the risk of race conditions.</p>"},{"location":"guides/yolo-thread-safe-inference/#thread-safe-example","title":"Thread-Safe Example","text":"<p>Here's how to instantiate a YOLO model inside each thread for safe parallel inference:</p> <pre><code># Safe: Instantiating a single model inside each thread\nfrom ultralytics import YOLO\nfrom threading import Thread\n\n\ndef thread_safe_predict(image_path):\n    # Instantiate a new model inside the thread\n    local_model = YOLO(\"yolov8n.pt\")\n    results = local_model.predict(image_path)\n    # Process results\n\n\n# Starting threads that each have their own model instance\nThread(target=thread_safe_predict, args=(\"image1.jpg\",)).start()\nThread(target=thread_safe_predict, args=(\"image2.jpg\",)).start()\n</code></pre> <p>In this example, each thread creates its own <code>YOLO</code> instance. This prevents any thread from interfering with the model state of another, thus ensuring that each thread performs inference safely and without unexpected interactions with the other threads.</p>"},{"location":"guides/yolo-thread-safe-inference/#conclusion","title":"Conclusion","text":"<p>When using YOLO models with Python's <code>threading</code>, always instantiate your models within the thread that will use them to ensure thread safety. This practice avoids race conditions and makes sure that your inference tasks run reliably.</p> <p>For more advanced scenarios and to further optimize your multi-threaded inference performance, consider using process-based parallelism with <code>multiprocessing</code> or leveraging a task queue with dedicated worker processes.</p>"},{"location":"help/","title":"Help","text":"<p>Welcome to the Ultralytics Help page! We are dedicated to providing you with detailed resources to enhance your experience with the Ultralytics YOLO models and repositories. This page serves as your portal to guides and documentation designed to assist you with various tasks and answer questions you may encounter while engaging with our repositories.</p> <ul> <li>Frequently Asked Questions (FAQ): Find answers to common questions and issues encountered by the community of Ultralytics YOLO users and contributors.</li> <li>Contributing Guide: Discover the protocols for making contributions, including how to submit pull requests, report bugs, and more.</li> <li>Continuous Integration (CI) Guide: Gain insights into the CI processes we employ, complete with status reports for each Ultralytics repository.</li> <li>Contributor License Agreement (CLA): Review the CLA to understand the rights and responsibilities associated with contributing to Ultralytics projects.</li> <li>Minimum Reproducible Example (MRE) Guide: Learn the process for creating an MRE, which is crucial for the timely and effective resolution of bug reports.</li> <li>Code of Conduct: Our community guidelines support a respectful and open atmosphere for all collaborators.</li> <li>Environmental, Health and Safety (EHS) Policy: Delve into our commitment to sustainability and the well-being of all our stakeholders.</li> <li>Security Policy: Familiarize yourself with our security protocols and the procedure for reporting vulnerabilities.</li> <li>Privacy Policy: Read our privacy policy to understand how we protect your data and respect your privacy in all our services and operations.</li> </ul> <p>We encourage you to review these resources for a seamless and productive experience. Our aim is to foster a helpful and friendly environment for everyone in the Ultralytics community. Should you require additional support, please feel free to reach out via GitHub Issues or our official discussion forums. Happy coding!</p>"},{"location":"help/CI/","title":"Continuous Integration (CI)","text":"<p>Continuous Integration (CI) is an essential aspect of software development which involves integrating changes and testing them automatically. CI allows us to maintain high-quality code by catching issues early and often in the development process. At Ultralytics, we use various CI tests to ensure the quality and integrity of our codebase.</p>"},{"location":"help/CI/#ci-actions","title":"CI Actions","text":"<p>Here's a brief description of our CI actions:</p> <ul> <li>CI: This is our primary CI test that involves running unit tests, linting checks, and sometimes more comprehensive tests depending on the repository.</li> <li>Docker Deployment: This test checks the deployment of the project using Docker to ensure the Dockerfile and related scripts are working correctly.</li> <li>Broken Links: This test scans the codebase for any broken or dead links in our markdown or HTML files.</li> <li>CodeQL: CodeQL is a tool from GitHub that performs semantic analysis on our code, helping to find potential security vulnerabilities and maintain high-quality code.</li> <li>PyPi Publishing: This test checks if the project can be packaged and published to PyPi without any errors.</li> </ul>"},{"location":"help/CI/#ci-results","title":"CI Results","text":"<p>Below is the table showing the status of these CI tests for our main repositories:</p> Repository CI Docker Deployment Broken Links CodeQL PyPi and Docs Publishing yolov3 yolov5 ultralytics hub docs <p>Each badge shows the status of the last run of the corresponding CI test on the <code>main</code> branch of the respective repository. If a test fails, the badge will display a \"failing\" status, and if it passes, it will display a \"passing\" status.</p> <p>If you notice a test failing, it would be a great help if you could report it through a GitHub issue in the respective repository.</p> <p>Remember, a successful CI test does not mean that everything is perfect. It is always recommended to manually review the code before deployment or merging changes.</p>"},{"location":"help/CI/#code-coverage","title":"Code Coverage","text":"<p>Code coverage is a metric that represents the percentage of your codebase that is executed when your tests run. It provides insight into how well your tests exercise your code and can be crucial in identifying untested parts of your application. A high code coverage percentage is often associated with a lower likelihood of bugs. However, it's essential to understand that code coverage does not guarantee the absence of defects. It merely indicates which parts of the code have been executed by the tests.</p>"},{"location":"help/CI/#integration-with-codecovio","title":"Integration with codecov.io","text":"<p>At Ultralytics, we have integrated our repositories with codecov.io, a popular online platform for measuring and visualizing code coverage. Codecov provides detailed insights, coverage comparisons between commits, and visual overlays directly on your code, indicating which lines were covered.</p> <p>By integrating with Codecov, we aim to maintain and improve the quality of our code by focusing on areas that might be prone to errors or need further testing.</p>"},{"location":"help/CI/#coverage-results","title":"Coverage Results","text":"<p>To quickly get a glimpse of the code coverage status of the <code>ultralytics</code> python package, we have included a badge and sunburst visual of the <code>ultralytics</code> coverage results. These images show the percentage of code covered by our tests, offering an at-a-glance metric of our testing efforts. For full details please see https://codecov.io/github/ultralytics/ultralytics.</p> Repository Code Coverage ultralytics <p>In the sunburst graphic below, the innermost circle is the entire project, moving away from the center are folders then, finally, a single file. The size and color of each slice is representing the number of statements and the coverage, respectively.</p> <p> </p>"},{"location":"help/CLA/","title":"Ultralytics Individual Contributor License Agreement","text":"<p>Thank you for your interest in contributing to open source software projects (\u201cProjects\u201d) made available by Ultralytics Inc. (\u201cUltralytics\u201d). This Individual Contributor License Agreement (\u201cAgreement\u201d) sets out the terms governing any source code, object code, bug fixes, configuration changes, tools, specifications, documentation, data, materials, feedback, information or other works of authorship that you submit or have submitted, in any form and in any manner, to Ultralytics in respect of any Projects (collectively \u201cContributions\u201d). If you have any questions respecting this Agreement, please contact hello@ultralytics.com.</p> <p>You agree that the following terms apply to all of your past, present and future Contributions. Except for the licenses granted in this Agreement, you retain all of your right, title and interest in and to your Contributions.</p> <p>Copyright License. You hereby grant, and agree to grant, to Ultralytics a non-exclusive, perpetual, irrevocable, worldwide, fully-paid, royalty-free, transferable copyright license to reproduce, prepare derivative works of, publicly display, publicly perform, and distribute your Contributions and such derivative works, with the right to sublicense the foregoing rights through multiple tiers of sublicensees.</p> <p>Patent License. You hereby grant, and agree to grant, to Ultralytics a non-exclusive, perpetual, irrevocable, worldwide, fully-paid, royalty-free, transferable patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer your Contributions, where such license applies only to those patent claims licensable by you that are necessarily infringed by your Contributions alone or by combination of your Contributions with the Project to which such Contributions were submitted, with the right to sublicense the foregoing rights through multiple tiers of sublicensees.</p> <p>Moral Rights. To the fullest extent permitted under applicable law, you hereby waive, and agree not to assert, all of your \u201cmoral rights\u201d in or relating to your Contributions for the benefit of Ultralytics, its assigns, and their respective direct and indirect sublicensees.</p> <p>Third Party Content/Rights. If your Contribution includes or is based on any source code, object code, bug fixes, configuration changes, tools, specifications, documentation, data, materials, feedback, information or other works of authorship that were not authored by you (\u201cThird Party Content\u201d) or if you are aware of any third party intellectual property or proprietary rights associated with your Contribution (\u201cThird Party Rights\u201d), then you agree to include with the submission of your Contribution full details respecting such Third Party Content and Third Party Rights, including, without limitation, identification of which aspects of your Contribution contain Third Party Content or are associated with Third Party Rights, the owner/author of the Third Party Content and Third Party Rights, where you obtained the Third Party Content, and any applicable third party license terms or restrictions respecting the Third Party Content and Third Party Rights. For greater certainty, the foregoing obligations respecting the identification of Third Party Content and Third Party Rights do not apply to any portion of a Project that is incorporated into your Contribution to that same Project.</p> <p>Representations. You represent that, other than the Third Party Content and Third Party Rights identified by you in accordance with this Agreement, you are the sole author of your Contributions and are legally entitled to grant the foregoing licenses and waivers in respect of your Contributions. If your Contributions were created in the course of your employment with your past or present employer(s), you represent that such employer(s) has authorized you to make your Contributions on behalf of such employer(s) or such employer(s) has waived all of their right, title or interest in or to your Contributions.</p> <p>Disclaimer. To the fullest extent permitted under applicable law, your Contributions are provided on an \"asis\" basis, without any warranties or conditions, express or implied, including, without limitation, any implied warranties or conditions of non-infringement, merchantability or fitness for a particular purpose. You are not required to provide support for your Contributions, except to the extent you desire to provide support.</p> <p>No Obligation. You acknowledge that Ultralytics is under no obligation to use or incorporate your Contributions into any of the Projects. The decision to use or incorporate your Contributions into any of the Projects will be made at the sole discretion of Ultralytics or its authorized delegates.</p> <p>Disputes. This Agreement shall be governed by and construed in accordance with the laws of the State of New York, United States of America, without giving effect to its principles or rules regarding conflicts of laws, other than such principles directing application of New York law. The parties hereby submit to venue in, and jurisdiction of the courts located in New York, New York for purposes relating to this Agreement. In the event that any of the provisions of this Agreement shall be held by a court or other tribunal of competent jurisdiction to be unenforceable, the remaining portions hereof shall remain in full force and effect.</p> <p>Assignment. You agree that Ultralytics may assign this Agreement, and all of its rights, obligations and licenses hereunder.</p>"},{"location":"help/FAQ/","title":"Ultralytics YOLO Frequently Asked Questions (FAQ)","text":"<p>This FAQ section addresses some common questions and issues users might encounter while working with Ultralytics YOLO repositories.</p>"},{"location":"help/FAQ/#1-what-are-the-hardware-requirements-for-running-ultralytics-yolo","title":"1. What are the hardware requirements for running Ultralytics YOLO?","text":"<p>Ultralytics YOLO can be run on a variety of hardware configurations, including CPUs, GPUs, and even some edge devices. However, for optimal performance and faster training and inference, we recommend using a GPU with a minimum of 8GB of memory. NVIDIA GPUs with CUDA support are ideal for this purpose.</p>"},{"location":"help/FAQ/#2-how-do-i-fine-tune-a-pre-trained-yolo-model-on-my-custom-dataset","title":"2. How do I fine-tune a pre-trained YOLO model on my custom dataset?","text":"<p>To fine-tune a pre-trained YOLO model on your custom dataset, you'll need to create a dataset configuration file (YAML) that defines the dataset's properties, such as the path to the images, the number of classes, and class names. Next, you'll need to modify the model configuration file to match the number of classes in your dataset. Finally, use the <code>train.py</code> script to start the training process with your custom dataset and the pre-trained model. You can find a detailed guide on fine-tuning YOLO in the Ultralytics documentation.</p>"},{"location":"help/FAQ/#3-how-do-i-convert-a-yolo-model-to-onnx-or-tensorflow-format","title":"3. How do I convert a YOLO model to ONNX or TensorFlow format?","text":"<p>Ultralytics provides built-in support for converting YOLO models to ONNX format. You can use the <code>export.py</code> script to convert a saved model to ONNX format. If you need to convert the model to TensorFlow format, you can use the ONNX model as an intermediary and then use the ONNX-TensorFlow converter to convert the ONNX model to TensorFlow format.</p>"},{"location":"help/FAQ/#4-can-i-use-ultralytics-yolo-for-real-time-object-detection","title":"4. Can I use Ultralytics YOLO for real-time object detection?","text":"<p>Yes, Ultralytics YOLO is designed to be efficient and fast, making it suitable for real-time object detection tasks. The actual performance will depend on your hardware configuration and the complexity of the model. Using a GPU and optimizing the model for your specific use case can help achieve real-time performance.</p>"},{"location":"help/FAQ/#5-how-can-i-improve-the-accuracy-of-my-yolo-model","title":"5. How can I improve the accuracy of my YOLO model?","text":"<p>Improving the accuracy of a YOLO model may involve several strategies, such as:</p> <ul> <li>Fine-tuning the model on more annotated data</li> <li>Data augmentation to increase the variety of training samples</li> <li>Using a larger or more complex model architecture</li> <li>Adjusting the learning rate, batch size, and other hyperparameters</li> <li>Using techniques like transfer learning or knowledge distillation</li> </ul> <p>Remember that there's often a trade-off between accuracy and inference speed, so finding the right balance is crucial for your specific application.</p> <p>If you have any more questions or need assistance, don't hesitate to consult the Ultralytics documentation or reach out to the community through GitHub Issues or the official discussion forum.</p>"},{"location":"help/code_of_conduct/","title":"Ultralytics Contributor Covenant Code of Conduct","text":""},{"location":"help/code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socioeconomic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"help/code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"help/code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"help/code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"help/code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at hello@ultralytics.com. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"help/code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"help/code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"help/code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"help/code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"help/code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"help/code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"help/contributing/","title":"Contributing to Ultralytics Open-Source YOLO Repositories","text":"<p>First of all, thank you for your interest in contributing to Ultralytics open-source YOLO repositories! Your contributions will help improve the project and benefit the community. This document provides guidelines and best practices to get you started.</p>"},{"location":"help/contributing/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Code of Conduct</li> <li>Contributing via Pull Requests<ul> <li>CLA Signing</li> <li>Google-Style Docstrings</li> <li>GitHub Actions CI Tests</li> </ul> </li> <li>Reporting Bugs</li> <li>License</li> <li>Conclusion</li> </ol>"},{"location":"help/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>All contributors are expected to adhere to the Code of Conduct to ensure a welcoming and inclusive environment for everyone.</p>"},{"location":"help/contributing/#contributing-via-pull-requests","title":"Contributing via Pull Requests","text":"<p>We welcome contributions in the form of pull requests. To make the review process smoother, please follow these guidelines:</p> <ol> <li> <p>Fork the repository: Fork the Ultralytics YOLO repository to your own GitHub account.</p> </li> <li> <p>Create a branch: Create a new branch in your forked repository with a descriptive name for your changes.</p> </li> <li> <p>Make your changes: Make the changes you want to contribute. Ensure that your changes follow the coding style of the project and do not introduce new errors or warnings.</p> </li> <li> <p>Test your changes: Test your changes locally to ensure that they work as expected and do not introduce new issues.</p> </li> <li> <p>Commit your changes: Commit your changes with a descriptive commit message. Make sure to include any relevant issue numbers in your commit message.</p> </li> <li> <p>Create a pull request: Create a pull request from your forked repository to the main Ultralytics YOLO repository. In the pull request description, provide a clear explanation of your changes and how they improve the project.</p> </li> </ol>"},{"location":"help/contributing/#cla-signing","title":"CLA Signing","text":"<p>Before we can accept your pull request, you need to sign a Contributor License Agreement (CLA). This is a legal document stating that you agree to the terms of contributing to the Ultralytics YOLO repositories. The CLA ensures that your contributions are properly licensed and that the project can continue to be distributed under the AGPL-3.0 license.</p> <p>To sign the CLA, follow the instructions provided by the CLA bot after you submit your PR and add a comment in your PR saying:</p> <pre><code>I have read the CLA Document and I sign the CLA\n</code></pre>"},{"location":"help/contributing/#google-style-docstrings","title":"Google-Style Docstrings","text":"<p>When adding new functions or classes, please include a Google-style docstring to provide clear and concise documentation for other developers. This will help ensure that your contributions are easy to understand and maintain.</p> <p>Example Google-style docstring:</p> <pre><code>def example_function(arg1: int, arg2: int) -&gt; bool:\n    \"\"\"\n    Example function that demonstrates Google-style docstrings.\n\n    Args:\n        arg1 (int): The first argument.\n        arg2 (int): The second argument.\n\n    Returns:\n        (bool): True if successful, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; result = example_function(1, 2)  # returns False\n    \"\"\"\n    if arg1 == arg2:\n        return True\n    return False\n</code></pre>"},{"location":"help/contributing/#github-actions-ci-tests","title":"GitHub Actions CI Tests","text":"<p>Before your pull request can be merged, all GitHub Actions Continuous Integration (CI) tests must pass. These tests include linting, unit tests, and other checks to ensure that your changes meet the quality standards of the project. Make sure to review the output of the GitHub Actions and fix any issues</p>"},{"location":"help/contributing/#reporting-bugs","title":"Reporting Bugs","text":"<p>We appreciate bug reports as they play a crucial role in maintaining the project's quality. When reporting bugs it is important to provide a Minimum Reproducible Example: a clear, concise code example that replicates the issue. This helps in quick identification and resolution of the bug.</p>"},{"location":"help/contributing/#license","title":"License","text":"<p>Ultralytics embraces the GNU Affero General Public License v3.0 (AGPL-3.0) for its repositories, promoting openness, transparency, and collaborative enhancement in software development. This strong copyleft license ensures that all users and developers retain the freedom to use, modify, and share the software. It fosters community collaboration, ensuring that any improvements remain accessible to all.</p> <p>Users and developers are encouraged to familiarize themselves with the terms of AGPL-3.0 to contribute effectively and ethically to the Ultralytics open-source community.</p>"},{"location":"help/contributing/#conclusion","title":"Conclusion","text":"<p>Thank you for your interest in contributing to Ultralytics' open-source YOLO projects. Your participation is crucial in shaping the future of our software and fostering a community of innovation and collaboration. Whether you're improving code, reporting bugs, or suggesting features, your contributions make a significant impact.</p> <p>We're eager to see your ideas in action and appreciate your commitment to advancing object detection technology. Let's continue to grow and innovate together in this exciting open-source journey. Happy coding! \ud83d\ude80\ud83c\udf1f</p>"},{"location":"help/environmental-health-safety/","title":"Ultralytics Environmental, Health and Safety (EHS) Policy","text":"<p>At Ultralytics, we recognize that the long-term success of our company relies not only on the products and services we offer, but also the manner in which we conduct our business. We are committed to ensuring the safety and well-being of our employees, stakeholders, and the environment, and we will continuously strive to mitigate our impact on the environment while promoting health and safety.</p>"},{"location":"help/environmental-health-safety/#policy-principles","title":"Policy Principles","text":"<ol> <li> <p>Compliance: We will comply with all applicable laws, regulations, and standards related to EHS, and we will strive to exceed these standards where possible.</p> </li> <li> <p>Prevention: We will work to prevent accidents, injuries, and environmental harm by implementing risk management measures and ensuring all our operations and procedures are safe.</p> </li> <li> <p>Continuous Improvement: We will continuously improve our EHS performance by setting measurable objectives, monitoring our performance, auditing our operations, and revising our policies and procedures as needed.</p> </li> <li> <p>Communication: We will communicate openly about our EHS performance and will engage with stakeholders to understand and address their concerns and expectations.</p> </li> <li> <p>Education and Training: We will educate and train our employees and contractors in appropriate EHS procedures and practices.</p> </li> </ol>"},{"location":"help/environmental-health-safety/#implementation-measures","title":"Implementation Measures","text":"<ol> <li> <p>Responsibility and Accountability: Every employee and contractor working at or with Ultralytics is responsible for adhering to this policy. Managers and supervisors are accountable for ensuring this policy is implemented within their areas of control.</p> </li> <li> <p>Risk Management: We will identify, assess, and manage EHS risks associated with our operations and activities to prevent accidents, injuries, and environmental harm.</p> </li> <li> <p>Resource Allocation: We will allocate the necessary resources to ensure the effective implementation of our EHS policy, including the necessary equipment, personnel, and training.</p> </li> <li> <p>Emergency Preparedness and Response: We will develop, maintain, and test emergency preparedness and response plans to ensure we can respond effectively to EHS incidents.</p> </li> <li> <p>Monitoring and Review: We will monitor and review our EHS performance regularly to identify opportunities for improvement and ensure we are meeting our objectives.</p> </li> </ol> <p>This policy reflects our commitment to minimizing our environmental footprint, ensuring the safety and well-being of our employees, and continuously improving our performance.</p> <p>Please remember that the implementation of an effective EHS policy requires the involvement and commitment of everyone working at or with Ultralytics. We encourage you to take personal responsibility for your safety and the safety of others, and to take care of the environment in which we live and work.</p>"},{"location":"help/minimum_reproducible_example/","title":"Creating a Minimum Reproducible Example for Bug Reports in Ultralytics YOLO Repositories","text":"<p>When submitting a bug report for Ultralytics YOLO repositories, it's essential to provide a minimum reproducible example (MRE). An MRE is a small, self-contained piece of code that demonstrates the problem you're experiencing. Providing an MRE helps maintainers and contributors understand the issue and work on a fix more efficiently. This guide explains how to create an MRE when submitting bug reports to Ultralytics YOLO repositories.</p>"},{"location":"help/minimum_reproducible_example/#1-isolate-the-problem","title":"1. Isolate the Problem","text":"<p>The first step in creating an MRE is to isolate the problem. This means removing any unnecessary code or dependencies that are not directly related to the issue. Focus on the specific part of the code that is causing the problem and remove any irrelevant code.</p>"},{"location":"help/minimum_reproducible_example/#2-use-public-models-and-datasets","title":"2. Use Public Models and Datasets","text":"<p>When creating an MRE, use publicly available models and datasets to reproduce the issue. For example, use the 'yolov8n.pt' model and the 'coco8.yaml' dataset. This ensures that the maintainers and contributors can easily run your example and investigate the problem without needing access to proprietary data or custom models.</p>"},{"location":"help/minimum_reproducible_example/#3-include-all-necessary-dependencies","title":"3. Include All Necessary Dependencies","text":"<p>Make sure to include all the necessary dependencies in your MRE. If your code relies on external libraries, specify the required packages and their versions. Ideally, provide a <code>requirements.txt</code> file or list the dependencies in your bug report.</p>"},{"location":"help/minimum_reproducible_example/#4-write-a-clear-description-of-the-issue","title":"4. Write a Clear Description of the Issue","text":"<p>Provide a clear and concise description of the issue you're experiencing. Explain the expected behavior and the actual behavior you're encountering. If applicable, include any relevant error messages or logs.</p>"},{"location":"help/minimum_reproducible_example/#5-format-your-code-properly","title":"5. Format Your Code Properly","text":"<p>When submitting an MRE, format your code properly using code blocks in the issue description. This makes it easier for others to read and understand your code. In GitHub, you can create a code block by wrapping your code with triple backticks (```) and specifying the language:</p> <pre>\n<pre><code># Your Python code goes here\n</code></pre>\n</pre>"},{"location":"help/minimum_reproducible_example/#6-test-your-mre","title":"6. Test Your MRE","text":"<p>Before submitting your MRE, test it to ensure that it accurately reproduces the issue. Make sure that others can run your example without any issues or modifications.</p>"},{"location":"help/minimum_reproducible_example/#example-of-an-mre","title":"Example of an MRE","text":"<p>Here's an example of an MRE for a hypothetical bug report:</p> <p>Bug description:</p> <p>When running the <code>detect.py</code> script on the sample image from the 'coco8.yaml' dataset, I get an error related to the dimensions of the input tensor.</p> <p>MRE:</p> <pre><code>import torch\nfrom ultralytics import YOLO\n\n# Load the model\nmodel = YOLO(\"yolov8n.pt\")\n\n# Load a 0-channel image\nimage = torch.rand(1, 0, 640, 640)\n\n# Run the model\nresults = model(image)\n</code></pre> <p>Error message:</p> <pre><code>RuntimeError: Expected input[1, 0, 640, 640] to have 3 channels, but got 0 channels instead\n</code></pre> <p>Dependencies:</p> <ul> <li>torch==2.0.0</li> <li>ultralytics==8.0.90</li> </ul> <p>In this example, the MRE demonstrates the issue with a minimal amount of code, uses a public model ('yolov8n.pt'), includes all necessary dependencies, and provides a clear description of the problem along with the error message.</p> <p>By following these guidelines, you'll help the maintainers and contributors of Ultralytics YOLO repositories to understand and resolve your issue more efficiently.</p>"},{"location":"help/privacy/","title":"Data Collection for Ultralytics Python Package","text":""},{"location":"help/privacy/#overview","title":"Overview","text":"<p>Ultralytics is dedicated to the continuous enhancement of the user experience and the capabilities of our Python package, including the advanced YOLO models we develop. Our approach involves the gathering of anonymized usage statistics and crash reports, helping us identify opportunities for improvement and ensuring the reliability of our software. This transparency document outlines what data we collect, its purpose, and the choice you have regarding this data collection.</p>"},{"location":"help/privacy/#anonymized-google-analytics","title":"Anonymized Google Analytics","text":"<p>Google Analytics is a web analytics service offered by Google that tracks and reports website traffic. It allows us to collect data about how our Python package is used, which is crucial for making informed decisions about design and functionality.</p>"},{"location":"help/privacy/#what-we-collect","title":"What We Collect","text":"<ul> <li>Usage Metrics: These metrics help us understand how frequently and in what ways the package is utilized, what features are favored, and the typical command-line arguments that are used.</li> <li>System Information: We collect general non-identifiable information about your computing environment to ensure our package performs well across various systems.</li> <li>Performance Data: Understanding the performance of our models during training, validation, and inference helps us in identifying optimization opportunities.</li> </ul> <p>For more information about Google Analytics and data privacy, visit Google Analytics Privacy.</p>"},{"location":"help/privacy/#how-we-use-this-data","title":"How We Use This Data","text":"<ul> <li>Feature Improvement: Insights from usage metrics guide us in enhancing user satisfaction and interface design.</li> <li>Optimization: Performance data assist us in fine-tuning our models for better efficiency and speed across diverse hardware and software configurations.</li> <li>Trend Analysis: By studying usage trends, we can predict and respond to the evolving needs of our community.</li> </ul>"},{"location":"help/privacy/#privacy-considerations","title":"Privacy Considerations","text":"<p>We take several measures to ensure the privacy and security of the data you entrust to us:</p> <ul> <li>Anonymization: We configure Google Analytics to anonymize the data collected, which means no personally identifiable information (PII) is gathered. You can use our services with the assurance that your personal details remain private.</li> <li>Aggregation: Data is analyzed only in aggregate form. This practice ensures that patterns can be observed without revealing any individual user's activity.</li> <li>No Image Data Collection: Ultralytics does not collect, process, or view any training or inference images.</li> </ul>"},{"location":"help/privacy/#sentry-crash-reporting","title":"Sentry Crash Reporting","text":"<p>Sentry is a developer-centric error tracking software that aids in identifying, diagnosing, and resolving issues in real-time, ensuring the robustness and reliability of applications. Within our package, it plays a crucial role by providing insights through crash reporting, significantly contributing to the stability and ongoing refinement of our software.</p> <p>Note</p> <p>Crash reporting via Sentry is activated only if the <code>sentry-sdk</code> Python package is pre-installed on your system. This package isn't included in the <code>ultralytics</code> prerequisites and won't be installed automatically by Ultralytics.</p>"},{"location":"help/privacy/#what-we-collect_1","title":"What We Collect","text":"<p>If the <code>sentry-sdk</code> Python package is pre-installed on your system a crash event may send the following information:</p> <ul> <li>Crash Logs: Detailed reports on the application's condition at the time of a crash, which are vital for our debugging efforts.</li> <li>Error Messages: We record error messages generated during the operation of our package to understand and resolve potential issues quickly.</li> </ul> <p>To learn more about how Sentry handles data, please visit Sentry's Privacy Policy.</p>"},{"location":"help/privacy/#how-we-use-this-data_1","title":"How We Use This Data","text":"<ul> <li>Debugging: Analyzing crash logs and error messages enables us to swiftly identify and correct software bugs.</li> <li>Stability Metrics: By constantly monitoring for crashes, we aim to improve the stability and reliability of our package.</li> </ul>"},{"location":"help/privacy/#privacy-considerations_1","title":"Privacy Considerations","text":"<ul> <li>Sensitive Information: We ensure that crash logs are scrubbed of any personally identifiable or sensitive user data, safeguarding the confidentiality of your information.</li> <li>Controlled Collection: Our crash reporting mechanism is meticulously calibrated to gather only what is essential for troubleshooting while respecting user privacy.</li> </ul> <p>By detailing the tools used for data collection and offering additional background information with URLs to their respective privacy pages, users are provided with a comprehensive view of our practices, emphasizing transparency and respect for user privacy.</p>"},{"location":"help/privacy/#disabling-data-collection","title":"Disabling Data Collection","text":"<p>We believe in providing our users with full control over their data. By default, our package is configured to collect analytics and crash reports to help improve the experience for all users. However, we respect that some users may prefer to opt out of this data collection.</p> <p>To opt out of sending analytics and crash reports, you can simply set <code>sync=False</code> in your YOLO settings. This ensures that no data is transmitted from your machine to our analytics tools.</p>"},{"location":"help/privacy/#inspecting-settings","title":"Inspecting Settings","text":"<p>To gain insight into the current configuration of your settings, you can view them directly:</p> <p>View settings</p> PythonCLI <p>You can use Python to view your settings. Start by importing the <code>settings</code> object from the <code>ultralytics</code> module. Print and return settings using the following commands: <pre><code>from ultralytics import settings\n\n# View all settings\nprint(settings)\n\n# Return analytics and crash reporting setting\nvalue = settings['sync']\n</code></pre></p> <p>Alternatively, the command-line interface allows you to check your settings with a simple command: <pre><code>yolo settings\n</code></pre></p>"},{"location":"help/privacy/#modifying-settings","title":"Modifying Settings","text":"<p>Ultralytics allows users to easily modify their settings. Changes can be performed in the following ways:</p> <p>Update settings</p> PythonCLI <p>Within the Python environment, call the <code>update</code> method on the <code>settings</code> object to change your settings: <pre><code>from ultralytics import settings\n\n# Disable analytics and crash reporting\nsettings.update({'sync': False})\n\n# Reset settings to default values\nsettings.reset()\n</code></pre></p> <p>If you prefer using the command-line interface, the following commands will allow you to modify your settings: <pre><code># Disable analytics and crash reporting\nyolo settings sync=False\n\n# Reset settings to default values\nyolo settings reset\n</code></pre></p> <p>The <code>sync=False</code> setting will prevent any data from being sent to Google Analytics or Sentry. Your settings will be respected across all sessions using the Ultralytics package and saved to disk for future sessions.</p>"},{"location":"help/privacy/#commitment-to-privacy","title":"Commitment to Privacy","text":"<p>Ultralytics takes user privacy seriously. We design our data collection practices with the following principles:</p> <ul> <li>Transparency: We are open about the data we collect and how it is used.</li> <li>Control: We give users full control over their data.</li> <li>Security: We employ industry-standard security measures to protect the data we collect.</li> </ul>"},{"location":"help/privacy/#questions-or-concerns","title":"Questions or Concerns","text":"<p>If you have any questions or concerns about our data collection practices, please reach out to us via our contact form or via support@ultralytics.com. We are dedicated to ensuring our users feel informed and confident in their privacy when using our package.</p>"},{"location":"help/security/","title":"Ultralytics Security Policy","text":"<p>At Ultralytics, the security of our users' data and systems is of utmost importance. To ensure the safety and security of our open-source projects, we have implemented several measures to detect and prevent security vulnerabilities.</p>"},{"location":"help/security/#snyk-scanning","title":"Snyk Scanning","text":"<p>We utilize Snyk to conduct comprehensive security scans on Ultralytics repositories. Snyk's robust scanning capabilities extend beyond dependency checks; it also examines our code and Dockerfiles for various vulnerabilities. By identifying and addressing these issues proactively, we ensure a higher level of security and reliability for our users.</p> <p></p>"},{"location":"help/security/#github-codeql-scanning","title":"GitHub CodeQL Scanning","text":"<p>Our security strategy includes GitHub's CodeQL scanning. CodeQL delves deep into our codebase, identifying complex vulnerabilities like SQL injection and XSS by analyzing the code's semantic structure. This advanced level of analysis ensures early detection and resolution of potential security risks.</p> <p></p>"},{"location":"help/security/#github-dependabot-alerts","title":"GitHub Dependabot Alerts","text":"<p>Dependabot is integrated into our workflow to monitor dependencies for known vulnerabilities. When a vulnerability is identified in one of our dependencies, Dependabot alerts us, allowing for swift and informed remediation actions.</p>"},{"location":"help/security/#github-secret-scanning-alerts","title":"GitHub Secret Scanning Alerts","text":"<p>We employ GitHub secret scanning alerts to detect sensitive data, such as credentials and private keys, accidentally pushed to our repositories. This early detection mechanism helps prevent potential security breaches and data exposures.</p>"},{"location":"help/security/#private-vulnerability-reporting","title":"Private Vulnerability Reporting","text":"<p>We enable private vulnerability reporting, allowing users to discreetly report potential security issues. This approach facilitates responsible disclosure, ensuring vulnerabilities are handled securely and efficiently.</p> <p>If you suspect or discover a security vulnerability in any of our repositories, please let us know immediately. You can reach out to us directly via our contact form or via security@ultralytics.com. Our security team will investigate and respond as soon as possible.</p> <p>We appreciate your help in keeping all Ultralytics open-source projects secure and safe for everyone \ud83d\ude4f.</p>"},{"location":"hub/","title":"Ultralytics HUB","text":"<p>\ud83d\udc4b Hello from the Ultralytics Team! We've been working hard these last few months to launch Ultralytics HUB, a new web tool for training and deploying all your YOLOv5 and YOLOv8 \ud83d\ude80 models from one spot!</p>"},{"location":"hub/#introduction","title":"Introduction","text":"<p>HUB is designed to be user-friendly and intuitive, with a drag-and-drop interface that allows users to easily upload their data and train new models quickly. It offers a range of pre-trained models and templates to choose from, making it easy for users to get started with training their own models. Once a model is trained, it can be easily deployed and used for real-time object detection, instance segmentation and classification tasks.</p> <p> Watch: Train Your Custom YOLO Models In A Few Clicks with Ultralytics HUB. </p> <p>We hope that the resources here will help you get the most out of HUB. Please browse the HUB Docs for details, raise an issue on GitHub for support, and join our Discord community for questions and discussions!</p> <ul> <li>Quickstart. Start training and deploying YOLO models with HUB in seconds.</li> <li>Datasets: Preparing and Uploading. Learn how to prepare and upload your datasets to HUB in YOLO format.</li> <li>Projects: Creating and Managing. Group your models into projects for improved organization.</li> <li>Models: Training and Exporting. Train YOLOv5 and YOLOv8 models on your custom datasets and export them to various formats for deployment.</li> <li>Integrations: Options. Explore different integration options for your trained models, such as TensorFlow, ONNX, OpenVINO, CoreML, and PaddlePaddle.</li> <li>Ultralytics HUB App. Learn about the Ultralytics App for iOS and Android, which allows you to run models directly on your mobile device.<ul> <li>iOS. Learn about YOLO CoreML models accelerated on Apple's Neural Engine on iPhones and iPads.</li> <li>Android. Explore TFLite acceleration on mobile devices.</li> </ul> </li> <li>Inference API. Understand how to use the Inference API for running your trained models in the cloud to generate predictions.</li> </ul>"},{"location":"hub/datasets/","title":"HUB Datasets","text":"<p>Ultralytics HUB datasets are a practical solution for managing and leveraging your custom datasets.</p> <p>Once uploaded, datasets can be immediately utilized for model training. This integrated approach facilitates a seamless transition from dataset management to model training, significantly simplifying the entire process.</p>"},{"location":"hub/datasets/#upload-dataset","title":"Upload Dataset","text":"<p>Ultralytics HUB datasets are just like YOLOv5 and YOLOv8 \ud83d\ude80 datasets. They use the same structure and the same label formats to keep everything simple.</p> <p>Before you upload a dataset to Ultralytics HUB, make sure to place your dataset YAML file inside the dataset root directory and that your dataset YAML, directory and ZIP have the same name, as shown in the example below, and then zip the dataset directory.</p> <p>For example, if your dataset is called \"coco8\", as our COCO8 example dataset, then you should have a <code>coco8.yaml</code> inside your <code>coco8/</code> directory, which will create a <code>coco8.zip</code> when zipped:</p> <pre><code>zip -r coco8.zip coco8\n</code></pre> <p>You can download our COCO8 example dataset and unzip it to see exactly how to structure your dataset.</p> <p> </p> <p>The dataset YAML is the same standard YOLOv5 and YOLOv8 YAML format.</p> <p>coco8.yaml</p> <pre><code># Ultralytics YOLO \ud83d\ude80, AGPL-3.0 license\n# COCO8 dataset (first 8 images from COCO train2017) by Ultralytics\n# Documentation: https://docs.ultralytics.com/datasets/detect/coco8/\n# Example usage: yolo train data=coco8.yaml\n# parent\n# \u251c\u2500\u2500 ultralytics\n# \u2514\u2500\u2500 datasets\n#     \u2514\u2500\u2500 coco8  \u2190 downloads here (1 MB)\n\n\n# Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]\npath: ../datasets/coco8  # dataset root dir\ntrain: images/train  # train images (relative to 'path') 4 images\nval: images/val  # val images (relative to 'path') 4 images\ntest:  # test images (optional)\n\n# Classes\nnames:\n  0: person\n  1: bicycle\n  2: car\n  3: motorcycle\n  4: airplane\n  5: bus\n  6: train\n  7: truck\n  8: boat\n  9: traffic light\n  10: fire hydrant\n  11: stop sign\n  12: parking meter\n  13: bench\n  14: bird\n  15: cat\n  16: dog\n  17: horse\n  18: sheep\n  19: cow\n  20: elephant\n  21: bear\n  22: zebra\n  23: giraffe\n  24: backpack\n  25: umbrella\n  26: handbag\n  27: tie\n  28: suitcase\n  29: frisbee\n  30: skis\n  31: snowboard\n  32: sports ball\n  33: kite\n  34: baseball bat\n  35: baseball glove\n  36: skateboard\n  37: surfboard\n  38: tennis racket\n  39: bottle\n  40: wine glass\n  41: cup\n  42: fork\n  43: knife\n  44: spoon\n  45: bowl\n  46: banana\n  47: apple\n  48: sandwich\n  49: orange\n  50: broccoli\n  51: carrot\n  52: hot dog\n  53: pizza\n  54: donut\n  55: cake\n  56: chair\n  57: couch\n  58: potted plant\n  59: bed\n  60: dining table\n  61: toilet\n  62: tv\n  63: laptop\n  64: mouse\n  65: remote\n  66: keyboard\n  67: cell phone\n  68: microwave\n  69: oven\n  70: toaster\n  71: sink\n  72: refrigerator\n  73: book\n  74: clock\n  75: vase\n  76: scissors\n  77: teddy bear\n  78: hair drier\n  79: toothbrush\n\n\n# Download script/URL (optional)\ndownload: https://ultralytics.com/assets/coco8.zip\n</code></pre> <p>After zipping your dataset, you should validate it before uploading it to Ultralytics HUB. Ultralytics HUB conducts the dataset validation check post-upload, so by ensuring your dataset is correctly formatted and error-free ahead of time, you can forestall any setbacks due to dataset rejection.</p> <pre><code>from ultralytics.hub import check_dataset\n\ncheck_dataset('path/to/coco8.zip')\n</code></pre> <p>Once your dataset ZIP is ready, navigate to the Datasets page by clicking on the Datasets button in the sidebar.</p> <p></p> Tip <p>You can also upload a dataset directly from the Home page.</p> <p></p> <p>Click on the Upload Dataset button on the top right of the page. This action will trigger the Upload Dataset dialog.</p> <p></p> <p>Upload your dataset in the Dataset .zip file field.</p> <p>You have the additional option to set a custom name and description for your Ultralytics HUB dataset.</p> <p>When you're happy with your dataset configuration, click Upload.</p> <p></p> <p>After your dataset is uploaded and processed, you will be able to access it from the Datasets page.</p> <p></p> <p>You can view the images in your dataset grouped by splits (Train, Validation, Test).</p> <p></p> Tip <p>Each image can be enlarged for better visualization.</p> <p></p> <p></p> <p>Also, you can analyze your dataset by click on the Overview tab.</p> <p></p> <p>Next, train a model on your dataset.</p> <p></p>"},{"location":"hub/datasets/#share-dataset","title":"Share Dataset","text":"<p>Info</p> <p>Ultralytics HUB's sharing functionality provides a convenient way to share datasets with others. This feature is designed to accommodate both existing Ultralytics HUB users and those who have yet to create an account.</p> Note <p>You have control over the general access of your datasets.</p> <p>You can choose to set the general access to \"Private\", in which case, only you will have access to it. Alternatively, you can set the general access to \"Unlisted\" which grants viewing access to anyone who has the direct link to the dataset, regardless of whether they have an Ultralytics HUB account or not.</p> <p>Navigate to the Dataset page of the dataset you want to share, open the dataset actions dropdown and click on the Share option. This action will trigger the Share Dataset dialog.</p> <p></p> Tip <p>You can also share a dataset directly from the Datasets page.</p> <p></p> <p>Set the general access to \"Unlisted\" and click Save.</p> <p></p> <p>Now, anyone who has the direct link to your dataset can view it.</p> Tip <p>You can easily click on the dataset's link shown in the Share Dataset dialog to copy it.</p> <p></p>"},{"location":"hub/datasets/#edit-dataset","title":"Edit Dataset","text":"<p>Navigate to the Dataset page of the dataset you want to edit, open the dataset actions dropdown and click on the Edit option. This action will trigger the Update Dataset dialog.</p> <p></p> Tip <p>You can also edit a dataset directly from the Datasets page.</p> <p></p> <p>Apply the desired modifications to your dataset and then confirm the changes by clicking Save.</p> <p></p>"},{"location":"hub/datasets/#delete-dataset","title":"Delete Dataset","text":"<p>Navigate to the Dataset page of the dataset you want to delete, open the dataset actions dropdown and click on the Delete option. This action will delete the dataset.</p> <p></p> Tip <p>You can also delete a dataset directly from the Datasets page.</p> <p></p> Note <p>If you change your mind, you can restore the dataset from the Trash page.</p> <p></p>"},{"location":"hub/inference_api/","title":"YOLO Inference API","text":"<p>The YOLO Inference API allows you to access the YOLOv8 object detection capabilities via a RESTful API. This enables you to run object detection on images without the need to install and set up the YOLOv8 environment locally.</p> <p> Screenshot of the Inference API section in the trained model Preview tab.</p>"},{"location":"hub/inference_api/#api-url","title":"API URL","text":"<p>The API URL is the address used to access the YOLO Inference API. In this case, the base URL is:</p> <pre><code>https://api.ultralytics.com/v1/predict\n</code></pre>"},{"location":"hub/inference_api/#example-usage-in-python","title":"Example Usage in Python","text":"<p>To access the YOLO Inference API with the specified model and API key using Python, you can use the following code:</p> <pre><code>import requests\n\n# API URL, use actual MODEL_ID\nurl = f\"https://api.ultralytics.com/v1/predict/MODEL_ID\"\n\n# Headers, use actual API_KEY\nheaders = {\"x-api-key\": \"API_KEY\"}\n\n# Inference arguments (optional)\ndata = {\"size\": 640, \"confidence\": 0.25, \"iou\": 0.45}\n\n# Load image and send request\nwith open(\"path/to/image.jpg\", \"rb\") as image_file:\n    files = {\"image\": image_file}\n    response = requests.post(url, headers=headers, files=files, data=data)\n\nprint(response.json())\n</code></pre> <p>In this example, replace <code>API_KEY</code> with your actual API key, <code>MODEL_ID</code> with the desired model ID, and <code>path/to/image.jpg</code> with the path to the image you want to analyze.</p>"},{"location":"hub/inference_api/#example-usage-with-cli","title":"Example Usage with CLI","text":"<p>You can use the YOLO Inference API with the command-line interface (CLI) by utilizing the <code>curl</code> command. Replace <code>API_KEY</code> with your actual API key, <code>MODEL_ID</code> with the desired model ID, and <code>image.jpg</code> with the path to the image you want to analyze:</p> <pre><code>curl -X POST \"https://api.ultralytics.com/v1/predict/MODEL_ID\" \\\n    -H \"x-api-key: API_KEY\" \\\n    -F \"image=@/path/to/image.jpg\" \\\n    -F \"size=640\" \\\n    -F \"confidence=0.25\" \\\n    -F \"iou=0.45\"\n</code></pre>"},{"location":"hub/inference_api/#passing-arguments","title":"Passing Arguments","text":"<p>This command sends a POST request to the YOLO Inference API with the specified <code>MODEL_ID</code> in the URL and the <code>API_KEY</code> in the request <code>headers</code>, along with the image file specified by <code>@path/to/image.jpg</code>.</p> <p>Here's an example of passing the <code>size</code>, <code>confidence</code>, and <code>iou</code> arguments via the API URL using the <code>requests</code> library in Python:</p> <pre><code>import requests\n\n# API URL, use actual MODEL_ID\nurl = f\"https://api.ultralytics.com/v1/predict/MODEL_ID\"\n\n# Headers, use actual API_KEY\nheaders = {\"x-api-key\": \"API_KEY\"}\n\n# Inference arguments (optional)\ndata = {\"size\": 640, \"confidence\": 0.25, \"iou\": 0.45}\n\n# Load image and send request\nwith open(\"path/to/image.jpg\", \"rb\") as image_file:\n    files = {\"image\": image_file}\n    response = requests.post(url, headers=headers, files=files, data=data)\n\nprint(response.json())\n</code></pre> <p>In this example, the <code>data</code> dictionary contains the query arguments <code>size</code>, <code>confidence</code>, and <code>iou</code>, which tells the API to run inference at image size 640 with confidence and IoU thresholds of 0.25 and 0.45.</p> <p>This will send the query parameters along with the file in the POST request. See the table below for a full list of available inference arguments.</p> Inference Argument Default Type Notes <code>size</code> <code>640</code> <code>int</code> valid range is <code>32</code> - <code>1280</code> pixels <code>confidence</code> <code>0.25</code> <code>float</code> valid range is <code>0.01</code> - <code>1.0</code> <code>iou</code> <code>0.45</code> <code>float</code> valid range is <code>0.0</code> - <code>0.95</code> <code>url</code> <code>''</code> <code>str</code> optional image URL if not image file is passed <code>normalize</code> <code>False</code> <code>bool</code>"},{"location":"hub/inference_api/#return-json-format","title":"Return JSON format","text":"<p>The YOLO Inference API returns a JSON list with the detection results. The format of the JSON list will be the same as the one produced locally by the <code>results[0].tojson()</code> command.</p> <p>The JSON list contains information about the detected objects, their coordinates, classes, and confidence scores.</p>"},{"location":"hub/inference_api/#detect-model-format","title":"Detect Model Format","text":"<p>YOLO detection models, such as <code>yolov8n.pt</code>, can return JSON responses from local inference, CLI API inference, and Python API inference. All of these methods produce the same JSON response format.</p> <p>Detect Model JSON Response</p> LocalCLI APIPython APIJSON Response <pre><code>from ultralytics import YOLO\n\n# Load model\nmodel = YOLO('yolov8n.pt')\n\n# Run inference\nresults = model('image.jpg')\n\n# Print image.jpg results in JSON format\nprint(results[0].tojson())\n</code></pre> <pre><code>curl -X POST \"https://api.ultralytics.com/v1/predict/MODEL_ID\" \\\n    -H \"x-api-key: API_KEY\" \\\n    -F \"image=@/path/to/image.jpg\" \\\n    -F \"size=640\" \\\n    -F \"confidence=0.25\" \\\n    -F \"iou=0.45\"\n</code></pre> <pre><code>import requests\n\n# API URL, use actual MODEL_ID\nurl = f\"https://api.ultralytics.com/v1/predict/MODEL_ID\"\n\n# Headers, use actual API_KEY\nheaders = {\"x-api-key\": \"API_KEY\"}\n\n# Inference arguments (optional)\ndata = {\"size\": 640, \"confidence\": 0.25, \"iou\": 0.45}\n\n# Load image and send request\nwith open(\"path/to/image.jpg\", \"rb\") as image_file:\n    files = {\"image\": image_file}\n    response = requests.post(url, headers=headers, files=files, data=data)\n\nprint(response.json())\n</code></pre> <pre><code>{\n  \"success\": True,\n  \"message\": \"Inference complete.\",\n  \"data\": [\n    {\n      \"name\": \"person\",\n      \"class\": 0,\n      \"confidence\": 0.8359682559967041,\n      \"box\": {\n        \"x1\": 0.08974208831787109,\n        \"y1\": 0.27418340047200523,\n        \"x2\": 0.8706787109375,\n        \"y2\": 0.9887352837456598\n      }\n    },\n    {\n      \"name\": \"person\",\n      \"class\": 0,\n      \"confidence\": 0.8189555406570435,\n      \"box\": {\n        \"x1\": 0.5847355842590332,\n        \"y1\": 0.05813225640190972,\n        \"x2\": 0.8930277824401855,\n        \"y2\": 0.9903111775716146\n      }\n    },\n    {\n      \"name\": \"tie\",\n      \"class\": 27,\n      \"confidence\": 0.2909725308418274,\n      \"box\": {\n        \"x1\": 0.3433395862579346,\n        \"y1\": 0.6070465511745877,\n        \"x2\": 0.40964522361755373,\n        \"y2\": 0.9849439832899306\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"hub/inference_api/#segment-model-format","title":"Segment Model Format","text":"<p>YOLO segmentation models, such as <code>yolov8n-seg.pt</code>, can return JSON responses from local inference, CLI API inference, and Python API inference. All of these methods produce the same JSON response format.</p> <p>Segment Model JSON Response</p> LocalCLI APIPython APIJSON Response <pre><code>from ultralytics import YOLO\n\n# Load model\nmodel = YOLO('yolov8n-seg.pt')\n\n# Run inference\nresults = model('image.jpg')\n\n# Print image.jpg results in JSON format\nprint(results[0].tojson())\n</code></pre> <pre><code>curl -X POST \"https://api.ultralytics.com/v1/predict/MODEL_ID\" \\\n    -H \"x-api-key: API_KEY\" \\\n    -F \"image=@/path/to/image.jpg\" \\\n    -F \"size=640\" \\\n    -F \"confidence=0.25\" \\\n    -F \"iou=0.45\"\n</code></pre> <pre><code>import requests\n\n# API URL, use actual MODEL_ID\nurl = f\"https://api.ultralytics.com/v1/predict/MODEL_ID\"\n\n# Headers, use actual API_KEY\nheaders = {\"x-api-key\": \"API_KEY\"}\n\n# Inference arguments (optional)\ndata = {\"size\": 640, \"confidence\": 0.25, \"iou\": 0.45}\n\n# Load image and send request\nwith open(\"path/to/image.jpg\", \"rb\") as image_file:\n    files = {\"image\": image_file}\n    response = requests.post(url, headers=headers, files=files, data=data)\n\nprint(response.json())\n</code></pre> <p>Note <code>segments</code> <code>x</code> and <code>y</code> lengths may vary from one object to another. Larger or more complex objects may have more segment points. <pre><code>{\n  \"success\": True,\n  \"message\": \"Inference complete.\",\n  \"data\": [\n    {\n      \"name\": \"person\",\n      \"class\": 0,\n      \"confidence\": 0.856913149356842,\n      \"box\": {\n        \"x1\": 0.1064866065979004,\n        \"y1\": 0.2798851860894097,\n        \"x2\": 0.8738358497619629,\n        \"y2\": 0.9894873725043403\n      },\n      \"segments\": {\n        \"x\": [\n          0.421875,\n          0.4203124940395355,\n          0.41718751192092896\n          ...\n        ],\n        \"y\": [\n          0.2888889014720917,\n          0.2916666567325592,\n          0.2916666567325592\n          ...\n        ]\n      }\n    },\n    {\n      \"name\": \"person\",\n      \"class\": 0,\n      \"confidence\": 0.8512625694274902,\n      \"box\": {\n        \"x1\": 0.5757311820983887,\n        \"y1\": 0.053943040635850696,\n        \"x2\": 0.8960096359252929,\n        \"y2\": 0.985154045952691\n      },\n      \"segments\": {\n        \"x\": [\n          0.7515624761581421,\n          0.75,\n          0.7437499761581421\n          ...\n        ],\n        \"y\": [\n          0.0555555559694767,\n          0.05833333358168602,\n          0.05833333358168602\n          ...\n        ]\n      }\n    },\n    {\n      \"name\": \"tie\",\n      \"class\": 27,\n      \"confidence\": 0.6485961675643921,\n      \"box\": {\n        \"x1\": 0.33911995887756347,\n        \"y1\": 0.6057066175672743,\n        \"x2\": 0.4081430912017822,\n        \"y2\": 0.9916408962673611\n      },\n      \"segments\": {\n        \"x\": [\n          0.37187498807907104,\n          0.37031251192092896,\n          0.3687500059604645\n          ...\n        ],\n        \"y\": [\n          0.6111111044883728,\n          0.6138888597488403,\n          0.6138888597488403\n          ...\n        ]\n      }\n    }\n  ]\n}\n</code></pre></p>"},{"location":"hub/inference_api/#pose-model-format","title":"Pose Model Format","text":"<p>YOLO pose models, such as <code>yolov8n-pose.pt</code>, can return JSON responses from local inference, CLI API inference, and Python API inference. All of these methods produce the same JSON response format.</p> <p>Pose Model JSON Response</p> LocalCLI APIPython APIJSON Response <pre><code>from ultralytics import YOLO\n\n# Load model\nmodel = YOLO('yolov8n-seg.pt')\n\n# Run inference\nresults = model('image.jpg')\n\n# Print image.jpg results in JSON format\nprint(results[0].tojson())\n</code></pre> <pre><code>curl -X POST \"https://api.ultralytics.com/v1/predict/MODEL_ID\" \\\n    -H \"x-api-key: API_KEY\" \\\n    -F \"image=@/path/to/image.jpg\" \\\n    -F \"size=640\" \\\n    -F \"confidence=0.25\" \\\n    -F \"iou=0.45\"\n</code></pre> <pre><code>import requests\n\n# API URL, use actual MODEL_ID\nurl = f\"https://api.ultralytics.com/v1/predict/MODEL_ID\"\n\n# Headers, use actual API_KEY\nheaders = {\"x-api-key\": \"API_KEY\"}\n\n# Inference arguments (optional)\ndata = {\"size\": 640, \"confidence\": 0.25, \"iou\": 0.45}\n\n# Load image and send request\nwith open(\"path/to/image.jpg\", \"rb\") as image_file:\n    files = {\"image\": image_file}\n    response = requests.post(url, headers=headers, files=files, data=data)\n\nprint(response.json())\n</code></pre> <p>Note COCO-keypoints pretrained models will have 17 human keypoints. The <code>visible</code> part of the keypoints indicates whether a keypoint is visible or obscured. Obscured keypoints may be outside the image or may not be visible, i.e. a person's eyes facing away from the camera. <pre><code>{\n  \"success\": True,\n  \"message\": \"Inference complete.\",\n  \"data\": [\n    {\n      \"name\": \"person\",\n      \"class\": 0,\n      \"confidence\": 0.8439509868621826,\n      \"box\": {\n        \"x1\": 0.1125,\n        \"y1\": 0.28194444444444444,\n        \"x2\": 0.7953125,\n        \"y2\": 0.9902777777777778\n      },\n      \"keypoints\": {\n        \"x\": [\n          0.5058594942092896,\n          0.5103894472122192,\n          0.4920862317085266\n          ...\n        ],\n        \"y\": [\n          0.48964157700538635,\n          0.4643048942089081,\n          0.4465252459049225\n          ...\n        ],\n        \"visible\": [\n          0.8726999163627625,\n          0.653947651386261,\n          0.9130823612213135\n          ...\n        ]\n      }\n    },\n    {\n      \"name\": \"person\",\n      \"class\": 0,\n      \"confidence\": 0.7474289536476135,\n      \"box\": {\n        \"x1\": 0.58125,\n        \"y1\": 0.0625,\n        \"x2\": 0.8859375,\n        \"y2\": 0.9888888888888889\n      },\n      \"keypoints\": {\n        \"x\": [\n          0.778544008731842,\n          0.7976160049438477,\n          0.7530890107154846\n          ...\n        ],\n        \"y\": [\n          0.27595141530036926,\n          0.2378823608160019,\n          0.23644638061523438\n          ...\n        ],\n        \"visible\": [\n          0.8900790810585022,\n          0.789978563785553,\n          0.8974530100822449\n          ...\n        ]\n      }\n    }\n  ]\n}\n</code></pre></p>"},{"location":"hub/integrations/","title":"HUB Integrations","text":"<p>\ud83d\udea7 Under Construction \ud83d\udea7</p> <p>Welcome to the Integrations guide for Ultralytics HUB! We are in the process of expanding this section to provide you with comprehensive guidance on integrating your YOLOv5 and YOLOv8 models with various platforms and formats. Currently, Roboflow is our available dataset integration, with a wide range of export integrations for your trained models.</p> <p> Watch: Train Your Custom YOLO Models In A Few Clicks with Ultralytics HUB. </p>"},{"location":"hub/integrations/#available-integrations","title":"Available Integrations","text":""},{"location":"hub/integrations/#dataset-integrations","title":"Dataset Integrations","text":"<ul> <li>Roboflow: Seamlessly import your datasets for training.</li> </ul>"},{"location":"hub/integrations/#export-integrations","title":"Export Integrations","text":"Format <code>format</code> Argument Model Metadata Arguments PyTorch - <code>yolov8n.pt</code> \u2705 - TorchScript <code>torchscript</code> <code>yolov8n.torchscript</code> \u2705 <code>imgsz</code>, <code>optimize</code> ONNX <code>onnx</code> <code>yolov8n.onnx</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>dynamic</code>, <code>simplify</code>, <code>opset</code> OpenVINO <code>openvino</code> <code>yolov8n_openvino_model/</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code> TensorRT <code>engine</code> <code>yolov8n.engine</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>dynamic</code>, <code>simplify</code>, <code>workspace</code> CoreML <code>coreml</code> <code>yolov8n.mlpackage</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code>, <code>nms</code> TF SavedModel <code>saved_model</code> <code>yolov8n_saved_model/</code> \u2705 <code>imgsz</code>, <code>keras</code>, <code>int8</code> TF GraphDef <code>pb</code> <code>yolov8n.pb</code> \u274c <code>imgsz</code> TF Lite <code>tflite</code> <code>yolov8n.tflite</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code> TF Edge TPU <code>edgetpu</code> <code>yolov8n_edgetpu.tflite</code> \u2705 <code>imgsz</code> TF.js <code>tfjs</code> <code>yolov8n_web_model/</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code> PaddlePaddle <code>paddle</code> <code>yolov8n_paddle_model/</code> \u2705 <code>imgsz</code> NCNN <code>ncnn</code> <code>yolov8n_ncnn_model/</code> \u2705 <code>imgsz</code>, <code>half</code>"},{"location":"hub/integrations/#coming-soon","title":"Coming Soon","text":"<ul> <li>Additional Dataset Integrations</li> <li>Detailed Export Integration Guides</li> <li>Step-by-Step Tutorials for Each Integration</li> </ul>"},{"location":"hub/integrations/#need-immediate-assistance","title":"Need Immediate Assistance?","text":"<p>While we're in the process of creating detailed guides:</p> <ul> <li>Browse through other HUB Docs for detailed guides and tutorials.</li> <li>Raise an issue on our GitHub for technical support.</li> <li>Join our Discord Community for live discussions and community support.</li> </ul> <p>We appreciate your patience as we work to make this section comprehensive and user-friendly. Stay tuned for updates!</p>"},{"location":"hub/models/","title":"Ultralytics HUB Models","text":"<p>Ultralytics HUB models provide a streamlined solution for training vision AI models on your custom datasets.</p> <p>The process is user-friendly and efficient, involving a simple three-step creation and accelerated training powered by Ultralytics YOLOv8. During training, real-time updates on model metrics are available so that you can monitor each step of the progress. Once training is completed, you can preview your model and easily deploy it to real-world applications. Therefore, Ultralytics HUB offers a comprehensive yet straightforward system for model creation, training, evaluation, and deployment.</p>"},{"location":"hub/models/#train-model","title":"Train Model","text":"<p>Navigate to the Models page by clicking on the Models button in the sidebar.</p> <p></p> Tip <p>You can also train a model directly from the Home page.</p> <p></p> <p>Click on the Train Model button on the top right of the page. This action will trigger the Train Model dialog.</p> <p></p> <p>The Train Model dialog has three simple steps, explained below.</p>"},{"location":"hub/models/#1-dataset","title":"1. Dataset","text":"<p>In this step, you have to select the dataset you want to train your model on. After you selected a dataset, click Continue.</p> <p></p> Tip <p>You can skip this step if you train a model directly from the Dataset page.</p> <p></p>"},{"location":"hub/models/#2-model","title":"2. Model","text":"<p>In this step, you have to choose the project in which you want to create your model, the name of your model and your model's architecture.</p> Note <p>Ultralytics HUB will try to pre-select the project.</p> <p>If you opened the Train Model dialog as described above, Ultralytics HUB will pre-select the last project you used.</p> <p>If you opened the Train Model dialog from the Project page, Ultralytics HUB will pre-select the project you were inside of.</p> <p></p> <p>In case you don't have a project created yet, you can set the name of your project in this step and it will be created together with your model.</p> <p></p> <p>Info</p> <p>You can read more about the available YOLOv8 (and YOLOv5) architectures in our documentation.</p> <p>When you're happy with your model configuration, click Continue.</p> <p></p> Note <p>By default, your model will use a pre-trained model (trained on the COCO dataset) to reduce training time.</p> <p>You can change this behaviour by opening the Advanced Options accordion.</p>"},{"location":"hub/models/#3-train","title":"3. Train","text":"<p>In this step, you will start training you model.</p> <p>Ultralytics HUB offers three training options:</p> <ul> <li>Ultralytics Cloud (COMING SOON)</li> <li>Google Colab</li> <li>Bring your own agent</li> </ul> <p>In order to start training your model, follow the instructions presented in this step.</p> <p></p> Note <p>When you are on this step, before the training starts, you can change the default training configuration by opening the Advanced Options accordion.</p> <p></p> Note <p>When you are on this step, you have the option to close the Train Model dialog and start training your model from the Model page later.</p> <p></p> <p>To start training your model using Google Colab, simply follow the instructions shown above or on the Google Colab notebook.</p> <p> </p> <p>When the training starts, you can click Done and monitor the training progress on the Model page.</p> <p></p> <p></p> Note <p>In case the training stops and a checkpoint was saved, you can resume training your model from the Model page.</p> <p></p>"},{"location":"hub/models/#preview-model","title":"Preview Model","text":"<p>Ultralytics HUB offers a variety of ways to preview your trained model.</p> <p>You can preview your model if you click on the Preview tab and upload an image in the Test card.</p> <p></p> <p>You can also use our Ultralytics Cloud API to effortlessly run inference with your custom model.</p> <p></p> <p>Furthermore, you can preview your model in real-time directly on your iOS or Android mobile device by downloading our Ultralytics HUB Mobile Application.</p> <p></p>"},{"location":"hub/models/#deploy-model","title":"Deploy Model","text":"<p>You can export your model to 13 different formats, including ONNX, OpenVINO, CoreML, TensorFlow, Paddle and many others.</p> <p></p> Tip <p>You can customize the export options of each format if you open the export actions dropdown and click on the Advanced option.</p> <p></p>"},{"location":"hub/models/#share-model","title":"Share Model","text":"<p>Info</p> <p>Ultralytics HUB's sharing functionality provides a convenient way to share models with others. This feature is designed to accommodate both existing Ultralytics HUB users and those who have yet to create an account.</p> Note <p>You have control over the general access of your models.</p> <p>You can choose to set the general access to \"Private\", in which case, only you will have access to it. Alternatively, you can set the general access to \"Unlisted\" which grants viewing access to anyone who has the direct link to the model, regardless of whether they have an Ultralytics HUB account or not.</p> <p>Navigate to the Model page of the model you want to share, open the model actions dropdown and click on the Share option. This action will trigger the Share Model dialog.</p> <p></p> Tip <p>You can also share a model directly from the Models page or from the Project page of the project where your model is located.</p> <p></p> <p>Set the general access to \"Unlisted\" and click Save.</p> <p></p> <p>Now, anyone who has the direct link to your model can view it.</p> Tip <p>You can easily click on the model's link shown in the Share Model dialog to copy it.</p> <p></p>"},{"location":"hub/models/#edit-model","title":"Edit Model","text":"<p>Navigate to the Model page of the model you want to edit, open the model actions dropdown and click on the Edit option. This action will trigger the Update Model dialog.</p> <p></p> Tip <p>You can also edit a model directly from the Models page or from the Project page of the project where your model is located.</p> <p></p> <p>Apply the desired modifications to your model and then confirm the changes by clicking Save.</p> <p></p>"},{"location":"hub/models/#delete-model","title":"Delete Model","text":"<p>Navigate to the Model page of the model you want to delete, open the model actions dropdown and click on the Delete option. This action will delete the model.</p> <p></p> Tip <p>You can also delete a model directly from the Models page or from the Project page of the project where your model is located.</p> <p></p> Note <p>If you change your mind, you can restore the model from the Trash page.</p> <p></p>"},{"location":"hub/projects/","title":"Ultralytics HUB Projects","text":"<p>Ultralytics HUB projects provide an effective solution for consolidating and managing your models. If you are working with several models that perform similar tasks or have related purposes, Ultralytics HUB projects allow you to group these models together.</p> <p>This creates a unified and organized workspace that facilitates easier model management, comparison and development. Having similar models or various iterations together can facilitate rapid benchmarking, as you can compare their effectiveness. This can lead to faster, more insightful iterative development and refinement of your models.</p> <p> Watch: Train YOLOv8 Pose Model on Tiger-Pose Dataset Using Ultralytics HUB </p>"},{"location":"hub/projects/#create-project","title":"Create Project","text":"<p>Navigate to the Projects page by clicking on the Projects button in the sidebar.</p> <p></p> Tip <p>You can also create a project directly from the Home page.</p> <p></p> <p>Click on the Create Project button on the top right of the page. This action will trigger the Create Project dialog, opening up a suite of options for tailoring your project to your needs.</p> <p></p> <p>Type the name of your project in the Project name field or keep the default name and finalize the project creation with a single click.</p> <p>You have the additional option to enrich your project with a description and a unique image, enhancing its recognizability on the Projects page.</p> <p>When you're happy with your project configuration, click Create.</p> <p></p> <p>After your project is created, you will be able to access it from the Projects page.</p> <p></p> <p>Next, train a model inside your project.</p> <p></p>"},{"location":"hub/projects/#share-project","title":"Share Project","text":"<p>Info</p> <p>Ultralytics HUB's sharing functionality provides a convenient way to share projects with others. This feature is designed to accommodate both existing Ultralytics HUB users and those who have yet to create an account.</p> Note <p>You have control over the general access of your projects.</p> <p>You can choose to set the general access to \"Private\", in which case, only you will have access to it. Alternatively, you can set the general access to \"Unlisted\" which grants viewing access to anyone who has the direct link to the project, regardless of whether they have an Ultralytics HUB account or not.</p> <p>Navigate to the Project page of the project you want to share, open the project actions dropdown and click on the Share option. This action will trigger the Share Project dialog.</p> <p></p> Tip <p>You can also share a project directly from the Projects page.</p> <p></p> <p>Set the general access to \"Unlisted\" and click Save.</p> <p></p> <p>Warning</p> <p>When changing the general access of a project, the general access of the models inside the project will be changed as well.</p> <p>Now, anyone who has the direct link to your project can view it.</p> Tip <p>You can easily click on the project's link shown in the Share Project dialog to copy it.</p> <p></p>"},{"location":"hub/projects/#edit-project","title":"Edit Project","text":"<p>Navigate to the Project page of the project you want to edit, open the project actions dropdown and click on the Edit option. This action will trigger the Update Project dialog.</p> <p></p> Tip <p>You can also edit a project directly from the Projects page.</p> <p></p> <p>Apply the desired modifications to your project and then confirm the changes by clicking Save.</p> <p></p>"},{"location":"hub/projects/#delete-project","title":"Delete Project","text":"<p>Navigate to the Project page of the project you want to delete, open the project actions dropdown and click on the Delete option. This action will delete the project.</p> <p></p> Tip <p>You can also delete a project directly from the Projects page.</p> <p></p> <p>Warning</p> <p>When deleting a project, the models inside the project will be deleted as well.</p> Note <p>If you change your mind, you can restore the project from the Trash page.</p> <p></p>"},{"location":"hub/projects/#compare-models","title":"Compare Models","text":"<p>Navigate to the Project page of the project where the models you want to compare are located. To use the model comparison feature, click on the Charts tab.</p> <p></p> <p>This will display all the relevant charts. Each chart corresponds to a different metric and contains the performance of each model for that metric. The models are represented by different colors and you can hover over each data point to get more information.</p> <p></p> Tip <p>Each chart can be enlarged for better visualization.</p> <p></p> <p></p> Tip <p>You have the flexibility to customize your view by selectively hiding certain models. This feature allows you to concentrate on the models of interest.</p> <p></p>"},{"location":"hub/projects/#reorder-models","title":"Reorder Models","text":"Note <p>Ultralytics HUB's reordering functionality works only inside projects you own.</p> <p>Navigate to the Project page of the project where the models you want to reorder are located. Click on the designated reorder icon of the model you want to move and drag it to the desired location.</p> <p></p>"},{"location":"hub/projects/#transfer-models","title":"Transfer Models","text":"<p>Navigate to the Project page of the project where the model you want to mode is located, open the project actions dropdown and click on the Transfer option. This action will trigger the Transfer Model dialog.</p> <p></p> Tip <p>You can also transfer a model directly from the Models page.</p> <p></p> <p>Select the project you want to transfer the model to and click Save.</p> <p></p>"},{"location":"hub/quickstart/","title":"Quickstart Guide for Ultralytics HUB","text":"<p>\ud83d\udea7 Under Construction \ud83d\udea7</p> <p>Thank you for visiting the Quickstart guide for Ultralytics HUB! We're currently hard at work building out this page to provide you with step-by-step instructions on how to get up and running with HUB in no time.</p> <p> Watch: Train Your Custom YOLO Models In A Few Clicks with Ultralytics HUB. </p> <p>In the meantime, here's a brief overview of what you can expect from Ultralytics HUB:</p>"},{"location":"hub/quickstart/#what-is-ultralytics-hub","title":"What is Ultralytics HUB?","text":"<p>Ultralytics HUB is your one-stop solution for training and deploying YOLOv5 and YOLOv8 models. It's designed with user experience in mind, featuring a drag-and-drop interface to make uploading data and training new models a breeze. Whether you're a beginner or an experienced machine learning practitioner, HUB has a range of pre-trained models and templates to accelerate your projects.</p>"},{"location":"hub/quickstart/#key-features","title":"Key Features","text":"<ul> <li>User-Friendly Interface: Simply drag and drop your data to start training.</li> <li>Pre-Trained Models: Choose from a selection of pre-trained models to kick-start your projects.</li> <li>Real-Time Object Detection: Deploy trained models easily for real-time object detection, instance segmentation, and classification tasks.</li> </ul>"},{"location":"hub/quickstart/#coming-soon","title":"Coming Soon","text":"<ul> <li>Detailed Steps to Start Your First Project</li> <li>Guide on Preparing and Uploading Datasets</li> <li>Tutorial on Model Training and Exporting</li> <li>Integration Options and How-To's</li> <li>And much more!</li> </ul>"},{"location":"hub/quickstart/#need-help-now","title":"Need Help Now?","text":"<p>While we're polishing this page, feel free to:</p> <ul> <li>Browse through other HUB Docs for detailed guides and tutorials.</li> <li>Raise an issue on our GitHub for technical support.</li> <li>Join our Discord Community for live discussions and community support.</li> </ul> <p>Stay tuned! We'll be back soon with more detailed information to help you get the most out of Ultralytics HUB. Thank you for your patience and interest!</p>"},{"location":"hub/app/","title":"Ultralytics HUB App","text":"<p>Welcome to the Ultralytics HUB App! We are excited to introduce this powerful mobile app that allows you to run YOLOv5 and YOLOv8 models directly on your iOS and Android devices. With the HUB App, you can utilize hardware acceleration features like Apple's Neural Engine (ANE) or Android GPU and Neural Network API (NNAPI) delegates to achieve impressive performance on your mobile device.</p>"},{"location":"hub/app/#features","title":"Features","text":"<ul> <li>Run YOLOv5 and YOLOv8 models: Experience the power of YOLO models on your mobile device for real-time object detection and image recognition tasks.</li> <li>Hardware Acceleration: Benefit from Apple ANE on iOS devices or Android GPU and NNAPI delegates for optimized performance.</li> <li>Custom Model Training: Train custom models with the Ultralytics HUB platform and preview them live using the HUB App.</li> <li>Mobile Compatibility: The HUB App supports both iOS and Android devices, bringing the power of YOLO models to a wide range of users.</li> </ul>"},{"location":"hub/app/#app-documentation","title":"App Documentation","text":"<ul> <li>iOS: Learn about YOLO CoreML models accelerated on Apple's Neural Engine for iPhones and iPads.</li> <li>Android: Explore TFLite acceleration on Android mobile devices.</li> </ul> <p>Get started today by downloading the Ultralytics HUB App on your mobile device and unlock the potential of YOLOv5 and YOLOv8 models on-the-go. Don't forget to check out our comprehensive HUB Docs for more information on training, deploying, and using your custom models with the Ultralytics HUB platform.</p>"},{"location":"hub/app/android/","title":"Ultralytics Android App: Real-time Object Detection with YOLO Models","text":"<p>The Ultralytics Android App is a powerful tool that allows you to run YOLO models directly on your Android device for real-time object detection. This app utilizes TensorFlow Lite for model optimization and various hardware delegates for acceleration, enabling fast and efficient object detection.</p>"},{"location":"hub/app/android/#quantization-and-acceleration","title":"Quantization and Acceleration","text":"<p>To achieve real-time performance on your Android device, YOLO models are quantized to either FP16 or INT8 precision. Quantization is a process that reduces the numerical precision of the model's weights and biases, thus reducing the model's size and the amount of computation required. This results in faster inference times without significantly affecting the model's accuracy.</p>"},{"location":"hub/app/android/#fp16-quantization","title":"FP16 Quantization","text":"<p>FP16 (or half-precision) quantization converts the model's 32-bit floating-point numbers to 16-bit floating-point numbers. This reduces the model's size by half and speeds up the inference process, while maintaining a good balance between accuracy and performance.</p>"},{"location":"hub/app/android/#int8-quantization","title":"INT8 Quantization","text":"<p>INT8 (or 8-bit integer) quantization further reduces the model's size and computation requirements by converting its 32-bit floating-point numbers to 8-bit integers. This quantization method can result in a significant speedup, but it may lead to a slight reduction in mean average precision (mAP) due to the lower numerical precision.</p> <p>mAP Reduction in INT8 Models</p> <p>The reduced numerical precision in INT8 models can lead to some loss of information during the quantization process, which may result in a slight decrease in mAP. However, this trade-off is often acceptable considering the substantial performance gains offered by INT8 quantization.</p>"},{"location":"hub/app/android/#delegates-and-performance-variability","title":"Delegates and Performance Variability","text":"<p>Different delegates are available on Android devices to accelerate model inference. These delegates include CPU, GPU, Hexagon and NNAPI. The performance of these delegates varies depending on the device's hardware vendor, product line, and specific chipsets used in the device.</p> <ol> <li>CPU: The default option, with reasonable performance on most devices.</li> <li>GPU: Utilizes the device's GPU for faster inference. It can provide a significant performance boost on devices with powerful GPUs.</li> <li>Hexagon: Leverages Qualcomm's Hexagon DSP for faster and more efficient processing. This option is available on devices with Qualcomm Snapdragon processors.</li> <li>NNAPI: The Android Neural Networks API (NNAPI) serves as an abstraction layer for running ML models on Android devices. NNAPI can utilize various hardware accelerators, such as CPU, GPU, and dedicated AI chips (e.g., Google's Edge TPU, or the Pixel Neural Core).</li> </ol> <p>Here's a table showing the primary vendors, their product lines, popular devices, and supported delegates:</p> Vendor Product Lines Popular Devices Delegates Supported Qualcomm Snapdragon (e.g., 800 series) Samsung Galaxy S21, OnePlus 9, Google Pixel 6 CPU, GPU, Hexagon, NNAPI Samsung Exynos (e.g., Exynos 2100) Samsung Galaxy S21 (Global version) CPU, GPU, NNAPI MediaTek Dimensity (e.g., Dimensity 1200) Realme GT, Xiaomi Redmi Note CPU, GPU, NNAPI HiSilicon Kirin (e.g., Kirin 990) Huawei P40 Pro, Huawei Mate 30 Pro CPU, GPU, NNAPI NVIDIA Tegra (e.g., Tegra X1) NVIDIA Shield TV, Nintendo Switch CPU, GPU, NNAPI <p>Please note that the list of devices mentioned is not exhaustive and may vary depending on the specific chipsets and device models. Always test your models on your target devices to ensure compatibility and optimal performance.</p> <p>Keep in mind that the choice of delegate can affect performance and model compatibility. For example, some models may not work with certain delegates, or a delegate may not be available on a specific device. As such, it's essential to test your model and the chosen delegate on your target devices for the best results.</p>"},{"location":"hub/app/android/#getting-started-with-the-ultralytics-android-app","title":"Getting Started with the Ultralytics Android App","text":"<p>To get started with the Ultralytics Android App, follow these steps:</p> <ol> <li> <p>Download the Ultralytics App from the Google Play Store.</p> </li> <li> <p>Launch the app on your Android device and sign in with your Ultralytics account. If you don't have an account yet, create one here.</p> </li> <li> <p>Once signed in, you will see a list of your trained YOLO models. Select a model to use for object detection.</p> </li> <li> <p>Grant the app permission to access your device's camera.</p> </li> <li> <p>Point your device's camera at objects you want to detect. The app will display bounding boxes and class labels in real-time as it detects objects.</p> </li> <li> <p>Explore the app's settings to adjust the detection threshold, enable or disable specific object classes, and more.</p> </li> </ol> <p>With the Ultralytics Android App, you now have the power of real-time object detection using YOLO models right at your fingertips. Enjoy exploring the app's features and optimizing its settings to suit your specific use cases.</p>"},{"location":"hub/app/ios/","title":"Ultralytics iOS App: Real-time Object Detection with YOLO Models","text":"<p>The Ultralytics iOS App is a powerful tool that allows you to run YOLO models directly on your iPhone or iPad for real-time object detection. This app utilizes the Apple Neural Engine and Core ML for model optimization and acceleration, enabling fast and efficient object detection.</p>"},{"location":"hub/app/ios/#quantization-and-acceleration","title":"Quantization and Acceleration","text":"<p>To achieve real-time performance on your iOS device, YOLO models are quantized to either FP16 or INT8 precision. Quantization is a process that reduces the numerical precision of the model's weights and biases, thus reducing the model's size and the amount of computation required. This results in faster inference times without significantly affecting the model's accuracy.</p>"},{"location":"hub/app/ios/#fp16-quantization","title":"FP16 Quantization","text":"<p>FP16 (or half-precision) quantization converts the model's 32-bit floating-point numbers to 16-bit floating-point numbers. This reduces the model's size by half and speeds up the inference process, while maintaining a good balance between accuracy and performance.</p>"},{"location":"hub/app/ios/#int8-quantization","title":"INT8 Quantization","text":"<p>INT8 (or 8-bit integer) quantization further reduces the model's size and computation requirements by converting its 32-bit floating-point numbers to 8-bit integers. This quantization method can result in a significant speedup, but it may lead to a slight reduction in accuracy.</p>"},{"location":"hub/app/ios/#apple-neural-engine","title":"Apple Neural Engine","text":"<p>The Apple Neural Engine (ANE) is a dedicated hardware component integrated into Apple's A-series and M-series chips. It's designed to accelerate machine learning tasks, particularly for neural networks, allowing for faster and more efficient execution of your YOLO models.</p> <p>By combining quantized YOLO models with the Apple Neural Engine, the Ultralytics iOS App achieves real-time object detection on your iOS device without compromising on accuracy or performance.</p> Release Year iPhone Name Chipset Name Node Size ANE TOPs 2017 iPhone X A11 Bionic 10 nm 0.6 2018 iPhone XS A12 Bionic 7 nm 5 2019 iPhone 11 A13 Bionic 7 nm 6 2020 iPhone 12 A14 Bionic 5 nm 11 2021 iPhone 13 A15 Bionic 5 nm 15.8 2022 iPhone 14 A16 Bionic 4 nm 17.0 <p>Please note that this list only includes iPhone models from 2017 onwards, and the ANE TOPs values are approximate.</p>"},{"location":"hub/app/ios/#getting-started-with-the-ultralytics-ios-app","title":"Getting Started with the Ultralytics iOS App","text":"<p>To get started with the Ultralytics iOS App, follow these steps:</p> <ol> <li> <p>Download the Ultralytics App from the App Store.</p> </li> <li> <p>Launch the app on your iOS device and sign in with your Ultralytics account. If you don't have an account yet, create one here.</p> </li> <li> <p>Once signed in, you will see a list of your trained YOLO models. Select a model to use for object detection.</p> </li> <li> <p>Grant the app permission to access your device's camera.</p> </li> <li> <p>Point your device's camera at objects you want to detect. The app will display bounding boxes and class labels in real-time as it detects objects.</p> </li> <li> <p>Explore the app's settings to adjust the detection threshold, enable or disable specific object classes, and more.</p> </li> </ol> <p>With the Ultralytics iOS App, you can now leverage the power of YOLO models for real-time object detection on your iPhone or iPad, powered by the Apple Neural Engine and optimized with FP16 or INT8 quantization.</p>"},{"location":"integrations/","title":"Ultralytics Integrations","text":"<p>Welcome to the Ultralytics Integrations page! This page provides an overview of our partnerships with various tools and platforms, designed to streamline your machine learning workflows, enhance dataset management, simplify model training, and facilitate efficient deployment.</p> <p></p>"},{"location":"integrations/#datasets-integrations","title":"Datasets Integrations","text":"<ul> <li>Roboflow: Facilitate seamless dataset management for Ultralytics models, offering robust annotation, preprocessing, and augmentation capabilities.</li> </ul>"},{"location":"integrations/#training-integrations","title":"Training Integrations","text":"<ul> <li> <p>ClearML: Automate your Ultralytics ML workflows, monitor experiments, and foster team collaboration.</p> </li> <li> <p>Comet ML: Enhance your model development with Ultralytics by tracking, comparing, and optimizing your machine learning experiments.</p> </li> <li> <p>DVC: Implement version control for your Ultralytics machine learning projects, synchronizing data, code, and models effectively.</p> </li> <li> <p>MLFlow: Streamline the entire ML lifecycle of Ultralytics models, from experimentation and reproducibility to deployment.</p> </li> <li> <p>Ultralytics HUB: Access and contribute to a community of pre-trained Ultralytics models.</p> </li> <li> <p>Neptune: Maintain a comprehensive log of your ML experiments with Ultralytics in this metadata store designed for MLOps.</p> </li> <li> <p>Ray Tune: Optimize the hyperparameters of your Ultralytics models at any scale.</p> </li> <li> <p>TensorBoard: Visualize your Ultralytics ML workflows, monitor model metrics, and foster team collaboration.</p> </li> <li> <p>Weights &amp; Biases (W&amp;B): Monitor experiments, visualize metrics, and foster reproducibility and collaboration on Ultralytics projects.</p> </li> <li> <p>Amazon SageMaker: Leverage Amazon SageMaker to efficiently build, train, and deploy Ultralytics models, providing an all-in-one platform for the ML lifecycle.</p> </li> </ul>"},{"location":"integrations/#deployment-integrations","title":"Deployment Integrations","text":"<ul> <li> <p>Neural Magic: Leverage Quantization Aware Training (QAT) and pruning techniques to optimize Ultralytics models for superior performance and leaner size.</p> </li> <li> <p>OpenVino: OpenVINO is Intel's toolkit for optimizing and deploying computer vision models efficiently across various Intel hardware platforms.</p> </li> </ul>"},{"location":"integrations/#export-formats","title":"Export Formats","text":"<p>We also support a variety of model export formats for deployment in different environments. Here are the available formats:</p> Format <code>format</code> Argument Model Metadata Arguments PyTorch - <code>yolov8n.pt</code> \u2705 - TorchScript <code>torchscript</code> <code>yolov8n.torchscript</code> \u2705 <code>imgsz</code>, <code>optimize</code> ONNX <code>onnx</code> <code>yolov8n.onnx</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>dynamic</code>, <code>simplify</code>, <code>opset</code> OpenVINO <code>openvino</code> <code>yolov8n_openvino_model/</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code> TensorRT <code>engine</code> <code>yolov8n.engine</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>dynamic</code>, <code>simplify</code>, <code>workspace</code> CoreML <code>coreml</code> <code>yolov8n.mlpackage</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code>, <code>nms</code> TF SavedModel <code>saved_model</code> <code>yolov8n_saved_model/</code> \u2705 <code>imgsz</code>, <code>keras</code>, <code>int8</code> TF GraphDef <code>pb</code> <code>yolov8n.pb</code> \u274c <code>imgsz</code> TF Lite <code>tflite</code> <code>yolov8n.tflite</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code> TF Edge TPU <code>edgetpu</code> <code>yolov8n_edgetpu.tflite</code> \u2705 <code>imgsz</code> TF.js <code>tfjs</code> <code>yolov8n_web_model/</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code> PaddlePaddle <code>paddle</code> <code>yolov8n_paddle_model/</code> \u2705 <code>imgsz</code> NCNN <code>ncnn</code> <code>yolov8n_ncnn_model/</code> \u2705 <code>imgsz</code>, <code>half</code> <p>Explore the links to learn more about each integration and how to get the most out of them with Ultralytics.</p>"},{"location":"integrations/#contribute-to-our-integrations","title":"Contribute to Our Integrations","text":"<p>We're always excited to see how the community integrates Ultralytics YOLO with other technologies, tools, and platforms! If you have successfully integrated YOLO with a new system or have valuable insights to share, consider contributing to our Integrations Docs.</p> <p>By writing a guide or tutorial, you can help expand our documentation and provide real-world examples that benefit the community. It's an excellent way to contribute to the growing ecosystem around Ultralytics YOLO.</p> <p>To contribute, please check out our Contributing Guide for instructions on how to submit a Pull Request (PR) \ud83d\udee0\ufe0f. We eagerly await your contributions!</p> <p>Let's collaborate to make the Ultralytics YOLO ecosystem more expansive and feature-rich \ud83d\ude4f!</p>"},{"location":"integrations/amazon-sagemaker/","title":"A Guide to Deploying YOLOv8 on Amazon SageMaker Endpoints","text":"<p>Deploying advanced computer vision models like Ultralytics\u2019 YOLOv8 on Amazon SageMaker Endpoints opens up a wide range of possibilities for various machine learning applications. The key to effectively using these models lies in understanding their setup, configuration, and deployment processes. YOLOv8 becomes even more powerful when integrated seamlessly with Amazon SageMaker, a robust and scalable machine learning service by AWS.</p> <p>This guide will take you through the process of deploying YOLOv8 PyTorch models on Amazon SageMaker Endpoints step by step. You'll learn the essentials of preparing your AWS environment, configuring the model appropriately, and using tools like AWS CloudFormation and the AWS Cloud Development Kit (CDK) for deployment.</p>"},{"location":"integrations/amazon-sagemaker/#amazon-sagemaker","title":"Amazon SageMaker","text":"<p>Amazon SageMaker is a machine learning service from Amazon Web Services (AWS) that simplifies the process of building, training, and deploying machine learning models. It provides a broad range of tools for handling various aspects of machine learning workflows. This includes automated features for tuning models, options for training models at scale, and straightforward methods for deploying models into production. SageMaker supports popular machine learning frameworks, offering the flexibility needed for diverse projects. Its features also cover data labeling, workflow management, and performance analysis.</p>"},{"location":"integrations/amazon-sagemaker/#deploying-yolov8-on-amazon-sagemaker-endpoints","title":"Deploying YOLOv8 on Amazon SageMaker Endpoints","text":"<p>Deploying YOLOv8 on Amazon SageMaker lets you use its managed environment for real-time inference and take advantage of features like autoscaling. Take a look at the AWS architecture below.</p> <p> </p>"},{"location":"integrations/amazon-sagemaker/#step-1-setup-your-aws-environment","title":"Step 1: Setup Your AWS Environment","text":"<p>First, ensure you have the following prerequisites in place:</p> <ul> <li> <p>An AWS Account: If you don't already have one, sign up for an AWS account.</p> </li> <li> <p>Configured IAM Roles: You\u2019ll need an IAM role with the necessary permissions for Amazon SageMaker, AWS CloudFormation, and Amazon S3. This role should have policies that allow it to access these services.</p> </li> <li> <p>AWS CLI: If not already installed, download and install the AWS Command Line Interface (CLI) and configure it with your account details. Follow the AWS CLI instructions for installation.</p> </li> <li> <p>AWS CDK: If not already installed, install the AWS Cloud Development Kit (CDK), which will be used for scripting the deployment. Follow the AWS CDK instructions for installation.</p> </li> <li> <p>Adequate Service Quota: Confirm that you have sufficient quotas for two separate resources in Amazon SageMaker: one for ml.m5.4xlarge for endpoint usage and another for ml.m5.4xlarge for notebook instance usage. Each of these requires a minimum of one quota value. If your current quotas are below this requirement, it's important to request an increase for each. You can request a quota increase by following the detailed instructions in the AWS Service Quotas documentation.</p> </li> </ul>"},{"location":"integrations/amazon-sagemaker/#step-2-clone-the-yolov8-sagemaker-repository","title":"Step 2: Clone the YOLOv8 SageMaker Repository","text":"<p>The next step is to clone the specific AWS repository that contains the resources for deploying YOLOv8 on SageMaker. This repository, hosted on GitHub, includes the necessary CDK scripts and configuration files.</p> <ul> <li>Clone the GitHub Repository: Execute the following command in your terminal to clone the host-yolov8-on-sagemaker-endpoint repository:</li> </ul> <pre><code>git clone https://github.com/aws-samples/host-yolov8-on-sagemaker-endpoint.git\n</code></pre> <ul> <li>Navigate to the Cloned Directory: Change your directory to the cloned repository:</li> </ul> <pre><code>cd host-yolov8-on-sagemaker-endpoint/yolov8-pytorch-cdk\n</code></pre>"},{"location":"integrations/amazon-sagemaker/#step-3-set-up-the-cdk-environment","title":"Step 3: Set Up the CDK Environment","text":"<p>Now that you have the necessary code, set up your environment for deploying with AWS CDK.</p> <ul> <li>Create a Python Virtual Environment: This isolates your Python environment and dependencies. Run:</li> </ul> <pre><code>python3 -m venv .venv\n</code></pre> <ul> <li>Activate the Virtual Environment:</li> </ul> <pre><code>source .venv/bin/activate\n</code></pre> <ul> <li>Install Dependencies: Install the required Python dependencies for the project:</li> </ul> <pre><code>pip3 install -r requirements.txt\n</code></pre> <ul> <li>Upgrade AWS CDK Library: Ensure you have the latest version of the AWS CDK library:</li> </ul> <pre><code>pip install --upgrade aws-cdk-lib\n</code></pre>"},{"location":"integrations/amazon-sagemaker/#step-4-create-the-aws-cloudformation-stack","title":"Step 4: Create the AWS CloudFormation Stack","text":"<ul> <li>Synthesize the CDK Application: Generate the AWS CloudFormation template from your CDK code:</li> </ul> <pre><code>cdk synth\n</code></pre> <ul> <li>Bootstrap the CDK Application: Prepare your AWS environment for CDK deployment:</li> </ul> <pre><code>cdk bootstrap\n</code></pre> <ul> <li>Deploy the Stack: This will create the necessary AWS resources and deploy your model:</li> </ul> <pre><code>cdk deploy\n</code></pre>"},{"location":"integrations/amazon-sagemaker/#step-5-deploy-the-yolov8-model","title":"Step 5: Deploy the YOLOv8 Model","text":"<p>Before diving into the deployment instructions, be sure to check out the range of YOLOv8 models offered by Ultralytics. This will help you choose the most appropriate model for your project requirements.</p> <p>After creating the AWS CloudFormation Stack, the next step is to deploy YOLOv8.</p> <ul> <li> <p>Open the Notebook Instance: Go to the AWS Console and navigate to the Amazon SageMaker service. Select \"Notebook Instances\" from the dashboard, then locate the notebook instance that was created by your CDK deployment script. Open the notebook instance to access the Jupyter environment.</p> </li> <li> <p>Access and Modify inference.py: After opening the SageMaker notebook instance in Jupyter, locate the inference.py file. Edit the output_fn function in inference.py as shown below and save your changes to the script, ensuring that there are no syntax errors.</p> </li> </ul> <pre><code>def output_fn(prediction_output, content_type):\n    print(\"Executing output_fn from inference.py ...\")\n    infer = {}\n    for result in prediction_output:\n        if 'boxes' in result._keys and result.boxes is not None:\n            infer['boxes'] = result.boxes.numpy().data.tolist()\n        if 'masks' in result._keys and result.masks is not None:\n            infer['masks'] = result.masks.numpy().data.tolist()\n        if 'keypoints' in result._keys and result.keypoints is not None:\n            infer['keypoints'] = result.keypoints.numpy().data.tolist()\n        if 'probs' in result._keys and result.probs is not None:\n            infer['probs'] = result.probs.numpy().data.tolist()\n    return json.dumps(infer)\n</code></pre> <ul> <li>Deploy the Endpoint Using 1_DeployEndpoint.ipynb: In the Jupyter environment, open the 1_DeployEndpoint.ipynb notebook located in the sm-notebook directory. Follow the instructions in the notebook and run the cells to download the YOLOv8 model, package it with the updated inference code, and upload it to an Amazon S3 bucket. The notebook will guide you through creating and deploying a SageMaker endpoint for the YOLOv8 model.</li> </ul>"},{"location":"integrations/amazon-sagemaker/#step-6-testing-your-deployment","title":"Step 6: Testing Your Deployment","text":"<p>Now that your YOLOv8 model is deployed, it's important to test its performance and functionality.</p> <ul> <li> <p>Open the Test Notebook: In the same Jupyter environment, locate and open the 2_TestEndpoint.ipynb notebook, also in the sm-notebook directory.</p> </li> <li> <p>Run the Test Notebook: Follow the instructions within the notebook to test the deployed SageMaker endpoint. This includes sending an image to the endpoint and running inferences. Then, you\u2019ll plot the output to visualize the model\u2019s performance and accuracy, as shown below.</p> </li> </ul> <p> </p> <ul> <li>Clean-Up Resources: The test notebook will also guide you through the process of cleaning up the endpoint and the hosted model. This is an important step to manage costs and resources effectively, especially if you do not plan to use the deployed model immediately.</li> </ul>"},{"location":"integrations/amazon-sagemaker/#step-7-monitoring-and-management","title":"Step 7: Monitoring and Management","text":"<p>After testing, continuous monitoring and management of your deployed model are essential.</p> <ul> <li> <p>Monitor with Amazon CloudWatch: Regularly check the performance and health of your SageMaker endpoint using Amazon CloudWatch.</p> </li> <li> <p>Manage the Endpoint: Use the SageMaker console for ongoing management of the endpoint. This includes scaling, updating, or redeploying the model as required.</p> </li> </ul> <p>By completing these steps, you will have successfully deployed and tested a YOLOv8 model on Amazon SageMaker Endpoints. This process not only equips you with practical experience in using AWS services for machine learning deployment but also lays the foundation for deploying other advanced models in the future.</p>"},{"location":"integrations/amazon-sagemaker/#summary","title":"Summary","text":"<p>This guide took you step by step through deploying YOLOv8 on Amazon SageMaker Endpoints using AWS CloudFormation and the AWS Cloud Development Kit (CDK). The process includes cloning the necessary GitHub repository, setting up the CDK environment, deploying the model using AWS services, and testing its performance on SageMaker.</p> <p>For more technical details, refer to this article on the AWS Machine Learning Blog. You can also check out the official Amazon SageMaker Documentation for more insights into various features and functionalities.</p> <p>Are you interested in learning more about different YOLOv8 integrations? Visit the Ultralytics integrations guide page to discover additional tools and capabilities that can enhance your machine-learning projects.</p>"},{"location":"integrations/clearml/","title":"Training YOLOv8 with ClearML: Streamlining Your MLOps Workflow","text":"<p>MLOps bridges the gap between creating and deploying machine learning models in real-world settings. It focuses on efficient deployment, scalability, and ongoing management to ensure models perform well in practical applications.</p> <p>Ultralytics YOLOv8 effortlessly integrates with ClearML, streamlining and enhancing your object detection model's training and management. This guide will walk you through the integration process, detailing how to set up ClearML, manage experiments, automate model management, and collaborate effectively.</p>"},{"location":"integrations/clearml/#clearml","title":"ClearML","text":"<p>ClearML is an innovative open-source MLOps platform that is skillfully designed to automate, monitor, and orchestrate machine learning workflows. Its key features include automated logging of all training and inference data for full experiment reproducibility, an intuitive web UI for easy data visualization and analysis, advanced hyperparameter optimization algorithms, and robust model management for efficient deployment across various platforms.</p>"},{"location":"integrations/clearml/#yolov8-training-with-clearml","title":"YOLOv8 Training with ClearML","text":"<p>You can bring automation and efficiency to your machine learning workflow by improving your training process by integrating YOLOv8 with ClearML.</p>"},{"location":"integrations/clearml/#installation","title":"Installation","text":"<p>To install the required packages, run:</p> <p>Installation</p> CLI <pre><code># Install the required packages for YOLOv8 and ClearML\npip install ultralytics clearml\n</code></pre> <p>For detailed instructions and best practices related to the installation process, be sure to check our YOLOv8 Installation guide. While installing the required packages for YOLOv8, if you encounter any difficulties, consult our Common Issues guide for solutions and tips.</p>"},{"location":"integrations/clearml/#configuring-clearml","title":"Configuring ClearML","text":"<p>Once you have installed the necessary packages, the next step is to initialize and configure your ClearML SDK. This involves setting up your ClearML account and obtaining the necessary credentials for a seamless connection between your development environment and the ClearML server.</p> <p>Begin by initializing the ClearML SDK in your environment. The \u2018clearml-init\u2019 command starts the setup process and prompts you for the necessary credentials.</p> <p>Initial SDK Setup</p> CLI <pre><code># Initialize your ClearML SDK setup process\nclearml-init\n</code></pre> <p>After executing this command, visit the ClearML Settings page. Navigate to the top right corner and select \"Settings.\" Go to the \"Workspace\" section and click on \"Create new credentials.\" Use the credentials provided in the \"Create Credentials\" pop-up to complete the setup as instructed, depending on whether you are configuring ClearML in a Jupyter Notebook or a local Python environment.</p>"},{"location":"integrations/clearml/#usage","title":"Usage","text":"<p>Before diving into the usage instructions, be sure to check out the range of YOLOv8 models offered by Ultralytics. This will help you choose the most appropriate model for your project requirements.</p> <p>Usage</p> Python <pre><code>from clearml import Task\nfrom ultralytics import YOLO\n\n# Step 1: Creating a ClearML Task\ntask = Task.init(\n    project_name=\"my_project\",\n    task_name=\"my_yolov8_task\"\n)\n\n# Step 2: Selecting the YOLOv8 Model\nmodel_variant = \"yolov8n\"\ntask.set_parameter(\"model_variant\", model_variant)\n\n# Step 3: Loading the YOLOv8 Model\nmodel = YOLO(f'{model_variant}.pt')\n\n# Step 4: Setting Up Training Arguments\nargs = dict(data=\"coco128.yaml\", epochs=16)\ntask.connect(args)\n\n# Step 5: Initiating Model Training\nresults = model.train(**args)\n</code></pre>"},{"location":"integrations/clearml/#understanding-the-code","title":"Understanding the Code","text":"<p>Let\u2019s understand the steps showcased in the usage code snippet above.</p> <p>Step 1: Creating a ClearML Task: A new task is initialized in ClearML, specifying your project and task names. This task will track and manage your model's training.</p> <p>Step 2: Selecting the YOLOv8 Model: The <code>model_variant</code> variable is set to 'yolov8n', one of the YOLOv8 models. This variant is then logged in ClearML for tracking.</p> <p>Step 3: Loading the YOLOv8 Model: The selected YOLOv8 model is loaded using Ultralytics' YOLO class, preparing it for training.</p> <p>Step 4: Setting Up Training Arguments: Key training arguments like the dataset (<code>coco128.yaml</code>) and the number of epochs (<code>16</code>) are organized in a dictionary and connected to the ClearML task. This allows for tracking and potential modification via the ClearML UI. For a detailed understanding of the model training process and best practices, refer to our YOLOv8 Model Training guide.</p> <p>Step 5: Initiating Model Training: The model training is started with the specified arguments. The results of the training process are captured in the <code>results</code> variable.</p>"},{"location":"integrations/clearml/#understanding-the-output","title":"Understanding the Output","text":"<p>Upon running the usage code snippet above, you can expect the following output:</p> <ul> <li>A confirmation message indicating the creation of a new ClearML task, along with its unique ID.</li> <li>An informational message about the script code being stored, indicating that the code execution is being tracked by ClearML.</li> <li>A URL link to the ClearML results page where you can monitor the training progress and view detailed logs.</li> <li>Download progress for the YOLOv8 model and the specified dataset, followed by a summary of the model architecture and training configuration.</li> <li>Initialization messages for various training components like TensorBoard, Automatic Mixed Precision (AMP), and dataset preparation.</li> <li>Finally, the training process starts, with progress updates as the model trains on the specified dataset. For an in-depth understanding of the performance metrics used during training, read our guide on performance metrics.</li> </ul>"},{"location":"integrations/clearml/#viewing-the-clearml-results-page","title":"Viewing the ClearML Results Page","text":"<p>By clicking on the URL link to the ClearML results page in the output of the usage code snippet, you can access a comprehensive view of your model's training process.</p>"},{"location":"integrations/clearml/#key-features-of-the-clearml-results-page","title":"Key Features of the ClearML Results Page","text":"<ul> <li> <p>Real-Time Metrics Tracking</p> <ul> <li>Track critical metrics like loss, accuracy, and validation scores as they occur.</li> <li>Provides immediate feedback for timely model performance adjustments.</li> </ul> </li> <li> <p>Experiment Comparison</p> <ul> <li>Compare different training runs side-by-side.</li> <li>Essential for hyperparameter tuning and identifying the most effective models.</li> </ul> </li> <li> <p>Detailed Logs and Outputs</p> <ul> <li>Access comprehensive logs, graphical representations of metrics, and console outputs.</li> <li>Gain a deeper understanding of model behavior and issue resolution.</li> </ul> </li> <li> <p>Resource Utilization Monitoring</p> <ul> <li>Monitor the utilization of computational resources, including CPU, GPU, and memory.</li> <li>Key to optimizing training efficiency and costs.</li> </ul> </li> <li> <p>Model Artifacts Management</p> <ul> <li>View, download, and share model artifacts like trained models and checkpoints.</li> <li>Enhances collaboration and streamlines model deployment and sharing.</li> </ul> </li> </ul> <p>For a visual walkthrough of what the ClearML Results Page looks like, watch the video below:</p> <p> Watch: YOLOv8 MLOps Integration using ClearML </p>"},{"location":"integrations/clearml/#advanced-features-in-clearml","title":"Advanced Features in ClearML","text":"<p>ClearML offers several advanced features to enhance your MLOps experience.</p>"},{"location":"integrations/clearml/#remote-execution","title":"Remote Execution","text":"<p>ClearML's remote execution feature facilitates the reproduction and manipulation of experiments on different machines. It logs essential details like installed packages and uncommitted changes. When a task is enqueued, the ClearML Agent pulls it, recreates the environment, and runs the experiment, reporting back with detailed results.</p> <p>Deploying a ClearML Agent is straightforward and can be done on various machines using the following command:</p> <pre><code>clearml-agent daemon --queue &lt;queues_to_listen_to&gt; [--docker]\n</code></pre> <p>This setup is applicable to cloud VMs, local GPUs, or laptops. ClearML Autoscalers help manage cloud workloads on platforms like AWS, GCP, and Azure, automating the deployment of agents and adjusting resources based on your resource budget.</p>"},{"location":"integrations/clearml/#cloning-editing-and-enqueuing","title":"Cloning, Editing, and Enqueuing","text":"<p>ClearML's user-friendly interface allows easy cloning, editing, and enqueuing of tasks. Users can clone an existing experiment, adjust parameters or other details through the UI, and enqueue the task for execution. This streamlined process ensures that the ClearML Agent executing the task uses updated configurations, making it ideal for iterative experimentation and model fine-tuning.</p> <p> </p>"},{"location":"integrations/clearml/#summary","title":"Summary","text":"<p>This guide has led you through the process of integrating ClearML with Ultralytics' YOLOv8. Covering everything from initial setup to advanced model management, you've discovered how to leverage ClearML for efficient training, experiment tracking, and workflow optimization in your machine learning projects.</p> <p>For further details on usage, visit ClearML's official documentation.</p> <p>Additionally, explore more integrations and capabilities of Ultralytics by visiting the Ultralytics integration guide page, which is a treasure trove of resources and insights.</p>"},{"location":"integrations/comet/","title":"Elevating YOLOv8 Training: Simplify Your Logging Process with Comet ML","text":"<p>Logging key training details such as parameters, metrics, image predictions, and model checkpoints is essential in machine learning\u2014it keeps your project transparent, your progress measurable, and your results repeatable.</p> <p>Ultralytics YOLOv8 seamlessly integrates with Comet ML, efficiently capturing and optimizing every aspect of your YOLOv8 object detection model's training process. In this guide, we'll cover the installation process, Comet ML setup, real-time insights, custom logging, and offline usage, ensuring that your YOLOv8 training is thoroughly documented and fine-tuned for outstanding results.</p>"},{"location":"integrations/comet/#comet-ml","title":"Comet ML","text":"<p>Comet ML is a platform for tracking, comparing, explaining, and optimizing machine learning models and experiments. It allows you to log metrics, parameters, media, and more during your model training and monitor your experiments through an aesthetically pleasing web interface. Comet ML helps data scientists iterate more rapidly, enhances transparency and reproducibility, and aids in the development of production models.</p>"},{"location":"integrations/comet/#harnessing-the-power-of-yolov8-and-comet-ml","title":"Harnessing the Power of YOLOv8 and Comet ML","text":"<p>By combining Ultralytics YOLOv8 with Comet ML, you unlock a range of benefits. These include simplified experiment management, real-time insights for quick adjustments, flexible and tailored logging options, and the ability to log experiments offline when internet access is limited. This integration empowers you to make data-driven decisions, analyze performance metrics, and achieve exceptional results.</p>"},{"location":"integrations/comet/#installation","title":"Installation","text":"<p>To install the required packages, run:</p> <p>Installation</p> CLI <pre><code># Install the required packages for YOLOv8 and Comet ML\npip install ultralytics comet_ml torch torchvision\n</code></pre>"},{"location":"integrations/comet/#configuring-comet-ml","title":"Configuring Comet ML","text":"<p>After installing the required packages, you\u2019ll need to sign up, get a Comet API Key, and configure it.</p> <p>Configuring Comet ML</p> CLI <pre><code># Set your Comet Api Key\nexport COMET_API_KEY=&lt;Your API Key&gt;\n</code></pre> <p>Then, you can initialize your Comet project. Comet will automatically detect the API key and proceed with the setup.</p> <pre><code>import comet_ml\n\ncomet_ml.init(project_name=\"comet-example-yolov8-coco128\")\n</code></pre> <p>Note: If you are using a Google Colab notebook, the code above will prompt you to enter your API key for initialization.</p>"},{"location":"integrations/comet/#usage","title":"Usage","text":"<p>Before diving into the usage instructions, be sure to check out the range of YOLOv8 models offered by Ultralytics. This will help you choose the most appropriate model for your project requirements.</p> <p>Usage</p> Python <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO(\"yolov8n.pt\")\n\n# train the model\nresults = model.train(\ndata=\"coco128.yaml\",\nproject=\"comet-example-yolov8-coco128\",\nbatch=32,\nsave_period=1,\nsave_json=True,\nepochs=3\n)\n</code></pre> <p>After running the training code, Comet ML will create an experiment in your Comet workspace to track the run automatically. You will then be provided with a link to view the detailed logging of your YOLOv8 model's training process.</p> <p>Comet automatically logs the following data with no additional configuration: metrics such as mAP and loss, hyperparameters, model checkpoints, interactive confusion matrix, and image bounding box predictions.</p>"},{"location":"integrations/comet/#understanding-your-models-performance-with-comet-ml-visualizations","title":"Understanding Your Model's Performance with Comet ML Visualizations","text":"<p>Let's dive into what you'll see on the Comet ML dashboard once your YOLOv8 model begins training. The dashboard is where all the action happens, presenting a range of automatically logged information through visuals and statistics. Here\u2019s a quick tour:</p> <p>Experiment Panels</p> <p>The experiment panels section of the Comet ML dashboard organize and present the different runs and their metrics, such as segment mask loss, class loss, precision, and mean average precision.</p> <p> </p> <p>Metrics</p> <p>In the metrics section, you have the option to examine the metrics in a tabular format as well, which is displayed in a dedicated pane as illustrated here.</p> <p> </p> <p>Interactive Confusion Matrix</p> <p>The confusion matrix, found in the Confusion Matrix tab, provides an interactive way to assess the model's classification accuracy. It details the correct and incorrect predictions, allowing you to understand the model's strengths and weaknesses.</p> <p> </p> <p>System Metrics</p> <p>Comet ML logs system metrics to help identify any bottlenecks in the training process. It includes metrics such as GPU utilization, GPU memory usage, CPU utilization, and RAM usage. These are essential for monitoring the efficiency of resource usage during model training.</p> <p> </p>"},{"location":"integrations/comet/#customizing-comet-ml-logging","title":"Customizing Comet ML Logging","text":"<p>Comet ML offers the flexibility to customize its logging behavior by setting environment variables. These configurations allow you to tailor Comet ML to your specific needs and preferences. Here are some helpful customization options:</p>"},{"location":"integrations/comet/#logging-image-predictions","title":"Logging Image Predictions","text":"<p>You can control the number of image predictions that Comet ML logs during your experiments. By default, Comet ML logs 100 image predictions from the validation set. However, you can change this number to better suit your requirements. For example, to log 200 image predictions, use the following code:</p> <pre><code>import os\n\nos.environ[\"COMET_MAX_IMAGE_PREDICTIONS\"] = \"200\"\n</code></pre>"},{"location":"integrations/comet/#batch-logging-interval","title":"Batch Logging Interval","text":"<p>Comet ML allows you to specify how often batches of image predictions are logged. The <code>COMET_EVAL_BATCH_LOGGING_INTERVAL</code> environment variable controls this frequency. The default setting is 1, which logs predictions from every validation batch. You can adjust this value to log predictions at a different interval. For instance, setting it to 4 will log predictions from every fourth batch.</p> <pre><code>import os\n\nos.environ['COMET_EVAL_BATCH_LOGGING_INTERVAL'] = \"4\"\n</code></pre>"},{"location":"integrations/comet/#disabling-confusion-matrix-logging","title":"Disabling Confusion Matrix Logging","text":"<p>In some cases, you may not want to log the confusion matrix from your validation set after every epoch. You can disable this feature by setting the <code>COMET_EVAL_LOG_CONFUSION_MATRIX</code> environment variable to \"false.\" The confusion matrix will only be logged once, after the training is completed.</p> <pre><code>import os\n\nos.environ[\"COMET_EVAL_LOG_CONFUSION_MATRIX\"] = \"false\"\n</code></pre>"},{"location":"integrations/comet/#offline-logging","title":"Offline Logging","text":"<p>If you find yourself in a situation where internet access is limited, Comet ML provides an offline logging option. You can set the <code>COMET_MODE</code> environment variable to \"offline\" to enable this feature. Your experiment data will be saved locally in a directory that you can later upload to Comet ML when internet connectivity is available.</p> <pre><code>import os\n\nos.environ[\"COMET_MODE\"] = \"offline\"\n</code></pre>"},{"location":"integrations/comet/#summary","title":"Summary","text":"<p>This guide has walked you through integrating Comet ML with Ultralytics' YOLOv8. From installation to customization, you've learned to streamline experiment management, gain real-time insights, and adapt logging to your project's needs.</p> <p>Explore Comet ML's official documentation for more insights on integrating with YOLOv8.</p> <p>Furthermore, if you're looking to dive deeper into the practical applications of YOLOv8, specifically for image segmentation tasks, this detailed guide on fine-tuning YOLOv8 with Comet ML offers valuable insights and step-by-step instructions to enhance your model's performance.</p> <p>Additionally, to explore other exciting integrations with Ultralytics, check out the integration guide page, which offers a wealth of resources and information.</p>"},{"location":"integrations/dvc/","title":"Advanced YOLOv8 Experiment Tracking with DVCLive","text":"<p>Experiment tracking in machine learning is critical to model development and evaluation. It involves recording and analyzing various parameters, metrics, and outcomes from numerous training runs. This process is essential for understanding model performance and making data-driven decisions to refine and optimize models.</p> <p>Integrating DVCLive with Ultralytics YOLOv8 transforms the way experiments are tracked and managed. This integration offers a seamless solution for automatically logging key experiment details, comparing results across different runs, and visualizing data for in-depth analysis. In this guide, we'll understand how DVCLive can be used to streamline the process.</p>"},{"location":"integrations/dvc/#dvclive","title":"DVCLive","text":"<p>DVCLive, developed by DVC, is an innovative open-source tool for experiment tracking in machine learning. Integrating seamlessly with Git and DVC, it automates the logging of crucial experiment data like model parameters and training metrics. Designed for simplicity, DVCLive enables effortless comparison and analysis of multiple runs, enhancing the efficiency of machine learning projects with intuitive data visualization and analysis tools.</p>"},{"location":"integrations/dvc/#yolov8-training-with-dvclive","title":"YOLOv8 Training with DVCLive","text":"<p>YOLOv8 training sessions can be effectively monitored with DVCLive. Additionally, DVC provides integral features for visualizing these experiments, including the generation of a report that enables the comparison of metric plots across all tracked experiments, offering a comprehensive view of the training process.</p>"},{"location":"integrations/dvc/#installation","title":"Installation","text":"<p>To install the required packages, run:</p> <p>Installation</p> CLI <pre><code># Install the required packages for YOLOv8 and DVCLive\npip install ultralytics dvclive\n</code></pre> <p>For detailed instructions and best practices related to the installation process, be sure to check our YOLOv8 Installation guide. While installing the required packages for YOLOv8, if you encounter any difficulties, consult our Common Issues guide for solutions and tips.</p>"},{"location":"integrations/dvc/#configuring-dvclive","title":"Configuring DVCLive","text":"<p>Once you have installed the necessary packages, the next step is to set up and configure your environment with the necessary credentials. This setup ensures a smooth integration of DVCLive into your existing workflow.</p> <p>Begin by initializing a Git repository, as Git plays a crucial role in version control for both your code and DVCLive configurations.</p> <p>Initial Environment Setup</p> CLI <pre><code># Initialize a Git repository\ngit init -q\n\n# Configure Git with your details\ngit config --local user.email \"you@example.com\"\ngit config --local user.name \"Your Name\"\n\n# Initialize DVCLive in your project\ndvc init -q\n\n# Commit the DVCLive setup to your Git repository\ngit commit -m \"DVC init\"\n</code></pre> <p>In these commands, ensure to replace \"you@example.com\" with the email address associated with your Git account, and \"Your Name\" with your Git account username.</p>"},{"location":"integrations/dvc/#usage","title":"Usage","text":"<p>Before diving into the usage instructions, be sure to check out the range of YOLOv8 models offered by Ultralytics. This will help you choose the most appropriate model for your project requirements.</p>"},{"location":"integrations/dvc/#training-yolov8-models-with-dvclive","title":"Training YOLOv8 Models with DVCLive","text":"<p>Start by running your YOLOv8 training sessions. You can use different model configurations and training parameters to suit your project needs. For instance:</p> <pre><code># Example training commands for YOLOv8 with varying configurations\nyolo train model=yolov8n.pt data=coco8.yaml epochs=5 imgsz=512\nyolo train model=yolov8n.pt data=coco8.yaml epochs=5 imgsz=640\n</code></pre> <p>Adjust the model, data, epochs, and imgsz parameters according to your specific requirements. For a detailed understanding of the model training process and best practices, refer to our YOLOv8 Model Training guide.</p>"},{"location":"integrations/dvc/#monitoring-experiments-with-dvclive","title":"Monitoring Experiments with DVCLive","text":"<p>DVCLive enhances the training process by enabling the tracking and visualization of key metrics. When installed, Ultralytics YOLOv8 automatically integrates with DVCLive for experiment tracking, which you can later analyze for performance insights. For a comprehensive understanding of the specific performance metrics used during training, be sure to explore our detailed guide on performance metrics.</p>"},{"location":"integrations/dvc/#analyzing-results","title":"Analyzing Results","text":"<p>After your YOLOv8 training sessions are complete, you can leverage DVCLive's powerful visualization tools for in-depth analysis of the results. DVCLive's integration ensures that all training metrics are systematically logged, facilitating a comprehensive evaluation of your model's performance.</p> <p>To start the analysis, you can extract the experiment data using DVC's API and process it with Pandas for easier handling and visualization:</p> <pre><code>import dvc.api\nimport pandas as pd\n\n# Define the columns of interest\ncolumns = [\"Experiment\", \"epochs\", \"imgsz\", \"model\", \"metrics.mAP50-95(B)\"]\n\n# Retrieve experiment data\ndf = pd.DataFrame(dvc.api.exp_show(), columns=columns)\n\n# Clean the data\ndf.dropna(inplace=True)\ndf.reset_index(drop=True, inplace=True)\n\n# Display the DataFrame\nprint(df)\n</code></pre> <p>The output of the code snippet above provides a clear tabular view of the different experiments conducted with YOLOv8 models. Each row represents a different training run, detailing the experiment's name, the number of epochs, image size (imgsz), the specific model used, and the mAP50-95(B) metric. This metric is crucial for evaluating the model's accuracy, with higher values indicating better performance.</p>"},{"location":"integrations/dvc/#visualizing-results-with-plotly","title":"Visualizing Results with Plotly","text":"<p>For a more interactive and visual analysis of your experiment results, you can use Plotly's parallel coordinates plot. This type of plot is particularly useful for understanding the relationships and trade-offs between different parameters and metrics.</p> <pre><code>from plotly.express import parallel_coordinates\n\n# Create a parallel coordinates plot\nfig = parallel_coordinates(df, columns, color=\"metrics.mAP50-95(B)\")\n\n# Display the plot\nfig.show()\n</code></pre> <p>The output of the code snippet above generates a plot that will visually represent the relationships between epochs, image size, model type, and their corresponding mAP50-95(B) scores, enabling you to spot trends and patterns in your experiment data.</p>"},{"location":"integrations/dvc/#generating-comparative-visualizations-with-dvc","title":"Generating Comparative Visualizations with DVC","text":"<p>DVC provides a useful command to generate comparative plots for your experiments. This can be especially helpful to compare the performance of different models over various training runs.</p> <pre><code># Generate DVC comparative plots\ndvc plots diff $(dvc exp list --names-only)\n</code></pre> <p>After executing this command, DVC generates plots comparing the metrics across different experiments, which are saved as HTML files. Below is an example image illustrating typical plots generated by this process. The image showcases various graphs, including those representing mAP, recall, precision, loss values, and more, providing a visual overview of key performance metrics:</p> <p> </p>"},{"location":"integrations/dvc/#displaying-dvc-plots","title":"Displaying DVC Plots","text":"<p>If you are using a Jupyter Notebook and you want to display the generated DVC plots, you can use the IPython display functionality.</p> <pre><code>from IPython.display import HTML\n\n# Display the DVC plots as HTML\nHTML(filename='./dvc_plots/index.html')\n</code></pre> <p>This code will render the HTML file containing the DVC plots directly in your Jupyter Notebook, providing an easy and convenient way to analyze the visualized experiment data.</p>"},{"location":"integrations/dvc/#making-data-driven-decisions","title":"Making Data-Driven Decisions","text":"<p>Use the insights gained from these visualizations to make informed decisions about model optimizations, hyperparameter tuning, and other modifications to enhance your model's performance.</p>"},{"location":"integrations/dvc/#iterating-on-experiments","title":"Iterating on Experiments","text":"<p>Based on your analysis, iterate on your experiments. Adjust model configurations, training parameters, or even the data inputs, and repeat the training and analysis process. This iterative approach is key to refining your model for the best possible performance.</p>"},{"location":"integrations/dvc/#summary","title":"Summary","text":"<p>This guide has led you through the process of integrating DVCLive with Ultralytics' YOLOv8. You have learned how to harness the power of DVCLive for detailed experiment monitoring, effective visualization, and insightful analysis in your machine learning endeavors.</p> <p>For further details on usage, visit DVCLive\u2019s official documentation.</p> <p>Additionally, explore more integrations and capabilities of Ultralytics by visiting the Ultralytics integration guide page, which is a collection of great resources and insights.</p>"},{"location":"integrations/mlflow/","title":"MLflow Integration for Ultralytics YOLO","text":""},{"location":"integrations/mlflow/#introduction","title":"Introduction","text":"<p>Experiment logging is a crucial aspect of machine learning workflows that enables tracking of various metrics, parameters, and artifacts. It helps to enhance model reproducibility, debug issues, and improve model performance. Ultralytics YOLO, known for its real-time object detection capabilities, now offers integration with MLflow, an open-source platform for complete machine learning lifecycle management.</p> <p>This documentation page is a comprehensive guide to setting up and utilizing the MLflow logging capabilities for your Ultralytics YOLO project.</p>"},{"location":"integrations/mlflow/#what-is-mlflow","title":"What is MLflow?","text":"<p>MLflow is an open-source platform developed by Databricks for managing the end-to-end machine learning lifecycle. It includes tools for tracking experiments, packaging code into reproducible runs, and sharing and deploying models. MLflow is designed to work with any machine learning library and programming language.</p>"},{"location":"integrations/mlflow/#features","title":"Features","text":"<ul> <li>Metrics Logging: Logs metrics at the end of each epoch and at the end of the training.</li> <li>Parameter Logging: Logs all the parameters used in the training.</li> <li>Artifacts Logging: Logs model artifacts, including weights and configuration files, at the end of the training.</li> </ul>"},{"location":"integrations/mlflow/#setup-and-prerequisites","title":"Setup and Prerequisites","text":"<p>Ensure MLflow is installed. If not, install it using pip:</p> <pre><code>pip install mlflow\n</code></pre> <p>Make sure that MLflow logging is enabled in Ultralytics settings. Usually, this is controlled by the settings <code>mflow</code> key. See the settings page for more info.</p> <p>Update Ultralytics MLflow Settings</p> PythonCLI <p>Within the Python environment, call the <code>update</code> method on the <code>settings</code> object to change your settings: <pre><code>from ultralytics import settings\n\n# Update a setting\nsettings.update({'mlflow': True})\n\n# Reset settings to default values\nsettings.reset()\n</code></pre></p> <p>If you prefer using the command-line interface, the following commands will allow you to modify your settings: <pre><code># Update a setting\nyolo settings runs_dir='/path/to/runs'\n\n# Reset settings to default values\nyolo settings reset\n</code></pre></p>"},{"location":"integrations/mlflow/#how-to-use","title":"How to Use","text":""},{"location":"integrations/mlflow/#commands","title":"Commands","text":"<ol> <li> <p>Set a Project Name: You can set the project name via an environment variable:</p> <pre><code>export MLFLOW_EXPERIMENT_NAME=&lt;your_experiment_name&gt;\n</code></pre> </li> </ol> <p>Or use the <code>project=&lt;project&gt;</code> argument when training a YOLO model, i.e. <code>yolo train project=my_project</code>.</p> <ol> <li> <p>Set a Run Name: Similar to setting a project name, you can set the run name via an environment variable:</p> <pre><code>export MLFLOW_RUN=&lt;your_run_name&gt;\n</code></pre> </li> </ol> <p>Or use the <code>name=&lt;name&gt;</code> argument when training a YOLO model, i.e. <code>yolo train project=my_project name=my_name</code>.</p> <ol> <li> <p>Start Local MLflow Server: To start tracking, use:</p> <pre><code>mlflow server --backend-store-uri runs/mlflow'\n</code></pre> </li> </ol> <p>This will start a local server at http://127.0.0.1:5000 by default and save all mlflow logs to the 'runs/mlflow' directory. To specify a different URI, set the <code>MLFLOW_TRACKING_URI</code> environment variable.</p> <ol> <li> <p>Kill MLflow Server Instances: To stop all running MLflow instances, run:</p> <pre><code>ps aux | grep 'mlflow' | grep -v 'grep' | awk '{print $2}' | xargs kill -9\n</code></pre> </li> </ol>"},{"location":"integrations/mlflow/#logging","title":"Logging","text":"<p>The logging is taken care of by the <code>on_pretrain_routine_end</code>, <code>on_fit_epoch_end</code>, and <code>on_train_end</code> callback functions. These functions are automatically called during the respective stages of the training process, and they handle the logging of parameters, metrics, and artifacts.</p>"},{"location":"integrations/mlflow/#examples","title":"Examples","text":"<ol> <li> <p>Logging Custom Metrics: You can add custom metrics to be logged by modifying the <code>trainer.metrics</code> dictionary before <code>on_fit_epoch_end</code> is called.</p> </li> <li> <p>View Experiment: To view your logs, navigate to your MLflow server (usually http://127.0.0.1:5000) and select your experiment and run. </p> </li> <li> <p>View Run: Runs are individual models inside an experiment. Click on a Run and see the Run details, including uploaded artifacts and model weights. </p> </li> </ol>"},{"location":"integrations/mlflow/#disabling-mlflow","title":"Disabling MLflow","text":"<p>To turn off MLflow logging:</p> <pre><code>yolo settings mlflow=False\n</code></pre>"},{"location":"integrations/mlflow/#conclusion","title":"Conclusion","text":"<p>MLflow logging integration with Ultralytics YOLO offers a streamlined way to keep track of your machine learning experiments. It empowers you to monitor performance metrics and manage artifacts effectively, thus aiding in robust model development and deployment. For further details please visit the MLflow official documentation.</p>"},{"location":"integrations/neural-magic/","title":"Optimizing YOLOv8 Inferences with Neural Magic\u2019s DeepSparse Engine","text":"<p>When deploying object detection models like Ultralytics\u2019 YOLOv8 on various hardware, you can bump into unique issues like optimization. This is where YOLOv8\u2019s integration with Neural Magic\u2019s DeepSparse Engine steps in. It transforms the way YOLOv8 models are executed and enables GPU-level performance directly on CPUs.</p> <p>This guide shows you how to deploy YOLOv8 using Neural Magic's DeepSparse, how to run inferences, and also how to benchmark performance to ensure it is optimized.</p>"},{"location":"integrations/neural-magic/#neural-magics-deepsparse","title":"Neural Magic\u2019s DeepSparse","text":"<p>Neural Magic\u2019s DeepSparse is an inference run-time designed to optimize the execution of neural networks on CPUs. It applies advanced techniques like sparsity, pruning, and quantization to dramatically reduce computational demands while maintaining accuracy. DeepSparse offers an agile solution for efficient and scalable neural network execution across various devices.</p>"},{"location":"integrations/neural-magic/#benefits-of-integrating-neural-magics-deepsparse-with-yolov8","title":"Benefits of Integrating Neural Magic\u2019s DeepSparse with YOLOv8","text":"<p>Before diving into how to deploy YOLOV8 using DeepSparse, let\u2019s understand the benefits of using DeepSparse. Some key advantages include:</p> <ul> <li>Enhanced Inference Speed: Achieves up to 525 FPS (on YOLOv8n), significantly speeding up YOLOv8's inference capabilities compared to traditional methods.</li> </ul> <p> </p> <ul> <li>Optimized Model Efficiency: Uses pruning and quantization to enhance YOLOv8's efficiency, reducing model size and computational requirements while maintaining accuracy.</li> </ul> <p> </p> <ul> <li> <p>High Performance on Standard CPUs: Delivers GPU-like performance on CPUs, providing a more accessible and cost-effective option for various applications.</p> </li> <li> <p>Streamlined Integration and Deployment: Offers user-friendly tools for easy integration of YOLOv8 into applications, including image and video annotation features.</p> </li> <li> <p>Support for Various Model Types: Compatible with both standard and sparsity-optimized YOLOv8 models, adding deployment flexibility.</p> </li> <li> <p>Cost-Effective and Scalable Solution: Reduces operational expenses and offers scalable deployment of advanced object detection models.</p> </li> </ul>"},{"location":"integrations/neural-magic/#how-does-neural-magics-deepsparse-technology-works","title":"How Does Neural Magic's DeepSparse Technology Works?","text":"<p>Neural Magic\u2019s Deep Sparse technology is inspired by the human brain\u2019s efficiency in neural network computation. It adopts two key principles from the brain as follows:</p> <ul> <li> <p>Sparsity: The process of sparsification involves pruning redundant information from deep learning networks, leading to smaller and faster models without compromising accuracy. This technique reduces the network's size and computational needs significantly.</p> </li> <li> <p>Locality of Reference: DeepSparse uses a unique execution method, breaking the network into Tensor Columns. These columns are executed depth-wise, fitting entirely within the CPU's cache. This approach mimics the brain's efficiency, minimizing data movement and maximizing the CPU's cache use.</p> </li> </ul> <p> </p> <p>For more details on how Neural Magic's DeepSparse technology work, check out their blog post.</p>"},{"location":"integrations/neural-magic/#creating-a-sparse-version-of-yolov8-trained-on-a-custom-dataset","title":"Creating A Sparse Version of YOLOv8 Trained on a Custom Dataset","text":"<p>SparseZoo, an open-source model repository by Neural Magic, offers a collection of pre-sparsified YOLOv8 model checkpoints. With SparseML, seamlessly integrated with Ultralytics, users can effortlessly fine-tune these sparse checkpoints on their specific datasets using a straightforward command-line interface.</p> <p>Checkout Neural Magic's SparseML YOLOv8 documentation for more details.</p>"},{"location":"integrations/neural-magic/#usage-deploying-yolov8-using-deepsparse","title":"Usage: Deploying YOLOV8 using DeepSparse","text":"<p>Deploying YOLOv8 with Neural Magic's DeepSparse involves a few straightforward steps. Before diving into the usage instructions, be sure to check out the range of YOLOv8 models offered by Ultralytics. This will help you choose the most appropriate model for your project requirements. Here's how you can get started.</p>"},{"location":"integrations/neural-magic/#step-1-installation","title":"Step 1: Installation","text":"<p>To install the required packages, run:</p> <p>Installation</p> CLI <pre><code># Install the required packages\npip install deepsparse[yolov8]\n</code></pre>"},{"location":"integrations/neural-magic/#step-2-exporting-yolov8-to-onnx-format","title":"Step 2: Exporting YOLOv8 to ONNX Format","text":"<p>DeepSparse Engine requires YOLOv8 models in ONNX format. Exporting your model to this format is essential for compatibility with DeepSparse. Use the following command to export YOLOv8 models:</p> <p>Model Export</p> CLI <pre><code># Export YOLOv8 model to ONNX format\nyolo task=detect mode=export model=yolov8n.pt format=onnx opset=13\n</code></pre> <p>This command will save the <code>yolov8n.onnx</code> model to your disk.</p>"},{"location":"integrations/neural-magic/#step-3-deploying-and-running-inferences","title":"Step 3: Deploying and Running Inferences","text":"<p>With your YOLOv8 model in ONNX format, you can deploy and run inferences using DeepSparse. This can be done easily with their intuitive Python API:</p> <p>Deploying and Running Inferences</p> Python <pre><code>from deepsparse import Pipeline\n\n# Specify the path to your YOLOv8 ONNX model\nmodel_path = \"path/to/yolov8n.onnx\"\n\n# Set up the DeepSparse Pipeline\nyolo_pipeline = Pipeline.create(\n    task=\"yolov8\",\n    model_path=model_path\n)\n\n# Run the model on your images\nimages = [\"path/to/image.jpg\"]\npipeline_outputs = yolo_pipeline(images=images)\n</code></pre>"},{"location":"integrations/neural-magic/#step-4-benchmarking-performance","title":"Step 4: Benchmarking Performance","text":"<p>It's important to check that your YOLOv8 model is performing optimally on DeepSparse. You can benchmark your model's performance to analyze throughput and latency:</p> <p>Benchmarking</p> CLI <pre><code># Benchmark performance\ndeepsparse.benchmark model_path=\"path/to/yolov8n.onnx\" --scenario=sync --input_shapes=\"[1,3,640,640]\"\n</code></pre>"},{"location":"integrations/neural-magic/#step-5-additional-features","title":"Step 5: Additional Features","text":"<p>DeepSparse provides additional features for practical integration of YOLOv8 in applications, such as image annotation and dataset evaluation.</p> <p>Additional Features</p> CLI <pre><code># For image annotation\ndeepsparse.yolov8.annotate --source \"path/to/image.jpg\" --model_filepath \"path/to/yolov8n.onnx\"\n\n# For evaluating model performance on a dataset\ndeepsparse.yolov8.eval --model_path \"path/to/yolov8n.onnx\"\n</code></pre> <p>Running the annotate command processes your specified image, detecting objects, and saving the annotated image with bounding boxes and classifications. The annotated image will be stored in an annotation-results folder. This helps provide a visual representation of the model's detection capabilities.</p> <p> </p> <p>After running the eval command, you will receive detailed output metrics such as precision, recall, and mAP (mean Average Precision). This provides a comprehensive view of your model's performance on the dataset. This functionality is particularly useful for fine-tuning and optimizing your YOLOv8 models for specific use cases, ensuring high accuracy and efficiency.</p>"},{"location":"integrations/neural-magic/#summary","title":"Summary","text":"<p>This guide explored integrating Ultralytics\u2019 YOLOv8 with Neural Magic's DeepSparse Engine. It highlighted how this integration enhances YOLOv8's performance on CPU platforms, offering GPU-level efficiency and advanced neural network sparsity techniques.</p> <p>For more detailed information and advanced usage, visit Neural Magic\u2019s DeepSparse documentation. Also, check out Neural Magic\u2019s documentation on the integration with YOLOv8 here and watch a great session on it here.</p> <p>Additionally, for a broader understanding of various YOLOv8 integrations, visit the Ultralytics integration guide page, where you can discover a range of other exciting integration possibilities.</p>"},{"location":"integrations/openvino/","title":"Intel OpenVINO Export","text":"<p>In this guide, we cover exporting YOLOv8 models to the OpenVINO format, which can provide up to 3x CPU speedup as well as accelerating on other Intel hardware (iGPU, dGPU, VPU, etc.).</p> <p>OpenVINO, short for Open Visual Inference &amp; Neural Network Optimization toolkit, is a comprehensive toolkit for optimizing and deploying AI inference models. Even though the name contains Visual, OpenVINO also supports various additional tasks including language, audio, time series, etc.</p> <p> Watch: How To Export and Optimize an Ultralytics YOLOv8 Model for Inference with OpenVINO. </p>"},{"location":"integrations/openvino/#usage-examples","title":"Usage Examples","text":"<p>Export a YOLOv8n model to OpenVINO format and run inference with the exported model.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a YOLOv8n PyTorch model\nmodel = YOLO('yolov8n.pt')\n\n# Export the model\nmodel.export(format='openvino')  # creates 'yolov8n_openvino_model/'\n\n# Load the exported OpenVINO model\nov_model = YOLO('yolov8n_openvino_model/')\n\n# Run inference\nresults = ov_model('https://ultralytics.com/images/bus.jpg')\n</code></pre> <pre><code># Export a YOLOv8n PyTorch model to OpenVINO format\nyolo export model=yolov8n.pt format=openvino  # creates 'yolov8n_openvino_model/'\n\n# Run inference with the exported model\nyolo predict model=yolov8n_openvino_model source='https://ultralytics.com/images/bus.jpg'\n</code></pre>"},{"location":"integrations/openvino/#arguments","title":"Arguments","text":"Key Value Description <code>format</code> <code>'openvino'</code> format to export to <code>imgsz</code> <code>640</code> image size as scalar or (h, w) list, i.e. (640, 480) <code>half</code> <code>False</code> FP16 quantization"},{"location":"integrations/openvino/#benefits-of-openvino","title":"Benefits of OpenVINO","text":"<ol> <li>Performance: OpenVINO delivers high-performance inference by utilizing the power of Intel CPUs, integrated and discrete GPUs, and FPGAs.</li> <li>Support for Heterogeneous Execution: OpenVINO provides an API to write once and deploy on any supported Intel hardware (CPU, GPU, FPGA, VPU, etc.).</li> <li>Model Optimizer: OpenVINO provides a Model Optimizer that imports, converts, and optimizes models from popular deep learning frameworks such as PyTorch, TensorFlow, TensorFlow Lite, Keras, ONNX, PaddlePaddle, and Caffe.</li> <li>Ease of Use: The toolkit comes with more than 80 tutorial notebooks (including YOLOv8 optimization) teaching different aspects of the toolkit.</li> </ol>"},{"location":"integrations/openvino/#openvino-export-structure","title":"OpenVINO Export Structure","text":"<p>When you export a model to OpenVINO format, it results in a directory containing the following:</p> <ol> <li>XML file: Describes the network topology.</li> <li>BIN file: Contains the weights and biases binary data.</li> <li>Mapping file: Holds mapping of original model output tensors to OpenVINO tensor names.</li> </ol> <p>You can use these files to run inference with the OpenVINO Inference Engine.</p>"},{"location":"integrations/openvino/#using-openvino-export-in-deployment","title":"Using OpenVINO Export in Deployment","text":"<p>Once you have the OpenVINO files, you can use the OpenVINO Runtime to run the model. The Runtime provides a unified API to inference across all supported Intel hardware. It also provides advanced capabilities like load balancing across Intel hardware and asynchronous execution. For more information on running the inference, refer to the Inference with OpenVINO Runtime Guide.</p> <p>Remember, you'll need the XML and BIN files as well as any application-specific settings like input size, scale factor for normalization, etc., to correctly set up and use the model with the Runtime.</p> <p>In your deployment application, you would typically do the following steps:</p> <ol> <li>Initialize OpenVINO by creating <code>core = Core()</code>.</li> <li>Load the model using the <code>core.read_model()</code> method.</li> <li>Compile the model using the <code>core.compile_model()</code> function.</li> <li>Prepare the input (image, text, audio, etc.).</li> <li>Run inference using <code>compiled_model(input_data)</code>.</li> </ol> <p>For more detailed steps and code snippets, refer to the OpenVINO documentation or API tutorial.</p>"},{"location":"integrations/openvino/#openvino-yolov8-benchmarks","title":"OpenVINO YOLOv8 Benchmarks","text":"<p>YOLOv8 benchmarks below were run by the Ultralytics team on 4 different model formats measuring speed and accuracy: PyTorch, TorchScript, ONNX and OpenVINO. Benchmarks were run on Intel Flex and Arc GPUs, and on Intel Xeon CPUs at FP32 precision (with the <code>half=False</code> argument).</p> <p>Note</p> <p>The benchmarking results below are for reference and might vary based on the exact hardware and software configuration of a system, as well as the current workload of the system at the time the benchmarks are run.</p> <p>All benchmarks run with <code>openvino</code> Python package version 2023.0.1.</p>"},{"location":"integrations/openvino/#intel-flex-gpu","title":"Intel Flex GPU","text":"<p>The Intel\u00ae Data Center GPU Flex Series is a versatile and robust solution designed for the intelligent visual cloud. This GPU supports a wide array of workloads including media streaming, cloud gaming, AI visual inference, and virtual desktop Infrastructure workloads. It stands out for its open architecture and built-in support for the AV1 encode, providing a standards-based software stack for high-performance, cross-architecture applications. The Flex Series GPU is optimized for density and quality, offering high reliability, availability, and scalability.</p> <p>Benchmarks below run on Intel\u00ae Data Center GPU Flex 170 at FP32 precision.</p> Model Format Status Size (MB) mAP50-95(B) Inference time (ms/im) YOLOv8n PyTorch \u2705 6.2 0.3709 21.79 YOLOv8n TorchScript \u2705 12.4 0.3704 23.24 YOLOv8n ONNX \u2705 12.2 0.3704 37.22 YOLOv8n OpenVINO \u2705 12.3 0.3703 3.29 YOLOv8s PyTorch \u2705 21.5 0.4471 31.89 YOLOv8s TorchScript \u2705 42.9 0.4472 32.71 YOLOv8s ONNX \u2705 42.8 0.4472 43.42 YOLOv8s OpenVINO \u2705 42.9 0.4470 3.92 YOLOv8m PyTorch \u2705 49.7 0.5013 50.75 YOLOv8m TorchScript \u2705 99.2 0.4999 47.90 YOLOv8m ONNX \u2705 99.0 0.4999 63.16 YOLOv8m OpenVINO \u2705 49.8 0.4997 7.11 YOLOv8l PyTorch \u2705 83.7 0.5293 77.45 YOLOv8l TorchScript \u2705 167.2 0.5268 85.71 YOLOv8l ONNX \u2705 166.8 0.5268 88.94 YOLOv8l OpenVINO \u2705 167.0 0.5264 9.37 YOLOv8x PyTorch \u2705 130.5 0.5404 100.09 YOLOv8x TorchScript \u2705 260.7 0.5371 114.64 YOLOv8x ONNX \u2705 260.4 0.5371 110.32 YOLOv8x OpenVINO \u2705 260.6 0.5367 15.02 <p>This table represents the benchmark results for five different models (YOLOv8n, YOLOv8s, YOLOv8m, YOLOv8l, YOLOv8x) across four different formats (PyTorch, TorchScript, ONNX, OpenVINO), giving us the status, size, mAP50-95(B) metric, and inference time for each combination.</p>"},{"location":"integrations/openvino/#intel-arc-gpu","title":"Intel Arc GPU","text":"<p>Intel\u00ae Arc\u2122 represents Intel's foray into the dedicated GPU market. The Arc\u2122 series, designed to compete with leading GPU manufacturers like AMD and Nvidia, caters to both the laptop and desktop markets. The series includes mobile versions for compact devices like laptops, and larger, more powerful versions for desktop computers.</p> <p>The Arc\u2122 series is divided into three categories: Arc\u2122 3, Arc\u2122 5, and Arc\u2122 7, with each number indicating the performance level. Each category includes several models, and the 'M' in the GPU model name signifies a mobile, integrated variant.</p> <p>Early reviews have praised the Arc\u2122 series, particularly the integrated A770M GPU, for its impressive graphics performance. The availability of the Arc\u2122 series varies by region, and additional models are expected to be released soon. Intel\u00ae Arc\u2122 GPUs offer high-performance solutions for a range of computing needs, from gaming to content creation.</p> <p>Benchmarks below run on Intel\u00ae Arc 770 GPU at FP32 precision.</p> Model Format Status Size (MB) metrics/mAP50-95(B) Inference time (ms/im) YOLOv8n PyTorch \u2705 6.2 0.3709 88.79 YOLOv8n TorchScript \u2705 12.4 0.3704 102.66 YOLOv8n ONNX \u2705 12.2 0.3704 57.98 YOLOv8n OpenVINO \u2705 12.3 0.3703 8.52 YOLOv8s PyTorch \u2705 21.5 0.4471 189.83 YOLOv8s TorchScript \u2705 42.9 0.4472 227.58 YOLOv8s ONNX \u2705 42.7 0.4472 142.03 YOLOv8s OpenVINO \u2705 42.9 0.4469 9.19 YOLOv8m PyTorch \u2705 49.7 0.5013 411.64 YOLOv8m TorchScript \u2705 99.2 0.4999 517.12 YOLOv8m ONNX \u2705 98.9 0.4999 298.68 YOLOv8m OpenVINO \u2705 99.1 0.4996 12.55 YOLOv8l PyTorch \u2705 83.7 0.5293 725.73 YOLOv8l TorchScript \u2705 167.1 0.5268 892.83 YOLOv8l ONNX \u2705 166.8 0.5268 576.11 YOLOv8l OpenVINO \u2705 167.0 0.5262 17.62 YOLOv8x PyTorch \u2705 130.5 0.5404 988.92 YOLOv8x TorchScript \u2705 260.7 0.5371 1186.42 YOLOv8x ONNX \u2705 260.4 0.5371 768.90 YOLOv8x OpenVINO \u2705 260.6 0.5367 19"},{"location":"integrations/openvino/#intel-xeon-cpu","title":"Intel Xeon CPU","text":"<p>The Intel\u00ae Xeon\u00ae CPU is a high-performance, server-grade processor designed for complex and demanding workloads. From high-end cloud computing and virtualization to artificial intelligence and machine learning applications, Xeon\u00ae CPUs provide the power, reliability, and flexibility required for today's data centers.</p> <p>Notably, Xeon\u00ae CPUs deliver high compute density and scalability, making them ideal for both small businesses and large enterprises. By choosing Intel\u00ae Xeon\u00ae CPUs, organizations can confidently handle their most demanding computing tasks and foster innovation while maintaining cost-effectiveness and operational efficiency.</p> <p>Benchmarks below run on 4th Gen Intel\u00ae Xeon\u00ae Scalable CPU at FP32 precision.</p> Model Format Status Size (MB) metrics/mAP50-95(B) Inference time (ms/im) YOLOv8n PyTorch \u2705 6.2 0.3709 24.36 YOLOv8n TorchScript \u2705 12.4 0.3704 23.93 YOLOv8n ONNX \u2705 12.2 0.3704 39.86 YOLOv8n OpenVINO \u2705 12.3 0.3704 11.34 YOLOv8s PyTorch \u2705 21.5 0.4471 33.77 YOLOv8s TorchScript \u2705 42.9 0.4472 34.84 YOLOv8s ONNX \u2705 42.8 0.4472 43.23 YOLOv8s OpenVINO \u2705 42.9 0.4471 13.86 YOLOv8m PyTorch \u2705 49.7 0.5013 53.91 YOLOv8m TorchScript \u2705 99.2 0.4999 53.51 YOLOv8m ONNX \u2705 99.0 0.4999 64.16 YOLOv8m OpenVINO \u2705 99.1 0.4996 28.79 YOLOv8l PyTorch \u2705 83.7 0.5293 75.78 YOLOv8l TorchScript \u2705 167.2 0.5268 79.13 YOLOv8l ONNX \u2705 166.8 0.5268 88.45 YOLOv8l OpenVINO \u2705 167.0 0.5263 56.23 YOLOv8x PyTorch \u2705 130.5 0.5404 96.60 YOLOv8x TorchScript \u2705 260.7 0.5371 114.28 YOLOv8x ONNX \u2705 260.4 0.5371 111.02 YOLOv8x OpenVINO \u2705 260.6 0.5371 83.28"},{"location":"integrations/openvino/#intel-core-cpu","title":"Intel Core CPU","text":"<p>The Intel\u00ae Core\u00ae series is a range of high-performance processors by Intel. The lineup includes Core i3 (entry-level), Core i5 (mid-range), Core i7 (high-end), and Core i9 (extreme performance). Each series caters to different computing needs and budgets, from everyday tasks to demanding professional workloads. With each new generation, improvements are made to performance, energy efficiency, and features.</p> <p>Benchmarks below run on 13th Gen Intel\u00ae Core\u00ae i7-13700H CPU at FP32 precision.</p> Model Format Status Size (MB) metrics/mAP50-95(B) Inference time (ms/im) YOLOv8n PyTorch \u2705 6.2 0.4478 104.61 YOLOv8n TorchScript \u2705 12.4 0.4525 112.39 YOLOv8n ONNX \u2705 12.2 0.4525 28.02 YOLOv8n OpenVINO \u2705 12.3 0.4504 23.53 YOLOv8s PyTorch \u2705 21.5 0.5885 194.83 YOLOv8s TorchScript \u2705 43.0 0.5962 202.01 YOLOv8s ONNX \u2705 42.8 0.5962 65.74 YOLOv8s OpenVINO \u2705 42.9 0.5966 38.66 YOLOv8m PyTorch \u2705 49.7 0.6101 355.23 YOLOv8m TorchScript \u2705 99.2 0.6120 424.78 YOLOv8m ONNX \u2705 99.0 0.6120 173.39 YOLOv8m OpenVINO \u2705 99.1 0.6091 69.80 YOLOv8l PyTorch \u2705 83.7 0.6591 593.00 YOLOv8l TorchScript \u2705 167.2 0.6580 697.54 YOLOv8l ONNX \u2705 166.8 0.6580 342.15 YOLOv8l OpenVINO \u2705 167.0 0.0708 117.69 YOLOv8x PyTorch \u2705 130.5 0.6651 804.65 YOLOv8x TorchScript \u2705 260.8 0.6650 921.46 YOLOv8x ONNX \u2705 260.4 0.6650 526.66 YOLOv8x OpenVINO \u2705 260.6 0.6619 158.73"},{"location":"integrations/openvino/#reproduce-our-results","title":"Reproduce Our Results","text":"<p>To reproduce the Ultralytics benchmarks above on all export formats run this code:</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a YOLOv8n PyTorch model\nmodel = YOLO('yolov8n.pt')\n\n# Benchmark YOLOv8n speed and accuracy on the COCO128 dataset for all all export formats\nresults= model.benchmarks(data='coco128.yaml')\n</code></pre> <pre><code># Benchmark YOLOv8n speed and accuracy on the COCO128 dataset for all all export formats\nyolo benchmark model=yolov8n.pt data=coco128.yaml\n</code></pre> <p>Note that benchmarking results might vary based on the exact hardware and software configuration of a system, as well as the current workload of the system at the time the benchmarks are run. For the most reliable results use a dataset with a large number of images, i.e. <code>data='coco128.yaml' (128 val images), or</code>data='coco.yaml'` (5000 val images).</p>"},{"location":"integrations/openvino/#conclusion","title":"Conclusion","text":"<p>The benchmarking results clearly demonstrate the benefits of exporting the YOLOv8 model to the OpenVINO format. Across different models and hardware platforms, the OpenVINO format consistently outperforms other formats in terms of inference speed while maintaining comparable accuracy.</p> <p>For the Intel\u00ae Data Center GPU Flex Series, the OpenVINO format was able to deliver inference speeds almost 10 times faster than the original PyTorch format. On the Xeon CPU, the OpenVINO format was twice as fast as the PyTorch format. The accuracy of the models remained nearly identical across the different formats.</p> <p>The benchmarks underline the effectiveness of OpenVINO as a tool for deploying deep learning models. By converting models to the OpenVINO format, developers can achieve significant performance improvements, making it easier to deploy these models in real-world applications.</p> <p>For more detailed information and instructions on using OpenVINO, refer to the official OpenVINO documentation.</p>"},{"location":"integrations/ray-tune/","title":"Efficient Hyperparameter Tuning with Ray Tune and YOLOv8","text":"<p>Hyperparameter tuning is vital in achieving peak model performance by discovering the optimal set of hyperparameters. This involves running trials with different hyperparameters and evaluating each trial\u2019s performance.</p>"},{"location":"integrations/ray-tune/#accelerate-tuning-with-ultralytics-yolov8-and-ray-tune","title":"Accelerate Tuning with Ultralytics YOLOv8 and Ray Tune","text":"<p>Ultralytics YOLOv8 incorporates Ray Tune for hyperparameter tuning, streamlining the optimization of YOLOv8 model hyperparameters. With Ray Tune, you can utilize advanced search strategies, parallelism, and early stopping to expedite the tuning process.</p>"},{"location":"integrations/ray-tune/#ray-tune","title":"Ray Tune","text":"<p>Ray Tune is a hyperparameter tuning library designed for efficiency and flexibility. It supports various search strategies, parallelism, and early stopping strategies, and seamlessly integrates with popular machine learning frameworks, including Ultralytics YOLOv8.</p>"},{"location":"integrations/ray-tune/#integration-with-weights-biases","title":"Integration with Weights &amp; Biases","text":"<p>YOLOv8 also allows optional integration with Weights &amp; Biases for monitoring the tuning process.</p>"},{"location":"integrations/ray-tune/#installation","title":"Installation","text":"<p>To install the required packages, run:</p> <p>Installation</p> CLI <pre><code># Install and update Ultralytics and Ray Tune packages\npip install -U ultralytics \"ray[tune]\"\n\n# Optionally install W&amp;B for logging\npip install wandb\n</code></pre>"},{"location":"integrations/ray-tune/#usage","title":"Usage","text":"<p>Usage</p> Python <pre><code>from ultralytics import YOLO\n\n# Load a YOLOv8n model\nmodel = YOLO('yolov8n.pt')\n\n# Start tuning hyperparameters for YOLOv8n training on the COCO8 dataset\nresult_grid = model.tune(data='coco8.yaml', use_ray=True)\n</code></pre>"},{"location":"integrations/ray-tune/#tune-method-parameters","title":"<code>tune()</code> Method Parameters","text":"<p>The <code>tune()</code> method in YOLOv8 provides an easy-to-use interface for hyperparameter tuning with Ray Tune. It accepts several arguments that allow you to customize the tuning process. Below is a detailed explanation of each parameter:</p> Parameter Type Description Default Value <code>data</code> <code>str</code> The dataset configuration file (in YAML format) to run the tuner on. This file should specify the training and validation data paths, as well as other dataset-specific settings. <code>space</code> <code>dict, optional</code> A dictionary defining the hyperparameter search space for Ray Tune. Each key corresponds to a hyperparameter name, and the value specifies the range of values to explore during tuning. If not provided, YOLOv8 uses a default search space with various hyperparameters. <code>grace_period</code> <code>int, optional</code> The grace period in epochs for the ASHA scheduler in Ray Tune. The scheduler will not terminate any trial before this number of epochs, allowing the model to have some minimum training before making a decision on early stopping. 10 <code>gpu_per_trial</code> <code>int, optional</code> The number of GPUs to allocate per trial during tuning. This helps manage GPU usage, particularly in multi-GPU environments. If not provided, the tuner will use all available GPUs. None <code>iterations</code> <code>int, optional</code> The maximum number of trials to run during tuning. This parameter helps control the total number of hyperparameter combinations tested, ensuring the tuning process does not run indefinitely. 10 <code>**train_args</code> <code>dict, optional</code> Additional arguments to pass to the <code>train()</code> method during tuning. These arguments can include settings like the number of training epochs, batch size, and other training-specific configurations. {} <p>By customizing these parameters, you can fine-tune the hyperparameter optimization process to suit your specific needs and available computational resources.</p>"},{"location":"integrations/ray-tune/#default-search-space-description","title":"Default Search Space Description","text":"<p>The following table lists the default search space parameters for hyperparameter tuning in YOLOv8 with Ray Tune. Each parameter has a specific value range defined by <code>tune.uniform()</code>.</p> Parameter Value Range Description <code>lr0</code> <code>tune.uniform(1e-5, 1e-1)</code> Initial learning rate <code>lrf</code> <code>tune.uniform(0.01, 1.0)</code> Final learning rate factor <code>momentum</code> <code>tune.uniform(0.6, 0.98)</code> Momentum <code>weight_decay</code> <code>tune.uniform(0.0, 0.001)</code> Weight decay <code>warmup_epochs</code> <code>tune.uniform(0.0, 5.0)</code> Warmup epochs <code>warmup_momentum</code> <code>tune.uniform(0.0, 0.95)</code> Warmup momentum <code>box</code> <code>tune.uniform(0.02, 0.2)</code> Box loss weight <code>cls</code> <code>tune.uniform(0.2, 4.0)</code> Class loss weight <code>hsv_h</code> <code>tune.uniform(0.0, 0.1)</code> Hue augmentation range <code>hsv_s</code> <code>tune.uniform(0.0, 0.9)</code> Saturation augmentation range <code>hsv_v</code> <code>tune.uniform(0.0, 0.9)</code> Value (brightness) augmentation range <code>degrees</code> <code>tune.uniform(0.0, 45.0)</code> Rotation augmentation range (degrees) <code>translate</code> <code>tune.uniform(0.0, 0.9)</code> Translation augmentation range <code>scale</code> <code>tune.uniform(0.0, 0.9)</code> Scaling augmentation range <code>shear</code> <code>tune.uniform(0.0, 10.0)</code> Shear augmentation range (degrees) <code>perspective</code> <code>tune.uniform(0.0, 0.001)</code> Perspective augmentation range <code>flipud</code> <code>tune.uniform(0.0, 1.0)</code> Vertical flip augmentation probability <code>fliplr</code> <code>tune.uniform(0.0, 1.0)</code> Horizontal flip augmentation probability <code>mosaic</code> <code>tune.uniform(0.0, 1.0)</code> Mosaic augmentation probability <code>mixup</code> <code>tune.uniform(0.0, 1.0)</code> Mixup augmentation probability <code>copy_paste</code> <code>tune.uniform(0.0, 1.0)</code> Copy-paste augmentation probability"},{"location":"integrations/ray-tune/#custom-search-space-example","title":"Custom Search Space Example","text":"<p>In this example, we demonstrate how to use a custom search space for hyperparameter tuning with Ray Tune and YOLOv8. By providing a custom search space, you can focus the tuning process on specific hyperparameters of interest.</p> <p>Usage</p> <pre><code>from ultralytics import YOLO\n\n# Define a YOLO model\nmodel = YOLO(\"yolov8n.pt\")\n\n# Run Ray Tune on the model\nresult_grid = model.tune(data=\"coco128.yaml\",\n                         space={\"lr0\": tune.uniform(1e-5, 1e-1)},\n                         epochs=50,\n                         use_ray=True)\n</code></pre> <p>In the code snippet above, we create a YOLO model with the \"yolov8n.pt\" pretrained weights. Then, we call the <code>tune()</code> method, specifying the dataset configuration with \"coco128.yaml\". We provide a custom search space for the initial learning rate <code>lr0</code> using a dictionary with the key \"lr0\" and the value <code>tune.uniform(1e-5, 1e-1)</code>. Finally, we pass additional training arguments, such as the number of epochs directly to the tune method as <code>epochs=50</code>.</p>"},{"location":"integrations/ray-tune/#processing-ray-tune-results","title":"Processing Ray Tune Results","text":"<p>After running a hyperparameter tuning experiment with Ray Tune, you might want to perform various analyses on the obtained results. This guide will take you through common workflows for processing and analyzing these results.</p>"},{"location":"integrations/ray-tune/#loading-tune-experiment-results-from-a-directory","title":"Loading Tune Experiment Results from a Directory","text":"<p>After running the tuning experiment with <code>tuner.fit()</code>, you can load the results from a directory. This is useful, especially if you're performing the analysis after the initial training script has exited.</p> <pre><code>experiment_path = f\"{storage_path}/{exp_name}\"\nprint(f\"Loading results from {experiment_path}...\")\n\nrestored_tuner = tune.Tuner.restore(experiment_path, trainable=train_mnist)\nresult_grid = restored_tuner.get_results()\n</code></pre>"},{"location":"integrations/ray-tune/#basic-experiment-level-analysis","title":"Basic Experiment-Level Analysis","text":"<p>Get an overview of how trials performed. You can quickly check if there were any errors during the trials.</p> <pre><code>if result_grid.errors:\n    print(\"One or more trials failed!\")\nelse:\n    print(\"No errors!\")\n</code></pre>"},{"location":"integrations/ray-tune/#basic-trial-level-analysis","title":"Basic Trial-Level Analysis","text":"<p>Access individual trial hyperparameter configurations and the last reported metrics.</p> <pre><code>for i, result in enumerate(result_grid):\n    print(f\"Trial #{i}: Configuration: {result.config}, Last Reported Metrics: {result.metrics}\")\n</code></pre>"},{"location":"integrations/ray-tune/#plotting-the-entire-history-of-reported-metrics-for-a-trial","title":"Plotting the Entire History of Reported Metrics for a Trial","text":"<p>You can plot the history of reported metrics for each trial to see how the metrics evolved over time.</p> <pre><code>import matplotlib.pyplot as plt\n\nfor result in result_grid:\n    plt.plot(result.metrics_dataframe[\"training_iteration\"], result.metrics_dataframe[\"mean_accuracy\"], label=f\"Trial {i}\")\n\nplt.xlabel('Training Iterations')\nplt.ylabel('Mean Accuracy')\nplt.legend()\nplt.show()\n</code></pre>"},{"location":"integrations/ray-tune/#summary","title":"Summary","text":"<p>In this documentation, we covered common workflows to analyze the results of experiments run with Ray Tune using Ultralytics. The key steps include loading the experiment results from a directory, performing basic experiment-level and trial-level analysis and plotting metrics.</p> <p>Explore further by looking into Ray Tune\u2019s Analyze Results docs page to get the most out of your hyperparameter tuning experiments.</p>"},{"location":"integrations/roboflow/","title":"Roboflow","text":"<p>Roboflow has everything you need to build and deploy computer vision models. Connect Roboflow at any step in your pipeline with APIs and SDKs, or use the end-to-end interface to automate the entire process from image to inference. Whether you\u2019re in need of data labeling, model training, or model deployment, Roboflow gives you building blocks to bring custom computer vision solutions to your project.</p> <p>Licensing</p> <p>Ultralytics offers two licensing options:</p> <ul> <li>The AGPL-3.0 License, an OSI-approved open-source license ideal for students and enthusiasts.</li> <li>The Enterprise License for businesses seeking to incorporate our AI models into their products and services.</li> </ul> <p>For more details see Ultralytics Licensing.</p> <p>In this guide, we are going to showcase how to find, label, and organize data for use in training a custom Ultralytics YOLOv8 model. Use the table of contents below to jump directly to a specific section:</p> <ul> <li>Gather data for training a custom YOLOv8 model</li> <li>Upload, convert and label data for YOLOv8 format</li> <li>Pre-process and augment data for model robustness</li> <li>Dataset management for YOLOv8</li> <li>Export data in 40+ formats for model training</li> <li>Upload custom YOLOv8 model weights for testing and deployment</li> <li>Gather Data for Training a Custom YOLOv8 Model</li> </ul> <p>Roboflow provides two services that can help you collect data for YOLOv8 models: Universe and Collect.</p> <p>Universe is an online repository with over 250,000 vision datasets totalling over 100 million images.</p> <p> </p> <p>With a free Roboflow account, you can export any dataset available on Universe. To export a dataset, click the \"Download this Dataset\" button on any dataset.</p> <p> </p> <p>For YOLOv8, select \"YOLOv8\" as the export format:</p> <p> </p> <p>Universe also has a page that aggregates all public fine-tuned YOLOv8 models uploaded to Roboflow. You can use this page to explore pre-trained models you can use for testing or for automated data labeling or to prototype with Roboflow inference.</p> <p>If you want to gather images yourself, try Collect, an open source project that allows you to automatically gather images using a webcam on the edge. You can use text or image prompts with Collect to instruct what data should be collected, allowing you to capture only the useful data you need to build your vision model.</p>"},{"location":"integrations/roboflow/#upload-convert-and-label-data-for-yolov8-format","title":"Upload, Convert and Label Data for YOLOv8 Format","text":"<p>Roboflow Annotate is an online annotation tool for use in labeling images for object detection, classification, and segmentation.</p> <p>To label data for a YOLOv8 object detection, instance segmentation, or classification model, first create a project in Roboflow.</p> <p> </p> <p>Next, upload your images, and any pre-existing annotations you have from other tools (using one of the 40+ supported import formats), into Roboflow.</p> <p> </p> <p>Select the batch of images you have uploaded on the Annotate page to which you are taken after uploading images. Then, click \"Start Annotating\" to label images.</p> <p>To label with bounding boxes, press the <code>B</code> key on your keyboard or click the box icon in the sidebar. Click on a point where you want to start your bounding box, then drag to create the box:</p> <p> </p> <p>A pop-up will appear asking you to select a class for your annotation once you have created an annotation.</p> <p>To label with polygons, press the <code>P</code> key on your keyboard, or the polygon icon in the sidebar. With the polygon annotation tool enabled, click on individual points in the image to draw a polygon.</p> <p>Roboflow offers a SAM-based label assistant with which you can label images faster than ever. SAM (Segment Anything Model) is a state-of-the-art computer vision model that can precisely label images. With SAM, you can significantly speed up the image labeling process. Annotating images with polygons becomes as simple as a few clicks, rather than the tedious process of precisely clicking points around an object.</p> <p>To use the label assistant, click the cursor icon in the sidebar, SAM will be loaded for use in your project.</p> <p> </p> <p>Hover over any object in the image and SAM will recommend an annotation. You can hover to find the right place to annotate, then click to create your annotation. To amend your annotation to be more or less specific, you can click inside or outside the annotation SAM has created on the document.</p> <p>You can also add tags to images from the Tags panel in the sidebar. You can apply tags to data from a particular area, taken from a specific camera, and more. You can then use these tags to search through data for images matching a tag and generate versions of a dataset with images that contain a particular tag or set of tags.</p> <p> </p> <p>Models hosted on Roboflow can be used with Label Assist, an automated annotation tool that uses your YOLOv8 model to recommend annotations. To use Label Assist, first upload a YOLOv8 model to Roboflow (see instructions later in the guide). Then, click the magic wand icon in the left sidebar and select your model for use in Label Assist.</p> <p>Choose a model, then click \"Continue\" to enable Label Assist:</p> <p> </p> <p>When you open new images for annotation, Label Assist will trigger and recommend annotations.</p> <p> </p>"},{"location":"integrations/roboflow/#dataset-management-for-yolov8","title":"Dataset Management for YOLOv8","text":"<p>Roboflow provides a suite of tools for understanding computer vision datasets.</p> <p>First, you can use dataset search to find images that meet a semantic text description (i.e. find all images that contain people), or that meet a specified label (i.e. the image is associated with a specific tag). To use dataset search, click \"Dataset\" in the sidebar. Then, input a search query using the search bar and associated filters at the top of the page.</p> <p>For example, the following text query finds images that contain people in a dataset:</p> <p> </p> <p>You can narrow your search to images with a particular tag using the \"Tags\" selector:</p> <p> </p> <p>Before you start training a model with your dataset, we recommend using Roboflow Health Check, a web tool that provides an insight into your dataset and how you can improve the dataset prior to training a vision model.</p> <p>To use Health Check, click the \"Health Check\" sidebar link. A list of statistics will appear that show the average size of images in your dataset, class balance, a heatmap of where annotations are in your images, and more.</p> <p> </p> <p>Health Check may recommend changes to help enhance dataset performance. For example, the class balance feature may show that there is an imbalance in labels that, if solved, may boost performance or your model.</p>"},{"location":"integrations/roboflow/#export-data-in-40-formats-for-model-training","title":"Export Data in 40+ Formats for Model Training","text":"<p>To export your data, you will need a dataset version. A version is a state of your dataset frozen-in-time. To create a version, first click \"Versions\" in the sidebar. Then, click the \"Create New Version\" button. On this page, you will be able to choose augmentations and preprocessing steps to apply to your dataset:</p> <p> </p> <p>For each augmentation you select, a pop-up will appear allowing you to tune the augmentation to your needs. Here is an example of tuning a brightness augmentation within specified parameters:</p> <p> </p> <p>When your dataset version has been generated, you can export your data into a range of formats. Click the \"Export Dataset\" button on your dataset version page to export your data:</p> <p> </p> <p>You are now ready to train YOLOv8 on a custom dataset. Follow this written guide and YouTube video for step-by-step instructions or refer to the Ultralytics documentation.</p>"},{"location":"integrations/roboflow/#upload-custom-yolov8-model-weights-for-testing-and-deployment","title":"Upload Custom YOLOv8 Model Weights for Testing and Deployment","text":"<p>Roboflow offers an infinitely scalable API for deployed models and SDKs for use with NVIDIA Jetsons, Luxonis OAKs, Raspberry Pis, GPU-based devices, and more.</p> <p>You can deploy YOLOv8 models by uploading YOLOv8 weights to Roboflow. You can do this in a few lines of Python code. Create a new Python file and add the following code:</p> <pre><code>import roboflow  # install with 'pip install roboflow'\n\nroboflow.login()\n\nrf = roboflow.Roboflow()\n\nproject = rf.workspace(WORKSPACE_ID).project(\"football-players-detection-3zvbc\")\ndataset = project.version(VERSION).download(\"yolov8\")\n\nproject.version(dataset.version).deploy(model_type=\"yolov8\", model_path=f\"{HOME}/runs/detect/train/\")\n</code></pre> <p>In this code, replace the project ID and version ID with the values for your account and project. Learn how to retrieve your Roboflow API key.</p> <p>When you run the code above, you will be asked to authenticate. Then, your model will be uploaded and an API will be created for your project. This process can take up to 30 minutes to complete.</p> <p>To test your model and find deployment instructions for supported SDKs, go to the \"Deploy\" tab in the Roboflow sidebar. At the top of this page, a widget will appear with which you can test your model. You can use your webcam for live testing or upload images or videos.</p> <p> </p> <p>You can also use your uploaded model as a labeling assistant. This feature uses your trained model to recommend annotations on images uploaded to Roboflow.</p>"},{"location":"integrations/roboflow/#how-to-evaluate-yolov8-models","title":"How to Evaluate YOLOv8 Models","text":"<p>Roboflow provides a range of features for use in evaluating models.</p> <p>Once you have uploaded a model to Roboflow, you can access our model evaluation tool, which provides a confusion matrix showing the performance of your model as well as an interactive vector analysis plot. These features can help you find opportunities to improve your model.</p> <p>To access a confusion matrix, go to your model page on the Roboflow dashboard, then click \"View Detailed Evaluation\":</p> <p> </p> <p>A pop-up will appear showing a confusion matrix:</p> <p> </p> <p>Hover over a box on the confusion matrix to see the value associated with the box. Click on a box to see images in the respective category. Click on an image to view the model predictions and ground truth data associated with that image.</p> <p>For more insights, click Vector Analysis. This will show a scatter plot of the images in your dataset, calculated using CLIP. The closer images are in the plot, the more similar they are, semantically. Each image is represented as a dot with a color between white and red. The more red the dot, the worse the model performed.</p> <p> </p> <p>You can use Vector Analysis to:</p> <ul> <li>Find clusters of images;</li> <li>Identify clusters where the model performs poorly, and;</li> <li>Visualize commonalities between images on which the model performs poorly.</li> </ul>"},{"location":"integrations/roboflow/#learning-resources","title":"Learning Resources","text":"<p>Want to learn more about using Roboflow for creating YOLOv8 models? The following resources may be helpful in your work.</p> <ul> <li>Train YOLOv8 on a Custom Dataset: Follow our interactive notebook that shows you how to train a YOLOv8 model on a custom dataset.</li> <li>Autodistill: Use large foundation vision models to label data for specific models. You can label images for use in training YOLOv8 classification, detection, and segmentation models with Autodistill.</li> <li>Supervision: A Python package with helpful utilities for use in working with computer vision models. You can use supervision to filter detections, compute confusion matrices, and more, all in a few lines of Python code.</li> <li>Roboflow Blog: The Roboflow Blog features over 500 articles on computer vision, covering topics from how to train a YOLOv8 model to annotation best practices.</li> <li>Roboflow YouTube channel: Browse dozens of in-depth computer vision guides on our YouTube channel, covering topics from training YOLOv8 models to automated image labeling.</li> </ul>"},{"location":"integrations/roboflow/#project-showcase","title":"Project Showcase","text":"<p>Below are a few of the many pieces of feedback we have received for using YOLOv8 and Roboflow together to create computer vision models.</p> <p> </p>"},{"location":"integrations/tensorboard/","title":"Gain Visual Insights with YOLOv8\u2019s Integration with TensorBoard","text":"<p>Understanding and fine-tuning computer vision models like Ultralytics\u2019 YOLOv8 becomes more straightforward when you take a closer look at their training processes. Model training visualization helps with getting insights into the model's learning patterns, performance metrics, and overall behavior. YOLOv8's integration with TensorBoard makes this process of visualization and analysis easier and enables more efficient and informed adjustments to the model.</p> <p>This guide covers how to use TensorBoard with YOLOv8. You'll learn about various visualizations, from tracking metrics to analyzing model graphs. These tools will help you understand your YOLOv8 model's performance better.</p>"},{"location":"integrations/tensorboard/#tensorboard","title":"TensorBoard","text":"<p>TensorBoard, TensorFlow's visualization toolkit, is essential for machine learning experimentation. TensorBoard features a range of visualization tools, crucial for monitoring machine learning models. These tools include tracking key metrics like loss and accuracy, visualizing model graphs, and viewing histograms of weights and biases over time. It also provides capabilities for projecting embeddings to lower-dimensional spaces and displaying multimedia data.</p>"},{"location":"integrations/tensorboard/#yolov8-training-with-tensorboard","title":"YOLOv8 Training with TensorBoard","text":"<p>Using TensorBoard while training YOLOv8 models is straightforward and offers significant benefits.</p>"},{"location":"integrations/tensorboard/#installation","title":"Installation","text":"<p>To install the required package, run:</p> <p>Installation</p> CLI <pre><code># Install the required package for YOLOv8 and Tensorboard\npip install ultralytics\n</code></pre> <p>TensorBoard is conveniently pre-installed with YOLOv8, eliminating the need for additional setup for visualization purposes.</p> <p>For detailed instructions and best practices related to the installation process, be sure to check our YOLOv8 Installation guide. While installing the required packages for YOLOv8, if you encounter any difficulties, consult our Common Issues guide for solutions and tips.</p>"},{"location":"integrations/tensorboard/#configuring-tensorboard-for-google-collab","title":"Configuring TensorBoard for Google Collab","text":"<p>When using Google Colab, it's important to set up TensorBoard before starting your training code:</p> <p>Configure TensorBoard for Google Collab</p> Python <pre><code>%load_ext tensorboard\n%tensorboard --logdir path/to/runs\n</code></pre>"},{"location":"integrations/tensorboard/#usage","title":"Usage","text":"<p>Before diving into the usage instructions, be sure to check out the range of YOLOv8 models offered by Ultralytics. This will help you choose the most appropriate model for your project requirements.</p> <p>Usage</p> Python <p>```python</p> <p>from ultralytics import YOLO</p> <p># Load a pre-trained model    model = YOLO('yolov8n.pt')</p> <p># Train the model    results = model.train(data='coco128.yaml', epochs=100, imgsz=640)    ```</p> <p>Upon running the usage code snippet above, you can expect the following output:</p> <pre><code>TensorBoard: Start with 'tensorboard --logdir path_to_your_tensorboard_logs', view at http://localhost:6006/\n</code></pre> <p>This output indicates that TensorBoard is now actively monitoring your YOLOv8 training session. You can access the TensorBoard dashboard by visiting the provided URL (http://localhost:6006/) to view real-time training metrics and model performance. For users working in Google Colab, the TensorBoard will be displayed in the same cell where you executed the TensorBoard configuration commands.</p> <p>For more information related to the model training process, be sure to check our YOLOv8 Model Training guide. If you are interested in learning more about logging, checkpoints, plotting, and file management, read our usage guide on configuration.</p>"},{"location":"integrations/tensorboard/#understanding-your-tensorboard-for-yolov8-training","title":"Understanding Your TensorBoard for YOLOv8 Training","text":"<p>Now, let\u2019s focus on understanding the various features and components of TensorBoard in the context of YOLOv8 training. The three key sections of the TensorBoard are Time Series, Scalars, and Graphs.</p>"},{"location":"integrations/tensorboard/#time-series","title":"Time Series","text":"<p>The Time Series feature in the TensorBoard offers a dynamic and detailed perspective of various training metrics over time for YOLOv8 models. It focuses on the progression and trends of metrics across training epochs. Here's an example of what you can expect to see.</p> <p></p>"},{"location":"integrations/tensorboard/#key-features-of-time-series-in-tensorboard","title":"Key Features of Time Series in TensorBoard","text":"<ul> <li> <p>Filter Tags and Pinned Cards: This functionality allows users to filter specific metrics and pin cards for quick comparison and access. It's particularly useful for focusing on specific aspects of the training process.</p> </li> <li> <p>Detailed Metric Cards: Time Series divides metrics into different categories like learning rate (lr), training (train), and validation (val) metrics, each represented by individual cards.</p> </li> <li> <p>Graphical Display: Each card in the Time Series section shows a detailed graph of a specific metric over the course of training. This visual representation aids in identifying trends, patterns, or anomalies in the training process.</p> </li> <li> <p>In-Depth Analysis: Time Series provides an in-depth analysis of each metric. For instance, different learning rate segments are shown, offering insights into how adjustments in learning rate impact the model's learning curve.</p> </li> </ul>"},{"location":"integrations/tensorboard/#importance-of-time-series-in-yolov8-training","title":"Importance of Time Series in YOLOv8 Training","text":"<p>The Time Series section is essential for a thorough analysis of the YOLOv8 model's training progress. It lets you track the metrics in real time so you can promptly identify and solve issues. It also offers a detailed view of each metric's progression, which is crucial for fine-tuning the model and enhancing its performance.</p>"},{"location":"integrations/tensorboard/#scalars","title":"Scalars","text":"<p>Scalars in the TensorBoard are crucial for plotting and analyzing simple metrics like loss and accuracy during the training of YOLOv8 models. They offer a clear and concise view of how these metrics evolve with each training epoch, providing insights into the model's learning effectiveness and stability. Here's an example of what you can expect to see.</p> <p></p>"},{"location":"integrations/tensorboard/#key-features-of-scalars-in-tensorboard","title":"Key Features of Scalars in TensorBoard","text":"<ul> <li> <p>Learning Rate (lr) Tags: These tags show the variations in the learning rate across different segments (e.g., <code>pg0</code>, <code>pg1</code>, <code>pg2</code>). This helps us understand the impact of learning rate adjustments on the training process.</p> </li> <li> <p>Metrics Tags: Scalars include performance indicators such as:</p> <ul> <li> <p><code>mAP50 (B)</code>: Mean Average Precision at 50% Intersection over Union (IoU), crucial for assessing object detection accuracy.</p> </li> <li> <p><code>mAP50-95 (B)</code>: Mean Average Precision calculated over a range of IoU thresholds, offering a more comprehensive evaluation of accuracy.</p> </li> <li> <p><code>Precision (B)</code>: Indicates the ratio of correctly predicted positive observations, key to understanding prediction accuracy.</p> </li> <li> <p><code>Recall (B)</code>: Important for models where missing a detection is significant, this metric measures the ability to detect all relevant instances.</p> </li> <li> <p>To learn more about the different metrics, read our guide on performance metrics.</p> </li> </ul> </li> <li> <p>Training and Validation Tags (<code>train</code>, <code>val</code>): These tags display metrics specifically for the training and validation datasets, allowing for a comparative analysis of model performance across different data sets.</p> </li> </ul>"},{"location":"integrations/tensorboard/#importance-of-monitoring-scalars","title":"Importance of Monitoring Scalars","text":"<p>Observing scalar metrics is crucial for fine-tuning the YOLOv8 model. Variations in these metrics, such as spikes or irregular patterns in loss graphs, can highlight potential issues such as overfitting, underfitting, or inappropriate learning rate settings. By closely monitoring these scalars, you can make informed decisions to optimize the training process, ensuring that the model learns effectively and achieves the desired performance.</p>"},{"location":"integrations/tensorboard/#difference-between-scalars-and-time-series","title":"Difference Between Scalars and Time Series","text":"<p>While both Scalars and Time Series in TensorBoard are used for tracking metrics, they serve slightly different purposes. Scalars focus on plotting simple metrics such as loss and accuracy as scalar values. They provide a high-level overview of how these metrics change with each training epoch. While, the time-series section of the TensorBoard offers a more detailed timeline view of various metrics. It is particularly useful for monitoring the progression and trends of metrics over time, providing a deeper dive into the specifics of the training process.</p>"},{"location":"integrations/tensorboard/#graphs","title":"Graphs","text":"<p>The Graphs section of the TensorBoard visualizes the computational graph of the YOLOv8 model, showing how operations and data flow within the model. It's a powerful tool for understanding the model's structure, ensuring that all layers are connected correctly, and for identifying any potential bottlenecks in data flow. Here's an example of what you can expect to see.</p> <p></p> <p>Graphs are particularly useful for debugging the model, especially in complex architectures typical in deep learning models like YOLOv8. They help in verifying layer connections and the overall design of the model.</p>"},{"location":"integrations/tensorboard/#summary","title":"Summary","text":"<p>This guide aims to help you use TensorBoard with YOLOv8 for visualization and analysis of machine learning model training. It focuses on explaining how key TensorBoard features can provides insights into training metrics and model performance during YOLOv8 training sessions.</p> <p>For a more detailed exploration of these features and effective utilization strategies, you can refer to TensorFlow\u2019s official TensorBoard documentation and their GitHub repository.</p> <p>Want to learn more about the various integrations of Ultralytics? Check out the Ultralytics integrations guide page to see what other exciting capabilities are waiting to be discovered!</p>"},{"location":"integrations/weights-biases/","title":"Enhancing YOLOv8 Experiment Tracking and Visualization with Weights &amp; Biases","text":"<p>Object detection models like Ultralytics YOLOv8 have become integral to many computer vision applications. However, training, evaluating, and deploying these complex models introduces several challenges. Tracking key training metrics, comparing model variants, analyzing model behavior, and detecting issues require substantial instrumentation and experiment management.</p> <p>This guide showcases Ultralytics YOLOv8 integration with Weights &amp; Biases\u2019 for enhanced experiment tracking, model-checkpointing, and visualization of model performance. It also includes instructions for setting up the integration, training, fine-tuning, and visualizing results using Weights &amp; Biases\u2019 interactive features.</p>"},{"location":"integrations/weights-biases/#weights-biases","title":"Weights &amp; Biases","text":"<p>Weights &amp; Biases is a cutting-edge MLOps platform designed for tracking, visualizing, and managing machine learning experiments. It features automatic logging of training metrics for full experiment reproducibility, an interactive UI for streamlined data analysis, and efficient model management tools for deploying across various environments.</p>"},{"location":"integrations/weights-biases/#yolov8-training-with-weights-biases","title":"YOLOv8 Training with Weights &amp; Biases","text":"<p>You can use Weights &amp; Biases to bring efficiency and automation to your YOLOv8 training process.</p>"},{"location":"integrations/weights-biases/#installation","title":"Installation","text":"<p>To install the required packages, run:</p> <p>Installation</p> CLI <pre><code># Install the required packages for YOLOv8 and Weights &amp; Biases\npip install --upgrade ultralytics==8.0.186 wandb\n</code></pre> <p>For detailed instructions and best practices related to the installation process, be sure to check our YOLOv8 Installation guide. While installing the required packages for YOLOv8, if you encounter any difficulties, consult our Common Issues guide for solutions and tips.</p>"},{"location":"integrations/weights-biases/#configuring-weights-biases","title":"Configuring Weights &amp; Biases","text":"<p>After installing the necessary packages, the next step is to set up your Weights &amp; Biases environment. This includes creating a Weights &amp; Biases account and obtaining the necessary API key for a smooth connection between your development environment and the W&amp;B platform.</p> <p>Start by initializing the Weights &amp; Biases environment in your workspace. You can do this by running the following command and following the prompted instructions.</p> <p>Initial SDK Setup</p> CLI <pre><code># Initialize your Weights &amp; Biases environment\nimport wandb\nwandb.login()\n</code></pre> <p>Navigate to the Weights &amp; Biases authorization page to create and retrieve your API key. Use this key to authenticate your environment with W&amp;B.</p>"},{"location":"integrations/weights-biases/#usage-training-yolov8-with-weights-biases","title":"Usage: Training YOLOv8 with Weights &amp; Biases","text":"<p>Before diving into the usage instructions for YOLOv8 model training with Weights &amp; Biases, be sure to check out the range of YOLOv8 models offered by Ultralytics. This will help you choose the most appropriate model for your project requirements.</p> <p>Usage: Training YOLOv8 with Weights &amp; Biases</p> Python <pre><code>from ultralytics import YOLO\nfrom wandb.integration.ultralytics import add_wandb_callback\nimport wandb\n\n# Step 1: Initialize a Weights &amp; Biases run\nwandb.init(project=\"ultralytics\", job_type=\"training\")\n\n# Step 2: Define the YOLOv8 Model and Dataset\nmodel_name = \"yolov8n\"\ndataset_name = \"coco128.yaml\"\nmodel = YOLO(f\"{model_name}.pt\")\n\n# Step 3: Add W&amp;B Callback for Ultralytics\nadd_wandb_callback(model, enable_model_checkpointing=True)\n\n# Step 4: Train and Fine-Tune the Model\nmodel.train(project=\"ultralytics\", data=dataset_name, epochs=5, imgsz=640)\n\n# Step 5: Validate the Model\nmodel.val()\n\n# Step 6: Perform Inference and Log Results\nmodel([\"path/to/image1\", \"path/to/image2\"])\n\n# Step 7: Finalize the W&amp;B Run\nwandb.finish()\n</code></pre>"},{"location":"integrations/weights-biases/#understanding-the-code","title":"Understanding the Code","text":"<p>Let\u2019s understand the steps showcased in the usage code snippet above.</p> <ul> <li> <p>Step 1: Initialize a Weights &amp; Biases Run: Start by initializing a Weights &amp; Biases run, specifying the project name and the job type. This run will track and manage the training and validation processes of your model.</p> </li> <li> <p>Step 2: Define the YOLOv8 Model and Dataset: Specify the model variant and the dataset you wish to use. The YOLO model is then initialized with the specified model file.</p> </li> <li> <p>Step 3: Add Weights &amp; Biases Callback for Ultralytics: This step is crucial as it enables the automatic logging of training metrics and validation results to Weights &amp; Biases, providing a detailed view of the model's performance.</p> </li> <li> <p>Step 4: Train and Fine-Tune the Model: Begin training the model with the specified dataset, number of epochs, and image size. The training process includes logging of metrics and predictions at the end of each epoch, offering a comprehensive view of the model's learning progress.</p> </li> <li> <p>Step 5: Validate the Model: After training, the model is validated. This step is crucial for assessing the model's performance on unseen data and ensuring its generalizability.</p> </li> <li> <p>Step 6: Perform Inference and Log Results: The model performs predictions on specified images. These predictions, along with visual overlays and insights, are automatically logged in a W&amp;B Table for interactive exploration.</p> </li> <li> <p>Step 7: Finalize the W&amp;B Run: This step marks the end of data logging and saves the final state of your model's training and validation process in the W&amp;B dashboard.</p> </li> </ul>"},{"location":"integrations/weights-biases/#understanding-the-output","title":"Understanding the Output","text":"<p>Upon running the usage code snippet above, you can expect the following key outputs:</p> <ul> <li>The setup of a new run with its unique ID, indicating the start of the training process.</li> <li>A concise summary of the model\u2019s structure, including the number of layers and parameters.</li> <li>Regular updates on important metrics such as box loss, cls loss, dfl loss, precision, recall, and mAP scores during each training epoch.</li> <li>At the end of training, detailed metrics including the model's inference speed, and overall accuracy metrics are displayed.</li> <li>Links to the Weights &amp; Biases dashboard for in-depth analysis and visualization of the training process, along with information on local log file locations.</li> </ul>"},{"location":"integrations/weights-biases/#viewing-the-weights-biases-dashboard","title":"Viewing the Weights &amp; Biases Dashboard","text":"<p>After running the usage code snippet, you can access the Weights &amp; Biases (W&amp;B) dashboard through the provided link in the output. This dashboard offers a comprehensive view of your model's training process with YOLOv8.</p>"},{"location":"integrations/weights-biases/#key-features-of-the-weights-biases-dashboard","title":"Key Features of the Weights &amp; Biases Dashboard","text":"<ul> <li> <p>Real-Time Metrics Tracking: Observe metrics like loss, accuracy, and validation scores as they evolve during the training, offering immediate insights for model tuning.</p> <p>Take a look at how the experiments are tracked using Weights &amp; Biases.</p> </li> <li> <p>Hyperparameter Optimization: Weights &amp; Biases aids in fine-tuning critical parameters such as learning rate, batch size, and more, enhancing the performance of YOLOv8.</p> </li> <li> <p>Comparative Analysis: The platform allows side-by-side comparisons of different training runs, essential for assessing the impact of various model configurations.</p> </li> <li> <p>Visualization of Training Progress: Graphical representations of key metrics provide an intuitive understanding of the model's performance across epochs.</p> <p>Take a look at how Weights &amp; Biases helps you visualize validation results.</p> </li> <li> <p>Resource Monitoring: Keep track of CPU, GPU, and memory usage to optimize the efficiency of the training process.</p> </li> <li> <p>Model Artifacts Management: Access and share model checkpoints, facilitating easy deployment and collaboration.</p> </li> <li> <p>Viewing Inference Results with Image Overlay: Visualize the prediction results on images using interactive overlays in Weights &amp; Biases, providing a clear and detailed view of model performance on real-world data. For more detailed information on Weights &amp; Biases\u2019 image overlay capabilities, check out this link.</p> <p>Take a look at how Weights &amp; Biases\u2019 image overlays helps visualize model inferences.</p> </li> </ul> <p>By using these features, you can effectively track, analyze, and optimize your YOLOv8 model's training, ensuring the best possible performance and efficiency.</p>"},{"location":"integrations/weights-biases/#summary","title":"Summary","text":"<p>This guide helped you explore Ultralytics\u2019 YOLOv8 integration with Weights &amp; Biases. It illustrates the ability of this integration to efficiently track and visualize model training and prediction results.</p> <p>For further details on usage, visit Weights &amp; Biases' official documentation.</p> <p>Also, be sure to check out the Ultralytics integration guide page, to learn more about different exciting integrations.</p>"},{"location":"models/","title":"Models Supported by Ultralytics","text":"<p>Welcome to Ultralytics' model documentation! We offer support for a wide range of models, each tailored to specific tasks like object detection, instance segmentation, image classification, pose estimation, and multi-object tracking. If you're interested in contributing your model architecture to Ultralytics, check out our Contributing Guide.</p>"},{"location":"models/#featured-models","title":"Featured Models","text":"<p>Here are some of the key models supported:</p> <ol> <li>YOLOv3: The third iteration of the YOLO model family, originally by Joseph Redmon, known for its efficient real-time object detection capabilities.</li> <li>YOLOv4: A darknet-native update to YOLOv3, released by Alexey Bochkovskiy in 2020.</li> <li>YOLOv5: An improved version of the YOLO architecture by Ultralytics, offering better performance and speed trade-offs compared to previous versions.</li> <li>YOLOv6: Released by Meituan in 2022, and in use in many of the company's autonomous delivery robots.</li> <li>YOLOv7: Updated YOLO models released in 2022 by the authors of YOLOv4.</li> <li>YOLOv8 NEW \ud83d\ude80: The latest version of the YOLO family, featuring enhanced capabilities such as instance segmentation, pose/keypoints estimation, and classification.</li> <li>Segment Anything Model (SAM): Meta's Segment Anything Model (SAM).</li> <li>Mobile Segment Anything Model (MobileSAM): MobileSAM for mobile applications, by Kyung Hee University.</li> <li>Fast Segment Anything Model (FastSAM): FastSAM by Image &amp; Video Analysis Group, Institute of Automation, Chinese Academy of Sciences.</li> <li>YOLO-NAS: YOLO Neural Architecture Search (NAS) Models.</li> <li>Realtime Detection Transformers (RT-DETR): Baidu's PaddlePaddle Realtime Detection Transformer (RT-DETR) models.</li> </ol> <p> Watch: Run Ultralytics YOLO models in just a few lines of code. </p>"},{"location":"models/#getting-started-usage-examples","title":"Getting Started: Usage Examples","text":"<p>This example provides simple YOLO training and inference examples. For full documentation on these and other modes see the Predict, Train, Val and Export docs pages.</p> <p>Note the below example is for YOLOv8 Detect models for object detection. For additional supported tasks see the Segment, Classify and Pose docs.</p> <p>Example</p> PythonCLI <p>PyTorch pretrained <code>*.pt</code> models as well as configuration <code>*.yaml</code> files can be passed to the <code>YOLO()</code>, <code>SAM()</code>, <code>NAS()</code> and <code>RTDETR()</code> classes to create a model instance in Python:</p> <pre><code>from ultralytics import YOLO\n\n# Load a COCO-pretrained YOLOv8n model\nmodel = YOLO('yolov8n.pt')\n\n# Display model information (optional)\nmodel.info()\n\n# Train the model on the COCO8 example dataset for 100 epochs\nresults = model.train(data='coco8.yaml', epochs=100, imgsz=640)\n\n# Run inference with the YOLOv8n model on the 'bus.jpg' image\nresults = model('path/to/bus.jpg')\n</code></pre> <p>CLI commands are available to directly run the models:</p> <pre><code># Load a COCO-pretrained YOLOv8n model and train it on the COCO8 example dataset for 100 epochs\nyolo train model=yolov8n.pt data=coco8.yaml epochs=100 imgsz=640\n\n# Load a COCO-pretrained YOLOv8n model and run inference on the 'bus.jpg' image\nyolo predict model=yolov8n.pt source=path/to/bus.jpg\n</code></pre>"},{"location":"models/#contributing-new-models","title":"Contributing New Models","text":"<p>Interested in contributing your model to Ultralytics? Great! We're always open to expanding our model portfolio.</p> <ol> <li> <p>Fork the Repository: Start by forking the Ultralytics GitHub repository.</p> </li> <li> <p>Clone Your Fork: Clone your fork to your local machine and create a new branch to work on.</p> </li> <li> <p>Implement Your Model: Add your model following the coding standards and guidelines provided in our Contributing Guide.</p> </li> <li> <p>Test Thoroughly: Make sure to test your model rigorously, both in isolation and as part of the pipeline.</p> </li> <li> <p>Create a Pull Request: Once you're satisfied with your model, create a pull request to the main repository for review.</p> </li> <li> <p>Code Review &amp; Merging: After review, if your model meets our criteria, it will be merged into the main repository.</p> </li> </ol> <p>For detailed steps, consult our Contributing Guide.</p>"},{"location":"models/fast-sam/","title":"Fast Segment Anything Model (FastSAM)","text":"<p>The Fast Segment Anything Model (FastSAM) is a novel, real-time CNN-based solution for the Segment Anything task. This task is designed to segment any object within an image based on various possible user interaction prompts. FastSAM significantly reduces computational demands while maintaining competitive performance, making it a practical choice for a variety of vision tasks.</p> <p></p>"},{"location":"models/fast-sam/#overview","title":"Overview","text":"<p>FastSAM is designed to address the limitations of the Segment Anything Model (SAM), a heavy Transformer model with substantial computational resource requirements. The FastSAM decouples the segment anything task into two sequential stages: all-instance segmentation and prompt-guided selection. The first stage uses YOLOv8-seg to produce the segmentation masks of all instances in the image. In the second stage, it outputs the region-of-interest corresponding to the prompt.</p>"},{"location":"models/fast-sam/#key-features","title":"Key Features","text":"<ol> <li> <p>Real-time Solution: By leveraging the computational efficiency of CNNs, FastSAM provides a real-time solution for the segment anything task, making it valuable for industrial applications that require quick results.</p> </li> <li> <p>Efficiency and Performance: FastSAM offers a significant reduction in computational and resource demands without compromising on performance quality. It achieves comparable performance to SAM but with drastically reduced computational resources, enabling real-time application.</p> </li> <li> <p>Prompt-guided Segmentation: FastSAM can segment any object within an image guided by various possible user interaction prompts, providing flexibility and adaptability in different scenarios.</p> </li> <li> <p>Based on YOLOv8-seg: FastSAM is based on YOLOv8-seg, an object detector equipped with an instance segmentation branch. This allows it to effectively produce the segmentation masks of all instances in an image.</p> </li> <li> <p>Competitive Results on Benchmarks: On the object proposal task on MS COCO, FastSAM achieves high scores at a significantly faster speed than SAM on a single NVIDIA RTX 3090, demonstrating its efficiency and capability.</p> </li> <li> <p>Practical Applications: The proposed approach provides a new, practical solution for a large number of vision tasks at a really high speed, tens or hundreds of times faster than current methods.</p> </li> <li> <p>Model Compression Feasibility: FastSAM demonstrates the feasibility of a path that can significantly reduce the computational effort by introducing an artificial prior to the structure, thus opening new possibilities for large model architecture for general vision tasks.</p> </li> </ol>"},{"location":"models/fast-sam/#available-models-supported-tasks-and-operating-modes","title":"Available Models, Supported Tasks, and Operating Modes","text":"<p>This table presents the available models with their specific pre-trained weights, the tasks they support, and their compatibility with different operating modes like Inference, Validation, Training, and Export, indicated by \u2705 emojis for supported modes and \u274c emojis for unsupported modes.</p> Model Type Pre-trained Weights Tasks Supported Inference Validation Training Export FastSAM-s <code>FastSAM-s.pt</code> Instance Segmentation \u2705 \u274c \u274c \u2705 FastSAM-x <code>FastSAM-x.pt</code> Instance Segmentation \u2705 \u274c \u274c \u2705"},{"location":"models/fast-sam/#usage-examples","title":"Usage Examples","text":"<p>The FastSAM models are easy to integrate into your Python applications. Ultralytics provides user-friendly Python API and CLI commands to streamline development.</p>"},{"location":"models/fast-sam/#predict-usage","title":"Predict Usage","text":"<p>To perform object detection on an image, use the <code>predict</code> method as shown below:</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import FastSAM\nfrom ultralytics.models.fastsam import FastSAMPrompt\n\n# Define an inference source\nsource = 'path/to/bus.jpg'\n\n# Create a FastSAM model\nmodel = FastSAM('FastSAM-s.pt')  # or FastSAM-x.pt\n\n# Run inference on an image\neverything_results = model(source, device='cpu', retina_masks=True, imgsz=1024, conf=0.4, iou=0.9)\n\n# Prepare a Prompt Process object\nprompt_process = FastSAMPrompt(source, everything_results, device='cpu')\n\n# Everything prompt\nann = prompt_process.everything_prompt()\n\n# Bbox default shape [0,0,0,0] -&gt; [x1,y1,x2,y2]\nann = prompt_process.box_prompt(bbox=[200, 200, 300, 300])\n\n# Text prompt\nann = prompt_process.text_prompt(text='a photo of a dog')\n\n# Point prompt\n# points default [[0,0]] [[x1,y1],[x2,y2]]\n# point_label default [0] [1,0] 0:background, 1:foreground\nann = prompt_process.point_prompt(points=[[200, 200]], pointlabel=[1])\nprompt_process.plot(annotations=ann, output='./')\n</code></pre> <pre><code># Load a FastSAM model and segment everything with it\nyolo segment predict model=FastSAM-s.pt source=path/to/bus.jpg imgsz=640\n</code></pre> <p>This snippet demonstrates the simplicity of loading a pre-trained model and running a prediction on an image.</p>"},{"location":"models/fast-sam/#val-usage","title":"Val Usage","text":"<p>Validation of the model on a dataset can be done as follows:</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import FastSAM\n\n# Create a FastSAM model\nmodel = FastSAM('FastSAM-s.pt')  # or FastSAM-x.pt\n\n# Validate the model\nresults = model.val(data='coco8-seg.yaml')\n</code></pre> <pre><code># Load a FastSAM model and validate it on the COCO8 example dataset at image size 640\nyolo segment val model=FastSAM-s.pt data=coco8.yaml imgsz=640\n</code></pre> <p>Please note that FastSAM only supports detection and segmentation of a single class of object. This means it will recognize and segment all objects as the same class. Therefore, when preparing the dataset, you need to convert all object category IDs to 0.</p>"},{"location":"models/fast-sam/#fastsam-official-usage","title":"FastSAM official Usage","text":"<p>FastSAM is also available directly from the https://github.com/CASIA-IVA-Lab/FastSAM repository. Here is a brief overview of the typical steps you might take to use FastSAM:</p>"},{"location":"models/fast-sam/#installation","title":"Installation","text":"<ol> <li> <p>Clone the FastSAM repository:    <pre><code>git clone https://github.com/CASIA-IVA-Lab/FastSAM.git\n</code></pre></p> </li> <li> <p>Create and activate a Conda environment with Python 3.9:    <pre><code>conda create -n FastSAM python=3.9\nconda activate FastSAM\n</code></pre></p> </li> <li> <p>Navigate to the cloned repository and install the required packages:    <pre><code>cd FastSAM\npip install -r requirements.txt\n</code></pre></p> </li> <li> <p>Install the CLIP model:    <pre><code>pip install git+https://github.com/openai/CLIP.git\n</code></pre></p> </li> </ol>"},{"location":"models/fast-sam/#example-usage","title":"Example Usage","text":"<ol> <li> <p>Download a model checkpoint.</p> </li> <li> <p>Use FastSAM for inference. Example commands:</p> <ul> <li> <p>Segment everything in an image:   <pre><code>python Inference.py --model_path ./weights/FastSAM.pt --img_path ./images/dogs.jpg\n</code></pre></p> </li> <li> <p>Segment specific objects using text prompt:   <pre><code>python Inference.py --model_path ./weights/FastSAM.pt --img_path ./images/dogs.jpg --text_prompt \"the yellow dog\"\n</code></pre></p> </li> <li> <p>Segment objects within a bounding box (provide box coordinates in xywh format):   <pre><code>python Inference.py --model_path ./weights/FastSAM.pt --img_path ./images/dogs.jpg --box_prompt \"[570,200,230,400]\"\n</code></pre></p> </li> <li> <p>Segment objects near specific points:   <pre><code>python Inference.py --model_path ./weights/FastSAM.pt --img_path ./images/dogs.jpg --point_prompt \"[[520,360],[620,300]]\" --point_label \"[1,0]\"\n</code></pre></p> </li> </ul> </li> </ol> <p>Additionally, you can try FastSAM through a Colab demo or on the HuggingFace web demo for a visual experience.</p>"},{"location":"models/fast-sam/#citations-and-acknowledgements","title":"Citations and Acknowledgements","text":"<p>We would like to acknowledge the FastSAM authors for their significant contributions in the field of real-time instance segmentation:</p> BibTeX <pre><code>@misc{zhao2023fast,\n      title={Fast Segment Anything},\n      author={Xu Zhao and Wenchao Ding and Yongqi An and Yinglong Du and Tao Yu and Min Li and Ming Tang and Jinqiao Wang},\n      year={2023},\n      eprint={2306.12156},\n      archivePrefix={arXiv},\n      primaryClass={cs.CV}\n}\n</code></pre> <p>The original FastSAM paper can be found on arXiv. The authors have made their work publicly available, and the codebase can be accessed on GitHub. We appreciate their efforts in advancing the field and making their work accessible to the broader community.</p>"},{"location":"models/mobile-sam/","title":"MobileSAM (Mobile Segment Anything Model)","text":""},{"location":"models/mobile-sam/#mobile-segment-anything-mobilesam","title":"Mobile Segment Anything (MobileSAM)","text":"<p>The MobileSAM paper is now available on arXiv.</p> <p>A demonstration of MobileSAM running on a CPU can be accessed at this demo link. The performance on a Mac i5 CPU takes approximately 3 seconds. On the Hugging Face demo, the interface and lower-performance CPUs contribute to a slower response, but it continues to function effectively.</p> <p>MobileSAM is implemented in various projects including Grounding-SAM, AnyLabeling, and Segment Anything in 3D.</p> <p>MobileSAM is trained on a single GPU with a 100k dataset (1% of the original images) in less than a day. The code for this training will be made available in the future.</p>"},{"location":"models/mobile-sam/#available-models-supported-tasks-and-operating-modes","title":"Available Models, Supported Tasks, and Operating Modes","text":"<p>This table presents the available models with their specific pre-trained weights, the tasks they support, and their compatibility with different operating modes like Inference, Validation, Training, and Export, indicated by \u2705 emojis for supported modes and \u274c emojis for unsupported modes.</p> Model Type Pre-trained Weights Tasks Supported Inference Validation Training Export MobileSAM <code>mobile_sam.pt</code> Instance Segmentation \u2705 \u274c \u274c \u274c"},{"location":"models/mobile-sam/#adapting-from-sam-to-mobilesam","title":"Adapting from SAM to MobileSAM","text":"<p>Since MobileSAM retains the same pipeline as the original SAM, we have incorporated the original's pre-processing, post-processing, and all other interfaces. Consequently, those currently using the original SAM can transition to MobileSAM with minimal effort.</p> <p>MobileSAM performs comparably to the original SAM and retains the same pipeline except for a change in the image encoder. Specifically, we replace the original heavyweight ViT-H encoder (632M) with a smaller Tiny-ViT (5M). On a single GPU, MobileSAM operates at about 12ms per image: 8ms on the image encoder and 4ms on the mask decoder.</p> <p>The following table provides a comparison of ViT-based image encoders:</p> Image Encoder Original SAM MobileSAM Parameters 611M 5M Speed 452ms 8ms <p>Both the original SAM and MobileSAM utilize the same prompt-guided mask decoder:</p> Mask Decoder Original SAM MobileSAM Parameters 3.876M 3.876M Speed 4ms 4ms <p>Here is the comparison of the whole pipeline:</p> Whole Pipeline (Enc+Dec) Original SAM MobileSAM Parameters 615M 9.66M Speed 456ms 12ms <p>The performance of MobileSAM and the original SAM are demonstrated using both a point and a box as prompts.</p> <p></p> <p></p> <p>With its superior performance, MobileSAM is approximately 5 times smaller and 7 times faster than the current FastSAM. More details are available at the MobileSAM project page.</p>"},{"location":"models/mobile-sam/#testing-mobilesam-in-ultralytics","title":"Testing MobileSAM in Ultralytics","text":"<p>Just like the original SAM, we offer a straightforward testing method in Ultralytics, including modes for both Point and Box prompts.</p>"},{"location":"models/mobile-sam/#model-download","title":"Model Download","text":"<p>You can download the model here.</p>"},{"location":"models/mobile-sam/#point-prompt","title":"Point Prompt","text":"<p>Example</p> Python <pre><code>from ultralytics import SAM\n\n# Load the model\nmodel = SAM('mobile_sam.pt')\n\n# Predict a segment based on a point prompt\nmodel.predict('ultralytics/assets/zidane.jpg', points=[900, 370], labels=[1])\n</code></pre>"},{"location":"models/mobile-sam/#box-prompt","title":"Box Prompt","text":"<p>Example</p> Python <pre><code>from ultralytics import SAM\n\n# Load the model\nmodel = SAM('mobile_sam.pt')\n\n# Predict a segment based on a box prompt\nmodel.predict('ultralytics/assets/zidane.jpg', bboxes=[439, 437, 524, 709])\n</code></pre> <p>We have implemented <code>MobileSAM</code> and <code>SAM</code> using the same API. For more usage information, please see the SAM page.</p>"},{"location":"models/mobile-sam/#citations-and-acknowledgements","title":"Citations and Acknowledgements","text":"<p>If you find MobileSAM useful in your research or development work, please consider citing our paper:</p> BibTeX <pre><code>@article{mobile_sam,\n  title={Faster Segment Anything: Towards Lightweight SAM for Mobile Applications},\n  author={Zhang, Chaoning and Han, Dongshen and Qiao, Yu and Kim, Jung Uk and Bae, Sung Ho and Lee, Seungkyu and Hong, Choong Seon},\n  journal={arXiv preprint arXiv:2306.14289},\n  year={2023}\n}\n</code></pre>"},{"location":"models/rtdetr/","title":"Baidu's RT-DETR: A Vision Transformer-Based Real-Time Object Detector","text":""},{"location":"models/rtdetr/#overview","title":"Overview","text":"<p>Real-Time Detection Transformer (RT-DETR), developed by Baidu, is a cutting-edge end-to-end object detector that provides real-time performance while maintaining high accuracy. It leverages the power of Vision Transformers (ViT) to efficiently process multiscale features by decoupling intra-scale interaction and cross-scale fusion. RT-DETR is highly adaptable, supporting flexible adjustment of inference speed using different decoder layers without retraining. The model excels on accelerated backends like CUDA with TensorRT, outperforming many other real-time object detectors.</p> <p> Overview of Baidu's RT-DETR. The RT-DETR model architecture diagram shows the last three stages of the backbone {S3, S4, S5} as the input to the encoder. The efficient hybrid encoder transforms multiscale features into a sequence of image features through intrascale feature interaction (AIFI) and cross-scale feature-fusion module (CCFM). The IoU-aware query selection is employed to select a fixed number of image features to serve as initial object queries for the decoder. Finally, the decoder with auxiliary prediction heads iteratively optimizes object queries to generate boxes and confidence scores (source).</p>"},{"location":"models/rtdetr/#key-features","title":"Key Features","text":"<ul> <li>Efficient Hybrid Encoder: Baidu's RT-DETR uses an efficient hybrid encoder that processes multiscale features by decoupling intra-scale interaction and cross-scale fusion. This unique Vision Transformers-based design reduces computational costs and allows for real-time object detection.</li> <li>IoU-aware Query Selection: Baidu's RT-DETR improves object query initialization by utilizing IoU-aware query selection. This allows the model to focus on the most relevant objects in the scene, enhancing the detection accuracy.</li> <li>Adaptable Inference Speed: Baidu's RT-DETR supports flexible adjustments of inference speed by using different decoder layers without the need for retraining. This adaptability facilitates practical application in various real-time object detection scenarios.</li> </ul>"},{"location":"models/rtdetr/#pre-trained-models","title":"Pre-trained Models","text":"<p>The Ultralytics Python API provides pre-trained PaddlePaddle RT-DETR models with different scales:</p> <ul> <li>RT-DETR-L: 53.0% AP on COCO val2017, 114 FPS on T4 GPU</li> <li>RT-DETR-X: 54.8% AP on COCO val2017, 74 FPS on T4 GPU</li> </ul>"},{"location":"models/rtdetr/#usage-examples","title":"Usage Examples","text":"<p>This example provides simple RT-DETRR training and inference examples. For full documentation on these and other modes see the Predict, Train, Val and Export docs pages.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import RTDETR\n\n# Load a COCO-pretrained RT-DETR-l model\nmodel = RTDETR('rtdetr-l.pt')\n\n# Display model information (optional)\nmodel.info()\n\n# Train the model on the COCO8 example dataset for 100 epochs\nresults = model.train(data='coco8.yaml', epochs=100, imgsz=640)\n\n# Run inference with the RT-DETR-l model on the 'bus.jpg' image\nresults = model('path/to/bus.jpg')\n</code></pre> <pre><code># Load a COCO-pretrained RT-DETR-l model and train it on the COCO8 example dataset for 100 epochs\nyolo train model=rtdetr-l.pt data=coco8.yaml epochs=100 imgsz=640\n\n# Load a COCO-pretrained RT-DETR-l model and run inference on the 'bus.jpg' image\nyolo predict model=rtdetr-l.pt source=path/to/bus.jpg\n</code></pre>"},{"location":"models/rtdetr/#supported-tasks-and-modes","title":"Supported Tasks and Modes","text":"<p>This table presents the model types, the specific pre-trained weights, the tasks supported by each model, and the various modes (Train , Val, Predict, Export) that are supported, indicated by \u2705 emojis.</p> Model Type Pre-trained Weights Tasks Supported Inference Validation Training Export RT-DETR Large <code>rtdetr-l.pt</code> Object Detection \u2705 \u2705 \u2705 \u2705 RT-DETR Extra-Large <code>rtdetr-x.pt</code> Object Detection \u2705 \u2705 \u2705 \u2705"},{"location":"models/rtdetr/#citations-and-acknowledgements","title":"Citations and Acknowledgements","text":"<p>If you use Baidu's RT-DETR in your research or development work, please cite the original paper:</p> BibTeX <pre><code>@misc{lv2023detrs,\n      title={DETRs Beat YOLOs on Real-time Object Detection},\n      author={Wenyu Lv and Shangliang Xu and Yian Zhao and Guanzhong Wang and Jinman Wei and Cheng Cui and Yuning Du and Qingqing Dang and Yi Liu},\n      year={2023},\n      eprint={2304.08069},\n      archivePrefix={arXiv},\n      primaryClass={cs.CV}\n}\n</code></pre> <p>We would like to acknowledge Baidu and the PaddlePaddle team for creating and maintaining this valuable resource for the computer vision community. Their contribution to the field with the development of the Vision Transformers-based real-time object detector, RT-DETR, is greatly appreciated.</p> <p>Keywords: RT-DETR, Transformer, ViT, Vision Transformers, Baidu RT-DETR, PaddlePaddle, Paddle Paddle RT-DETR, real-time object detection, Vision Transformers-based object detection, pre-trained PaddlePaddle RT-DETR models, Baidu's RT-DETR usage, Ultralytics Python API</p>"},{"location":"models/sam/","title":"Segment Anything Model (SAM)","text":"<p>Welcome to the frontier of image segmentation with the Segment Anything Model, or SAM. This revolutionary model has changed the game by introducing promptable image segmentation with real-time performance, setting new standards in the field.</p>"},{"location":"models/sam/#introduction-to-sam-the-segment-anything-model","title":"Introduction to SAM: The Segment Anything Model","text":"<p>The Segment Anything Model, or SAM, is a cutting-edge image segmentation model that allows for promptable segmentation, providing unparalleled versatility in image analysis tasks. SAM forms the heart of the Segment Anything initiative, a groundbreaking project that introduces a novel model, task, and dataset for image segmentation.</p> <p>SAM's advanced design allows it to adapt to new image distributions and tasks without prior knowledge, a feature known as zero-shot transfer. Trained on the expansive SA-1B dataset, which contains more than 1 billion masks spread over 11 million carefully curated images, SAM has displayed impressive zero-shot performance, surpassing previous fully supervised results in many cases.</p> <p> SA-1B Example images. Dataset images overlaid masks from the newly introduced SA-1B dataset. SA-1B contains 11M diverse, high-resolution, licensed, and privacy protecting images and 1.1B high-quality segmentation masks. These masks were annotated fully automatically by SAM, and as verified by human ratings and numerous experiments, are of high quality and diversity. Images are grouped by number of masks per image for visualization (there are \u223c100 masks per image on average).</p>"},{"location":"models/sam/#key-features-of-the-segment-anything-model-sam","title":"Key Features of the Segment Anything Model (SAM)","text":"<ul> <li>Promptable Segmentation Task: SAM was designed with a promptable segmentation task in mind, allowing it to generate valid segmentation masks from any given prompt, such as spatial or text clues identifying an object.</li> <li>Advanced Architecture: The Segment Anything Model employs a powerful image encoder, a prompt encoder, and a lightweight mask decoder. This unique architecture enables flexible prompting, real-time mask computation, and ambiguity awareness in segmentation tasks.</li> <li>The SA-1B Dataset: Introduced by the Segment Anything project, the SA-1B dataset features over 1 billion masks on 11 million images. As the largest segmentation dataset to date, it provides SAM with a diverse and large-scale training data source.</li> <li>Zero-Shot Performance: SAM displays outstanding zero-shot performance across various segmentation tasks, making it a ready-to-use tool for diverse applications with minimal need for prompt engineering.</li> </ul> <p>For an in-depth look at the Segment Anything Model and the SA-1B dataset, please visit the Segment Anything website and check out the research paper Segment Anything.</p>"},{"location":"models/sam/#available-models-supported-tasks-and-operating-modes","title":"Available Models, Supported Tasks, and Operating Modes","text":"<p>This table presents the available models with their specific pre-trained weights, the tasks they support, and their compatibility with different operating modes like Inference, Validation, Training, and Export, indicated by \u2705 emojis for supported modes and \u274c emojis for unsupported modes.</p> Model Type Pre-trained Weights Tasks Supported Inference Validation Training Export SAM base <code>sam_b.pt</code> Instance Segmentation \u2705 \u274c \u274c \u274c SAM large <code>sam_l.pt</code> Instance Segmentation \u2705 \u274c \u274c \u274c"},{"location":"models/sam/#how-to-use-sam-versatility-and-power-in-image-segmentation","title":"How to Use SAM: Versatility and Power in Image Segmentation","text":"<p>The Segment Anything Model can be employed for a multitude of downstream tasks that go beyond its training data. This includes edge detection, object proposal generation, instance segmentation, and preliminary text-to-mask prediction. With prompt engineering, SAM can swiftly adapt to new tasks and data distributions in a zero-shot manner, establishing it as a versatile and potent tool for all your image segmentation needs.</p>"},{"location":"models/sam/#sam-prediction-example","title":"SAM prediction example","text":"<p>Segment with prompts</p> <p>Segment image with given prompts.</p> Python <pre><code>from ultralytics import SAM\n\n# Load a model\nmodel = SAM('sam_b.pt')\n\n# Display model information (optional)\nmodel.info()\n\n# Run inference with bboxes prompt\nmodel('ultralytics/assets/zidane.jpg', bboxes=[439, 437, 524, 709])\n\n# Run inference with points prompt\nmodel('ultralytics/assets/zidane.jpg', points=[900, 370], labels=[1])\n</code></pre> <p>Segment everything</p> <p>Segment the whole image.</p> PythonCLI <pre><code>from ultralytics import SAM\n\n# Load a model\nmodel = SAM('sam_b.pt')\n\n# Display model information (optional)\nmodel.info()\n\n# Run inference\nmodel('path/to/image.jpg')\n</code></pre> <pre><code># Run inference with a SAM model\nyolo predict model=sam_b.pt source=path/to/image.jpg\n</code></pre> <ul> <li>The logic here is to segment the whole image if you don't pass any prompts(bboxes/points/masks).</li> </ul> <p>SAMPredictor example</p> <p>This way you can set image once and run prompts inference multiple times without running image encoder multiple times.</p> Prompt inference <pre><code>from ultralytics.models.sam import Predictor as SAMPredictor\n\n# Create SAMPredictor\noverrides = dict(conf=0.25, task='segment', mode='predict', imgsz=1024, model=\"mobile_sam.pt\")\npredictor = SAMPredictor(overrides=overrides)\n\n# Set image\npredictor.set_image(\"ultralytics/assets/zidane.jpg\")  # set with image file\npredictor.set_image(cv2.imread(\"ultralytics/assets/zidane.jpg\"))  # set with np.ndarray\nresults = predictor(bboxes=[439, 437, 524, 709])\nresults = predictor(points=[900, 370], labels=[1])\n\n# Reset image\npredictor.reset_image()\n</code></pre> <p>Segment everything with additional args.</p> Segment everything <pre><code>from ultralytics.models.sam import Predictor as SAMPredictor\n\n# Create SAMPredictor\noverrides = dict(conf=0.25, task='segment', mode='predict', imgsz=1024, model=\"mobile_sam.pt\")\npredictor = SAMPredictor(overrides=overrides)\n\n# Segment with additional args\nresults = predictor(source=\"ultralytics/assets/zidane.jpg\", crop_n_layers=1, points_stride=64)\n</code></pre> <ul> <li>More additional args for <code>Segment everything</code> see <code>Predictor/generate</code> Reference.</li> </ul>"},{"location":"models/sam/#sam-comparison-vs-yolov8","title":"SAM comparison vs YOLOv8","text":"<p>Here we compare Meta's smallest SAM model, SAM-b, with Ultralytics smallest segmentation model, YOLOv8n-seg:</p> Model Size Parameters Speed (CPU) Meta's SAM-b 358 MB 94.7 M 51096 ms/im MobileSAM 40.7 MB 10.1 M 46122 ms/im FastSAM-s with YOLOv8 backbone 23.7 MB 11.8 M 115 ms/im Ultralytics YOLOv8n-seg 6.7 MB (53.4x smaller) 3.4 M (27.9x less) 59 ms/im (866x faster) <p>This comparison shows the order-of-magnitude differences in the model sizes and speeds between models. Whereas SAM presents unique capabilities for automatic segmenting, it is not a direct competitor to YOLOv8 segment models, which are smaller, faster and more efficient.</p> <p>Tests run on a 2023 Apple M2 Macbook with 16GB of RAM. To reproduce this test:</p> <p>Example</p> Python <pre><code>from ultralytics import FastSAM, SAM, YOLO\n\n# Profile SAM-b\nmodel = SAM('sam_b.pt')\nmodel.info()\nmodel('ultralytics/assets')\n\n# Profile MobileSAM\nmodel = SAM('mobile_sam.pt')\nmodel.info()\nmodel('ultralytics/assets')\n\n# Profile FastSAM-s\nmodel = FastSAM('FastSAM-s.pt')\nmodel.info()\nmodel('ultralytics/assets')\n\n# Profile YOLOv8n-seg\nmodel = YOLO('yolov8n-seg.pt')\nmodel.info()\nmodel('ultralytics/assets')\n</code></pre>"},{"location":"models/sam/#auto-annotation-a-quick-path-to-segmentation-datasets","title":"Auto-Annotation: A Quick Path to Segmentation Datasets","text":"<p>Auto-annotation is a key feature of SAM, allowing users to generate a segmentation dataset using a pre-trained detection model. This feature enables rapid and accurate annotation of a large number of images, bypassing the need for time-consuming manual labeling.</p>"},{"location":"models/sam/#generate-your-segmentation-dataset-using-a-detection-model","title":"Generate Your Segmentation Dataset Using a Detection Model","text":"<p>To auto-annotate your dataset with the Ultralytics framework, use the <code>auto_annotate</code> function as shown below:</p> <p>Example</p> Python <pre><code>from ultralytics.data.annotator import auto_annotate\n\nauto_annotate(data=\"path/to/images\", det_model=\"yolov8x.pt\", sam_model='sam_b.pt')\n</code></pre> Argument Type Description Default data str Path to a folder containing images to be annotated. det_model str, optional Pre-trained YOLO detection model. Defaults to 'yolov8x.pt'. 'yolov8x.pt' sam_model str, optional Pre-trained SAM segmentation model. Defaults to 'sam_b.pt'. 'sam_b.pt' device str, optional Device to run the models on. Defaults to an empty string (CPU or GPU, if available). output_dir str, None, optional Directory to save the annotated results. Defaults to a 'labels' folder in the same directory as 'data'. None <p>The <code>auto_annotate</code> function takes the path to your images, with optional arguments for specifying the pre-trained detection and SAM segmentation models, the device to run the models on, and the output directory for saving the annotated results.</p> <p>Auto-annotation with pre-trained models can dramatically cut down the time and effort required for creating high-quality segmentation datasets. This feature is especially beneficial for researchers and developers dealing with large image collections, as it allows them to focus on model development and evaluation rather than manual annotation.</p>"},{"location":"models/sam/#citations-and-acknowledgements","title":"Citations and Acknowledgements","text":"<p>If you find SAM useful in your research or development work, please consider citing our paper:</p> BibTeX <pre><code>@misc{kirillov2023segment,\n      title={Segment Anything},\n      author={Alexander Kirillov and Eric Mintun and Nikhila Ravi and Hanzi Mao and Chloe Rolland and Laura Gustafson and Tete Xiao and Spencer Whitehead and Alexander C. Berg and Wan-Yen Lo and Piotr Doll\u00e1r and Ross Girshick},\n      year={2023},\n      eprint={2304.02643},\n      archivePrefix={arXiv},\n      primaryClass={cs.CV}\n}\n</code></pre> <p>We would like to express our gratitude to Meta AI for creating and maintaining this valuable resource for the computer vision community.</p> <p>keywords: Segment Anything, Segment Anything Model, SAM, Meta SAM, image segmentation, promptable segmentation, zero-shot performance, SA-1B dataset, advanced architecture, auto-annotation, Ultralytics, pre-trained models, SAM base, SAM large, instance segmentation, computer vision, AI, artificial intelligence, machine learning, data annotation, segmentation masks, detection model, YOLO detection model, bibtex, Meta AI.</p>"},{"location":"models/yolo-nas/","title":"YOLO-NAS","text":""},{"location":"models/yolo-nas/#overview","title":"Overview","text":"<p>Developed by Deci AI, YOLO-NAS is a groundbreaking object detection foundational model. It is the product of advanced Neural Architecture Search technology, meticulously designed to address the limitations of previous YOLO models. With significant improvements in quantization support and accuracy-latency trade-offs, YOLO-NAS represents a major leap in object detection.</p> <p> Overview of YOLO-NAS. YOLO-NAS employs quantization-aware blocks and selective quantization for optimal performance. The model, when converted to its INT8 quantized version, experiences a minimal precision drop, a significant improvement over other models. These advancements culminate in a superior architecture with unprecedented object detection capabilities and outstanding performance.</p>"},{"location":"models/yolo-nas/#key-features","title":"Key Features","text":"<ul> <li>Quantization-Friendly Basic Block: YOLO-NAS introduces a new basic block that is friendly to quantization, addressing one of the significant limitations of previous YOLO models.</li> <li>Sophisticated Training and Quantization: YOLO-NAS leverages advanced training schemes and post-training quantization to enhance performance.</li> <li>AutoNAC Optimization and Pre-training: YOLO-NAS utilizes AutoNAC optimization and is pre-trained on prominent datasets such as COCO, Objects365, and Roboflow 100. This pre-training makes it extremely suitable for downstream object detection tasks in production environments.</li> </ul>"},{"location":"models/yolo-nas/#pre-trained-models","title":"Pre-trained Models","text":"<p>Experience the power of next-generation object detection with the pre-trained YOLO-NAS models provided by Ultralytics. These models are designed to deliver top-notch performance in terms of both speed and accuracy. Choose from a variety of options tailored to your specific needs:</p> Model mAP Latency (ms) YOLO-NAS S 47.5 3.21 YOLO-NAS M 51.55 5.85 YOLO-NAS L 52.22 7.87 YOLO-NAS S INT-8 47.03 2.36 YOLO-NAS M INT-8 51.0 3.78 YOLO-NAS L INT-8 52.1 4.78 <p>Each model variant is designed to offer a balance between Mean Average Precision (mAP) and latency, helping you optimize your object detection tasks for both performance and speed.</p>"},{"location":"models/yolo-nas/#usage-examples","title":"Usage Examples","text":"<p>Ultralytics has made YOLO-NAS models easy to integrate into your Python applications via our <code>ultralytics</code> python package. The package provides a user-friendly Python API to streamline the process.</p> <p>The following examples show how to use YOLO-NAS models with the <code>ultralytics</code> package for inference and validation:</p>"},{"location":"models/yolo-nas/#inference-and-validation-examples","title":"Inference and Validation Examples","text":"<p>In this example we validate YOLO-NAS-s on the COCO8 dataset.</p> <p>Example</p> <p>This example provides simple inference and validation code for YOLO-NAS. For handling inference results see Predict mode. For using YOLO-NAS with additional modes see Val and Export. YOLO-NAS on the <code>ultralytics</code> package does not support training.</p> PythonCLI <p>PyTorch pretrained <code>*.pt</code> models files can be passed to the <code>NAS()</code> class to create a model instance in python:</p> <pre><code>from ultralytics import NAS\n\n# Load a COCO-pretrained YOLO-NAS-s model\nmodel = NAS('yolo_nas_s.pt')\n\n# Display model information (optional)\nmodel.info()\n\n# Validate the model on the COCO8 example dataset\nresults = model.val(data='coco8.yaml')\n\n# Run inference with the YOLO-NAS-s model on the 'bus.jpg' image\nresults = model('path/to/bus.jpg')\n</code></pre> <p>CLI commands are available to directly run the models:</p> <pre><code># Load a COCO-pretrained YOLO-NAS-s model and validate it's performance on the COCO8 example dataset\nyolo val model=yolo_nas_s.pt data=coco8.yaml\n\n# Load a COCO-pretrained YOLO-NAS-s model and run inference on the 'bus.jpg' image\nyolo predict model=yolo_nas_s.pt source=path/to/bus.jpg\n</code></pre>"},{"location":"models/yolo-nas/#supported-tasks-and-modes","title":"Supported Tasks and Modes","text":"<p>We offer three variants of the YOLO-NAS models: Small (s), Medium (m), and Large (l). Each variant is designed to cater to different computational and performance needs:</p> <ul> <li>YOLO-NAS-s: Optimized for environments where computational resources are limited but efficiency is key.</li> <li>YOLO-NAS-m: Offers a balanced approach, suitable for general-purpose object detection with higher accuracy.</li> <li>YOLO-NAS-l: Tailored for scenarios requiring the highest accuracy, where computational resources are less of a constraint.</li> </ul> <p>Below is a detailed overview of each model, including links to their pre-trained weights, the tasks they support, and their compatibility with different operating modes.</p> Model Type Pre-trained Weights Tasks Supported Inference Validation Training Export YOLO-NAS-s yolo_nas_s.pt Object Detection \u2705 \u2705 \u274c \u2705 YOLO-NAS-m yolo_nas_m.pt Object Detection \u2705 \u2705 \u274c \u2705 YOLO-NAS-l yolo_nas_l.pt Object Detection \u2705 \u2705 \u274c \u2705"},{"location":"models/yolo-nas/#citations-and-acknowledgements","title":"Citations and Acknowledgements","text":"<p>If you employ YOLO-NAS in your research or development work, please cite SuperGradients:</p> BibTeX <pre><code>@misc{supergradients,\n      doi = {10.5281/ZENODO.7789328},\n      url = {https://zenodo.org/record/7789328},\n      author = {Aharon,  Shay and {Louis-Dupont} and {Ofri Masad} and Yurkova,  Kate and {Lotem Fridman} and {Lkdci} and Khvedchenya,  Eugene and Rubin,  Ran and Bagrov,  Natan and Tymchenko,  Borys and Keren,  Tomer and Zhilko,  Alexander and {Eran-Deci}},\n      title = {Super-Gradients},\n      publisher = {GitHub},\n      journal = {GitHub repository},\n      year = {2021},\n}\n</code></pre> <p>We express our gratitude to Deci AI's SuperGradients team for their efforts in creating and maintaining this valuable resource for the computer vision community. We believe YOLO-NAS, with its innovative architecture and superior object detection capabilities, will become a critical tool for developers and researchers alike.</p> <p>Keywords: YOLO-NAS, Deci AI, object detection, deep learning, neural architecture search, Ultralytics Python API, YOLO model, SuperGradients, pre-trained models, quantization-friendly basic block, advanced training schemes, post-training quantization, AutoNAC optimization, COCO, Objects365, Roboflow 100</p>"},{"location":"models/yolov3/","title":"YOLOv3, YOLOv3-Ultralytics, and YOLOv3u","text":""},{"location":"models/yolov3/#overview","title":"Overview","text":"<p>This document presents an overview of three closely related object detection models, namely YOLOv3, YOLOv3-Ultralytics, and YOLOv3u.</p> <ol> <li> <p>YOLOv3: This is the third version of the You Only Look Once (YOLO) object detection algorithm. Originally developed by Joseph Redmon, YOLOv3 improved on its predecessors by introducing features such as multiscale predictions and three different sizes of detection kernels.</p> </li> <li> <p>YOLOv3-Ultralytics: This is Ultralytics' implementation of the YOLOv3 model. It reproduces the original YOLOv3 architecture and offers additional functionalities, such as support for more pre-trained models and easier customization options.</p> </li> <li> <p>YOLOv3u: This is an updated version of YOLOv3-Ultralytics that incorporates the anchor-free, objectness-free split head used in YOLOv8 models. YOLOv3u maintains the same backbone and neck architecture as YOLOv3 but with the updated detection head from YOLOv8.</p> </li> </ol> <p></p>"},{"location":"models/yolov3/#key-features","title":"Key Features","text":"<ul> <li> <p>YOLOv3: Introduced the use of three different scales for detection, leveraging three different sizes of detection kernels: 13x13, 26x26, and 52x52. This significantly improved detection accuracy for objects of different sizes. Additionally, YOLOv3 added features such as multi-label predictions for each bounding box and a better feature extractor network.</p> </li> <li> <p>YOLOv3-Ultralytics: Ultralytics' implementation of YOLOv3 provides the same performance as the original model but comes with added support for more pre-trained models, additional training methods, and easier customization options. This makes it more versatile and user-friendly for practical applications.</p> </li> <li> <p>YOLOv3u: This updated model incorporates the anchor-free, objectness-free split head from YOLOv8. By eliminating the need for pre-defined anchor boxes and objectness scores, this detection head design can improve the model's ability to detect objects of varying sizes and shapes. This makes YOLOv3u more robust and accurate for object detection tasks.</p> </li> </ul>"},{"location":"models/yolov3/#supported-tasks-and-modes","title":"Supported Tasks and Modes","text":"<p>The YOLOv3 series, including YOLOv3, YOLOv3-Ultralytics, and YOLOv3u, are designed specifically for object detection tasks. These models are renowned for their effectiveness in various real-world scenarios, balancing accuracy and speed. Each variant offers unique features and optimizations, making them suitable for a range of applications.</p> <p>All three models support a comprehensive set of modes, ensuring versatility in various stages of model deployment and development. These modes include Inference, Validation, Training, and Export, providing users with a complete toolkit for effective object detection.</p> Model Type Tasks Supported Inference Validation Training Export YOLOv3 Object Detection \u2705 \u2705 \u2705 \u2705 YOLOv3-Ultralytics Object Detection \u2705 \u2705 \u2705 \u2705 YOLOv3u Object Detection \u2705 \u2705 \u2705 \u2705 <p>This table provides an at-a-glance view of the capabilities of each YOLOv3 variant, highlighting their versatility and suitability for various tasks and operational modes in object detection workflows.</p>"},{"location":"models/yolov3/#usage-examples","title":"Usage Examples","text":"<p>This example provides simple YOLOv3 training and inference examples. For full documentation on these and other modes see the Predict, Train, Val and Export docs pages.</p> <p>Example</p> PythonCLI <p>PyTorch pretrained <code>*.pt</code> models as well as configuration <code>*.yaml</code> files can be passed to the <code>YOLO()</code> class to create a model instance in python:</p> <pre><code>from ultralytics import YOLO\n\n# Load a COCO-pretrained YOLOv3n model\nmodel = YOLO('yolov3n.pt')\n\n# Display model information (optional)\nmodel.info()\n\n# Train the model on the COCO8 example dataset for 100 epochs\nresults = model.train(data='coco8.yaml', epochs=100, imgsz=640)\n\n# Run inference with the YOLOv3n model on the 'bus.jpg' image\nresults = model('path/to/bus.jpg')\n</code></pre> <p>CLI commands are available to directly run the models:</p> <pre><code># Load a COCO-pretrained YOLOv3n model and train it on the COCO8 example dataset for 100 epochs\nyolo train model=yolov3n.pt data=coco8.yaml epochs=100 imgsz=640\n\n# Load a COCO-pretrained YOLOv3n model and run inference on the 'bus.jpg' image\nyolo predict model=yolov3n.pt source=path/to/bus.jpg\n</code></pre>"},{"location":"models/yolov3/#citations-and-acknowledgements","title":"Citations and Acknowledgements","text":"<p>If you use YOLOv3 in your research, please cite the original YOLO papers and the Ultralytics YOLOv3 repository:</p> BibTeX <pre><code>@article{redmon2018yolov3,\n  title={YOLOv3: An Incremental Improvement},\n  author={Redmon, Joseph and Farhadi, Ali},\n  journal={arXiv preprint arXiv:1804.02767},\n  year={2018}\n}\n</code></pre> <p>Thank you to Joseph Redmon and Ali Farhadi for developing the original YOLOv3.</p>"},{"location":"models/yolov4/","title":"YOLOv4: High-Speed and Precise Object Detection","text":"<p>Welcome to the Ultralytics documentation page for YOLOv4, a state-of-the-art, real-time object detector launched in 2020 by Alexey Bochkovskiy at https://github.com/AlexeyAB/darknet. YOLOv4 is designed to provide the optimal balance between speed and accuracy, making it an excellent choice for many applications.</p> <p> YOLOv4 architecture diagram. Showcasing the intricate network design of YOLOv4, including the backbone, neck, and head components, and their interconnected layers for optimal real-time object detection.</p>"},{"location":"models/yolov4/#introduction","title":"Introduction","text":"<p>YOLOv4 stands for You Only Look Once version 4. It is a real-time object detection model developed to address the limitations of previous YOLO versions like YOLOv3 and other object detection models. Unlike other convolutional neural network (CNN) based object detectors, YOLOv4 is not only applicable for recommendation systems but also for standalone process management and human input reduction. Its operation on conventional graphics processing units (GPUs) allows for mass usage at an affordable price, and it is designed to work in real-time on a conventional GPU while requiring only one such GPU for training.</p>"},{"location":"models/yolov4/#architecture","title":"Architecture","text":"<p>YOLOv4 makes use of several innovative features that work together to optimize its performance. These include Weighted-Residual-Connections (WRC), Cross-Stage-Partial-connections (CSP), Cross mini-Batch Normalization (CmBN), Self-adversarial-training (SAT), Mish-activation, Mosaic data augmentation, DropBlock regularization, and CIoU loss. These features are combined to achieve state-of-the-art results.</p> <p>A typical object detector is composed of several parts including the input, the backbone, the neck, and the head. The backbone of YOLOv4 is pre-trained on ImageNet and is used to predict classes and bounding boxes of objects. The backbone could be from several models including VGG, ResNet, ResNeXt, or DenseNet. The neck part of the detector is used to collect feature maps from different stages and usually includes several bottom-up paths and several top-down paths. The head part is what is used to make the final object detections and classifications.</p>"},{"location":"models/yolov4/#bag-of-freebies","title":"Bag of Freebies","text":"<p>YOLOv4 also makes use of methods known as \"bag of freebies,\" which are techniques that improve the accuracy of the model during training without increasing the cost of inference. Data augmentation is a common bag of freebies technique used in object detection, which increases the variability of the input images to improve the robustness of the model. Some examples of data augmentation include photometric distortions (adjusting the brightness, contrast, hue, saturation, and noise of an image) and geometric distortions (adding random scaling, cropping, flipping, and rotating). These techniques help the model to generalize better to different types of images.</p>"},{"location":"models/yolov4/#features-and-performance","title":"Features and Performance","text":"<p>YOLOv4 is designed for optimal speed and accuracy in object detection. The architecture of YOLOv4 includes CSPDarknet53 as the backbone, PANet as the neck, and YOLOv3 as the detection head. This design allows YOLOv4 to perform object detection at an impressive speed, making it suitable for real-time applications. YOLOv4 also excels in accuracy, achieving state-of-the-art results in object detection benchmarks.</p>"},{"location":"models/yolov4/#usage-examples","title":"Usage Examples","text":"<p>As of the time of writing, Ultralytics does not currently support YOLOv4 models. Therefore, any users interested in using YOLOv4 will need to refer directly to the YOLOv4 GitHub repository for installation and usage instructions.</p> <p>Here is a brief overview of the typical steps you might take to use YOLOv4:</p> <ol> <li> <p>Visit the YOLOv4 GitHub repository: https://github.com/AlexeyAB/darknet.</p> </li> <li> <p>Follow the instructions provided in the README file for installation. This typically involves cloning the repository, installing necessary dependencies, and setting up any necessary environment variables.</p> </li> <li> <p>Once installation is complete, you can train and use the model as per the usage instructions provided in the repository. This usually involves preparing your dataset, configuring the model parameters, training the model, and then using the trained model to perform object detection.</p> </li> </ol> <p>Please note that the specific steps may vary depending on your specific use case and the current state of the YOLOv4 repository. Therefore, it is strongly recommended to refer directly to the instructions provided in the YOLOv4 GitHub repository.</p> <p>We regret any inconvenience this may cause and will strive to update this document with usage examples for Ultralytics once support for YOLOv4 is implemented.</p>"},{"location":"models/yolov4/#conclusion","title":"Conclusion","text":"<p>YOLOv4 is a powerful and efficient object detection model that strikes a balance between speed and accuracy. Its use of unique features and bag of freebies techniques during training allows it to perform excellently in real-time object detection tasks. YOLOv4 can be trained and used by anyone with a conventional GPU, making it accessible and practical for a wide range of applications.</p>"},{"location":"models/yolov4/#citations-and-acknowledgements","title":"Citations and Acknowledgements","text":"<p>We would like to acknowledge the YOLOv4 authors for their significant contributions in the field of real-time object detection:</p> BibTeX <pre><code>@misc{bochkovskiy2020yolov4,\n      title={YOLOv4: Optimal Speed and Accuracy of Object Detection},\n      author={Alexey Bochkovskiy and Chien-Yao Wang and Hong-Yuan Mark Liao},\n      year={2020},\n      eprint={2004.10934},\n      archivePrefix={arXiv},\n      primaryClass={cs.CV}\n}\n</code></pre> <p>The original YOLOv4 paper can be found on arXiv. The authors have made their work publicly available, and the codebase can be accessed on GitHub. We appreciate their efforts in advancing the field and making their work accessible to the broader community.</p>"},{"location":"models/yolov5/","title":"YOLOv5","text":""},{"location":"models/yolov5/#overview","title":"Overview","text":"<p>YOLOv5u represents an advancement in object detection methodologies. Originating from the foundational architecture of the YOLOv5 model developed by Ultralytics, YOLOv5u integrates the anchor-free, objectness-free split head, a feature previously introduced in the YOLOv8 models. This adaptation refines the model's architecture, leading to an improved accuracy-speed tradeoff in object detection tasks. Given the empirical results and its derived features, YOLOv5u provides an efficient alternative for those seeking robust solutions in both research and practical applications.</p> <p></p>"},{"location":"models/yolov5/#key-features","title":"Key Features","text":"<ul> <li> <p>Anchor-free Split Ultralytics Head: Traditional object detection models rely on predefined anchor boxes to predict object locations. However, YOLOv5u modernizes this approach. By adopting an anchor-free split Ultralytics head, it ensures a more flexible and adaptive detection mechanism, consequently enhancing the performance in diverse scenarios.</p> </li> <li> <p>Optimized Accuracy-Speed Tradeoff: Speed and accuracy often pull in opposite directions. But YOLOv5u challenges this tradeoff. It offers a calibrated balance, ensuring real-time detections without compromising on accuracy. This feature is particularly invaluable for applications that demand swift responses, such as autonomous vehicles, robotics, and real-time video analytics.</p> </li> <li> <p>Variety of Pre-trained Models: Understanding that different tasks require different toolsets, YOLOv5u provides a plethora of pre-trained models. Whether you're focusing on Inference, Validation, or Training, there's a tailor-made model awaiting you. This variety ensures you're not just using a one-size-fits-all solution, but a model specifically fine-tuned for your unique challenge.</p> </li> </ul>"},{"location":"models/yolov5/#supported-tasks-and-modes","title":"Supported Tasks and Modes","text":"<p>The YOLOv5u models, with various pre-trained weights, excel in Object Detection tasks. They support a comprehensive range of modes, making them suitable for diverse applications, from development to deployment.</p> Model Type Pre-trained Weights Task Inference Validation Training Export YOLOv5u <code>yolov5nu</code>, <code>yolov5su</code>, <code>yolov5mu</code>, <code>yolov5lu</code>, <code>yolov5xu</code>, <code>yolov5n6u</code>, <code>yolov5s6u</code>, <code>yolov5m6u</code>, <code>yolov5l6u</code>, <code>yolov5x6u</code> Object Detection \u2705 \u2705 \u2705 \u2705 <p>This table provides a detailed overview of the YOLOv5u model variants, highlighting their applicability in object detection tasks and support for various operational modes such as Inference, Validation, Training, and Export. This comprehensive support ensures that users can fully leverage the capabilities of YOLOv5u models in a wide range of object detection scenarios.</p>"},{"location":"models/yolov5/#performance-metrics","title":"Performance Metrics","text":"<p>Performance</p> Detection <p>See Detection Docs for usage examples with these models trained on COCO, which include 80 pre-trained classes.</p> Model YAML size<sup>(pixels) mAP<sup>val50-95 Speed<sup>CPU ONNX(ms) Speed<sup>A100 TensorRT(ms) params<sup>(M) FLOPs<sup>(B) yolov5nu.pt yolov5n.yaml 640 34.3 73.6 1.06 2.6 7.7 yolov5su.pt yolov5s.yaml 640 43.0 120.7 1.27 9.1 24.0 yolov5mu.pt yolov5m.yaml 640 49.0 233.9 1.86 25.1 64.2 yolov5lu.pt yolov5l.yaml 640 52.2 408.4 2.50 53.2 135.0 yolov5xu.pt yolov5x.yaml 640 53.2 763.2 3.81 97.2 246.4 yolov5n6u.pt yolov5n6.yaml 1280 42.1 211.0 1.83 4.3 7.8 yolov5s6u.pt yolov5s6.yaml 1280 48.6 422.6 2.34 15.3 24.6 yolov5m6u.pt yolov5m6.yaml 1280 53.6 810.9 4.36 41.2 65.7 yolov5l6u.pt yolov5l6.yaml 1280 55.7 1470.9 5.47 86.1 137.4 yolov5x6u.pt yolov5x6.yaml 1280 56.8 2436.5 8.98 155.4 250.7"},{"location":"models/yolov5/#usage-examples","title":"Usage Examples","text":"<p>This example provides simple YOLOv5 training and inference examples. For full documentation on these and other modes see the Predict, Train, Val and Export docs pages.</p> <p>Example</p> PythonCLI <p>PyTorch pretrained <code>*.pt</code> models as well as configuration <code>*.yaml</code> files can be passed to the <code>YOLO()</code> class to create a model instance in python:</p> <pre><code>from ultralytics import YOLO\n\n# Load a COCO-pretrained YOLOv5n model\nmodel = YOLO('yolov5n.pt')\n\n# Display model information (optional)\nmodel.info()\n\n# Train the model on the COCO8 example dataset for 100 epochs\nresults = model.train(data='coco8.yaml', epochs=100, imgsz=640)\n\n# Run inference with the YOLOv5n model on the 'bus.jpg' image\nresults = model('path/to/bus.jpg')\n</code></pre> <p>CLI commands are available to directly run the models:</p> <pre><code># Load a COCO-pretrained YOLOv5n model and train it on the COCO8 example dataset for 100 epochs\nyolo train model=yolov5n.pt data=coco8.yaml epochs=100 imgsz=640\n\n# Load a COCO-pretrained YOLOv5n model and run inference on the 'bus.jpg' image\nyolo predict model=yolov5n.pt source=path/to/bus.jpg\n</code></pre>"},{"location":"models/yolov5/#citations-and-acknowledgements","title":"Citations and Acknowledgements","text":"<p>If you use YOLOv5 or YOLOv5u in your research, please cite the Ultralytics YOLOv5 repository as follows:</p> BibTeX <pre><code>@software{yolov5,\n  title = {Ultralytics YOLOv5},\n  author = {Glenn Jocher},\n  year = {2020},\n  version = {7.0},\n  license = {AGPL-3.0},\n  url = {https://github.com/ultralytics/yolov5},\n  doi = {10.5281/zenodo.3908559},\n  orcid = {0000-0001-5950-6979}\n}\n</code></pre> <p>Please note that YOLOv5 models are provided under AGPL-3.0 and Enterprise licenses.</p>"},{"location":"models/yolov6/","title":"Meituan YOLOv6","text":""},{"location":"models/yolov6/#overview","title":"Overview","text":"<p>Meituan YOLOv6 is a cutting-edge object detector that offers remarkable balance between speed and accuracy, making it a popular choice for real-time applications. This model introduces several notable enhancements on its architecture and training scheme, including the implementation of a Bi-directional Concatenation (BiC) module, an anchor-aided training (AAT) strategy, and an improved backbone and neck design for state-of-the-art accuracy on the COCO dataset.</p> <p> Overview of YOLOv6. Model architecture diagram showing the redesigned network components and training strategies that have led to significant performance improvements. (a) The neck of YOLOv6 (N and S are shown). Note for M/L, RepBlocks is replaced with CSPStackRep. (b) The structure of a BiC module. (c) A SimCSPSPPF block. (source).</p>"},{"location":"models/yolov6/#key-features","title":"Key Features","text":"<ul> <li>Bidirectional Concatenation (BiC) Module: YOLOv6 introduces a BiC module in the neck of the detector, enhancing localization signals and delivering performance gains with negligible speed degradation.</li> <li>Anchor-Aided Training (AAT) Strategy: This model proposes AAT to enjoy the benefits of both anchor-based and anchor-free paradigms without compromising inference efficiency.</li> <li>Enhanced Backbone and Neck Design: By deepening YOLOv6 to include another stage in the backbone and neck, this model achieves state-of-the-art performance on the COCO dataset at high-resolution input.</li> <li>Self-Distillation Strategy: A new self-distillation strategy is implemented to boost the performance of smaller models of YOLOv6, enhancing the auxiliary regression branch during training and removing it at inference to avoid a marked speed decline.</li> </ul>"},{"location":"models/yolov6/#performance-metrics","title":"Performance Metrics","text":"<p>YOLOv6 provides various pre-trained models with different scales:</p> <ul> <li>YOLOv6-N: 37.5% AP on COCO val2017 at 1187 FPS with NVIDIA Tesla T4 GPU.</li> <li>YOLOv6-S: 45.0% AP at 484 FPS.</li> <li>YOLOv6-M: 50.0% AP at 226 FPS.</li> <li>YOLOv6-L: 52.8% AP at 116 FPS.</li> <li>YOLOv6-L6: State-of-the-art accuracy in real-time.</li> </ul> <p>YOLOv6 also provides quantized models for different precisions and models optimized for mobile platforms.</p>"},{"location":"models/yolov6/#usage-examples","title":"Usage Examples","text":"<p>This example provides simple YOLOv6 training and inference examples. For full documentation on these and other modes see the Predict, Train, Val and Export docs pages.</p> <p>Example</p> PythonCLI <p>PyTorch pretrained <code>*.pt</code> models as well as configuration <code>*.yaml</code> files can be passed to the <code>YOLO()</code> class to create a model instance in python:</p> <pre><code>from ultralytics import YOLO\n\n# Build a YOLOv6n model from scratch\nmodel = YOLO('yolov6n.yaml')\n\n# Display model information (optional)\nmodel.info()\n\n# Train the model on the COCO8 example dataset for 100 epochs\nresults = model.train(data='coco8.yaml', epochs=100, imgsz=640)\n\n# Run inference with the YOLOv6n model on the 'bus.jpg' image\nresults = model('path/to/bus.jpg')\n</code></pre> <p>CLI commands are available to directly run the models:</p> <pre><code># Build a YOLOv6n model from scratch and train it on the COCO8 example dataset for 100 epochs\nyolo train model=yolov6n.yaml data=coco8.yaml epochs=100 imgsz=640\n\n# Build a YOLOv6n model from scratch and run inference on the 'bus.jpg' image\nyolo predict model=yolov6n.yaml source=path/to/bus.jpg\n</code></pre>"},{"location":"models/yolov6/#supported-tasks-and-modes","title":"Supported Tasks and Modes","text":"<p>The YOLOv6 series offers a range of models, each optimized for high-performance Object Detection. These models cater to varying computational needs and accuracy requirements, making them versatile for a wide array of applications.</p> Model Type Pre-trained Weights Tasks Supported Inference Validation Training Export YOLOv6-N <code>yolov6-n.pt</code> Object Detection \u2705 \u2705 \u2705 \u2705 YOLOv6-S <code>yolov6-s.pt</code> Object Detection \u2705 \u2705 \u2705 \u2705 YOLOv6-M <code>yolov6-m.pt</code> Object Detection \u2705 \u2705 \u2705 \u2705 YOLOv6-L <code>yolov6-l.pt</code> Object Detection \u2705 \u2705 \u2705 \u2705 YOLOv6-L6 <code>yolov6-l6.pt</code> Object Detection \u2705 \u2705 \u2705 \u2705 <p>This table provides a detailed overview of the YOLOv6 model variants, highlighting their capabilities in object detection tasks and their compatibility with various operational modes such as Inference, Validation, Training, and Export. This comprehensive support ensures that users can fully leverage the capabilities of YOLOv6 models in a broad range of object detection scenarios.</p>"},{"location":"models/yolov6/#citations-and-acknowledgements","title":"Citations and Acknowledgements","text":"<p>We would like to acknowledge the authors for their significant contributions in the field of real-time object detection:</p> BibTeX <pre><code>@misc{li2023yolov6,\n      title={YOLOv6 v3.0: A Full-Scale Reloading},\n      author={Chuyi Li and Lulu Li and Yifei Geng and Hongliang Jiang and Meng Cheng and Bo Zhang and Zaidan Ke and Xiaoming Xu and Xiangxiang Chu},\n      year={2023},\n      eprint={2301.05586},\n      archivePrefix={arXiv},\n      primaryClass={cs.CV}\n}\n</code></pre> <p>The original YOLOv6 paper can be found on arXiv. The authors have made their work publicly available, and the codebase can be accessed on GitHub. We appreciate their efforts in advancing the field and making their work accessible to the broader community.</p>"},{"location":"models/yolov7/","title":"YOLOv7: Trainable Bag-of-Freebies","text":"<p>YOLOv7 is a state-of-the-art real-time object detector that surpasses all known object detectors in both speed and accuracy in the range from 5 FPS to 160 FPS. It has the highest accuracy (56.8% AP) among all known real-time object detectors with 30 FPS or higher on GPU V100. Moreover, YOLOv7 outperforms other object detectors such as YOLOR, YOLOX, Scaled-YOLOv4, YOLOv5, and many others in speed and accuracy. The model is trained on the MS COCO dataset from scratch without using any other datasets or pre-trained weights. Source code for YOLOv7 is available on GitHub.</p> <p> Comparison of state-of-the-art object detectors. From the results in Table 2 we know that the proposed method has the best speed-accuracy trade-off comprehensively. If we compare YOLOv7-tiny-SiLU with YOLOv5-N (r6.1), our method is 127 fps faster and 10.7% more accurate on AP. In addition, YOLOv7 has 51.4% AP at frame rate of 161 fps, while PPYOLOE-L with the same AP has only 78 fps frame rate. In terms of parameter usage, YOLOv7 is 41% less than PPYOLOE-L. If we compare YOLOv7-X with 114 fps inference speed to YOLOv5-L (r6.1) with 99 fps inference speed, YOLOv7-X can improve AP by 3.9%. If YOLOv7-X is compared with YOLOv5-X (r6.1) of similar scale, the inference speed of YOLOv7-X is 31 fps faster. In addition, in terms the amount of parameters and computation, YOLOv7-X reduces 22% of parameters and 8% of computation compared to YOLOv5-X (r6.1), but improves AP by 2.2% (Source).</p>"},{"location":"models/yolov7/#overview","title":"Overview","text":"<p>Real-time object detection is an important component in many computer vision systems, including multi-object tracking, autonomous driving, robotics, and medical image analysis. In recent years, real-time object detection development has focused on designing efficient architectures and improving the inference speed of various CPUs, GPUs, and neural processing units (NPUs). YOLOv7 supports both mobile GPU and GPU devices, from the edge to the cloud.</p> <p>Unlike traditional real-time object detectors that focus on architecture optimization, YOLOv7 introduces a focus on the optimization of the training process. This includes modules and optimization methods designed to improve the accuracy of object detection without increasing the inference cost, a concept known as the \"trainable bag-of-freebies\".</p>"},{"location":"models/yolov7/#key-features","title":"Key Features","text":"<p>YOLOv7 introduces several key features:</p> <ol> <li> <p>Model Re-parameterization: YOLOv7 proposes a planned re-parameterized model, which is a strategy applicable to layers in different networks with the concept of gradient propagation path.</p> </li> <li> <p>Dynamic Label Assignment: The training of the model with multiple output layers presents a new issue: \"How to assign dynamic targets for the outputs of different branches?\" To solve this problem, YOLOv7 introduces a new label assignment method called coarse-to-fine lead guided label assignment.</p> </li> <li> <p>Extended and Compound Scaling: YOLOv7 proposes \"extend\" and \"compound scaling\" methods for the real-time object detector that can effectively utilize parameters and computation.</p> </li> <li> <p>Efficiency: The method proposed by YOLOv7 can effectively reduce about 40% parameters and 50% computation of state-of-the-art real-time object detector, and has faster inference speed and higher detection accuracy.</p> </li> </ol>"},{"location":"models/yolov7/#usage-examples","title":"Usage Examples","text":"<p>As of the time of writing, Ultralytics does not currently support YOLOv7 models. Therefore, any users interested in using YOLOv7 will need to refer directly to the YOLOv7 GitHub repository for installation and usage instructions.</p> <p>Here is a brief overview of the typical steps you might take to use YOLOv7:</p> <ol> <li> <p>Visit the YOLOv7 GitHub repository: https://github.com/WongKinYiu/yolov7.</p> </li> <li> <p>Follow the instructions provided in the README file for installation. This typically involves cloning the repository, installing necessary dependencies, and setting up any necessary environment variables.</p> </li> <li> <p>Once installation is complete, you can train and use the model as per the usage instructions provided in the repository. This usually involves preparing your dataset, configuring the model parameters, training the model, and then using the trained model to perform object detection.</p> </li> </ol> <p>Please note that the specific steps may vary depending on your specific use case and the current state of the YOLOv7 repository. Therefore, it is strongly recommended to refer directly to the instructions provided in the YOLOv7 GitHub repository.</p> <p>We regret any inconvenience this may cause and will strive to update this document with usage examples for Ultralytics once support for YOLOv7 is implemented.</p>"},{"location":"models/yolov7/#citations-and-acknowledgements","title":"Citations and Acknowledgements","text":"<p>We would like to acknowledge the YOLOv7 authors for their significant contributions in the field of real-time object detection:</p> BibTeX <pre><code>@article{wang2022yolov7,\n  title={{YOLOv7}: Trainable bag-of-freebies sets new state-of-the-art for real-time object detectors},\n  author={Wang, Chien-Yao and Bochkovskiy, Alexey and Liao, Hong-Yuan Mark},\n  journal={arXiv preprint arXiv:2207.02696},\n  year={2022}\n}\n</code></pre> <p>The original YOLOv7 paper can be found on arXiv. The authors have made their work publicly available, and the codebase can be accessed on GitHub. We appreciate their efforts in advancing the field and making their work accessible to the broader community.</p>"},{"location":"models/yolov8/","title":"YOLOv8","text":""},{"location":"models/yolov8/#overview","title":"Overview","text":"<p>YOLOv8 is the latest iteration in the YOLO series of real-time object detectors, offering cutting-edge performance in terms of accuracy and speed. Building upon the advancements of previous YOLO versions, YOLOv8 introduces new features and optimizations that make it an ideal choice for various object detection tasks in a wide range of applications.</p> <p></p> <p> Watch: Ultralytics YOLOv8 Model Overview </p>"},{"location":"models/yolov8/#key-features","title":"Key Features","text":"<ul> <li>Advanced Backbone and Neck Architectures: YOLOv8 employs state-of-the-art backbone and neck architectures, resulting in improved feature extraction and object detection performance.</li> <li>Anchor-free Split Ultralytics Head: YOLOv8 adopts an anchor-free split Ultralytics head, which contributes to better accuracy and a more efficient detection process compared to anchor-based approaches.</li> <li>Optimized Accuracy-Speed Tradeoff: With a focus on maintaining an optimal balance between accuracy and speed, YOLOv8 is suitable for real-time object detection tasks in diverse application areas.</li> <li>Variety of Pre-trained Models: YOLOv8 offers a range of pre-trained models to cater to various tasks and performance requirements, making it easier to find the right model for your specific use case.</li> </ul>"},{"location":"models/yolov8/#supported-tasks-and-modes","title":"Supported Tasks and Modes","text":"<p>The YOLOv8 series offers a diverse range of models, each specialized for specific tasks in computer vision. These models are designed to cater to various requirements, from object detection to more complex tasks like instance segmentation, pose/keypoints detection, oriented object detection, and classification.</p> <p>Each variant of the YOLOv8 series is optimized for its respective task, ensuring high performance and accuracy. Additionally, these models are compatible with various operational modes including Inference, Validation, Training, and Export, facilitating their use in different stages of deployment and development.</p> Model Filenames Task Inference Validation Training Export YOLOv8 <code>yolov8n.pt</code> <code>yolov8s.pt</code> <code>yolov8m.pt</code> <code>yolov8l.pt</code> <code>yolov8x.pt</code> Detection \u2705 \u2705 \u2705 \u2705 YOLOv8-seg <code>yolov8n-seg.pt</code> <code>yolov8s-seg.pt</code> <code>yolov8m-seg.pt</code> <code>yolov8l-seg.pt</code> <code>yolov8x-seg.pt</code> Instance Segmentation \u2705 \u2705 \u2705 \u2705 YOLOv8-pose <code>yolov8n-pose.pt</code> <code>yolov8s-pose.pt</code> <code>yolov8m-pose.pt</code> <code>yolov8l-pose.pt</code> <code>yolov8x-pose.pt</code> <code>yolov8x-pose-p6.pt</code> Pose/Keypoints \u2705 \u2705 \u2705 \u2705 YOLOv8-obb <code>yolov8n-obb.pt</code> <code>yolov8s-obb.pt</code> <code>yolov8m-obb.pt</code> <code>yolov8l-obb.pt</code> <code>yolov8x-obb.pt</code> Oriented Detection \u2705 \u2705 \u2705 \u2705 YOLOv8-cls <code>yolov8n-cls.pt</code> <code>yolov8s-cls.pt</code> <code>yolov8m-cls.pt</code> <code>yolov8l-cls.pt</code> <code>yolov8x-cls.pt</code> Classification \u2705 \u2705 \u2705 \u2705 <p>This table provides an overview of the YOLOv8 model variants, highlighting their applicability in specific tasks and their compatibility with various operational modes such as Inference, Validation, Training, and Export. It showcases the versatility and robustness of the YOLOv8 series, making them suitable for a variety of applications in computer vision.</p>"},{"location":"models/yolov8/#performance-metrics","title":"Performance Metrics","text":"<p>Performance</p> Detection (COCO)Detection (Open Images V7)Segmentation (COCO)Classification (ImageNet)Pose (COCO)OBB (DOTAv1) <p>See Detection Docs for usage examples with these models trained on COCO, which include 80 pre-trained classes.</p> Model size<sup>(pixels) mAP<sup>val50-95 Speed<sup>CPU ONNX(ms) Speed<sup>A100 TensorRT(ms) params<sup>(M) FLOPs<sup>(B) YOLOv8n 640 37.3 80.4 0.99 3.2 8.7 YOLOv8s 640 44.9 128.4 1.20 11.2 28.6 YOLOv8m 640 50.2 234.7 1.83 25.9 78.9 YOLOv8l 640 52.9 375.2 2.39 43.7 165.2 YOLOv8x 640 53.9 479.1 3.53 68.2 257.8 <p>See Detection Docs for usage examples with these models trained on Open Image V7, which include 600 pre-trained classes.</p> Model size<sup>(pixels) mAP<sup>val50-95 Speed<sup>CPU ONNX(ms) Speed<sup>A100 TensorRT(ms) params<sup>(M) FLOPs<sup>(B) YOLOv8n 640 18.4 142.4 1.21 3.5 10.5 YOLOv8s 640 27.7 183.1 1.40 11.4 29.7 YOLOv8m 640 33.6 408.5 2.26 26.2 80.6 YOLOv8l 640 34.9 596.9 2.43 44.1 167.4 YOLOv8x 640 36.3 860.6 3.56 68.7 260.6 <p>See Segmentation Docs for usage examples with these models trained on COCO, which include 80 pre-trained classes.</p> Model size<sup>(pixels) mAP<sup>box50-95 mAP<sup>mask50-95 Speed<sup>CPU ONNX(ms) Speed<sup>A100 TensorRT(ms) params<sup>(M) FLOPs<sup>(B) YOLOv8n-seg 640 36.7 30.5 96.1 1.21 3.4 12.6 YOLOv8s-seg 640 44.6 36.8 155.7 1.47 11.8 42.6 YOLOv8m-seg 640 49.9 40.8 317.0 2.18 27.3 110.2 YOLOv8l-seg 640 52.3 42.6 572.4 2.79 46.0 220.5 YOLOv8x-seg 640 53.4 43.4 712.1 4.02 71.8 344.1 <p>See Classification Docs for usage examples with these models trained on ImageNet, which include 1000 pre-trained classes.</p> Model size<sup>(pixels) acc<sup>top1 acc<sup>top5 Speed<sup>CPU ONNX(ms) Speed<sup>A100 TensorRT(ms) params<sup>(M) FLOPs<sup>(B) at 640 YOLOv8n-cls 224 69.0 88.3 12.9 0.31 2.7 4.3 YOLOv8s-cls 224 73.8 91.7 23.4 0.35 6.4 13.5 YOLOv8m-cls 224 76.8 93.5 85.4 0.62 17.0 42.7 YOLOv8l-cls 224 76.8 93.5 163.0 0.87 37.5 99.7 YOLOv8x-cls 224 79.0 94.6 232.0 1.01 57.4 154.8 <p>See Pose Estimation Docs for usage examples with these models trained on COCO, which include 1 pre-trained class, 'person'.</p> Model size<sup>(pixels) mAP<sup>pose50-95 mAP<sup>pose50 Speed<sup>CPU ONNX(ms) Speed<sup>A100 TensorRT(ms) params<sup>(M) FLOPs<sup>(B) YOLOv8n-pose 640 50.4 80.1 131.8 1.18 3.3 9.2 YOLOv8s-pose 640 60.0 86.2 233.2 1.42 11.6 30.2 YOLOv8m-pose 640 65.0 88.8 456.3 2.00 26.4 81.0 YOLOv8l-pose 640 67.6 90.0 784.5 2.59 44.4 168.6 YOLOv8x-pose 640 69.2 90.2 1607.1 3.73 69.4 263.2 YOLOv8x-pose-p6 1280 71.6 91.2 4088.7 10.04 99.1 1066.4 <p>See Oriented Detection Docs for usage examples with these models trained on DOTAv1, which include 15 pre-trained classes.</p> Model size<sup>(pixels) mAP<sup>test50 Speed<sup>CPU ONNX(ms) Speed<sup>A100 TensorRT(ms) params<sup>(M) FLOPs<sup>(B) YOLOv8n-obb 1024 76.9 204.77 3.57 3.1 23.3 YOLOv8s-obb 1024 78.0 424.88 4.07 11.4 76.3 YOLOv8m-obb 1024 80.5 763.48 7.61 26.4 208.6 YOLOv8l-obb 1024 80.7 1278.42 11.83 44.5 433.8 YOLOv8x-obb 1024 81.36 1759.10 13.23 69.5 676.7"},{"location":"models/yolov8/#usage-examples","title":"Usage Examples","text":"<p>This example provides simple YOLOv8 training and inference examples. For full documentation on these and other modes see the Predict, Train, Val and Export docs pages.</p> <p>Note the below example is for YOLOv8 Detect models for object detection. For additional supported tasks see the Segment, Classify, OBB docs and Pose docs.</p> <p>Example</p> PythonCLI <p>PyTorch pretrained <code>*.pt</code> models as well as configuration <code>*.yaml</code> files can be passed to the <code>YOLO()</code> class to create a model instance in python:</p> <pre><code>from ultralytics import YOLO\n\n# Load a COCO-pretrained YOLOv8n model\nmodel = YOLO('yolov8n.pt')\n\n# Display model information (optional)\nmodel.info()\n\n# Train the model on the COCO8 example dataset for 100 epochs\nresults = model.train(data='coco8.yaml', epochs=100, imgsz=640)\n\n# Run inference with the YOLOv8n model on the 'bus.jpg' image\nresults = model('path/to/bus.jpg')\n</code></pre> <p>CLI commands are available to directly run the models:</p> <pre><code># Load a COCO-pretrained YOLOv8n model and train it on the COCO8 example dataset for 100 epochs\nyolo train model=yolov8n.pt data=coco8.yaml epochs=100 imgsz=640\n\n# Load a COCO-pretrained YOLOv8n model and run inference on the 'bus.jpg' image\nyolo predict model=yolov8n.pt source=path/to/bus.jpg\n</code></pre>"},{"location":"models/yolov8/#citations-and-acknowledgements","title":"Citations and Acknowledgements","text":"<p>If you use the YOLOv8 model or any other software from this repository in your work, please cite it using the following format:</p> BibTeX <pre><code>@software{yolov8_ultralytics,\n  author = {Glenn Jocher and Ayush Chaurasia and Jing Qiu},\n  title = {Ultralytics YOLOv8},\n  version = {8.0.0},\n  year = {2023},\n  url = {https://github.com/ultralytics/ultralytics},\n  orcid = {0000-0001-5950-6979, 0000-0002-7603-6750, 0000-0003-3783-7069},\n  license = {AGPL-3.0}\n}\n</code></pre> <p>Please note that the DOI is pending and will be added to the citation once it is available. YOLOv8 models are provided under AGPL-3.0 and Enterprise licenses.</p>"},{"location":"modes/","title":"Ultralytics YOLOv8 Modes","text":""},{"location":"modes/#introduction","title":"Introduction","text":"<p>Ultralytics YOLOv8 is not just another object detection model; it's a versatile framework designed to cover the entire lifecycle of machine learning models\u2014from data ingestion and model training to validation, deployment, and real-world tracking. Each mode serves a specific purpose and is engineered to offer you the flexibility and efficiency required for different tasks and use-cases.</p> <p> Watch: Ultralytics Modes Tutorial: Train, Validate, Predict, Export &amp; Benchmark. </p>"},{"location":"modes/#modes-at-a-glance","title":"Modes at a Glance","text":"<p>Understanding the different modes that Ultralytics YOLOv8 supports is critical to getting the most out of your models:</p> <ul> <li>Train mode: Fine-tune your model on custom or preloaded datasets.</li> <li>Val mode: A post-training checkpoint to validate model performance.</li> <li>Predict mode: Unleash the predictive power of your model on real-world data.</li> <li>Export mode: Make your model deployment-ready in various formats.</li> <li>Track mode: Extend your object detection model into real-time tracking applications.</li> <li>Benchmark mode: Analyze the speed and accuracy of your model in diverse deployment environments.</li> </ul> <p>This comprehensive guide aims to give you an overview and practical insights into each mode, helping you harness the full potential of YOLOv8.</p>"},{"location":"modes/#train","title":"Train","text":"<p>Train mode is used for training a YOLOv8 model on a custom dataset. In this mode, the model is trained using the specified dataset and hyperparameters. The training process involves optimizing the model's parameters so that it can accurately predict the classes and locations of objects in an image.</p> <p>Train Examples</p>"},{"location":"modes/#val","title":"Val","text":"<p>Val mode is used for validating a YOLOv8 model after it has been trained. In this mode, the model is evaluated on a validation set to measure its accuracy and generalization performance. This mode can be used to tune the hyperparameters of the model to improve its performance.</p> <p>Val Examples</p>"},{"location":"modes/#predict","title":"Predict","text":"<p>Predict mode is used for making predictions using a trained YOLOv8 model on new images or videos. In this mode, the model is loaded from a checkpoint file, and the user can provide images or videos to perform inference. The model predicts the classes and locations of objects in the input images or videos.</p> <p>Predict Examples</p>"},{"location":"modes/#export","title":"Export","text":"<p>Export mode is used for exporting a YOLOv8 model to a format that can be used for deployment. In this mode, the model is converted to a format that can be used by other software applications or hardware devices. This mode is useful when deploying the model to production environments.</p> <p>Export Examples</p>"},{"location":"modes/#track","title":"Track","text":"<p>Track mode is used for tracking objects in real-time using a YOLOv8 model. In this mode, the model is loaded from a checkpoint file, and the user can provide a live video stream to perform real-time object tracking. This mode is useful for applications such as surveillance systems or self-driving cars.</p> <p>Track Examples</p>"},{"location":"modes/#benchmark","title":"Benchmark","text":"<p>Benchmark mode is used to profile the speed and accuracy of various export formats for YOLOv8. The benchmarks provide information on the size of the exported format, its <code>mAP50-95</code> metrics (for object detection, segmentation and pose) or <code>accuracy_top5</code> metrics (for classification), and the inference time in milliseconds per image across various export formats like ONNX, OpenVINO, TensorRT and others. This information can help users choose the optimal export format for their specific use case based on their requirements for speed and accuracy.</p> <p>Benchmark Examples</p>"},{"location":"modes/benchmark/","title":"Model Benchmarking with Ultralytics YOLO","text":""},{"location":"modes/benchmark/#introduction","title":"Introduction","text":"<p>Once your model is trained and validated, the next logical step is to evaluate its performance in various real-world scenarios. Benchmark mode in Ultralytics YOLOv8 serves this purpose by providing a robust framework for assessing the speed and accuracy of your model across a range of export formats.</p> <p> Watch: Ultralytics Modes Tutorial: Benchmark </p>"},{"location":"modes/benchmark/#why-is-benchmarking-crucial","title":"Why Is Benchmarking Crucial?","text":"<ul> <li>Informed Decisions: Gain insights into the trade-offs between speed and accuracy.</li> <li>Resource Allocation: Understand how different export formats perform on different hardware.</li> <li>Optimization: Learn which export format offers the best performance for your specific use case.</li> <li>Cost Efficiency: Make more efficient use of hardware resources based on benchmark results.</li> </ul>"},{"location":"modes/benchmark/#key-metrics-in-benchmark-mode","title":"Key Metrics in Benchmark Mode","text":"<ul> <li>mAP50-95: For object detection, segmentation, and pose estimation.</li> <li>accuracy_top5: For image classification.</li> <li>Inference Time: Time taken for each image in milliseconds.</li> </ul>"},{"location":"modes/benchmark/#supported-export-formats","title":"Supported Export Formats","text":"<ul> <li>ONNX: For optimal CPU performance</li> <li>TensorRT: For maximal GPU efficiency</li> <li>OpenVINO: For Intel hardware optimization</li> <li>CoreML, TensorFlow SavedModel, and More: For diverse deployment needs.</li> </ul> <p>Tip</p> <ul> <li>Export to ONNX or OpenVINO for up to 3x CPU speedup.</li> <li>Export to TensorRT for up to 5x GPU speedup.</li> </ul>"},{"location":"modes/benchmark/#usage-examples","title":"Usage Examples","text":"<p>Run YOLOv8n benchmarks on all supported export formats including ONNX, TensorRT etc. See Arguments section below for a full list of export arguments.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics.utils.benchmarks import benchmark\n\n# Benchmark on GPU\nbenchmark(model='yolov8n.pt', data='coco8.yaml', imgsz=640, half=False, device=0)\n</code></pre> <pre><code>yolo benchmark model=yolov8n.pt data='coco8.yaml' imgsz=640 half=False device=0\n</code></pre>"},{"location":"modes/benchmark/#arguments","title":"Arguments","text":"<p>Arguments such as <code>model</code>, <code>data</code>, <code>imgsz</code>, <code>half</code>, <code>device</code>, and <code>verbose</code> provide users with the flexibility to fine-tune the benchmarks to their specific needs and compare the performance of different export formats with ease.</p> Key Value Description <code>model</code> <code>None</code> path to model file, i.e. yolov8n.pt, yolov8n.yaml <code>data</code> <code>None</code> path to YAML referencing the benchmarking dataset (under <code>val</code> label) <code>imgsz</code> <code>640</code> image size as scalar or (h, w) list, i.e. (640, 480) <code>half</code> <code>False</code> FP16 quantization <code>int8</code> <code>False</code> INT8 quantization <code>device</code> <code>None</code> device to run on, i.e. cuda device=0 or device=0,1,2,3 or device=cpu <code>verbose</code> <code>False</code> do not continue on error (bool), or val floor threshold (float)"},{"location":"modes/benchmark/#export-formats","title":"Export Formats","text":"<p>Benchmarks will attempt to run automatically on all possible export formats below.</p> Format <code>format</code> Argument Model Metadata Arguments PyTorch - <code>yolov8n.pt</code> \u2705 - TorchScript <code>torchscript</code> <code>yolov8n.torchscript</code> \u2705 <code>imgsz</code>, <code>optimize</code> ONNX <code>onnx</code> <code>yolov8n.onnx</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>dynamic</code>, <code>simplify</code>, <code>opset</code> OpenVINO <code>openvino</code> <code>yolov8n_openvino_model/</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code> TensorRT <code>engine</code> <code>yolov8n.engine</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>dynamic</code>, <code>simplify</code>, <code>workspace</code> CoreML <code>coreml</code> <code>yolov8n.mlpackage</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code>, <code>nms</code> TF SavedModel <code>saved_model</code> <code>yolov8n_saved_model/</code> \u2705 <code>imgsz</code>, <code>keras</code>, <code>int8</code> TF GraphDef <code>pb</code> <code>yolov8n.pb</code> \u274c <code>imgsz</code> TF Lite <code>tflite</code> <code>yolov8n.tflite</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code> TF Edge TPU <code>edgetpu</code> <code>yolov8n_edgetpu.tflite</code> \u2705 <code>imgsz</code> TF.js <code>tfjs</code> <code>yolov8n_web_model/</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code> PaddlePaddle <code>paddle</code> <code>yolov8n_paddle_model/</code> \u2705 <code>imgsz</code> ncnn <code>ncnn</code> <code>yolov8n_ncnn_model/</code> \u2705 <code>imgsz</code>, <code>half</code> <p>See full <code>export</code> details in the Export page.</p>"},{"location":"modes/export/","title":"Model Export with Ultralytics YOLO","text":""},{"location":"modes/export/#introduction","title":"Introduction","text":"<p>The ultimate goal of training a model is to deploy it for real-world applications. Export mode in Ultralytics YOLOv8 offers a versatile range of options for exporting your trained model to different formats, making it deployable across various platforms and devices. This comprehensive guide aims to walk you through the nuances of model exporting, showcasing how to achieve maximum compatibility and performance.</p> <p> Watch: How To Export Custom Trained Ultralytics YOLOv8 Model and Run Live Inference on Webcam. </p>"},{"location":"modes/export/#why-choose-yolov8s-export-mode","title":"Why Choose YOLOv8's Export Mode?","text":"<ul> <li>Versatility: Export to multiple formats including ONNX, TensorRT, CoreML, and more.</li> <li>Performance: Gain up to 5x GPU speedup with TensorRT and 3x CPU speedup with ONNX or OpenVINO.</li> <li>Compatibility: Make your model universally deployable across numerous hardware and software environments.</li> <li>Ease of Use: Simple CLI and Python API for quick and straightforward model exporting.</li> </ul>"},{"location":"modes/export/#key-features-of-export-mode","title":"Key Features of Export Mode","text":"<p>Here are some of the standout functionalities:</p> <ul> <li>One-Click Export: Simple commands for exporting to different formats.</li> <li>Batch Export: Export batched-inference capable models.</li> <li>Optimized Inference: Exported models are optimized for quicker inference times.</li> <li>Tutorial Videos: In-depth guides and tutorials for a smooth exporting experience.</li> </ul> <p>Tip</p> <ul> <li>Export to ONNX or OpenVINO for up to 3x CPU speedup.</li> <li>Export to TensorRT for up to 5x GPU speedup.</li> </ul>"},{"location":"modes/export/#usage-examples","title":"Usage Examples","text":"<p>Export a YOLOv8n model to a different format like ONNX or TensorRT. See Arguments section below for a full list of export arguments.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n.pt')  # load an official model\nmodel = YOLO('path/to/best.pt')  # load a custom trained model\n\n# Export the model\nmodel.export(format='onnx')\n</code></pre> <pre><code>yolo export model=yolov8n.pt format=onnx  # export official model\nyolo export model=path/to/best.pt format=onnx  # export custom trained model\n</code></pre>"},{"location":"modes/export/#arguments","title":"Arguments","text":"<p>Export settings for YOLO models refer to the various configurations and options used to save or export the model for use in other environments or platforms. These settings can affect the model's performance, size, and compatibility with different systems. Some common YOLO export settings include the format of the exported model file (e.g. ONNX, TensorFlow SavedModel), the device on which the model will be run (e.g. CPU, GPU), and the presence of additional features such as masks or multiple labels per box. Other factors that may affect the export process include the specific task the model is being used for and the requirements or constraints of the target environment or platform. It is important to carefully consider and configure these settings to ensure that the exported model is optimized for the intended use case and can be used effectively in the target environment.</p> Key Value Description <code>format</code> <code>'torchscript'</code> format to export to <code>imgsz</code> <code>640</code> image size as scalar or (h, w) list, i.e. (640, 480) <code>keras</code> <code>False</code> use Keras for TF SavedModel export <code>optimize</code> <code>False</code> TorchScript: optimize for mobile <code>half</code> <code>False</code> FP16 quantization <code>int8</code> <code>False</code> INT8 quantization <code>dynamic</code> <code>False</code> ONNX/TensorRT: dynamic axes <code>simplify</code> <code>False</code> ONNX/TensorRT: simplify model <code>opset</code> <code>None</code> ONNX: opset version (optional, defaults to latest) <code>workspace</code> <code>4</code> TensorRT: workspace size (GB) <code>nms</code> <code>False</code> CoreML: add NMS"},{"location":"modes/export/#export-formats","title":"Export Formats","text":"<p>Available YOLOv8 export formats are in the table below. You can export to any format using the <code>format</code> argument, i.e. <code>format='onnx'</code> or <code>format='engine'</code>.</p> Format <code>format</code> Argument Model Metadata Arguments PyTorch - <code>yolov8n.pt</code> \u2705 - TorchScript <code>torchscript</code> <code>yolov8n.torchscript</code> \u2705 <code>imgsz</code>, <code>optimize</code> ONNX <code>onnx</code> <code>yolov8n.onnx</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>dynamic</code>, <code>simplify</code>, <code>opset</code> OpenVINO <code>openvino</code> <code>yolov8n_openvino_model/</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code> TensorRT <code>engine</code> <code>yolov8n.engine</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>dynamic</code>, <code>simplify</code>, <code>workspace</code> CoreML <code>coreml</code> <code>yolov8n.mlpackage</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code>, <code>nms</code> TF SavedModel <code>saved_model</code> <code>yolov8n_saved_model/</code> \u2705 <code>imgsz</code>, <code>keras</code>, <code>int8</code> TF GraphDef <code>pb</code> <code>yolov8n.pb</code> \u274c <code>imgsz</code> TF Lite <code>tflite</code> <code>yolov8n.tflite</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code> TF Edge TPU <code>edgetpu</code> <code>yolov8n_edgetpu.tflite</code> \u2705 <code>imgsz</code> TF.js <code>tfjs</code> <code>yolov8n_web_model/</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code> PaddlePaddle <code>paddle</code> <code>yolov8n_paddle_model/</code> \u2705 <code>imgsz</code> ncnn <code>ncnn</code> <code>yolov8n_ncnn_model/</code> \u2705 <code>imgsz</code>, <code>half</code>"},{"location":"modes/predict/","title":"Model Prediction with Ultralytics YOLO","text":""},{"location":"modes/predict/#introduction","title":"Introduction","text":"<p>In the world of machine learning and computer vision, the process of making sense out of visual data is called 'inference' or 'prediction'. Ultralytics YOLOv8 offers a powerful feature known as predict mode that is tailored for high-performance, real-time inference on a wide range of data sources.</p> <p> Watch: How to Extract the Outputs from Ultralytics YOLOv8 Model for Custom Projects. </p>"},{"location":"modes/predict/#real-world-applications","title":"Real-world Applications","text":"Manufacturing Sports Safety Vehicle Spare Parts Detection Football Player Detection People Fall Detection"},{"location":"modes/predict/#why-use-ultralytics-yolo-for-inference","title":"Why Use Ultralytics YOLO for Inference?","text":"<p>Here's why you should consider YOLOv8's predict mode for your various inference needs:</p> <ul> <li>Versatility: Capable of making inferences on images, videos, and even live streams.</li> <li>Performance: Engineered for real-time, high-speed processing without sacrificing accuracy.</li> <li>Ease of Use: Intuitive Python and CLI interfaces for rapid deployment and testing.</li> <li>Highly Customizable: Various settings and parameters to tune the model's inference behavior according to your specific requirements.</li> </ul>"},{"location":"modes/predict/#key-features-of-predict-mode","title":"Key Features of Predict Mode","text":"<p>YOLOv8's predict mode is designed to be robust and versatile, featuring:</p> <ul> <li>Multiple Data Source Compatibility: Whether your data is in the form of individual images, a collection of images, video files, or real-time video streams, predict mode has you covered.</li> <li>Streaming Mode: Use the streaming feature to generate a memory-efficient generator of <code>Results</code> objects. Enable this by setting <code>stream=True</code> in the predictor's call method.</li> <li>Batch Processing: The ability to process multiple images or video frames in a single batch, further speeding up inference time.</li> <li>Integration Friendly: Easily integrate with existing data pipelines and other software components, thanks to its flexible API.</li> </ul> <p>Ultralytics YOLO models return either a Python list of <code>Results</code> objects, or a memory-efficient Python generator of <code>Results</code> objects when <code>stream=True</code> is passed to the model during inference:</p> <p>Predict</p> Return a list with <code>stream=False</code>Return a generator with <code>stream=True</code> <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n.pt')  # pretrained YOLOv8n model\n\n# Run batched inference on a list of images\nresults = model(['im1.jpg', 'im2.jpg'])  # return a list of Results objects\n\n# Process results list\nfor result in results:\n    boxes = result.boxes  # Boxes object for bbox outputs\n    masks = result.masks  # Masks object for segmentation masks outputs\n    keypoints = result.keypoints  # Keypoints object for pose outputs\n    probs = result.probs  # Probs object for classification outputs\n</code></pre> <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n.pt')  # pretrained YOLOv8n model\n\n# Run batched inference on a list of images\nresults = model(['im1.jpg', 'im2.jpg'], stream=True)  # return a generator of Results objects\n\n# Process results generator\nfor result in results:\n    boxes = result.boxes  # Boxes object for bbox outputs\n    masks = result.masks  # Masks object for segmentation masks outputs\n    keypoints = result.keypoints  # Keypoints object for pose outputs\n    probs = result.probs  # Probs object for classification outputs\n</code></pre>"},{"location":"modes/predict/#inference-sources","title":"Inference Sources","text":"<p>YOLOv8 can process different types of input sources for inference, as shown in the table below. The sources include static images, video streams, and various data formats. The table also indicates whether each source can be used in streaming mode with the argument <code>stream=True</code> \u2705. Streaming mode is beneficial for processing videos or live streams as it creates a generator of results instead of loading all frames into memory.</p> <p>Tip</p> <p>Use <code>stream=True</code> for processing long videos or large datasets to efficiently manage memory. When <code>stream=False</code>, the results for all frames or data points are stored in memory, which can quickly add up and cause out-of-memory errors for large inputs. In contrast, <code>stream=True</code> utilizes a generator, which only keeps the results of the current frame or data point in memory, significantly reducing memory consumption and preventing out-of-memory issues.</p> Source Argument Type Notes image <code>'image.jpg'</code> <code>str</code> or <code>Path</code> Single image file. URL <code>'https://ultralytics.com/images/bus.jpg'</code> <code>str</code> URL to an image. screenshot <code>'screen'</code> <code>str</code> Capture a screenshot. PIL <code>Image.open('im.jpg')</code> <code>PIL.Image</code> HWC format with RGB channels. OpenCV <code>cv2.imread('im.jpg')</code> <code>np.ndarray</code> HWC format with BGR channels <code>uint8 (0-255)</code>. numpy <code>np.zeros((640,1280,3))</code> <code>np.ndarray</code> HWC format with BGR channels <code>uint8 (0-255)</code>. torch <code>torch.zeros(16,3,320,640)</code> <code>torch.Tensor</code> BCHW format with RGB channels <code>float32 (0.0-1.0)</code>. CSV <code>'sources.csv'</code> <code>str</code> or <code>Path</code> CSV file containing paths to images, videos, or directories. video \u2705 <code>'video.mp4'</code> <code>str</code> or <code>Path</code> Video file in formats like MP4, AVI, etc. directory \u2705 <code>'path/'</code> <code>str</code> or <code>Path</code> Path to a directory containing images or videos. glob \u2705 <code>'path/*.jpg'</code> <code>str</code> Glob pattern to match multiple files. Use the <code>*</code> character as a wildcard. YouTube \u2705 <code>'https://youtu.be/LNwODJXcvt4'</code> <code>str</code> URL to a YouTube video. stream \u2705 <code>'rtsp://example.com/media.mp4'</code> <code>str</code> URL for streaming protocols such as RTSP, RTMP, TCP, or an IP address. multi-stream \u2705 <code>'list.streams'</code> <code>str</code> or <code>Path</code> <code>*.streams</code> text file with one stream URL per row, i.e. 8 streams will run at batch-size 8. <p>Below are code examples for using each source type:</p> <p>Prediction sources</p> imagescreenshotURLPILOpenCVnumpytorchCSVvideodirectoryglobYouTubeStreams <p>Run inference on an image file. <pre><code>from ultralytics import YOLO\n\n# Load a pretrained YOLOv8n model\nmodel = YOLO('yolov8n.pt')\n\n# Define path to the image file\nsource = 'path/to/image.jpg'\n\n# Run inference on the source\nresults = model(source)  # list of Results objects\n</code></pre></p> <p>Run inference on the current screen content as a screenshot. <pre><code>from ultralytics import YOLO\n\n# Load a pretrained YOLOv8n model\nmodel = YOLO('yolov8n.pt')\n\n# Define current screenshot as source\nsource = 'screen'\n\n# Run inference on the source\nresults = model(source)  # list of Results objects\n</code></pre></p> <p>Run inference on an image or video hosted remotely via URL. <pre><code>from ultralytics import YOLO\n\n# Load a pretrained YOLOv8n model\nmodel = YOLO('yolov8n.pt')\n\n# Define remote image or video URL\nsource = 'https://ultralytics.com/images/bus.jpg'\n\n# Run inference on the source\nresults = model(source)  # list of Results objects\n</code></pre></p> <p>Run inference on an image opened with Python Imaging Library (PIL). <pre><code>from PIL import Image\nfrom ultralytics import YOLO\n\n# Load a pretrained YOLOv8n model\nmodel = YOLO('yolov8n.pt')\n\n# Open an image using PIL\nsource = Image.open('path/to/image.jpg')\n\n# Run inference on the source\nresults = model(source)  # list of Results objects\n</code></pre></p> <p>Run inference on an image read with OpenCV. <pre><code>import cv2\nfrom ultralytics import YOLO\n\n# Load a pretrained YOLOv8n model\nmodel = YOLO('yolov8n.pt')\n\n# Read an image using OpenCV\nsource = cv2.imread('path/to/image.jpg')\n\n# Run inference on the source\nresults = model(source)  # list of Results objects\n</code></pre></p> <p>Run inference on an image represented as a numpy array. <pre><code>import numpy as np\nfrom ultralytics import YOLO\n\n# Load a pretrained YOLOv8n model\nmodel = YOLO('yolov8n.pt')\n\n# Create a random numpy array of HWC shape (640, 640, 3) with values in range [0, 255] and type uint8\nsource = np.random.randint(low=0, high=255, size=(640, 640, 3), dtype='uint8')\n\n# Run inference on the source\nresults = model(source)  # list of Results objects\n</code></pre></p> <p>Run inference on an image represented as a PyTorch tensor. <pre><code>import torch\nfrom ultralytics import YOLO\n\n# Load a pretrained YOLOv8n model\nmodel = YOLO('yolov8n.pt')\n\n# Create a random torch tensor of BCHW shape (1, 3, 640, 640) with values in range [0, 1] and type float32\nsource = torch.rand(1, 3, 640, 640, dtype=torch.float32)\n\n# Run inference on the source\nresults = model(source)  # list of Results objects\n</code></pre></p> <p>Run inference on a collection of images, URLs, videos and directories listed in a CSV file. <pre><code>import torch\nfrom ultralytics import YOLO\n\n# Load a pretrained YOLOv8n model\nmodel = YOLO('yolov8n.pt')\n\n# Define a path to a CSV file with images, URLs, videos and directories\nsource = 'path/to/file.csv'\n\n# Run inference on the source\nresults = model(source)  # list of Results objects\n</code></pre></p> <p>Run inference on a video file. By using <code>stream=True</code>, you can create a generator of Results objects to reduce memory usage. <pre><code>from ultralytics import YOLO\n\n# Load a pretrained YOLOv8n model\nmodel = YOLO('yolov8n.pt')\n\n# Define path to video file\nsource = 'path/to/video.mp4'\n\n# Run inference on the source\nresults = model(source, stream=True)  # generator of Results objects\n</code></pre></p> <p>Run inference on all images and videos in a directory. To also capture images and videos in subdirectories use a glob pattern, i.e. <code>path/to/dir/**/*</code>. <pre><code>from ultralytics import YOLO\n\n# Load a pretrained YOLOv8n model\nmodel = YOLO('yolov8n.pt')\n\n# Define path to directory containing images and videos for inference\nsource = 'path/to/dir'\n\n# Run inference on the source\nresults = model(source, stream=True)  # generator of Results objects\n</code></pre></p> <p>Run inference on all images and videos that match a glob expression with <code>*</code> characters. <pre><code>from ultralytics import YOLO\n\n# Load a pretrained YOLOv8n model\nmodel = YOLO('yolov8n.pt')\n\n# Define a glob search for all JPG files in a directory\nsource = 'path/to/dir/*.jpg'\n\n# OR define a recursive glob search for all JPG files including subdirectories\nsource = 'path/to/dir/**/*.jpg'\n\n# Run inference on the source\nresults = model(source, stream=True)  # generator of Results objects\n</code></pre></p> <p>Run inference on a YouTube video. By using <code>stream=True</code>, you can create a generator of Results objects to reduce memory usage for long videos. <pre><code>from ultralytics import YOLO\n\n# Load a pretrained YOLOv8n model\nmodel = YOLO('yolov8n.pt')\n\n# Define source as YouTube video URL\nsource = 'https://youtu.be/LNwODJXcvt4'\n\n# Run inference on the source\nresults = model(source, stream=True)  # generator of Results objects\n</code></pre></p> <p>Run inference on remote streaming sources using RTSP, RTMP, TCP and IP address protocols. If multiple streams are provided in a <code>*.streams</code> text file then batched inference will run, i.e. 8 streams will run at batch-size 8, otherwise single streams will run at batch-size 1. <pre><code>from ultralytics import YOLO\n\n# Load a pretrained YOLOv8n model\nmodel = YOLO('yolov8n.pt')\n\n# Single stream with batch-size 1 inference\nsource = 'rtsp://example.com/media.mp4'  # RTSP, RTMP, TCP or IP streaming address\n\n# Multiple streams with batched inference (i.e. batch-size 8 for 8 streams)\nsource = 'path/to/list.streams'  # *.streams text file with one streaming address per row\n\n# Run inference on the source\nresults = model(source, stream=True)  # generator of Results objects\n</code></pre></p>"},{"location":"modes/predict/#inference-arguments","title":"Inference Arguments","text":"<p><code>model.predict()</code> accepts multiple arguments that can be passed at inference time to override defaults:</p> <p>Example</p> <pre><code>from ultralytics import YOLO\n\n# Load a pretrained YOLOv8n model\nmodel = YOLO('yolov8n.pt')\n\n# Run inference on 'bus.jpg' with arguments\nmodel.predict('bus.jpg', save=True, imgsz=320, conf=0.5)\n</code></pre> <p>Inference arguments:</p> Name Type Default Description <code>source</code> <code>str</code> <code>'ultralytics/assets'</code> source directory for images or videos <code>conf</code> <code>float</code> <code>0.25</code> object confidence threshold for detection <code>iou</code> <code>float</code> <code>0.7</code> intersection over union (IoU) threshold for NMS <code>imgsz</code> <code>int or tuple</code> <code>640</code> image size as scalar or (h, w) list, i.e. (640, 480) <code>half</code> <code>bool</code> <code>False</code> use half precision (FP16) <code>device</code> <code>None or str</code> <code>None</code> device to run on, i.e. cuda device=0/1/2/3 or device=cpu <code>max_det</code> <code>int</code> <code>300</code> maximum number of detections per image <code>vid_stride</code> <code>bool</code> <code>False</code> video frame-rate stride <code>stream_buffer</code> <code>bool</code> <code>False</code> buffer all streaming frames (True) or return the most recent frame (False) <code>visualize</code> <code>bool</code> <code>False</code> visualize model features <code>augment</code> <code>bool</code> <code>False</code> apply image augmentation to prediction sources <code>agnostic_nms</code> <code>bool</code> <code>False</code> class-agnostic NMS <code>classes</code> <code>list[int]</code> <code>None</code> filter results by class, i.e. classes=0, or classes=[0,2,3] <code>retina_masks</code> <code>bool</code> <code>False</code> use high-resolution segmentation masks <code>embed</code> <code>list[int]</code> <code>None</code> return feature vectors/embeddings from given layers <p>Visualization arguments:</p> Name Type Default Description <code>show</code> <code>bool</code> <code>False</code> show predicted images and videos if environment allows <code>save</code> <code>bool</code> <code>False</code> save predicted images and videos <code>save_frames</code> <code>bool</code> <code>False</code> save predicted individual video frames <code>save_txt</code> <code>bool</code> <code>False</code> save results as <code>.txt</code> file <code>save_conf</code> <code>bool</code> <code>False</code> save results with confidence scores <code>save_crop</code> <code>bool</code> <code>False</code> save cropped images with results <code>show_labels</code> <code>bool</code> <code>True</code> show prediction labels, i.e. 'person' <code>show_conf</code> <code>bool</code> <code>True</code> show prediction confidence, i.e. '0.99' <code>show_boxes</code> <code>bool</code> <code>True</code> show prediction boxes <code>line_width</code> <code>None or int</code> <code>None</code> line width of the bounding boxes. Scaled to image size if None."},{"location":"modes/predict/#image-and-video-formats","title":"Image and Video Formats","text":"<p>YOLOv8 supports various image and video formats, as specified in data/utils.py. See the tables below for the valid suffixes and example predict commands.</p>"},{"location":"modes/predict/#images","title":"Images","text":"<p>The below table contains valid Ultralytics image formats.</p> Image Suffixes Example Predict Command Reference .bmp <code>yolo predict source=image.bmp</code> Microsoft BMP File Format .dng <code>yolo predict source=image.dng</code> Adobe DNG .jpeg <code>yolo predict source=image.jpeg</code> JPEG .jpg <code>yolo predict source=image.jpg</code> JPEG .mpo <code>yolo predict source=image.mpo</code> Multi Picture Object .png <code>yolo predict source=image.png</code> Portable Network Graphics .tif <code>yolo predict source=image.tif</code> Tag Image File Format .tiff <code>yolo predict source=image.tiff</code> Tag Image File Format .webp <code>yolo predict source=image.webp</code> WebP .pfm <code>yolo predict source=image.pfm</code> Portable FloatMap"},{"location":"modes/predict/#videos","title":"Videos","text":"<p>The below table contains valid Ultralytics video formats.</p> Video Suffixes Example Predict Command Reference .asf <code>yolo predict source=video.asf</code> Advanced Systems Format .avi <code>yolo predict source=video.avi</code> Audio Video Interleave .gif <code>yolo predict source=video.gif</code> Graphics Interchange Format .m4v <code>yolo predict source=video.m4v</code> MPEG-4 Part 14 .mkv <code>yolo predict source=video.mkv</code> Matroska .mov <code>yolo predict source=video.mov</code> QuickTime File Format .mp4 <code>yolo predict source=video.mp4</code> MPEG-4 Part 14 - Wikipedia .mpeg <code>yolo predict source=video.mpeg</code> MPEG-1 Part 2 .mpg <code>yolo predict source=video.mpg</code> MPEG-1 Part 2 .ts <code>yolo predict source=video.ts</code> MPEG Transport Stream .wmv <code>yolo predict source=video.wmv</code> Windows Media Video .webm <code>yolo predict source=video.webm</code> WebM Project"},{"location":"modes/predict/#working-with-results","title":"Working with Results","text":"<p>All Ultralytics <code>predict()</code> calls will return a list of <code>Results</code> objects:</p> <p>Results</p> <pre><code>from ultralytics import YOLO\n\n# Load a pretrained YOLOv8n model\nmodel = YOLO('yolov8n.pt')\n\n# Run inference on an image\nresults = model('bus.jpg')  # list of 1 Results object\nresults = model(['bus.jpg', 'zidane.jpg'])  # list of 2 Results objects\n</code></pre> <p><code>Results</code> objects have the following attributes:</p> Attribute Type Description <code>orig_img</code> <code>numpy.ndarray</code> The original image as a numpy array. <code>orig_shape</code> <code>tuple</code> The original image shape in (height, width) format. <code>boxes</code> <code>Boxes, optional</code> A Boxes object containing the detection bounding boxes. <code>masks</code> <code>Masks, optional</code> A Masks object containing the detection masks. <code>probs</code> <code>Probs, optional</code> A Probs object containing probabilities of each class for classification task. <code>keypoints</code> <code>Keypoints, optional</code> A Keypoints object containing detected keypoints for each object. <code>speed</code> <code>dict</code> A dictionary of preprocess, inference, and postprocess speeds in milliseconds per image. <code>names</code> <code>dict</code> A dictionary of class names. <code>path</code> <code>str</code> The path to the image file. <p><code>Results</code> objects have the following methods:</p> Method Return Type Description <code>__getitem__()</code> <code>Results</code> Return a Results object for the specified index. <code>__len__()</code> <code>int</code> Return the number of detections in the Results object. <code>update()</code> <code>None</code> Update the boxes, masks, and probs attributes of the Results object. <code>cpu()</code> <code>Results</code> Return a copy of the Results object with all tensors on CPU memory. <code>numpy()</code> <code>Results</code> Return a copy of the Results object with all tensors as numpy arrays. <code>cuda()</code> <code>Results</code> Return a copy of the Results object with all tensors on GPU memory. <code>to()</code> <code>Results</code> Return a copy of the Results object with tensors on the specified device and dtype. <code>new()</code> <code>Results</code> Return a new Results object with the same image, path, and names. <code>keys()</code> <code>List[str]</code> Return a list of non-empty attribute names. <code>plot()</code> <code>numpy.ndarray</code> Plots the detection results. Returns a numpy array of the annotated image. <code>verbose()</code> <code>str</code> Return log string for each task. <code>save_txt()</code> <code>None</code> Save predictions into a txt file. <code>save_crop()</code> <code>None</code> Save cropped predictions to <code>save_dir/cls/file_name.jpg</code>. <code>tojson()</code> <code>None</code> Convert the object to JSON format. <p>For more details see the <code>Results</code> class documentation.</p>"},{"location":"modes/predict/#boxes","title":"Boxes","text":"<p><code>Boxes</code> object can be used to index, manipulate, and convert bounding boxes to different formats.</p> <p>Boxes</p> <pre><code>from ultralytics import YOLO\n\n# Load a pretrained YOLOv8n model\nmodel = YOLO('yolov8n.pt')\n\n# Run inference on an image\nresults = model('bus.jpg')  # results list\n\n# View results\nfor r in results:\n    print(r.boxes)  # print the Boxes object containing the detection bounding boxes\n</code></pre> <p>Here is a table for the <code>Boxes</code> class methods and properties, including their name, type, and description:</p> Name Type Description <code>cpu()</code> Method Move the object to CPU memory. <code>numpy()</code> Method Convert the object to a numpy array. <code>cuda()</code> Method Move the object to CUDA memory. <code>to()</code> Method Move the object to the specified device. <code>xyxy</code> Property (<code>torch.Tensor</code>) Return the boxes in xyxy format. <code>conf</code> Property (<code>torch.Tensor</code>) Return the confidence values of the boxes. <code>cls</code> Property (<code>torch.Tensor</code>) Return the class values of the boxes. <code>id</code> Property (<code>torch.Tensor</code>) Return the track IDs of the boxes (if available). <code>xywh</code> Property (<code>torch.Tensor</code>) Return the boxes in xywh format. <code>xyxyn</code> Property (<code>torch.Tensor</code>) Return the boxes in xyxy format normalized by original image size. <code>xywhn</code> Property (<code>torch.Tensor</code>) Return the boxes in xywh format normalized by original image size. <p>For more details see the <code>Boxes</code> class documentation.</p>"},{"location":"modes/predict/#masks","title":"Masks","text":"<p><code>Masks</code> object can be used index, manipulate and convert masks to segments.</p> <p>Masks</p> <pre><code>from ultralytics import YOLO\n\n# Load a pretrained YOLOv8n-seg Segment model\nmodel = YOLO('yolov8n-seg.pt')\n\n# Run inference on an image\nresults = model('bus.jpg')  # results list\n\n# View results\nfor r in results:\n    print(r.masks)  # print the Masks object containing the detected instance masks\n</code></pre> <p>Here is a table for the <code>Masks</code> class methods and properties, including their name, type, and description:</p> Name Type Description <code>cpu()</code> Method Returns the masks tensor on CPU memory. <code>numpy()</code> Method Returns the masks tensor as a numpy array. <code>cuda()</code> Method Returns the masks tensor on GPU memory. <code>to()</code> Method Returns the masks tensor with the specified device and dtype. <code>xyn</code> Property (<code>torch.Tensor</code>) A list of normalized segments represented as tensors. <code>xy</code> Property (<code>torch.Tensor</code>) A list of segments in pixel coordinates represented as tensors. <p>For more details see the <code>Masks</code> class documentation.</p>"},{"location":"modes/predict/#keypoints","title":"Keypoints","text":"<p><code>Keypoints</code> object can be used index, manipulate and normalize coordinates.</p> <p>Keypoints</p> <pre><code>from ultralytics import YOLO\n\n# Load a pretrained YOLOv8n-pose Pose model\nmodel = YOLO('yolov8n-pose.pt')\n\n# Run inference on an image\nresults = model('bus.jpg')  # results list\n\n# View results\nfor r in results:\n    print(r.keypoints)  # print the Keypoints object containing the detected keypoints\n</code></pre> <p>Here is a table for the <code>Keypoints</code> class methods and properties, including their name, type, and description:</p> Name Type Description <code>cpu()</code> Method Returns the keypoints tensor on CPU memory. <code>numpy()</code> Method Returns the keypoints tensor as a numpy array. <code>cuda()</code> Method Returns the keypoints tensor on GPU memory. <code>to()</code> Method Returns the keypoints tensor with the specified device and dtype. <code>xyn</code> Property (<code>torch.Tensor</code>) A list of normalized keypoints represented as tensors. <code>xy</code> Property (<code>torch.Tensor</code>) A list of keypoints in pixel coordinates represented as tensors. <code>conf</code> Property (<code>torch.Tensor</code>) Returns confidence values of keypoints if available, else None. <p>For more details see the <code>Keypoints</code> class documentation.</p>"},{"location":"modes/predict/#probs","title":"Probs","text":"<p><code>Probs</code> object can be used index, get <code>top1</code> and <code>top5</code> indices and scores of classification.</p> <p>Probs</p> <pre><code>from ultralytics import YOLO\n\n# Load a pretrained YOLOv8n-cls Classify model\nmodel = YOLO('yolov8n-cls.pt')\n\n# Run inference on an image\nresults = model('bus.jpg')  # results list\n\n# View results\nfor r in results:\n    print(r.probs)  # print the Probs object containing the detected class probabilities\n</code></pre> <p>Here's a table summarizing the methods and properties for the <code>Probs</code> class:</p> Name Type Description <code>cpu()</code> Method Returns a copy of the probs tensor on CPU memory. <code>numpy()</code> Method Returns a copy of the probs tensor as a numpy array. <code>cuda()</code> Method Returns a copy of the probs tensor on GPU memory. <code>to()</code> Method Returns a copy of the probs tensor with the specified device and dtype. <code>top1</code> Property (<code>int</code>) Index of the top 1 class. <code>top5</code> Property (<code>list[int]</code>) Indices of the top 5 classes. <code>top1conf</code> Property (<code>torch.Tensor</code>) Confidence of the top 1 class. <code>top5conf</code> Property (<code>torch.Tensor</code>) Confidences of the top 5 classes. <p>For more details see the <code>Probs</code> class documentation.</p>"},{"location":"modes/predict/#plotting-results","title":"Plotting Results","text":"<p>You can use the <code>plot()</code> method of a <code>Result</code> objects to visualize predictions. It plots all prediction types (boxes, masks, keypoints, probabilities, etc.) contained in the <code>Results</code> object onto a numpy array that can then be shown or saved.</p> <p>Plotting</p> <pre><code>from PIL import Image\nfrom ultralytics import YOLO\n\n# Load a pretrained YOLOv8n model\nmodel = YOLO('yolov8n.pt')\n\n# Run inference on 'bus.jpg'\nresults = model('bus.jpg')  # results list\n\n# Show the results\nfor r in results:\n    im_array = r.plot()  # plot a BGR numpy array of predictions\n    im = Image.fromarray(im_array[..., ::-1])  # RGB PIL image\n    im.show()  # show image\n    im.save('results.jpg')  # save image\n</code></pre> <p>The <code>plot()</code> method supports the following arguments:</p> Argument Type Description Default <code>conf</code> <code>bool</code> Whether to plot the detection confidence score. <code>True</code> <code>line_width</code> <code>float</code> The line width of the bounding boxes. If None, it is scaled to the image size. <code>None</code> <code>font_size</code> <code>float</code> The font size of the text. If None, it is scaled to the image size. <code>None</code> <code>font</code> <code>str</code> The font to use for the text. <code>'Arial.ttf'</code> <code>pil</code> <code>bool</code> Whether to return the image as a PIL Image. <code>False</code> <code>img</code> <code>numpy.ndarray</code> Plot to another image. if not, plot to original image. <code>None</code> <code>im_gpu</code> <code>torch.Tensor</code> Normalized image in gpu with shape (1, 3, 640, 640), for faster mask plotting. <code>None</code> <code>kpt_radius</code> <code>int</code> Radius of the drawn keypoints. Default is 5. <code>5</code> <code>kpt_line</code> <code>bool</code> Whether to draw lines connecting keypoints. <code>True</code> <code>labels</code> <code>bool</code> Whether to plot the label of bounding boxes. <code>True</code> <code>boxes</code> <code>bool</code> Whether to plot the bounding boxes. <code>True</code> <code>masks</code> <code>bool</code> Whether to plot the masks. <code>True</code> <code>probs</code> <code>bool</code> Whether to plot classification probability <code>True</code>"},{"location":"modes/predict/#thread-safe-inference","title":"Thread-Safe Inference","text":"<p>Ensuring thread safety during inference is crucial when you are running multiple YOLO models in parallel across different threads. Thread-safe inference guarantees that each thread's predictions are isolated and do not interfere with one another, avoiding race conditions and ensuring consistent and reliable outputs.</p> <p>When using YOLO models in a multi-threaded application, it's important to instantiate separate model objects for each thread or employ thread-local storage to prevent conflicts:</p> <p>Thread-Safe Inference</p> <p>Instantiate a single model inside each thread for thread-safe inference: <pre><code>from ultralytics import YOLO\nfrom threading import Thread\n\ndef thread_safe_predict(image_path):\n    # Instantiate a new model inside the thread\n    local_model = YOLO(\"yolov8n.pt\")\n    results = local_model.predict(image_path)\n    # Process results\n\n\n# Starting threads that each have their own model instance\nThread(target=thread_safe_predict, args=(\"image1.jpg\",)).start()\nThread(target=thread_safe_predict, args=(\"image2.jpg\",)).start()\n</code></pre></p> <p>For an in-depth look at thread-safe inference with YOLO models and step-by-step instructions, please refer to our YOLO Thread-Safe Inference Guide. This guide will provide you with all the necessary information to avoid common pitfalls and ensure that your multi-threaded inference runs smoothly.</p>"},{"location":"modes/predict/#streaming-source-for-loop","title":"Streaming Source <code>for</code>-loop","text":"<p>Here's a Python script using OpenCV (<code>cv2</code>) and YOLOv8 to run inference on video frames. This script assumes you have already installed the necessary packages (<code>opencv-python</code> and <code>ultralytics</code>).</p> <p>Streaming for-loop</p> <pre><code>import cv2\nfrom ultralytics import YOLO\n\n# Load the YOLOv8 model\nmodel = YOLO('yolov8n.pt')\n\n# Open the video file\nvideo_path = \"path/to/your/video/file.mp4\"\ncap = cv2.VideoCapture(video_path)\n\n# Loop through the video frames\nwhile cap.isOpened():\n    # Read a frame from the video\n    success, frame = cap.read()\n\n    if success:\n        # Run YOLOv8 inference on the frame\n        results = model(frame)\n\n        # Visualize the results on the frame\n        annotated_frame = results[0].plot()\n\n        # Display the annotated frame\n        cv2.imshow(\"YOLOv8 Inference\", annotated_frame)\n\n        # Break the loop if 'q' is pressed\n        if cv2.waitKey(1) &amp; 0xFF == ord(\"q\"):\n            break\n    else:\n        # Break the loop if the end of the video is reached\n        break\n\n# Release the video capture object and close the display window\ncap.release()\ncv2.destroyAllWindows()\n</code></pre> <p>This script will run predictions on each frame of the video, visualize the results, and display them in a window. The loop can be exited by pressing 'q'.</p>"},{"location":"modes/track/","title":"Multi-Object Tracking with Ultralytics YOLO","text":"<p>Object tracking in the realm of video analytics is a critical task that not only identifies the location and class of objects within the frame but also maintains a unique ID for each detected object as the video progresses. The applications are limitless\u2014ranging from surveillance and security to real-time sports analytics.</p>"},{"location":"modes/track/#why-choose-ultralytics-yolo-for-object-tracking","title":"Why Choose Ultralytics YOLO for Object Tracking?","text":"<p>The output from Ultralytics trackers is consistent with standard object detection but has the added value of object IDs. This makes it easy to track objects in video streams and perform subsequent analytics. Here's why you should consider using Ultralytics YOLO for your object tracking needs:</p> <ul> <li>Efficiency: Process video streams in real-time without compromising accuracy.</li> <li>Flexibility: Supports multiple tracking algorithms and configurations.</li> <li>Ease of Use: Simple Python API and CLI options for quick integration and deployment.</li> <li>Customizability: Easy to use with custom trained YOLO models, allowing integration into domain-specific applications.</li> </ul> <p> Watch: Object Detection and Tracking with Ultralytics YOLOv8. </p>"},{"location":"modes/track/#real-world-applications","title":"Real-world Applications","text":"Transportation Retail Aquaculture Vehicle Tracking People Tracking Fish Tracking"},{"location":"modes/track/#features-at-a-glance","title":"Features at a Glance","text":"<p>Ultralytics YOLO extends its object detection features to provide robust and versatile object tracking:</p> <ul> <li>Real-Time Tracking: Seamlessly track objects in high-frame-rate videos.</li> <li>Multiple Tracker Support: Choose from a variety of established tracking algorithms.</li> <li>Customizable Tracker Configurations: Tailor the tracking algorithm to meet specific requirements by adjusting various parameters.</li> </ul>"},{"location":"modes/track/#available-trackers","title":"Available Trackers","text":"<p>Ultralytics YOLO supports the following tracking algorithms. They can be enabled by passing the relevant YAML configuration file such as <code>tracker=tracker_type.yaml</code>:</p> <ul> <li>BoT-SORT - Use <code>botsort.yaml</code> to enable this tracker.</li> <li>ByteTrack - Use <code>bytetrack.yaml</code> to enable this tracker.</li> </ul> <p>The default tracker is BoT-SORT.</p>"},{"location":"modes/track/#tracking","title":"Tracking","text":"<p>To run the tracker on video streams, use a trained Detect, Segment or Pose model such as YOLOv8n, YOLOv8n-seg and YOLOv8n-pose.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load an official or custom model\nmodel = YOLO('yolov8n.pt')  # Load an official Detect model\nmodel = YOLO('yolov8n-seg.pt')  # Load an official Segment model\nmodel = YOLO('yolov8n-pose.pt')  # Load an official Pose model\nmodel = YOLO('path/to/best.pt')  # Load a custom trained model\n\n# Perform tracking with the model\nresults = model.track(source=\"https://youtu.be/LNwODJXcvt4\", show=True)  # Tracking with default tracker\nresults = model.track(source=\"https://youtu.be/LNwODJXcvt4\", show=True, tracker=\"bytetrack.yaml\")  # Tracking with ByteTrack tracker\n</code></pre> <pre><code># Perform tracking with various models using the command line interface\nyolo track model=yolov8n.pt source=\"https://youtu.be/LNwODJXcvt4\"  # Official Detect model\nyolo track model=yolov8n-seg.pt source=\"https://youtu.be/LNwODJXcvt4\"  # Official Segment model\nyolo track model=yolov8n-pose.pt source=\"https://youtu.be/LNwODJXcvt4\"  # Official Pose model\nyolo track model=path/to/best.pt source=\"https://youtu.be/LNwODJXcvt4\"  # Custom trained model\n\n# Track using ByteTrack tracker\nyolo track model=path/to/best.pt tracker=\"bytetrack.yaml\"\n</code></pre> <p>As can be seen in the above usage, tracking is available for all Detect, Segment and Pose models run on videos or streaming sources.</p>"},{"location":"modes/track/#configuration","title":"Configuration","text":""},{"location":"modes/track/#tracking-arguments","title":"Tracking Arguments","text":"<p>Tracking configuration shares properties with Predict mode, such as <code>conf</code>, <code>iou</code>, and <code>show</code>. For further configurations, refer to the Predict model page.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Configure the tracking parameters and run the tracker\nmodel = YOLO('yolov8n.pt')\nresults = model.track(source=\"https://youtu.be/LNwODJXcvt4\", conf=0.3, iou=0.5, show=True)\n</code></pre> <pre><code># Configure tracking parameters and run the tracker using the command line interface\nyolo track model=yolov8n.pt source=\"https://youtu.be/LNwODJXcvt4\" conf=0.3, iou=0.5 show\n</code></pre>"},{"location":"modes/track/#tracker-selection","title":"Tracker Selection","text":"<p>Ultralytics also allows you to use a modified tracker configuration file. To do this, simply make a copy of a tracker config file (for example, <code>custom_tracker.yaml</code>) from ultralytics/cfg/trackers and modify any configurations (except the <code>tracker_type</code>) as per your needs.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load the model and run the tracker with a custom configuration file\nmodel = YOLO('yolov8n.pt')\nresults = model.track(source=\"https://youtu.be/LNwODJXcvt4\", tracker='custom_tracker.yaml')\n</code></pre> <pre><code># Load the model and run the tracker with a custom configuration file using the command line interface\nyolo track model=yolov8n.pt source=\"https://youtu.be/LNwODJXcvt4\" tracker='custom_tracker.yaml'\n</code></pre> <p>For a comprehensive list of tracking arguments, refer to the ultralytics/cfg/trackers page.</p>"},{"location":"modes/track/#python-examples","title":"Python Examples","text":""},{"location":"modes/track/#persisting-tracks-loop","title":"Persisting Tracks Loop","text":"<p>Here is a Python script using OpenCV (<code>cv2</code>) and YOLOv8 to run object tracking on video frames. This script still assumes you have already installed the necessary packages (<code>opencv-python</code> and <code>ultralytics</code>). The <code>persist=True</code> argument tells the tracker that the current image or frame is the next in a sequence and to expect tracks from the previous image in the current image.</p> <p>Streaming for-loop with tracking</p> <pre><code>import cv2\nfrom ultralytics import YOLO\n\n# Load the YOLOv8 model\nmodel = YOLO('yolov8n.pt')\n\n# Open the video file\nvideo_path = \"path/to/video.mp4\"\ncap = cv2.VideoCapture(video_path)\n\n# Loop through the video frames\nwhile cap.isOpened():\n    # Read a frame from the video\n    success, frame = cap.read()\n\n    if success:\n        # Run YOLOv8 tracking on the frame, persisting tracks between frames\n        results = model.track(frame, persist=True)\n\n        # Visualize the results on the frame\n        annotated_frame = results[0].plot()\n\n        # Display the annotated frame\n        cv2.imshow(\"YOLOv8 Tracking\", annotated_frame)\n\n        # Break the loop if 'q' is pressed\n        if cv2.waitKey(1) &amp; 0xFF == ord(\"q\"):\n            break\n    else:\n        # Break the loop if the end of the video is reached\n        break\n\n# Release the video capture object and close the display window\ncap.release()\ncv2.destroyAllWindows()\n</code></pre> <p>Please note the change from <code>model(frame)</code> to <code>model.track(frame)</code>, which enables object tracking instead of simple detection. This modified script will run the tracker on each frame of the video, visualize the results, and display them in a window. The loop can be exited by pressing 'q'.</p>"},{"location":"modes/track/#plotting-tracks-over-time","title":"Plotting Tracks Over Time","text":"<p>Visualizing object tracks over consecutive frames can provide valuable insights into the movement patterns and behavior of detected objects within a video. With Ultralytics YOLOv8, plotting these tracks is a seamless and efficient process.</p> <p>In the following example, we demonstrate how to utilize YOLOv8's tracking capabilities to plot the movement of detected objects across multiple video frames. This script involves opening a video file, reading it frame by frame, and utilizing the YOLO model to identify and track various objects. By retaining the center points of the detected bounding boxes and connecting them, we can draw lines that represent the paths followed by the tracked objects.</p> <p>Plotting tracks over multiple video frames</p> <pre><code>from collections import defaultdict\n\nimport cv2\nimport numpy as np\n\nfrom ultralytics import YOLO\n\n# Load the YOLOv8 model\nmodel = YOLO('yolov8n.pt')\n\n# Open the video file\nvideo_path = \"path/to/video.mp4\"\ncap = cv2.VideoCapture(video_path)\n\n# Store the track history\ntrack_history = defaultdict(lambda: [])\n\n# Loop through the video frames\nwhile cap.isOpened():\n    # Read a frame from the video\n    success, frame = cap.read()\n\n    if success:\n        # Run YOLOv8 tracking on the frame, persisting tracks between frames\n        results = model.track(frame, persist=True)\n\n        # Get the boxes and track IDs\n        boxes = results[0].boxes.xywh.cpu()\n        track_ids = results[0].boxes.id.int().cpu().tolist()\n\n        # Visualize the results on the frame\n        annotated_frame = results[0].plot()\n\n        # Plot the tracks\n        for box, track_id in zip(boxes, track_ids):\n            x, y, w, h = box\n            track = track_history[track_id]\n            track.append((float(x), float(y)))  # x, y center point\n            if len(track) &gt; 30:  # retain 90 tracks for 90 frames\n                track.pop(0)\n\n            # Draw the tracking lines\n            points = np.hstack(track).astype(np.int32).reshape((-1, 1, 2))\n            cv2.polylines(annotated_frame, [points], isClosed=False, color=(230, 230, 230), thickness=10)\n\n        # Display the annotated frame\n        cv2.imshow(\"YOLOv8 Tracking\", annotated_frame)\n\n        # Break the loop if 'q' is pressed\n        if cv2.waitKey(1) &amp; 0xFF == ord(\"q\"):\n            break\n    else:\n        # Break the loop if the end of the video is reached\n        break\n\n# Release the video capture object and close the display window\ncap.release()\ncv2.destroyAllWindows()\n</code></pre>"},{"location":"modes/track/#multithreaded-tracking","title":"Multithreaded Tracking","text":"<p>Multithreaded tracking provides the capability to run object tracking on multiple video streams simultaneously. This is particularly useful when handling multiple video inputs, such as from multiple surveillance cameras, where concurrent processing can greatly enhance efficiency and performance.</p> <p>In the provided Python script, we make use of Python's <code>threading</code> module to run multiple instances of the tracker concurrently. Each thread is responsible for running the tracker on one video file, and all the threads run simultaneously in the background.</p> <p>To ensure that each thread receives the correct parameters (the video file, the model to use and the file index), we define a function <code>run_tracker_in_thread</code> that accepts these parameters and contains the main tracking loop. This function reads the video frame by frame, runs the tracker, and displays the results.</p> <p>Two different models are used in this example: <code>yolov8n.pt</code> and <code>yolov8n-seg.pt</code>, each tracking objects in a different video file. The video files are specified in <code>video_file1</code> and <code>video_file2</code>.</p> <p>The <code>daemon=True</code> parameter in <code>threading.Thread</code> means that these threads will be closed as soon as the main program finishes. We then start the threads with <code>start()</code> and use <code>join()</code> to make the main thread wait until both tracker threads have finished.</p> <p>Finally, after all threads have completed their task, the windows displaying the results are closed using <code>cv2.destroyAllWindows()</code>.</p> <p>Streaming for-loop with tracking</p> <pre><code>import threading\nimport cv2\nfrom ultralytics import YOLO\n\n\ndef run_tracker_in_thread(filename, model, file_index):\n    \"\"\"\n    Runs a video file or webcam stream concurrently with the YOLOv8 model using threading.\n\n    This function captures video frames from a given file or camera source and utilizes the YOLOv8 model for object\n    tracking. The function runs in its own thread for concurrent processing.\n\n    Args:\n        filename (str): The path to the video file or the identifier for the webcam/external camera source.\n        model (obj): The YOLOv8 model object.\n        file_index (int): An index to uniquely identify the file being processed, used for display purposes.\n\n    Note:\n        Press 'q' to quit the video display window.\n    \"\"\"\n    video = cv2.VideoCapture(filename)  # Read the video file\n\n    while True:\n        ret, frame = video.read()  # Read the video frames\n\n        # Exit the loop if no more frames in either video\n        if not ret:\n            break\n\n        # Track objects in frames if available\n        results = model.track(frame, persist=True)\n        res_plotted = results[0].plot()\n        cv2.imshow(f\"Tracking_Stream_{file_index}\", res_plotted)\n\n        key = cv2.waitKey(1)\n        if key == ord('q'):\n            break\n\n    # Release video sources\n    video.release()\n\n\n# Load the models\nmodel1 = YOLO('yolov8n.pt')\nmodel2 = YOLO('yolov8n-seg.pt')\n\n# Define the video files for the trackers\nvideo_file1 = \"path/to/video1.mp4\"  # Path to video file, 0 for webcam\nvideo_file2 = 0  # Path to video file, 0 for webcam, 1 for external camera\n\n# Create the tracker threads\ntracker_thread1 = threading.Thread(target=run_tracker_in_thread, args=(video_file1, model1, 1), daemon=True)\ntracker_thread2 = threading.Thread(target=run_tracker_in_thread, args=(video_file2, model2, 2), daemon=True)\n\n# Start the tracker threads\ntracker_thread1.start()\ntracker_thread2.start()\n\n# Wait for the tracker threads to finish\ntracker_thread1.join()\ntracker_thread2.join()\n\n# Clean up and close windows\ncv2.destroyAllWindows()\n</code></pre> <p>This example can easily be extended to handle more video files and models by creating more threads and applying the same methodology.</p>"},{"location":"modes/track/#contribute-new-trackers","title":"Contribute New Trackers","text":"<p>Are you proficient in multi-object tracking and have successfully implemented or adapted a tracking algorithm with Ultralytics YOLO? We invite you to contribute to our Trackers section in ultralytics/cfg/trackers! Your real-world applications and solutions could be invaluable for users working on tracking tasks.</p> <p>By contributing to this section, you help expand the scope of tracking solutions available within the Ultralytics YOLO framework, adding another layer of functionality and utility for the community.</p> <p>To initiate your contribution, please refer to our Contributing Guide for comprehensive instructions on submitting a Pull Request (PR) \ud83d\udee0\ufe0f. We are excited to see what you bring to the table!</p> <p>Together, let's enhance the tracking capabilities of the Ultralytics YOLO ecosystem \ud83d\ude4f!</p>"},{"location":"modes/train/","title":"Model Training with Ultralytics YOLO","text":""},{"location":"modes/train/#introduction","title":"Introduction","text":"<p>Training a deep learning model involves feeding it data and adjusting its parameters so that it can make accurate predictions. Train mode in Ultralytics YOLOv8 is engineered for effective and efficient training of object detection models, fully utilizing modern hardware capabilities. This guide aims to cover all the details you need to get started with training your own models using YOLOv8's robust set of features.</p> <p> Watch: How to Train a YOLOv8 model on Your Custom Dataset in Google Colab. </p>"},{"location":"modes/train/#why-choose-ultralytics-yolo-for-training","title":"Why Choose Ultralytics YOLO for Training?","text":"<p>Here are some compelling reasons to opt for YOLOv8's Train mode:</p> <ul> <li>Efficiency: Make the most out of your hardware, whether you're on a single-GPU setup or scaling across multiple GPUs.</li> <li>Versatility: Train on custom datasets in addition to readily available ones like COCO, VOC, and ImageNet.</li> <li>User-Friendly: Simple yet powerful CLI and Python interfaces for a straightforward training experience.</li> <li>Hyperparameter Flexibility: A broad range of customizable hyperparameters to fine-tune model performance.</li> </ul>"},{"location":"modes/train/#key-features-of-train-mode","title":"Key Features of Train Mode","text":"<p>The following are some notable features of YOLOv8's Train mode:</p> <ul> <li>Automatic Dataset Download: Standard datasets like COCO, VOC, and ImageNet are downloaded automatically on first use.</li> <li>Multi-GPU Support: Scale your training efforts seamlessly across multiple GPUs to expedite the process.</li> <li>Hyperparameter Configuration: The option to modify hyperparameters through YAML configuration files or CLI arguments.</li> <li>Visualization and Monitoring: Real-time tracking of training metrics and visualization of the learning process for better insights.</li> </ul> <p>Tip</p> <ul> <li>YOLOv8 datasets like COCO, VOC, ImageNet and many others automatically download on first use, i.e. <code>yolo train data=coco.yaml</code></li> </ul>"},{"location":"modes/train/#usage-examples","title":"Usage Examples","text":"<p>Train YOLOv8n on the COCO128 dataset for 100 epochs at image size 640. The training device can be specified using the <code>device</code> argument. If no argument is passed GPU <code>device=0</code> will be used if available, otherwise <code>device=cpu</code> will be used. See Arguments section below for a full list of training arguments.</p> <p>Single-GPU and CPU Training Example</p> <p>Device is determined automatically. If a GPU is available then it will be used, otherwise training will start on CPU.</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n.yaml')  # build a new model from YAML\nmodel = YOLO('yolov8n.pt')  # load a pretrained model (recommended for training)\nmodel = YOLO('yolov8n.yaml').load('yolov8n.pt')  # build from YAML and transfer weights\n\n# Train the model\nresults = model.train(data='coco128.yaml', epochs=100, imgsz=640)\n</code></pre> <pre><code># Build a new model from YAML and start training from scratch\nyolo detect train data=coco128.yaml model=yolov8n.yaml epochs=100 imgsz=640\n\n# Start training from a pretrained *.pt model\nyolo detect train data=coco128.yaml model=yolov8n.pt epochs=100 imgsz=640\n\n# Build a new model from YAML, transfer pretrained weights to it and start training\nyolo detect train data=coco128.yaml model=yolov8n.yaml pretrained=yolov8n.pt epochs=100 imgsz=640\n</code></pre>"},{"location":"modes/train/#multi-gpu-training","title":"Multi-GPU Training","text":"<p>Multi-GPU training allows for more efficient utilization of available hardware resources by distributing the training load across multiple GPUs. This feature is available through both the Python API and the command-line interface. To enable multi-GPU training, specify the GPU device IDs you wish to use.</p> <p>Multi-GPU Training Example</p> <p>To train with 2 GPUs, CUDA devices 0 and 1 use the following commands. Expand to additional GPUs as required.</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n.pt')  # load a pretrained model (recommended for training)\n\n# Train the model with 2 GPUs\nresults = model.train(data='coco128.yaml', epochs=100, imgsz=640, device=[0, 1])\n</code></pre> <pre><code># Start training from a pretrained *.pt model using GPUs 0 and 1\nyolo detect train data=coco128.yaml model=yolov8n.pt epochs=100 imgsz=640 device=0,1\n</code></pre>"},{"location":"modes/train/#apple-m1-and-m2-mps-training","title":"Apple M1 and M2 MPS Training","text":"<p>With the support for Apple M1 and M2 chips integrated in the Ultralytics YOLO models, it's now possible to train your models on devices utilizing the powerful Metal Performance Shaders (MPS) framework. The MPS offers a high-performance way of executing computation and image processing tasks on Apple's custom silicon.</p> <p>To enable training on Apple M1 and M2 chips, you should specify 'mps' as your device when initiating the training process. Below is an example of how you could do this in Python and via the command line:</p> <p>MPS Training Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n.pt')  # load a pretrained model (recommended for training)\n\n# Train the model with 2 GPUs\nresults = model.train(data='coco128.yaml', epochs=100, imgsz=640, device='mps')\n</code></pre> <pre><code># Start training from a pretrained *.pt model using GPUs 0 and 1\nyolo detect train data=coco128.yaml model=yolov8n.pt epochs=100 imgsz=640 device=mps\n</code></pre> <p>While leveraging the computational power of the M1/M2 chips, this enables more efficient processing of the training tasks. For more detailed guidance and advanced configuration options, please refer to the PyTorch MPS documentation.</p>"},{"location":"modes/train/#resuming-interrupted-trainings","title":"Resuming Interrupted Trainings","text":"<p>Resuming training from a previously saved state is a crucial feature when working with deep learning models. This can come in handy in various scenarios, like when the training process has been unexpectedly interrupted, or when you wish to continue training a model with new data or for more epochs.</p> <p>When training is resumed, Ultralytics YOLO loads the weights from the last saved model and also restores the optimizer state, learning rate scheduler, and the epoch number. This allows you to continue the training process seamlessly from where it was left off.</p> <p>You can easily resume training in Ultralytics YOLO by setting the <code>resume</code> argument to <code>True</code> when calling the <code>train</code> method, and specifying the path to the <code>.pt</code> file containing the partially trained model weights.</p> <p>Below is an example of how to resume an interrupted training using Python and via the command line:</p> <p>Resume Training Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('path/to/last.pt')  # load a partially trained model\n\n# Resume training\nresults = model.train(resume=True)\n</code></pre> <pre><code># Resume an interrupted training\nyolo train resume model=path/to/last.pt\n</code></pre> <p>By setting <code>resume=True</code>, the <code>train</code> function will continue training from where it left off, using the state stored in the 'path/to/last.pt' file. If the <code>resume</code> argument is omitted or set to <code>False</code>, the <code>train</code> function will start a new training session.</p> <p>Remember that checkpoints are saved at the end of every epoch by default, or at fixed interval using the <code>save_period</code> argument, so you must complete at least 1 epoch to resume a training run.</p>"},{"location":"modes/train/#arguments","title":"Arguments","text":"<p>Training settings for YOLO models refer to the various hyperparameters and configurations used to train the model on a dataset. These settings can affect the model's performance, speed, and accuracy. Some common YOLO training settings include the batch size, learning rate, momentum, and weight decay. Other factors that may affect the training process include the choice of optimizer, the choice of loss function, and the size and composition of the training dataset. It is important to carefully tune and experiment with these settings to achieve the best possible performance for a given task.</p> Key Value Description <code>model</code> <code>None</code> path to model file, i.e. yolov8n.pt, yolov8n.yaml <code>data</code> <code>None</code> path to data file, i.e. coco128.yaml <code>epochs</code> <code>100</code> number of epochs to train for <code>time</code> <code>None</code> number of hours to train for, overrides epochs if supplied <code>patience</code> <code>50</code> epochs to wait for no observable improvement for early stopping of training <code>batch</code> <code>16</code> number of images per batch (-1 for AutoBatch) <code>imgsz</code> <code>640</code> size of input images as integer <code>save</code> <code>True</code> save train checkpoints and predict results <code>save_period</code> <code>-1</code> Save checkpoint every x epochs (disabled if &lt; 1) <code>cache</code> <code>False</code> True/ram, disk or False. Use cache for data loading <code>device</code> <code>None</code> device to run on, i.e. cuda device=0 or device=0,1,2,3 or device=cpu <code>workers</code> <code>8</code> number of worker threads for data loading (per RANK if DDP) <code>project</code> <code>None</code> project name <code>name</code> <code>None</code> experiment name <code>exist_ok</code> <code>False</code> whether to overwrite existing experiment <code>pretrained</code> <code>True</code> (bool or str) whether to use a pretrained model (bool) or a model to load weights from (str) <code>optimizer</code> <code>'auto'</code> optimizer to use, choices=[SGD, Adam, Adamax, AdamW, NAdam, RAdam, RMSProp, auto] <code>verbose</code> <code>False</code> whether to print verbose output <code>seed</code> <code>0</code> random seed for reproducibility <code>deterministic</code> <code>True</code> whether to enable deterministic mode <code>single_cls</code> <code>False</code> train multi-class data as single-class <code>rect</code> <code>False</code> rectangular training with each batch collated for minimum padding <code>cos_lr</code> <code>False</code> use cosine learning rate scheduler <code>close_mosaic</code> <code>10</code> (int) disable mosaic augmentation for final epochs (0 to disable) <code>resume</code> <code>False</code> resume training from last checkpoint <code>amp</code> <code>True</code> Automatic Mixed Precision (AMP) training, choices=[True, False] <code>fraction</code> <code>1.0</code> dataset fraction to train on (default is 1.0, all images in train set) <code>profile</code> <code>False</code> profile ONNX and TensorRT speeds during training for loggers <code>freeze</code> <code>None</code> (int or list, optional) freeze first n layers, or freeze list of layer indices during training <code>lr0</code> <code>0.01</code> initial learning rate (i.e. SGD=1E-2, Adam=1E-3) <code>lrf</code> <code>0.01</code> final learning rate (lr0 * lrf) <code>momentum</code> <code>0.937</code> SGD momentum/Adam beta1 <code>weight_decay</code> <code>0.0005</code> optimizer weight decay 5e-4 <code>warmup_epochs</code> <code>3.0</code> warmup epochs (fractions ok) <code>warmup_momentum</code> <code>0.8</code> warmup initial momentum <code>warmup_bias_lr</code> <code>0.1</code> warmup initial bias lr <code>box</code> <code>7.5</code> box loss gain <code>cls</code> <code>0.5</code> cls loss gain (scale with pixels) <code>dfl</code> <code>1.5</code> dfl loss gain <code>pose</code> <code>12.0</code> pose loss gain (pose-only) <code>kobj</code> <code>2.0</code> keypoint obj loss gain (pose-only) <code>label_smoothing</code> <code>0.0</code> label smoothing (fraction) <code>nbs</code> <code>64</code> nominal batch size <code>overlap_mask</code> <code>True</code> masks should overlap during training (segment train only) <code>mask_ratio</code> <code>4</code> mask downsample ratio (segment train only) <code>dropout</code> <code>0.0</code> use dropout regularization (classify train only) <code>val</code> <code>True</code> validate/test during training <code>plots</code> <code>False</code> save plots and images during train/val"},{"location":"modes/train/#logging","title":"Logging","text":"<p>In training a YOLOv8 model, you might find it valuable to keep track of the model's performance over time. This is where logging comes into play. Ultralytics' YOLO provides support for three types of loggers - Comet, ClearML, and TensorBoard.</p> <p>To use a logger, select it from the dropdown menu in the code snippet above and run it. The chosen logger will be installed and initialized.</p>"},{"location":"modes/train/#comet","title":"Comet","text":"<p>Comet is a platform that allows data scientists and developers to track, compare, explain and optimize experiments and models. It provides functionalities such as real-time metrics, code diffs, and hyperparameters tracking.</p> <p>To use Comet:</p> <p>Example</p> Python <pre><code># pip install comet_ml\nimport comet_ml\n\ncomet_ml.init()\n</code></pre> <p>Remember to sign in to your Comet account on their website and get your API key. You will need to add this to your environment variables or your script to log your experiments.</p>"},{"location":"modes/train/#clearml","title":"ClearML","text":"<p>ClearML is an open-source platform that automates tracking of experiments and helps with efficient sharing of resources. It is designed to help teams manage, execute, and reproduce their ML work more efficiently.</p> <p>To use ClearML:</p> <p>Example</p> Python <pre><code># pip install clearml\nimport clearml\n\nclearml.browser_login()\n</code></pre> <p>After running this script, you will need to sign in to your ClearML account on the browser and authenticate your session.</p>"},{"location":"modes/train/#tensorboard","title":"TensorBoard","text":"<p>TensorBoard is a visualization toolkit for TensorFlow. It allows you to visualize your TensorFlow graph, plot quantitative metrics about the execution of your graph, and show additional data like images that pass through it.</p> <p>To use TensorBoard in Google Colab:</p> <p>Example</p> CLI <pre><code>load_ext tensorboard\ntensorboard --logdir ultralytics/runs  # replace with 'runs' directory\n</code></pre> <p>To use TensorBoard locally run the below command and view results at http://localhost:6006/.</p> <p>Example</p> CLI <pre><code>tensorboard --logdir ultralytics/runs  # replace with 'runs' directory\n</code></pre> <p>This will load TensorBoard and direct it to the directory where your training logs are saved.</p> <p>After setting up your logger, you can then proceed with your model training. All training metrics will be automatically logged in your chosen platform, and you can access these logs to monitor your model's performance over time, compare different models, and identify areas for improvement.</p>"},{"location":"modes/val/","title":"Model Validation with Ultralytics YOLO","text":""},{"location":"modes/val/#introduction","title":"Introduction","text":"<p>Validation is a critical step in the machine learning pipeline, allowing you to assess the quality of your trained models. Val mode in Ultralytics YOLOv8 provides a robust suite of tools and metrics for evaluating the performance of your object detection models. This guide serves as a complete resource for understanding how to effectively use the Val mode to ensure that your models are both accurate and reliable.</p> <p> Watch: Ultralytics Modes Tutorial: Validation </p>"},{"location":"modes/val/#why-validate-with-ultralytics-yolo","title":"Why Validate with Ultralytics YOLO?","text":"<p>Here's why using YOLOv8's Val mode is advantageous:</p> <ul> <li>Precision: Get accurate metrics like mAP50, mAP75, and mAP50-95 to comprehensively evaluate your model.</li> <li>Convenience: Utilize built-in features that remember training settings, simplifying the validation process.</li> <li>Flexibility: Validate your model with the same or different datasets and image sizes.</li> <li>Hyperparameter Tuning: Use validation metrics to fine-tune your model for better performance.</li> </ul>"},{"location":"modes/val/#key-features-of-val-mode","title":"Key Features of Val Mode","text":"<p>These are the notable functionalities offered by YOLOv8's Val mode:</p> <ul> <li>Automated Settings: Models remember their training configurations for straightforward validation.</li> <li>Multi-Metric Support: Evaluate your model based on a range of accuracy metrics.</li> <li>CLI and Python API: Choose from command-line interface or Python API based on your preference for validation.</li> <li>Data Compatibility: Works seamlessly with datasets used during the training phase as well as custom datasets.</li> </ul> <p>Tip</p> <ul> <li>YOLOv8 models automatically remember their training settings, so you can validate a model at the same image size and on the original dataset easily with just <code>yolo val model=yolov8n.pt</code> or <code>model('yolov8n.pt').val()</code></li> </ul>"},{"location":"modes/val/#usage-examples","title":"Usage Examples","text":"<p>Validate trained YOLOv8n model accuracy on the COCO128 dataset. No argument need to passed as the <code>model</code> retains it's training <code>data</code> and arguments as model attributes. See Arguments section below for a full list of export arguments.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n.pt')  # load an official model\nmodel = YOLO('path/to/best.pt')  # load a custom model\n\n# Validate the model\nmetrics = model.val()  # no arguments needed, dataset and settings remembered\nmetrics.box.map    # map50-95\nmetrics.box.map50  # map50\nmetrics.box.map75  # map75\nmetrics.box.maps   # a list contains map50-95 of each category\n</code></pre> <pre><code>yolo detect val model=yolov8n.pt  # val official model\nyolo detect val model=path/to/best.pt  # val custom model\n</code></pre>"},{"location":"modes/val/#arguments","title":"Arguments","text":"<p>Validation settings for YOLO models refer to the various hyperparameters and configurations used to evaluate the model's performance on a validation dataset. These settings can affect the model's performance, speed, and accuracy. Some common YOLO validation settings include the batch size, the frequency with which validation is performed during training, and the metrics used to evaluate the model's performance. Other factors that may affect the validation process include the size and composition of the validation dataset and the specific task the model is being used for. It is important to carefully tune and experiment with these settings to ensure that the model is performing well on the validation dataset and to detect and prevent overfitting.</p> Key Value Description <code>data</code> <code>None</code> path to data file, i.e. coco128.yaml <code>imgsz</code> <code>640</code> size of input images as integer <code>batch</code> <code>16</code> number of images per batch (-1 for AutoBatch) <code>save_json</code> <code>False</code> save results to JSON file <code>save_hybrid</code> <code>False</code> save hybrid version of labels (labels + additional predictions) <code>conf</code> <code>0.001</code> object confidence threshold for detection <code>iou</code> <code>0.6</code> intersection over union (IoU) threshold for NMS <code>max_det</code> <code>300</code> maximum number of detections per image <code>half</code> <code>True</code> use half precision (FP16) <code>device</code> <code>None</code> device to run on, i.e. cuda device=0/1/2/3 or device=cpu <code>dnn</code> <code>False</code> use OpenCV DNN for ONNX inference <code>plots</code> <code>False</code> save plots and images during train/val <code>rect</code> <code>False</code> rectangular val with each batch collated for minimum padding <code>split</code> <code>val</code> dataset split to use for validation, i.e. 'val', 'test' or 'train'"},{"location":"reference/cfg/__init__/","title":"Reference for <code>ultralytics/cfg/__init__.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/cfg/init.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/cfg/__init__/#ultralytics.cfg.cfg2dict","title":"<code>ultralytics.cfg.cfg2dict(cfg)</code>","text":"<p>Convert a configuration object to a dictionary, whether it is a file path, a string, or a SimpleNamespace object.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>str | Path | dict | SimpleNamespace</code> <p>Configuration object to be converted to a dictionary.</p> required <p>Returns:</p> Name Type Description <code>cfg</code> <code>dict</code> <p>Configuration object in dictionary format.</p> Source code in <code>ultralytics/cfg/__init__.py</code> <pre><code>def cfg2dict(cfg):\n    \"\"\"\n    Convert a configuration object to a dictionary, whether it is a file path, a string, or a SimpleNamespace object.\n\n    Args:\n        cfg (str | Path | dict | SimpleNamespace): Configuration object to be converted to a dictionary.\n\n    Returns:\n        cfg (dict): Configuration object in dictionary format.\n    \"\"\"\n    if isinstance(cfg, (str, Path)):\n        cfg = yaml_load(cfg)  # load dict\n    elif isinstance(cfg, SimpleNamespace):\n        cfg = vars(cfg)  # convert to dict\n    return cfg\n</code></pre>"},{"location":"reference/cfg/__init__/#ultralytics.cfg.get_cfg","title":"<code>ultralytics.cfg.get_cfg(cfg=DEFAULT_CFG_DICT, overrides=None)</code>","text":"<p>Load and merge configuration data from a file or dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>str | Path | Dict | SimpleNamespace</code> <p>Configuration data.</p> <code>DEFAULT_CFG_DICT</code> <code>overrides</code> <code>str | Dict | optional</code> <p>Overrides in the form of a file name or a dictionary. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>SimpleNamespace</code> <p>Training arguments namespace.</p> Source code in <code>ultralytics/cfg/__init__.py</code> <pre><code>def get_cfg(cfg: Union[str, Path, Dict, SimpleNamespace] = DEFAULT_CFG_DICT, overrides: Dict = None):\n    \"\"\"\n    Load and merge configuration data from a file or dictionary.\n\n    Args:\n        cfg (str | Path | Dict | SimpleNamespace): Configuration data.\n        overrides (str | Dict | optional): Overrides in the form of a file name or a dictionary. Default is None.\n\n    Returns:\n        (SimpleNamespace): Training arguments namespace.\n    \"\"\"\n    cfg = cfg2dict(cfg)\n\n    # Merge overrides\n    if overrides:\n        overrides = cfg2dict(overrides)\n        if \"save_dir\" not in cfg:\n            overrides.pop(\"save_dir\", None)  # special override keys to ignore\n        check_dict_alignment(cfg, overrides)\n        cfg = {**cfg, **overrides}  # merge cfg and overrides dicts (prefer overrides)\n\n    # Special handling for numeric project/name\n    for k in \"project\", \"name\":\n        if k in cfg and isinstance(cfg[k], (int, float)):\n            cfg[k] = str(cfg[k])\n    if cfg.get(\"name\") == \"model\":  # assign model to 'name' arg\n        cfg[\"name\"] = cfg.get(\"model\", \"\").split(\".\")[0]\n        LOGGER.warning(f\"WARNING \u26a0\ufe0f 'name=model' automatically updated to 'name={cfg['name']}'.\")\n\n    # Type and Value checks\n    for k, v in cfg.items():\n        if v is not None:  # None values may be from optional args\n            if k in CFG_FLOAT_KEYS and not isinstance(v, (int, float)):\n                raise TypeError(\n                    f\"'{k}={v}' is of invalid type {type(v).__name__}. \"\n                    f\"Valid '{k}' types are int (i.e. '{k}=0') or float (i.e. '{k}=0.5')\"\n                )\n            elif k in CFG_FRACTION_KEYS:\n                if not isinstance(v, (int, float)):\n                    raise TypeError(\n                        f\"'{k}={v}' is of invalid type {type(v).__name__}. \"\n                        f\"Valid '{k}' types are int (i.e. '{k}=0') or float (i.e. '{k}=0.5')\"\n                    )\n                if not (0.0 &lt;= v &lt;= 1.0):\n                    raise ValueError(f\"'{k}={v}' is an invalid value. \" f\"Valid '{k}' values are between 0.0 and 1.0.\")\n            elif k in CFG_INT_KEYS and not isinstance(v, int):\n                raise TypeError(\n                    f\"'{k}={v}' is of invalid type {type(v).__name__}. \" f\"'{k}' must be an int (i.e. '{k}=8')\"\n                )\n            elif k in CFG_BOOL_KEYS and not isinstance(v, bool):\n                raise TypeError(\n                    f\"'{k}={v}' is of invalid type {type(v).__name__}. \"\n                    f\"'{k}' must be a bool (i.e. '{k}=True' or '{k}=False')\"\n                )\n\n    # Return instance\n    return IterableSimpleNamespace(**cfg)\n</code></pre>"},{"location":"reference/cfg/__init__/#ultralytics.cfg.get_save_dir","title":"<code>ultralytics.cfg.get_save_dir(args, name=None)</code>","text":"<p>Return save_dir as created from train/val/predict arguments.</p> Source code in <code>ultralytics/cfg/__init__.py</code> <pre><code>def get_save_dir(args, name=None):\n    \"\"\"Return save_dir as created from train/val/predict arguments.\"\"\"\n\n    if getattr(args, \"save_dir\", None):\n        save_dir = args.save_dir\n    else:\n        from ultralytics.utils.files import increment_path\n\n        project = args.project or (ROOT.parent / \"tests/tmp/runs\" if TESTS_RUNNING else RUNS_DIR) / args.task\n        name = name or args.name or f\"{args.mode}\"\n        save_dir = increment_path(Path(project) / name, exist_ok=args.exist_ok if RANK in (-1, 0) else True)\n\n    return Path(save_dir)\n</code></pre>"},{"location":"reference/cfg/__init__/#ultralytics.cfg._handle_deprecation","title":"<code>ultralytics.cfg._handle_deprecation(custom)</code>","text":"<p>Hardcoded function to handle deprecated config keys.</p> Source code in <code>ultralytics/cfg/__init__.py</code> <pre><code>def _handle_deprecation(custom):\n    \"\"\"Hardcoded function to handle deprecated config keys.\"\"\"\n\n    for key in custom.copy().keys():\n        if key == \"boxes\":\n            deprecation_warn(key, \"show_boxes\")\n            custom[\"show_boxes\"] = custom.pop(\"boxes\")\n        if key == \"hide_labels\":\n            deprecation_warn(key, \"show_labels\")\n            custom[\"show_labels\"] = custom.pop(\"hide_labels\") == \"False\"\n        if key == \"hide_conf\":\n            deprecation_warn(key, \"show_conf\")\n            custom[\"show_conf\"] = custom.pop(\"hide_conf\") == \"False\"\n        if key == \"line_thickness\":\n            deprecation_warn(key, \"line_width\")\n            custom[\"line_width\"] = custom.pop(\"line_thickness\")\n\n    return custom\n</code></pre>"},{"location":"reference/cfg/__init__/#ultralytics.cfg.check_dict_alignment","title":"<code>ultralytics.cfg.check_dict_alignment(base, custom, e=None)</code>","text":"<p>This function checks for any mismatched keys between a custom configuration list and a base configuration list. If any mismatched keys are found, the function prints out similar keys from the base list and exits the program.</p> <p>Parameters:</p> Name Type Description Default <code>custom</code> <code>dict</code> <p>a dictionary of custom configuration options</p> required <code>base</code> <code>dict</code> <p>a dictionary of base configuration options</p> required <code>e</code> <code>Error</code> <p>An optional error that is passed by the calling function.</p> <code>None</code> Source code in <code>ultralytics/cfg/__init__.py</code> <pre><code>def check_dict_alignment(base: Dict, custom: Dict, e=None):\n    \"\"\"\n    This function checks for any mismatched keys between a custom configuration list and a base configuration list. If\n    any mismatched keys are found, the function prints out similar keys from the base list and exits the program.\n\n    Args:\n        custom (dict): a dictionary of custom configuration options\n        base (dict): a dictionary of base configuration options\n        e (Error, optional): An optional error that is passed by the calling function.\n    \"\"\"\n    custom = _handle_deprecation(custom)\n    base_keys, custom_keys = (set(x.keys()) for x in (base, custom))\n    mismatched = [k for k in custom_keys if k not in base_keys]\n    if mismatched:\n        from difflib import get_close_matches\n\n        string = \"\"\n        for x in mismatched:\n            matches = get_close_matches(x, base_keys)  # key list\n            matches = [f\"{k}={base[k]}\" if base.get(k) is not None else k for k in matches]\n            match_str = f\"Similar arguments are i.e. {matches}.\" if matches else \"\"\n            string += f\"'{colorstr('red', 'bold', x)}' is not a valid YOLO argument. {match_str}\\n\"\n        raise SyntaxError(string + CLI_HELP_MSG) from e\n</code></pre>"},{"location":"reference/cfg/__init__/#ultralytics.cfg.merge_equals_args","title":"<code>ultralytics.cfg.merge_equals_args(args)</code>","text":"<p>Merges arguments around isolated '=' args in a list of strings. The function considers cases where the first argument ends with '=' or the second starts with '=', as well as when the middle one is an equals sign.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>List[str]</code> <p>A list of strings where each element is an argument.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of strings where the arguments around isolated '=' are merged.</p> Source code in <code>ultralytics/cfg/__init__.py</code> <pre><code>def merge_equals_args(args: List[str]) -&gt; List[str]:\n    \"\"\"\n    Merges arguments around isolated '=' args in a list of strings. The function considers cases where the first\n    argument ends with '=' or the second starts with '=', as well as when the middle one is an equals sign.\n\n    Args:\n        args (List[str]): A list of strings where each element is an argument.\n\n    Returns:\n        List[str]: A list of strings where the arguments around isolated '=' are merged.\n    \"\"\"\n    new_args = []\n    for i, arg in enumerate(args):\n        if arg == \"=\" and 0 &lt; i &lt; len(args) - 1:  # merge ['arg', '=', 'val']\n            new_args[-1] += f\"={args[i + 1]}\"\n            del args[i + 1]\n        elif arg.endswith(\"=\") and i &lt; len(args) - 1 and \"=\" not in args[i + 1]:  # merge ['arg=', 'val']\n            new_args.append(f\"{arg}{args[i + 1]}\")\n            del args[i + 1]\n        elif arg.startswith(\"=\") and i &gt; 0:  # merge ['arg', '=val']\n            new_args[-1] += arg\n        else:\n            new_args.append(arg)\n    return new_args\n</code></pre>"},{"location":"reference/cfg/__init__/#ultralytics.cfg.handle_yolo_hub","title":"<code>ultralytics.cfg.handle_yolo_hub(args)</code>","text":"<p>Handle Ultralytics HUB command-line interface (CLI) commands.</p> <p>This function processes Ultralytics HUB CLI commands such as login and logout. It should be called when executing a script with arguments related to HUB authentication.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>List[str]</code> <p>A list of command line arguments</p> required Example <pre><code>python my_script.py hub login your_api_key\n</code></pre> Source code in <code>ultralytics/cfg/__init__.py</code> <pre><code>def handle_yolo_hub(args: List[str]) -&gt; None:\n    \"\"\"\n    Handle Ultralytics HUB command-line interface (CLI) commands.\n\n    This function processes Ultralytics HUB CLI commands such as login and logout.\n    It should be called when executing a script with arguments related to HUB authentication.\n\n    Args:\n        args (List[str]): A list of command line arguments\n\n    Example:\n        ```bash\n        python my_script.py hub login your_api_key\n        ```\n    \"\"\"\n    from ultralytics import hub\n\n    if args[0] == \"login\":\n        key = args[1] if len(args) &gt; 1 else \"\"\n        # Log in to Ultralytics HUB using the provided API key\n        hub.login(key)\n    elif args[0] == \"logout\":\n        # Log out from Ultralytics HUB\n        hub.logout()\n</code></pre>"},{"location":"reference/cfg/__init__/#ultralytics.cfg.handle_yolo_settings","title":"<code>ultralytics.cfg.handle_yolo_settings(args)</code>","text":"<p>Handle YOLO settings command-line interface (CLI) commands.</p> <p>This function processes YOLO settings CLI commands such as reset. It should be called when executing a script with arguments related to YOLO settings management.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>List[str]</code> <p>A list of command line arguments for YOLO settings management.</p> required Example <pre><code>python my_script.py yolo settings reset\n</code></pre> Source code in <code>ultralytics/cfg/__init__.py</code> <pre><code>def handle_yolo_settings(args: List[str]) -&gt; None:\n    \"\"\"\n    Handle YOLO settings command-line interface (CLI) commands.\n\n    This function processes YOLO settings CLI commands such as reset.\n    It should be called when executing a script with arguments related to YOLO settings management.\n\n    Args:\n        args (List[str]): A list of command line arguments for YOLO settings management.\n\n    Example:\n        ```bash\n        python my_script.py yolo settings reset\n        ```\n    \"\"\"\n    url = \"https://docs.ultralytics.com/quickstart/#ultralytics-settings\"  # help URL\n    try:\n        if any(args):\n            if args[0] == \"reset\":\n                SETTINGS_YAML.unlink()  # delete the settings file\n                SETTINGS.reset()  # create new settings\n                LOGGER.info(\"Settings reset successfully\")  # inform the user that settings have been reset\n            else:  # save a new setting\n                new = dict(parse_key_value_pair(a) for a in args)\n                check_dict_alignment(SETTINGS, new)\n                SETTINGS.update(new)\n\n        LOGGER.info(f\"\ud83d\udca1 Learn about settings at {url}\")\n        yaml_print(SETTINGS_YAML)  # print the current settings\n    except Exception as e:\n        LOGGER.warning(f\"WARNING \u26a0\ufe0f settings error: '{e}'. Please see {url} for help.\")\n</code></pre>"},{"location":"reference/cfg/__init__/#ultralytics.cfg.handle_explorer","title":"<code>ultralytics.cfg.handle_explorer()</code>","text":"<p>Open the Ultralytics Explorer GUI.</p> Source code in <code>ultralytics/cfg/__init__.py</code> <pre><code>def handle_explorer():\n    \"\"\"Open the Ultralytics Explorer GUI.\"\"\"\n    checks.check_requirements(\"streamlit\")\n    subprocess.run([\"streamlit\", \"run\", ROOT / \"data/explorer/gui/dash.py\", \"--server.maxMessageSize\", \"2048\"])\n</code></pre>"},{"location":"reference/cfg/__init__/#ultralytics.cfg.parse_key_value_pair","title":"<code>ultralytics.cfg.parse_key_value_pair(pair)</code>","text":"<p>Parse one 'key=value' pair and return key and value.</p> Source code in <code>ultralytics/cfg/__init__.py</code> <pre><code>def parse_key_value_pair(pair):\n    \"\"\"Parse one 'key=value' pair and return key and value.\"\"\"\n    k, v = pair.split(\"=\", 1)  # split on first '=' sign\n    k, v = k.strip(), v.strip()  # remove spaces\n    assert v, f\"missing '{k}' value\"\n    return k, smart_value(v)\n</code></pre>"},{"location":"reference/cfg/__init__/#ultralytics.cfg.smart_value","title":"<code>ultralytics.cfg.smart_value(v)</code>","text":"<p>Convert a string to an underlying type such as int, float, bool, etc.</p> Source code in <code>ultralytics/cfg/__init__.py</code> <pre><code>def smart_value(v):\n    \"\"\"Convert a string to an underlying type such as int, float, bool, etc.\"\"\"\n    v_lower = v.lower()\n    if v_lower == \"none\":\n        return None\n    elif v_lower == \"true\":\n        return True\n    elif v_lower == \"false\":\n        return False\n    else:\n        with contextlib.suppress(Exception):\n            return eval(v)\n        return v\n</code></pre>"},{"location":"reference/cfg/__init__/#ultralytics.cfg.entrypoint","title":"<code>ultralytics.cfg.entrypoint(debug='')</code>","text":"<p>This function is the ultralytics package entrypoint, it's responsible for parsing the command line arguments passed to the package.</p> <p>This function allows for: - passing mandatory YOLO args as a list of strings - specifying the task to be performed, either 'detect', 'segment' or 'classify' - specifying the mode, either 'train', 'val', 'test', or 'predict' - running special modes like 'checks' - passing overrides to the package's configuration</p> <p>It uses the package's default cfg and initializes it using the passed overrides. Then it calls the CLI function with the composed cfg</p> Source code in <code>ultralytics/cfg/__init__.py</code> <pre><code>def entrypoint(debug=\"\"):\n    \"\"\"\n    This function is the ultralytics package entrypoint, it's responsible for parsing the command line arguments passed\n    to the package.\n\n    This function allows for:\n    - passing mandatory YOLO args as a list of strings\n    - specifying the task to be performed, either 'detect', 'segment' or 'classify'\n    - specifying the mode, either 'train', 'val', 'test', or 'predict'\n    - running special modes like 'checks'\n    - passing overrides to the package's configuration\n\n    It uses the package's default cfg and initializes it using the passed overrides.\n    Then it calls the CLI function with the composed cfg\n    \"\"\"\n    args = (debug.split(\" \") if debug else sys.argv)[1:]\n    if not args:  # no arguments passed\n        LOGGER.info(CLI_HELP_MSG)\n        return\n\n    special = {\n        \"help\": lambda: LOGGER.info(CLI_HELP_MSG),\n        \"checks\": checks.collect_system_info,\n        \"version\": lambda: LOGGER.info(__version__),\n        \"settings\": lambda: handle_yolo_settings(args[1:]),\n        \"cfg\": lambda: yaml_print(DEFAULT_CFG_PATH),\n        \"hub\": lambda: handle_yolo_hub(args[1:]),\n        \"login\": lambda: handle_yolo_hub(args),\n        \"copy-cfg\": copy_default_cfg,\n        \"explorer\": lambda: handle_explorer(),\n    }\n    full_args_dict = {**DEFAULT_CFG_DICT, **{k: None for k in TASKS}, **{k: None for k in MODES}, **special}\n\n    # Define common misuses of special commands, i.e. -h, -help, --help\n    special.update({k[0]: v for k, v in special.items()})  # singular\n    special.update({k[:-1]: v for k, v in special.items() if len(k) &gt; 1 and k.endswith(\"s\")})  # singular\n    special = {**special, **{f\"-{k}\": v for k, v in special.items()}, **{f\"--{k}\": v for k, v in special.items()}}\n\n    overrides = {}  # basic overrides, i.e. imgsz=320\n    for a in merge_equals_args(args):  # merge spaces around '=' sign\n        if a.startswith(\"--\"):\n            LOGGER.warning(f\"WARNING \u26a0\ufe0f '{a}' does not require leading dashes '--', updating to '{a[2:]}'.\")\n            a = a[2:]\n        if a.endswith(\",\"):\n            LOGGER.warning(f\"WARNING \u26a0\ufe0f '{a}' does not require trailing comma ',', updating to '{a[:-1]}'.\")\n            a = a[:-1]\n        if \"=\" in a:\n            try:\n                k, v = parse_key_value_pair(a)\n                if k == \"cfg\" and v is not None:  # custom.yaml passed\n                    LOGGER.info(f\"Overriding {DEFAULT_CFG_PATH} with {v}\")\n                    overrides = {k: val for k, val in yaml_load(checks.check_yaml(v)).items() if k != \"cfg\"}\n                else:\n                    overrides[k] = v\n            except (NameError, SyntaxError, ValueError, AssertionError) as e:\n                check_dict_alignment(full_args_dict, {a: \"\"}, e)\n\n        elif a in TASKS:\n            overrides[\"task\"] = a\n        elif a in MODES:\n            overrides[\"mode\"] = a\n        elif a.lower() in special:\n            special[a.lower()]()\n            return\n        elif a in DEFAULT_CFG_DICT and isinstance(DEFAULT_CFG_DICT[a], bool):\n            overrides[a] = True  # auto-True for default bool args, i.e. 'yolo show' sets show=True\n        elif a in DEFAULT_CFG_DICT:\n            raise SyntaxError(\n                f\"'{colorstr('red', 'bold', a)}' is a valid YOLO argument but is missing an '=' sign \"\n                f\"to set its value, i.e. try '{a}={DEFAULT_CFG_DICT[a]}'\\n{CLI_HELP_MSG}\"\n            )\n        else:\n            check_dict_alignment(full_args_dict, {a: \"\"})\n\n    # Check keys\n    check_dict_alignment(full_args_dict, overrides)\n\n    # Mode\n    mode = overrides.get(\"mode\")\n    if mode is None:\n        mode = DEFAULT_CFG.mode or \"predict\"\n        LOGGER.warning(f\"WARNING \u26a0\ufe0f 'mode' is missing. Valid modes are {MODES}. Using default 'mode={mode}'.\")\n    elif mode not in MODES:\n        raise ValueError(f\"Invalid 'mode={mode}'. Valid modes are {MODES}.\\n{CLI_HELP_MSG}\")\n\n    # Task\n    task = overrides.pop(\"task\", None)\n    if task:\n        if task not in TASKS:\n            raise ValueError(f\"Invalid 'task={task}'. Valid tasks are {TASKS}.\\n{CLI_HELP_MSG}\")\n        if \"model\" not in overrides:\n            overrides[\"model\"] = TASK2MODEL[task]\n\n    # Model\n    model = overrides.pop(\"model\", DEFAULT_CFG.model)\n    if model is None:\n        model = \"yolov8n.pt\"\n        LOGGER.warning(f\"WARNING \u26a0\ufe0f 'model' is missing. Using default 'model={model}'.\")\n    overrides[\"model\"] = model\n    stem = Path(model).stem.lower()\n    if \"rtdetr\" in stem:  # guess architecture\n        from ultralytics import RTDETR\n\n        model = RTDETR(model)  # no task argument\n    elif \"fastsam\" in stem:\n        from ultralytics import FastSAM\n\n        model = FastSAM(model)\n    elif \"sam\" in stem:\n        from ultralytics import SAM\n\n        model = SAM(model)\n    else:\n        from ultralytics import YOLO\n\n        model = YOLO(model, task=task)\n    if isinstance(overrides.get(\"pretrained\"), str):\n        model.load(overrides[\"pretrained\"])\n\n    # Task Update\n    if task != model.task:\n        if task:\n            LOGGER.warning(\n                f\"WARNING \u26a0\ufe0f conflicting 'task={task}' passed with 'task={model.task}' model. \"\n                f\"Ignoring 'task={task}' and updating to 'task={model.task}' to match model.\"\n            )\n        task = model.task\n\n    # Mode\n    if mode in (\"predict\", \"track\") and \"source\" not in overrides:\n        overrides[\"source\"] = DEFAULT_CFG.source or ASSETS\n        LOGGER.warning(f\"WARNING \u26a0\ufe0f 'source' is missing. Using default 'source={overrides['source']}'.\")\n    elif mode in (\"train\", \"val\"):\n        if \"data\" not in overrides and \"resume\" not in overrides:\n            overrides[\"data\"] = DEFAULT_CFG.data or TASK2DATA.get(task or DEFAULT_CFG.task, DEFAULT_CFG.data)\n            LOGGER.warning(f\"WARNING \u26a0\ufe0f 'data' is missing. Using default 'data={overrides['data']}'.\")\n    elif mode == \"export\":\n        if \"format\" not in overrides:\n            overrides[\"format\"] = DEFAULT_CFG.format or \"torchscript\"\n            LOGGER.warning(f\"WARNING \u26a0\ufe0f 'format' is missing. Using default 'format={overrides['format']}'.\")\n\n    # Run command in python\n    getattr(model, mode)(**overrides)  # default args from model\n\n    # Show help\n    LOGGER.info(f\"\ud83d\udca1 Learn more at https://docs.ultralytics.com/modes/{mode}\")\n</code></pre>"},{"location":"reference/cfg/__init__/#ultralytics.cfg.copy_default_cfg","title":"<code>ultralytics.cfg.copy_default_cfg()</code>","text":"<p>Copy and create a new default configuration file with '_copy' appended to its name.</p> Source code in <code>ultralytics/cfg/__init__.py</code> <pre><code>def copy_default_cfg():\n    \"\"\"Copy and create a new default configuration file with '_copy' appended to its name.\"\"\"\n    new_file = Path.cwd() / DEFAULT_CFG_PATH.name.replace(\".yaml\", \"_copy.yaml\")\n    shutil.copy2(DEFAULT_CFG_PATH, new_file)\n    LOGGER.info(\n        f\"{DEFAULT_CFG_PATH} copied to {new_file}\\n\"\n        f\"Example YOLO command with this new custom cfg:\\n    yolo cfg='{new_file}' imgsz=320 batch=8\"\n    )\n</code></pre>"},{"location":"reference/data/annotator/","title":"Reference for <code>ultralytics/data/annotator.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/annotator.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/data/annotator/#ultralytics.data.annotator.auto_annotate","title":"<code>ultralytics.data.annotator.auto_annotate(data, det_model='yolov8x.pt', sam_model='sam_b.pt', device='', output_dir=None)</code>","text":"<p>Automatically annotates images using a YOLO object detection model and a SAM segmentation model.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Path to a folder containing images to be annotated.</p> required <code>det_model</code> <code>str</code> <p>Pre-trained YOLO detection model. Defaults to 'yolov8x.pt'.</p> <code>'yolov8x.pt'</code> <code>sam_model</code> <code>str</code> <p>Pre-trained SAM segmentation model. Defaults to 'sam_b.pt'.</p> <code>'sam_b.pt'</code> <code>device</code> <code>str</code> <p>Device to run the models on. Defaults to an empty string (CPU or GPU, if available).</p> <code>''</code> <code>output_dir</code> <code>str | None | optional</code> <p>Directory to save the annotated results. Defaults to a 'labels' folder in the same directory as 'data'.</p> <code>None</code> Example <pre><code>from ultralytics.data.annotator import auto_annotate\n\nauto_annotate(data='ultralytics/assets', det_model='yolov8n.pt', sam_model='mobile_sam.pt')\n</code></pre> Source code in <code>ultralytics/data/annotator.py</code> <pre><code>def auto_annotate(data, det_model=\"yolov8x.pt\", sam_model=\"sam_b.pt\", device=\"\", output_dir=None):\n    \"\"\"\n    Automatically annotates images using a YOLO object detection model and a SAM segmentation model.\n\n    Args:\n        data (str): Path to a folder containing images to be annotated.\n        det_model (str, optional): Pre-trained YOLO detection model. Defaults to 'yolov8x.pt'.\n        sam_model (str, optional): Pre-trained SAM segmentation model. Defaults to 'sam_b.pt'.\n        device (str, optional): Device to run the models on. Defaults to an empty string (CPU or GPU, if available).\n        output_dir (str | None | optional): Directory to save the annotated results.\n            Defaults to a 'labels' folder in the same directory as 'data'.\n\n    Example:\n        ```python\n        from ultralytics.data.annotator import auto_annotate\n\n        auto_annotate(data='ultralytics/assets', det_model='yolov8n.pt', sam_model='mobile_sam.pt')\n        ```\n    \"\"\"\n    det_model = YOLO(det_model)\n    sam_model = SAM(sam_model)\n\n    data = Path(data)\n    if not output_dir:\n        output_dir = data.parent / f\"{data.stem}_auto_annotate_labels\"\n    Path(output_dir).mkdir(exist_ok=True, parents=True)\n\n    det_results = det_model(data, stream=True, device=device)\n\n    for result in det_results:\n        class_ids = result.boxes.cls.int().tolist()  # noqa\n        if len(class_ids):\n            boxes = result.boxes.xyxy  # Boxes object for bbox outputs\n            sam_results = sam_model(result.orig_img, bboxes=boxes, verbose=False, save=False, device=device)\n            segments = sam_results[0].masks.xyn  # noqa\n\n            with open(f\"{str(Path(output_dir) / Path(result.path).stem)}.txt\", \"w\") as f:\n                for i in range(len(segments)):\n                    s = segments[i]\n                    if len(s) == 0:\n                        continue\n                    segment = map(str, segments[i].reshape(-1).tolist())\n                    f.write(f\"{class_ids[i]} \" + \" \".join(segment) + \"\\n\")\n</code></pre>"},{"location":"reference/data/augment/","title":"Reference for <code>ultralytics/data/augment.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/data/augment/#ultralytics.data.augment.BaseTransform","title":"<code>ultralytics.data.augment.BaseTransform</code>","text":"<p>Base class for image transformations.</p> <p>This is a generic transformation class that can be extended for specific image processing needs. The class is designed to be compatible with both classification and semantic segmentation tasks.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes the BaseTransform object.</p> <code>apply_image</code> <p>Applies image transformation to labels.</p> <code>apply_instances</code> <p>Applies transformations to object instances in labels.</p> <code>apply_semantic</code> <p>Applies semantic segmentation to an image.</p> <code>__call__</code> <p>Applies all label transformations to an image, instances, and semantic masks.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>class BaseTransform:\n    \"\"\"\n    Base class for image transformations.\n\n    This is a generic transformation class that can be extended for specific image processing needs.\n    The class is designed to be compatible with both classification and semantic segmentation tasks.\n\n    Methods:\n        __init__: Initializes the BaseTransform object.\n        apply_image: Applies image transformation to labels.\n        apply_instances: Applies transformations to object instances in labels.\n        apply_semantic: Applies semantic segmentation to an image.\n        __call__: Applies all label transformations to an image, instances, and semantic masks.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initializes the BaseTransform object.\"\"\"\n        pass\n\n    def apply_image(self, labels):\n        \"\"\"Applies image transformations to labels.\"\"\"\n        pass\n\n    def apply_instances(self, labels):\n        \"\"\"Applies transformations to object instances in labels.\"\"\"\n        pass\n\n    def apply_semantic(self, labels):\n        \"\"\"Applies semantic segmentation to an image.\"\"\"\n        pass\n\n    def __call__(self, labels):\n        \"\"\"Applies all label transformations to an image, instances, and semantic masks.\"\"\"\n        self.apply_image(labels)\n        self.apply_instances(labels)\n        self.apply_semantic(labels)\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.BaseTransform.__call__","title":"<code>__call__(labels)</code>","text":"<p>Applies all label transformations to an image, instances, and semantic masks.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __call__(self, labels):\n    \"\"\"Applies all label transformations to an image, instances, and semantic masks.\"\"\"\n    self.apply_image(labels)\n    self.apply_instances(labels)\n    self.apply_semantic(labels)\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.BaseTransform.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the BaseTransform object.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initializes the BaseTransform object.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.BaseTransform.apply_image","title":"<code>apply_image(labels)</code>","text":"<p>Applies image transformations to labels.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def apply_image(self, labels):\n    \"\"\"Applies image transformations to labels.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.BaseTransform.apply_instances","title":"<code>apply_instances(labels)</code>","text":"<p>Applies transformations to object instances in labels.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def apply_instances(self, labels):\n    \"\"\"Applies transformations to object instances in labels.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.BaseTransform.apply_semantic","title":"<code>apply_semantic(labels)</code>","text":"<p>Applies semantic segmentation to an image.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def apply_semantic(self, labels):\n    \"\"\"Applies semantic segmentation to an image.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.Compose","title":"<code>ultralytics.data.augment.Compose</code>","text":"<p>Class for composing multiple image transformations.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>class Compose:\n    \"\"\"Class for composing multiple image transformations.\"\"\"\n\n    def __init__(self, transforms):\n        \"\"\"Initializes the Compose object with a list of transforms.\"\"\"\n        self.transforms = transforms\n\n    def __call__(self, data):\n        \"\"\"Applies a series of transformations to input data.\"\"\"\n        for t in self.transforms:\n            data = t(data)\n        return data\n\n    def append(self, transform):\n        \"\"\"Appends a new transform to the existing list of transforms.\"\"\"\n        self.transforms.append(transform)\n\n    def tolist(self):\n        \"\"\"Converts the list of transforms to a standard Python list.\"\"\"\n        return self.transforms\n\n    def __repr__(self):\n        \"\"\"Returns a string representation of the object.\"\"\"\n        return f\"{self.__class__.__name__}({', '.join([f'{t}' for t in self.transforms])})\"\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.Compose.__call__","title":"<code>__call__(data)</code>","text":"<p>Applies a series of transformations to input data.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __call__(self, data):\n    \"\"\"Applies a series of transformations to input data.\"\"\"\n    for t in self.transforms:\n        data = t(data)\n    return data\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.Compose.__init__","title":"<code>__init__(transforms)</code>","text":"<p>Initializes the Compose object with a list of transforms.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __init__(self, transforms):\n    \"\"\"Initializes the Compose object with a list of transforms.\"\"\"\n    self.transforms = transforms\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.Compose.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns a string representation of the object.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __repr__(self):\n    \"\"\"Returns a string representation of the object.\"\"\"\n    return f\"{self.__class__.__name__}({', '.join([f'{t}' for t in self.transforms])})\"\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.Compose.append","title":"<code>append(transform)</code>","text":"<p>Appends a new transform to the existing list of transforms.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def append(self, transform):\n    \"\"\"Appends a new transform to the existing list of transforms.\"\"\"\n    self.transforms.append(transform)\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.Compose.tolist","title":"<code>tolist()</code>","text":"<p>Converts the list of transforms to a standard Python list.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def tolist(self):\n    \"\"\"Converts the list of transforms to a standard Python list.\"\"\"\n    return self.transforms\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.BaseMixTransform","title":"<code>ultralytics.data.augment.BaseMixTransform</code>","text":"<p>Class for base mix (MixUp/Mosaic) transformations.</p> <p>This implementation is from mmyolo.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>class BaseMixTransform:\n    \"\"\"\n    Class for base mix (MixUp/Mosaic) transformations.\n\n    This implementation is from mmyolo.\n    \"\"\"\n\n    def __init__(self, dataset, pre_transform=None, p=0.0) -&gt; None:\n        \"\"\"Initializes the BaseMixTransform object with dataset, pre_transform, and probability.\"\"\"\n        self.dataset = dataset\n        self.pre_transform = pre_transform\n        self.p = p\n\n    def __call__(self, labels):\n        \"\"\"Applies pre-processing transforms and mixup/mosaic transforms to labels data.\"\"\"\n        if random.uniform(0, 1) &gt; self.p:\n            return labels\n\n        # Get index of one or three other images\n        indexes = self.get_indexes()\n        if isinstance(indexes, int):\n            indexes = [indexes]\n\n        # Get images information will be used for Mosaic or MixUp\n        mix_labels = [self.dataset.get_image_and_label(i) for i in indexes]\n\n        if self.pre_transform is not None:\n            for i, data in enumerate(mix_labels):\n                mix_labels[i] = self.pre_transform(data)\n        labels[\"mix_labels\"] = mix_labels\n\n        # Mosaic or MixUp\n        labels = self._mix_transform(labels)\n        labels.pop(\"mix_labels\", None)\n        return labels\n\n    def _mix_transform(self, labels):\n        \"\"\"Applies MixUp or Mosaic augmentation to the label dictionary.\"\"\"\n        raise NotImplementedError\n\n    def get_indexes(self):\n        \"\"\"Gets a list of shuffled indexes for mosaic augmentation.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.BaseMixTransform.__call__","title":"<code>__call__(labels)</code>","text":"<p>Applies pre-processing transforms and mixup/mosaic transforms to labels data.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __call__(self, labels):\n    \"\"\"Applies pre-processing transforms and mixup/mosaic transforms to labels data.\"\"\"\n    if random.uniform(0, 1) &gt; self.p:\n        return labels\n\n    # Get index of one or three other images\n    indexes = self.get_indexes()\n    if isinstance(indexes, int):\n        indexes = [indexes]\n\n    # Get images information will be used for Mosaic or MixUp\n    mix_labels = [self.dataset.get_image_and_label(i) for i in indexes]\n\n    if self.pre_transform is not None:\n        for i, data in enumerate(mix_labels):\n            mix_labels[i] = self.pre_transform(data)\n    labels[\"mix_labels\"] = mix_labels\n\n    # Mosaic or MixUp\n    labels = self._mix_transform(labels)\n    labels.pop(\"mix_labels\", None)\n    return labels\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.BaseMixTransform.__init__","title":"<code>__init__(dataset, pre_transform=None, p=0.0)</code>","text":"<p>Initializes the BaseMixTransform object with dataset, pre_transform, and probability.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __init__(self, dataset, pre_transform=None, p=0.0) -&gt; None:\n    \"\"\"Initializes the BaseMixTransform object with dataset, pre_transform, and probability.\"\"\"\n    self.dataset = dataset\n    self.pre_transform = pre_transform\n    self.p = p\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.BaseMixTransform.get_indexes","title":"<code>get_indexes()</code>","text":"<p>Gets a list of shuffled indexes for mosaic augmentation.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def get_indexes(self):\n    \"\"\"Gets a list of shuffled indexes for mosaic augmentation.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.Mosaic","title":"<code>ultralytics.data.augment.Mosaic</code>","text":"<p>             Bases: <code>BaseMixTransform</code></p> <p>Mosaic augmentation.</p> <p>This class performs mosaic augmentation by combining multiple (4 or 9) images into a single mosaic image. The augmentation is applied to a dataset with a given probability.</p> <p>Attributes:</p> Name Type Description <code>dataset</code> <p>The dataset on which the mosaic augmentation is applied.</p> <code>imgsz</code> <code>int</code> <p>Image size (height and width) after mosaic pipeline of a single image. Default to 640.</p> <code>p</code> <code>float</code> <p>Probability of applying the mosaic augmentation. Must be in the range 0-1. Default to 1.0.</p> <code>n</code> <code>int</code> <p>The grid size, either 4 (for 2x2) or 9 (for 3x3).</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>class Mosaic(BaseMixTransform):\n    \"\"\"\n    Mosaic augmentation.\n\n    This class performs mosaic augmentation by combining multiple (4 or 9) images into a single mosaic image.\n    The augmentation is applied to a dataset with a given probability.\n\n    Attributes:\n        dataset: The dataset on which the mosaic augmentation is applied.\n        imgsz (int, optional): Image size (height and width) after mosaic pipeline of a single image. Default to 640.\n        p (float, optional): Probability of applying the mosaic augmentation. Must be in the range 0-1. Default to 1.0.\n        n (int, optional): The grid size, either 4 (for 2x2) or 9 (for 3x3).\n    \"\"\"\n\n    def __init__(self, dataset, imgsz=640, p=1.0, n=4):\n        \"\"\"Initializes the object with a dataset, image size, probability, and border.\"\"\"\n        assert 0 &lt;= p &lt;= 1.0, f\"The probability should be in range [0, 1], but got {p}.\"\n        assert n in (4, 9), \"grid must be equal to 4 or 9.\"\n        super().__init__(dataset=dataset, p=p)\n        self.dataset = dataset\n        self.imgsz = imgsz\n        self.border = (-imgsz // 2, -imgsz // 2)  # width, height\n        self.n = n\n\n    def get_indexes(self, buffer=True):\n        \"\"\"Return a list of random indexes from the dataset.\"\"\"\n        if buffer:  # select images from buffer\n            return random.choices(list(self.dataset.buffer), k=self.n - 1)\n        else:  # select any images\n            return [random.randint(0, len(self.dataset) - 1) for _ in range(self.n - 1)]\n\n    def _mix_transform(self, labels):\n        \"\"\"Apply mixup transformation to the input image and labels.\"\"\"\n        assert labels.get(\"rect_shape\", None) is None, \"rect and mosaic are mutually exclusive.\"\n        assert len(labels.get(\"mix_labels\", [])), \"There are no other images for mosaic augment.\"\n        return (\n            self._mosaic3(labels) if self.n == 3 else self._mosaic4(labels) if self.n == 4 else self._mosaic9(labels)\n        )  # This code is modified for mosaic3 method.\n\n    def _mosaic3(self, labels):\n        \"\"\"Create a 1x3 image mosaic.\"\"\"\n        mosaic_labels = []\n        s = self.imgsz\n        for i in range(3):\n            labels_patch = labels if i == 0 else labels[\"mix_labels\"][i - 1]\n            # Load image\n            img = labels_patch[\"img\"]\n            h, w = labels_patch.pop(\"resized_shape\")\n\n            # Place img in img3\n            if i == 0:  # center\n                img3 = np.full((s * 3, s * 3, img.shape[2]), 114, dtype=np.uint8)  # base image with 3 tiles\n                h0, w0 = h, w\n                c = s, s, s + w, s + h  # xmin, ymin, xmax, ymax (base) coordinates\n            elif i == 1:  # right\n                c = s + w0, s, s + w0 + w, s + h\n            elif i == 2:  # left\n                c = s - w, s + h0 - h, s, s + h0\n\n            padw, padh = c[:2]\n            x1, y1, x2, y2 = (max(x, 0) for x in c)  # allocate coords\n\n            img3[y1:y2, x1:x2] = img[y1 - padh :, x1 - padw :]  # img3[ymin:ymax, xmin:xmax]\n            # hp, wp = h, w  # height, width previous for next iteration\n\n            # Labels assuming imgsz*2 mosaic size\n            labels_patch = self._update_labels(labels_patch, padw + self.border[0], padh + self.border[1])\n            mosaic_labels.append(labels_patch)\n        final_labels = self._cat_labels(mosaic_labels)\n\n        final_labels[\"img\"] = img3[-self.border[0] : self.border[0], -self.border[1] : self.border[1]]\n        return final_labels\n\n    def _mosaic4(self, labels):\n        \"\"\"Create a 2x2 image mosaic.\"\"\"\n        mosaic_labels = []\n        s = self.imgsz\n        yc, xc = (int(random.uniform(-x, 2 * s + x)) for x in self.border)  # mosaic center x, y\n        for i in range(4):\n            labels_patch = labels if i == 0 else labels[\"mix_labels\"][i - 1]\n            # Load image\n            img = labels_patch[\"img\"]\n            h, w = labels_patch.pop(\"resized_shape\")\n\n            # Place img in img4\n            if i == 0:  # top left\n                img4 = np.full((s * 2, s * 2, img.shape[2]), 114, dtype=np.uint8)  # base image with 4 tiles\n                x1a, y1a, x2a, y2a = max(xc - w, 0), max(yc - h, 0), xc, yc  # xmin, ymin, xmax, ymax (large image)\n                x1b, y1b, x2b, y2b = w - (x2a - x1a), h - (y2a - y1a), w, h  # xmin, ymin, xmax, ymax (small image)\n            elif i == 1:  # top right\n                x1a, y1a, x2a, y2a = xc, max(yc - h, 0), min(xc + w, s * 2), yc\n                x1b, y1b, x2b, y2b = 0, h - (y2a - y1a), min(w, x2a - x1a), h\n            elif i == 2:  # bottom left\n                x1a, y1a, x2a, y2a = max(xc - w, 0), yc, xc, min(s * 2, yc + h)\n                x1b, y1b, x2b, y2b = w - (x2a - x1a), 0, w, min(y2a - y1a, h)\n            elif i == 3:  # bottom right\n                x1a, y1a, x2a, y2a = xc, yc, min(xc + w, s * 2), min(s * 2, yc + h)\n                x1b, y1b, x2b, y2b = 0, 0, min(w, x2a - x1a), min(y2a - y1a, h)\n\n            img4[y1a:y2a, x1a:x2a] = img[y1b:y2b, x1b:x2b]  # img4[ymin:ymax, xmin:xmax]\n            padw = x1a - x1b\n            padh = y1a - y1b\n\n            labels_patch = self._update_labels(labels_patch, padw, padh)\n            mosaic_labels.append(labels_patch)\n        final_labels = self._cat_labels(mosaic_labels)\n        final_labels[\"img\"] = img4\n        return final_labels\n\n    def _mosaic9(self, labels):\n        \"\"\"Create a 3x3 image mosaic.\"\"\"\n        mosaic_labels = []\n        s = self.imgsz\n        hp, wp = -1, -1  # height, width previous\n        for i in range(9):\n            labels_patch = labels if i == 0 else labels[\"mix_labels\"][i - 1]\n            # Load image\n            img = labels_patch[\"img\"]\n            h, w = labels_patch.pop(\"resized_shape\")\n\n            # Place img in img9\n            if i == 0:  # center\n                img9 = np.full((s * 3, s * 3, img.shape[2]), 114, dtype=np.uint8)  # base image with 4 tiles\n                h0, w0 = h, w\n                c = s, s, s + w, s + h  # xmin, ymin, xmax, ymax (base) coordinates\n            elif i == 1:  # top\n                c = s, s - h, s + w, s\n            elif i == 2:  # top right\n                c = s + wp, s - h, s + wp + w, s\n            elif i == 3:  # right\n                c = s + w0, s, s + w0 + w, s + h\n            elif i == 4:  # bottom right\n                c = s + w0, s + hp, s + w0 + w, s + hp + h\n            elif i == 5:  # bottom\n                c = s + w0 - w, s + h0, s + w0, s + h0 + h\n            elif i == 6:  # bottom left\n                c = s + w0 - wp - w, s + h0, s + w0 - wp, s + h0 + h\n            elif i == 7:  # left\n                c = s - w, s + h0 - h, s, s + h0\n            elif i == 8:  # top left\n                c = s - w, s + h0 - hp - h, s, s + h0 - hp\n\n            padw, padh = c[:2]\n            x1, y1, x2, y2 = (max(x, 0) for x in c)  # allocate coords\n\n            # Image\n            img9[y1:y2, x1:x2] = img[y1 - padh :, x1 - padw :]  # img9[ymin:ymax, xmin:xmax]\n            hp, wp = h, w  # height, width previous for next iteration\n\n            # Labels assuming imgsz*2 mosaic size\n            labels_patch = self._update_labels(labels_patch, padw + self.border[0], padh + self.border[1])\n            mosaic_labels.append(labels_patch)\n        final_labels = self._cat_labels(mosaic_labels)\n\n        final_labels[\"img\"] = img9[-self.border[0] : self.border[0], -self.border[1] : self.border[1]]\n        return final_labels\n\n    @staticmethod\n    def _update_labels(labels, padw, padh):\n        \"\"\"Update labels.\"\"\"\n        nh, nw = labels[\"img\"].shape[:2]\n        labels[\"instances\"].convert_bbox(format=\"xyxy\")\n        labels[\"instances\"].denormalize(nw, nh)\n        labels[\"instances\"].add_padding(padw, padh)\n        return labels\n\n    def _cat_labels(self, mosaic_labels):\n        \"\"\"Return labels with mosaic border instances clipped.\"\"\"\n        if len(mosaic_labels) == 0:\n            return {}\n        cls = []\n        instances = []\n        imgsz = self.imgsz * 2  # mosaic imgsz\n        for labels in mosaic_labels:\n            cls.append(labels[\"cls\"])\n            instances.append(labels[\"instances\"])\n        # Final labels\n        final_labels = {\n            \"im_file\": mosaic_labels[0][\"im_file\"],\n            \"ori_shape\": mosaic_labels[0][\"ori_shape\"],\n            \"resized_shape\": (imgsz, imgsz),\n            \"cls\": np.concatenate(cls, 0),\n            \"instances\": Instances.concatenate(instances, axis=0),\n            \"mosaic_border\": self.border,\n        }\n        final_labels[\"instances\"].clip(imgsz, imgsz)\n        good = final_labels[\"instances\"].remove_zero_area_boxes()\n        final_labels[\"cls\"] = final_labels[\"cls\"][good]\n        return final_labels\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.Mosaic.__init__","title":"<code>__init__(dataset, imgsz=640, p=1.0, n=4)</code>","text":"<p>Initializes the object with a dataset, image size, probability, and border.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __init__(self, dataset, imgsz=640, p=1.0, n=4):\n    \"\"\"Initializes the object with a dataset, image size, probability, and border.\"\"\"\n    assert 0 &lt;= p &lt;= 1.0, f\"The probability should be in range [0, 1], but got {p}.\"\n    assert n in (4, 9), \"grid must be equal to 4 or 9.\"\n    super().__init__(dataset=dataset, p=p)\n    self.dataset = dataset\n    self.imgsz = imgsz\n    self.border = (-imgsz // 2, -imgsz // 2)  # width, height\n    self.n = n\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.Mosaic.get_indexes","title":"<code>get_indexes(buffer=True)</code>","text":"<p>Return a list of random indexes from the dataset.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def get_indexes(self, buffer=True):\n    \"\"\"Return a list of random indexes from the dataset.\"\"\"\n    if buffer:  # select images from buffer\n        return random.choices(list(self.dataset.buffer), k=self.n - 1)\n    else:  # select any images\n        return [random.randint(0, len(self.dataset) - 1) for _ in range(self.n - 1)]\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.MixUp","title":"<code>ultralytics.data.augment.MixUp</code>","text":"<p>             Bases: <code>BaseMixTransform</code></p> <p>Class for applying MixUp augmentation to the dataset.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>class MixUp(BaseMixTransform):\n    \"\"\"Class for applying MixUp augmentation to the dataset.\"\"\"\n\n    def __init__(self, dataset, pre_transform=None, p=0.0) -&gt; None:\n        \"\"\"Initializes MixUp object with dataset, pre_transform, and probability of applying MixUp.\"\"\"\n        super().__init__(dataset=dataset, pre_transform=pre_transform, p=p)\n\n    def get_indexes(self):\n        \"\"\"Get a random index from the dataset.\"\"\"\n        return random.randint(0, len(self.dataset) - 1)\n\n    def _mix_transform(self, labels):\n        \"\"\"Applies MixUp augmentation as per https://arxiv.org/pdf/1710.09412.pdf.\"\"\"\n        r = np.random.beta(32.0, 32.0)  # mixup ratio, alpha=beta=32.0\n        labels2 = labels[\"mix_labels\"][0]\n        labels[\"img\"] = (labels[\"img\"] * r + labels2[\"img\"] * (1 - r)).astype(np.uint8)\n        labels[\"instances\"] = Instances.concatenate([labels[\"instances\"], labels2[\"instances\"]], axis=0)\n        labels[\"cls\"] = np.concatenate([labels[\"cls\"], labels2[\"cls\"]], 0)\n        return labels\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.MixUp.__init__","title":"<code>__init__(dataset, pre_transform=None, p=0.0)</code>","text":"<p>Initializes MixUp object with dataset, pre_transform, and probability of applying MixUp.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __init__(self, dataset, pre_transform=None, p=0.0) -&gt; None:\n    \"\"\"Initializes MixUp object with dataset, pre_transform, and probability of applying MixUp.\"\"\"\n    super().__init__(dataset=dataset, pre_transform=pre_transform, p=p)\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.MixUp.get_indexes","title":"<code>get_indexes()</code>","text":"<p>Get a random index from the dataset.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def get_indexes(self):\n    \"\"\"Get a random index from the dataset.\"\"\"\n    return random.randint(0, len(self.dataset) - 1)\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.RandomPerspective","title":"<code>ultralytics.data.augment.RandomPerspective</code>","text":"<p>Implements random perspective and affine transformations on images and corresponding bounding boxes, segments, and keypoints. These transformations include rotation, translation, scaling, and shearing. The class also offers the option to apply these transformations conditionally with a specified probability.</p> <p>Attributes:</p> Name Type Description <code>degrees</code> <code>float</code> <p>Degree range for random rotations.</p> <code>translate</code> <code>float</code> <p>Fraction of total width and height for random translation.</p> <code>scale</code> <code>float</code> <p>Scaling factor interval, e.g., a scale factor of 0.1 allows a resize between 90%-110%.</p> <code>shear</code> <code>float</code> <p>Shear intensity (angle in degrees).</p> <code>perspective</code> <code>float</code> <p>Perspective distortion factor.</p> <code>border</code> <code>tuple</code> <p>Tuple specifying mosaic border.</p> <code>pre_transform</code> <code>callable</code> <p>A function/transform to apply to the image before starting the random transformation.</p> <p>Methods:</p> Name Description <code>affine_transform</code> <p>Applies a series of affine transformations to the image.</p> <code>apply_bboxes</code> <p>Transforms bounding boxes using the calculated affine matrix.</p> <code>apply_segments</code> <p>Transforms segments and generates new bounding boxes.</p> <code>apply_keypoints</code> <p>Transforms keypoints.</p> <code>__call__</code> <p>Main method to apply transformations to both images and their corresponding annotations.</p> <code>box_candidates</code> <p>Filters out bounding boxes that don't meet certain criteria post-transformation.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>class RandomPerspective:\n    \"\"\"\n    Implements random perspective and affine transformations on images and corresponding bounding boxes, segments, and\n    keypoints. These transformations include rotation, translation, scaling, and shearing. The class also offers the\n    option to apply these transformations conditionally with a specified probability.\n\n    Attributes:\n        degrees (float): Degree range for random rotations.\n        translate (float): Fraction of total width and height for random translation.\n        scale (float): Scaling factor interval, e.g., a scale factor of 0.1 allows a resize between 90%-110%.\n        shear (float): Shear intensity (angle in degrees).\n        perspective (float): Perspective distortion factor.\n        border (tuple): Tuple specifying mosaic border.\n        pre_transform (callable): A function/transform to apply to the image before starting the random transformation.\n\n    Methods:\n        affine_transform(img, border): Applies a series of affine transformations to the image.\n        apply_bboxes(bboxes, M): Transforms bounding boxes using the calculated affine matrix.\n        apply_segments(segments, M): Transforms segments and generates new bounding boxes.\n        apply_keypoints(keypoints, M): Transforms keypoints.\n        __call__(labels): Main method to apply transformations to both images and their corresponding annotations.\n        box_candidates(box1, box2): Filters out bounding boxes that don't meet certain criteria post-transformation.\n    \"\"\"\n\n    def __init__(\n        self, degrees=0.0, translate=0.1, scale=0.5, shear=0.0, perspective=0.0, border=(0, 0), pre_transform=None\n    ):\n        \"\"\"Initializes RandomPerspective object with transformation parameters.\"\"\"\n\n        self.degrees = degrees\n        self.translate = translate\n        self.scale = scale\n        self.shear = shear\n        self.perspective = perspective\n        self.border = border  # mosaic border\n        self.pre_transform = pre_transform\n\n    def affine_transform(self, img, border):\n        \"\"\"\n        Applies a sequence of affine transformations centered around the image center.\n\n        Args:\n            img (ndarray): Input image.\n            border (tuple): Border dimensions.\n\n        Returns:\n            img (ndarray): Transformed image.\n            M (ndarray): Transformation matrix.\n            s (float): Scale factor.\n        \"\"\"\n\n        # Center\n        C = np.eye(3, dtype=np.float32)\n\n        C[0, 2] = -img.shape[1] / 2  # x translation (pixels)\n        C[1, 2] = -img.shape[0] / 2  # y translation (pixels)\n\n        # Perspective\n        P = np.eye(3, dtype=np.float32)\n        P[2, 0] = random.uniform(-self.perspective, self.perspective)  # x perspective (about y)\n        P[2, 1] = random.uniform(-self.perspective, self.perspective)  # y perspective (about x)\n\n        # Rotation and Scale\n        R = np.eye(3, dtype=np.float32)\n        a = random.uniform(-self.degrees, self.degrees)\n        # a += random.choice([-180, -90, 0, 90])  # add 90deg rotations to small rotations\n        s = random.uniform(1 - self.scale, 1 + self.scale)\n        # s = 2 ** random.uniform(-scale, scale)\n        R[:2] = cv2.getRotationMatrix2D(angle=a, center=(0, 0), scale=s)\n\n        # Shear\n        S = np.eye(3, dtype=np.float32)\n        S[0, 1] = math.tan(random.uniform(-self.shear, self.shear) * math.pi / 180)  # x shear (deg)\n        S[1, 0] = math.tan(random.uniform(-self.shear, self.shear) * math.pi / 180)  # y shear (deg)\n\n        # Translation\n        T = np.eye(3, dtype=np.float32)\n        T[0, 2] = random.uniform(0.5 - self.translate, 0.5 + self.translate) * self.size[0]  # x translation (pixels)\n        T[1, 2] = random.uniform(0.5 - self.translate, 0.5 + self.translate) * self.size[1]  # y translation (pixels)\n\n        # Combined rotation matrix\n        M = T @ S @ R @ P @ C  # order of operations (right to left) is IMPORTANT\n        # Affine image\n        if (border[0] != 0) or (border[1] != 0) or (M != np.eye(3)).any():  # image changed\n            if self.perspective:\n                img = cv2.warpPerspective(img, M, dsize=self.size, borderValue=(114, 114, 114))\n            else:  # affine\n                img = cv2.warpAffine(img, M[:2], dsize=self.size, borderValue=(114, 114, 114))\n        return img, M, s\n\n    def apply_bboxes(self, bboxes, M):\n        \"\"\"\n        Apply affine to bboxes only.\n\n        Args:\n            bboxes (ndarray): list of bboxes, xyxy format, with shape (num_bboxes, 4).\n            M (ndarray): affine matrix.\n\n        Returns:\n            new_bboxes (ndarray): bboxes after affine, [num_bboxes, 4].\n        \"\"\"\n        n = len(bboxes)\n        if n == 0:\n            return bboxes\n\n        xy = np.ones((n * 4, 3), dtype=bboxes.dtype)\n        xy[:, :2] = bboxes[:, [0, 1, 2, 3, 0, 3, 2, 1]].reshape(n * 4, 2)  # x1y1, x2y2, x1y2, x2y1\n        xy = xy @ M.T  # transform\n        xy = (xy[:, :2] / xy[:, 2:3] if self.perspective else xy[:, :2]).reshape(n, 8)  # perspective rescale or affine\n\n        # Create new boxes\n        x = xy[:, [0, 2, 4, 6]]\n        y = xy[:, [1, 3, 5, 7]]\n        return np.concatenate((x.min(1), y.min(1), x.max(1), y.max(1)), dtype=bboxes.dtype).reshape(4, n).T\n\n    def apply_segments(self, segments, M):\n        \"\"\"\n        Apply affine to segments and generate new bboxes from segments.\n\n        Args:\n            segments (ndarray): list of segments, [num_samples, 500, 2].\n            M (ndarray): affine matrix.\n\n        Returns:\n            new_segments (ndarray): list of segments after affine, [num_samples, 500, 2].\n            new_bboxes (ndarray): bboxes after affine, [N, 4].\n        \"\"\"\n        n, num = segments.shape[:2]\n        if n == 0:\n            return [], segments\n\n        xy = np.ones((n * num, 3), dtype=segments.dtype)\n        segments = segments.reshape(-1, 2)\n        xy[:, :2] = segments\n        xy = xy @ M.T  # transform\n        xy = xy[:, :2] / xy[:, 2:3]\n        segments = xy.reshape(n, -1, 2)\n        bboxes = np.stack([segment2box(xy, self.size[0], self.size[1]) for xy in segments], 0)\n        segments[..., 0] = segments[..., 0].clip(bboxes[:, 0:1], bboxes[:, 2:3])\n        segments[..., 1] = segments[..., 1].clip(bboxes[:, 1:2], bboxes[:, 3:4])\n        return bboxes, segments\n\n    def apply_keypoints(self, keypoints, M):\n        \"\"\"\n        Apply affine to keypoints.\n\n        Args:\n            keypoints (ndarray): keypoints, [N, 17, 3].\n            M (ndarray): affine matrix.\n\n        Returns:\n            new_keypoints (ndarray): keypoints after affine, [N, 17, 3].\n        \"\"\"\n        n, nkpt = keypoints.shape[:2]\n        if n == 0:\n            return keypoints\n        xy = np.ones((n * nkpt, 3), dtype=keypoints.dtype)\n        visible = keypoints[..., 2].reshape(n * nkpt, 1)\n        xy[:, :2] = keypoints[..., :2].reshape(n * nkpt, 2)\n        xy = xy @ M.T  # transform\n        xy = xy[:, :2] / xy[:, 2:3]  # perspective rescale or affine\n        out_mask = (xy[:, 0] &lt; 0) | (xy[:, 1] &lt; 0) | (xy[:, 0] &gt; self.size[0]) | (xy[:, 1] &gt; self.size[1])\n        visible[out_mask] = 0\n        return np.concatenate([xy, visible], axis=-1).reshape(n, nkpt, 3)\n\n    def __call__(self, labels):\n        \"\"\"\n        Affine images and targets.\n\n        Args:\n            labels (dict): a dict of `bboxes`, `segments`, `keypoints`.\n        \"\"\"\n        if self.pre_transform and \"mosaic_border\" not in labels:\n            labels = self.pre_transform(labels)\n        labels.pop(\"ratio_pad\", None)  # do not need ratio pad\n\n        img = labels[\"img\"]\n        cls = labels[\"cls\"]\n        instances = labels.pop(\"instances\")\n        # Make sure the coord formats are right\n        instances.convert_bbox(format=\"xyxy\")\n        instances.denormalize(*img.shape[:2][::-1])\n\n        border = labels.pop(\"mosaic_border\", self.border)\n        self.size = img.shape[1] + border[1] * 2, img.shape[0] + border[0] * 2  # w, h\n        # M is affine matrix\n        # Scale for func:`box_candidates`\n        img, M, scale = self.affine_transform(img, border)\n\n        bboxes = self.apply_bboxes(instances.bboxes, M)\n\n        segments = instances.segments\n        keypoints = instances.keypoints\n        # Update bboxes if there are segments.\n        if len(segments):\n            bboxes, segments = self.apply_segments(segments, M)\n\n        if keypoints is not None:\n            keypoints = self.apply_keypoints(keypoints, M)\n        new_instances = Instances(bboxes, segments, keypoints, bbox_format=\"xyxy\", normalized=False)\n        # Clip\n        new_instances.clip(*self.size)\n\n        # Filter instances\n        instances.scale(scale_w=scale, scale_h=scale, bbox_only=True)\n        # Make the bboxes have the same scale with new_bboxes\n        i = self.box_candidates(\n            box1=instances.bboxes.T, box2=new_instances.bboxes.T, area_thr=0.01 if len(segments) else 0.10\n        )\n        labels[\"instances\"] = new_instances[i]\n        labels[\"cls\"] = cls[i]\n        labels[\"img\"] = img\n        labels[\"resized_shape\"] = img.shape[:2]\n        return labels\n\n    def box_candidates(self, box1, box2, wh_thr=2, ar_thr=100, area_thr=0.1, eps=1e-16):\n        \"\"\"\n        Compute box candidates based on a set of thresholds. This method compares the characteristics of the boxes\n        before and after augmentation to decide whether a box is a candidate for further processing.\n\n        Args:\n            box1 (numpy.ndarray): The 4,n bounding box before augmentation, represented as [x1, y1, x2, y2].\n            box2 (numpy.ndarray): The 4,n bounding box after augmentation, represented as [x1, y1, x2, y2].\n            wh_thr (float, optional): The width and height threshold in pixels. Default is 2.\n            ar_thr (float, optional): The aspect ratio threshold. Default is 100.\n            area_thr (float, optional): The area ratio threshold. Default is 0.1.\n            eps (float, optional): A small epsilon value to prevent division by zero. Default is 1e-16.\n\n        Returns:\n            (numpy.ndarray): A boolean array indicating which boxes are candidates based on the given thresholds.\n        \"\"\"\n        w1, h1 = box1[2] - box1[0], box1[3] - box1[1]\n        w2, h2 = box2[2] - box2[0], box2[3] - box2[1]\n        ar = np.maximum(w2 / (h2 + eps), h2 / (w2 + eps))  # aspect ratio\n        return (w2 &gt; wh_thr) &amp; (h2 &gt; wh_thr) &amp; (w2 * h2 / (w1 * h1 + eps) &gt; area_thr) &amp; (ar &lt; ar_thr)  # candidates\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.RandomPerspective.__call__","title":"<code>__call__(labels)</code>","text":"<p>Affine images and targets.</p> <p>Parameters:</p> Name Type Description Default <code>labels</code> <code>dict</code> <p>a dict of <code>bboxes</code>, <code>segments</code>, <code>keypoints</code>.</p> required Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __call__(self, labels):\n    \"\"\"\n    Affine images and targets.\n\n    Args:\n        labels (dict): a dict of `bboxes`, `segments`, `keypoints`.\n    \"\"\"\n    if self.pre_transform and \"mosaic_border\" not in labels:\n        labels = self.pre_transform(labels)\n    labels.pop(\"ratio_pad\", None)  # do not need ratio pad\n\n    img = labels[\"img\"]\n    cls = labels[\"cls\"]\n    instances = labels.pop(\"instances\")\n    # Make sure the coord formats are right\n    instances.convert_bbox(format=\"xyxy\")\n    instances.denormalize(*img.shape[:2][::-1])\n\n    border = labels.pop(\"mosaic_border\", self.border)\n    self.size = img.shape[1] + border[1] * 2, img.shape[0] + border[0] * 2  # w, h\n    # M is affine matrix\n    # Scale for func:`box_candidates`\n    img, M, scale = self.affine_transform(img, border)\n\n    bboxes = self.apply_bboxes(instances.bboxes, M)\n\n    segments = instances.segments\n    keypoints = instances.keypoints\n    # Update bboxes if there are segments.\n    if len(segments):\n        bboxes, segments = self.apply_segments(segments, M)\n\n    if keypoints is not None:\n        keypoints = self.apply_keypoints(keypoints, M)\n    new_instances = Instances(bboxes, segments, keypoints, bbox_format=\"xyxy\", normalized=False)\n    # Clip\n    new_instances.clip(*self.size)\n\n    # Filter instances\n    instances.scale(scale_w=scale, scale_h=scale, bbox_only=True)\n    # Make the bboxes have the same scale with new_bboxes\n    i = self.box_candidates(\n        box1=instances.bboxes.T, box2=new_instances.bboxes.T, area_thr=0.01 if len(segments) else 0.10\n    )\n    labels[\"instances\"] = new_instances[i]\n    labels[\"cls\"] = cls[i]\n    labels[\"img\"] = img\n    labels[\"resized_shape\"] = img.shape[:2]\n    return labels\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.RandomPerspective.__init__","title":"<code>__init__(degrees=0.0, translate=0.1, scale=0.5, shear=0.0, perspective=0.0, border=(0, 0), pre_transform=None)</code>","text":"<p>Initializes RandomPerspective object with transformation parameters.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __init__(\n    self, degrees=0.0, translate=0.1, scale=0.5, shear=0.0, perspective=0.0, border=(0, 0), pre_transform=None\n):\n    \"\"\"Initializes RandomPerspective object with transformation parameters.\"\"\"\n\n    self.degrees = degrees\n    self.translate = translate\n    self.scale = scale\n    self.shear = shear\n    self.perspective = perspective\n    self.border = border  # mosaic border\n    self.pre_transform = pre_transform\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.RandomPerspective.affine_transform","title":"<code>affine_transform(img, border)</code>","text":"<p>Applies a sequence of affine transformations centered around the image center.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ndarray</code> <p>Input image.</p> required <code>border</code> <code>tuple</code> <p>Border dimensions.</p> required <p>Returns:</p> Name Type Description <code>img</code> <code>ndarray</code> <p>Transformed image.</p> <code>M</code> <code>ndarray</code> <p>Transformation matrix.</p> <code>s</code> <code>float</code> <p>Scale factor.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def affine_transform(self, img, border):\n    \"\"\"\n    Applies a sequence of affine transformations centered around the image center.\n\n    Args:\n        img (ndarray): Input image.\n        border (tuple): Border dimensions.\n\n    Returns:\n        img (ndarray): Transformed image.\n        M (ndarray): Transformation matrix.\n        s (float): Scale factor.\n    \"\"\"\n\n    # Center\n    C = np.eye(3, dtype=np.float32)\n\n    C[0, 2] = -img.shape[1] / 2  # x translation (pixels)\n    C[1, 2] = -img.shape[0] / 2  # y translation (pixels)\n\n    # Perspective\n    P = np.eye(3, dtype=np.float32)\n    P[2, 0] = random.uniform(-self.perspective, self.perspective)  # x perspective (about y)\n    P[2, 1] = random.uniform(-self.perspective, self.perspective)  # y perspective (about x)\n\n    # Rotation and Scale\n    R = np.eye(3, dtype=np.float32)\n    a = random.uniform(-self.degrees, self.degrees)\n    # a += random.choice([-180, -90, 0, 90])  # add 90deg rotations to small rotations\n    s = random.uniform(1 - self.scale, 1 + self.scale)\n    # s = 2 ** random.uniform(-scale, scale)\n    R[:2] = cv2.getRotationMatrix2D(angle=a, center=(0, 0), scale=s)\n\n    # Shear\n    S = np.eye(3, dtype=np.float32)\n    S[0, 1] = math.tan(random.uniform(-self.shear, self.shear) * math.pi / 180)  # x shear (deg)\n    S[1, 0] = math.tan(random.uniform(-self.shear, self.shear) * math.pi / 180)  # y shear (deg)\n\n    # Translation\n    T = np.eye(3, dtype=np.float32)\n    T[0, 2] = random.uniform(0.5 - self.translate, 0.5 + self.translate) * self.size[0]  # x translation (pixels)\n    T[1, 2] = random.uniform(0.5 - self.translate, 0.5 + self.translate) * self.size[1]  # y translation (pixels)\n\n    # Combined rotation matrix\n    M = T @ S @ R @ P @ C  # order of operations (right to left) is IMPORTANT\n    # Affine image\n    if (border[0] != 0) or (border[1] != 0) or (M != np.eye(3)).any():  # image changed\n        if self.perspective:\n            img = cv2.warpPerspective(img, M, dsize=self.size, borderValue=(114, 114, 114))\n        else:  # affine\n            img = cv2.warpAffine(img, M[:2], dsize=self.size, borderValue=(114, 114, 114))\n    return img, M, s\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.RandomPerspective.apply_bboxes","title":"<code>apply_bboxes(bboxes, M)</code>","text":"<p>Apply affine to bboxes only.</p> <p>Parameters:</p> Name Type Description Default <code>bboxes</code> <code>ndarray</code> <p>list of bboxes, xyxy format, with shape (num_bboxes, 4).</p> required <code>M</code> <code>ndarray</code> <p>affine matrix.</p> required <p>Returns:</p> Name Type Description <code>new_bboxes</code> <code>ndarray</code> <p>bboxes after affine, [num_bboxes, 4].</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def apply_bboxes(self, bboxes, M):\n    \"\"\"\n    Apply affine to bboxes only.\n\n    Args:\n        bboxes (ndarray): list of bboxes, xyxy format, with shape (num_bboxes, 4).\n        M (ndarray): affine matrix.\n\n    Returns:\n        new_bboxes (ndarray): bboxes after affine, [num_bboxes, 4].\n    \"\"\"\n    n = len(bboxes)\n    if n == 0:\n        return bboxes\n\n    xy = np.ones((n * 4, 3), dtype=bboxes.dtype)\n    xy[:, :2] = bboxes[:, [0, 1, 2, 3, 0, 3, 2, 1]].reshape(n * 4, 2)  # x1y1, x2y2, x1y2, x2y1\n    xy = xy @ M.T  # transform\n    xy = (xy[:, :2] / xy[:, 2:3] if self.perspective else xy[:, :2]).reshape(n, 8)  # perspective rescale or affine\n\n    # Create new boxes\n    x = xy[:, [0, 2, 4, 6]]\n    y = xy[:, [1, 3, 5, 7]]\n    return np.concatenate((x.min(1), y.min(1), x.max(1), y.max(1)), dtype=bboxes.dtype).reshape(4, n).T\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.RandomPerspective.apply_keypoints","title":"<code>apply_keypoints(keypoints, M)</code>","text":"<p>Apply affine to keypoints.</p> <p>Parameters:</p> Name Type Description Default <code>keypoints</code> <code>ndarray</code> <p>keypoints, [N, 17, 3].</p> required <code>M</code> <code>ndarray</code> <p>affine matrix.</p> required <p>Returns:</p> Name Type Description <code>new_keypoints</code> <code>ndarray</code> <p>keypoints after affine, [N, 17, 3].</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def apply_keypoints(self, keypoints, M):\n    \"\"\"\n    Apply affine to keypoints.\n\n    Args:\n        keypoints (ndarray): keypoints, [N, 17, 3].\n        M (ndarray): affine matrix.\n\n    Returns:\n        new_keypoints (ndarray): keypoints after affine, [N, 17, 3].\n    \"\"\"\n    n, nkpt = keypoints.shape[:2]\n    if n == 0:\n        return keypoints\n    xy = np.ones((n * nkpt, 3), dtype=keypoints.dtype)\n    visible = keypoints[..., 2].reshape(n * nkpt, 1)\n    xy[:, :2] = keypoints[..., :2].reshape(n * nkpt, 2)\n    xy = xy @ M.T  # transform\n    xy = xy[:, :2] / xy[:, 2:3]  # perspective rescale or affine\n    out_mask = (xy[:, 0] &lt; 0) | (xy[:, 1] &lt; 0) | (xy[:, 0] &gt; self.size[0]) | (xy[:, 1] &gt; self.size[1])\n    visible[out_mask] = 0\n    return np.concatenate([xy, visible], axis=-1).reshape(n, nkpt, 3)\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.RandomPerspective.apply_segments","title":"<code>apply_segments(segments, M)</code>","text":"<p>Apply affine to segments and generate new bboxes from segments.</p> <p>Parameters:</p> Name Type Description Default <code>segments</code> <code>ndarray</code> <p>list of segments, [num_samples, 500, 2].</p> required <code>M</code> <code>ndarray</code> <p>affine matrix.</p> required <p>Returns:</p> Name Type Description <code>new_segments</code> <code>ndarray</code> <p>list of segments after affine, [num_samples, 500, 2].</p> <code>new_bboxes</code> <code>ndarray</code> <p>bboxes after affine, [N, 4].</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def apply_segments(self, segments, M):\n    \"\"\"\n    Apply affine to segments and generate new bboxes from segments.\n\n    Args:\n        segments (ndarray): list of segments, [num_samples, 500, 2].\n        M (ndarray): affine matrix.\n\n    Returns:\n        new_segments (ndarray): list of segments after affine, [num_samples, 500, 2].\n        new_bboxes (ndarray): bboxes after affine, [N, 4].\n    \"\"\"\n    n, num = segments.shape[:2]\n    if n == 0:\n        return [], segments\n\n    xy = np.ones((n * num, 3), dtype=segments.dtype)\n    segments = segments.reshape(-1, 2)\n    xy[:, :2] = segments\n    xy = xy @ M.T  # transform\n    xy = xy[:, :2] / xy[:, 2:3]\n    segments = xy.reshape(n, -1, 2)\n    bboxes = np.stack([segment2box(xy, self.size[0], self.size[1]) for xy in segments], 0)\n    segments[..., 0] = segments[..., 0].clip(bboxes[:, 0:1], bboxes[:, 2:3])\n    segments[..., 1] = segments[..., 1].clip(bboxes[:, 1:2], bboxes[:, 3:4])\n    return bboxes, segments\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.RandomPerspective.box_candidates","title":"<code>box_candidates(box1, box2, wh_thr=2, ar_thr=100, area_thr=0.1, eps=1e-16)</code>","text":"<p>Compute box candidates based on a set of thresholds. This method compares the characteristics of the boxes before and after augmentation to decide whether a box is a candidate for further processing.</p> <p>Parameters:</p> Name Type Description Default <code>box1</code> <code>ndarray</code> <p>The 4,n bounding box before augmentation, represented as [x1, y1, x2, y2].</p> required <code>box2</code> <code>ndarray</code> <p>The 4,n bounding box after augmentation, represented as [x1, y1, x2, y2].</p> required <code>wh_thr</code> <code>float</code> <p>The width and height threshold in pixels. Default is 2.</p> <code>2</code> <code>ar_thr</code> <code>float</code> <p>The aspect ratio threshold. Default is 100.</p> <code>100</code> <code>area_thr</code> <code>float</code> <p>The area ratio threshold. Default is 0.1.</p> <code>0.1</code> <code>eps</code> <code>float</code> <p>A small epsilon value to prevent division by zero. Default is 1e-16.</p> <code>1e-16</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A boolean array indicating which boxes are candidates based on the given thresholds.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def box_candidates(self, box1, box2, wh_thr=2, ar_thr=100, area_thr=0.1, eps=1e-16):\n    \"\"\"\n    Compute box candidates based on a set of thresholds. This method compares the characteristics of the boxes\n    before and after augmentation to decide whether a box is a candidate for further processing.\n\n    Args:\n        box1 (numpy.ndarray): The 4,n bounding box before augmentation, represented as [x1, y1, x2, y2].\n        box2 (numpy.ndarray): The 4,n bounding box after augmentation, represented as [x1, y1, x2, y2].\n        wh_thr (float, optional): The width and height threshold in pixels. Default is 2.\n        ar_thr (float, optional): The aspect ratio threshold. Default is 100.\n        area_thr (float, optional): The area ratio threshold. Default is 0.1.\n        eps (float, optional): A small epsilon value to prevent division by zero. Default is 1e-16.\n\n    Returns:\n        (numpy.ndarray): A boolean array indicating which boxes are candidates based on the given thresholds.\n    \"\"\"\n    w1, h1 = box1[2] - box1[0], box1[3] - box1[1]\n    w2, h2 = box2[2] - box2[0], box2[3] - box2[1]\n    ar = np.maximum(w2 / (h2 + eps), h2 / (w2 + eps))  # aspect ratio\n    return (w2 &gt; wh_thr) &amp; (h2 &gt; wh_thr) &amp; (w2 * h2 / (w1 * h1 + eps) &gt; area_thr) &amp; (ar &lt; ar_thr)  # candidates\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.RandomHSV","title":"<code>ultralytics.data.augment.RandomHSV</code>","text":"<p>This class is responsible for performing random adjustments to the Hue, Saturation, and Value (HSV) channels of an image.</p> <p>The adjustments are random but within limits set by hgain, sgain, and vgain.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>class RandomHSV:\n    \"\"\"\n    This class is responsible for performing random adjustments to the Hue, Saturation, and Value (HSV) channels of an\n    image.\n\n    The adjustments are random but within limits set by hgain, sgain, and vgain.\n    \"\"\"\n\n    def __init__(self, hgain=0.5, sgain=0.5, vgain=0.5) -&gt; None:\n        \"\"\"\n        Initialize RandomHSV class with gains for each HSV channel.\n\n        Args:\n            hgain (float, optional): Maximum variation for hue. Default is 0.5.\n            sgain (float, optional): Maximum variation for saturation. Default is 0.5.\n            vgain (float, optional): Maximum variation for value. Default is 0.5.\n        \"\"\"\n        self.hgain = hgain\n        self.sgain = sgain\n        self.vgain = vgain\n\n    def __call__(self, labels):\n        \"\"\"\n        Applies random HSV augmentation to an image within the predefined limits.\n\n        The modified image replaces the original image in the input 'labels' dict.\n        \"\"\"\n        img = labels[\"img\"]\n        if self.hgain or self.sgain or self.vgain:\n            r = np.random.uniform(-1, 1, 3) * [self.hgain, self.sgain, self.vgain] + 1  # random gains\n            hue, sat, val = cv2.split(cv2.cvtColor(img, cv2.COLOR_BGR2HSV))\n            dtype = img.dtype  # uint8\n\n            x = np.arange(0, 256, dtype=r.dtype)\n            lut_hue = ((x * r[0]) % 180).astype(dtype)\n            lut_sat = np.clip(x * r[1], 0, 255).astype(dtype)\n            lut_val = np.clip(x * r[2], 0, 255).astype(dtype)\n\n            im_hsv = cv2.merge((cv2.LUT(hue, lut_hue), cv2.LUT(sat, lut_sat), cv2.LUT(val, lut_val)))\n            cv2.cvtColor(im_hsv, cv2.COLOR_HSV2BGR, dst=img)  # no return needed\n        return labels\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.RandomHSV.__call__","title":"<code>__call__(labels)</code>","text":"<p>Applies random HSV augmentation to an image within the predefined limits.</p> <p>The modified image replaces the original image in the input 'labels' dict.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __call__(self, labels):\n    \"\"\"\n    Applies random HSV augmentation to an image within the predefined limits.\n\n    The modified image replaces the original image in the input 'labels' dict.\n    \"\"\"\n    img = labels[\"img\"]\n    if self.hgain or self.sgain or self.vgain:\n        r = np.random.uniform(-1, 1, 3) * [self.hgain, self.sgain, self.vgain] + 1  # random gains\n        hue, sat, val = cv2.split(cv2.cvtColor(img, cv2.COLOR_BGR2HSV))\n        dtype = img.dtype  # uint8\n\n        x = np.arange(0, 256, dtype=r.dtype)\n        lut_hue = ((x * r[0]) % 180).astype(dtype)\n        lut_sat = np.clip(x * r[1], 0, 255).astype(dtype)\n        lut_val = np.clip(x * r[2], 0, 255).astype(dtype)\n\n        im_hsv = cv2.merge((cv2.LUT(hue, lut_hue), cv2.LUT(sat, lut_sat), cv2.LUT(val, lut_val)))\n        cv2.cvtColor(im_hsv, cv2.COLOR_HSV2BGR, dst=img)  # no return needed\n    return labels\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.RandomHSV.__init__","title":"<code>__init__(hgain=0.5, sgain=0.5, vgain=0.5)</code>","text":"<p>Initialize RandomHSV class with gains for each HSV channel.</p> <p>Parameters:</p> Name Type Description Default <code>hgain</code> <code>float</code> <p>Maximum variation for hue. Default is 0.5.</p> <code>0.5</code> <code>sgain</code> <code>float</code> <p>Maximum variation for saturation. Default is 0.5.</p> <code>0.5</code> <code>vgain</code> <code>float</code> <p>Maximum variation for value. Default is 0.5.</p> <code>0.5</code> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __init__(self, hgain=0.5, sgain=0.5, vgain=0.5) -&gt; None:\n    \"\"\"\n    Initialize RandomHSV class with gains for each HSV channel.\n\n    Args:\n        hgain (float, optional): Maximum variation for hue. Default is 0.5.\n        sgain (float, optional): Maximum variation for saturation. Default is 0.5.\n        vgain (float, optional): Maximum variation for value. Default is 0.5.\n    \"\"\"\n    self.hgain = hgain\n    self.sgain = sgain\n    self.vgain = vgain\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.RandomFlip","title":"<code>ultralytics.data.augment.RandomFlip</code>","text":"<p>Applies a random horizontal or vertical flip to an image with a given probability.</p> <p>Also updates any instances (bounding boxes, keypoints, etc.) accordingly.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>class RandomFlip:\n    \"\"\"\n    Applies a random horizontal or vertical flip to an image with a given probability.\n\n    Also updates any instances (bounding boxes, keypoints, etc.) accordingly.\n    \"\"\"\n\n    def __init__(self, p=0.5, direction=\"horizontal\", flip_idx=None) -&gt; None:\n        \"\"\"\n        Initializes the RandomFlip class with probability and direction.\n\n        Args:\n            p (float, optional): The probability of applying the flip. Must be between 0 and 1. Default is 0.5.\n            direction (str, optional): The direction to apply the flip. Must be 'horizontal' or 'vertical'.\n                Default is 'horizontal'.\n            flip_idx (array-like, optional): Index mapping for flipping keypoints, if any.\n        \"\"\"\n        assert direction in [\"horizontal\", \"vertical\"], f\"Support direction `horizontal` or `vertical`, got {direction}\"\n        assert 0 &lt;= p &lt;= 1.0\n\n        self.p = p\n        self.direction = direction\n        self.flip_idx = flip_idx\n\n    def __call__(self, labels):\n        \"\"\"\n        Applies random flip to an image and updates any instances like bounding boxes or keypoints accordingly.\n\n        Args:\n            labels (dict): A dictionary containing the keys 'img' and 'instances'. 'img' is the image to be flipped.\n                           'instances' is an object containing bounding boxes and optionally keypoints.\n\n        Returns:\n            (dict): The same dict with the flipped image and updated instances under the 'img' and 'instances' keys.\n        \"\"\"\n        img = labels[\"img\"]\n        instances = labels.pop(\"instances\")\n        instances.convert_bbox(format=\"xywh\")\n        h, w = img.shape[:2]\n        h = 1 if instances.normalized else h\n        w = 1 if instances.normalized else w\n\n        # Flip up-down\n        if self.direction == \"vertical\" and random.random() &lt; self.p:\n            img = np.flipud(img)\n            instances.flipud(h)\n        if self.direction == \"horizontal\" and random.random() &lt; self.p:\n            img = np.fliplr(img)\n            instances.fliplr(w)\n            # For keypoints\n            if self.flip_idx is not None and instances.keypoints is not None:\n                instances.keypoints = np.ascontiguousarray(instances.keypoints[:, self.flip_idx, :])\n        labels[\"img\"] = np.ascontiguousarray(img)\n        labels[\"instances\"] = instances\n        return labels\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.RandomFlip.__call__","title":"<code>__call__(labels)</code>","text":"<p>Applies random flip to an image and updates any instances like bounding boxes or keypoints accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>labels</code> <code>dict</code> <p>A dictionary containing the keys 'img' and 'instances'. 'img' is the image to be flipped.            'instances' is an object containing bounding boxes and optionally keypoints.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The same dict with the flipped image and updated instances under the 'img' and 'instances' keys.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __call__(self, labels):\n    \"\"\"\n    Applies random flip to an image and updates any instances like bounding boxes or keypoints accordingly.\n\n    Args:\n        labels (dict): A dictionary containing the keys 'img' and 'instances'. 'img' is the image to be flipped.\n                       'instances' is an object containing bounding boxes and optionally keypoints.\n\n    Returns:\n        (dict): The same dict with the flipped image and updated instances under the 'img' and 'instances' keys.\n    \"\"\"\n    img = labels[\"img\"]\n    instances = labels.pop(\"instances\")\n    instances.convert_bbox(format=\"xywh\")\n    h, w = img.shape[:2]\n    h = 1 if instances.normalized else h\n    w = 1 if instances.normalized else w\n\n    # Flip up-down\n    if self.direction == \"vertical\" and random.random() &lt; self.p:\n        img = np.flipud(img)\n        instances.flipud(h)\n    if self.direction == \"horizontal\" and random.random() &lt; self.p:\n        img = np.fliplr(img)\n        instances.fliplr(w)\n        # For keypoints\n        if self.flip_idx is not None and instances.keypoints is not None:\n            instances.keypoints = np.ascontiguousarray(instances.keypoints[:, self.flip_idx, :])\n    labels[\"img\"] = np.ascontiguousarray(img)\n    labels[\"instances\"] = instances\n    return labels\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.RandomFlip.__init__","title":"<code>__init__(p=0.5, direction='horizontal', flip_idx=None)</code>","text":"<p>Initializes the RandomFlip class with probability and direction.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>float</code> <p>The probability of applying the flip. Must be between 0 and 1. Default is 0.5.</p> <code>0.5</code> <code>direction</code> <code>str</code> <p>The direction to apply the flip. Must be 'horizontal' or 'vertical'. Default is 'horizontal'.</p> <code>'horizontal'</code> <code>flip_idx</code> <code>array - like</code> <p>Index mapping for flipping keypoints, if any.</p> <code>None</code> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __init__(self, p=0.5, direction=\"horizontal\", flip_idx=None) -&gt; None:\n    \"\"\"\n    Initializes the RandomFlip class with probability and direction.\n\n    Args:\n        p (float, optional): The probability of applying the flip. Must be between 0 and 1. Default is 0.5.\n        direction (str, optional): The direction to apply the flip. Must be 'horizontal' or 'vertical'.\n            Default is 'horizontal'.\n        flip_idx (array-like, optional): Index mapping for flipping keypoints, if any.\n    \"\"\"\n    assert direction in [\"horizontal\", \"vertical\"], f\"Support direction `horizontal` or `vertical`, got {direction}\"\n    assert 0 &lt;= p &lt;= 1.0\n\n    self.p = p\n    self.direction = direction\n    self.flip_idx = flip_idx\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.LetterBox","title":"<code>ultralytics.data.augment.LetterBox</code>","text":"<p>Resize image and padding for detection, instance segmentation, pose.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>class LetterBox:\n    \"\"\"Resize image and padding for detection, instance segmentation, pose.\"\"\"\n\n    def __init__(self, new_shape=(640, 640), auto=False, scaleFill=False, scaleup=True, center=True, stride=32):\n        \"\"\"Initialize LetterBox object with specific parameters.\"\"\"\n        self.new_shape = new_shape\n        self.auto = auto\n        self.scaleFill = scaleFill\n        self.scaleup = scaleup\n        self.stride = stride\n        self.center = center  # Put the image in the middle or top-left\n\n    def __call__(self, labels=None, image=None):\n        \"\"\"Return updated labels and image with added border.\"\"\"\n        if labels is None:\n            labels = {}\n        img = labels.get(\"img\") if image is None else image\n        shape = img.shape[:2]  # current shape [height, width]\n        new_shape = labels.pop(\"rect_shape\", self.new_shape)\n        if isinstance(new_shape, int):\n            new_shape = (new_shape, new_shape)\n\n        # Scale ratio (new / old)\n        r = min(new_shape[0] / shape[0], new_shape[1] / shape[1])\n        if not self.scaleup:  # only scale down, do not scale up (for better val mAP)\n            r = min(r, 1.0)\n\n        # Compute padding\n        ratio = r, r  # width, height ratios\n        new_unpad = int(round(shape[1] * r)), int(round(shape[0] * r))\n        dw, dh = new_shape[1] - new_unpad[0], new_shape[0] - new_unpad[1]  # wh padding\n        if self.auto:  # minimum rectangle\n            dw, dh = np.mod(dw, self.stride), np.mod(dh, self.stride)  # wh padding\n        elif self.scaleFill:  # stretch\n            dw, dh = 0.0, 0.0\n            new_unpad = (new_shape[1], new_shape[0])\n            ratio = new_shape[1] / shape[1], new_shape[0] / shape[0]  # width, height ratios\n\n        if self.center:\n            dw /= 2  # divide padding into 2 sides\n            dh /= 2\n\n        if shape[::-1] != new_unpad:  # resize\n            img = cv2.resize(img, new_unpad, interpolation=cv2.INTER_LINEAR)\n        top, bottom = int(round(dh - 0.1)) if self.center else 0, int(round(dh + 0.1))\n        left, right = int(round(dw - 0.1)) if self.center else 0, int(round(dw + 0.1))\n        img = cv2.copyMakeBorder(\n            img, top, bottom, left, right, cv2.BORDER_CONSTANT, value=(114, 114, 114)\n        )  # add border\n        if labels.get(\"ratio_pad\"):\n            labels[\"ratio_pad\"] = (labels[\"ratio_pad\"], (left, top))  # for evaluation\n\n        if len(labels):\n            labels = self._update_labels(labels, ratio, dw, dh)\n            labels[\"img\"] = img\n            labels[\"resized_shape\"] = new_shape\n            return labels\n        else:\n            return img\n\n    def _update_labels(self, labels, ratio, padw, padh):\n        \"\"\"Update labels.\"\"\"\n        labels[\"instances\"].convert_bbox(format=\"xyxy\")\n        labels[\"instances\"].denormalize(*labels[\"img\"].shape[:2][::-1])\n        labels[\"instances\"].scale(*ratio)\n        labels[\"instances\"].add_padding(padw, padh)\n        return labels\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.LetterBox.__call__","title":"<code>__call__(labels=None, image=None)</code>","text":"<p>Return updated labels and image with added border.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __call__(self, labels=None, image=None):\n    \"\"\"Return updated labels and image with added border.\"\"\"\n    if labels is None:\n        labels = {}\n    img = labels.get(\"img\") if image is None else image\n    shape = img.shape[:2]  # current shape [height, width]\n    new_shape = labels.pop(\"rect_shape\", self.new_shape)\n    if isinstance(new_shape, int):\n        new_shape = (new_shape, new_shape)\n\n    # Scale ratio (new / old)\n    r = min(new_shape[0] / shape[0], new_shape[1] / shape[1])\n    if not self.scaleup:  # only scale down, do not scale up (for better val mAP)\n        r = min(r, 1.0)\n\n    # Compute padding\n    ratio = r, r  # width, height ratios\n    new_unpad = int(round(shape[1] * r)), int(round(shape[0] * r))\n    dw, dh = new_shape[1] - new_unpad[0], new_shape[0] - new_unpad[1]  # wh padding\n    if self.auto:  # minimum rectangle\n        dw, dh = np.mod(dw, self.stride), np.mod(dh, self.stride)  # wh padding\n    elif self.scaleFill:  # stretch\n        dw, dh = 0.0, 0.0\n        new_unpad = (new_shape[1], new_shape[0])\n        ratio = new_shape[1] / shape[1], new_shape[0] / shape[0]  # width, height ratios\n\n    if self.center:\n        dw /= 2  # divide padding into 2 sides\n        dh /= 2\n\n    if shape[::-1] != new_unpad:  # resize\n        img = cv2.resize(img, new_unpad, interpolation=cv2.INTER_LINEAR)\n    top, bottom = int(round(dh - 0.1)) if self.center else 0, int(round(dh + 0.1))\n    left, right = int(round(dw - 0.1)) if self.center else 0, int(round(dw + 0.1))\n    img = cv2.copyMakeBorder(\n        img, top, bottom, left, right, cv2.BORDER_CONSTANT, value=(114, 114, 114)\n    )  # add border\n    if labels.get(\"ratio_pad\"):\n        labels[\"ratio_pad\"] = (labels[\"ratio_pad\"], (left, top))  # for evaluation\n\n    if len(labels):\n        labels = self._update_labels(labels, ratio, dw, dh)\n        labels[\"img\"] = img\n        labels[\"resized_shape\"] = new_shape\n        return labels\n    else:\n        return img\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.LetterBox.__init__","title":"<code>__init__(new_shape=(640, 640), auto=False, scaleFill=False, scaleup=True, center=True, stride=32)</code>","text":"<p>Initialize LetterBox object with specific parameters.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __init__(self, new_shape=(640, 640), auto=False, scaleFill=False, scaleup=True, center=True, stride=32):\n    \"\"\"Initialize LetterBox object with specific parameters.\"\"\"\n    self.new_shape = new_shape\n    self.auto = auto\n    self.scaleFill = scaleFill\n    self.scaleup = scaleup\n    self.stride = stride\n    self.center = center  # Put the image in the middle or top-left\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.CopyPaste","title":"<code>ultralytics.data.augment.CopyPaste</code>","text":"<p>Implements the Copy-Paste augmentation as described in the paper https://arxiv.org/abs/2012.07177. This class is responsible for applying the Copy-Paste augmentation on images and their corresponding instances.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>class CopyPaste:\n    \"\"\"\n    Implements the Copy-Paste augmentation as described in the paper https://arxiv.org/abs/2012.07177. This class is\n    responsible for applying the Copy-Paste augmentation on images and their corresponding instances.\n    \"\"\"\n\n    def __init__(self, p=0.5) -&gt; None:\n        \"\"\"\n        Initializes the CopyPaste class with a given probability.\n\n        Args:\n            p (float, optional): The probability of applying the Copy-Paste augmentation. Must be between 0 and 1.\n                                 Default is 0.5.\n        \"\"\"\n        self.p = p\n\n    def __call__(self, labels):\n        \"\"\"\n        Applies the Copy-Paste augmentation to the given image and instances.\n\n        Args:\n            labels (dict): A dictionary containing:\n                           - 'img': The image to augment.\n                           - 'cls': Class labels associated with the instances.\n                           - 'instances': Object containing bounding boxes, and optionally, keypoints and segments.\n\n        Returns:\n            (dict): Dict with augmented image and updated instances under the 'img', 'cls', and 'instances' keys.\n\n        Notes:\n            1. Instances are expected to have 'segments' as one of their attributes for this augmentation to work.\n            2. This method modifies the input dictionary 'labels' in place.\n        \"\"\"\n        im = labels[\"img\"]\n        cls = labels[\"cls\"]\n        h, w = im.shape[:2]\n        instances = labels.pop(\"instances\")\n        instances.convert_bbox(format=\"xyxy\")\n        instances.denormalize(w, h)\n        if self.p and len(instances.segments):\n            n = len(instances)\n            _, w, _ = im.shape  # height, width, channels\n            im_new = np.zeros(im.shape, np.uint8)\n\n            # Calculate ioa first then select indexes randomly\n            ins_flip = deepcopy(instances)\n            ins_flip.fliplr(w)\n\n            ioa = bbox_ioa(ins_flip.bboxes, instances.bboxes)  # intersection over area, (N, M)\n            indexes = np.nonzero((ioa &lt; 0.30).all(1))[0]  # (N, )\n            n = len(indexes)\n            for j in random.sample(list(indexes), k=round(self.p * n)):\n                cls = np.concatenate((cls, cls[[j]]), axis=0)\n                instances = Instances.concatenate((instances, ins_flip[[j]]), axis=0)\n                cv2.drawContours(im_new, instances.segments[[j]].astype(np.int32), -1, (1, 1, 1), cv2.FILLED)\n\n            result = cv2.flip(im, 1)  # augment segments (flip left-right)\n            i = cv2.flip(im_new, 1).astype(bool)\n            im[i] = result[i]\n\n        labels[\"img\"] = im\n        labels[\"cls\"] = cls\n        labels[\"instances\"] = instances\n        return labels\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.CopyPaste.__call__","title":"<code>__call__(labels)</code>","text":"<p>Applies the Copy-Paste augmentation to the given image and instances.</p> <p>Parameters:</p> Name Type Description Default <code>labels</code> <code>dict</code> <p>A dictionary containing:            - 'img': The image to augment.            - 'cls': Class labels associated with the instances.            - 'instances': Object containing bounding boxes, and optionally, keypoints and segments.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dict with augmented image and updated instances under the 'img', 'cls', and 'instances' keys.</p> Notes <ol> <li>Instances are expected to have 'segments' as one of their attributes for this augmentation to work.</li> <li>This method modifies the input dictionary 'labels' in place.</li> </ol> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __call__(self, labels):\n    \"\"\"\n    Applies the Copy-Paste augmentation to the given image and instances.\n\n    Args:\n        labels (dict): A dictionary containing:\n                       - 'img': The image to augment.\n                       - 'cls': Class labels associated with the instances.\n                       - 'instances': Object containing bounding boxes, and optionally, keypoints and segments.\n\n    Returns:\n        (dict): Dict with augmented image and updated instances under the 'img', 'cls', and 'instances' keys.\n\n    Notes:\n        1. Instances are expected to have 'segments' as one of their attributes for this augmentation to work.\n        2. This method modifies the input dictionary 'labels' in place.\n    \"\"\"\n    im = labels[\"img\"]\n    cls = labels[\"cls\"]\n    h, w = im.shape[:2]\n    instances = labels.pop(\"instances\")\n    instances.convert_bbox(format=\"xyxy\")\n    instances.denormalize(w, h)\n    if self.p and len(instances.segments):\n        n = len(instances)\n        _, w, _ = im.shape  # height, width, channels\n        im_new = np.zeros(im.shape, np.uint8)\n\n        # Calculate ioa first then select indexes randomly\n        ins_flip = deepcopy(instances)\n        ins_flip.fliplr(w)\n\n        ioa = bbox_ioa(ins_flip.bboxes, instances.bboxes)  # intersection over area, (N, M)\n        indexes = np.nonzero((ioa &lt; 0.30).all(1))[0]  # (N, )\n        n = len(indexes)\n        for j in random.sample(list(indexes), k=round(self.p * n)):\n            cls = np.concatenate((cls, cls[[j]]), axis=0)\n            instances = Instances.concatenate((instances, ins_flip[[j]]), axis=0)\n            cv2.drawContours(im_new, instances.segments[[j]].astype(np.int32), -1, (1, 1, 1), cv2.FILLED)\n\n        result = cv2.flip(im, 1)  # augment segments (flip left-right)\n        i = cv2.flip(im_new, 1).astype(bool)\n        im[i] = result[i]\n\n    labels[\"img\"] = im\n    labels[\"cls\"] = cls\n    labels[\"instances\"] = instances\n    return labels\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.CopyPaste.__init__","title":"<code>__init__(p=0.5)</code>","text":"<p>Initializes the CopyPaste class with a given probability.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>float</code> <p>The probability of applying the Copy-Paste augmentation. Must be between 0 and 1.                  Default is 0.5.</p> <code>0.5</code> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __init__(self, p=0.5) -&gt; None:\n    \"\"\"\n    Initializes the CopyPaste class with a given probability.\n\n    Args:\n        p (float, optional): The probability of applying the Copy-Paste augmentation. Must be between 0 and 1.\n                             Default is 0.5.\n    \"\"\"\n    self.p = p\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.Albumentations","title":"<code>ultralytics.data.augment.Albumentations</code>","text":"<p>Albumentations transformations.</p> <p>Optional, uninstall package to disable. Applies Blur, Median Blur, convert to grayscale, Contrast Limited Adaptive Histogram Equalization, random change of brightness and contrast, RandomGamma and lowering of image quality by compression.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>class Albumentations:\n    \"\"\"\n    Albumentations transformations.\n\n    Optional, uninstall package to disable. Applies Blur, Median Blur, convert to grayscale, Contrast Limited Adaptive\n    Histogram Equalization, random change of brightness and contrast, RandomGamma and lowering of image quality by\n    compression.\n    \"\"\"\n\n    def __init__(self, p=1.0):\n        \"\"\"Initialize the transform object for YOLO bbox formatted params.\"\"\"\n        self.p = p\n        self.transform = None\n        prefix = colorstr(\"albumentations: \")\n        try:\n            import albumentations as A\n\n            check_version(A.__version__, \"1.0.3\", hard=True)  # version requirement\n\n            # Transforms\n            T = [\n                A.Blur(p=0.01),\n                A.MedianBlur(p=0.01),\n                A.ToGray(p=0.01),\n                A.CLAHE(p=0.01),\n                A.RandomBrightnessContrast(p=0.0),\n                A.RandomGamma(p=0.0),\n                A.ImageCompression(quality_lower=75, p=0.0),\n            ]\n            self.transform = A.Compose(T, bbox_params=A.BboxParams(format=\"yolo\", label_fields=[\"class_labels\"]))\n\n            LOGGER.info(prefix + \", \".join(f\"{x}\".replace(\"always_apply=False, \", \"\") for x in T if x.p))\n        except ImportError:  # package not installed, skip\n            pass\n        except Exception as e:\n            LOGGER.info(f\"{prefix}{e}\")\n\n    def __call__(self, labels):\n        \"\"\"Generates object detections and returns a dictionary with detection results.\"\"\"\n        im = labels[\"img\"]\n        cls = labels[\"cls\"]\n        if len(cls):\n            labels[\"instances\"].convert_bbox(\"xywh\")\n            labels[\"instances\"].normalize(*im.shape[:2][::-1])\n            bboxes = labels[\"instances\"].bboxes\n            # TODO: add supports of segments and keypoints\n            if self.transform and random.random() &lt; self.p:\n                new = self.transform(image=im, bboxes=bboxes, class_labels=cls)  # transformed\n                if len(new[\"class_labels\"]) &gt; 0:  # skip update if no bbox in new im\n                    labels[\"img\"] = new[\"image\"]\n                    labels[\"cls\"] = np.array(new[\"class_labels\"])\n                    bboxes = np.array(new[\"bboxes\"], dtype=np.float32)\n            labels[\"instances\"].update(bboxes=bboxes)\n        return labels\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.Albumentations.__call__","title":"<code>__call__(labels)</code>","text":"<p>Generates object detections and returns a dictionary with detection results.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __call__(self, labels):\n    \"\"\"Generates object detections and returns a dictionary with detection results.\"\"\"\n    im = labels[\"img\"]\n    cls = labels[\"cls\"]\n    if len(cls):\n        labels[\"instances\"].convert_bbox(\"xywh\")\n        labels[\"instances\"].normalize(*im.shape[:2][::-1])\n        bboxes = labels[\"instances\"].bboxes\n        # TODO: add supports of segments and keypoints\n        if self.transform and random.random() &lt; self.p:\n            new = self.transform(image=im, bboxes=bboxes, class_labels=cls)  # transformed\n            if len(new[\"class_labels\"]) &gt; 0:  # skip update if no bbox in new im\n                labels[\"img\"] = new[\"image\"]\n                labels[\"cls\"] = np.array(new[\"class_labels\"])\n                bboxes = np.array(new[\"bboxes\"], dtype=np.float32)\n        labels[\"instances\"].update(bboxes=bboxes)\n    return labels\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.Albumentations.__init__","title":"<code>__init__(p=1.0)</code>","text":"<p>Initialize the transform object for YOLO bbox formatted params.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __init__(self, p=1.0):\n    \"\"\"Initialize the transform object for YOLO bbox formatted params.\"\"\"\n    self.p = p\n    self.transform = None\n    prefix = colorstr(\"albumentations: \")\n    try:\n        import albumentations as A\n\n        check_version(A.__version__, \"1.0.3\", hard=True)  # version requirement\n\n        # Transforms\n        T = [\n            A.Blur(p=0.01),\n            A.MedianBlur(p=0.01),\n            A.ToGray(p=0.01),\n            A.CLAHE(p=0.01),\n            A.RandomBrightnessContrast(p=0.0),\n            A.RandomGamma(p=0.0),\n            A.ImageCompression(quality_lower=75, p=0.0),\n        ]\n        self.transform = A.Compose(T, bbox_params=A.BboxParams(format=\"yolo\", label_fields=[\"class_labels\"]))\n\n        LOGGER.info(prefix + \", \".join(f\"{x}\".replace(\"always_apply=False, \", \"\") for x in T if x.p))\n    except ImportError:  # package not installed, skip\n        pass\n    except Exception as e:\n        LOGGER.info(f\"{prefix}{e}\")\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.Format","title":"<code>ultralytics.data.augment.Format</code>","text":"<p>Formats image annotations for object detection, instance segmentation, and pose estimation tasks. The class standardizes the image and instance annotations to be used by the <code>collate_fn</code> in PyTorch DataLoader.</p> <p>Attributes:</p> Name Type Description <code>bbox_format</code> <code>str</code> <p>Format for bounding boxes. Default is 'xywh'.</p> <code>normalize</code> <code>bool</code> <p>Whether to normalize bounding boxes. Default is True.</p> <code>return_mask</code> <code>bool</code> <p>Return instance masks for segmentation. Default is False.</p> <code>return_keypoint</code> <code>bool</code> <p>Return keypoints for pose estimation. Default is False.</p> <code>mask_ratio</code> <code>int</code> <p>Downsample ratio for masks. Default is 4.</p> <code>mask_overlap</code> <code>bool</code> <p>Whether to overlap masks. Default is True.</p> <code>batch_idx</code> <code>bool</code> <p>Keep batch indexes. Default is True.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>class Format:\n    \"\"\"\n    Formats image annotations for object detection, instance segmentation, and pose estimation tasks. The class\n    standardizes the image and instance annotations to be used by the `collate_fn` in PyTorch DataLoader.\n\n    Attributes:\n        bbox_format (str): Format for bounding boxes. Default is 'xywh'.\n        normalize (bool): Whether to normalize bounding boxes. Default is True.\n        return_mask (bool): Return instance masks for segmentation. Default is False.\n        return_keypoint (bool): Return keypoints for pose estimation. Default is False.\n        mask_ratio (int): Downsample ratio for masks. Default is 4.\n        mask_overlap (bool): Whether to overlap masks. Default is True.\n        batch_idx (bool): Keep batch indexes. Default is True.\n    \"\"\"\n\n    def __init__(\n        self,\n        bbox_format=\"xywh\",\n        normalize=True,\n        return_mask=False,\n        return_keypoint=False,\n        return_obb=False,\n        mask_ratio=4,\n        mask_overlap=True,\n        batch_idx=True,\n    ):\n        \"\"\"Initializes the Format class with given parameters.\"\"\"\n        self.bbox_format = bbox_format\n        self.normalize = normalize\n        self.return_mask = return_mask  # set False when training detection only\n        self.return_keypoint = return_keypoint\n        self.return_obb = return_obb\n        self.mask_ratio = mask_ratio\n        self.mask_overlap = mask_overlap\n        self.batch_idx = batch_idx  # keep the batch indexes\n\n    def __call__(self, labels):\n        \"\"\"Return formatted image, classes, bounding boxes &amp; keypoints to be used by 'collate_fn'.\"\"\"\n        img = labels.pop(\"img\")\n        h, w = img.shape[:2]\n        cls = labels.pop(\"cls\")\n        instances = labels.pop(\"instances\")\n        instances.convert_bbox(format=self.bbox_format)\n        instances.denormalize(w, h)\n        nl = len(instances)\n\n        if self.return_mask:\n            if nl:\n                masks, instances, cls = self._format_segments(instances, cls, w, h)\n                masks = torch.from_numpy(masks)\n            else:\n                masks = torch.zeros(\n                    1 if self.mask_overlap else nl, img.shape[0] // self.mask_ratio, img.shape[1] // self.mask_ratio\n                )\n            labels[\"masks\"] = masks\n        if self.normalize:\n            instances.normalize(w, h)\n        labels[\"img\"] = self._format_img(img)\n        labels[\"cls\"] = torch.from_numpy(cls) if nl else torch.zeros(nl)\n        labels[\"bboxes\"] = torch.from_numpy(instances.bboxes) if nl else torch.zeros((nl, 4))\n        if self.return_keypoint:\n            labels[\"keypoints\"] = torch.from_numpy(instances.keypoints)\n        if self.return_obb:\n            labels[\"bboxes\"] = (\n                xyxyxyxy2xywhr(torch.from_numpy(instances.segments)) if len(instances.segments) else torch.zeros((0, 5))\n            )\n        # Then we can use collate_fn\n        if self.batch_idx:\n            labels[\"batch_idx\"] = torch.zeros(nl)\n        return labels\n\n    def _format_img(self, img):\n        \"\"\"Format the image for YOLO from Numpy array to PyTorch tensor.\"\"\"\n        if len(img.shape) &lt; 3:\n            img = np.expand_dims(img, -1)\n        img = np.ascontiguousarray(img.transpose(2, 0, 1)[::-1])\n        img = torch.from_numpy(img)\n        return img\n\n    def _format_segments(self, instances, cls, w, h):\n        \"\"\"Convert polygon points to bitmap.\"\"\"\n        segments = instances.segments\n        if self.mask_overlap:\n            masks, sorted_idx = polygons2masks_overlap((h, w), segments, downsample_ratio=self.mask_ratio)\n            masks = masks[None]  # (640, 640) -&gt; (1, 640, 640)\n            instances = instances[sorted_idx]\n            cls = cls[sorted_idx]\n        else:\n            masks = polygons2masks((h, w), segments, color=1, downsample_ratio=self.mask_ratio)\n\n        return masks, instances, cls\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.Format.__call__","title":"<code>__call__(labels)</code>","text":"<p>Return formatted image, classes, bounding boxes &amp; keypoints to be used by 'collate_fn'.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __call__(self, labels):\n    \"\"\"Return formatted image, classes, bounding boxes &amp; keypoints to be used by 'collate_fn'.\"\"\"\n    img = labels.pop(\"img\")\n    h, w = img.shape[:2]\n    cls = labels.pop(\"cls\")\n    instances = labels.pop(\"instances\")\n    instances.convert_bbox(format=self.bbox_format)\n    instances.denormalize(w, h)\n    nl = len(instances)\n\n    if self.return_mask:\n        if nl:\n            masks, instances, cls = self._format_segments(instances, cls, w, h)\n            masks = torch.from_numpy(masks)\n        else:\n            masks = torch.zeros(\n                1 if self.mask_overlap else nl, img.shape[0] // self.mask_ratio, img.shape[1] // self.mask_ratio\n            )\n        labels[\"masks\"] = masks\n    if self.normalize:\n        instances.normalize(w, h)\n    labels[\"img\"] = self._format_img(img)\n    labels[\"cls\"] = torch.from_numpy(cls) if nl else torch.zeros(nl)\n    labels[\"bboxes\"] = torch.from_numpy(instances.bboxes) if nl else torch.zeros((nl, 4))\n    if self.return_keypoint:\n        labels[\"keypoints\"] = torch.from_numpy(instances.keypoints)\n    if self.return_obb:\n        labels[\"bboxes\"] = (\n            xyxyxyxy2xywhr(torch.from_numpy(instances.segments)) if len(instances.segments) else torch.zeros((0, 5))\n        )\n    # Then we can use collate_fn\n    if self.batch_idx:\n        labels[\"batch_idx\"] = torch.zeros(nl)\n    return labels\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.Format.__init__","title":"<code>__init__(bbox_format='xywh', normalize=True, return_mask=False, return_keypoint=False, return_obb=False, mask_ratio=4, mask_overlap=True, batch_idx=True)</code>","text":"<p>Initializes the Format class with given parameters.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __init__(\n    self,\n    bbox_format=\"xywh\",\n    normalize=True,\n    return_mask=False,\n    return_keypoint=False,\n    return_obb=False,\n    mask_ratio=4,\n    mask_overlap=True,\n    batch_idx=True,\n):\n    \"\"\"Initializes the Format class with given parameters.\"\"\"\n    self.bbox_format = bbox_format\n    self.normalize = normalize\n    self.return_mask = return_mask  # set False when training detection only\n    self.return_keypoint = return_keypoint\n    self.return_obb = return_obb\n    self.mask_ratio = mask_ratio\n    self.mask_overlap = mask_overlap\n    self.batch_idx = batch_idx  # keep the batch indexes\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.ClassifyLetterBox","title":"<code>ultralytics.data.augment.ClassifyLetterBox</code>","text":"<p>YOLOv8 LetterBox class for image preprocessing, designed to be part of a transformation pipeline, e.g., T.Compose([LetterBox(size), ToTensor()]).</p> <p>Attributes:</p> Name Type Description <code>h</code> <code>int</code> <p>Target height of the image.</p> <code>w</code> <code>int</code> <p>Target width of the image.</p> <code>auto</code> <code>bool</code> <p>If True, automatically solves for short side using stride.</p> <code>stride</code> <code>int</code> <p>The stride value, used when 'auto' is True.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>class ClassifyLetterBox:\n    \"\"\"\n    YOLOv8 LetterBox class for image preprocessing, designed to be part of a transformation pipeline, e.g.,\n    T.Compose([LetterBox(size), ToTensor()]).\n\n    Attributes:\n        h (int): Target height of the image.\n        w (int): Target width of the image.\n        auto (bool): If True, automatically solves for short side using stride.\n        stride (int): The stride value, used when 'auto' is True.\n    \"\"\"\n\n    def __init__(self, size=(640, 640), auto=False, stride=32):\n        \"\"\"\n        Initializes the ClassifyLetterBox class with a target size, auto-flag, and stride.\n\n        Args:\n            size (Union[int, Tuple[int, int]]): The target dimensions (height, width) for the letterbox.\n            auto (bool): If True, automatically calculates the short side based on stride.\n            stride (int): The stride value, used when 'auto' is True.\n        \"\"\"\n        super().__init__()\n        self.h, self.w = (size, size) if isinstance(size, int) else size\n        self.auto = auto  # pass max size integer, automatically solve for short side using stride\n        self.stride = stride  # used with auto\n\n    def __call__(self, im):\n        \"\"\"\n        Resizes the image and pads it with a letterbox method.\n\n        Args:\n            im (numpy.ndarray): The input image as a numpy array of shape HWC.\n\n        Returns:\n            (numpy.ndarray): The letterboxed and resized image as a numpy array.\n        \"\"\"\n        imh, imw = im.shape[:2]\n        r = min(self.h / imh, self.w / imw)  # ratio of new/old dimensions\n        h, w = round(imh * r), round(imw * r)  # resized image dimensions\n\n        # Calculate padding dimensions\n        hs, ws = (math.ceil(x / self.stride) * self.stride for x in (h, w)) if self.auto else (self.h, self.w)\n        top, left = round((hs - h) / 2 - 0.1), round((ws - w) / 2 - 0.1)\n\n        # Create padded image\n        im_out = np.full((hs, ws, 3), 114, dtype=im.dtype)\n        im_out[top : top + h, left : left + w] = cv2.resize(im, (w, h), interpolation=cv2.INTER_LINEAR)\n        return im_out\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.ClassifyLetterBox.__call__","title":"<code>__call__(im)</code>","text":"<p>Resizes the image and pads it with a letterbox method.</p> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>ndarray</code> <p>The input image as a numpy array of shape HWC.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The letterboxed and resized image as a numpy array.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __call__(self, im):\n    \"\"\"\n    Resizes the image and pads it with a letterbox method.\n\n    Args:\n        im (numpy.ndarray): The input image as a numpy array of shape HWC.\n\n    Returns:\n        (numpy.ndarray): The letterboxed and resized image as a numpy array.\n    \"\"\"\n    imh, imw = im.shape[:2]\n    r = min(self.h / imh, self.w / imw)  # ratio of new/old dimensions\n    h, w = round(imh * r), round(imw * r)  # resized image dimensions\n\n    # Calculate padding dimensions\n    hs, ws = (math.ceil(x / self.stride) * self.stride for x in (h, w)) if self.auto else (self.h, self.w)\n    top, left = round((hs - h) / 2 - 0.1), round((ws - w) / 2 - 0.1)\n\n    # Create padded image\n    im_out = np.full((hs, ws, 3), 114, dtype=im.dtype)\n    im_out[top : top + h, left : left + w] = cv2.resize(im, (w, h), interpolation=cv2.INTER_LINEAR)\n    return im_out\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.ClassifyLetterBox.__init__","title":"<code>__init__(size=(640, 640), auto=False, stride=32)</code>","text":"<p>Initializes the ClassifyLetterBox class with a target size, auto-flag, and stride.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>Union[int, Tuple[int, int]]</code> <p>The target dimensions (height, width) for the letterbox.</p> <code>(640, 640)</code> <code>auto</code> <code>bool</code> <p>If True, automatically calculates the short side based on stride.</p> <code>False</code> <code>stride</code> <code>int</code> <p>The stride value, used when 'auto' is True.</p> <code>32</code> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __init__(self, size=(640, 640), auto=False, stride=32):\n    \"\"\"\n    Initializes the ClassifyLetterBox class with a target size, auto-flag, and stride.\n\n    Args:\n        size (Union[int, Tuple[int, int]]): The target dimensions (height, width) for the letterbox.\n        auto (bool): If True, automatically calculates the short side based on stride.\n        stride (int): The stride value, used when 'auto' is True.\n    \"\"\"\n    super().__init__()\n    self.h, self.w = (size, size) if isinstance(size, int) else size\n    self.auto = auto  # pass max size integer, automatically solve for short side using stride\n    self.stride = stride  # used with auto\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.CenterCrop","title":"<code>ultralytics.data.augment.CenterCrop</code>","text":"<p>YOLOv8 CenterCrop class for image preprocessing, designed to be part of a transformation pipeline, e.g., T.Compose([CenterCrop(size), ToTensor()]).</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>class CenterCrop:\n    \"\"\"YOLOv8 CenterCrop class for image preprocessing, designed to be part of a transformation pipeline, e.g.,\n    T.Compose([CenterCrop(size), ToTensor()]).\n    \"\"\"\n\n    def __init__(self, size=640):\n        \"\"\"Converts an image from numpy array to PyTorch tensor.\"\"\"\n        super().__init__()\n        self.h, self.w = (size, size) if isinstance(size, int) else size\n\n    def __call__(self, im):\n        \"\"\"\n        Resizes and crops the center of the image using a letterbox method.\n\n        Args:\n            im (numpy.ndarray): The input image as a numpy array of shape HWC.\n\n        Returns:\n            (numpy.ndarray): The center-cropped and resized image as a numpy array.\n        \"\"\"\n        imh, imw = im.shape[:2]\n        m = min(imh, imw)  # min dimension\n        top, left = (imh - m) // 2, (imw - m) // 2\n        return cv2.resize(im[top : top + m, left : left + m], (self.w, self.h), interpolation=cv2.INTER_LINEAR)\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.CenterCrop.__call__","title":"<code>__call__(im)</code>","text":"<p>Resizes and crops the center of the image using a letterbox method.</p> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>ndarray</code> <p>The input image as a numpy array of shape HWC.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The center-cropped and resized image as a numpy array.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __call__(self, im):\n    \"\"\"\n    Resizes and crops the center of the image using a letterbox method.\n\n    Args:\n        im (numpy.ndarray): The input image as a numpy array of shape HWC.\n\n    Returns:\n        (numpy.ndarray): The center-cropped and resized image as a numpy array.\n    \"\"\"\n    imh, imw = im.shape[:2]\n    m = min(imh, imw)  # min dimension\n    top, left = (imh - m) // 2, (imw - m) // 2\n    return cv2.resize(im[top : top + m, left : left + m], (self.w, self.h), interpolation=cv2.INTER_LINEAR)\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.CenterCrop.__init__","title":"<code>__init__(size=640)</code>","text":"<p>Converts an image from numpy array to PyTorch tensor.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __init__(self, size=640):\n    \"\"\"Converts an image from numpy array to PyTorch tensor.\"\"\"\n    super().__init__()\n    self.h, self.w = (size, size) if isinstance(size, int) else size\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.ToTensor","title":"<code>ultralytics.data.augment.ToTensor</code>","text":"<p>YOLOv8 ToTensor class for image preprocessing, i.e., T.Compose([LetterBox(size), ToTensor()]).</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>class ToTensor:\n    \"\"\"YOLOv8 ToTensor class for image preprocessing, i.e., T.Compose([LetterBox(size), ToTensor()]).\"\"\"\n\n    def __init__(self, half=False):\n        \"\"\"Initialize YOLOv8 ToTensor object with optional half-precision support.\"\"\"\n        super().__init__()\n        self.half = half\n\n    def __call__(self, im):\n        \"\"\"\n        Transforms an image from a numpy array to a PyTorch tensor, applying optional half-precision and normalization.\n\n        Args:\n            im (numpy.ndarray): Input image as a numpy array with shape (H, W, C) in BGR order.\n\n        Returns:\n            (torch.Tensor): The transformed image as a PyTorch tensor in float32 or float16, normalized to [0, 1].\n        \"\"\"\n        im = np.ascontiguousarray(im.transpose((2, 0, 1))[::-1])  # HWC to CHW -&gt; BGR to RGB -&gt; contiguous\n        im = torch.from_numpy(im)  # to torch\n        im = im.half() if self.half else im.float()  # uint8 to fp16/32\n        im /= 255.0  # 0-255 to 0.0-1.0\n        return im\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.ToTensor.__call__","title":"<code>__call__(im)</code>","text":"<p>Transforms an image from a numpy array to a PyTorch tensor, applying optional half-precision and normalization.</p> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>ndarray</code> <p>Input image as a numpy array with shape (H, W, C) in BGR order.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The transformed image as a PyTorch tensor in float32 or float16, normalized to [0, 1].</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __call__(self, im):\n    \"\"\"\n    Transforms an image from a numpy array to a PyTorch tensor, applying optional half-precision and normalization.\n\n    Args:\n        im (numpy.ndarray): Input image as a numpy array with shape (H, W, C) in BGR order.\n\n    Returns:\n        (torch.Tensor): The transformed image as a PyTorch tensor in float32 or float16, normalized to [0, 1].\n    \"\"\"\n    im = np.ascontiguousarray(im.transpose((2, 0, 1))[::-1])  # HWC to CHW -&gt; BGR to RGB -&gt; contiguous\n    im = torch.from_numpy(im)  # to torch\n    im = im.half() if self.half else im.float()  # uint8 to fp16/32\n    im /= 255.0  # 0-255 to 0.0-1.0\n    return im\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.ToTensor.__init__","title":"<code>__init__(half=False)</code>","text":"<p>Initialize YOLOv8 ToTensor object with optional half-precision support.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def __init__(self, half=False):\n    \"\"\"Initialize YOLOv8 ToTensor object with optional half-precision support.\"\"\"\n    super().__init__()\n    self.half = half\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.v8_transforms","title":"<code>ultralytics.data.augment.v8_transforms(dataset, imgsz, hyp, stretch=False)</code>","text":"<p>Convert images to a size suitable for YOLOv8 training.</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def v8_transforms(dataset, imgsz, hyp, stretch=False):\n    \"\"\"Convert images to a size suitable for YOLOv8 training.\"\"\"\n    pre_transform = Compose(\n        [\n            Mosaic(dataset, imgsz=imgsz, p=hyp.mosaic),\n            CopyPaste(p=hyp.copy_paste),\n            RandomPerspective(\n                degrees=hyp.degrees,\n                translate=hyp.translate,\n                scale=hyp.scale,\n                shear=hyp.shear,\n                perspective=hyp.perspective,\n                pre_transform=None if stretch else LetterBox(new_shape=(imgsz, imgsz)),\n            ),\n        ]\n    )\n    flip_idx = dataset.data.get(\"flip_idx\", [])  # for keypoints augmentation\n    if dataset.use_keypoints:\n        kpt_shape = dataset.data.get(\"kpt_shape\", None)\n        if len(flip_idx) == 0 and hyp.fliplr &gt; 0.0:\n            hyp.fliplr = 0.0\n            LOGGER.warning(\"WARNING \u26a0\ufe0f No 'flip_idx' array defined in data.yaml, setting augmentation 'fliplr=0.0'\")\n        elif flip_idx and (len(flip_idx) != kpt_shape[0]):\n            raise ValueError(f\"data.yaml flip_idx={flip_idx} length must be equal to kpt_shape[0]={kpt_shape[0]}\")\n\n    return Compose(\n        [\n            pre_transform,\n            MixUp(dataset, pre_transform=pre_transform, p=hyp.mixup),\n            Albumentations(p=1.0),\n            RandomHSV(hgain=hyp.hsv_h, sgain=hyp.hsv_s, vgain=hyp.hsv_v),\n            RandomFlip(direction=\"vertical\", p=hyp.flipud),\n            RandomFlip(direction=\"horizontal\", p=hyp.fliplr, flip_idx=flip_idx),\n        ]\n    )  # transforms\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.classify_transforms","title":"<code>ultralytics.data.augment.classify_transforms(size=224, mean=DEFAULT_MEAN, std=DEFAULT_STD, interpolation=T.InterpolationMode.BILINEAR, crop_fraction=DEFAULT_CROP_FTACTION)</code>","text":"<p>Classification transforms for evaluation/inference. Inspired by timm/data/transforms_factory.py.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>image size</p> <code>224</code> <code>mean</code> <code>tuple</code> <p>mean values of RGB channels</p> <code>DEFAULT_MEAN</code> <code>std</code> <code>tuple</code> <p>std values of RGB channels</p> <code>DEFAULT_STD</code> <code>interpolation</code> <code>InterpolationMode</code> <p>interpolation mode. default is T.InterpolationMode.BILINEAR.</p> <code>BILINEAR</code> <code>crop_fraction</code> <code>float</code> <p>fraction of image to crop. default is 1.0.</p> <code>DEFAULT_CROP_FTACTION</code> <p>Returns:</p> Type Description <code>Compose</code> <p>torchvision transforms</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def classify_transforms(\n    size=224,\n    mean=DEFAULT_MEAN,\n    std=DEFAULT_STD,\n    interpolation: T.InterpolationMode = T.InterpolationMode.BILINEAR,\n    crop_fraction: float = DEFAULT_CROP_FTACTION,\n):\n    \"\"\"\n    Classification transforms for evaluation/inference. Inspired by timm/data/transforms_factory.py.\n\n    Args:\n        size (int): image size\n        mean (tuple): mean values of RGB channels\n        std (tuple): std values of RGB channels\n        interpolation (T.InterpolationMode): interpolation mode. default is T.InterpolationMode.BILINEAR.\n        crop_fraction (float): fraction of image to crop. default is 1.0.\n\n    Returns:\n        (T.Compose): torchvision transforms\n    \"\"\"\n\n    if isinstance(size, (tuple, list)):\n        assert len(size) == 2\n        scale_size = tuple([math.floor(x / crop_fraction) for x in size])\n    else:\n        scale_size = math.floor(size / crop_fraction)\n        scale_size = (scale_size, scale_size)\n\n    # aspect ratio is preserved, crops center within image, no borders are added, image is lost\n    if scale_size[0] == scale_size[1]:\n        # simple case, use torchvision built-in Resize w/ shortest edge mode (scalar size arg)\n        tfl = [T.Resize(scale_size[0], interpolation=interpolation)]\n    else:\n        # resize shortest edge to matching target dim for non-square target\n        tfl = [T.Resize(scale_size)]\n    tfl += [T.CenterCrop(size)]\n\n    tfl += [\n        T.ToTensor(),\n        T.Normalize(\n            mean=torch.tensor(mean),\n            std=torch.tensor(std),\n        ),\n    ]\n\n    return T.Compose(tfl)\n</code></pre>"},{"location":"reference/data/augment/#ultralytics.data.augment.classify_augmentations","title":"<code>ultralytics.data.augment.classify_augmentations(size=224, mean=DEFAULT_MEAN, std=DEFAULT_STD, scale=None, ratio=None, hflip=0.5, vflip=0.0, auto_augment=None, hsv_h=0.015, hsv_s=0.4, hsv_v=0.4, force_color_jitter=False, erasing=0.0, interpolation=T.InterpolationMode.BILINEAR)</code>","text":"<p>Classification transforms with augmentation for training. Inspired by timm/data/transforms_factory.py.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>image size</p> <code>224</code> <code>scale</code> <code>tuple</code> <p>scale range of the image. default is (0.08, 1.0)</p> <code>None</code> <code>ratio</code> <code>tuple</code> <p>aspect ratio range of the image. default is (3./4., 4./3.)</p> <code>None</code> <code>mean</code> <code>tuple</code> <p>mean values of RGB channels</p> <code>DEFAULT_MEAN</code> <code>std</code> <code>tuple</code> <p>std values of RGB channels</p> <code>DEFAULT_STD</code> <code>hflip</code> <code>float</code> <p>probability of horizontal flip</p> <code>0.5</code> <code>vflip</code> <code>float</code> <p>probability of vertical flip</p> <code>0.0</code> <code>auto_augment</code> <code>str</code> <p>auto augmentation policy. can be 'randaugment', 'augmix', 'autoaugment' or None.</p> <code>None</code> <code>hsv_h</code> <code>float</code> <p>image HSV-Hue augmentation (fraction)</p> <code>0.015</code> <code>hsv_s</code> <code>float</code> <p>image HSV-Saturation augmentation (fraction)</p> <code>0.4</code> <code>hsv_v</code> <code>float</code> <p>image HSV-Value augmentation (fraction)</p> <code>0.4</code> <code>force_color_jitter</code> <code>bool</code> <p>force to apply color jitter even if auto augment is enabled</p> <code>False</code> <code>erasing</code> <code>float</code> <p>probability of random erasing</p> <code>0.0</code> <code>interpolation</code> <code>InterpolationMode</code> <p>interpolation mode. default is T.InterpolationMode.BILINEAR.</p> <code>BILINEAR</code> <p>Returns:</p> Type Description <code>Compose</code> <p>torchvision transforms</p> Source code in <code>ultralytics/data/augment.py</code> <pre><code>def classify_augmentations(\n    size=224,\n    mean=DEFAULT_MEAN,\n    std=DEFAULT_STD,\n    scale=None,\n    ratio=None,\n    hflip=0.5,\n    vflip=0.0,\n    auto_augment=None,\n    hsv_h=0.015,  # image HSV-Hue augmentation (fraction)\n    hsv_s=0.4,  # image HSV-Saturation augmentation (fraction)\n    hsv_v=0.4,  # image HSV-Value augmentation (fraction)\n    force_color_jitter=False,\n    erasing=0.0,\n    interpolation: T.InterpolationMode = T.InterpolationMode.BILINEAR,\n):\n    \"\"\"\n    Classification transforms with augmentation for training. Inspired by timm/data/transforms_factory.py.\n\n    Args:\n        size (int): image size\n        scale (tuple): scale range of the image. default is (0.08, 1.0)\n        ratio (tuple): aspect ratio range of the image. default is (3./4., 4./3.)\n        mean (tuple): mean values of RGB channels\n        std (tuple): std values of RGB channels\n        hflip (float): probability of horizontal flip\n        vflip (float): probability of vertical flip\n        auto_augment (str): auto augmentation policy. can be 'randaugment', 'augmix', 'autoaugment' or None.\n        hsv_h (float): image HSV-Hue augmentation (fraction)\n        hsv_s (float): image HSV-Saturation augmentation (fraction)\n        hsv_v (float): image HSV-Value augmentation (fraction)\n        force_color_jitter (bool): force to apply color jitter even if auto augment is enabled\n        erasing (float): probability of random erasing\n        interpolation (T.InterpolationMode): interpolation mode. default is T.InterpolationMode.BILINEAR.\n\n    Returns:\n        (T.Compose): torchvision transforms\n    \"\"\"\n    # Transforms to apply if albumentations not installed\n    if not isinstance(size, int):\n        raise TypeError(f\"classify_transforms() size {size} must be integer, not (list, tuple)\")\n    scale = tuple(scale or (0.08, 1.0))  # default imagenet scale range\n    ratio = tuple(ratio or (3.0 / 4.0, 4.0 / 3.0))  # default imagenet ratio range\n    primary_tfl = [T.RandomResizedCrop(size, scale=scale, ratio=ratio, interpolation=interpolation)]\n    if hflip &gt; 0.0:\n        primary_tfl += [T.RandomHorizontalFlip(p=hflip)]\n    if vflip &gt; 0.0:\n        primary_tfl += [T.RandomVerticalFlip(p=vflip)]\n\n    secondary_tfl = []\n    disable_color_jitter = False\n    if auto_augment:\n        assert isinstance(auto_augment, str)\n        # color jitter is typically disabled if AA/RA on,\n        # this allows override without breaking old hparm cfgs\n        disable_color_jitter = not force_color_jitter\n\n        if auto_augment == \"randaugment\":\n            if TORCHVISION_0_11:\n                secondary_tfl += [T.RandAugment(interpolation=interpolation)]\n            else:\n                LOGGER.warning('\"auto_augment=randaugment\" requires torchvision &gt;= 0.11.0. Disabling it.')\n\n        elif auto_augment == \"augmix\":\n            if TORCHVISION_0_13:\n                secondary_tfl += [T.AugMix(interpolation=interpolation)]\n            else:\n                LOGGER.warning('\"auto_augment=augmix\" requires torchvision &gt;= 0.13.0. Disabling it.')\n\n        elif auto_augment == \"autoaugment\":\n            if TORCHVISION_0_10:\n                secondary_tfl += [T.AutoAugment(interpolation=interpolation)]\n            else:\n                LOGGER.warning('\"auto_augment=autoaugment\" requires torchvision &gt;= 0.10.0. Disabling it.')\n\n        else:\n            raise ValueError(\n                f'Invalid auto_augment policy: {auto_augment}. Should be one of \"randaugment\", '\n                f'\"augmix\", \"autoaugment\" or None'\n            )\n\n    if not disable_color_jitter:\n        secondary_tfl += [T.ColorJitter(brightness=hsv_v, contrast=hsv_v, saturation=hsv_s, hue=hsv_h)]\n\n    final_tfl = [\n        T.ToTensor(),\n        T.Normalize(mean=torch.tensor(mean), std=torch.tensor(std)),\n        T.RandomErasing(p=erasing, inplace=True),\n    ]\n\n    return T.Compose(primary_tfl + secondary_tfl + final_tfl)\n</code></pre>"},{"location":"reference/data/base/","title":"Reference for <code>ultralytics/data/base.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/base.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/data/base/#ultralytics.data.base.BaseDataset","title":"<code>ultralytics.data.base.BaseDataset</code>","text":"<p>             Bases: <code>Dataset</code></p> <p>Base dataset class for loading and processing image data.</p> <p>Parameters:</p> Name Type Description Default <code>img_path</code> <code>str</code> <p>Path to the folder containing images.</p> required <code>imgsz</code> <code>int</code> <p>Image size. Defaults to 640.</p> <code>640</code> <code>cache</code> <code>bool</code> <p>Cache images to RAM or disk during training. Defaults to False.</p> <code>False</code> <code>augment</code> <code>bool</code> <p>If True, data augmentation is applied. Defaults to True.</p> <code>True</code> <code>hyp</code> <code>dict</code> <p>Hyperparameters to apply data augmentation. Defaults to None.</p> <code>DEFAULT_CFG</code> <code>prefix</code> <code>str</code> <p>Prefix to print in log messages. Defaults to ''.</p> <code>''</code> <code>rect</code> <code>bool</code> <p>If True, rectangular training is used. Defaults to False.</p> <code>False</code> <code>batch_size</code> <code>int</code> <p>Size of batches. Defaults to None.</p> <code>16</code> <code>stride</code> <code>int</code> <p>Stride. Defaults to 32.</p> <code>32</code> <code>pad</code> <code>float</code> <p>Padding. Defaults to 0.0.</p> <code>0.5</code> <code>single_cls</code> <code>bool</code> <p>If True, single class training is used. Defaults to False.</p> <code>False</code> <code>classes</code> <code>list</code> <p>List of included classes. Default is None.</p> <code>None</code> <code>fraction</code> <code>float</code> <p>Fraction of dataset to utilize. Default is 1.0 (use all data).</p> <code>1.0</code> <p>Attributes:</p> Name Type Description <code>im_files</code> <code>list</code> <p>List of image file paths.</p> <code>labels</code> <code>list</code> <p>List of label data dictionaries.</p> <code>ni</code> <code>int</code> <p>Number of images in the dataset.</p> <code>ims</code> <code>list</code> <p>List of loaded images.</p> <code>npy_files</code> <code>list</code> <p>List of numpy file paths.</p> <code>transforms</code> <code>callable</code> <p>Image transformation function.</p> Source code in <code>ultralytics/data/base.py</code> <pre><code>class BaseDataset(Dataset):\n    \"\"\"\n    Base dataset class for loading and processing image data.\n\n    Args:\n        img_path (str): Path to the folder containing images.\n        imgsz (int, optional): Image size. Defaults to 640.\n        cache (bool, optional): Cache images to RAM or disk during training. Defaults to False.\n        augment (bool, optional): If True, data augmentation is applied. Defaults to True.\n        hyp (dict, optional): Hyperparameters to apply data augmentation. Defaults to None.\n        prefix (str, optional): Prefix to print in log messages. Defaults to ''.\n        rect (bool, optional): If True, rectangular training is used. Defaults to False.\n        batch_size (int, optional): Size of batches. Defaults to None.\n        stride (int, optional): Stride. Defaults to 32.\n        pad (float, optional): Padding. Defaults to 0.0.\n        single_cls (bool, optional): If True, single class training is used. Defaults to False.\n        classes (list): List of included classes. Default is None.\n        fraction (float): Fraction of dataset to utilize. Default is 1.0 (use all data).\n\n    Attributes:\n        im_files (list): List of image file paths.\n        labels (list): List of label data dictionaries.\n        ni (int): Number of images in the dataset.\n        ims (list): List of loaded images.\n        npy_files (list): List of numpy file paths.\n        transforms (callable): Image transformation function.\n    \"\"\"\n\n    def __init__(\n        self,\n        img_path,\n        imgsz=640,\n        cache=False,\n        augment=True,\n        hyp=DEFAULT_CFG,\n        prefix=\"\",\n        rect=False,\n        batch_size=16,\n        stride=32,\n        pad=0.5,\n        single_cls=False,\n        classes=None,\n        fraction=1.0,\n    ):\n        \"\"\"Initialize BaseDataset with given configuration and options.\"\"\"\n        super().__init__()\n        self.img_path = img_path\n        self.imgsz = imgsz\n        self.augment = augment\n        self.single_cls = single_cls\n        self.prefix = prefix\n        self.fraction = fraction\n        self.im_files = self.get_img_files(self.img_path)\n        self.labels = self.get_labels()\n        self.update_labels(include_class=classes)  # single_cls and include_class\n        self.ni = len(self.labels)  # number of images\n        self.rect = rect\n        self.batch_size = batch_size\n        self.stride = stride\n        self.pad = pad\n        if self.rect:\n            assert self.batch_size is not None\n            self.set_rectangle()\n\n        # Buffer thread for mosaic images\n        self.buffer = []  # buffer size = batch size\n        self.max_buffer_length = min((self.ni, self.batch_size * 8, 1000)) if self.augment else 0\n\n        # Cache images\n        if cache == \"ram\" and not self.check_cache_ram():\n            cache = False\n        self.ims, self.im_hw0, self.im_hw = [None] * self.ni, [None] * self.ni, [None] * self.ni\n        self.npy_files = [Path(f).with_suffix(\".npy\") for f in self.im_files]\n        if cache:\n            self.cache_images(cache)\n\n        # Transforms\n        self.transforms = self.build_transforms(hyp=hyp)\n\n    def get_img_files(self, img_path):\n        \"\"\"Read image files.\"\"\"\n        try:\n            f = []  # image files\n            for p in img_path if isinstance(img_path, list) else [img_path]:\n                p = Path(p)  # os-agnostic\n                if p.is_dir():  # dir\n                    f += glob.glob(str(p / \"**\" / \"*.*\"), recursive=True)\n                    # F = list(p.rglob('*.*'))  # pathlib\n                elif p.is_file():  # file\n                    with open(p) as t:\n                        t = t.read().strip().splitlines()\n                        parent = str(p.parent) + os.sep\n                        f += [x.replace(\"./\", parent) if x.startswith(\"./\") else x for x in t]  # local to global path\n                        # F += [p.parent / x.lstrip(os.sep) for x in t]  # local to global path (pathlib)\n                else:\n                    raise FileNotFoundError(f\"{self.prefix}{p} does not exist\")\n            im_files = sorted(x.replace(\"/\", os.sep) for x in f if x.split(\".\")[-1].lower() in IMG_FORMATS)\n            # self.img_files = sorted([x for x in f if x.suffix[1:].lower() in IMG_FORMATS])  # pathlib\n            assert im_files, f\"{self.prefix}No images found in {img_path}\"\n        except Exception as e:\n            raise FileNotFoundError(f\"{self.prefix}Error loading data from {img_path}\\n{HELP_URL}\") from e\n        if self.fraction &lt; 1:\n            im_files = im_files[: round(len(im_files) * self.fraction)]\n        return im_files\n\n    def update_labels(self, include_class: Optional[list]):\n        \"\"\"Update labels to include only these classes (optional).\"\"\"\n        include_class_array = np.array(include_class).reshape(1, -1)\n        for i in range(len(self.labels)):\n            if include_class is not None:\n                cls = self.labels[i][\"cls\"]\n                bboxes = self.labels[i][\"bboxes\"]\n                segments = self.labels[i][\"segments\"]\n                keypoints = self.labels[i][\"keypoints\"]\n                j = (cls == include_class_array).any(1)\n                self.labels[i][\"cls\"] = cls[j]\n                self.labels[i][\"bboxes\"] = bboxes[j]\n                if segments:\n                    self.labels[i][\"segments\"] = [segments[si] for si, idx in enumerate(j) if idx]\n                if keypoints is not None:\n                    self.labels[i][\"keypoints\"] = keypoints[j]\n            if self.single_cls:\n                self.labels[i][\"cls\"][:, 0] = 0\n\n    def load_image(self, i, rect_mode=True):\n        \"\"\"Loads 1 image from dataset index 'i', returns (im, resized hw).\"\"\"\n        im, f, fn = self.ims[i], self.im_files[i], self.npy_files[i]\n        if im is None:  # not cached in RAM\n            if fn.exists():  # load npy\n                try:\n                    im = np.load(fn)\n                except Exception as e:\n                    LOGGER.warning(f\"{self.prefix}WARNING \u26a0\ufe0f Removing corrupt *.npy image file {fn} due to: {e}\")\n                    Path(fn).unlink(missing_ok=True)\n                    im = cv2.imread(f)  # BGR\n            else:  # read image\n                im = cv2.imread(f)  # BGR\n            if im is None:\n                raise FileNotFoundError(f\"Image Not Found {f}\")\n\n            h0, w0 = im.shape[:2]  # orig hw\n            if rect_mode:  # resize long side to imgsz while maintaining aspect ratio\n                r = self.imgsz / max(h0, w0)  # ratio\n                if r != 1:  # if sizes are not equal\n                    w, h = (min(math.ceil(w0 * r), self.imgsz), min(math.ceil(h0 * r), self.imgsz))\n                    im = cv2.resize(im, (w, h), interpolation=cv2.INTER_LINEAR)\n            elif not (h0 == w0 == self.imgsz):  # resize by stretching image to square imgsz\n                im = cv2.resize(im, (self.imgsz, self.imgsz), interpolation=cv2.INTER_LINEAR)\n\n            # Add to buffer if training with augmentations\n            if self.augment:\n                self.ims[i], self.im_hw0[i], self.im_hw[i] = im, (h0, w0), im.shape[:2]  # im, hw_original, hw_resized\n                self.buffer.append(i)\n                if len(self.buffer) &gt;= self.max_buffer_length:\n                    j = self.buffer.pop(0)\n                    self.ims[j], self.im_hw0[j], self.im_hw[j] = None, None, None\n\n            return im, (h0, w0), im.shape[:2]\n\n        return self.ims[i], self.im_hw0[i], self.im_hw[i]\n\n    def cache_images(self, cache):\n        \"\"\"Cache images to memory or disk.\"\"\"\n        b, gb = 0, 1 &lt;&lt; 30  # bytes of cached images, bytes per gigabytes\n        fcn = self.cache_images_to_disk if cache == \"disk\" else self.load_image\n        with ThreadPool(NUM_THREADS) as pool:\n            results = pool.imap(fcn, range(self.ni))\n            pbar = TQDM(enumerate(results), total=self.ni, disable=LOCAL_RANK &gt; 0)\n            for i, x in pbar:\n                if cache == \"disk\":\n                    b += self.npy_files[i].stat().st_size\n                else:  # 'ram'\n                    self.ims[i], self.im_hw0[i], self.im_hw[i] = x  # im, hw_orig, hw_resized = load_image(self, i)\n                    b += self.ims[i].nbytes\n                pbar.desc = f\"{self.prefix}Caching images ({b / gb:.1f}GB {cache})\"\n            pbar.close()\n\n    def cache_images_to_disk(self, i):\n        \"\"\"Saves an image as an *.npy file for faster loading.\"\"\"\n        f = self.npy_files[i]\n        if not f.exists():\n            np.save(f.as_posix(), cv2.imread(self.im_files[i]), allow_pickle=False)\n\n    def check_cache_ram(self, safety_margin=0.5):\n        \"\"\"Check image caching requirements vs available memory.\"\"\"\n        b, gb = 0, 1 &lt;&lt; 30  # bytes of cached images, bytes per gigabytes\n        n = min(self.ni, 30)  # extrapolate from 30 random images\n        for _ in range(n):\n            im = cv2.imread(random.choice(self.im_files))  # sample image\n            ratio = self.imgsz / max(im.shape[0], im.shape[1])  # max(h, w)  # ratio\n            b += im.nbytes * ratio**2\n        mem_required = b * self.ni / n * (1 + safety_margin)  # GB required to cache dataset into RAM\n        mem = psutil.virtual_memory()\n        cache = mem_required &lt; mem.available  # to cache or not to cache, that is the question\n        if not cache:\n            LOGGER.info(\n                f'{self.prefix}{mem_required / gb:.1f}GB RAM required to cache images '\n                f'with {int(safety_margin * 100)}% safety margin but only '\n                f'{mem.available / gb:.1f}/{mem.total / gb:.1f}GB available, '\n                f\"{'caching images \u2705' if cache else 'not caching images \u26a0\ufe0f'}\"\n            )\n        return cache\n\n    def set_rectangle(self):\n        \"\"\"Sets the shape of bounding boxes for YOLO detections as rectangles.\"\"\"\n        bi = np.floor(np.arange(self.ni) / self.batch_size).astype(int)  # batch index\n        nb = bi[-1] + 1  # number of batches\n\n        s = np.array([x.pop(\"shape\") for x in self.labels])  # hw\n        ar = s[:, 0] / s[:, 1]  # aspect ratio\n        irect = ar.argsort()\n        self.im_files = [self.im_files[i] for i in irect]\n        self.labels = [self.labels[i] for i in irect]\n        ar = ar[irect]\n\n        # Set training image shapes\n        shapes = [[1, 1]] * nb\n        for i in range(nb):\n            ari = ar[bi == i]\n            mini, maxi = ari.min(), ari.max()\n            if maxi &lt; 1:\n                shapes[i] = [maxi, 1]\n            elif mini &gt; 1:\n                shapes[i] = [1, 1 / mini]\n\n        self.batch_shapes = np.ceil(np.array(shapes) * self.imgsz / self.stride + self.pad).astype(int) * self.stride\n        self.batch = bi  # batch index of image\n\n    def __getitem__(self, index):\n        \"\"\"Returns transformed label information for given index.\"\"\"\n        return self.transforms(self.get_image_and_label(index))\n\n    def get_image_and_label(self, index):\n        \"\"\"Get and return label information from the dataset.\"\"\"\n        label = deepcopy(self.labels[index])  # requires deepcopy() https://github.com/ultralytics/ultralytics/pull/1948\n        label.pop(\"shape\", None)  # shape is for rect, remove it\n        label[\"img\"], label[\"ori_shape\"], label[\"resized_shape\"] = self.load_image(index)\n        label[\"ratio_pad\"] = (\n            label[\"resized_shape\"][0] / label[\"ori_shape\"][0],\n            label[\"resized_shape\"][1] / label[\"ori_shape\"][1],\n        )  # for evaluation\n        if self.rect:\n            label[\"rect_shape\"] = self.batch_shapes[self.batch[index]]\n        return self.update_labels_info(label)\n\n    def __len__(self):\n        \"\"\"Returns the length of the labels list for the dataset.\"\"\"\n        return len(self.labels)\n\n    def update_labels_info(self, label):\n        \"\"\"Custom your label format here.\"\"\"\n        return label\n\n    def build_transforms(self, hyp=None):\n        \"\"\"\n        Users can customize augmentations here.\n\n        Example:\n            ```python\n            if self.augment:\n                # Training transforms\n                return Compose([])\n            else:\n                # Val transforms\n                return Compose([])\n            ```\n        \"\"\"\n        raise NotImplementedError\n\n    def get_labels(self):\n        \"\"\"\n        Users can customize their own format here.\n\n        Note:\n            Ensure output is a dictionary with the following keys:\n            ```python\n            dict(\n                im_file=im_file,\n                shape=shape,  # format: (height, width)\n                cls=cls,\n                bboxes=bboxes, # xywh\n                segments=segments,  # xy\n                keypoints=keypoints, # xy\n                normalized=True, # or False\n                bbox_format=\"xyxy\",  # or xywh, ltwh\n            )\n            ```\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/data/base/#ultralytics.data.base.BaseDataset.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Returns transformed label information for given index.</p> Source code in <code>ultralytics/data/base.py</code> <pre><code>def __getitem__(self, index):\n    \"\"\"Returns transformed label information for given index.\"\"\"\n    return self.transforms(self.get_image_and_label(index))\n</code></pre>"},{"location":"reference/data/base/#ultralytics.data.base.BaseDataset.__init__","title":"<code>__init__(img_path, imgsz=640, cache=False, augment=True, hyp=DEFAULT_CFG, prefix='', rect=False, batch_size=16, stride=32, pad=0.5, single_cls=False, classes=None, fraction=1.0)</code>","text":"<p>Initialize BaseDataset with given configuration and options.</p> Source code in <code>ultralytics/data/base.py</code> <pre><code>def __init__(\n    self,\n    img_path,\n    imgsz=640,\n    cache=False,\n    augment=True,\n    hyp=DEFAULT_CFG,\n    prefix=\"\",\n    rect=False,\n    batch_size=16,\n    stride=32,\n    pad=0.5,\n    single_cls=False,\n    classes=None,\n    fraction=1.0,\n):\n    \"\"\"Initialize BaseDataset with given configuration and options.\"\"\"\n    super().__init__()\n    self.img_path = img_path\n    self.imgsz = imgsz\n    self.augment = augment\n    self.single_cls = single_cls\n    self.prefix = prefix\n    self.fraction = fraction\n    self.im_files = self.get_img_files(self.img_path)\n    self.labels = self.get_labels()\n    self.update_labels(include_class=classes)  # single_cls and include_class\n    self.ni = len(self.labels)  # number of images\n    self.rect = rect\n    self.batch_size = batch_size\n    self.stride = stride\n    self.pad = pad\n    if self.rect:\n        assert self.batch_size is not None\n        self.set_rectangle()\n\n    # Buffer thread for mosaic images\n    self.buffer = []  # buffer size = batch size\n    self.max_buffer_length = min((self.ni, self.batch_size * 8, 1000)) if self.augment else 0\n\n    # Cache images\n    if cache == \"ram\" and not self.check_cache_ram():\n        cache = False\n    self.ims, self.im_hw0, self.im_hw = [None] * self.ni, [None] * self.ni, [None] * self.ni\n    self.npy_files = [Path(f).with_suffix(\".npy\") for f in self.im_files]\n    if cache:\n        self.cache_images(cache)\n\n    # Transforms\n    self.transforms = self.build_transforms(hyp=hyp)\n</code></pre>"},{"location":"reference/data/base/#ultralytics.data.base.BaseDataset.__len__","title":"<code>__len__()</code>","text":"<p>Returns the length of the labels list for the dataset.</p> Source code in <code>ultralytics/data/base.py</code> <pre><code>def __len__(self):\n    \"\"\"Returns the length of the labels list for the dataset.\"\"\"\n    return len(self.labels)\n</code></pre>"},{"location":"reference/data/base/#ultralytics.data.base.BaseDataset.build_transforms","title":"<code>build_transforms(hyp=None)</code>","text":"<p>Users can customize augmentations here.</p> Example <pre><code>if self.augment:\n    # Training transforms\n    return Compose([])\nelse:\n    # Val transforms\n    return Compose([])\n</code></pre> Source code in <code>ultralytics/data/base.py</code> <pre><code>def build_transforms(self, hyp=None):\n    \"\"\"\n    Users can customize augmentations here.\n\n    Example:\n        ```python\n        if self.augment:\n            # Training transforms\n            return Compose([])\n        else:\n            # Val transforms\n            return Compose([])\n        ```\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/data/base/#ultralytics.data.base.BaseDataset.cache_images","title":"<code>cache_images(cache)</code>","text":"<p>Cache images to memory or disk.</p> Source code in <code>ultralytics/data/base.py</code> <pre><code>def cache_images(self, cache):\n    \"\"\"Cache images to memory or disk.\"\"\"\n    b, gb = 0, 1 &lt;&lt; 30  # bytes of cached images, bytes per gigabytes\n    fcn = self.cache_images_to_disk if cache == \"disk\" else self.load_image\n    with ThreadPool(NUM_THREADS) as pool:\n        results = pool.imap(fcn, range(self.ni))\n        pbar = TQDM(enumerate(results), total=self.ni, disable=LOCAL_RANK &gt; 0)\n        for i, x in pbar:\n            if cache == \"disk\":\n                b += self.npy_files[i].stat().st_size\n            else:  # 'ram'\n                self.ims[i], self.im_hw0[i], self.im_hw[i] = x  # im, hw_orig, hw_resized = load_image(self, i)\n                b += self.ims[i].nbytes\n            pbar.desc = f\"{self.prefix}Caching images ({b / gb:.1f}GB {cache})\"\n        pbar.close()\n</code></pre>"},{"location":"reference/data/base/#ultralytics.data.base.BaseDataset.cache_images_to_disk","title":"<code>cache_images_to_disk(i)</code>","text":"<p>Saves an image as an *.npy file for faster loading.</p> Source code in <code>ultralytics/data/base.py</code> <pre><code>def cache_images_to_disk(self, i):\n    \"\"\"Saves an image as an *.npy file for faster loading.\"\"\"\n    f = self.npy_files[i]\n    if not f.exists():\n        np.save(f.as_posix(), cv2.imread(self.im_files[i]), allow_pickle=False)\n</code></pre>"},{"location":"reference/data/base/#ultralytics.data.base.BaseDataset.check_cache_ram","title":"<code>check_cache_ram(safety_margin=0.5)</code>","text":"<p>Check image caching requirements vs available memory.</p> Source code in <code>ultralytics/data/base.py</code> <pre><code>def check_cache_ram(self, safety_margin=0.5):\n    \"\"\"Check image caching requirements vs available memory.\"\"\"\n    b, gb = 0, 1 &lt;&lt; 30  # bytes of cached images, bytes per gigabytes\n    n = min(self.ni, 30)  # extrapolate from 30 random images\n    for _ in range(n):\n        im = cv2.imread(random.choice(self.im_files))  # sample image\n        ratio = self.imgsz / max(im.shape[0], im.shape[1])  # max(h, w)  # ratio\n        b += im.nbytes * ratio**2\n    mem_required = b * self.ni / n * (1 + safety_margin)  # GB required to cache dataset into RAM\n    mem = psutil.virtual_memory()\n    cache = mem_required &lt; mem.available  # to cache or not to cache, that is the question\n    if not cache:\n        LOGGER.info(\n            f'{self.prefix}{mem_required / gb:.1f}GB RAM required to cache images '\n            f'with {int(safety_margin * 100)}% safety margin but only '\n            f'{mem.available / gb:.1f}/{mem.total / gb:.1f}GB available, '\n            f\"{'caching images \u2705' if cache else 'not caching images \u26a0\ufe0f'}\"\n        )\n    return cache\n</code></pre>"},{"location":"reference/data/base/#ultralytics.data.base.BaseDataset.get_image_and_label","title":"<code>get_image_and_label(index)</code>","text":"<p>Get and return label information from the dataset.</p> Source code in <code>ultralytics/data/base.py</code> <pre><code>def get_image_and_label(self, index):\n    \"\"\"Get and return label information from the dataset.\"\"\"\n    label = deepcopy(self.labels[index])  # requires deepcopy() https://github.com/ultralytics/ultralytics/pull/1948\n    label.pop(\"shape\", None)  # shape is for rect, remove it\n    label[\"img\"], label[\"ori_shape\"], label[\"resized_shape\"] = self.load_image(index)\n    label[\"ratio_pad\"] = (\n        label[\"resized_shape\"][0] / label[\"ori_shape\"][0],\n        label[\"resized_shape\"][1] / label[\"ori_shape\"][1],\n    )  # for evaluation\n    if self.rect:\n        label[\"rect_shape\"] = self.batch_shapes[self.batch[index]]\n    return self.update_labels_info(label)\n</code></pre>"},{"location":"reference/data/base/#ultralytics.data.base.BaseDataset.get_img_files","title":"<code>get_img_files(img_path)</code>","text":"<p>Read image files.</p> Source code in <code>ultralytics/data/base.py</code> <pre><code>def get_img_files(self, img_path):\n    \"\"\"Read image files.\"\"\"\n    try:\n        f = []  # image files\n        for p in img_path if isinstance(img_path, list) else [img_path]:\n            p = Path(p)  # os-agnostic\n            if p.is_dir():  # dir\n                f += glob.glob(str(p / \"**\" / \"*.*\"), recursive=True)\n                # F = list(p.rglob('*.*'))  # pathlib\n            elif p.is_file():  # file\n                with open(p) as t:\n                    t = t.read().strip().splitlines()\n                    parent = str(p.parent) + os.sep\n                    f += [x.replace(\"./\", parent) if x.startswith(\"./\") else x for x in t]  # local to global path\n                    # F += [p.parent / x.lstrip(os.sep) for x in t]  # local to global path (pathlib)\n            else:\n                raise FileNotFoundError(f\"{self.prefix}{p} does not exist\")\n        im_files = sorted(x.replace(\"/\", os.sep) for x in f if x.split(\".\")[-1].lower() in IMG_FORMATS)\n        # self.img_files = sorted([x for x in f if x.suffix[1:].lower() in IMG_FORMATS])  # pathlib\n        assert im_files, f\"{self.prefix}No images found in {img_path}\"\n    except Exception as e:\n        raise FileNotFoundError(f\"{self.prefix}Error loading data from {img_path}\\n{HELP_URL}\") from e\n    if self.fraction &lt; 1:\n        im_files = im_files[: round(len(im_files) * self.fraction)]\n    return im_files\n</code></pre>"},{"location":"reference/data/base/#ultralytics.data.base.BaseDataset.get_labels","title":"<code>get_labels()</code>","text":"<p>Users can customize their own format here.</p> Note <p>Ensure output is a dictionary with the following keys: <pre><code>dict(\n    im_file=im_file,\n    shape=shape,  # format: (height, width)\n    cls=cls,\n    bboxes=bboxes, # xywh\n    segments=segments,  # xy\n    keypoints=keypoints, # xy\n    normalized=True, # or False\n    bbox_format=\"xyxy\",  # or xywh, ltwh\n)\n</code></pre></p> Source code in <code>ultralytics/data/base.py</code> <pre><code>def get_labels(self):\n    \"\"\"\n    Users can customize their own format here.\n\n    Note:\n        Ensure output is a dictionary with the following keys:\n        ```python\n        dict(\n            im_file=im_file,\n            shape=shape,  # format: (height, width)\n            cls=cls,\n            bboxes=bboxes, # xywh\n            segments=segments,  # xy\n            keypoints=keypoints, # xy\n            normalized=True, # or False\n            bbox_format=\"xyxy\",  # or xywh, ltwh\n        )\n        ```\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/data/base/#ultralytics.data.base.BaseDataset.load_image","title":"<code>load_image(i, rect_mode=True)</code>","text":"<p>Loads 1 image from dataset index 'i', returns (im, resized hw).</p> Source code in <code>ultralytics/data/base.py</code> <pre><code>def load_image(self, i, rect_mode=True):\n    \"\"\"Loads 1 image from dataset index 'i', returns (im, resized hw).\"\"\"\n    im, f, fn = self.ims[i], self.im_files[i], self.npy_files[i]\n    if im is None:  # not cached in RAM\n        if fn.exists():  # load npy\n            try:\n                im = np.load(fn)\n            except Exception as e:\n                LOGGER.warning(f\"{self.prefix}WARNING \u26a0\ufe0f Removing corrupt *.npy image file {fn} due to: {e}\")\n                Path(fn).unlink(missing_ok=True)\n                im = cv2.imread(f)  # BGR\n        else:  # read image\n            im = cv2.imread(f)  # BGR\n        if im is None:\n            raise FileNotFoundError(f\"Image Not Found {f}\")\n\n        h0, w0 = im.shape[:2]  # orig hw\n        if rect_mode:  # resize long side to imgsz while maintaining aspect ratio\n            r = self.imgsz / max(h0, w0)  # ratio\n            if r != 1:  # if sizes are not equal\n                w, h = (min(math.ceil(w0 * r), self.imgsz), min(math.ceil(h0 * r), self.imgsz))\n                im = cv2.resize(im, (w, h), interpolation=cv2.INTER_LINEAR)\n        elif not (h0 == w0 == self.imgsz):  # resize by stretching image to square imgsz\n            im = cv2.resize(im, (self.imgsz, self.imgsz), interpolation=cv2.INTER_LINEAR)\n\n        # Add to buffer if training with augmentations\n        if self.augment:\n            self.ims[i], self.im_hw0[i], self.im_hw[i] = im, (h0, w0), im.shape[:2]  # im, hw_original, hw_resized\n            self.buffer.append(i)\n            if len(self.buffer) &gt;= self.max_buffer_length:\n                j = self.buffer.pop(0)\n                self.ims[j], self.im_hw0[j], self.im_hw[j] = None, None, None\n\n        return im, (h0, w0), im.shape[:2]\n\n    return self.ims[i], self.im_hw0[i], self.im_hw[i]\n</code></pre>"},{"location":"reference/data/base/#ultralytics.data.base.BaseDataset.set_rectangle","title":"<code>set_rectangle()</code>","text":"<p>Sets the shape of bounding boxes for YOLO detections as rectangles.</p> Source code in <code>ultralytics/data/base.py</code> <pre><code>def set_rectangle(self):\n    \"\"\"Sets the shape of bounding boxes for YOLO detections as rectangles.\"\"\"\n    bi = np.floor(np.arange(self.ni) / self.batch_size).astype(int)  # batch index\n    nb = bi[-1] + 1  # number of batches\n\n    s = np.array([x.pop(\"shape\") for x in self.labels])  # hw\n    ar = s[:, 0] / s[:, 1]  # aspect ratio\n    irect = ar.argsort()\n    self.im_files = [self.im_files[i] for i in irect]\n    self.labels = [self.labels[i] for i in irect]\n    ar = ar[irect]\n\n    # Set training image shapes\n    shapes = [[1, 1]] * nb\n    for i in range(nb):\n        ari = ar[bi == i]\n        mini, maxi = ari.min(), ari.max()\n        if maxi &lt; 1:\n            shapes[i] = [maxi, 1]\n        elif mini &gt; 1:\n            shapes[i] = [1, 1 / mini]\n\n    self.batch_shapes = np.ceil(np.array(shapes) * self.imgsz / self.stride + self.pad).astype(int) * self.stride\n    self.batch = bi  # batch index of image\n</code></pre>"},{"location":"reference/data/base/#ultralytics.data.base.BaseDataset.update_labels","title":"<code>update_labels(include_class)</code>","text":"<p>Update labels to include only these classes (optional).</p> Source code in <code>ultralytics/data/base.py</code> <pre><code>def update_labels(self, include_class: Optional[list]):\n    \"\"\"Update labels to include only these classes (optional).\"\"\"\n    include_class_array = np.array(include_class).reshape(1, -1)\n    for i in range(len(self.labels)):\n        if include_class is not None:\n            cls = self.labels[i][\"cls\"]\n            bboxes = self.labels[i][\"bboxes\"]\n            segments = self.labels[i][\"segments\"]\n            keypoints = self.labels[i][\"keypoints\"]\n            j = (cls == include_class_array).any(1)\n            self.labels[i][\"cls\"] = cls[j]\n            self.labels[i][\"bboxes\"] = bboxes[j]\n            if segments:\n                self.labels[i][\"segments\"] = [segments[si] for si, idx in enumerate(j) if idx]\n            if keypoints is not None:\n                self.labels[i][\"keypoints\"] = keypoints[j]\n        if self.single_cls:\n            self.labels[i][\"cls\"][:, 0] = 0\n</code></pre>"},{"location":"reference/data/base/#ultralytics.data.base.BaseDataset.update_labels_info","title":"<code>update_labels_info(label)</code>","text":"<p>Custom your label format here.</p> Source code in <code>ultralytics/data/base.py</code> <pre><code>def update_labels_info(self, label):\n    \"\"\"Custom your label format here.\"\"\"\n    return label\n</code></pre>"},{"location":"reference/data/build/","title":"Reference for <code>ultralytics/data/build.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/build.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/data/build/#ultralytics.data.build.InfiniteDataLoader","title":"<code>ultralytics.data.build.InfiniteDataLoader</code>","text":"<p>             Bases: <code>DataLoader</code></p> <p>Dataloader that reuses workers.</p> <p>Uses same syntax as vanilla DataLoader.</p> Source code in <code>ultralytics/data/build.py</code> <pre><code>class InfiniteDataLoader(dataloader.DataLoader):\n    \"\"\"\n    Dataloader that reuses workers.\n\n    Uses same syntax as vanilla DataLoader.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Dataloader that infinitely recycles workers, inherits from DataLoader.\"\"\"\n        super().__init__(*args, **kwargs)\n        object.__setattr__(self, \"batch_sampler\", _RepeatSampler(self.batch_sampler))\n        self.iterator = super().__iter__()\n\n    def __len__(self):\n        \"\"\"Returns the length of the batch sampler's sampler.\"\"\"\n        return len(self.batch_sampler.sampler)\n\n    def __iter__(self):\n        \"\"\"Creates a sampler that repeats indefinitely.\"\"\"\n        for _ in range(len(self)):\n            yield next(self.iterator)\n\n    def reset(self):\n        \"\"\"\n        Reset iterator.\n\n        This is useful when we want to modify settings of dataset while training.\n        \"\"\"\n        self.iterator = self._get_iterator()\n</code></pre>"},{"location":"reference/data/build/#ultralytics.data.build.InfiniteDataLoader.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Dataloader that infinitely recycles workers, inherits from DataLoader.</p> Source code in <code>ultralytics/data/build.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"Dataloader that infinitely recycles workers, inherits from DataLoader.\"\"\"\n    super().__init__(*args, **kwargs)\n    object.__setattr__(self, \"batch_sampler\", _RepeatSampler(self.batch_sampler))\n    self.iterator = super().__iter__()\n</code></pre>"},{"location":"reference/data/build/#ultralytics.data.build.InfiniteDataLoader.__iter__","title":"<code>__iter__()</code>","text":"<p>Creates a sampler that repeats indefinitely.</p> Source code in <code>ultralytics/data/build.py</code> <pre><code>def __iter__(self):\n    \"\"\"Creates a sampler that repeats indefinitely.\"\"\"\n    for _ in range(len(self)):\n        yield next(self.iterator)\n</code></pre>"},{"location":"reference/data/build/#ultralytics.data.build.InfiniteDataLoader.__len__","title":"<code>__len__()</code>","text":"<p>Returns the length of the batch sampler's sampler.</p> Source code in <code>ultralytics/data/build.py</code> <pre><code>def __len__(self):\n    \"\"\"Returns the length of the batch sampler's sampler.\"\"\"\n    return len(self.batch_sampler.sampler)\n</code></pre>"},{"location":"reference/data/build/#ultralytics.data.build.InfiniteDataLoader.reset","title":"<code>reset()</code>","text":"<p>Reset iterator.</p> <p>This is useful when we want to modify settings of dataset while training.</p> Source code in <code>ultralytics/data/build.py</code> <pre><code>def reset(self):\n    \"\"\"\n    Reset iterator.\n\n    This is useful when we want to modify settings of dataset while training.\n    \"\"\"\n    self.iterator = self._get_iterator()\n</code></pre>"},{"location":"reference/data/build/#ultralytics.data.build._RepeatSampler","title":"<code>ultralytics.data.build._RepeatSampler</code>","text":"<p>Sampler that repeats forever.</p> <p>Parameters:</p> Name Type Description Default <code>sampler</code> <code>sampler</code> <p>The sampler to repeat.</p> required Source code in <code>ultralytics/data/build.py</code> <pre><code>class _RepeatSampler:\n    \"\"\"\n    Sampler that repeats forever.\n\n    Args:\n        sampler (Dataset.sampler): The sampler to repeat.\n    \"\"\"\n\n    def __init__(self, sampler):\n        \"\"\"Initializes an object that repeats a given sampler indefinitely.\"\"\"\n        self.sampler = sampler\n\n    def __iter__(self):\n        \"\"\"Iterates over the 'sampler' and yields its contents.\"\"\"\n        while True:\n            yield from iter(self.sampler)\n</code></pre>"},{"location":"reference/data/build/#ultralytics.data.build._RepeatSampler.__init__","title":"<code>__init__(sampler)</code>","text":"<p>Initializes an object that repeats a given sampler indefinitely.</p> Source code in <code>ultralytics/data/build.py</code> <pre><code>def __init__(self, sampler):\n    \"\"\"Initializes an object that repeats a given sampler indefinitely.\"\"\"\n    self.sampler = sampler\n</code></pre>"},{"location":"reference/data/build/#ultralytics.data.build._RepeatSampler.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterates over the 'sampler' and yields its contents.</p> Source code in <code>ultralytics/data/build.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterates over the 'sampler' and yields its contents.\"\"\"\n    while True:\n        yield from iter(self.sampler)\n</code></pre>"},{"location":"reference/data/build/#ultralytics.data.build.seed_worker","title":"<code>ultralytics.data.build.seed_worker(worker_id)</code>","text":"<p>Set dataloader worker seed https://pytorch.org/docs/stable/notes/randomness.html#dataloader.</p> Source code in <code>ultralytics/data/build.py</code> <pre><code>def seed_worker(worker_id):  # noqa\n    \"\"\"Set dataloader worker seed https://pytorch.org/docs/stable/notes/randomness.html#dataloader.\"\"\"\n    worker_seed = torch.initial_seed() % 2**32\n    np.random.seed(worker_seed)\n    random.seed(worker_seed)\n</code></pre>"},{"location":"reference/data/build/#ultralytics.data.build.build_yolo_dataset","title":"<code>ultralytics.data.build.build_yolo_dataset(cfg, img_path, batch, data, mode='train', rect=False, stride=32)</code>","text":"<p>Build YOLO Dataset.</p> Source code in <code>ultralytics/data/build.py</code> <pre><code>def build_yolo_dataset(cfg, img_path, batch, data, mode=\"train\", rect=False, stride=32):\n    \"\"\"Build YOLO Dataset.\"\"\"\n    return YOLODataset(\n        img_path=img_path,\n        imgsz=cfg.imgsz,\n        batch_size=batch,\n        augment=mode == \"train\",  # augmentation\n        hyp=cfg,  # TODO: probably add a get_hyps_from_cfg function\n        rect=cfg.rect or rect,  # rectangular batches\n        cache=cfg.cache or None,\n        single_cls=cfg.single_cls or False,\n        stride=int(stride),\n        pad=0.0 if mode == \"train\" else 0.5,\n        prefix=colorstr(f\"{mode}: \"),\n        task=cfg.task,\n        classes=cfg.classes,\n        data=data,\n        fraction=cfg.fraction if mode == \"train\" else 1.0,\n    )\n</code></pre>"},{"location":"reference/data/build/#ultralytics.data.build.build_dataloader","title":"<code>ultralytics.data.build.build_dataloader(dataset, batch, workers, shuffle=True, rank=-1)</code>","text":"<p>Return an InfiniteDataLoader or DataLoader for training or validation set.</p> Source code in <code>ultralytics/data/build.py</code> <pre><code>def build_dataloader(dataset, batch, workers, shuffle=True, rank=-1):\n    \"\"\"Return an InfiniteDataLoader or DataLoader for training or validation set.\"\"\"\n    batch = min(batch, len(dataset))\n    nd = torch.cuda.device_count()  # number of CUDA devices\n    nw = min([os.cpu_count() // max(nd, 1), batch, workers])  # number of workers\n    sampler = None if rank == -1 else distributed.DistributedSampler(dataset, shuffle=shuffle)\n    generator = torch.Generator()\n    generator.manual_seed(6148914691236517205 + RANK)\n    return InfiniteDataLoader(\n        dataset=dataset,\n        batch_size=batch,\n        shuffle=shuffle and sampler is None,\n        num_workers=nw,\n        sampler=sampler,\n        pin_memory=PIN_MEMORY,\n        collate_fn=getattr(dataset, \"collate_fn\", None),\n        worker_init_fn=seed_worker,\n        generator=generator,\n    )\n</code></pre>"},{"location":"reference/data/build/#ultralytics.data.build.check_source","title":"<code>ultralytics.data.build.check_source(source)</code>","text":"<p>Check source type and return corresponding flag values.</p> Source code in <code>ultralytics/data/build.py</code> <pre><code>def check_source(source):\n    \"\"\"Check source type and return corresponding flag values.\"\"\"\n    webcam, screenshot, from_img, in_memory, tensor = False, False, False, False, False\n    if isinstance(source, (str, int, Path)):  # int for local usb camera\n        source = str(source)\n        is_file = Path(source).suffix[1:] in (IMG_FORMATS + VID_FORMATS)\n        is_url = source.lower().startswith((\"https://\", \"http://\", \"rtsp://\", \"rtmp://\", \"tcp://\"))\n        webcam = source.isnumeric() or source.endswith(\".streams\") or (is_url and not is_file)\n        screenshot = source.lower() == \"screen\"\n        if is_url and is_file:\n            source = check_file(source)  # download\n    elif isinstance(source, LOADERS):\n        in_memory = True\n    elif isinstance(source, (list, tuple)):\n        source = autocast_list(source)  # convert all list elements to PIL or np arrays\n        from_img = True\n    elif isinstance(source, (Image.Image, np.ndarray)):\n        from_img = True\n    elif isinstance(source, torch.Tensor):\n        tensor = True\n    else:\n        raise TypeError(\"Unsupported image type. For supported types see https://docs.ultralytics.com/modes/predict\")\n\n    return source, webcam, screenshot, from_img, in_memory, tensor\n</code></pre>"},{"location":"reference/data/build/#ultralytics.data.build.load_inference_source","title":"<code>ultralytics.data.build.load_inference_source(source=None, imgsz=640, vid_stride=1, buffer=False)</code>","text":"<p>Loads an inference source for object detection and applies necessary transformations.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>(str, Path, Tensor, Image, ndarray)</code> <p>The input source for inference.</p> <code>None</code> <code>imgsz</code> <code>int</code> <p>The size of the image for inference. Default is 640.</p> <code>640</code> <code>vid_stride</code> <code>int</code> <p>The frame interval for video sources. Default is 1.</p> <code>1</code> <code>buffer</code> <code>bool</code> <p>Determined whether stream frames will be buffered. Default is False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dataset</code> <code>Dataset</code> <p>A dataset object for the specified input source.</p> Source code in <code>ultralytics/data/build.py</code> <pre><code>def load_inference_source(source=None, imgsz=640, vid_stride=1, buffer=False):\n    \"\"\"\n    Loads an inference source for object detection and applies necessary transformations.\n\n    Args:\n        source (str, Path, Tensor, PIL.Image, np.ndarray): The input source for inference.\n        imgsz (int, optional): The size of the image for inference. Default is 640.\n        vid_stride (int, optional): The frame interval for video sources. Default is 1.\n        buffer (bool, optional): Determined whether stream frames will be buffered. Default is False.\n\n    Returns:\n        dataset (Dataset): A dataset object for the specified input source.\n    \"\"\"\n    source, webcam, screenshot, from_img, in_memory, tensor = check_source(source)\n    source_type = source.source_type if in_memory else SourceTypes(webcam, screenshot, from_img, tensor)\n\n    # Dataloader\n    if tensor:\n        dataset = LoadTensor(source)\n    elif in_memory:\n        dataset = source\n    elif webcam:\n        dataset = LoadStreams(source, imgsz=imgsz, vid_stride=vid_stride, buffer=buffer)\n    elif screenshot:\n        dataset = LoadScreenshots(source, imgsz=imgsz)\n    elif from_img:\n        dataset = LoadPilAndNumpy(source, imgsz=imgsz)\n    else:\n        dataset = LoadImages(source, imgsz=imgsz, vid_stride=vid_stride)\n\n    # Attach source types to the dataset\n    setattr(dataset, \"source_type\", source_type)\n\n    return dataset\n</code></pre>"},{"location":"reference/data/converter/","title":"Reference for <code>ultralytics/data/converter.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/converter.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/data/converter/#ultralytics.data.converter.coco91_to_coco80_class","title":"<code>ultralytics.data.converter.coco91_to_coco80_class()</code>","text":"<p>Converts 91-index COCO class IDs to 80-index COCO class IDs.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of 91 class IDs where the index represents the 80-index class ID and the value is the corresponding 91-index class ID.</p> Source code in <code>ultralytics/data/converter.py</code> <pre><code>def coco91_to_coco80_class():\n    \"\"\"\n    Converts 91-index COCO class IDs to 80-index COCO class IDs.\n\n    Returns:\n        (list): A list of 91 class IDs where the index represents the 80-index class ID and the value is the\n            corresponding 91-index class ID.\n    \"\"\"\n    return [\n        0,\n        1,\n        2,\n        3,\n        4,\n        5,\n        6,\n        7,\n        8,\n        9,\n        10,\n        None,\n        11,\n        12,\n        13,\n        14,\n        15,\n        16,\n        17,\n        18,\n        19,\n        20,\n        21,\n        22,\n        23,\n        None,\n        24,\n        25,\n        None,\n        None,\n        26,\n        27,\n        28,\n        29,\n        30,\n        31,\n        32,\n        33,\n        34,\n        35,\n        36,\n        37,\n        38,\n        39,\n        None,\n        40,\n        41,\n        42,\n        43,\n        44,\n        45,\n        46,\n        47,\n        48,\n        49,\n        50,\n        51,\n        52,\n        53,\n        54,\n        55,\n        56,\n        57,\n        58,\n        59,\n        None,\n        60,\n        None,\n        None,\n        61,\n        None,\n        62,\n        63,\n        64,\n        65,\n        66,\n        67,\n        68,\n        69,\n        70,\n        71,\n        72,\n        None,\n        73,\n        74,\n        75,\n        76,\n        77,\n        78,\n        79,\n        None,\n    ]\n</code></pre>"},{"location":"reference/data/converter/#ultralytics.data.converter.coco80_to_coco91_class","title":"<code>ultralytics.data.converter.coco80_to_coco91_class()</code>","text":"<pre><code>Converts 80-index (val2014) to 91-index (paper).\nFor details see https://tech.amikelive.com/node-718/what-object-categories-labels-are-in-coco-dataset/.\n\nExample:\n    ```python\n    import numpy as np\n\n    a = np.loadtxt('data/coco.names', dtype='str', delimiter='\n</code></pre> <p>')         b = np.loadtxt('data/coco_paper.names', dtype='str', delimiter=' ')         x1 = [list(a[i] == b).index(True) + 1 for i in range(80)]  # darknet to coco         x2 = [list(b[i] == a).index(True) if any(b[i] == a) else None for i in range(91)]  # coco to darknet         ```</p> Source code in <code>ultralytics/data/converter.py</code> <pre><code>def coco80_to_coco91_class():\n    \"\"\"\n    Converts 80-index (val2014) to 91-index (paper).\n    For details see https://tech.amikelive.com/node-718/what-object-categories-labels-are-in-coco-dataset/.\n\n    Example:\n        ```python\n        import numpy as np\n\n        a = np.loadtxt('data/coco.names', dtype='str', delimiter='\\n')\n        b = np.loadtxt('data/coco_paper.names', dtype='str', delimiter='\\n')\n        x1 = [list(a[i] == b).index(True) + 1 for i in range(80)]  # darknet to coco\n        x2 = [list(b[i] == a).index(True) if any(b[i] == a) else None for i in range(91)]  # coco to darknet\n        ```\n    \"\"\"\n    return [\n        1,\n        2,\n        3,\n        4,\n        5,\n        6,\n        7,\n        8,\n        9,\n        10,\n        11,\n        13,\n        14,\n        15,\n        16,\n        17,\n        18,\n        19,\n        20,\n        21,\n        22,\n        23,\n        24,\n        25,\n        27,\n        28,\n        31,\n        32,\n        33,\n        34,\n        35,\n        36,\n        37,\n        38,\n        39,\n        40,\n        41,\n        42,\n        43,\n        44,\n        46,\n        47,\n        48,\n        49,\n        50,\n        51,\n        52,\n        53,\n        54,\n        55,\n        56,\n        57,\n        58,\n        59,\n        60,\n        61,\n        62,\n        63,\n        64,\n        65,\n        67,\n        70,\n        72,\n        73,\n        74,\n        75,\n        76,\n        77,\n        78,\n        79,\n        80,\n        81,\n        82,\n        84,\n        85,\n        86,\n        87,\n        88,\n        89,\n        90,\n    ]\n</code></pre>"},{"location":"reference/data/converter/#ultralytics.data.converter.convert_coco","title":"<code>ultralytics.data.converter.convert_coco(labels_dir='../coco/annotations/', save_dir='coco_converted/', use_segments=False, use_keypoints=False, cls91to80=True)</code>","text":"<p>Converts COCO dataset annotations to a YOLO annotation format  suitable for training YOLO models.</p> <p>Parameters:</p> Name Type Description Default <code>labels_dir</code> <code>str</code> <p>Path to directory containing COCO dataset annotation files.</p> <code>'../coco/annotations/'</code> <code>save_dir</code> <code>str</code> <p>Path to directory to save results to.</p> <code>'coco_converted/'</code> <code>use_segments</code> <code>bool</code> <p>Whether to include segmentation masks in the output.</p> <code>False</code> <code>use_keypoints</code> <code>bool</code> <p>Whether to include keypoint annotations in the output.</p> <code>False</code> <code>cls91to80</code> <code>bool</code> <p>Whether to map 91 COCO class IDs to the corresponding 80 COCO class IDs.</p> <code>True</code> Example <pre><code>from ultralytics.data.converter import convert_coco\n\nconvert_coco('../datasets/coco/annotations/', use_segments=True, use_keypoints=False, cls91to80=True)\n</code></pre> Output <p>Generates output files in the specified output directory.</p> Source code in <code>ultralytics/data/converter.py</code> <pre><code>def convert_coco(\n    labels_dir=\"../coco/annotations/\",\n    save_dir=\"coco_converted/\",\n    use_segments=False,\n    use_keypoints=False,\n    cls91to80=True,\n):\n    \"\"\"\n    Converts COCO dataset annotations to a YOLO annotation format  suitable for training YOLO models.\n\n    Args:\n        labels_dir (str, optional): Path to directory containing COCO dataset annotation files.\n        save_dir (str, optional): Path to directory to save results to.\n        use_segments (bool, optional): Whether to include segmentation masks in the output.\n        use_keypoints (bool, optional): Whether to include keypoint annotations in the output.\n        cls91to80 (bool, optional): Whether to map 91 COCO class IDs to the corresponding 80 COCO class IDs.\n\n    Example:\n        ```python\n        from ultralytics.data.converter import convert_coco\n\n        convert_coco('../datasets/coco/annotations/', use_segments=True, use_keypoints=False, cls91to80=True)\n        ```\n\n    Output:\n        Generates output files in the specified output directory.\n    \"\"\"\n\n    # Create dataset directory\n    save_dir = increment_path(save_dir)  # increment if save directory already exists\n    for p in save_dir / \"labels\", save_dir / \"images\":\n        p.mkdir(parents=True, exist_ok=True)  # make dir\n\n    # Convert classes\n    coco80 = coco91_to_coco80_class()\n\n    # Import json\n    for json_file in sorted(Path(labels_dir).resolve().glob(\"*.json\")):\n        fn = Path(save_dir) / \"labels\" / json_file.stem.replace(\"instances_\", \"\")  # folder name\n        fn.mkdir(parents=True, exist_ok=True)\n        with open(json_file) as f:\n            data = json.load(f)\n\n        # Create image dict\n        images = {f'{x[\"id\"]:d}': x for x in data[\"images\"]}\n        # Create image-annotations dict\n        imgToAnns = defaultdict(list)\n        for ann in data[\"annotations\"]:\n            imgToAnns[ann[\"image_id\"]].append(ann)\n\n        # Write labels file\n        for img_id, anns in TQDM(imgToAnns.items(), desc=f\"Annotations {json_file}\"):\n            img = images[f\"{img_id:d}\"]\n            h, w, f = img[\"height\"], img[\"width\"], img[\"file_name\"]\n\n            bboxes = []\n            segments = []\n            keypoints = []\n            for ann in anns:\n                if ann[\"iscrowd\"]:\n                    continue\n                # The COCO box format is [top left x, top left y, width, height]\n                box = np.array(ann[\"bbox\"], dtype=np.float64)\n                box[:2] += box[2:] / 2  # xy top-left corner to center\n                box[[0, 2]] /= w  # normalize x\n                box[[1, 3]] /= h  # normalize y\n                if box[2] &lt;= 0 or box[3] &lt;= 0:  # if w &lt;= 0 and h &lt;= 0\n                    continue\n\n                cls = coco80[ann[\"category_id\"] - 1] if cls91to80 else ann[\"category_id\"] - 1  # class\n                box = [cls] + box.tolist()\n                if box not in bboxes:\n                    bboxes.append(box)\n                    if use_segments and ann.get(\"segmentation\") is not None:\n                        if len(ann[\"segmentation\"]) == 0:\n                            segments.append([])\n                            continue\n                        elif len(ann[\"segmentation\"]) &gt; 1:\n                            s = merge_multi_segment(ann[\"segmentation\"])\n                            s = (np.concatenate(s, axis=0) / np.array([w, h])).reshape(-1).tolist()\n                        else:\n                            s = [j for i in ann[\"segmentation\"] for j in i]  # all segments concatenated\n                            s = (np.array(s).reshape(-1, 2) / np.array([w, h])).reshape(-1).tolist()\n                        s = [cls] + s\n                        segments.append(s)\n                    if use_keypoints and ann.get(\"keypoints\") is not None:\n                        keypoints.append(\n                            box + (np.array(ann[\"keypoints\"]).reshape(-1, 3) / np.array([w, h, 1])).reshape(-1).tolist()\n                        )\n\n            # Write\n            with open((fn / f).with_suffix(\".txt\"), \"a\") as file:\n                for i in range(len(bboxes)):\n                    if use_keypoints:\n                        line = (*(keypoints[i]),)  # cls, box, keypoints\n                    else:\n                        line = (\n                            *(segments[i] if use_segments and len(segments[i]) &gt; 0 else bboxes[i]),\n                        )  # cls, box or segments\n                    file.write((\"%g \" * len(line)).rstrip() % line + \"\\n\")\n\n    LOGGER.info(f\"COCO data converted successfully.\\nResults saved to {save_dir.resolve()}\")\n</code></pre>"},{"location":"reference/data/converter/#ultralytics.data.converter.convert_dota_to_yolo_obb","title":"<code>ultralytics.data.converter.convert_dota_to_yolo_obb(dota_root_path)</code>","text":"<p>Converts DOTA dataset annotations to YOLO OBB (Oriented Bounding Box) format.</p> <p>The function processes images in the 'train' and 'val' folders of the DOTA dataset. For each image, it reads the associated label from the original labels directory and writes new labels in YOLO OBB format to a new directory.</p> <p>Parameters:</p> Name Type Description Default <code>dota_root_path</code> <code>str</code> <p>The root directory path of the DOTA dataset.</p> required Example <pre><code>from ultralytics.data.converter import convert_dota_to_yolo_obb\n\nconvert_dota_to_yolo_obb('path/to/DOTA')\n</code></pre> Notes <p>The directory structure assumed for the DOTA dataset:     - DOTA         \u251c\u2500 images         \u2502   \u251c\u2500 train         \u2502   \u2514\u2500 val         \u2514\u2500 labels             \u251c\u2500 train_original             \u2514\u2500 val_original</p> <p>After execution, the function will organize the labels into:     - DOTA         \u2514\u2500 labels             \u251c\u2500 train             \u2514\u2500 val</p> Source code in <code>ultralytics/data/converter.py</code> <pre><code>def convert_dota_to_yolo_obb(dota_root_path: str):\n    \"\"\"\n    Converts DOTA dataset annotations to YOLO OBB (Oriented Bounding Box) format.\n\n    The function processes images in the 'train' and 'val' folders of the DOTA dataset. For each image, it reads the\n    associated label from the original labels directory and writes new labels in YOLO OBB format to a new directory.\n\n    Args:\n        dota_root_path (str): The root directory path of the DOTA dataset.\n\n    Example:\n        ```python\n        from ultralytics.data.converter import convert_dota_to_yolo_obb\n\n        convert_dota_to_yolo_obb('path/to/DOTA')\n        ```\n\n    Notes:\n        The directory structure assumed for the DOTA dataset:\n            - DOTA\n                \u251c\u2500 images\n                \u2502   \u251c\u2500 train\n                \u2502   \u2514\u2500 val\n                \u2514\u2500 labels\n                    \u251c\u2500 train_original\n                    \u2514\u2500 val_original\n\n        After execution, the function will organize the labels into:\n            - DOTA\n                \u2514\u2500 labels\n                    \u251c\u2500 train\n                    \u2514\u2500 val\n    \"\"\"\n    dota_root_path = Path(dota_root_path)\n\n    # Class names to indices mapping\n    class_mapping = {\n        \"plane\": 0,\n        \"ship\": 1,\n        \"storage-tank\": 2,\n        \"baseball-diamond\": 3,\n        \"tennis-court\": 4,\n        \"basketball-court\": 5,\n        \"ground-track-field\": 6,\n        \"harbor\": 7,\n        \"bridge\": 8,\n        \"large-vehicle\": 9,\n        \"small-vehicle\": 10,\n        \"helicopter\": 11,\n        \"roundabout\": 12,\n        \"soccer-ball-field\": 13,\n        \"swimming-pool\": 14,\n        \"container-crane\": 15,\n        \"airport\": 16,\n        \"helipad\": 17,\n    }\n\n    def convert_label(image_name, image_width, image_height, orig_label_dir, save_dir):\n        \"\"\"Converts a single image's DOTA annotation to YOLO OBB format and saves it to a specified directory.\"\"\"\n        orig_label_path = orig_label_dir / f\"{image_name}.txt\"\n        save_path = save_dir / f\"{image_name}.txt\"\n\n        with orig_label_path.open(\"r\") as f, save_path.open(\"w\") as g:\n            lines = f.readlines()\n            for line in lines:\n                parts = line.strip().split()\n                if len(parts) &lt; 9:\n                    continue\n                class_name = parts[8]\n                class_idx = class_mapping[class_name]\n                coords = [float(p) for p in parts[:8]]\n                normalized_coords = [\n                    coords[i] / image_width if i % 2 == 0 else coords[i] / image_height for i in range(8)\n                ]\n                formatted_coords = [\"{:.6g}\".format(coord) for coord in normalized_coords]\n                g.write(f\"{class_idx} {' '.join(formatted_coords)}\\n\")\n\n    for phase in [\"train\", \"val\"]:\n        image_dir = dota_root_path / \"images\" / phase\n        orig_label_dir = dota_root_path / \"labels\" / f\"{phase}_original\"\n        save_dir = dota_root_path / \"labels\" / phase\n\n        save_dir.mkdir(parents=True, exist_ok=True)\n\n        image_paths = list(image_dir.iterdir())\n        for image_path in TQDM(image_paths, desc=f\"Processing {phase} images\"):\n            if image_path.suffix != \".png\":\n                continue\n            image_name_without_ext = image_path.stem\n            img = cv2.imread(str(image_path))\n            h, w = img.shape[:2]\n            convert_label(image_name_without_ext, w, h, orig_label_dir, save_dir)\n</code></pre>"},{"location":"reference/data/converter/#ultralytics.data.converter.min_index","title":"<code>ultralytics.data.converter.min_index(arr1, arr2)</code>","text":"<p>Find a pair of indexes with the shortest distance between two arrays of 2D points.</p> <p>Parameters:</p> Name Type Description Default <code>arr1</code> <code>array</code> <p>A NumPy array of shape (N, 2) representing N 2D points.</p> required <code>arr2</code> <code>array</code> <p>A NumPy array of shape (M, 2) representing M 2D points.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the indexes of the points with the shortest distance in arr1 and arr2 respectively.</p> Source code in <code>ultralytics/data/converter.py</code> <pre><code>def min_index(arr1, arr2):\n    \"\"\"\n    Find a pair of indexes with the shortest distance between two arrays of 2D points.\n\n    Args:\n        arr1 (np.array): A NumPy array of shape (N, 2) representing N 2D points.\n        arr2 (np.array): A NumPy array of shape (M, 2) representing M 2D points.\n\n    Returns:\n        (tuple): A tuple containing the indexes of the points with the shortest distance in arr1 and arr2 respectively.\n    \"\"\"\n    dis = ((arr1[:, None, :] - arr2[None, :, :]) ** 2).sum(-1)\n    return np.unravel_index(np.argmin(dis, axis=None), dis.shape)\n</code></pre>"},{"location":"reference/data/converter/#ultralytics.data.converter.merge_multi_segment","title":"<code>ultralytics.data.converter.merge_multi_segment(segments)</code>","text":"<p>Merge multiple segments into one list by connecting the coordinates with the minimum distance between each segment. This function connects these coordinates with a thin line to merge all segments into one.</p> <p>Parameters:</p> Name Type Description Default <code>segments</code> <code>List[List]</code> <p>Original segmentations in COCO's JSON file.                    Each element is a list of coordinates, like [segmentation1, segmentation2,...].</p> required <p>Returns:</p> Name Type Description <code>s</code> <code>List[ndarray]</code> <p>A list of connected segments represented as NumPy arrays.</p> Source code in <code>ultralytics/data/converter.py</code> <pre><code>def merge_multi_segment(segments):\n    \"\"\"\n    Merge multiple segments into one list by connecting the coordinates with the minimum distance between each segment.\n    This function connects these coordinates with a thin line to merge all segments into one.\n\n    Args:\n        segments (List[List]): Original segmentations in COCO's JSON file.\n                               Each element is a list of coordinates, like [segmentation1, segmentation2,...].\n\n    Returns:\n        s (List[np.ndarray]): A list of connected segments represented as NumPy arrays.\n    \"\"\"\n    s = []\n    segments = [np.array(i).reshape(-1, 2) for i in segments]\n    idx_list = [[] for _ in range(len(segments))]\n\n    # Record the indexes with min distance between each segment\n    for i in range(1, len(segments)):\n        idx1, idx2 = min_index(segments[i - 1], segments[i])\n        idx_list[i - 1].append(idx1)\n        idx_list[i].append(idx2)\n\n    # Use two round to connect all the segments\n    for k in range(2):\n        # Forward connection\n        if k == 0:\n            for i, idx in enumerate(idx_list):\n                # Middle segments have two indexes, reverse the index of middle segments\n                if len(idx) == 2 and idx[0] &gt; idx[1]:\n                    idx = idx[::-1]\n                    segments[i] = segments[i][::-1, :]\n\n                segments[i] = np.roll(segments[i], -idx[0], axis=0)\n                segments[i] = np.concatenate([segments[i], segments[i][:1]])\n                # Deal with the first segment and the last one\n                if i in [0, len(idx_list) - 1]:\n                    s.append(segments[i])\n                else:\n                    idx = [0, idx[1] - idx[0]]\n                    s.append(segments[i][idx[0] : idx[1] + 1])\n\n        else:\n            for i in range(len(idx_list) - 1, -1, -1):\n                if i not in [0, len(idx_list) - 1]:\n                    idx = idx_list[i]\n                    nidx = abs(idx[1] - idx[0])\n                    s.append(segments[i][nidx:])\n    return s\n</code></pre>"},{"location":"reference/data/dataset/","title":"Reference for <code>ultralytics/data/dataset.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/dataset.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/data/dataset/#ultralytics.data.dataset.YOLODataset","title":"<code>ultralytics.data.dataset.YOLODataset</code>","text":"<p>             Bases: <code>BaseDataset</code></p> <p>Dataset class for loading object detection and/or segmentation labels in YOLO format.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>A dataset YAML dictionary. Defaults to None.</p> <code>None</code> <code>task</code> <code>str</code> <p>An explicit arg to point current task, Defaults to 'detect'.</p> <code>'detect'</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>A PyTorch dataset object that can be used for training an object detection model.</p> Source code in <code>ultralytics/data/dataset.py</code> <pre><code>class YOLODataset(BaseDataset):\n    \"\"\"\n    Dataset class for loading object detection and/or segmentation labels in YOLO format.\n\n    Args:\n        data (dict, optional): A dataset YAML dictionary. Defaults to None.\n        task (str): An explicit arg to point current task, Defaults to 'detect'.\n\n    Returns:\n        (torch.utils.data.Dataset): A PyTorch dataset object that can be used for training an object detection model.\n    \"\"\"\n\n    def __init__(self, *args, data=None, task=\"detect\", **kwargs):\n        \"\"\"Initializes the YOLODataset with optional configurations for segments and keypoints.\"\"\"\n        self.use_segments = task == \"segment\"\n        self.use_keypoints = task == \"pose\"\n        self.use_obb = task == \"obb\"\n        self.data = data\n        assert not (self.use_segments and self.use_keypoints), \"Can not use both segments and keypoints.\"\n        super().__init__(*args, **kwargs)\n\n    def cache_labels(self, path=Path(\"./labels.cache\")):\n        \"\"\"\n        Cache dataset labels, check images and read shapes.\n\n        Args:\n            path (Path): path where to save the cache file (default: Path('./labels.cache')).\n        Returns:\n            (dict): labels.\n        \"\"\"\n        x = {\"labels\": []}\n        nm, nf, ne, nc, msgs = 0, 0, 0, 0, []  # number missing, found, empty, corrupt, messages\n        desc = f\"{self.prefix}Scanning {path.parent / path.stem}...\"\n        total = len(self.im_files)\n        nkpt, ndim = self.data.get(\"kpt_shape\", (0, 0))\n        if self.use_keypoints and (nkpt &lt;= 0 or ndim not in (2, 3)):\n            raise ValueError(\n                \"'kpt_shape' in data.yaml missing or incorrect. Should be a list with [number of \"\n                \"keypoints, number of dims (2 for x,y or 3 for x,y,visible)], i.e. 'kpt_shape: [17, 3]'\"\n            )\n        with ThreadPool(NUM_THREADS) as pool:\n            results = pool.imap(\n                func=verify_image_label,\n                iterable=zip(\n                    self.im_files,\n                    self.label_files,\n                    repeat(self.prefix),\n                    repeat(self.use_keypoints),\n                    repeat(len(self.data[\"names\"])),\n                    repeat(nkpt),\n                    repeat(ndim),\n                ),\n            )\n            pbar = TQDM(results, desc=desc, total=total)\n            for im_file, lb, shape, segments, keypoint, nm_f, nf_f, ne_f, nc_f, msg in pbar:\n                nm += nm_f\n                nf += nf_f\n                ne += ne_f\n                nc += nc_f\n                if im_file:\n                    x[\"labels\"].append(\n                        dict(\n                            im_file=im_file,\n                            shape=shape,\n                            cls=lb[:, 0:1],  # n, 1\n                            bboxes=lb[:, 1:],  # n, 4\n                            segments=segments,\n                            keypoints=keypoint,\n                            normalized=True,\n                            bbox_format=\"xywh\",\n                        )\n                    )\n                if msg:\n                    msgs.append(msg)\n                pbar.desc = f\"{desc} {nf} images, {nm + ne} backgrounds, {nc} corrupt\"\n            pbar.close()\n\n        if msgs:\n            LOGGER.info(\"\\n\".join(msgs))\n        if nf == 0:\n            LOGGER.warning(f\"{self.prefix}WARNING \u26a0\ufe0f No labels found in {path}. {HELP_URL}\")\n        x[\"hash\"] = get_hash(self.label_files + self.im_files)\n        x[\"results\"] = nf, nm, ne, nc, len(self.im_files)\n        x[\"msgs\"] = msgs  # warnings\n        save_dataset_cache_file(self.prefix, path, x)\n        return x\n\n    def get_labels(self):\n        \"\"\"Returns dictionary of labels for YOLO training.\"\"\"\n        self.label_files = img2label_paths(self.im_files)\n        cache_path = Path(self.label_files[0]).parent.with_suffix(\".cache\")\n        try:\n            cache, exists = load_dataset_cache_file(cache_path), True  # attempt to load a *.cache file\n            assert cache[\"version\"] == DATASET_CACHE_VERSION  # matches current version\n            assert cache[\"hash\"] == get_hash(self.label_files + self.im_files)  # identical hash\n        except (FileNotFoundError, AssertionError, AttributeError):\n            cache, exists = self.cache_labels(cache_path), False  # run cache ops\n\n        # Display cache\n        nf, nm, ne, nc, n = cache.pop(\"results\")  # found, missing, empty, corrupt, total\n        if exists and LOCAL_RANK in (-1, 0):\n            d = f\"Scanning {cache_path}... {nf} images, {nm + ne} backgrounds, {nc} corrupt\"\n            TQDM(None, desc=self.prefix + d, total=n, initial=n)  # display results\n            if cache[\"msgs\"]:\n                LOGGER.info(\"\\n\".join(cache[\"msgs\"]))  # display warnings\n\n        # Read cache\n        [cache.pop(k) for k in (\"hash\", \"version\", \"msgs\")]  # remove items\n        labels = cache[\"labels\"]\n        if not labels:\n            LOGGER.warning(f\"WARNING \u26a0\ufe0f No images found in {cache_path}, training may not work correctly. {HELP_URL}\")\n        self.im_files = [lb[\"im_file\"] for lb in labels]  # update im_files\n\n        # Check if the dataset is all boxes or all segments\n        lengths = ((len(lb[\"cls\"]), len(lb[\"bboxes\"]), len(lb[\"segments\"])) for lb in labels)\n        len_cls, len_boxes, len_segments = (sum(x) for x in zip(*lengths))\n        if len_segments and len_boxes != len_segments:\n            LOGGER.warning(\n                f\"WARNING \u26a0\ufe0f Box and segment counts should be equal, but got len(segments) = {len_segments}, \"\n                f\"len(boxes) = {len_boxes}. To resolve this only boxes will be used and all segments will be removed. \"\n                \"To avoid this please supply either a detect or segment dataset, not a detect-segment mixed dataset.\"\n            )\n            for lb in labels:\n                lb[\"segments\"] = []\n        if len_cls == 0:\n            LOGGER.warning(f\"WARNING \u26a0\ufe0f No labels found in {cache_path}, training may not work correctly. {HELP_URL}\")\n        return labels\n\n    def build_transforms(self, hyp=None):\n        \"\"\"Builds and appends transforms to the list.\"\"\"\n        if self.augment:\n            hyp.mosaic = hyp.mosaic if self.augment and not self.rect else 0.0\n            hyp.mixup = hyp.mixup if self.augment and not self.rect else 0.0\n            transforms = v8_transforms(self, self.imgsz, hyp)\n        else:\n            transforms = Compose([LetterBox(new_shape=(self.imgsz, self.imgsz), scaleup=False)])\n        transforms.append(\n            Format(\n                bbox_format=\"xywh\",\n                normalize=True,\n                return_mask=self.use_segments,\n                return_keypoint=self.use_keypoints,\n                return_obb=self.use_obb,\n                batch_idx=True,\n                mask_ratio=hyp.mask_ratio,\n                mask_overlap=hyp.overlap_mask,\n            )\n        )\n        return transforms\n\n    def close_mosaic(self, hyp):\n        \"\"\"Sets mosaic, copy_paste and mixup options to 0.0 and builds transformations.\"\"\"\n        hyp.mosaic = 0.0  # set mosaic ratio=0.0\n        hyp.copy_paste = 0.0  # keep the same behavior as previous v8 close-mosaic\n        hyp.mixup = 0.0  # keep the same behavior as previous v8 close-mosaic\n        self.transforms = self.build_transforms(hyp)\n\n    def update_labels_info(self, label):\n        \"\"\"Custom your label format here.\"\"\"\n        # NOTE: cls is not with bboxes now, classification and semantic segmentation need an independent cls label\n        # We can make it also support classification and semantic segmentation by add or remove some dict keys there.\n        bboxes = label.pop(\"bboxes\")\n        segments = label.pop(\"segments\", [])\n        keypoints = label.pop(\"keypoints\", None)\n        bbox_format = label.pop(\"bbox_format\")\n        normalized = label.pop(\"normalized\")\n\n        # NOTE: do NOT resample oriented boxes\n        segment_resamples = 100 if self.use_obb else 1000\n        if len(segments) &gt; 0:\n            # list[np.array(1000, 2)] * num_samples\n            # (N, 1000, 2)\n            segments = np.stack(resample_segments(segments, n=segment_resamples), axis=0)\n        else:\n            segments = np.zeros((0, segment_resamples, 2), dtype=np.float32)\n        label[\"instances\"] = Instances(bboxes, segments, keypoints, bbox_format=bbox_format, normalized=normalized)\n        return label\n\n    @staticmethod\n    def collate_fn(batch):\n        \"\"\"Collates data samples into batches.\"\"\"\n        new_batch = {}\n        keys = batch[0].keys()\n        values = list(zip(*[list(b.values()) for b in batch]))\n        for i, k in enumerate(keys):\n            value = values[i]\n            if k == \"img\":\n                value = torch.stack(value, 0)\n            if k in [\"masks\", \"keypoints\", \"bboxes\", \"cls\", \"segments\", \"obb\"]:\n                value = torch.cat(value, 0)\n            new_batch[k] = value\n        new_batch[\"batch_idx\"] = list(new_batch[\"batch_idx\"])\n        for i in range(len(new_batch[\"batch_idx\"])):\n            new_batch[\"batch_idx\"][i] += i  # add target image index for build_targets()\n        new_batch[\"batch_idx\"] = torch.cat(new_batch[\"batch_idx\"], 0)\n        return new_batch\n</code></pre>"},{"location":"reference/data/dataset/#ultralytics.data.dataset.YOLODataset.__init__","title":"<code>__init__(*args, data=None, task='detect', **kwargs)</code>","text":"<p>Initializes the YOLODataset with optional configurations for segments and keypoints.</p> Source code in <code>ultralytics/data/dataset.py</code> <pre><code>def __init__(self, *args, data=None, task=\"detect\", **kwargs):\n    \"\"\"Initializes the YOLODataset with optional configurations for segments and keypoints.\"\"\"\n    self.use_segments = task == \"segment\"\n    self.use_keypoints = task == \"pose\"\n    self.use_obb = task == \"obb\"\n    self.data = data\n    assert not (self.use_segments and self.use_keypoints), \"Can not use both segments and keypoints.\"\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"reference/data/dataset/#ultralytics.data.dataset.YOLODataset.build_transforms","title":"<code>build_transforms(hyp=None)</code>","text":"<p>Builds and appends transforms to the list.</p> Source code in <code>ultralytics/data/dataset.py</code> <pre><code>def build_transforms(self, hyp=None):\n    \"\"\"Builds and appends transforms to the list.\"\"\"\n    if self.augment:\n        hyp.mosaic = hyp.mosaic if self.augment and not self.rect else 0.0\n        hyp.mixup = hyp.mixup if self.augment and not self.rect else 0.0\n        transforms = v8_transforms(self, self.imgsz, hyp)\n    else:\n        transforms = Compose([LetterBox(new_shape=(self.imgsz, self.imgsz), scaleup=False)])\n    transforms.append(\n        Format(\n            bbox_format=\"xywh\",\n            normalize=True,\n            return_mask=self.use_segments,\n            return_keypoint=self.use_keypoints,\n            return_obb=self.use_obb,\n            batch_idx=True,\n            mask_ratio=hyp.mask_ratio,\n            mask_overlap=hyp.overlap_mask,\n        )\n    )\n    return transforms\n</code></pre>"},{"location":"reference/data/dataset/#ultralytics.data.dataset.YOLODataset.cache_labels","title":"<code>cache_labels(path=Path('./labels.cache'))</code>","text":"<p>Cache dataset labels, check images and read shapes.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>path where to save the cache file (default: Path('./labels.cache')).</p> <code>Path('./labels.cache')</code> <p>Returns:     (dict): labels.</p> Source code in <code>ultralytics/data/dataset.py</code> <pre><code>def cache_labels(self, path=Path(\"./labels.cache\")):\n    \"\"\"\n    Cache dataset labels, check images and read shapes.\n\n    Args:\n        path (Path): path where to save the cache file (default: Path('./labels.cache')).\n    Returns:\n        (dict): labels.\n    \"\"\"\n    x = {\"labels\": []}\n    nm, nf, ne, nc, msgs = 0, 0, 0, 0, []  # number missing, found, empty, corrupt, messages\n    desc = f\"{self.prefix}Scanning {path.parent / path.stem}...\"\n    total = len(self.im_files)\n    nkpt, ndim = self.data.get(\"kpt_shape\", (0, 0))\n    if self.use_keypoints and (nkpt &lt;= 0 or ndim not in (2, 3)):\n        raise ValueError(\n            \"'kpt_shape' in data.yaml missing or incorrect. Should be a list with [number of \"\n            \"keypoints, number of dims (2 for x,y or 3 for x,y,visible)], i.e. 'kpt_shape: [17, 3]'\"\n        )\n    with ThreadPool(NUM_THREADS) as pool:\n        results = pool.imap(\n            func=verify_image_label,\n            iterable=zip(\n                self.im_files,\n                self.label_files,\n                repeat(self.prefix),\n                repeat(self.use_keypoints),\n                repeat(len(self.data[\"names\"])),\n                repeat(nkpt),\n                repeat(ndim),\n            ),\n        )\n        pbar = TQDM(results, desc=desc, total=total)\n        for im_file, lb, shape, segments, keypoint, nm_f, nf_f, ne_f, nc_f, msg in pbar:\n            nm += nm_f\n            nf += nf_f\n            ne += ne_f\n            nc += nc_f\n            if im_file:\n                x[\"labels\"].append(\n                    dict(\n                        im_file=im_file,\n                        shape=shape,\n                        cls=lb[:, 0:1],  # n, 1\n                        bboxes=lb[:, 1:],  # n, 4\n                        segments=segments,\n                        keypoints=keypoint,\n                        normalized=True,\n                        bbox_format=\"xywh\",\n                    )\n                )\n            if msg:\n                msgs.append(msg)\n            pbar.desc = f\"{desc} {nf} images, {nm + ne} backgrounds, {nc} corrupt\"\n        pbar.close()\n\n    if msgs:\n        LOGGER.info(\"\\n\".join(msgs))\n    if nf == 0:\n        LOGGER.warning(f\"{self.prefix}WARNING \u26a0\ufe0f No labels found in {path}. {HELP_URL}\")\n    x[\"hash\"] = get_hash(self.label_files + self.im_files)\n    x[\"results\"] = nf, nm, ne, nc, len(self.im_files)\n    x[\"msgs\"] = msgs  # warnings\n    save_dataset_cache_file(self.prefix, path, x)\n    return x\n</code></pre>"},{"location":"reference/data/dataset/#ultralytics.data.dataset.YOLODataset.close_mosaic","title":"<code>close_mosaic(hyp)</code>","text":"<p>Sets mosaic, copy_paste and mixup options to 0.0 and builds transformations.</p> Source code in <code>ultralytics/data/dataset.py</code> <pre><code>def close_mosaic(self, hyp):\n    \"\"\"Sets mosaic, copy_paste and mixup options to 0.0 and builds transformations.\"\"\"\n    hyp.mosaic = 0.0  # set mosaic ratio=0.0\n    hyp.copy_paste = 0.0  # keep the same behavior as previous v8 close-mosaic\n    hyp.mixup = 0.0  # keep the same behavior as previous v8 close-mosaic\n    self.transforms = self.build_transforms(hyp)\n</code></pre>"},{"location":"reference/data/dataset/#ultralytics.data.dataset.YOLODataset.collate_fn","title":"<code>collate_fn(batch)</code>  <code>staticmethod</code>","text":"<p>Collates data samples into batches.</p> Source code in <code>ultralytics/data/dataset.py</code> <pre><code>@staticmethod\ndef collate_fn(batch):\n    \"\"\"Collates data samples into batches.\"\"\"\n    new_batch = {}\n    keys = batch[0].keys()\n    values = list(zip(*[list(b.values()) for b in batch]))\n    for i, k in enumerate(keys):\n        value = values[i]\n        if k == \"img\":\n            value = torch.stack(value, 0)\n        if k in [\"masks\", \"keypoints\", \"bboxes\", \"cls\", \"segments\", \"obb\"]:\n            value = torch.cat(value, 0)\n        new_batch[k] = value\n    new_batch[\"batch_idx\"] = list(new_batch[\"batch_idx\"])\n    for i in range(len(new_batch[\"batch_idx\"])):\n        new_batch[\"batch_idx\"][i] += i  # add target image index for build_targets()\n    new_batch[\"batch_idx\"] = torch.cat(new_batch[\"batch_idx\"], 0)\n    return new_batch\n</code></pre>"},{"location":"reference/data/dataset/#ultralytics.data.dataset.YOLODataset.get_labels","title":"<code>get_labels()</code>","text":"<p>Returns dictionary of labels for YOLO training.</p> Source code in <code>ultralytics/data/dataset.py</code> <pre><code>def get_labels(self):\n    \"\"\"Returns dictionary of labels for YOLO training.\"\"\"\n    self.label_files = img2label_paths(self.im_files)\n    cache_path = Path(self.label_files[0]).parent.with_suffix(\".cache\")\n    try:\n        cache, exists = load_dataset_cache_file(cache_path), True  # attempt to load a *.cache file\n        assert cache[\"version\"] == DATASET_CACHE_VERSION  # matches current version\n        assert cache[\"hash\"] == get_hash(self.label_files + self.im_files)  # identical hash\n    except (FileNotFoundError, AssertionError, AttributeError):\n        cache, exists = self.cache_labels(cache_path), False  # run cache ops\n\n    # Display cache\n    nf, nm, ne, nc, n = cache.pop(\"results\")  # found, missing, empty, corrupt, total\n    if exists and LOCAL_RANK in (-1, 0):\n        d = f\"Scanning {cache_path}... {nf} images, {nm + ne} backgrounds, {nc} corrupt\"\n        TQDM(None, desc=self.prefix + d, total=n, initial=n)  # display results\n        if cache[\"msgs\"]:\n            LOGGER.info(\"\\n\".join(cache[\"msgs\"]))  # display warnings\n\n    # Read cache\n    [cache.pop(k) for k in (\"hash\", \"version\", \"msgs\")]  # remove items\n    labels = cache[\"labels\"]\n    if not labels:\n        LOGGER.warning(f\"WARNING \u26a0\ufe0f No images found in {cache_path}, training may not work correctly. {HELP_URL}\")\n    self.im_files = [lb[\"im_file\"] for lb in labels]  # update im_files\n\n    # Check if the dataset is all boxes or all segments\n    lengths = ((len(lb[\"cls\"]), len(lb[\"bboxes\"]), len(lb[\"segments\"])) for lb in labels)\n    len_cls, len_boxes, len_segments = (sum(x) for x in zip(*lengths))\n    if len_segments and len_boxes != len_segments:\n        LOGGER.warning(\n            f\"WARNING \u26a0\ufe0f Box and segment counts should be equal, but got len(segments) = {len_segments}, \"\n            f\"len(boxes) = {len_boxes}. To resolve this only boxes will be used and all segments will be removed. \"\n            \"To avoid this please supply either a detect or segment dataset, not a detect-segment mixed dataset.\"\n        )\n        for lb in labels:\n            lb[\"segments\"] = []\n    if len_cls == 0:\n        LOGGER.warning(f\"WARNING \u26a0\ufe0f No labels found in {cache_path}, training may not work correctly. {HELP_URL}\")\n    return labels\n</code></pre>"},{"location":"reference/data/dataset/#ultralytics.data.dataset.YOLODataset.update_labels_info","title":"<code>update_labels_info(label)</code>","text":"<p>Custom your label format here.</p> Source code in <code>ultralytics/data/dataset.py</code> <pre><code>def update_labels_info(self, label):\n    \"\"\"Custom your label format here.\"\"\"\n    # NOTE: cls is not with bboxes now, classification and semantic segmentation need an independent cls label\n    # We can make it also support classification and semantic segmentation by add or remove some dict keys there.\n    bboxes = label.pop(\"bboxes\")\n    segments = label.pop(\"segments\", [])\n    keypoints = label.pop(\"keypoints\", None)\n    bbox_format = label.pop(\"bbox_format\")\n    normalized = label.pop(\"normalized\")\n\n    # NOTE: do NOT resample oriented boxes\n    segment_resamples = 100 if self.use_obb else 1000\n    if len(segments) &gt; 0:\n        # list[np.array(1000, 2)] * num_samples\n        # (N, 1000, 2)\n        segments = np.stack(resample_segments(segments, n=segment_resamples), axis=0)\n    else:\n        segments = np.zeros((0, segment_resamples, 2), dtype=np.float32)\n    label[\"instances\"] = Instances(bboxes, segments, keypoints, bbox_format=bbox_format, normalized=normalized)\n    return label\n</code></pre>"},{"location":"reference/data/dataset/#ultralytics.data.dataset.ClassificationDataset","title":"<code>ultralytics.data.dataset.ClassificationDataset</code>","text":"<p>             Bases: <code>ImageFolder</code></p> <p>YOLO Classification Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>str</code> <p>Dataset path.</p> required <p>Attributes:</p> Name Type Description <code>cache_ram</code> <code>bool</code> <p>True if images should be cached in RAM, False otherwise.</p> <code>cache_disk</code> <code>bool</code> <p>True if images should be cached on disk, False otherwise.</p> <code>samples</code> <code>list</code> <p>List of samples containing file, index, npy, and im.</p> <code>torch_transforms</code> <code>callable</code> <p>torchvision transforms applied to the dataset.</p> <code>album_transforms</code> <code>callable</code> <p>Albumentations transforms applied to the dataset if augment is True.</p> Source code in <code>ultralytics/data/dataset.py</code> <pre><code>class ClassificationDataset(torchvision.datasets.ImageFolder):\n    \"\"\"\n    YOLO Classification Dataset.\n\n    Args:\n        root (str): Dataset path.\n\n    Attributes:\n        cache_ram (bool): True if images should be cached in RAM, False otherwise.\n        cache_disk (bool): True if images should be cached on disk, False otherwise.\n        samples (list): List of samples containing file, index, npy, and im.\n        torch_transforms (callable): torchvision transforms applied to the dataset.\n        album_transforms (callable, optional): Albumentations transforms applied to the dataset if augment is True.\n    \"\"\"\n\n    def __init__(self, root, args, augment=False, cache=False, prefix=\"\"):\n        \"\"\"\n        Initialize YOLO object with root, image size, augmentations, and cache settings.\n\n        Args:\n            root (str): Dataset path.\n            args (Namespace): Argument parser containing dataset related settings.\n            augment (bool, optional): True if dataset should be augmented, False otherwise. Defaults to False.\n            cache (bool | str | optional): Cache setting, can be True, False, 'ram' or 'disk'. Defaults to False.\n        \"\"\"\n        super().__init__(root=root)\n        if augment and args.fraction &lt; 1.0:  # reduce training fraction\n            self.samples = self.samples[: round(len(self.samples) * args.fraction)]\n        self.prefix = colorstr(f\"{prefix}: \") if prefix else \"\"\n        self.cache_ram = cache is True or cache == \"ram\"\n        self.cache_disk = cache == \"disk\"\n        self.samples = self.verify_images()  # filter out bad images\n        self.samples = [list(x) + [Path(x[0]).with_suffix(\".npy\"), None] for x in self.samples]  # file, index, npy, im\n        scale = (1.0 - args.scale, 1.0)  # (0.08, 1.0)\n        self.torch_transforms = (\n            classify_augmentations(\n                size=args.imgsz,\n                scale=scale,\n                hflip=args.fliplr,\n                vflip=args.flipud,\n                erasing=args.erasing,\n                auto_augment=args.auto_augment,\n                hsv_h=args.hsv_h,\n                hsv_s=args.hsv_s,\n                hsv_v=args.hsv_v,\n            )\n            if augment\n            else classify_transforms(size=args.imgsz, crop_fraction=args.crop_fraction)\n        )\n\n    def __getitem__(self, i):\n        \"\"\"Returns subset of data and targets corresponding to given indices.\"\"\"\n        f, j, fn, im = self.samples[i]  # filename, index, filename.with_suffix('.npy'), image\n        if self.cache_ram and im is None:\n            im = self.samples[i][3] = cv2.imread(f)\n        elif self.cache_disk:\n            if not fn.exists():  # load npy\n                np.save(fn.as_posix(), cv2.imread(f), allow_pickle=False)\n            im = np.load(fn)\n        else:  # read image\n            im = cv2.imread(f)  # BGR\n        # Convert NumPy array to PIL image\n        im = Image.fromarray(cv2.cvtColor(im, cv2.COLOR_BGR2RGB))\n        sample = self.torch_transforms(im)\n        return {\"img\": sample, \"cls\": j}\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the total number of samples in the dataset.\"\"\"\n        return len(self.samples)\n\n    def verify_images(self):\n        \"\"\"Verify all images in dataset.\"\"\"\n        desc = f\"{self.prefix}Scanning {self.root}...\"\n        path = Path(self.root).with_suffix(\".cache\")  # *.cache file path\n\n        with contextlib.suppress(FileNotFoundError, AssertionError, AttributeError):\n            cache = load_dataset_cache_file(path)  # attempt to load a *.cache file\n            assert cache[\"version\"] == DATASET_CACHE_VERSION  # matches current version\n            assert cache[\"hash\"] == get_hash([x[0] for x in self.samples])  # identical hash\n            nf, nc, n, samples = cache.pop(\"results\")  # found, missing, empty, corrupt, total\n            if LOCAL_RANK in (-1, 0):\n                d = f\"{desc} {nf} images, {nc} corrupt\"\n                TQDM(None, desc=d, total=n, initial=n)\n                if cache[\"msgs\"]:\n                    LOGGER.info(\"\\n\".join(cache[\"msgs\"]))  # display warnings\n            return samples\n\n        # Run scan if *.cache retrieval failed\n        nf, nc, msgs, samples, x = 0, 0, [], [], {}\n        with ThreadPool(NUM_THREADS) as pool:\n            results = pool.imap(func=verify_image, iterable=zip(self.samples, repeat(self.prefix)))\n            pbar = TQDM(results, desc=desc, total=len(self.samples))\n            for sample, nf_f, nc_f, msg in pbar:\n                if nf_f:\n                    samples.append(sample)\n                if msg:\n                    msgs.append(msg)\n                nf += nf_f\n                nc += nc_f\n                pbar.desc = f\"{desc} {nf} images, {nc} corrupt\"\n            pbar.close()\n        if msgs:\n            LOGGER.info(\"\\n\".join(msgs))\n        x[\"hash\"] = get_hash([x[0] for x in self.samples])\n        x[\"results\"] = nf, nc, len(samples), samples\n        x[\"msgs\"] = msgs  # warnings\n        save_dataset_cache_file(self.prefix, path, x)\n        return samples\n</code></pre>"},{"location":"reference/data/dataset/#ultralytics.data.dataset.ClassificationDataset.__getitem__","title":"<code>__getitem__(i)</code>","text":"<p>Returns subset of data and targets corresponding to given indices.</p> Source code in <code>ultralytics/data/dataset.py</code> <pre><code>def __getitem__(self, i):\n    \"\"\"Returns subset of data and targets corresponding to given indices.\"\"\"\n    f, j, fn, im = self.samples[i]  # filename, index, filename.with_suffix('.npy'), image\n    if self.cache_ram and im is None:\n        im = self.samples[i][3] = cv2.imread(f)\n    elif self.cache_disk:\n        if not fn.exists():  # load npy\n            np.save(fn.as_posix(), cv2.imread(f), allow_pickle=False)\n        im = np.load(fn)\n    else:  # read image\n        im = cv2.imread(f)  # BGR\n    # Convert NumPy array to PIL image\n    im = Image.fromarray(cv2.cvtColor(im, cv2.COLOR_BGR2RGB))\n    sample = self.torch_transforms(im)\n    return {\"img\": sample, \"cls\": j}\n</code></pre>"},{"location":"reference/data/dataset/#ultralytics.data.dataset.ClassificationDataset.__init__","title":"<code>__init__(root, args, augment=False, cache=False, prefix='')</code>","text":"<p>Initialize YOLO object with root, image size, augmentations, and cache settings.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>str</code> <p>Dataset path.</p> required <code>args</code> <code>Namespace</code> <p>Argument parser containing dataset related settings.</p> required <code>augment</code> <code>bool</code> <p>True if dataset should be augmented, False otherwise. Defaults to False.</p> <code>False</code> <code>cache</code> <code>bool | str | optional</code> <p>Cache setting, can be True, False, 'ram' or 'disk'. Defaults to False.</p> <code>False</code> Source code in <code>ultralytics/data/dataset.py</code> <pre><code>def __init__(self, root, args, augment=False, cache=False, prefix=\"\"):\n    \"\"\"\n    Initialize YOLO object with root, image size, augmentations, and cache settings.\n\n    Args:\n        root (str): Dataset path.\n        args (Namespace): Argument parser containing dataset related settings.\n        augment (bool, optional): True if dataset should be augmented, False otherwise. Defaults to False.\n        cache (bool | str | optional): Cache setting, can be True, False, 'ram' or 'disk'. Defaults to False.\n    \"\"\"\n    super().__init__(root=root)\n    if augment and args.fraction &lt; 1.0:  # reduce training fraction\n        self.samples = self.samples[: round(len(self.samples) * args.fraction)]\n    self.prefix = colorstr(f\"{prefix}: \") if prefix else \"\"\n    self.cache_ram = cache is True or cache == \"ram\"\n    self.cache_disk = cache == \"disk\"\n    self.samples = self.verify_images()  # filter out bad images\n    self.samples = [list(x) + [Path(x[0]).with_suffix(\".npy\"), None] for x in self.samples]  # file, index, npy, im\n    scale = (1.0 - args.scale, 1.0)  # (0.08, 1.0)\n    self.torch_transforms = (\n        classify_augmentations(\n            size=args.imgsz,\n            scale=scale,\n            hflip=args.fliplr,\n            vflip=args.flipud,\n            erasing=args.erasing,\n            auto_augment=args.auto_augment,\n            hsv_h=args.hsv_h,\n            hsv_s=args.hsv_s,\n            hsv_v=args.hsv_v,\n        )\n        if augment\n        else classify_transforms(size=args.imgsz, crop_fraction=args.crop_fraction)\n    )\n</code></pre>"},{"location":"reference/data/dataset/#ultralytics.data.dataset.ClassificationDataset.__len__","title":"<code>__len__()</code>","text":"<p>Return the total number of samples in the dataset.</p> Source code in <code>ultralytics/data/dataset.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the total number of samples in the dataset.\"\"\"\n    return len(self.samples)\n</code></pre>"},{"location":"reference/data/dataset/#ultralytics.data.dataset.ClassificationDataset.verify_images","title":"<code>verify_images()</code>","text":"<p>Verify all images in dataset.</p> Source code in <code>ultralytics/data/dataset.py</code> <pre><code>def verify_images(self):\n    \"\"\"Verify all images in dataset.\"\"\"\n    desc = f\"{self.prefix}Scanning {self.root}...\"\n    path = Path(self.root).with_suffix(\".cache\")  # *.cache file path\n\n    with contextlib.suppress(FileNotFoundError, AssertionError, AttributeError):\n        cache = load_dataset_cache_file(path)  # attempt to load a *.cache file\n        assert cache[\"version\"] == DATASET_CACHE_VERSION  # matches current version\n        assert cache[\"hash\"] == get_hash([x[0] for x in self.samples])  # identical hash\n        nf, nc, n, samples = cache.pop(\"results\")  # found, missing, empty, corrupt, total\n        if LOCAL_RANK in (-1, 0):\n            d = f\"{desc} {nf} images, {nc} corrupt\"\n            TQDM(None, desc=d, total=n, initial=n)\n            if cache[\"msgs\"]:\n                LOGGER.info(\"\\n\".join(cache[\"msgs\"]))  # display warnings\n        return samples\n\n    # Run scan if *.cache retrieval failed\n    nf, nc, msgs, samples, x = 0, 0, [], [], {}\n    with ThreadPool(NUM_THREADS) as pool:\n        results = pool.imap(func=verify_image, iterable=zip(self.samples, repeat(self.prefix)))\n        pbar = TQDM(results, desc=desc, total=len(self.samples))\n        for sample, nf_f, nc_f, msg in pbar:\n            if nf_f:\n                samples.append(sample)\n            if msg:\n                msgs.append(msg)\n            nf += nf_f\n            nc += nc_f\n            pbar.desc = f\"{desc} {nf} images, {nc} corrupt\"\n        pbar.close()\n    if msgs:\n        LOGGER.info(\"\\n\".join(msgs))\n    x[\"hash\"] = get_hash([x[0] for x in self.samples])\n    x[\"results\"] = nf, nc, len(samples), samples\n    x[\"msgs\"] = msgs  # warnings\n    save_dataset_cache_file(self.prefix, path, x)\n    return samples\n</code></pre>"},{"location":"reference/data/dataset/#ultralytics.data.dataset.SemanticDataset","title":"<code>ultralytics.data.dataset.SemanticDataset</code>","text":"<p>             Bases: <code>BaseDataset</code></p> <p>Semantic Segmentation Dataset.</p> <p>This class is responsible for handling datasets used for semantic segmentation tasks. It inherits functionalities from the BaseDataset class.</p> Note <p>This class is currently a placeholder and needs to be populated with methods and attributes for supporting semantic segmentation tasks.</p> Source code in <code>ultralytics/data/dataset.py</code> <pre><code>class SemanticDataset(BaseDataset):\n    \"\"\"\n    Semantic Segmentation Dataset.\n\n    This class is responsible for handling datasets used for semantic segmentation tasks. It inherits functionalities\n    from the BaseDataset class.\n\n    Note:\n        This class is currently a placeholder and needs to be populated with methods and attributes for supporting\n        semantic segmentation tasks.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize a SemanticDataset object.\"\"\"\n        super().__init__()\n</code></pre>"},{"location":"reference/data/dataset/#ultralytics.data.dataset.SemanticDataset.__init__","title":"<code>__init__()</code>","text":"<p>Initialize a SemanticDataset object.</p> Source code in <code>ultralytics/data/dataset.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize a SemanticDataset object.\"\"\"\n    super().__init__()\n</code></pre>"},{"location":"reference/data/dataset/#ultralytics.data.dataset.load_dataset_cache_file","title":"<code>ultralytics.data.dataset.load_dataset_cache_file(path)</code>","text":"<p>Load an Ultralytics *.cache dictionary from path.</p> Source code in <code>ultralytics/data/dataset.py</code> <pre><code>def load_dataset_cache_file(path):\n    \"\"\"Load an Ultralytics *.cache dictionary from path.\"\"\"\n    import gc\n\n    gc.disable()  # reduce pickle load time https://github.com/ultralytics/ultralytics/pull/1585\n    cache = np.load(str(path), allow_pickle=True).item()  # load dict\n    gc.enable()\n    return cache\n</code></pre>"},{"location":"reference/data/dataset/#ultralytics.data.dataset.save_dataset_cache_file","title":"<code>ultralytics.data.dataset.save_dataset_cache_file(prefix, path, x)</code>","text":"<p>Save an Ultralytics dataset *.cache dictionary x to path.</p> Source code in <code>ultralytics/data/dataset.py</code> <pre><code>def save_dataset_cache_file(prefix, path, x):\n    \"\"\"Save an Ultralytics dataset *.cache dictionary x to path.\"\"\"\n    x[\"version\"] = DATASET_CACHE_VERSION  # add cache version\n    if is_dir_writeable(path.parent):\n        if path.exists():\n            path.unlink()  # remove *.cache file if exists\n        np.save(str(path), x)  # save cache for next time\n        path.with_suffix(\".cache.npy\").rename(path)  # remove .npy suffix\n        LOGGER.info(f\"{prefix}New cache created: {path}\")\n    else:\n        LOGGER.warning(f\"{prefix}WARNING \u26a0\ufe0f Cache directory {path.parent} is not writeable, cache not saved.\")\n</code></pre>"},{"location":"reference/data/loaders/","title":"Reference for <code>ultralytics/data/loaders.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/loaders.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.SourceTypes","title":"<code>ultralytics.data.loaders.SourceTypes</code>  <code>dataclass</code>","text":"<p>Class to represent various types of input sources for predictions.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>@dataclass\nclass SourceTypes:\n    \"\"\"Class to represent various types of input sources for predictions.\"\"\"\n\n    webcam: bool = False\n    screenshot: bool = False\n    from_img: bool = False\n    tensor: bool = False\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.LoadStreams","title":"<code>ultralytics.data.loaders.LoadStreams</code>","text":"<p>Stream Loader for various types of video streams.</p> <p>Suitable for use with <code>yolo predict source='rtsp://example.com/media.mp4'</code>, supports RTSP, RTMP, HTTP, and TCP streams.</p> <p>Attributes:</p> Name Type Description <code>sources</code> <code>str</code> <p>The source input paths or URLs for the video streams.</p> <code>imgsz</code> <code>int</code> <p>The image size for processing, defaults to 640.</p> <code>vid_stride</code> <code>int</code> <p>Video frame-rate stride, defaults to 1.</p> <code>buffer</code> <code>bool</code> <p>Whether to buffer input streams, defaults to False.</p> <code>running</code> <code>bool</code> <p>Flag to indicate if the streaming thread is running.</p> <code>mode</code> <code>str</code> <p>Set to 'stream' indicating real-time capture.</p> <code>imgs</code> <code>list</code> <p>List of image frames for each stream.</p> <code>fps</code> <code>list</code> <p>List of FPS for each stream.</p> <code>frames</code> <code>list</code> <p>List of total frames for each stream.</p> <code>threads</code> <code>list</code> <p>List of threads for each stream.</p> <code>shape</code> <code>list</code> <p>List of shapes for each stream.</p> <code>caps</code> <code>list</code> <p>List of cv2.VideoCapture objects for each stream.</p> <code>bs</code> <code>int</code> <p>Batch size for processing.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initialize the stream loader.</p> <code>update</code> <p>Read stream frames in daemon thread.</p> <code>close</code> <p>Close stream loader and release resources.</p> <code>__iter__</code> <p>Returns an iterator object for the class.</p> <code>__next__</code> <p>Returns source paths, transformed, and original images for processing.</p> <code>__len__</code> <p>Return the length of the sources object.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>class LoadStreams:\n    \"\"\"\n    Stream Loader for various types of video streams.\n\n    Suitable for use with `yolo predict source='rtsp://example.com/media.mp4'`, supports RTSP, RTMP, HTTP, and TCP streams.\n\n    Attributes:\n        sources (str): The source input paths or URLs for the video streams.\n        imgsz (int): The image size for processing, defaults to 640.\n        vid_stride (int): Video frame-rate stride, defaults to 1.\n        buffer (bool): Whether to buffer input streams, defaults to False.\n        running (bool): Flag to indicate if the streaming thread is running.\n        mode (str): Set to 'stream' indicating real-time capture.\n        imgs (list): List of image frames for each stream.\n        fps (list): List of FPS for each stream.\n        frames (list): List of total frames for each stream.\n        threads (list): List of threads for each stream.\n        shape (list): List of shapes for each stream.\n        caps (list): List of cv2.VideoCapture objects for each stream.\n        bs (int): Batch size for processing.\n\n    Methods:\n        __init__: Initialize the stream loader.\n        update: Read stream frames in daemon thread.\n        close: Close stream loader and release resources.\n        __iter__: Returns an iterator object for the class.\n        __next__: Returns source paths, transformed, and original images for processing.\n        __len__: Return the length of the sources object.\n    \"\"\"\n\n    def __init__(self, sources=\"file.streams\", imgsz=640, vid_stride=1, buffer=False):\n        \"\"\"Initialize instance variables and check for consistent input stream shapes.\"\"\"\n        torch.backends.cudnn.benchmark = True  # faster for fixed-size inference\n        self.buffer = buffer  # buffer input streams\n        self.running = True  # running flag for Thread\n        self.mode = \"stream\"\n        self.imgsz = imgsz\n        self.vid_stride = vid_stride  # video frame-rate stride\n\n        sources = Path(sources).read_text().rsplit() if os.path.isfile(sources) else [sources]\n        n = len(sources)\n        self.fps = [0] * n  # frames per second\n        self.frames = [0] * n\n        self.threads = [None] * n\n        self.caps = [None] * n  # video capture objects\n        self.imgs = [[] for _ in range(n)]  # images\n        self.shape = [[] for _ in range(n)]  # image shapes\n        self.sources = [ops.clean_str(x) for x in sources]  # clean source names for later\n        for i, s in enumerate(sources):  # index, source\n            # Start thread to read frames from video stream\n            st = f\"{i + 1}/{n}: {s}... \"\n            if urlparse(s).hostname in (\"www.youtube.com\", \"youtube.com\", \"youtu.be\"):  # if source is YouTube video\n                # YouTube format i.e. 'https://www.youtube.com/watch?v=Zgi9g1ksQHc' or 'https://youtu.be/LNwODJXcvt4'\n                s = get_best_youtube_url(s)\n            s = eval(s) if s.isnumeric() else s  # i.e. s = '0' local webcam\n            if s == 0 and (is_colab() or is_kaggle()):\n                raise NotImplementedError(\n                    \"'source=0' webcam not supported in Colab and Kaggle notebooks. \"\n                    \"Try running 'source=0' in a local environment.\"\n                )\n            self.caps[i] = cv2.VideoCapture(s)  # store video capture object\n            if not self.caps[i].isOpened():\n                raise ConnectionError(f\"{st}Failed to open {s}\")\n            w = int(self.caps[i].get(cv2.CAP_PROP_FRAME_WIDTH))\n            h = int(self.caps[i].get(cv2.CAP_PROP_FRAME_HEIGHT))\n            fps = self.caps[i].get(cv2.CAP_PROP_FPS)  # warning: may return 0 or nan\n            self.frames[i] = max(int(self.caps[i].get(cv2.CAP_PROP_FRAME_COUNT)), 0) or float(\n                \"inf\"\n            )  # infinite stream fallback\n            self.fps[i] = max((fps if math.isfinite(fps) else 0) % 100, 0) or 30  # 30 FPS fallback\n\n            success, im = self.caps[i].read()  # guarantee first frame\n            if not success or im is None:\n                raise ConnectionError(f\"{st}Failed to read images from {s}\")\n            self.imgs[i].append(im)\n            self.shape[i] = im.shape\n            self.threads[i] = Thread(target=self.update, args=([i, self.caps[i], s]), daemon=True)\n            LOGGER.info(f\"{st}Success \u2705 ({self.frames[i]} frames of shape {w}x{h} at {self.fps[i]:.2f} FPS)\")\n            self.threads[i].start()\n        LOGGER.info(\"\")  # newline\n\n        # Check for common shapes\n        self.bs = self.__len__()\n\n    def update(self, i, cap, stream):\n        \"\"\"Read stream `i` frames in daemon thread.\"\"\"\n        n, f = 0, self.frames[i]  # frame number, frame array\n        while self.running and cap.isOpened() and n &lt; (f - 1):\n            if len(self.imgs[i]) &lt; 30:  # keep a &lt;=30-image buffer\n                n += 1\n                cap.grab()  # .read() = .grab() followed by .retrieve()\n                if n % self.vid_stride == 0:\n                    success, im = cap.retrieve()\n                    if not success:\n                        im = np.zeros(self.shape[i], dtype=np.uint8)\n                        LOGGER.warning(\"WARNING \u26a0\ufe0f Video stream unresponsive, please check your IP camera connection.\")\n                        cap.open(stream)  # re-open stream if signal was lost\n                    if self.buffer:\n                        self.imgs[i].append(im)\n                    else:\n                        self.imgs[i] = [im]\n            else:\n                time.sleep(0.01)  # wait until the buffer is empty\n\n    def close(self):\n        \"\"\"Close stream loader and release resources.\"\"\"\n        self.running = False  # stop flag for Thread\n        for thread in self.threads:\n            if thread.is_alive():\n                thread.join(timeout=5)  # Add timeout\n        for cap in self.caps:  # Iterate through the stored VideoCapture objects\n            try:\n                cap.release()  # release video capture\n            except Exception as e:\n                LOGGER.warning(f\"WARNING \u26a0\ufe0f Could not release VideoCapture object: {e}\")\n        cv2.destroyAllWindows()\n\n    def __iter__(self):\n        \"\"\"Iterates through YOLO image feed and re-opens unresponsive streams.\"\"\"\n        self.count = -1\n        return self\n\n    def __next__(self):\n        \"\"\"Returns source paths, transformed and original images for processing.\"\"\"\n        self.count += 1\n\n        images = []\n        for i, x in enumerate(self.imgs):\n            # Wait until a frame is available in each buffer\n            while not x:\n                if not self.threads[i].is_alive() or cv2.waitKey(1) == ord(\"q\"):  # q to quit\n                    self.close()\n                    raise StopIteration\n                time.sleep(1 / min(self.fps))\n                x = self.imgs[i]\n                if not x:\n                    LOGGER.warning(f\"WARNING \u26a0\ufe0f Waiting for stream {i}\")\n\n            # Get and remove the first frame from imgs buffer\n            if self.buffer:\n                images.append(x.pop(0))\n\n            # Get the last frame, and clear the rest from the imgs buffer\n            else:\n                images.append(x.pop(-1) if x else np.zeros(self.shape[i], dtype=np.uint8))\n                x.clear()\n\n        return self.sources, images, None, \"\"\n\n    def __len__(self):\n        \"\"\"Return the length of the sources object.\"\"\"\n        return len(self.sources)  # 1E12 frames = 32 streams at 30 FPS for 30 years\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.LoadStreams.__init__","title":"<code>__init__(sources='file.streams', imgsz=640, vid_stride=1, buffer=False)</code>","text":"<p>Initialize instance variables and check for consistent input stream shapes.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>def __init__(self, sources=\"file.streams\", imgsz=640, vid_stride=1, buffer=False):\n    \"\"\"Initialize instance variables and check for consistent input stream shapes.\"\"\"\n    torch.backends.cudnn.benchmark = True  # faster for fixed-size inference\n    self.buffer = buffer  # buffer input streams\n    self.running = True  # running flag for Thread\n    self.mode = \"stream\"\n    self.imgsz = imgsz\n    self.vid_stride = vid_stride  # video frame-rate stride\n\n    sources = Path(sources).read_text().rsplit() if os.path.isfile(sources) else [sources]\n    n = len(sources)\n    self.fps = [0] * n  # frames per second\n    self.frames = [0] * n\n    self.threads = [None] * n\n    self.caps = [None] * n  # video capture objects\n    self.imgs = [[] for _ in range(n)]  # images\n    self.shape = [[] for _ in range(n)]  # image shapes\n    self.sources = [ops.clean_str(x) for x in sources]  # clean source names for later\n    for i, s in enumerate(sources):  # index, source\n        # Start thread to read frames from video stream\n        st = f\"{i + 1}/{n}: {s}... \"\n        if urlparse(s).hostname in (\"www.youtube.com\", \"youtube.com\", \"youtu.be\"):  # if source is YouTube video\n            # YouTube format i.e. 'https://www.youtube.com/watch?v=Zgi9g1ksQHc' or 'https://youtu.be/LNwODJXcvt4'\n            s = get_best_youtube_url(s)\n        s = eval(s) if s.isnumeric() else s  # i.e. s = '0' local webcam\n        if s == 0 and (is_colab() or is_kaggle()):\n            raise NotImplementedError(\n                \"'source=0' webcam not supported in Colab and Kaggle notebooks. \"\n                \"Try running 'source=0' in a local environment.\"\n            )\n        self.caps[i] = cv2.VideoCapture(s)  # store video capture object\n        if not self.caps[i].isOpened():\n            raise ConnectionError(f\"{st}Failed to open {s}\")\n        w = int(self.caps[i].get(cv2.CAP_PROP_FRAME_WIDTH))\n        h = int(self.caps[i].get(cv2.CAP_PROP_FRAME_HEIGHT))\n        fps = self.caps[i].get(cv2.CAP_PROP_FPS)  # warning: may return 0 or nan\n        self.frames[i] = max(int(self.caps[i].get(cv2.CAP_PROP_FRAME_COUNT)), 0) or float(\n            \"inf\"\n        )  # infinite stream fallback\n        self.fps[i] = max((fps if math.isfinite(fps) else 0) % 100, 0) or 30  # 30 FPS fallback\n\n        success, im = self.caps[i].read()  # guarantee first frame\n        if not success or im is None:\n            raise ConnectionError(f\"{st}Failed to read images from {s}\")\n        self.imgs[i].append(im)\n        self.shape[i] = im.shape\n        self.threads[i] = Thread(target=self.update, args=([i, self.caps[i], s]), daemon=True)\n        LOGGER.info(f\"{st}Success \u2705 ({self.frames[i]} frames of shape {w}x{h} at {self.fps[i]:.2f} FPS)\")\n        self.threads[i].start()\n    LOGGER.info(\"\")  # newline\n\n    # Check for common shapes\n    self.bs = self.__len__()\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.LoadStreams.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterates through YOLO image feed and re-opens unresponsive streams.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterates through YOLO image feed and re-opens unresponsive streams.\"\"\"\n    self.count = -1\n    return self\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.LoadStreams.__len__","title":"<code>__len__()</code>","text":"<p>Return the length of the sources object.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>def __len__(self):\n    \"\"\"Return the length of the sources object.\"\"\"\n    return len(self.sources)  # 1E12 frames = 32 streams at 30 FPS for 30 years\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.LoadStreams.__next__","title":"<code>__next__()</code>","text":"<p>Returns source paths, transformed and original images for processing.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>def __next__(self):\n    \"\"\"Returns source paths, transformed and original images for processing.\"\"\"\n    self.count += 1\n\n    images = []\n    for i, x in enumerate(self.imgs):\n        # Wait until a frame is available in each buffer\n        while not x:\n            if not self.threads[i].is_alive() or cv2.waitKey(1) == ord(\"q\"):  # q to quit\n                self.close()\n                raise StopIteration\n            time.sleep(1 / min(self.fps))\n            x = self.imgs[i]\n            if not x:\n                LOGGER.warning(f\"WARNING \u26a0\ufe0f Waiting for stream {i}\")\n\n        # Get and remove the first frame from imgs buffer\n        if self.buffer:\n            images.append(x.pop(0))\n\n        # Get the last frame, and clear the rest from the imgs buffer\n        else:\n            images.append(x.pop(-1) if x else np.zeros(self.shape[i], dtype=np.uint8))\n            x.clear()\n\n    return self.sources, images, None, \"\"\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.LoadStreams.close","title":"<code>close()</code>","text":"<p>Close stream loader and release resources.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>def close(self):\n    \"\"\"Close stream loader and release resources.\"\"\"\n    self.running = False  # stop flag for Thread\n    for thread in self.threads:\n        if thread.is_alive():\n            thread.join(timeout=5)  # Add timeout\n    for cap in self.caps:  # Iterate through the stored VideoCapture objects\n        try:\n            cap.release()  # release video capture\n        except Exception as e:\n            LOGGER.warning(f\"WARNING \u26a0\ufe0f Could not release VideoCapture object: {e}\")\n    cv2.destroyAllWindows()\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.LoadStreams.update","title":"<code>update(i, cap, stream)</code>","text":"<p>Read stream <code>i</code> frames in daemon thread.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>def update(self, i, cap, stream):\n    \"\"\"Read stream `i` frames in daemon thread.\"\"\"\n    n, f = 0, self.frames[i]  # frame number, frame array\n    while self.running and cap.isOpened() and n &lt; (f - 1):\n        if len(self.imgs[i]) &lt; 30:  # keep a &lt;=30-image buffer\n            n += 1\n            cap.grab()  # .read() = .grab() followed by .retrieve()\n            if n % self.vid_stride == 0:\n                success, im = cap.retrieve()\n                if not success:\n                    im = np.zeros(self.shape[i], dtype=np.uint8)\n                    LOGGER.warning(\"WARNING \u26a0\ufe0f Video stream unresponsive, please check your IP camera connection.\")\n                    cap.open(stream)  # re-open stream if signal was lost\n                if self.buffer:\n                    self.imgs[i].append(im)\n                else:\n                    self.imgs[i] = [im]\n        else:\n            time.sleep(0.01)  # wait until the buffer is empty\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.LoadScreenshots","title":"<code>ultralytics.data.loaders.LoadScreenshots</code>","text":"<p>YOLOv8 screenshot dataloader.</p> <p>This class manages the loading of screenshot images for processing with YOLOv8. Suitable for use with <code>yolo predict source=screen</code>.</p> <p>Attributes:</p> Name Type Description <code>source</code> <code>str</code> <p>The source input indicating which screen to capture.</p> <code>imgsz</code> <code>int</code> <p>The image size for processing, defaults to 640.</p> <code>screen</code> <code>int</code> <p>The screen number to capture.</p> <code>left</code> <code>int</code> <p>The left coordinate for screen capture area.</p> <code>top</code> <code>int</code> <p>The top coordinate for screen capture area.</p> <code>width</code> <code>int</code> <p>The width of the screen capture area.</p> <code>height</code> <code>int</code> <p>The height of the screen capture area.</p> <code>mode</code> <code>str</code> <p>Set to 'stream' indicating real-time capture.</p> <code>frame</code> <code>int</code> <p>Counter for captured frames.</p> <code>sct</code> <code>mss</code> <p>Screen capture object from <code>mss</code> library.</p> <code>bs</code> <code>int</code> <p>Batch size, set to 1.</p> <code>monitor</code> <code>dict</code> <p>Monitor configuration details.</p> <p>Methods:</p> Name Description <code>__iter__</code> <p>Returns an iterator object.</p> <code>__next__</code> <p>Captures the next screenshot and returns it.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>class LoadScreenshots:\n    \"\"\"\n    YOLOv8 screenshot dataloader.\n\n    This class manages the loading of screenshot images for processing with YOLOv8.\n    Suitable for use with `yolo predict source=screen`.\n\n    Attributes:\n        source (str): The source input indicating which screen to capture.\n        imgsz (int): The image size for processing, defaults to 640.\n        screen (int): The screen number to capture.\n        left (int): The left coordinate for screen capture area.\n        top (int): The top coordinate for screen capture area.\n        width (int): The width of the screen capture area.\n        height (int): The height of the screen capture area.\n        mode (str): Set to 'stream' indicating real-time capture.\n        frame (int): Counter for captured frames.\n        sct (mss.mss): Screen capture object from `mss` library.\n        bs (int): Batch size, set to 1.\n        monitor (dict): Monitor configuration details.\n\n    Methods:\n        __iter__: Returns an iterator object.\n        __next__: Captures the next screenshot and returns it.\n    \"\"\"\n\n    def __init__(self, source, imgsz=640):\n        \"\"\"Source = [screen_number left top width height] (pixels).\"\"\"\n        check_requirements(\"mss\")\n        import mss  # noqa\n\n        source, *params = source.split()\n        self.screen, left, top, width, height = 0, None, None, None, None  # default to full screen 0\n        if len(params) == 1:\n            self.screen = int(params[0])\n        elif len(params) == 4:\n            left, top, width, height = (int(x) for x in params)\n        elif len(params) == 5:\n            self.screen, left, top, width, height = (int(x) for x in params)\n        self.imgsz = imgsz\n        self.mode = \"stream\"\n        self.frame = 0\n        self.sct = mss.mss()\n        self.bs = 1\n\n        # Parse monitor shape\n        monitor = self.sct.monitors[self.screen]\n        self.top = monitor[\"top\"] if top is None else (monitor[\"top\"] + top)\n        self.left = monitor[\"left\"] if left is None else (monitor[\"left\"] + left)\n        self.width = width or monitor[\"width\"]\n        self.height = height or monitor[\"height\"]\n        self.monitor = {\"left\": self.left, \"top\": self.top, \"width\": self.width, \"height\": self.height}\n\n    def __iter__(self):\n        \"\"\"Returns an iterator of the object.\"\"\"\n        return self\n\n    def __next__(self):\n        \"\"\"mss screen capture: get raw pixels from the screen as np array.\"\"\"\n        im0 = np.asarray(self.sct.grab(self.monitor))[:, :, :3]  # BGRA to BGR\n        s = f\"screen {self.screen} (LTWH): {self.left},{self.top},{self.width},{self.height}: \"\n\n        self.frame += 1\n        return [str(self.screen)], [im0], None, s  # screen, img, vid_cap, string\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.LoadScreenshots.__init__","title":"<code>__init__(source, imgsz=640)</code>","text":"<p>Source = [screen_number left top width height] (pixels).</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>def __init__(self, source, imgsz=640):\n    \"\"\"Source = [screen_number left top width height] (pixels).\"\"\"\n    check_requirements(\"mss\")\n    import mss  # noqa\n\n    source, *params = source.split()\n    self.screen, left, top, width, height = 0, None, None, None, None  # default to full screen 0\n    if len(params) == 1:\n        self.screen = int(params[0])\n    elif len(params) == 4:\n        left, top, width, height = (int(x) for x in params)\n    elif len(params) == 5:\n        self.screen, left, top, width, height = (int(x) for x in params)\n    self.imgsz = imgsz\n    self.mode = \"stream\"\n    self.frame = 0\n    self.sct = mss.mss()\n    self.bs = 1\n\n    # Parse monitor shape\n    monitor = self.sct.monitors[self.screen]\n    self.top = monitor[\"top\"] if top is None else (monitor[\"top\"] + top)\n    self.left = monitor[\"left\"] if left is None else (monitor[\"left\"] + left)\n    self.width = width or monitor[\"width\"]\n    self.height = height or monitor[\"height\"]\n    self.monitor = {\"left\": self.left, \"top\": self.top, \"width\": self.width, \"height\": self.height}\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.LoadScreenshots.__iter__","title":"<code>__iter__()</code>","text":"<p>Returns an iterator of the object.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>def __iter__(self):\n    \"\"\"Returns an iterator of the object.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.LoadScreenshots.__next__","title":"<code>__next__()</code>","text":"<p>mss screen capture: get raw pixels from the screen as np array.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>def __next__(self):\n    \"\"\"mss screen capture: get raw pixels from the screen as np array.\"\"\"\n    im0 = np.asarray(self.sct.grab(self.monitor))[:, :, :3]  # BGRA to BGR\n    s = f\"screen {self.screen} (LTWH): {self.left},{self.top},{self.width},{self.height}: \"\n\n    self.frame += 1\n    return [str(self.screen)], [im0], None, s  # screen, img, vid_cap, string\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.LoadImages","title":"<code>ultralytics.data.loaders.LoadImages</code>","text":"<p>YOLOv8 image/video dataloader.</p> <p>This class manages the loading and pre-processing of image and video data for YOLOv8. It supports loading from various formats, including single image files, video files, and lists of image and video paths.</p> <p>Attributes:</p> Name Type Description <code>imgsz</code> <code>int</code> <p>Image size, defaults to 640.</p> <code>files</code> <code>list</code> <p>List of image and video file paths.</p> <code>nf</code> <code>int</code> <p>Total number of files (images and videos).</p> <code>video_flag</code> <code>list</code> <p>Flags indicating whether a file is a video (True) or an image (False).</p> <code>mode</code> <code>str</code> <p>Current mode, 'image' or 'video'.</p> <code>vid_stride</code> <code>int</code> <p>Stride for video frame-rate, defaults to 1.</p> <code>bs</code> <code>int</code> <p>Batch size, set to 1 for this class.</p> <code>cap</code> <code>VideoCapture</code> <p>Video capture object for OpenCV.</p> <code>frame</code> <code>int</code> <p>Frame counter for video.</p> <code>frames</code> <code>int</code> <p>Total number of frames in the video.</p> <code>count</code> <code>int</code> <p>Counter for iteration, initialized at 0 during <code>__iter__()</code>.</p> <p>Methods:</p> Name Description <code>_new_video</code> <p>Create a new cv2.VideoCapture object for a given video path.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>class LoadImages:\n    \"\"\"\n    YOLOv8 image/video dataloader.\n\n    This class manages the loading and pre-processing of image and video data for YOLOv8. It supports loading from\n    various formats, including single image files, video files, and lists of image and video paths.\n\n    Attributes:\n        imgsz (int): Image size, defaults to 640.\n        files (list): List of image and video file paths.\n        nf (int): Total number of files (images and videos).\n        video_flag (list): Flags indicating whether a file is a video (True) or an image (False).\n        mode (str): Current mode, 'image' or 'video'.\n        vid_stride (int): Stride for video frame-rate, defaults to 1.\n        bs (int): Batch size, set to 1 for this class.\n        cap (cv2.VideoCapture): Video capture object for OpenCV.\n        frame (int): Frame counter for video.\n        frames (int): Total number of frames in the video.\n        count (int): Counter for iteration, initialized at 0 during `__iter__()`.\n\n    Methods:\n        _new_video(path): Create a new cv2.VideoCapture object for a given video path.\n    \"\"\"\n\n    def __init__(self, path, imgsz=640, vid_stride=1):\n        \"\"\"Initialize the Dataloader and raise FileNotFoundError if file not found.\"\"\"\n        parent = None\n        if isinstance(path, str) and Path(path).suffix == \".txt\":  # *.txt file with img/vid/dir on each line\n            parent = Path(path).parent\n            path = Path(path).read_text().splitlines()  # list of sources\n        files = []\n        for p in sorted(path) if isinstance(path, (list, tuple)) else [path]:\n            a = str(Path(p).absolute())  # do not use .resolve() https://github.com/ultralytics/ultralytics/issues/2912\n            if \"*\" in a:\n                files.extend(sorted(glob.glob(a, recursive=True)))  # glob\n            elif os.path.isdir(a):\n                files.extend(sorted(glob.glob(os.path.join(a, \"*.*\"))))  # dir\n            elif os.path.isfile(a):\n                files.append(a)  # files (absolute or relative to CWD)\n            elif parent and (parent / p).is_file():\n                files.append(str((parent / p).absolute()))  # files (relative to *.txt file parent)\n            else:\n                raise FileNotFoundError(f\"{p} does not exist\")\n\n        images = [x for x in files if x.split(\".\")[-1].lower() in IMG_FORMATS]\n        videos = [x for x in files if x.split(\".\")[-1].lower() in VID_FORMATS]\n        ni, nv = len(images), len(videos)\n\n        self.imgsz = imgsz\n        self.files = images + videos\n        self.nf = ni + nv  # number of files\n        self.video_flag = [False] * ni + [True] * nv\n        self.mode = \"image\"\n        self.vid_stride = vid_stride  # video frame-rate stride\n        self.bs = 1\n        if any(videos):\n            self._new_video(videos[0])  # new video\n        else:\n            self.cap = None\n        if self.nf == 0:\n            raise FileNotFoundError(\n                f\"No images or videos found in {p}. \"\n                f\"Supported formats are:\\nimages: {IMG_FORMATS}\\nvideos: {VID_FORMATS}\"\n            )\n\n    def __iter__(self):\n        \"\"\"Returns an iterator object for VideoStream or ImageFolder.\"\"\"\n        self.count = 0\n        return self\n\n    def __next__(self):\n        \"\"\"Return next image, path and metadata from dataset.\"\"\"\n        if self.count == self.nf:\n            raise StopIteration\n        path = self.files[self.count]\n\n        if self.video_flag[self.count]:\n            # Read video\n            self.mode = \"video\"\n            for _ in range(self.vid_stride):\n                self.cap.grab()\n            success, im0 = self.cap.retrieve()\n            while not success:\n                self.count += 1\n                self.cap.release()\n                if self.count == self.nf:  # last video\n                    raise StopIteration\n                path = self.files[self.count]\n                self._new_video(path)\n                success, im0 = self.cap.read()\n\n            self.frame += 1\n            # im0 = self._cv2_rotate(im0)  # for use if cv2 autorotation is False\n            s = f\"video {self.count + 1}/{self.nf} ({self.frame}/{self.frames}) {path}: \"\n\n        else:\n            # Read image\n            self.count += 1\n            im0 = cv2.imread(path)  # BGR\n            if im0 is None:\n                raise FileNotFoundError(f\"Image Not Found {path}\")\n            s = f\"image {self.count}/{self.nf} {path}: \"\n\n        return [path], [im0], self.cap, s\n\n    def _new_video(self, path):\n        \"\"\"Create a new video capture object.\"\"\"\n        self.frame = 0\n        self.cap = cv2.VideoCapture(path)\n        self.frames = int(self.cap.get(cv2.CAP_PROP_FRAME_COUNT) / self.vid_stride)\n\n    def __len__(self):\n        \"\"\"Returns the number of files in the object.\"\"\"\n        return self.nf  # number of files\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.LoadImages.__init__","title":"<code>__init__(path, imgsz=640, vid_stride=1)</code>","text":"<p>Initialize the Dataloader and raise FileNotFoundError if file not found.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>def __init__(self, path, imgsz=640, vid_stride=1):\n    \"\"\"Initialize the Dataloader and raise FileNotFoundError if file not found.\"\"\"\n    parent = None\n    if isinstance(path, str) and Path(path).suffix == \".txt\":  # *.txt file with img/vid/dir on each line\n        parent = Path(path).parent\n        path = Path(path).read_text().splitlines()  # list of sources\n    files = []\n    for p in sorted(path) if isinstance(path, (list, tuple)) else [path]:\n        a = str(Path(p).absolute())  # do not use .resolve() https://github.com/ultralytics/ultralytics/issues/2912\n        if \"*\" in a:\n            files.extend(sorted(glob.glob(a, recursive=True)))  # glob\n        elif os.path.isdir(a):\n            files.extend(sorted(glob.glob(os.path.join(a, \"*.*\"))))  # dir\n        elif os.path.isfile(a):\n            files.append(a)  # files (absolute or relative to CWD)\n        elif parent and (parent / p).is_file():\n            files.append(str((parent / p).absolute()))  # files (relative to *.txt file parent)\n        else:\n            raise FileNotFoundError(f\"{p} does not exist\")\n\n    images = [x for x in files if x.split(\".\")[-1].lower() in IMG_FORMATS]\n    videos = [x for x in files if x.split(\".\")[-1].lower() in VID_FORMATS]\n    ni, nv = len(images), len(videos)\n\n    self.imgsz = imgsz\n    self.files = images + videos\n    self.nf = ni + nv  # number of files\n    self.video_flag = [False] * ni + [True] * nv\n    self.mode = \"image\"\n    self.vid_stride = vid_stride  # video frame-rate stride\n    self.bs = 1\n    if any(videos):\n        self._new_video(videos[0])  # new video\n    else:\n        self.cap = None\n    if self.nf == 0:\n        raise FileNotFoundError(\n            f\"No images or videos found in {p}. \"\n            f\"Supported formats are:\\nimages: {IMG_FORMATS}\\nvideos: {VID_FORMATS}\"\n        )\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.LoadImages.__iter__","title":"<code>__iter__()</code>","text":"<p>Returns an iterator object for VideoStream or ImageFolder.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>def __iter__(self):\n    \"\"\"Returns an iterator object for VideoStream or ImageFolder.\"\"\"\n    self.count = 0\n    return self\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.LoadImages.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of files in the object.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>def __len__(self):\n    \"\"\"Returns the number of files in the object.\"\"\"\n    return self.nf  # number of files\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.LoadImages.__next__","title":"<code>__next__()</code>","text":"<p>Return next image, path and metadata from dataset.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>def __next__(self):\n    \"\"\"Return next image, path and metadata from dataset.\"\"\"\n    if self.count == self.nf:\n        raise StopIteration\n    path = self.files[self.count]\n\n    if self.video_flag[self.count]:\n        # Read video\n        self.mode = \"video\"\n        for _ in range(self.vid_stride):\n            self.cap.grab()\n        success, im0 = self.cap.retrieve()\n        while not success:\n            self.count += 1\n            self.cap.release()\n            if self.count == self.nf:  # last video\n                raise StopIteration\n            path = self.files[self.count]\n            self._new_video(path)\n            success, im0 = self.cap.read()\n\n        self.frame += 1\n        # im0 = self._cv2_rotate(im0)  # for use if cv2 autorotation is False\n        s = f\"video {self.count + 1}/{self.nf} ({self.frame}/{self.frames}) {path}: \"\n\n    else:\n        # Read image\n        self.count += 1\n        im0 = cv2.imread(path)  # BGR\n        if im0 is None:\n            raise FileNotFoundError(f\"Image Not Found {path}\")\n        s = f\"image {self.count}/{self.nf} {path}: \"\n\n    return [path], [im0], self.cap, s\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.LoadPilAndNumpy","title":"<code>ultralytics.data.loaders.LoadPilAndNumpy</code>","text":"<p>Load images from PIL and Numpy arrays for batch processing.</p> <p>This class is designed to manage loading and pre-processing of image data from both PIL and Numpy formats. It performs basic validation and format conversion to ensure that the images are in the required format for downstream processing.</p> <p>Attributes:</p> Name Type Description <code>paths</code> <code>list</code> <p>List of image paths or autogenerated filenames.</p> <code>im0</code> <code>list</code> <p>List of images stored as Numpy arrays.</p> <code>imgsz</code> <code>int</code> <p>Image size, defaults to 640.</p> <code>mode</code> <code>str</code> <p>Type of data being processed, defaults to 'image'.</p> <code>bs</code> <code>int</code> <p>Batch size, equivalent to the length of <code>im0</code>.</p> <code>count</code> <code>int</code> <p>Counter for iteration, initialized at 0 during <code>__iter__()</code>.</p> <p>Methods:</p> Name Description <code>_single_check</code> <p>Validate and format a single image to a Numpy array.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>class LoadPilAndNumpy:\n    \"\"\"\n    Load images from PIL and Numpy arrays for batch processing.\n\n    This class is designed to manage loading and pre-processing of image data from both PIL and Numpy formats.\n    It performs basic validation and format conversion to ensure that the images are in the required format for\n    downstream processing.\n\n    Attributes:\n        paths (list): List of image paths or autogenerated filenames.\n        im0 (list): List of images stored as Numpy arrays.\n        imgsz (int): Image size, defaults to 640.\n        mode (str): Type of data being processed, defaults to 'image'.\n        bs (int): Batch size, equivalent to the length of `im0`.\n        count (int): Counter for iteration, initialized at 0 during `__iter__()`.\n\n    Methods:\n        _single_check(im): Validate and format a single image to a Numpy array.\n    \"\"\"\n\n    def __init__(self, im0, imgsz=640):\n        \"\"\"Initialize PIL and Numpy Dataloader.\"\"\"\n        if not isinstance(im0, list):\n            im0 = [im0]\n        self.paths = [getattr(im, \"filename\", f\"image{i}.jpg\") for i, im in enumerate(im0)]\n        self.im0 = [self._single_check(im) for im in im0]\n        self.imgsz = imgsz\n        self.mode = \"image\"\n        # Generate fake paths\n        self.bs = len(self.im0)\n\n    @staticmethod\n    def _single_check(im):\n        \"\"\"Validate and format an image to numpy array.\"\"\"\n        assert isinstance(im, (Image.Image, np.ndarray)), f\"Expected PIL/np.ndarray image type, but got {type(im)}\"\n        if isinstance(im, Image.Image):\n            if im.mode != \"RGB\":\n                im = im.convert(\"RGB\")\n            im = np.asarray(im)[:, :, ::-1]\n            im = np.ascontiguousarray(im)  # contiguous\n        return im\n\n    def __len__(self):\n        \"\"\"Returns the length of the 'im0' attribute.\"\"\"\n        return len(self.im0)\n\n    def __next__(self):\n        \"\"\"Returns batch paths, images, processed images, None, ''.\"\"\"\n        if self.count == 1:  # loop only once as it's batch inference\n            raise StopIteration\n        self.count += 1\n        return self.paths, self.im0, None, \"\"\n\n    def __iter__(self):\n        \"\"\"Enables iteration for class LoadPilAndNumpy.\"\"\"\n        self.count = 0\n        return self\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.LoadPilAndNumpy.__init__","title":"<code>__init__(im0, imgsz=640)</code>","text":"<p>Initialize PIL and Numpy Dataloader.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>def __init__(self, im0, imgsz=640):\n    \"\"\"Initialize PIL and Numpy Dataloader.\"\"\"\n    if not isinstance(im0, list):\n        im0 = [im0]\n    self.paths = [getattr(im, \"filename\", f\"image{i}.jpg\") for i, im in enumerate(im0)]\n    self.im0 = [self._single_check(im) for im in im0]\n    self.imgsz = imgsz\n    self.mode = \"image\"\n    # Generate fake paths\n    self.bs = len(self.im0)\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.LoadPilAndNumpy.__iter__","title":"<code>__iter__()</code>","text":"<p>Enables iteration for class LoadPilAndNumpy.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>def __iter__(self):\n    \"\"\"Enables iteration for class LoadPilAndNumpy.\"\"\"\n    self.count = 0\n    return self\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.LoadPilAndNumpy.__len__","title":"<code>__len__()</code>","text":"<p>Returns the length of the 'im0' attribute.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>def __len__(self):\n    \"\"\"Returns the length of the 'im0' attribute.\"\"\"\n    return len(self.im0)\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.LoadPilAndNumpy.__next__","title":"<code>__next__()</code>","text":"<p>Returns batch paths, images, processed images, None, ''.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>def __next__(self):\n    \"\"\"Returns batch paths, images, processed images, None, ''.\"\"\"\n    if self.count == 1:  # loop only once as it's batch inference\n        raise StopIteration\n    self.count += 1\n    return self.paths, self.im0, None, \"\"\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.LoadTensor","title":"<code>ultralytics.data.loaders.LoadTensor</code>","text":"<p>Load images from torch.Tensor data.</p> <p>This class manages the loading and pre-processing of image data from PyTorch tensors for further processing.</p> <p>Attributes:</p> Name Type Description <code>im0</code> <code>Tensor</code> <p>The input tensor containing the image(s).</p> <code>bs</code> <code>int</code> <p>Batch size, inferred from the shape of <code>im0</code>.</p> <code>mode</code> <code>str</code> <p>Current mode, set to 'image'.</p> <code>paths</code> <code>list</code> <p>List of image paths or filenames.</p> <code>count</code> <code>int</code> <p>Counter for iteration, initialized at 0 during <code>__iter__()</code>.</p> <p>Methods:</p> Name Description <code>_single_check</code> <p>Validate and possibly modify the input tensor.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>class LoadTensor:\n    \"\"\"\n    Load images from torch.Tensor data.\n\n    This class manages the loading and pre-processing of image data from PyTorch tensors for further processing.\n\n    Attributes:\n        im0 (torch.Tensor): The input tensor containing the image(s).\n        bs (int): Batch size, inferred from the shape of `im0`.\n        mode (str): Current mode, set to 'image'.\n        paths (list): List of image paths or filenames.\n        count (int): Counter for iteration, initialized at 0 during `__iter__()`.\n\n    Methods:\n        _single_check(im, stride): Validate and possibly modify the input tensor.\n    \"\"\"\n\n    def __init__(self, im0) -&gt; None:\n        \"\"\"Initialize Tensor Dataloader.\"\"\"\n        self.im0 = self._single_check(im0)\n        self.bs = self.im0.shape[0]\n        self.mode = \"image\"\n        self.paths = [getattr(im, \"filename\", f\"image{i}.jpg\") for i, im in enumerate(im0)]\n\n    @staticmethod\n    def _single_check(im, stride=32):\n        \"\"\"Validate and format an image to torch.Tensor.\"\"\"\n        s = (\n            f\"WARNING \u26a0\ufe0f torch.Tensor inputs should be BCHW i.e. shape(1, 3, 640, 640) \"\n            f\"divisible by stride {stride}. Input shape{tuple(im.shape)} is incompatible.\"\n        )\n        if len(im.shape) != 4:\n            if len(im.shape) != 3:\n                raise ValueError(s)\n            LOGGER.warning(s)\n            im = im.unsqueeze(0)\n        if im.shape[2] % stride or im.shape[3] % stride:\n            raise ValueError(s)\n        if im.max() &gt; 1.0 + torch.finfo(im.dtype).eps:  # torch.float32 eps is 1.2e-07\n            LOGGER.warning(\n                f\"WARNING \u26a0\ufe0f torch.Tensor inputs should be normalized 0.0-1.0 but max value is {im.max()}. \"\n                f\"Dividing input by 255.\"\n            )\n            im = im.float() / 255.0\n\n        return im\n\n    def __iter__(self):\n        \"\"\"Returns an iterator object.\"\"\"\n        self.count = 0\n        return self\n\n    def __next__(self):\n        \"\"\"Return next item in the iterator.\"\"\"\n        if self.count == 1:\n            raise StopIteration\n        self.count += 1\n        return self.paths, self.im0, None, \"\"\n\n    def __len__(self):\n        \"\"\"Returns the batch size.\"\"\"\n        return self.bs\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.LoadTensor.__init__","title":"<code>__init__(im0)</code>","text":"<p>Initialize Tensor Dataloader.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>def __init__(self, im0) -&gt; None:\n    \"\"\"Initialize Tensor Dataloader.\"\"\"\n    self.im0 = self._single_check(im0)\n    self.bs = self.im0.shape[0]\n    self.mode = \"image\"\n    self.paths = [getattr(im, \"filename\", f\"image{i}.jpg\") for i, im in enumerate(im0)]\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.LoadTensor.__iter__","title":"<code>__iter__()</code>","text":"<p>Returns an iterator object.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>def __iter__(self):\n    \"\"\"Returns an iterator object.\"\"\"\n    self.count = 0\n    return self\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.LoadTensor.__len__","title":"<code>__len__()</code>","text":"<p>Returns the batch size.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>def __len__(self):\n    \"\"\"Returns the batch size.\"\"\"\n    return self.bs\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.LoadTensor.__next__","title":"<code>__next__()</code>","text":"<p>Return next item in the iterator.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>def __next__(self):\n    \"\"\"Return next item in the iterator.\"\"\"\n    if self.count == 1:\n        raise StopIteration\n    self.count += 1\n    return self.paths, self.im0, None, \"\"\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.autocast_list","title":"<code>ultralytics.data.loaders.autocast_list(source)</code>","text":"<p>Merges a list of source of different types into a list of numpy arrays or PIL images.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>def autocast_list(source):\n    \"\"\"Merges a list of source of different types into a list of numpy arrays or PIL images.\"\"\"\n    files = []\n    for im in source:\n        if isinstance(im, (str, Path)):  # filename or uri\n            files.append(Image.open(requests.get(im, stream=True).raw if str(im).startswith(\"http\") else im))\n        elif isinstance(im, (Image.Image, np.ndarray)):  # PIL or np Image\n            files.append(im)\n        else:\n            raise TypeError(\n                f\"type {type(im).__name__} is not a supported Ultralytics prediction source type. \\n\"\n                f\"See https://docs.ultralytics.com/modes/predict for supported source types.\"\n            )\n\n    return files\n</code></pre>"},{"location":"reference/data/loaders/#ultralytics.data.loaders.get_best_youtube_url","title":"<code>ultralytics.data.loaders.get_best_youtube_url(url, use_pafy=True)</code>","text":"<p>Retrieves the URL of the best quality MP4 video stream from a given YouTube video.</p> <p>This function uses the pafy or yt_dlp library to extract the video info from YouTube. It then finds the highest quality MP4 format that has video codec but no audio codec, and returns the URL of this video stream.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the YouTube video.</p> required <code>use_pafy</code> <code>bool</code> <p>Use the pafy package, default=True, otherwise use yt_dlp package.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The URL of the best quality MP4 video stream, or None if no suitable stream is found.</p> Source code in <code>ultralytics/data/loaders.py</code> <pre><code>def get_best_youtube_url(url, use_pafy=True):\n    \"\"\"\n    Retrieves the URL of the best quality MP4 video stream from a given YouTube video.\n\n    This function uses the pafy or yt_dlp library to extract the video info from YouTube. It then finds the highest\n    quality MP4 format that has video codec but no audio codec, and returns the URL of this video stream.\n\n    Args:\n        url (str): The URL of the YouTube video.\n        use_pafy (bool): Use the pafy package, default=True, otherwise use yt_dlp package.\n\n    Returns:\n        (str): The URL of the best quality MP4 video stream, or None if no suitable stream is found.\n    \"\"\"\n    if use_pafy:\n        check_requirements((\"pafy\", \"youtube_dl==2020.12.2\"))\n        import pafy  # noqa\n\n        return pafy.new(url).getbestvideo(preftype=\"mp4\").url\n    else:\n        check_requirements(\"yt-dlp\")\n        import yt_dlp\n\n        with yt_dlp.YoutubeDL({\"quiet\": True}) as ydl:\n            info_dict = ydl.extract_info(url, download=False)  # extract info\n        for f in reversed(info_dict.get(\"formats\", [])):  # reversed because best is usually last\n            # Find a format with video codec, no audio, *.mp4 extension at least 1920x1080 size\n            good_size = (f.get(\"width\") or 0) &gt;= 1920 or (f.get(\"height\") or 0) &gt;= 1080\n            if good_size and f[\"vcodec\"] != \"none\" and f[\"acodec\"] == \"none\" and f[\"ext\"] == \"mp4\":\n                return f.get(\"url\")\n</code></pre>"},{"location":"reference/data/split_dota/","title":"Reference for <code>ultralytics/data/split_dota.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/split_dota.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/data/split_dota/#ultralytics.data.split_dota.bbox_iof","title":"<code>ultralytics.data.split_dota.bbox_iof(polygon1, bbox2, eps=1e-06)</code>","text":"<p>Calculate iofs between bbox1 and bbox2.</p> <p>Parameters:</p> Name Type Description Default <code>polygon1</code> <code>ndarray</code> <p>Polygon coordinates, (n, 8).</p> required <code>bbox2</code> <code>ndarray</code> <p>Bounding boxes, (n ,4).</p> required Source code in <code>ultralytics/data/split_dota.py</code> <pre><code>def bbox_iof(polygon1, bbox2, eps=1e-6):\n    \"\"\"\n    Calculate iofs between bbox1 and bbox2.\n\n    Args:\n        polygon1 (np.ndarray): Polygon coordinates, (n, 8).\n        bbox2 (np.ndarray): Bounding boxes, (n ,4).\n    \"\"\"\n    polygon1 = polygon1.reshape(-1, 4, 2)\n    lt_point = np.min(polygon1, axis=-2)\n    rb_point = np.max(polygon1, axis=-2)\n    bbox1 = np.concatenate([lt_point, rb_point], axis=-1)\n\n    lt = np.maximum(bbox1[:, None, :2], bbox2[..., :2])\n    rb = np.minimum(bbox1[:, None, 2:], bbox2[..., 2:])\n    wh = np.clip(rb - lt, 0, np.inf)\n    h_overlaps = wh[..., 0] * wh[..., 1]\n\n    l, t, r, b = (bbox2[..., i] for i in range(4))\n    polygon2 = np.stack([l, t, r, t, r, b, l, b], axis=-1).reshape(-1, 4, 2)\n\n    sg_polys1 = [Polygon(p) for p in polygon1]\n    sg_polys2 = [Polygon(p) for p in polygon2]\n    overlaps = np.zeros(h_overlaps.shape)\n    for p in zip(*np.nonzero(h_overlaps)):\n        overlaps[p] = sg_polys1[p[0]].intersection(sg_polys2[p[-1]]).area\n    unions = np.array([p.area for p in sg_polys1], dtype=np.float32)\n    unions = unions[..., None]\n\n    unions = np.clip(unions, eps, np.inf)\n    outputs = overlaps / unions\n    if outputs.ndim == 1:\n        outputs = outputs[..., None]\n    return outputs\n</code></pre>"},{"location":"reference/data/split_dota/#ultralytics.data.split_dota.load_yolo_dota","title":"<code>ultralytics.data.split_dota.load_yolo_dota(data_root, split='train')</code>","text":"<p>Load DOTA dataset.</p> <p>Parameters:</p> Name Type Description Default <code>data_root</code> <code>str</code> <p>Data root.</p> required <code>split</code> <code>str</code> <p>The split data set, could be train or val.</p> <code>'train'</code> Notes <p>The directory structure assumed for the DOTA dataset:     - data_root         - images             - train             - val         - labels             - train             - val</p> Source code in <code>ultralytics/data/split_dota.py</code> <pre><code>def load_yolo_dota(data_root, split=\"train\"):\n    \"\"\"\n    Load DOTA dataset.\n\n    Args:\n        data_root (str): Data root.\n        split (str): The split data set, could be train or val.\n\n    Notes:\n        The directory structure assumed for the DOTA dataset:\n            - data_root\n                - images\n                    - train\n                    - val\n                - labels\n                    - train\n                    - val\n    \"\"\"\n    assert split in [\"train\", \"val\"]\n    im_dir = os.path.join(data_root, f\"images/{split}\")\n    assert Path(im_dir).exists(), f\"Can't find {im_dir}, please check your data root.\"\n    im_files = glob(os.path.join(data_root, f\"images/{split}/*\"))\n    lb_files = img2label_paths(im_files)\n    annos = []\n    for im_file, lb_file in zip(im_files, lb_files):\n        w, h = exif_size(Image.open(im_file))\n        with open(lb_file) as f:\n            lb = [x.split() for x in f.read().strip().splitlines() if len(x)]\n            lb = np.array(lb, dtype=np.float32)\n        annos.append(dict(ori_size=(h, w), label=lb, filepath=im_file))\n    return annos\n</code></pre>"},{"location":"reference/data/split_dota/#ultralytics.data.split_dota.get_windows","title":"<code>ultralytics.data.split_dota.get_windows(im_size, crop_sizes=[1024], gaps=[200], im_rate_thr=0.6, eps=0.01)</code>","text":"<p>Get the coordinates of windows.</p> <p>Parameters:</p> Name Type Description Default <code>im_size</code> <code>tuple</code> <p>Original image size, (h, w).</p> required <code>crop_sizes</code> <code>List(int</code> <p>Crop size of windows.</p> <code>[1024]</code> <code>gaps</code> <code>List(int</code> <p>Gap between each crops.</p> <code>[200]</code> <code>im_rate_thr</code> <code>float</code> <p>Threshold of windows areas divided by image ares.</p> <code>0.6</code> Source code in <code>ultralytics/data/split_dota.py</code> <pre><code>def get_windows(im_size, crop_sizes=[1024], gaps=[200], im_rate_thr=0.6, eps=0.01):\n    \"\"\"\n    Get the coordinates of windows.\n\n    Args:\n        im_size (tuple): Original image size, (h, w).\n        crop_sizes (List(int)): Crop size of windows.\n        gaps (List(int)): Gap between each crops.\n        im_rate_thr (float): Threshold of windows areas divided by image ares.\n    \"\"\"\n    h, w = im_size\n    windows = []\n    for crop_size, gap in zip(crop_sizes, gaps):\n        assert crop_size &gt; gap, f\"invalid crop_size gap pair [{crop_size} {gap}]\"\n        step = crop_size - gap\n\n        xn = 1 if w &lt;= crop_size else ceil((w - crop_size) / step + 1)\n        xs = [step * i for i in range(xn)]\n        if len(xs) &gt; 1 and xs[-1] + crop_size &gt; w:\n            xs[-1] = w - crop_size\n\n        yn = 1 if h &lt;= crop_size else ceil((h - crop_size) / step + 1)\n        ys = [step * i for i in range(yn)]\n        if len(ys) &gt; 1 and ys[-1] + crop_size &gt; h:\n            ys[-1] = h - crop_size\n\n        start = np.array(list(itertools.product(xs, ys)), dtype=np.int64)\n        stop = start + crop_size\n        windows.append(np.concatenate([start, stop], axis=1))\n    windows = np.concatenate(windows, axis=0)\n\n    im_in_wins = windows.copy()\n    im_in_wins[:, 0::2] = np.clip(im_in_wins[:, 0::2], 0, w)\n    im_in_wins[:, 1::2] = np.clip(im_in_wins[:, 1::2], 0, h)\n    im_areas = (im_in_wins[:, 2] - im_in_wins[:, 0]) * (im_in_wins[:, 3] - im_in_wins[:, 1])\n    win_areas = (windows[:, 2] - windows[:, 0]) * (windows[:, 3] - windows[:, 1])\n    im_rates = im_areas / win_areas\n    if not (im_rates &gt; im_rate_thr).any():\n        max_rate = im_rates.max()\n        im_rates[abs(im_rates - max_rate) &lt; eps] = 1\n    return windows[im_rates &gt; im_rate_thr]\n</code></pre>"},{"location":"reference/data/split_dota/#ultralytics.data.split_dota.get_window_obj","title":"<code>ultralytics.data.split_dota.get_window_obj(anno, windows, iof_thr=0.7)</code>","text":"<p>Get objects for each window.</p> Source code in <code>ultralytics/data/split_dota.py</code> <pre><code>def get_window_obj(anno, windows, iof_thr=0.7):\n    \"\"\"Get objects for each window.\"\"\"\n    h, w = anno[\"ori_size\"]\n    label = anno[\"label\"]\n    if len(label):\n        label[:, 1::2] *= w\n        label[:, 2::2] *= h\n        iofs = bbox_iof(label[:, 1:], windows)\n        # Unnormalized and misaligned coordinates\n        window_anns = [(label[iofs[:, i] &gt;= iof_thr]) for i in range(len(windows))]\n    else:\n        window_anns = [np.zeros((0, 9), dtype=np.float32) for _ in range(len(windows))]\n    return window_anns\n</code></pre>"},{"location":"reference/data/split_dota/#ultralytics.data.split_dota.crop_and_save","title":"<code>ultralytics.data.split_dota.crop_and_save(anno, windows, window_objs, im_dir, lb_dir)</code>","text":"<p>Crop images and save new labels.</p> <p>Parameters:</p> Name Type Description Default <code>anno</code> <code>dict</code> <p>Annotation dict, including <code>filepath</code>, <code>label</code>, <code>ori_size</code> as its keys.</p> required <code>windows</code> <code>list</code> <p>A list of windows coordinates.</p> required <code>window_objs</code> <code>list</code> <p>A list of labels inside each window.</p> required <code>im_dir</code> <code>str</code> <p>The output directory path of images.</p> required <code>lb_dir</code> <code>str</code> <p>The output directory path of labels.</p> required Notes <p>The directory structure assumed for the DOTA dataset:     - data_root         - images             - train             - val         - labels             - train             - val</p> Source code in <code>ultralytics/data/split_dota.py</code> <pre><code>def crop_and_save(anno, windows, window_objs, im_dir, lb_dir):\n    \"\"\"\n    Crop images and save new labels.\n\n    Args:\n        anno (dict): Annotation dict, including `filepath`, `label`, `ori_size` as its keys.\n        windows (list): A list of windows coordinates.\n        window_objs (list): A list of labels inside each window.\n        im_dir (str): The output directory path of images.\n        lb_dir (str): The output directory path of labels.\n\n    Notes:\n        The directory structure assumed for the DOTA dataset:\n            - data_root\n                - images\n                    - train\n                    - val\n                - labels\n                    - train\n                    - val\n    \"\"\"\n    im = cv2.imread(anno[\"filepath\"])\n    name = Path(anno[\"filepath\"]).stem\n    for i, window in enumerate(windows):\n        x_start, y_start, x_stop, y_stop = window.tolist()\n        new_name = name + \"__\" + str(x_stop - x_start) + \"__\" + str(x_start) + \"___\" + str(y_start)\n        patch_im = im[y_start:y_stop, x_start:x_stop]\n        ph, pw = patch_im.shape[:2]\n\n        cv2.imwrite(os.path.join(im_dir, f\"{new_name}.jpg\"), patch_im)\n        label = window_objs[i]\n        if len(label) == 0:\n            continue\n        label[:, 1::2] -= x_start\n        label[:, 2::2] -= y_start\n        label[:, 1::2] /= pw\n        label[:, 2::2] /= ph\n\n        with open(os.path.join(lb_dir, f\"{new_name}.txt\"), \"w\") as f:\n            for lb in label:\n                formatted_coords = [\"{:.6g}\".format(coord) for coord in lb[1:]]\n                f.write(f\"{int(lb[0])} {' '.join(formatted_coords)}\\n\")\n</code></pre>"},{"location":"reference/data/split_dota/#ultralytics.data.split_dota.split_images_and_labels","title":"<code>ultralytics.data.split_dota.split_images_and_labels(data_root, save_dir, split='train', crop_sizes=[1024], gaps=[200])</code>","text":"<p>Split both images and labels.</p> Notes <p>The directory structure assumed for the DOTA dataset:     - data_root         - images             - split         - labels             - split and the output directory structure is:     - save_dir         - images             - split         - labels             - split</p> Source code in <code>ultralytics/data/split_dota.py</code> <pre><code>def split_images_and_labels(data_root, save_dir, split=\"train\", crop_sizes=[1024], gaps=[200]):\n    \"\"\"\n    Split both images and labels.\n\n    Notes:\n        The directory structure assumed for the DOTA dataset:\n            - data_root\n                - images\n                    - split\n                - labels\n                    - split\n        and the output directory structure is:\n            - save_dir\n                - images\n                    - split\n                - labels\n                    - split\n    \"\"\"\n    im_dir = Path(save_dir) / \"images\" / split\n    im_dir.mkdir(parents=True, exist_ok=True)\n    lb_dir = Path(save_dir) / \"labels\" / split\n    lb_dir.mkdir(parents=True, exist_ok=True)\n\n    annos = load_yolo_dota(data_root, split=split)\n    for anno in tqdm(annos, total=len(annos), desc=split):\n        windows = get_windows(anno[\"ori_size\"], crop_sizes, gaps)\n        window_objs = get_window_obj(anno, windows)\n        crop_and_save(anno, windows, window_objs, str(im_dir), str(lb_dir))\n</code></pre>"},{"location":"reference/data/split_dota/#ultralytics.data.split_dota.split_trainval","title":"<code>ultralytics.data.split_dota.split_trainval(data_root, save_dir, crop_size=1024, gap=200, rates=[1.0])</code>","text":"<p>Split train and val set of DOTA.</p> Notes <p>The directory structure assumed for the DOTA dataset:     - data_root         - images             - train             - val         - labels             - train             - val and the output directory structure is:     - save_dir         - images             - train             - val         - labels             - train             - val</p> Source code in <code>ultralytics/data/split_dota.py</code> <pre><code>def split_trainval(data_root, save_dir, crop_size=1024, gap=200, rates=[1.0]):\n    \"\"\"\n    Split train and val set of DOTA.\n\n    Notes:\n        The directory structure assumed for the DOTA dataset:\n            - data_root\n                - images\n                    - train\n                    - val\n                - labels\n                    - train\n                    - val\n        and the output directory structure is:\n            - save_dir\n                - images\n                    - train\n                    - val\n                - labels\n                    - train\n                    - val\n    \"\"\"\n    crop_sizes, gaps = [], []\n    for r in rates:\n        crop_sizes.append(int(crop_size / r))\n        gaps.append(int(gap / r))\n    for split in [\"train\", \"val\"]:\n        split_images_and_labels(data_root, save_dir, split, crop_sizes, gaps)\n</code></pre>"},{"location":"reference/data/split_dota/#ultralytics.data.split_dota.split_test","title":"<code>ultralytics.data.split_dota.split_test(data_root, save_dir, crop_size=1024, gap=200, rates=[1.0])</code>","text":"<p>Split test set of DOTA, labels are not included within this set.</p> Notes <p>The directory structure assumed for the DOTA dataset:     - data_root         - images             - test and the output directory structure is:     - save_dir         - images             - test</p> Source code in <code>ultralytics/data/split_dota.py</code> <pre><code>def split_test(data_root, save_dir, crop_size=1024, gap=200, rates=[1.0]):\n    \"\"\"\n    Split test set of DOTA, labels are not included within this set.\n\n    Notes:\n        The directory structure assumed for the DOTA dataset:\n            - data_root\n                - images\n                    - test\n        and the output directory structure is:\n            - save_dir\n                - images\n                    - test\n    \"\"\"\n    crop_sizes, gaps = [], []\n    for r in rates:\n        crop_sizes.append(int(crop_size / r))\n        gaps.append(int(gap / r))\n    save_dir = Path(save_dir) / \"images\" / \"test\"\n    save_dir.mkdir(parents=True, exist_ok=True)\n\n    im_dir = Path(os.path.join(data_root, \"images/test\"))\n    assert im_dir.exists(), f\"Can't find {str(im_dir)}, please check your data root.\"\n    im_files = glob(str(im_dir / \"*\"))\n    for im_file in tqdm(im_files, total=len(im_files), desc=\"test\"):\n        w, h = exif_size(Image.open(im_file))\n        windows = get_windows((h, w), crop_sizes=crop_sizes, gaps=gaps)\n        im = cv2.imread(im_file)\n        name = Path(im_file).stem\n        for window in windows:\n            x_start, y_start, x_stop, y_stop = window.tolist()\n            new_name = name + \"__\" + str(x_stop - x_start) + \"__\" + str(x_start) + \"___\" + str(y_start)\n            patch_im = im[y_start:y_stop, x_start:x_stop]\n            cv2.imwrite(os.path.join(str(save_dir), f\"{new_name}.jpg\"), patch_im)\n</code></pre>"},{"location":"reference/data/utils/","title":"Reference for <code>ultralytics/data/utils.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/utils.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/data/utils/#ultralytics.data.utils.HUBDatasetStats","title":"<code>ultralytics.data.utils.HUBDatasetStats</code>","text":"<p>A class for generating HUB dataset JSON and <code>-hub</code> dataset directory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to data.yaml or data.zip (with data.yaml inside data.zip). Default is 'coco8.yaml'.</p> <code>'coco8.yaml'</code> <code>task</code> <code>str</code> <p>Dataset task. Options are 'detect', 'segment', 'pose', 'classify'. Default is 'detect'.</p> <code>'detect'</code> <code>autodownload</code> <code>bool</code> <p>Attempt to download dataset if not found locally. Default is False.</p> <code>False</code> Example <p>Download *.zip files from https://github.com/ultralytics/hub/tree/main/example_datasets     i.e. https://github.com/ultralytics/hub/raw/main/example_datasets/coco8.zip for coco8.zip. <pre><code>from ultralytics.data.utils import HUBDatasetStats\n\nstats = HUBDatasetStats('path/to/coco8.zip', task='detect')  # detect dataset\nstats = HUBDatasetStats('path/to/coco8-seg.zip', task='segment')  # segment dataset\nstats = HUBDatasetStats('path/to/coco8-pose.zip', task='pose')  # pose dataset\nstats = HUBDatasetStats('path/to/imagenet10.zip', task='classify')  # classification dataset\n\nstats.get_json(save=True)\nstats.process_images()\n</code></pre></p> Source code in <code>ultralytics/data/utils.py</code> <pre><code>class HUBDatasetStats:\n    \"\"\"\n    A class for generating HUB dataset JSON and `-hub` dataset directory.\n\n    Args:\n        path (str): Path to data.yaml or data.zip (with data.yaml inside data.zip). Default is 'coco8.yaml'.\n        task (str): Dataset task. Options are 'detect', 'segment', 'pose', 'classify'. Default is 'detect'.\n        autodownload (bool): Attempt to download dataset if not found locally. Default is False.\n\n    Example:\n        Download *.zip files from https://github.com/ultralytics/hub/tree/main/example_datasets\n            i.e. https://github.com/ultralytics/hub/raw/main/example_datasets/coco8.zip for coco8.zip.\n        ```python\n        from ultralytics.data.utils import HUBDatasetStats\n\n        stats = HUBDatasetStats('path/to/coco8.zip', task='detect')  # detect dataset\n        stats = HUBDatasetStats('path/to/coco8-seg.zip', task='segment')  # segment dataset\n        stats = HUBDatasetStats('path/to/coco8-pose.zip', task='pose')  # pose dataset\n        stats = HUBDatasetStats('path/to/imagenet10.zip', task='classify')  # classification dataset\n\n        stats.get_json(save=True)\n        stats.process_images()\n        ```\n    \"\"\"\n\n    def __init__(self, path=\"coco8.yaml\", task=\"detect\", autodownload=False):\n        \"\"\"Initialize class.\"\"\"\n        path = Path(path).resolve()\n        LOGGER.info(f\"Starting HUB dataset checks for {path}....\")\n\n        self.task = task  # detect, segment, pose, classify\n        if self.task == \"classify\":\n            unzip_dir = unzip_file(path)\n            data = check_cls_dataset(unzip_dir)\n            data[\"path\"] = unzip_dir\n        else:  # detect, segment, pose\n            _, data_dir, yaml_path = self._unzip(Path(path))\n            try:\n                # Load YAML with checks\n                data = yaml_load(yaml_path)\n                data[\"path\"] = \"\"  # strip path since YAML should be in dataset root for all HUB datasets\n                yaml_save(yaml_path, data)\n                data = check_det_dataset(yaml_path, autodownload)  # dict\n                data[\"path\"] = data_dir  # YAML path should be set to '' (relative) or parent (absolute)\n            except Exception as e:\n                raise Exception(\"error/HUB/dataset_stats/init\") from e\n\n        self.hub_dir = Path(f'{data[\"path\"]}-hub')\n        self.im_dir = self.hub_dir / \"images\"\n        self.im_dir.mkdir(parents=True, exist_ok=True)  # makes /images\n        self.stats = {\"nc\": len(data[\"names\"]), \"names\": list(data[\"names\"].values())}  # statistics dictionary\n        self.data = data\n\n    @staticmethod\n    def _unzip(path):\n        \"\"\"Unzip data.zip.\"\"\"\n        if not str(path).endswith(\".zip\"):  # path is data.yaml\n            return False, None, path\n        unzip_dir = unzip_file(path, path=path.parent)\n        assert unzip_dir.is_dir(), (\n            f\"Error unzipping {path}, {unzip_dir} not found. \" f\"path/to/abc.zip MUST unzip to path/to/abc/\"\n        )\n        return True, str(unzip_dir), find_dataset_yaml(unzip_dir)  # zipped, data_dir, yaml_path\n\n    def _hub_ops(self, f):\n        \"\"\"Saves a compressed image for HUB previews.\"\"\"\n        compress_one_image(f, self.im_dir / Path(f).name)  # save to dataset-hub\n\n    def get_json(self, save=False, verbose=False):\n        \"\"\"Return dataset JSON for Ultralytics HUB.\"\"\"\n\n        def _round(labels):\n            \"\"\"Update labels to integer class and 4 decimal place floats.\"\"\"\n            if self.task == \"detect\":\n                coordinates = labels[\"bboxes\"]\n            elif self.task == \"segment\":\n                coordinates = [x.flatten() for x in labels[\"segments\"]]\n            elif self.task == \"pose\":\n                n = labels[\"keypoints\"].shape[0]\n                coordinates = np.concatenate((labels[\"bboxes\"], labels[\"keypoints\"].reshape(n, -1)), 1)\n            else:\n                raise ValueError(\"Undefined dataset task.\")\n            zipped = zip(labels[\"cls\"], coordinates)\n            return [[int(c[0]), *(round(float(x), 4) for x in points)] for c, points in zipped]\n\n        for split in \"train\", \"val\", \"test\":\n            self.stats[split] = None  # predefine\n            path = self.data.get(split)\n\n            # Check split\n            if path is None:  # no split\n                continue\n            files = [f for f in Path(path).rglob(\"*.*\") if f.suffix[1:].lower() in IMG_FORMATS]  # image files in split\n            if not files:  # no images\n                continue\n\n            # Get dataset statistics\n            if self.task == \"classify\":\n                from torchvision.datasets import ImageFolder\n\n                dataset = ImageFolder(self.data[split])\n\n                x = np.zeros(len(dataset.classes)).astype(int)\n                for im in dataset.imgs:\n                    x[im[1]] += 1\n\n                self.stats[split] = {\n                    \"instance_stats\": {\"total\": len(dataset), \"per_class\": x.tolist()},\n                    \"image_stats\": {\"total\": len(dataset), \"unlabelled\": 0, \"per_class\": x.tolist()},\n                    \"labels\": [{Path(k).name: v} for k, v in dataset.imgs],\n                }\n            else:\n                from ultralytics.data import YOLODataset\n\n                dataset = YOLODataset(img_path=self.data[split], data=self.data, task=self.task)\n                x = np.array(\n                    [\n                        np.bincount(label[\"cls\"].astype(int).flatten(), minlength=self.data[\"nc\"])\n                        for label in TQDM(dataset.labels, total=len(dataset), desc=\"Statistics\")\n                    ]\n                )  # shape(128x80)\n                self.stats[split] = {\n                    \"instance_stats\": {\"total\": int(x.sum()), \"per_class\": x.sum(0).tolist()},\n                    \"image_stats\": {\n                        \"total\": len(dataset),\n                        \"unlabelled\": int(np.all(x == 0, 1).sum()),\n                        \"per_class\": (x &gt; 0).sum(0).tolist(),\n                    },\n                    \"labels\": [{Path(k).name: _round(v)} for k, v in zip(dataset.im_files, dataset.labels)],\n                }\n\n        # Save, print and return\n        if save:\n            stats_path = self.hub_dir / \"stats.json\"\n            LOGGER.info(f\"Saving {stats_path.resolve()}...\")\n            with open(stats_path, \"w\") as f:\n                json.dump(self.stats, f)  # save stats.json\n        if verbose:\n            LOGGER.info(json.dumps(self.stats, indent=2, sort_keys=False))\n        return self.stats\n\n    def process_images(self):\n        \"\"\"Compress images for Ultralytics HUB.\"\"\"\n        from ultralytics.data import YOLODataset  # ClassificationDataset\n\n        for split in \"train\", \"val\", \"test\":\n            if self.data.get(split) is None:\n                continue\n            dataset = YOLODataset(img_path=self.data[split], data=self.data)\n            with ThreadPool(NUM_THREADS) as pool:\n                for _ in TQDM(pool.imap(self._hub_ops, dataset.im_files), total=len(dataset), desc=f\"{split} images\"):\n                    pass\n        LOGGER.info(f\"Done. All images saved to {self.im_dir}\")\n        return self.im_dir\n</code></pre>"},{"location":"reference/data/utils/#ultralytics.data.utils.HUBDatasetStats.__init__","title":"<code>__init__(path='coco8.yaml', task='detect', autodownload=False)</code>","text":"<p>Initialize class.</p> Source code in <code>ultralytics/data/utils.py</code> <pre><code>def __init__(self, path=\"coco8.yaml\", task=\"detect\", autodownload=False):\n    \"\"\"Initialize class.\"\"\"\n    path = Path(path).resolve()\n    LOGGER.info(f\"Starting HUB dataset checks for {path}....\")\n\n    self.task = task  # detect, segment, pose, classify\n    if self.task == \"classify\":\n        unzip_dir = unzip_file(path)\n        data = check_cls_dataset(unzip_dir)\n        data[\"path\"] = unzip_dir\n    else:  # detect, segment, pose\n        _, data_dir, yaml_path = self._unzip(Path(path))\n        try:\n            # Load YAML with checks\n            data = yaml_load(yaml_path)\n            data[\"path\"] = \"\"  # strip path since YAML should be in dataset root for all HUB datasets\n            yaml_save(yaml_path, data)\n            data = check_det_dataset(yaml_path, autodownload)  # dict\n            data[\"path\"] = data_dir  # YAML path should be set to '' (relative) or parent (absolute)\n        except Exception as e:\n            raise Exception(\"error/HUB/dataset_stats/init\") from e\n\n    self.hub_dir = Path(f'{data[\"path\"]}-hub')\n    self.im_dir = self.hub_dir / \"images\"\n    self.im_dir.mkdir(parents=True, exist_ok=True)  # makes /images\n    self.stats = {\"nc\": len(data[\"names\"]), \"names\": list(data[\"names\"].values())}  # statistics dictionary\n    self.data = data\n</code></pre>"},{"location":"reference/data/utils/#ultralytics.data.utils.HUBDatasetStats.get_json","title":"<code>get_json(save=False, verbose=False)</code>","text":"<p>Return dataset JSON for Ultralytics HUB.</p> Source code in <code>ultralytics/data/utils.py</code> <pre><code>def get_json(self, save=False, verbose=False):\n    \"\"\"Return dataset JSON for Ultralytics HUB.\"\"\"\n\n    def _round(labels):\n        \"\"\"Update labels to integer class and 4 decimal place floats.\"\"\"\n        if self.task == \"detect\":\n            coordinates = labels[\"bboxes\"]\n        elif self.task == \"segment\":\n            coordinates = [x.flatten() for x in labels[\"segments\"]]\n        elif self.task == \"pose\":\n            n = labels[\"keypoints\"].shape[0]\n            coordinates = np.concatenate((labels[\"bboxes\"], labels[\"keypoints\"].reshape(n, -1)), 1)\n        else:\n            raise ValueError(\"Undefined dataset task.\")\n        zipped = zip(labels[\"cls\"], coordinates)\n        return [[int(c[0]), *(round(float(x), 4) for x in points)] for c, points in zipped]\n\n    for split in \"train\", \"val\", \"test\":\n        self.stats[split] = None  # predefine\n        path = self.data.get(split)\n\n        # Check split\n        if path is None:  # no split\n            continue\n        files = [f for f in Path(path).rglob(\"*.*\") if f.suffix[1:].lower() in IMG_FORMATS]  # image files in split\n        if not files:  # no images\n            continue\n\n        # Get dataset statistics\n        if self.task == \"classify\":\n            from torchvision.datasets import ImageFolder\n\n            dataset = ImageFolder(self.data[split])\n\n            x = np.zeros(len(dataset.classes)).astype(int)\n            for im in dataset.imgs:\n                x[im[1]] += 1\n\n            self.stats[split] = {\n                \"instance_stats\": {\"total\": len(dataset), \"per_class\": x.tolist()},\n                \"image_stats\": {\"total\": len(dataset), \"unlabelled\": 0, \"per_class\": x.tolist()},\n                \"labels\": [{Path(k).name: v} for k, v in dataset.imgs],\n            }\n        else:\n            from ultralytics.data import YOLODataset\n\n            dataset = YOLODataset(img_path=self.data[split], data=self.data, task=self.task)\n            x = np.array(\n                [\n                    np.bincount(label[\"cls\"].astype(int).flatten(), minlength=self.data[\"nc\"])\n                    for label in TQDM(dataset.labels, total=len(dataset), desc=\"Statistics\")\n                ]\n            )  # shape(128x80)\n            self.stats[split] = {\n                \"instance_stats\": {\"total\": int(x.sum()), \"per_class\": x.sum(0).tolist()},\n                \"image_stats\": {\n                    \"total\": len(dataset),\n                    \"unlabelled\": int(np.all(x == 0, 1).sum()),\n                    \"per_class\": (x &gt; 0).sum(0).tolist(),\n                },\n                \"labels\": [{Path(k).name: _round(v)} for k, v in zip(dataset.im_files, dataset.labels)],\n            }\n\n    # Save, print and return\n    if save:\n        stats_path = self.hub_dir / \"stats.json\"\n        LOGGER.info(f\"Saving {stats_path.resolve()}...\")\n        with open(stats_path, \"w\") as f:\n            json.dump(self.stats, f)  # save stats.json\n    if verbose:\n        LOGGER.info(json.dumps(self.stats, indent=2, sort_keys=False))\n    return self.stats\n</code></pre>"},{"location":"reference/data/utils/#ultralytics.data.utils.HUBDatasetStats.process_images","title":"<code>process_images()</code>","text":"<p>Compress images for Ultralytics HUB.</p> Source code in <code>ultralytics/data/utils.py</code> <pre><code>def process_images(self):\n    \"\"\"Compress images for Ultralytics HUB.\"\"\"\n    from ultralytics.data import YOLODataset  # ClassificationDataset\n\n    for split in \"train\", \"val\", \"test\":\n        if self.data.get(split) is None:\n            continue\n        dataset = YOLODataset(img_path=self.data[split], data=self.data)\n        with ThreadPool(NUM_THREADS) as pool:\n            for _ in TQDM(pool.imap(self._hub_ops, dataset.im_files), total=len(dataset), desc=f\"{split} images\"):\n                pass\n    LOGGER.info(f\"Done. All images saved to {self.im_dir}\")\n    return self.im_dir\n</code></pre>"},{"location":"reference/data/utils/#ultralytics.data.utils.img2label_paths","title":"<code>ultralytics.data.utils.img2label_paths(img_paths)</code>","text":"<p>Define label paths as a function of image paths.</p> Source code in <code>ultralytics/data/utils.py</code> <pre><code>def img2label_paths(img_paths):\n    \"\"\"Define label paths as a function of image paths.\"\"\"\n    sa, sb = f\"{os.sep}images{os.sep}\", f\"{os.sep}labels{os.sep}\"  # /images/, /labels/ substrings\n    return [sb.join(x.rsplit(sa, 1)).rsplit(\".\", 1)[0] + \".txt\" for x in img_paths]\n</code></pre>"},{"location":"reference/data/utils/#ultralytics.data.utils.get_hash","title":"<code>ultralytics.data.utils.get_hash(paths)</code>","text":"<p>Returns a single hash value of a list of paths (files or dirs).</p> Source code in <code>ultralytics/data/utils.py</code> <pre><code>def get_hash(paths):\n    \"\"\"Returns a single hash value of a list of paths (files or dirs).\"\"\"\n    size = sum(os.path.getsize(p) for p in paths if os.path.exists(p))  # sizes\n    h = hashlib.sha256(str(size).encode())  # hash sizes\n    h.update(\"\".join(paths).encode())  # hash paths\n    return h.hexdigest()  # return hash\n</code></pre>"},{"location":"reference/data/utils/#ultralytics.data.utils.exif_size","title":"<code>ultralytics.data.utils.exif_size(img)</code>","text":"<p>Returns exif-corrected PIL size.</p> Source code in <code>ultralytics/data/utils.py</code> <pre><code>def exif_size(img: Image.Image):\n    \"\"\"Returns exif-corrected PIL size.\"\"\"\n    s = img.size  # (width, height)\n    if img.format == \"JPEG\":  # only support JPEG images\n        with contextlib.suppress(Exception):\n            exif = img.getexif()\n            if exif:\n                rotation = exif.get(274, None)  # the EXIF key for the orientation tag is 274\n                if rotation in [6, 8]:  # rotation 270 or 90\n                    s = s[1], s[0]\n    return s\n</code></pre>"},{"location":"reference/data/utils/#ultralytics.data.utils.verify_image","title":"<code>ultralytics.data.utils.verify_image(args)</code>","text":"<p>Verify one image.</p> Source code in <code>ultralytics/data/utils.py</code> <pre><code>def verify_image(args):\n    \"\"\"Verify one image.\"\"\"\n    (im_file, cls), prefix = args\n    # Number (found, corrupt), message\n    nf, nc, msg = 0, 0, \"\"\n    try:\n        im = Image.open(im_file)\n        im.verify()  # PIL verify\n        shape = exif_size(im)  # image size\n        shape = (shape[1], shape[0])  # hw\n        assert (shape[0] &gt; 9) &amp; (shape[1] &gt; 9), f\"image size {shape} &lt;10 pixels\"\n        assert im.format.lower() in IMG_FORMATS, f\"invalid image format {im.format}\"\n        if im.format.lower() in (\"jpg\", \"jpeg\"):\n            with open(im_file, \"rb\") as f:\n                f.seek(-2, 2)\n                if f.read() != b\"\\xff\\xd9\":  # corrupt JPEG\n                    ImageOps.exif_transpose(Image.open(im_file)).save(im_file, \"JPEG\", subsampling=0, quality=100)\n                    msg = f\"{prefix}WARNING \u26a0\ufe0f {im_file}: corrupt JPEG restored and saved\"\n        nf = 1\n    except Exception as e:\n        nc = 1\n        msg = f\"{prefix}WARNING \u26a0\ufe0f {im_file}: ignoring corrupt image/label: {e}\"\n    return (im_file, cls), nf, nc, msg\n</code></pre>"},{"location":"reference/data/utils/#ultralytics.data.utils.verify_image_label","title":"<code>ultralytics.data.utils.verify_image_label(args)</code>","text":"<p>Verify one image-label pair.</p> Source code in <code>ultralytics/data/utils.py</code> <pre><code>def verify_image_label(args):\n    \"\"\"Verify one image-label pair.\"\"\"\n    im_file, lb_file, prefix, keypoint, num_cls, nkpt, ndim = args\n    # Number (missing, found, empty, corrupt), message, segments, keypoints\n    nm, nf, ne, nc, msg, segments, keypoints = 0, 0, 0, 0, \"\", [], None\n    try:\n        # Verify images\n        im = Image.open(im_file)\n        im.verify()  # PIL verify\n        shape = exif_size(im)  # image size\n        shape = (shape[1], shape[0])  # hw\n        assert (shape[0] &gt; 9) &amp; (shape[1] &gt; 9), f\"image size {shape} &lt;10 pixels\"\n        assert im.format.lower() in IMG_FORMATS, f\"invalid image format {im.format}\"\n        if im.format.lower() in (\"jpg\", \"jpeg\"):\n            with open(im_file, \"rb\") as f:\n                f.seek(-2, 2)\n                if f.read() != b\"\\xff\\xd9\":  # corrupt JPEG\n                    ImageOps.exif_transpose(Image.open(im_file)).save(im_file, \"JPEG\", subsampling=0, quality=100)\n                    msg = f\"{prefix}WARNING \u26a0\ufe0f {im_file}: corrupt JPEG restored and saved\"\n\n        # Verify labels\n        if os.path.isfile(lb_file):\n            nf = 1  # label found\n            with open(lb_file) as f:\n                lb = [x.split() for x in f.read().strip().splitlines() if len(x)]\n                if any(len(x) &gt; 6 for x in lb) and (not keypoint):  # is segment\n                    classes = np.array([x[0] for x in lb], dtype=np.float32)\n                    segments = [np.array(x[1:], dtype=np.float32).reshape(-1, 2) for x in lb]  # (cls, xy1...)\n                    lb = np.concatenate((classes.reshape(-1, 1), segments2boxes(segments)), 1)  # (cls, xywh)\n                lb = np.array(lb, dtype=np.float32)\n            nl = len(lb)\n            if nl:\n                if keypoint:\n                    assert lb.shape[1] == (5 + nkpt * ndim), f\"labels require {(5 + nkpt * ndim)} columns each\"\n                    points = lb[:, 5:].reshape(-1, ndim)[:, :2]\n                else:\n                    assert lb.shape[1] == 5, f\"labels require 5 columns, {lb.shape[1]} columns detected\"\n                    points = lb[:, 1:]\n                assert points.max() &lt;= 1, f\"non-normalized or out of bounds coordinates {points[points &gt; 1]}\"\n                assert lb.min() &gt;= 0, f\"negative label values {lb[lb &lt; 0]}\"\n\n                # All labels\n                max_cls = lb[:, 0].max()  # max label count\n                assert max_cls &lt;= num_cls, (\n                    f\"Label class {int(max_cls)} exceeds dataset class count {num_cls}. \"\n                    f\"Possible class labels are 0-{num_cls - 1}\"\n                )\n                _, i = np.unique(lb, axis=0, return_index=True)\n                if len(i) &lt; nl:  # duplicate row check\n                    lb = lb[i]  # remove duplicates\n                    if segments:\n                        segments = [segments[x] for x in i]\n                    msg = f\"{prefix}WARNING \u26a0\ufe0f {im_file}: {nl - len(i)} duplicate labels removed\"\n            else:\n                ne = 1  # label empty\n                lb = np.zeros((0, (5 + nkpt * ndim) if keypoint else 5), dtype=np.float32)\n        else:\n            nm = 1  # label missing\n            lb = np.zeros((0, (5 + nkpt * ndim) if keypoints else 5), dtype=np.float32)\n        if keypoint:\n            keypoints = lb[:, 5:].reshape(-1, nkpt, ndim)\n            if ndim == 2:\n                kpt_mask = np.where((keypoints[..., 0] &lt; 0) | (keypoints[..., 1] &lt; 0), 0.0, 1.0).astype(np.float32)\n                keypoints = np.concatenate([keypoints, kpt_mask[..., None]], axis=-1)  # (nl, nkpt, 3)\n        lb = lb[:, :5]\n        return im_file, lb, shape, segments, keypoints, nm, nf, ne, nc, msg\n    except Exception as e:\n        nc = 1\n        msg = f\"{prefix}WARNING \u26a0\ufe0f {im_file}: ignoring corrupt image/label: {e}\"\n        return [None, None, None, None, None, nm, nf, ne, nc, msg]\n</code></pre>"},{"location":"reference/data/utils/#ultralytics.data.utils.polygon2mask","title":"<code>ultralytics.data.utils.polygon2mask(imgsz, polygons, color=1, downsample_ratio=1)</code>","text":"<p>Convert a list of polygons to a binary mask of the specified image size.</p> <p>Parameters:</p> Name Type Description Default <code>imgsz</code> <code>tuple</code> <p>The size of the image as (height, width).</p> required <code>polygons</code> <code>list[ndarray]</code> <p>A list of polygons. Each polygon is an array with shape [N, M], where                          N is the number of polygons, and M is the number of points such that M % 2 = 0.</p> required <code>color</code> <code>int</code> <p>The color value to fill in the polygons on the mask. Defaults to 1.</p> <code>1</code> <code>downsample_ratio</code> <code>int</code> <p>Factor by which to downsample the mask. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A binary mask of the specified image size with the polygons filled in.</p> Source code in <code>ultralytics/data/utils.py</code> <pre><code>def polygon2mask(imgsz, polygons, color=1, downsample_ratio=1):\n    \"\"\"\n    Convert a list of polygons to a binary mask of the specified image size.\n\n    Args:\n        imgsz (tuple): The size of the image as (height, width).\n        polygons (list[np.ndarray]): A list of polygons. Each polygon is an array with shape [N, M], where\n                                     N is the number of polygons, and M is the number of points such that M % 2 = 0.\n        color (int, optional): The color value to fill in the polygons on the mask. Defaults to 1.\n        downsample_ratio (int, optional): Factor by which to downsample the mask. Defaults to 1.\n\n    Returns:\n        (np.ndarray): A binary mask of the specified image size with the polygons filled in.\n    \"\"\"\n    mask = np.zeros(imgsz, dtype=np.uint8)\n    polygons = np.asarray(polygons, dtype=np.int32)\n    polygons = polygons.reshape((polygons.shape[0], -1, 2))\n    cv2.fillPoly(mask, polygons, color=color)\n    nh, nw = (imgsz[0] // downsample_ratio, imgsz[1] // downsample_ratio)\n    # Note: fillPoly first then resize is trying to keep the same loss calculation method when mask-ratio=1\n    return cv2.resize(mask, (nw, nh))\n</code></pre>"},{"location":"reference/data/utils/#ultralytics.data.utils.polygons2masks","title":"<code>ultralytics.data.utils.polygons2masks(imgsz, polygons, color, downsample_ratio=1)</code>","text":"<p>Convert a list of polygons to a set of binary masks of the specified image size.</p> <p>Parameters:</p> Name Type Description Default <code>imgsz</code> <code>tuple</code> <p>The size of the image as (height, width).</p> required <code>polygons</code> <code>list[ndarray]</code> <p>A list of polygons. Each polygon is an array with shape [N, M], where                          N is the number of polygons, and M is the number of points such that M % 2 = 0.</p> required <code>color</code> <code>int</code> <p>The color value to fill in the polygons on the masks.</p> required <code>downsample_ratio</code> <code>int</code> <p>Factor by which to downsample each mask. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A set of binary masks of the specified image size with the polygons filled in.</p> Source code in <code>ultralytics/data/utils.py</code> <pre><code>def polygons2masks(imgsz, polygons, color, downsample_ratio=1):\n    \"\"\"\n    Convert a list of polygons to a set of binary masks of the specified image size.\n\n    Args:\n        imgsz (tuple): The size of the image as (height, width).\n        polygons (list[np.ndarray]): A list of polygons. Each polygon is an array with shape [N, M], where\n                                     N is the number of polygons, and M is the number of points such that M % 2 = 0.\n        color (int): The color value to fill in the polygons on the masks.\n        downsample_ratio (int, optional): Factor by which to downsample each mask. Defaults to 1.\n\n    Returns:\n        (np.ndarray): A set of binary masks of the specified image size with the polygons filled in.\n    \"\"\"\n    return np.array([polygon2mask(imgsz, [x.reshape(-1)], color, downsample_ratio) for x in polygons])\n</code></pre>"},{"location":"reference/data/utils/#ultralytics.data.utils.polygons2masks_overlap","title":"<code>ultralytics.data.utils.polygons2masks_overlap(imgsz, segments, downsample_ratio=1)</code>","text":"<p>Return a (640, 640) overlap mask.</p> Source code in <code>ultralytics/data/utils.py</code> <pre><code>def polygons2masks_overlap(imgsz, segments, downsample_ratio=1):\n    \"\"\"Return a (640, 640) overlap mask.\"\"\"\n    masks = np.zeros(\n        (imgsz[0] // downsample_ratio, imgsz[1] // downsample_ratio),\n        dtype=np.int32 if len(segments) &gt; 255 else np.uint8,\n    )\n    areas = []\n    ms = []\n    for si in range(len(segments)):\n        mask = polygon2mask(imgsz, [segments[si].reshape(-1)], downsample_ratio=downsample_ratio, color=1)\n        ms.append(mask)\n        areas.append(mask.sum())\n    areas = np.asarray(areas)\n    index = np.argsort(-areas)\n    ms = np.array(ms)[index]\n    for i in range(len(segments)):\n        mask = ms[i] * (i + 1)\n        masks = masks + mask\n        masks = np.clip(masks, a_min=0, a_max=i + 1)\n    return masks, index\n</code></pre>"},{"location":"reference/data/utils/#ultralytics.data.utils.find_dataset_yaml","title":"<code>ultralytics.data.utils.find_dataset_yaml(path)</code>","text":"<p>Find and return the YAML file associated with a Detect, Segment or Pose dataset.</p> <p>This function searches for a YAML file at the root level of the provided directory first, and if not found, it performs a recursive search. It prefers YAML files that have the same stem as the provided path. An AssertionError is raised if no YAML file is found or if multiple YAML files are found.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The directory path to search for the YAML file.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The path of the found YAML file.</p> Source code in <code>ultralytics/data/utils.py</code> <pre><code>def find_dataset_yaml(path: Path) -&gt; Path:\n    \"\"\"\n    Find and return the YAML file associated with a Detect, Segment or Pose dataset.\n\n    This function searches for a YAML file at the root level of the provided directory first, and if not found, it\n    performs a recursive search. It prefers YAML files that have the same stem as the provided path. An AssertionError\n    is raised if no YAML file is found or if multiple YAML files are found.\n\n    Args:\n        path (Path): The directory path to search for the YAML file.\n\n    Returns:\n        (Path): The path of the found YAML file.\n    \"\"\"\n    files = list(path.glob(\"*.yaml\")) or list(path.rglob(\"*.yaml\"))  # try root level first and then recursive\n    assert files, f\"No YAML file found in '{path.resolve()}'\"\n    if len(files) &gt; 1:\n        files = [f for f in files if f.stem == path.stem]  # prefer *.yaml files that match\n    assert len(files) == 1, f\"Expected 1 YAML file in '{path.resolve()}', but found {len(files)}.\\n{files}\"\n    return files[0]\n</code></pre>"},{"location":"reference/data/utils/#ultralytics.data.utils.check_det_dataset","title":"<code>ultralytics.data.utils.check_det_dataset(dataset, autodownload=True)</code>","text":"<p>Download, verify, and/or unzip a dataset if not found locally.</p> <p>This function checks the availability of a specified dataset, and if not found, it has the option to download and unzip the dataset. It then reads and parses the accompanying YAML data, ensuring key requirements are met and also resolves paths related to the dataset.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>str</code> <p>Path to the dataset or dataset descriptor (like a YAML file).</p> required <code>autodownload</code> <code>bool</code> <p>Whether to automatically download the dataset if not found. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict</code> <p>Parsed dataset information and paths.</p> Source code in <code>ultralytics/data/utils.py</code> <pre><code>def check_det_dataset(dataset, autodownload=True):\n    \"\"\"\n    Download, verify, and/or unzip a dataset if not found locally.\n\n    This function checks the availability of a specified dataset, and if not found, it has the option to download and\n    unzip the dataset. It then reads and parses the accompanying YAML data, ensuring key requirements are met and also\n    resolves paths related to the dataset.\n\n    Args:\n        dataset (str): Path to the dataset or dataset descriptor (like a YAML file).\n        autodownload (bool, optional): Whether to automatically download the dataset if not found. Defaults to True.\n\n    Returns:\n        (dict): Parsed dataset information and paths.\n    \"\"\"\n\n    file = check_file(dataset)\n\n    # Download (optional)\n    extract_dir = \"\"\n    if zipfile.is_zipfile(file) or is_tarfile(file):\n        new_dir = safe_download(file, dir=DATASETS_DIR, unzip=True, delete=False)\n        file = find_dataset_yaml(DATASETS_DIR / new_dir)\n        extract_dir, autodownload = file.parent, False\n\n    # Read YAML\n    data = yaml_load(file, append_filename=True)  # dictionary\n\n    # Checks\n    for k in \"train\", \"val\":\n        if k not in data:\n            if k != \"val\" or \"validation\" not in data:\n                raise SyntaxError(\n                    emojis(f\"{dataset} '{k}:' key missing \u274c.\\n'train' and 'val' are required in all data YAMLs.\")\n                )\n            LOGGER.info(\"WARNING \u26a0\ufe0f renaming data YAML 'validation' key to 'val' to match YOLO format.\")\n            data[\"val\"] = data.pop(\"validation\")  # replace 'validation' key with 'val' key\n    if \"names\" not in data and \"nc\" not in data:\n        raise SyntaxError(emojis(f\"{dataset} key missing \u274c.\\n either 'names' or 'nc' are required in all data YAMLs.\"))\n    if \"names\" in data and \"nc\" in data and len(data[\"names\"]) != data[\"nc\"]:\n        raise SyntaxError(emojis(f\"{dataset} 'names' length {len(data['names'])} and 'nc: {data['nc']}' must match.\"))\n    if \"names\" not in data:\n        data[\"names\"] = [f\"class_{i}\" for i in range(data[\"nc\"])]\n    else:\n        data[\"nc\"] = len(data[\"names\"])\n\n    data[\"names\"] = check_class_names(data[\"names\"])\n\n    # Resolve paths\n    path = Path(extract_dir or data.get(\"path\") or Path(data.get(\"yaml_file\", \"\")).parent)  # dataset root\n    if not path.is_absolute():\n        path = (DATASETS_DIR / path).resolve()\n\n    # Set paths\n    data[\"path\"] = path  # download scripts\n    for k in \"train\", \"val\", \"test\":\n        if data.get(k):  # prepend path\n            if isinstance(data[k], str):\n                x = (path / data[k]).resolve()\n                if not x.exists() and data[k].startswith(\"../\"):\n                    x = (path / data[k][3:]).resolve()\n                data[k] = str(x)\n            else:\n                data[k] = [str((path / x).resolve()) for x in data[k]]\n\n    # Parse YAML\n    val, s = (data.get(x) for x in (\"val\", \"download\"))\n    if val:\n        val = [Path(x).resolve() for x in (val if isinstance(val, list) else [val])]  # val path\n        if not all(x.exists() for x in val):\n            name = clean_url(dataset)  # dataset name with URL auth stripped\n            m = f\"\\nDataset '{name}' images not found \u26a0\ufe0f, missing path '{[x for x in val if not x.exists()][0]}'\"\n            if s and autodownload:\n                LOGGER.warning(m)\n            else:\n                m += f\"\\nNote dataset download directory is '{DATASETS_DIR}'. You can update this in '{SETTINGS_YAML}'\"\n                raise FileNotFoundError(m)\n            t = time.time()\n            r = None  # success\n            if s.startswith(\"http\") and s.endswith(\".zip\"):  # URL\n                safe_download(url=s, dir=DATASETS_DIR, delete=True)\n            elif s.startswith(\"bash \"):  # bash script\n                LOGGER.info(f\"Running {s} ...\")\n                r = os.system(s)\n            else:  # python script\n                exec(s, {\"yaml\": data})\n            dt = f\"({round(time.time() - t, 1)}s)\"\n            s = f\"success \u2705 {dt}, saved to {colorstr('bold', DATASETS_DIR)}\" if r in (0, None) else f\"failure {dt} \u274c\"\n            LOGGER.info(f\"Dataset download {s}\\n\")\n    check_font(\"Arial.ttf\" if is_ascii(data[\"names\"]) else \"Arial.Unicode.ttf\")  # download fonts\n\n    return data  # dictionary\n</code></pre>"},{"location":"reference/data/utils/#ultralytics.data.utils.check_cls_dataset","title":"<code>ultralytics.data.utils.check_cls_dataset(dataset, split='')</code>","text":"<p>Checks a classification dataset such as Imagenet.</p> <p>This function accepts a <code>dataset</code> name and attempts to retrieve the corresponding dataset information. If the dataset is not found locally, it attempts to download the dataset from the internet and save it locally.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>str | Path</code> <p>The name of the dataset.</p> required <code>split</code> <code>str</code> <p>The split of the dataset. Either 'val', 'test', or ''. Defaults to ''.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the following keys: - 'train' (Path): The directory path containing the training set of the dataset. - 'val' (Path): The directory path containing the validation set of the dataset. - 'test' (Path): The directory path containing the test set of the dataset. - 'nc' (int): The number of classes in the dataset. - 'names' (dict): A dictionary of class names in the dataset.</p> Source code in <code>ultralytics/data/utils.py</code> <pre><code>def check_cls_dataset(dataset, split=\"\"):\n    \"\"\"\n    Checks a classification dataset such as Imagenet.\n\n    This function accepts a `dataset` name and attempts to retrieve the corresponding dataset information.\n    If the dataset is not found locally, it attempts to download the dataset from the internet and save it locally.\n\n    Args:\n        dataset (str | Path): The name of the dataset.\n        split (str, optional): The split of the dataset. Either 'val', 'test', or ''. Defaults to ''.\n\n    Returns:\n        (dict): A dictionary containing the following keys:\n            - 'train' (Path): The directory path containing the training set of the dataset.\n            - 'val' (Path): The directory path containing the validation set of the dataset.\n            - 'test' (Path): The directory path containing the test set of the dataset.\n            - 'nc' (int): The number of classes in the dataset.\n            - 'names' (dict): A dictionary of class names in the dataset.\n    \"\"\"\n\n    # Download (optional if dataset=https://file.zip is passed directly)\n    if str(dataset).startswith((\"http:/\", \"https:/\")):\n        dataset = safe_download(dataset, dir=DATASETS_DIR, unzip=True, delete=False)\n\n    dataset = Path(dataset)\n    data_dir = (dataset if dataset.is_dir() else (DATASETS_DIR / dataset)).resolve()\n    if not data_dir.is_dir():\n        LOGGER.warning(f\"\\nDataset not found \u26a0\ufe0f, missing path {data_dir}, attempting download...\")\n        t = time.time()\n        if str(dataset) == \"imagenet\":\n            subprocess.run(f\"bash {ROOT / 'data/scripts/get_imagenet.sh'}\", shell=True, check=True)\n        else:\n            url = f\"https://github.com/ultralytics/yolov5/releases/download/v1.0/{dataset}.zip\"\n            download(url, dir=data_dir.parent)\n        s = f\"Dataset download success \u2705 ({time.time() - t:.1f}s), saved to {colorstr('bold', data_dir)}\\n\"\n        LOGGER.info(s)\n    train_set = data_dir / \"train\"\n    val_set = (\n        data_dir / \"val\"\n        if (data_dir / \"val\").exists()\n        else data_dir / \"validation\"\n        if (data_dir / \"validation\").exists()\n        else None\n    )  # data/test or data/val\n    test_set = data_dir / \"test\" if (data_dir / \"test\").exists() else None  # data/val or data/test\n    if split == \"val\" and not val_set:\n        LOGGER.warning(\"WARNING \u26a0\ufe0f Dataset 'split=val' not found, using 'split=test' instead.\")\n    elif split == \"test\" and not test_set:\n        LOGGER.warning(\"WARNING \u26a0\ufe0f Dataset 'split=test' not found, using 'split=val' instead.\")\n\n    nc = len([x for x in (data_dir / \"train\").glob(\"*\") if x.is_dir()])  # number of classes\n    names = [x.name for x in (data_dir / \"train\").iterdir() if x.is_dir()]  # class names list\n    names = dict(enumerate(sorted(names)))\n\n    # Print to console\n    for k, v in {\"train\": train_set, \"val\": val_set, \"test\": test_set}.items():\n        prefix = f'{colorstr(f\"{k}:\")} {v}...'\n        if v is None:\n            LOGGER.info(prefix)\n        else:\n            files = [path for path in v.rglob(\"*.*\") if path.suffix[1:].lower() in IMG_FORMATS]\n            nf = len(files)  # number of files\n            nd = len({file.parent for file in files})  # number of directories\n            if nf == 0:\n                if k == \"train\":\n                    raise FileNotFoundError(emojis(f\"{dataset} '{k}:' no training images found \u274c \"))\n                else:\n                    LOGGER.warning(f\"{prefix} found {nf} images in {nd} classes: WARNING \u26a0\ufe0f no images found\")\n            elif nd != nc:\n                LOGGER.warning(f\"{prefix} found {nf} images in {nd} classes: ERROR \u274c\ufe0f requires {nc} classes, not {nd}\")\n            else:\n                LOGGER.info(f\"{prefix} found {nf} images in {nd} classes \u2705 \")\n\n    return {\"train\": train_set, \"val\": val_set, \"test\": test_set, \"nc\": nc, \"names\": names}\n</code></pre>"},{"location":"reference/data/utils/#ultralytics.data.utils.compress_one_image","title":"<code>ultralytics.data.utils.compress_one_image(f, f_new=None, max_dim=1920, quality=50)</code>","text":"<p>Compresses a single image file to reduced size while preserving its aspect ratio and quality using either the Python Imaging Library (PIL) or OpenCV library. If the input image is smaller than the maximum dimension, it will not be resized.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>str</code> <p>The path to the input image file.</p> required <code>f_new</code> <code>str</code> <p>The path to the output image file. If not specified, the input file will be overwritten.</p> <code>None</code> <code>max_dim</code> <code>int</code> <p>The maximum dimension (width or height) of the output image. Default is 1920 pixels.</p> <code>1920</code> <code>quality</code> <code>int</code> <p>The image compression quality as a percentage. Default is 50%.</p> <code>50</code> Example <pre><code>from pathlib import Path\nfrom ultralytics.data.utils import compress_one_image\n\nfor f in Path('path/to/dataset').rglob('*.jpg'):\n    compress_one_image(f)\n</code></pre> Source code in <code>ultralytics/data/utils.py</code> <pre><code>def compress_one_image(f, f_new=None, max_dim=1920, quality=50):\n    \"\"\"\n    Compresses a single image file to reduced size while preserving its aspect ratio and quality using either the Python\n    Imaging Library (PIL) or OpenCV library. If the input image is smaller than the maximum dimension, it will not be\n    resized.\n\n    Args:\n        f (str): The path to the input image file.\n        f_new (str, optional): The path to the output image file. If not specified, the input file will be overwritten.\n        max_dim (int, optional): The maximum dimension (width or height) of the output image. Default is 1920 pixels.\n        quality (int, optional): The image compression quality as a percentage. Default is 50%.\n\n    Example:\n        ```python\n        from pathlib import Path\n        from ultralytics.data.utils import compress_one_image\n\n        for f in Path('path/to/dataset').rglob('*.jpg'):\n            compress_one_image(f)\n        ```\n    \"\"\"\n\n    try:  # use PIL\n        im = Image.open(f)\n        r = max_dim / max(im.height, im.width)  # ratio\n        if r &lt; 1.0:  # image too large\n            im = im.resize((int(im.width * r), int(im.height * r)))\n        im.save(f_new or f, \"JPEG\", quality=quality, optimize=True)  # save\n    except Exception as e:  # use OpenCV\n        LOGGER.info(f\"WARNING \u26a0\ufe0f HUB ops PIL failure {f}: {e}\")\n        im = cv2.imread(f)\n        im_height, im_width = im.shape[:2]\n        r = max_dim / max(im_height, im_width)  # ratio\n        if r &lt; 1.0:  # image too large\n            im = cv2.resize(im, (int(im_width * r), int(im_height * r)), interpolation=cv2.INTER_AREA)\n        cv2.imwrite(str(f_new or f), im)\n</code></pre>"},{"location":"reference/data/utils/#ultralytics.data.utils.autosplit","title":"<code>ultralytics.data.utils.autosplit(path=DATASETS_DIR / 'coco8/images', weights=(0.9, 0.1, 0.0), annotated_only=False)</code>","text":"<p>Automatically split a dataset into train/val/test splits and save the resulting splits into autosplit_*.txt files.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to images directory. Defaults to DATASETS_DIR / 'coco8/images'.</p> <code>DATASETS_DIR / 'coco8/images'</code> <code>weights</code> <code>list | tuple</code> <p>Train, validation, and test split fractions. Defaults to (0.9, 0.1, 0.0).</p> <code>(0.9, 0.1, 0.0)</code> <code>annotated_only</code> <code>bool</code> <p>If True, only images with an associated txt file are used. Defaults to False.</p> <code>False</code> Example <pre><code>from ultralytics.data.utils import autosplit\n\nautosplit()\n</code></pre> Source code in <code>ultralytics/data/utils.py</code> <pre><code>def autosplit(path=DATASETS_DIR / \"coco8/images\", weights=(0.9, 0.1, 0.0), annotated_only=False):\n    \"\"\"\n    Automatically split a dataset into train/val/test splits and save the resulting splits into autosplit_*.txt files.\n\n    Args:\n        path (Path, optional): Path to images directory. Defaults to DATASETS_DIR / 'coco8/images'.\n        weights (list | tuple, optional): Train, validation, and test split fractions. Defaults to (0.9, 0.1, 0.0).\n        annotated_only (bool, optional): If True, only images with an associated txt file are used. Defaults to False.\n\n    Example:\n        ```python\n        from ultralytics.data.utils import autosplit\n\n        autosplit()\n        ```\n    \"\"\"\n\n    path = Path(path)  # images dir\n    files = sorted(x for x in path.rglob(\"*.*\") if x.suffix[1:].lower() in IMG_FORMATS)  # image files only\n    n = len(files)  # number of files\n    random.seed(0)  # for reproducibility\n    indices = random.choices([0, 1, 2], weights=weights, k=n)  # assign each image to a split\n\n    txt = [\"autosplit_train.txt\", \"autosplit_val.txt\", \"autosplit_test.txt\"]  # 3 txt files\n    for x in txt:\n        if (path.parent / x).exists():\n            (path.parent / x).unlink()  # remove existing\n\n    LOGGER.info(f\"Autosplitting images from {path}\" + \", using *.txt labeled images only\" * annotated_only)\n    for i, img in TQDM(zip(indices, files), total=n):\n        if not annotated_only or Path(img2label_paths([str(img)])[0]).exists():  # check label\n            with open(path.parent / txt[i], \"a\") as f:\n                f.write(f\"./{img.relative_to(path.parent).as_posix()}\" + \"\\n\")  # add image to txt file\n</code></pre>"},{"location":"reference/engine/exporter/","title":"Reference for <code>ultralytics/engine/exporter.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/engine/exporter.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/engine/exporter/#ultralytics.engine.exporter.Exporter","title":"<code>ultralytics.engine.exporter.Exporter</code>","text":"<p>A class for exporting a model.</p> <p>Attributes:</p> Name Type Description <code>args</code> <code>SimpleNamespace</code> <p>Configuration for the exporter.</p> <code>callbacks</code> <code>list</code> <p>List of callback functions. Defaults to None.</p> Source code in <code>ultralytics/engine/exporter.py</code> <pre><code>class Exporter:\n    \"\"\"\n    A class for exporting a model.\n\n    Attributes:\n        args (SimpleNamespace): Configuration for the exporter.\n        callbacks (list, optional): List of callback functions. Defaults to None.\n    \"\"\"\n\n    def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n        \"\"\"\n        Initializes the Exporter class.\n\n        Args:\n            cfg (str, optional): Path to a configuration file. Defaults to DEFAULT_CFG.\n            overrides (dict, optional): Configuration overrides. Defaults to None.\n            _callbacks (dict, optional): Dictionary of callback functions. Defaults to None.\n        \"\"\"\n        self.args = get_cfg(cfg, overrides)\n        if self.args.format.lower() in (\"coreml\", \"mlmodel\"):  # fix attempt for protobuf&lt;3.20.x errors\n            os.environ[\"PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION\"] = \"python\"  # must run before TensorBoard callback\n\n        self.callbacks = _callbacks or callbacks.get_default_callbacks()\n        callbacks.add_integration_callbacks(self)\n\n    @smart_inference_mode()\n    def __call__(self, model=None):\n        \"\"\"Returns list of exported files/dirs after running callbacks.\"\"\"\n        self.run_callbacks(\"on_export_start\")\n        t = time.time()\n        fmt = self.args.format.lower()  # to lowercase\n        if fmt in (\"tensorrt\", \"trt\"):  # 'engine' aliases\n            fmt = \"engine\"\n        if fmt in (\"mlmodel\", \"mlpackage\", \"mlprogram\", \"apple\", \"ios\", \"coreml\"):  # 'coreml' aliases\n            fmt = \"coreml\"\n        fmts = tuple(export_formats()[\"Argument\"][1:])  # available export formats\n        flags = [x == fmt for x in fmts]\n        if sum(flags) != 1:\n            raise ValueError(f\"Invalid export format='{fmt}'. Valid formats are {fmts}\")\n        jit, onnx, xml, engine, coreml, saved_model, pb, tflite, edgetpu, tfjs, paddle, ncnn = flags  # export booleans\n\n        # Device\n        if fmt == \"engine\" and self.args.device is None:\n            LOGGER.warning(\"WARNING \u26a0\ufe0f TensorRT requires GPU export, automatically assigning device=0\")\n            self.args.device = \"0\"\n        self.device = select_device(\"cpu\" if self.args.device is None else self.args.device)\n\n        # Checks\n        if not hasattr(model, \"names\"):\n            model.names = default_class_names()\n        model.names = check_class_names(model.names)\n        if self.args.half and onnx and self.device.type == \"cpu\":\n            LOGGER.warning(\"WARNING \u26a0\ufe0f half=True only compatible with GPU export, i.e. use device=0\")\n            self.args.half = False\n            assert not self.args.dynamic, \"half=True not compatible with dynamic=True, i.e. use only one.\"\n        self.imgsz = check_imgsz(self.args.imgsz, stride=model.stride, min_dim=2)  # check image size\n        if self.args.optimize:\n            assert not ncnn, \"optimize=True not compatible with format='ncnn', i.e. use optimize=False\"\n            assert self.device.type == \"cpu\", \"optimize=True not compatible with cuda devices, i.e. use device='cpu'\"\n        if edgetpu and not LINUX:\n            raise SystemError(\"Edge TPU export only supported on Linux. See https://coral.ai/docs/edgetpu/compiler/\")\n\n        # Input\n        im = torch.zeros(self.args.batch, 3, *self.imgsz).to(self.device)\n        file = Path(\n            getattr(model, \"pt_path\", None) or getattr(model, \"yaml_file\", None) or model.yaml.get(\"yaml_file\", \"\")\n        )\n        if file.suffix in {\".yaml\", \".yml\"}:\n            file = Path(file.name)\n\n        # Update model\n        model = deepcopy(model).to(self.device)\n        for p in model.parameters():\n            p.requires_grad = False\n        model.eval()\n        model.float()\n        model = model.fuse()\n        for m in model.modules():\n            if isinstance(m, (Detect, RTDETRDecoder)):  # Segment and Pose use Detect base class\n                m.dynamic = self.args.dynamic\n                m.export = True\n                m.format = self.args.format\n            elif isinstance(m, C2f) and not any((saved_model, pb, tflite, edgetpu, tfjs)):\n                # EdgeTPU does not support FlexSplitV while split provides cleaner ONNX graph\n                m.forward = m.forward_split\n\n        y = None\n        for _ in range(2):\n            y = model(im)  # dry runs\n        if self.args.half and (engine or onnx) and self.device.type != \"cpu\":\n            im, model = im.half(), model.half()  # to FP16\n\n        # Filter warnings\n        warnings.filterwarnings(\"ignore\", category=torch.jit.TracerWarning)  # suppress TracerWarning\n        warnings.filterwarnings(\"ignore\", category=UserWarning)  # suppress shape prim::Constant missing ONNX warning\n        warnings.filterwarnings(\"ignore\", category=DeprecationWarning)  # suppress CoreML np.bool deprecation warning\n\n        # Assign\n        self.im = im\n        self.model = model\n        self.file = file\n        self.output_shape = (\n            tuple(y.shape)\n            if isinstance(y, torch.Tensor)\n            else tuple(tuple(x.shape if isinstance(x, torch.Tensor) else []) for x in y)\n        )\n        self.pretty_name = Path(self.model.yaml.get(\"yaml_file\", self.file)).stem.replace(\"yolo\", \"YOLO\")\n        data = model.args[\"data\"] if hasattr(model, \"args\") and isinstance(model.args, dict) else \"\"\n        description = f'Ultralytics {self.pretty_name} model {f\"trained on {data}\" if data else \"\"}'\n        self.metadata = {\n            \"description\": description,\n            \"author\": \"Ultralytics\",\n            \"license\": \"AGPL-3.0 https://ultralytics.com/license\",\n            \"date\": datetime.now().isoformat(),\n            \"version\": __version__,\n            \"stride\": int(max(model.stride)),\n            \"task\": model.task,\n            \"batch\": self.args.batch,\n            \"imgsz\": self.imgsz,\n            \"names\": model.names,\n        }  # model metadata\n        if model.task == \"pose\":\n            self.metadata[\"kpt_shape\"] = model.model[-1].kpt_shape\n\n        LOGGER.info(\n            f\"\\n{colorstr('PyTorch:')} starting from '{file}' with input shape {tuple(im.shape)} BCHW and \"\n            f'output shape(s) {self.output_shape} ({file_size(file):.1f} MB)'\n        )\n\n        # Exports\n        f = [\"\"] * len(fmts)  # exported filenames\n        if jit or ncnn:  # TorchScript\n            f[0], _ = self.export_torchscript()\n        if engine:  # TensorRT required before ONNX\n            f[1], _ = self.export_engine()\n        if onnx or xml:  # OpenVINO requires ONNX\n            f[2], _ = self.export_onnx()\n        if xml:  # OpenVINO\n            f[3], _ = self.export_openvino()\n        if coreml:  # CoreML\n            f[4], _ = self.export_coreml()\n        if any((saved_model, pb, tflite, edgetpu, tfjs)):  # TensorFlow formats\n            self.args.int8 |= edgetpu\n            f[5], keras_model = self.export_saved_model()\n            if pb or tfjs:  # pb prerequisite to tfjs\n                f[6], _ = self.export_pb(keras_model=keras_model)\n            if tflite:\n                f[7], _ = self.export_tflite(keras_model=keras_model, nms=False, agnostic_nms=self.args.agnostic_nms)\n            if edgetpu:\n                f[8], _ = self.export_edgetpu(tflite_model=Path(f[5]) / f\"{self.file.stem}_full_integer_quant.tflite\")\n            if tfjs:\n                f[9], _ = self.export_tfjs()\n        if paddle:  # PaddlePaddle\n            f[10], _ = self.export_paddle()\n        if ncnn:  # ncnn\n            f[11], _ = self.export_ncnn()\n\n        # Finish\n        f = [str(x) for x in f if x]  # filter out '' and None\n        if any(f):\n            f = str(Path(f[-1]))\n            square = self.imgsz[0] == self.imgsz[1]\n            s = (\n                \"\"\n                if square\n                else f\"WARNING \u26a0\ufe0f non-PyTorch val requires square images, 'imgsz={self.imgsz}' will not \"\n                f\"work. Use export 'imgsz={max(self.imgsz)}' if val is required.\"\n            )\n            imgsz = self.imgsz[0] if square else str(self.imgsz)[1:-1].replace(\" \", \"\")\n            predict_data = f\"data={data}\" if model.task == \"segment\" and fmt == \"pb\" else \"\"\n            q = \"int8\" if self.args.int8 else \"half\" if self.args.half else \"\"  # quantization\n            LOGGER.info(\n                f'\\nExport complete ({time.time() - t:.1f}s)'\n                f\"\\nResults saved to {colorstr('bold', file.parent.resolve())}\"\n                f'\\nPredict:         yolo predict task={model.task} model={f} imgsz={imgsz} {q} {predict_data}'\n                f'\\nValidate:        yolo val task={model.task} model={f} imgsz={imgsz} data={data} {q} {s}'\n                f'\\nVisualize:       https://netron.app'\n            )\n\n        self.run_callbacks(\"on_export_end\")\n        return f  # return list of exported files/dirs\n\n    @try_export\n    def export_torchscript(self, prefix=colorstr(\"TorchScript:\")):\n        \"\"\"YOLOv8 TorchScript model export.\"\"\"\n        LOGGER.info(f\"\\n{prefix} starting export with torch {torch.__version__}...\")\n        f = self.file.with_suffix(\".torchscript\")\n\n        ts = torch.jit.trace(self.model, self.im, strict=False)\n        extra_files = {\"config.txt\": json.dumps(self.metadata)}  # torch._C.ExtraFilesMap()\n        if self.args.optimize:  # https://pytorch.org/tutorials/recipes/mobile_interpreter.html\n            LOGGER.info(f\"{prefix} optimizing for mobile...\")\n            from torch.utils.mobile_optimizer import optimize_for_mobile\n\n            optimize_for_mobile(ts)._save_for_lite_interpreter(str(f), _extra_files=extra_files)\n        else:\n            ts.save(str(f), _extra_files=extra_files)\n        return f, None\n\n    @try_export\n    def export_onnx(self, prefix=colorstr(\"ONNX:\")):\n        \"\"\"YOLOv8 ONNX export.\"\"\"\n        requirements = [\"onnx&gt;=1.12.0\"]\n        if self.args.simplify:\n            requirements += [\"onnxsim&gt;=0.4.33\", \"onnxruntime-gpu\" if torch.cuda.is_available() else \"onnxruntime\"]\n        check_requirements(requirements)\n        import onnx  # noqa\n\n        opset_version = self.args.opset or get_latest_opset()\n        LOGGER.info(f\"\\n{prefix} starting export with onnx {onnx.__version__} opset {opset_version}...\")\n        f = str(self.file.with_suffix(\".onnx\"))\n\n        output_names = [\"output0\", \"output1\"] if isinstance(self.model, SegmentationModel) else [\"output0\"]\n        dynamic = self.args.dynamic\n        if dynamic:\n            dynamic = {\"images\": {0: \"batch\", 2: \"height\", 3: \"width\"}}  # shape(1,3,640,640)\n            if isinstance(self.model, SegmentationModel):\n                dynamic[\"output0\"] = {0: \"batch\", 2: \"anchors\"}  # shape(1, 116, 8400)\n                dynamic[\"output1\"] = {0: \"batch\", 2: \"mask_height\", 3: \"mask_width\"}  # shape(1,32,160,160)\n            elif isinstance(self.model, DetectionModel):\n                dynamic[\"output0\"] = {0: \"batch\", 2: \"anchors\"}  # shape(1, 84, 8400)\n\n        torch.onnx.export(\n            self.model.cpu() if dynamic else self.model,  # dynamic=True only compatible with cpu\n            self.im.cpu() if dynamic else self.im,\n            f,\n            verbose=False,\n            opset_version=opset_version,\n            do_constant_folding=True,  # WARNING: DNN inference with torch&gt;=1.12 may require do_constant_folding=False\n            input_names=[\"images\"],\n            output_names=output_names,\n            dynamic_axes=dynamic or None,\n        )\n\n        # Checks\n        model_onnx = onnx.load(f)  # load onnx model\n        # onnx.checker.check_model(model_onnx)  # check onnx model\n\n        # Simplify\n        if self.args.simplify:\n            try:\n                import onnxsim\n\n                LOGGER.info(f\"{prefix} simplifying with onnxsim {onnxsim.__version__}...\")\n                # subprocess.run(f'onnxsim \"{f}\" \"{f}\"', shell=True)\n                model_onnx, check = onnxsim.simplify(model_onnx)\n                assert check, \"Simplified ONNX model could not be validated\"\n            except Exception as e:\n                LOGGER.info(f\"{prefix} simplifier failure: {e}\")\n\n        # Metadata\n        for k, v in self.metadata.items():\n            meta = model_onnx.metadata_props.add()\n            meta.key, meta.value = k, str(v)\n\n        onnx.save(model_onnx, f)\n        return f, model_onnx\n\n    @try_export\n    def export_openvino(self, prefix=colorstr(\"OpenVINO:\")):\n        \"\"\"YOLOv8 OpenVINO export.\"\"\"\n        check_requirements(\"openvino-dev&gt;=2023.0\")  # requires openvino-dev: https://pypi.org/project/openvino-dev/\n        import openvino.runtime as ov  # noqa\n        from openvino.tools import mo  # noqa\n\n        LOGGER.info(f\"\\n{prefix} starting export with openvino {ov.__version__}...\")\n        f = str(self.file).replace(self.file.suffix, f\"_openvino_model{os.sep}\")\n        fq = str(self.file).replace(self.file.suffix, f\"_int8_openvino_model{os.sep}\")\n        f_onnx = self.file.with_suffix(\".onnx\")\n        f_ov = str(Path(f) / self.file.with_suffix(\".xml\").name)\n        fq_ov = str(Path(fq) / self.file.with_suffix(\".xml\").name)\n\n        def serialize(ov_model, file):\n            \"\"\"Set RT info, serialize and save metadata YAML.\"\"\"\n            ov_model.set_rt_info(\"YOLOv8\", [\"model_info\", \"model_type\"])\n            ov_model.set_rt_info(True, [\"model_info\", \"reverse_input_channels\"])\n            ov_model.set_rt_info(114, [\"model_info\", \"pad_value\"])\n            ov_model.set_rt_info([255.0], [\"model_info\", \"scale_values\"])\n            ov_model.set_rt_info(self.args.iou, [\"model_info\", \"iou_threshold\"])\n            ov_model.set_rt_info([v.replace(\" \", \"_\") for v in self.model.names.values()], [\"model_info\", \"labels\"])\n            if self.model.task != \"classify\":\n                ov_model.set_rt_info(\"fit_to_window_letterbox\", [\"model_info\", \"resize_type\"])\n\n            ov.serialize(ov_model, file)  # save\n            yaml_save(Path(file).parent / \"metadata.yaml\", self.metadata)  # add metadata.yaml\n\n        ov_model = mo.convert_model(\n            f_onnx, model_name=self.pretty_name, framework=\"onnx\", compress_to_fp16=self.args.half\n        )  # export\n\n        if self.args.int8:\n            assert self.args.data, \"INT8 export requires a data argument for calibration, i.e. 'data=coco8.yaml'\"\n            check_requirements(\"nncf&gt;=2.5.0\")\n            import nncf\n\n            def transform_fn(data_item):\n                \"\"\"Quantization transform function.\"\"\"\n                im = data_item[\"img\"].numpy().astype(np.float32) / 255.0  # uint8 to fp16/32 and 0 - 255 to 0.0 - 1.0\n                return np.expand_dims(im, 0) if im.ndim == 3 else im\n\n            # Generate calibration data for integer quantization\n            LOGGER.info(f\"{prefix} collecting INT8 calibration images from 'data={self.args.data}'\")\n            data = check_det_dataset(self.args.data)\n            dataset = YOLODataset(data[\"val\"], data=data, imgsz=self.imgsz[0], augment=False)\n            quantization_dataset = nncf.Dataset(dataset, transform_fn)\n            ignored_scope = nncf.IgnoredScope(types=[\"Multiply\", \"Subtract\", \"Sigmoid\"])  # ignore operation\n            quantized_ov_model = nncf.quantize(\n                ov_model, quantization_dataset, preset=nncf.QuantizationPreset.MIXED, ignored_scope=ignored_scope\n            )\n            serialize(quantized_ov_model, fq_ov)\n            return fq, None\n\n        serialize(ov_model, f_ov)\n        return f, None\n\n    @try_export\n    def export_paddle(self, prefix=colorstr(\"PaddlePaddle:\")):\n        \"\"\"YOLOv8 Paddle export.\"\"\"\n        check_requirements((\"paddlepaddle\", \"x2paddle\"))\n        import x2paddle  # noqa\n        from x2paddle.convert import pytorch2paddle  # noqa\n\n        LOGGER.info(f\"\\n{prefix} starting export with X2Paddle {x2paddle.__version__}...\")\n        f = str(self.file).replace(self.file.suffix, f\"_paddle_model{os.sep}\")\n\n        pytorch2paddle(module=self.model, save_dir=f, jit_type=\"trace\", input_examples=[self.im])  # export\n        yaml_save(Path(f) / \"metadata.yaml\", self.metadata)  # add metadata.yaml\n        return f, None\n\n    @try_export\n    def export_ncnn(self, prefix=colorstr(\"ncnn:\")):\n        \"\"\"\n        YOLOv8 ncnn export using PNNX https://github.com/pnnx/pnnx.\n        \"\"\"\n        check_requirements(\"git+https://github.com/Tencent/ncnn.git\" if ARM64 else \"ncnn\")  # requires ncnn\n        import ncnn  # noqa\n\n        LOGGER.info(f\"\\n{prefix} starting export with ncnn {ncnn.__version__}...\")\n        f = Path(str(self.file).replace(self.file.suffix, f\"_ncnn_model{os.sep}\"))\n        f_ts = self.file.with_suffix(\".torchscript\")\n\n        name = Path(\"pnnx.exe\" if WINDOWS else \"pnnx\")  # PNNX filename\n        pnnx = name if name.is_file() else ROOT / name\n        if not pnnx.is_file():\n            LOGGER.warning(\n                f\"{prefix} WARNING \u26a0\ufe0f PNNX not found. Attempting to download binary file from \"\n                \"https://github.com/pnnx/pnnx/.\\nNote PNNX Binary file must be placed in current working directory \"\n                f\"or in {ROOT}. See PNNX repo for full installation instructions.\"\n            )\n            system = [\"macos\"] if MACOS else [\"windows\"] if WINDOWS else [\"ubuntu\", \"linux\"]  # operating system\n            try:\n                _, assets = get_github_assets(repo=\"pnnx/pnnx\", retry=True)\n                url = [x for x in assets if any(s in x for s in system)][0]\n            except Exception as e:\n                url = f\"https://github.com/pnnx/pnnx/releases/download/20231127/pnnx-20231127-{system[0]}.zip\"\n                LOGGER.warning(f\"{prefix} WARNING \u26a0\ufe0f PNNX GitHub assets not found: {e}, using default {url}\")\n            asset = attempt_download_asset(url, repo=\"pnnx/pnnx\", release=\"latest\")\n            if check_is_path_safe(Path.cwd(), asset):  # avoid path traversal security vulnerability\n                unzip_dir = Path(asset).with_suffix(\"\")\n                (unzip_dir / name).rename(pnnx)  # move binary to ROOT\n                shutil.rmtree(unzip_dir)  # delete unzip dir\n                Path(asset).unlink()  # delete zip\n                pnnx.chmod(0o777)  # set read, write, and execute permissions for everyone\n\n        ncnn_args = [\n            f'ncnnparam={f / \"model.ncnn.param\"}',\n            f'ncnnbin={f / \"model.ncnn.bin\"}',\n            f'ncnnpy={f / \"model_ncnn.py\"}',\n        ]\n\n        pnnx_args = [\n            f'pnnxparam={f / \"model.pnnx.param\"}',\n            f'pnnxbin={f / \"model.pnnx.bin\"}',\n            f'pnnxpy={f / \"model_pnnx.py\"}',\n            f'pnnxonnx={f / \"model.pnnx.onnx\"}',\n        ]\n\n        cmd = [\n            str(pnnx),\n            str(f_ts),\n            *ncnn_args,\n            *pnnx_args,\n            f\"fp16={int(self.args.half)}\",\n            f\"device={self.device.type}\",\n            f'inputshape=\"{[self.args.batch, 3, *self.imgsz]}\"',\n        ]\n        f.mkdir(exist_ok=True)  # make ncnn_model directory\n        LOGGER.info(f\"{prefix} running '{' '.join(cmd)}'\")\n        subprocess.run(cmd, check=True)\n\n        # Remove debug files\n        pnnx_files = [x.split(\"=\")[-1] for x in pnnx_args]\n        for f_debug in (\"debug.bin\", \"debug.param\", \"debug2.bin\", \"debug2.param\", *pnnx_files):\n            Path(f_debug).unlink(missing_ok=True)\n\n        yaml_save(f / \"metadata.yaml\", self.metadata)  # add metadata.yaml\n        return str(f), None\n\n    @try_export\n    def export_coreml(self, prefix=colorstr(\"CoreML:\")):\n        \"\"\"YOLOv8 CoreML export.\"\"\"\n        mlmodel = self.args.format.lower() == \"mlmodel\"  # legacy *.mlmodel export format requested\n        check_requirements(\"coremltools&gt;=6.0,&lt;=6.2\" if mlmodel else \"coremltools&gt;=7.0\")\n        import coremltools as ct  # noqa\n\n        LOGGER.info(f\"\\n{prefix} starting export with coremltools {ct.__version__}...\")\n        f = self.file.with_suffix(\".mlmodel\" if mlmodel else \".mlpackage\")\n        if f.is_dir():\n            shutil.rmtree(f)\n\n        bias = [0.0, 0.0, 0.0]\n        scale = 1 / 255\n        classifier_config = None\n        if self.model.task == \"classify\":\n            classifier_config = ct.ClassifierConfig(list(self.model.names.values())) if self.args.nms else None\n            model = self.model\n        elif self.model.task == \"detect\":\n            model = IOSDetectModel(self.model, self.im) if self.args.nms else self.model\n        else:\n            if self.args.nms:\n                LOGGER.warning(f\"{prefix} WARNING \u26a0\ufe0f 'nms=True' is only available for Detect models like 'yolov8n.pt'.\")\n                # TODO CoreML Segment and Pose model pipelining\n            model = self.model\n\n        ts = torch.jit.trace(model.eval(), self.im, strict=False)  # TorchScript model\n        ct_model = ct.convert(\n            ts,\n            inputs=[ct.ImageType(\"image\", shape=self.im.shape, scale=scale, bias=bias)],\n            classifier_config=classifier_config,\n            convert_to=\"neuralnetwork\" if mlmodel else \"mlprogram\",\n        )\n        bits, mode = (8, \"kmeans\") if self.args.int8 else (16, \"linear\") if self.args.half else (32, None)\n        if bits &lt; 32:\n            if \"kmeans\" in mode:\n                check_requirements(\"scikit-learn\")  # scikit-learn package required for k-means quantization\n            if mlmodel:\n                ct_model = ct.models.neural_network.quantization_utils.quantize_weights(ct_model, bits, mode)\n            elif bits == 8:  # mlprogram already quantized to FP16\n                import coremltools.optimize.coreml as cto\n\n                op_config = cto.OpPalettizerConfig(mode=\"kmeans\", nbits=bits, weight_threshold=512)\n                config = cto.OptimizationConfig(global_config=op_config)\n                ct_model = cto.palettize_weights(ct_model, config=config)\n        if self.args.nms and self.model.task == \"detect\":\n            if mlmodel:\n                import platform\n\n                # coremltools&lt;=6.2 NMS export requires Python&lt;3.11\n                check_version(platform.python_version(), \"&lt;3.11\", name=\"Python \", hard=True)\n                weights_dir = None\n            else:\n                ct_model.save(str(f))  # save otherwise weights_dir does not exist\n                weights_dir = str(f / \"Data/com.apple.CoreML/weights\")\n            ct_model = self._pipeline_coreml(ct_model, weights_dir=weights_dir)\n\n        m = self.metadata  # metadata dict\n        ct_model.short_description = m.pop(\"description\")\n        ct_model.author = m.pop(\"author\")\n        ct_model.license = m.pop(\"license\")\n        ct_model.version = m.pop(\"version\")\n        ct_model.user_defined_metadata.update({k: str(v) for k, v in m.items()})\n        try:\n            ct_model.save(str(f))  # save *.mlpackage\n        except Exception as e:\n            LOGGER.warning(\n                f\"{prefix} WARNING \u26a0\ufe0f CoreML export to *.mlpackage failed ({e}), reverting to *.mlmodel export. \"\n                f\"Known coremltools Python 3.11 and Windows bugs https://github.com/apple/coremltools/issues/1928.\"\n            )\n            f = f.with_suffix(\".mlmodel\")\n            ct_model.save(str(f))\n        return f, ct_model\n\n    @try_export\n    def export_engine(self, prefix=colorstr(\"TensorRT:\")):\n        \"\"\"YOLOv8 TensorRT export https://developer.nvidia.com/tensorrt.\"\"\"\n        assert self.im.device.type != \"cpu\", \"export running on CPU but must be on GPU, i.e. use 'device=0'\"\n        f_onnx, _ = self.export_onnx()  # run before trt import https://github.com/ultralytics/ultralytics/issues/7016\n\n        try:\n            import tensorrt as trt  # noqa\n        except ImportError:\n            if LINUX:\n                check_requirements(\"nvidia-tensorrt\", cmds=\"-U --index-url https://pypi.ngc.nvidia.com\")\n            import tensorrt as trt  # noqa\n\n        check_version(trt.__version__, \"7.0.0\", hard=True)  # require tensorrt&gt;=7.0.0\n\n        self.args.simplify = True\n\n        LOGGER.info(f\"\\n{prefix} starting export with TensorRT {trt.__version__}...\")\n        assert Path(f_onnx).exists(), f\"failed to export ONNX file: {f_onnx}\"\n        f = self.file.with_suffix(\".engine\")  # TensorRT engine file\n        logger = trt.Logger(trt.Logger.INFO)\n        if self.args.verbose:\n            logger.min_severity = trt.Logger.Severity.VERBOSE\n\n        builder = trt.Builder(logger)\n        config = builder.create_builder_config()\n        config.max_workspace_size = self.args.workspace * 1 &lt;&lt; 30\n        # config.set_memory_pool_limit(trt.MemoryPoolType.WORKSPACE, workspace &lt;&lt; 30)  # fix TRT 8.4 deprecation notice\n\n        flag = 1 &lt;&lt; int(trt.NetworkDefinitionCreationFlag.EXPLICIT_BATCH)\n        network = builder.create_network(flag)\n        parser = trt.OnnxParser(network, logger)\n        if not parser.parse_from_file(f_onnx):\n            raise RuntimeError(f\"failed to load ONNX file: {f_onnx}\")\n\n        inputs = [network.get_input(i) for i in range(network.num_inputs)]\n        outputs = [network.get_output(i) for i in range(network.num_outputs)]\n        for inp in inputs:\n            LOGGER.info(f'{prefix} input \"{inp.name}\" with shape{inp.shape} {inp.dtype}')\n        for out in outputs:\n            LOGGER.info(f'{prefix} output \"{out.name}\" with shape{out.shape} {out.dtype}')\n\n        if self.args.dynamic:\n            shape = self.im.shape\n            if shape[0] &lt;= 1:\n                LOGGER.warning(f\"{prefix} WARNING \u26a0\ufe0f 'dynamic=True' model requires max batch size, i.e. 'batch=16'\")\n            profile = builder.create_optimization_profile()\n            for inp in inputs:\n                profile.set_shape(inp.name, (1, *shape[1:]), (max(1, shape[0] // 2), *shape[1:]), shape)\n            config.add_optimization_profile(profile)\n\n        LOGGER.info(\n            f\"{prefix} building FP{16 if builder.platform_has_fast_fp16 and self.args.half else 32} engine as {f}\"\n        )\n        if builder.platform_has_fast_fp16 and self.args.half:\n            config.set_flag(trt.BuilderFlag.FP16)\n\n        del self.model\n        torch.cuda.empty_cache()\n\n        # Write file\n        with builder.build_engine(network, config) as engine, open(f, \"wb\") as t:\n            # Metadata\n            meta = json.dumps(self.metadata)\n            t.write(len(meta).to_bytes(4, byteorder=\"little\", signed=True))\n            t.write(meta.encode())\n            # Model\n            t.write(engine.serialize())\n\n        return f, None\n\n    @try_export\n    def export_saved_model(self, prefix=colorstr(\"TensorFlow SavedModel:\")):\n        \"\"\"YOLOv8 TensorFlow SavedModel export.\"\"\"\n        cuda = torch.cuda.is_available()\n        try:\n            import tensorflow as tf  # noqa\n        except ImportError:\n            check_requirements(f\"tensorflow{'-macos' if MACOS else '-aarch64' if ARM64 else '' if cuda else '-cpu'}\")\n            import tensorflow as tf  # noqa\n        check_requirements(\n            (\n                \"onnx\",\n                \"onnx2tf&gt;=1.15.4,&lt;=1.17.5\",\n                \"sng4onnx&gt;=1.0.1\",\n                \"onnxsim&gt;=0.4.33\",\n                \"onnx_graphsurgeon&gt;=0.3.26\",\n                \"tflite_support\",\n                \"onnxruntime-gpu\" if cuda else \"onnxruntime\",\n            ),\n            cmds=\"--extra-index-url https://pypi.ngc.nvidia.com\",\n        )  # onnx_graphsurgeon only on NVIDIA\n\n        LOGGER.info(f\"\\n{prefix} starting export with tensorflow {tf.__version__}...\")\n        check_version(\n            tf.__version__,\n            \"&lt;=2.13.1\",\n            name=\"tensorflow\",\n            verbose=True,\n            msg=\"https://github.com/ultralytics/ultralytics/issues/5161\",\n        )\n        f = Path(str(self.file).replace(self.file.suffix, \"_saved_model\"))\n        if f.is_dir():\n            import shutil\n\n            shutil.rmtree(f)  # delete output folder\n\n        # Pre-download calibration file to fix https://github.com/PINTO0309/onnx2tf/issues/545\n        onnx2tf_file = Path(\"calibration_image_sample_data_20x128x128x3_float32.npy\")\n        if not onnx2tf_file.exists():\n            attempt_download_asset(f\"{onnx2tf_file}.zip\", unzip=True, delete=True)\n\n        # Export to ONNX\n        self.args.simplify = True\n        f_onnx, _ = self.export_onnx()\n\n        # Export to TF\n        tmp_file = f / \"tmp_tflite_int8_calibration_images.npy\"  # int8 calibration images file\n        if self.args.int8:\n            verbosity = \"--verbosity info\"\n            if self.args.data:\n                # Generate calibration data for integer quantization\n                LOGGER.info(f\"{prefix} collecting INT8 calibration images from 'data={self.args.data}'\")\n                data = check_det_dataset(self.args.data)\n                dataset = YOLODataset(data[\"val\"], data=data, imgsz=self.imgsz[0], augment=False)\n                images = []\n                for i, batch in enumerate(dataset):\n                    if i &gt;= 100:  # maximum number of calibration images\n                        break\n                    im = batch[\"img\"].permute(1, 2, 0)[None]  # list to nparray, CHW to BHWC\n                    images.append(im)\n                f.mkdir()\n                images = torch.cat(images, 0).float()\n                # mean = images.view(-1, 3).mean(0)  # imagenet mean [123.675, 116.28, 103.53]\n                # std = images.view(-1, 3).std(0)  # imagenet std [58.395, 57.12, 57.375]\n                np.save(str(tmp_file), images.numpy())  # BHWC\n                int8 = f'-oiqt -qt per-tensor -cind images \"{tmp_file}\" \"[[[[0, 0, 0]]]]\" \"[[[[255, 255, 255]]]]\"'\n            else:\n                int8 = \"-oiqt -qt per-tensor\"\n        else:\n            verbosity = \"--non_verbose\"\n            int8 = \"\"\n\n        cmd = f'onnx2tf -i \"{f_onnx}\" -o \"{f}\" -nuo {verbosity} {int8}'.strip()\n        LOGGER.info(f\"{prefix} running '{cmd}'\")\n        subprocess.run(cmd, shell=True)\n        yaml_save(f / \"metadata.yaml\", self.metadata)  # add metadata.yaml\n\n        # Remove/rename TFLite models\n        if self.args.int8:\n            tmp_file.unlink(missing_ok=True)\n            for file in f.rglob(\"*_dynamic_range_quant.tflite\"):\n                file.rename(file.with_name(file.stem.replace(\"_dynamic_range_quant\", \"_int8\") + file.suffix))\n            for file in f.rglob(\"*_integer_quant_with_int16_act.tflite\"):\n                file.unlink()  # delete extra fp16 activation TFLite files\n\n        # Add TFLite metadata\n        for file in f.rglob(\"*.tflite\"):\n            f.unlink() if \"quant_with_int16_act.tflite\" in str(f) else self._add_tflite_metadata(file)\n\n        return str(f), tf.saved_model.load(f, tags=None, options=None)  # load saved_model as Keras model\n\n    @try_export\n    def export_pb(self, keras_model, prefix=colorstr(\"TensorFlow GraphDef:\")):\n        \"\"\"YOLOv8 TensorFlow GraphDef *.pb export https://github.com/leimao/Frozen_Graph_TensorFlow.\"\"\"\n        import tensorflow as tf  # noqa\n        from tensorflow.python.framework.convert_to_constants import convert_variables_to_constants_v2  # noqa\n\n        LOGGER.info(f\"\\n{prefix} starting export with tensorflow {tf.__version__}...\")\n        f = self.file.with_suffix(\".pb\")\n\n        m = tf.function(lambda x: keras_model(x))  # full model\n        m = m.get_concrete_function(tf.TensorSpec(keras_model.inputs[0].shape, keras_model.inputs[0].dtype))\n        frozen_func = convert_variables_to_constants_v2(m)\n        frozen_func.graph.as_graph_def()\n        tf.io.write_graph(graph_or_graph_def=frozen_func.graph, logdir=str(f.parent), name=f.name, as_text=False)\n        return f, None\n\n    @try_export\n    def export_tflite(self, keras_model, nms, agnostic_nms, prefix=colorstr(\"TensorFlow Lite:\")):\n        \"\"\"YOLOv8 TensorFlow Lite export.\"\"\"\n        import tensorflow as tf  # noqa\n\n        LOGGER.info(f\"\\n{prefix} starting export with tensorflow {tf.__version__}...\")\n        saved_model = Path(str(self.file).replace(self.file.suffix, \"_saved_model\"))\n        if self.args.int8:\n            f = saved_model / f\"{self.file.stem}_int8.tflite\"  # fp32 in/out\n        elif self.args.half:\n            f = saved_model / f\"{self.file.stem}_float16.tflite\"  # fp32 in/out\n        else:\n            f = saved_model / f\"{self.file.stem}_float32.tflite\"\n        return str(f), None\n\n    @try_export\n    def export_edgetpu(self, tflite_model=\"\", prefix=colorstr(\"Edge TPU:\")):\n        \"\"\"YOLOv8 Edge TPU export https://coral.ai/docs/edgetpu/models-intro/.\"\"\"\n        LOGGER.warning(f\"{prefix} WARNING \u26a0\ufe0f Edge TPU known bug https://github.com/ultralytics/ultralytics/issues/1185\")\n\n        cmd = \"edgetpu_compiler --version\"\n        help_url = \"https://coral.ai/docs/edgetpu/compiler/\"\n        assert LINUX, f\"export only supported on Linux. See {help_url}\"\n        if subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True).returncode != 0:\n            LOGGER.info(f\"\\n{prefix} export requires Edge TPU compiler. Attempting install from {help_url}\")\n            sudo = subprocess.run(\"sudo --version &gt;/dev/null\", shell=True).returncode == 0  # sudo installed on system\n            for c in (\n                \"curl https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -\",\n                'echo \"deb https://packages.cloud.google.com/apt coral-edgetpu-stable main\" | '\n                \"sudo tee /etc/apt/sources.list.d/coral-edgetpu.list\",\n                \"sudo apt-get update\",\n                \"sudo apt-get install edgetpu-compiler\",\n            ):\n                subprocess.run(c if sudo else c.replace(\"sudo \", \"\"), shell=True, check=True)\n        ver = subprocess.run(cmd, shell=True, capture_output=True, check=True).stdout.decode().split()[-1]\n\n        LOGGER.info(f\"\\n{prefix} starting export with Edge TPU compiler {ver}...\")\n        f = str(tflite_model).replace(\".tflite\", \"_edgetpu.tflite\")  # Edge TPU model\n\n        cmd = f'edgetpu_compiler -s -d -k 10 --out_dir \"{Path(f).parent}\" \"{tflite_model}\"'\n        LOGGER.info(f\"{prefix} running '{cmd}'\")\n        subprocess.run(cmd, shell=True)\n        self._add_tflite_metadata(f)\n        return f, None\n\n    @try_export\n    def export_tfjs(self, prefix=colorstr(\"TensorFlow.js:\")):\n        \"\"\"YOLOv8 TensorFlow.js export.\"\"\"\n        # JAX bug requiring install constraints in https://github.com/google/jax/issues/18978\n        check_requirements([\"jax&lt;=0.4.21\", \"jaxlib&lt;=0.4.21\", \"tensorflowjs\"])\n        import tensorflow as tf\n        import tensorflowjs as tfjs  # noqa\n\n        LOGGER.info(f\"\\n{prefix} starting export with tensorflowjs {tfjs.__version__}...\")\n        f = str(self.file).replace(self.file.suffix, \"_web_model\")  # js dir\n        f_pb = str(self.file.with_suffix(\".pb\"))  # *.pb path\n\n        gd = tf.Graph().as_graph_def()  # TF GraphDef\n        with open(f_pb, \"rb\") as file:\n            gd.ParseFromString(file.read())\n        outputs = \",\".join(gd_outputs(gd))\n        LOGGER.info(f\"\\n{prefix} output node names: {outputs}\")\n\n        quantization = \"--quantize_float16\" if self.args.half else \"--quantize_uint8\" if self.args.int8 else \"\"\n        with spaces_in_path(f_pb) as fpb_, spaces_in_path(f) as f_:  # exporter can not handle spaces in path\n            cmd = f'tensorflowjs_converter --input_format=tf_frozen_model {quantization} --output_node_names={outputs} \"{fpb_}\" \"{f_}\"'\n            LOGGER.info(f\"{prefix} running '{cmd}'\")\n            subprocess.run(cmd, shell=True)\n\n        if \" \" in f:\n            LOGGER.warning(f\"{prefix} WARNING \u26a0\ufe0f your model may not work correctly with spaces in path '{f}'.\")\n\n        # f_json = Path(f) / 'model.json'  # *.json path\n        # with open(f_json, 'w') as j:  # sort JSON Identity_* in ascending order\n        #     subst = re.sub(\n        #         r'{\"outputs\": {\"Identity.?.?\": {\"name\": \"Identity.?.?\"}, '\n        #         r'\"Identity.?.?\": {\"name\": \"Identity.?.?\"}, '\n        #         r'\"Identity.?.?\": {\"name\": \"Identity.?.?\"}, '\n        #         r'\"Identity.?.?\": {\"name\": \"Identity.?.?\"}}}',\n        #         r'{\"outputs\": {\"Identity\": {\"name\": \"Identity\"}, '\n        #         r'\"Identity_1\": {\"name\": \"Identity_1\"}, '\n        #         r'\"Identity_2\": {\"name\": \"Identity_2\"}, '\n        #         r'\"Identity_3\": {\"name\": \"Identity_3\"}}}',\n        #         f_json.read_text(),\n        #     )\n        #     j.write(subst)\n        yaml_save(Path(f) / \"metadata.yaml\", self.metadata)  # add metadata.yaml\n        return f, None\n\n    def _add_tflite_metadata(self, file):\n        \"\"\"Add metadata to *.tflite models per https://www.tensorflow.org/lite/models/convert/metadata.\"\"\"\n        from tflite_support import flatbuffers  # noqa\n        from tflite_support import metadata as _metadata  # noqa\n        from tflite_support import metadata_schema_py_generated as _metadata_fb  # noqa\n\n        # Create model info\n        model_meta = _metadata_fb.ModelMetadataT()\n        model_meta.name = self.metadata[\"description\"]\n        model_meta.version = self.metadata[\"version\"]\n        model_meta.author = self.metadata[\"author\"]\n        model_meta.license = self.metadata[\"license\"]\n\n        # Label file\n        tmp_file = Path(file).parent / \"temp_meta.txt\"\n        with open(tmp_file, \"w\") as f:\n            f.write(str(self.metadata))\n\n        label_file = _metadata_fb.AssociatedFileT()\n        label_file.name = tmp_file.name\n        label_file.type = _metadata_fb.AssociatedFileType.TENSOR_AXIS_LABELS\n\n        # Create input info\n        input_meta = _metadata_fb.TensorMetadataT()\n        input_meta.name = \"image\"\n        input_meta.description = \"Input image to be detected.\"\n        input_meta.content = _metadata_fb.ContentT()\n        input_meta.content.contentProperties = _metadata_fb.ImagePropertiesT()\n        input_meta.content.contentProperties.colorSpace = _metadata_fb.ColorSpaceType.RGB\n        input_meta.content.contentPropertiesType = _metadata_fb.ContentProperties.ImageProperties\n\n        # Create output info\n        output1 = _metadata_fb.TensorMetadataT()\n        output1.name = \"output\"\n        output1.description = \"Coordinates of detected objects, class labels, and confidence score\"\n        output1.associatedFiles = [label_file]\n        if self.model.task == \"segment\":\n            output2 = _metadata_fb.TensorMetadataT()\n            output2.name = \"output\"\n            output2.description = \"Mask protos\"\n            output2.associatedFiles = [label_file]\n\n        # Create subgraph info\n        subgraph = _metadata_fb.SubGraphMetadataT()\n        subgraph.inputTensorMetadata = [input_meta]\n        subgraph.outputTensorMetadata = [output1, output2] if self.model.task == \"segment\" else [output1]\n        model_meta.subgraphMetadata = [subgraph]\n\n        b = flatbuffers.Builder(0)\n        b.Finish(model_meta.Pack(b), _metadata.MetadataPopulator.METADATA_FILE_IDENTIFIER)\n        metadata_buf = b.Output()\n\n        populator = _metadata.MetadataPopulator.with_model_file(str(file))\n        populator.load_metadata_buffer(metadata_buf)\n        populator.load_associated_files([str(tmp_file)])\n        populator.populate()\n        tmp_file.unlink()\n\n    def _pipeline_coreml(self, model, weights_dir=None, prefix=colorstr(\"CoreML Pipeline:\")):\n        \"\"\"YOLOv8 CoreML pipeline.\"\"\"\n        import coremltools as ct  # noqa\n\n        LOGGER.info(f\"{prefix} starting pipeline with coremltools {ct.__version__}...\")\n        _, _, h, w = list(self.im.shape)  # BCHW\n\n        # Output shapes\n        spec = model.get_spec()\n        out0, out1 = iter(spec.description.output)\n        if MACOS:\n            from PIL import Image\n\n            img = Image.new(\"RGB\", (w, h))  # w=192, h=320\n            out = model.predict({\"image\": img})\n            out0_shape = out[out0.name].shape  # (3780, 80)\n            out1_shape = out[out1.name].shape  # (3780, 4)\n        else:  # linux and windows can not run model.predict(), get sizes from PyTorch model output y\n            out0_shape = self.output_shape[2], self.output_shape[1] - 4  # (3780, 80)\n            out1_shape = self.output_shape[2], 4  # (3780, 4)\n\n        # Checks\n        names = self.metadata[\"names\"]\n        nx, ny = spec.description.input[0].type.imageType.width, spec.description.input[0].type.imageType.height\n        _, nc = out0_shape  # number of anchors, number of classes\n        # _, nc = out0.type.multiArrayType.shape\n        assert len(names) == nc, f\"{len(names)} names found for nc={nc}\"  # check\n\n        # Define output shapes (missing)\n        out0.type.multiArrayType.shape[:] = out0_shape  # (3780, 80)\n        out1.type.multiArrayType.shape[:] = out1_shape  # (3780, 4)\n        # spec.neuralNetwork.preprocessing[0].featureName = '0'\n\n        # Flexible input shapes\n        # from coremltools.models.neural_network import flexible_shape_utils\n        # s = [] # shapes\n        # s.append(flexible_shape_utils.NeuralNetworkImageSize(320, 192))\n        # s.append(flexible_shape_utils.NeuralNetworkImageSize(640, 384))  # (height, width)\n        # flexible_shape_utils.add_enumerated_image_sizes(spec, feature_name='image', sizes=s)\n        # r = flexible_shape_utils.NeuralNetworkImageSizeRange()  # shape ranges\n        # r.add_height_range((192, 640))\n        # r.add_width_range((192, 640))\n        # flexible_shape_utils.update_image_size_range(spec, feature_name='image', size_range=r)\n\n        # Print\n        # print(spec.description)\n\n        # Model from spec\n        model = ct.models.MLModel(spec, weights_dir=weights_dir)\n\n        # 3. Create NMS protobuf\n        nms_spec = ct.proto.Model_pb2.Model()\n        nms_spec.specificationVersion = 5\n        for i in range(2):\n            decoder_output = model._spec.description.output[i].SerializeToString()\n            nms_spec.description.input.add()\n            nms_spec.description.input[i].ParseFromString(decoder_output)\n            nms_spec.description.output.add()\n            nms_spec.description.output[i].ParseFromString(decoder_output)\n\n        nms_spec.description.output[0].name = \"confidence\"\n        nms_spec.description.output[1].name = \"coordinates\"\n\n        output_sizes = [nc, 4]\n        for i in range(2):\n            ma_type = nms_spec.description.output[i].type.multiArrayType\n            ma_type.shapeRange.sizeRanges.add()\n            ma_type.shapeRange.sizeRanges[0].lowerBound = 0\n            ma_type.shapeRange.sizeRanges[0].upperBound = -1\n            ma_type.shapeRange.sizeRanges.add()\n            ma_type.shapeRange.sizeRanges[1].lowerBound = output_sizes[i]\n            ma_type.shapeRange.sizeRanges[1].upperBound = output_sizes[i]\n            del ma_type.shape[:]\n\n        nms = nms_spec.nonMaximumSuppression\n        nms.confidenceInputFeatureName = out0.name  # 1x507x80\n        nms.coordinatesInputFeatureName = out1.name  # 1x507x4\n        nms.confidenceOutputFeatureName = \"confidence\"\n        nms.coordinatesOutputFeatureName = \"coordinates\"\n        nms.iouThresholdInputFeatureName = \"iouThreshold\"\n        nms.confidenceThresholdInputFeatureName = \"confidenceThreshold\"\n        nms.iouThreshold = 0.45\n        nms.confidenceThreshold = 0.25\n        nms.pickTop.perClass = True\n        nms.stringClassLabels.vector.extend(names.values())\n        nms_model = ct.models.MLModel(nms_spec)\n\n        # 4. Pipeline models together\n        pipeline = ct.models.pipeline.Pipeline(\n            input_features=[\n                (\"image\", ct.models.datatypes.Array(3, ny, nx)),\n                (\"iouThreshold\", ct.models.datatypes.Double()),\n                (\"confidenceThreshold\", ct.models.datatypes.Double()),\n            ],\n            output_features=[\"confidence\", \"coordinates\"],\n        )\n        pipeline.add_model(model)\n        pipeline.add_model(nms_model)\n\n        # Correct datatypes\n        pipeline.spec.description.input[0].ParseFromString(model._spec.description.input[0].SerializeToString())\n        pipeline.spec.description.output[0].ParseFromString(nms_model._spec.description.output[0].SerializeToString())\n        pipeline.spec.description.output[1].ParseFromString(nms_model._spec.description.output[1].SerializeToString())\n\n        # Update metadata\n        pipeline.spec.specificationVersion = 5\n        pipeline.spec.description.metadata.userDefined.update(\n            {\"IoU threshold\": str(nms.iouThreshold), \"Confidence threshold\": str(nms.confidenceThreshold)}\n        )\n\n        # Save the model\n        model = ct.models.MLModel(pipeline.spec, weights_dir=weights_dir)\n        model.input_description[\"image\"] = \"Input image\"\n        model.input_description[\"iouThreshold\"] = f\"(optional) IOU threshold override (default: {nms.iouThreshold})\"\n        model.input_description[\n            \"confidenceThreshold\"\n        ] = f\"(optional) Confidence threshold override (default: {nms.confidenceThreshold})\"\n        model.output_description[\"confidence\"] = 'Boxes \u00d7 Class confidence (see user-defined metadata \"classes\")'\n        model.output_description[\"coordinates\"] = \"Boxes \u00d7 [x, y, width, height] (relative to image size)\"\n        LOGGER.info(f\"{prefix} pipeline success\")\n        return model\n\n    def add_callback(self, event: str, callback):\n        \"\"\"Appends the given callback.\"\"\"\n        self.callbacks[event].append(callback)\n\n    def run_callbacks(self, event: str):\n        \"\"\"Execute all callbacks for a given event.\"\"\"\n        for callback in self.callbacks.get(event, []):\n            callback(self)\n</code></pre>"},{"location":"reference/engine/exporter/#ultralytics.engine.exporter.Exporter.__call__","title":"<code>__call__(model=None)</code>","text":"<p>Returns list of exported files/dirs after running callbacks.</p> Source code in <code>ultralytics/engine/exporter.py</code> <pre><code>@smart_inference_mode()\ndef __call__(self, model=None):\n    \"\"\"Returns list of exported files/dirs after running callbacks.\"\"\"\n    self.run_callbacks(\"on_export_start\")\n    t = time.time()\n    fmt = self.args.format.lower()  # to lowercase\n    if fmt in (\"tensorrt\", \"trt\"):  # 'engine' aliases\n        fmt = \"engine\"\n    if fmt in (\"mlmodel\", \"mlpackage\", \"mlprogram\", \"apple\", \"ios\", \"coreml\"):  # 'coreml' aliases\n        fmt = \"coreml\"\n    fmts = tuple(export_formats()[\"Argument\"][1:])  # available export formats\n    flags = [x == fmt for x in fmts]\n    if sum(flags) != 1:\n        raise ValueError(f\"Invalid export format='{fmt}'. Valid formats are {fmts}\")\n    jit, onnx, xml, engine, coreml, saved_model, pb, tflite, edgetpu, tfjs, paddle, ncnn = flags  # export booleans\n\n    # Device\n    if fmt == \"engine\" and self.args.device is None:\n        LOGGER.warning(\"WARNING \u26a0\ufe0f TensorRT requires GPU export, automatically assigning device=0\")\n        self.args.device = \"0\"\n    self.device = select_device(\"cpu\" if self.args.device is None else self.args.device)\n\n    # Checks\n    if not hasattr(model, \"names\"):\n        model.names = default_class_names()\n    model.names = check_class_names(model.names)\n    if self.args.half and onnx and self.device.type == \"cpu\":\n        LOGGER.warning(\"WARNING \u26a0\ufe0f half=True only compatible with GPU export, i.e. use device=0\")\n        self.args.half = False\n        assert not self.args.dynamic, \"half=True not compatible with dynamic=True, i.e. use only one.\"\n    self.imgsz = check_imgsz(self.args.imgsz, stride=model.stride, min_dim=2)  # check image size\n    if self.args.optimize:\n        assert not ncnn, \"optimize=True not compatible with format='ncnn', i.e. use optimize=False\"\n        assert self.device.type == \"cpu\", \"optimize=True not compatible with cuda devices, i.e. use device='cpu'\"\n    if edgetpu and not LINUX:\n        raise SystemError(\"Edge TPU export only supported on Linux. See https://coral.ai/docs/edgetpu/compiler/\")\n\n    # Input\n    im = torch.zeros(self.args.batch, 3, *self.imgsz).to(self.device)\n    file = Path(\n        getattr(model, \"pt_path\", None) or getattr(model, \"yaml_file\", None) or model.yaml.get(\"yaml_file\", \"\")\n    )\n    if file.suffix in {\".yaml\", \".yml\"}:\n        file = Path(file.name)\n\n    # Update model\n    model = deepcopy(model).to(self.device)\n    for p in model.parameters():\n        p.requires_grad = False\n    model.eval()\n    model.float()\n    model = model.fuse()\n    for m in model.modules():\n        if isinstance(m, (Detect, RTDETRDecoder)):  # Segment and Pose use Detect base class\n            m.dynamic = self.args.dynamic\n            m.export = True\n            m.format = self.args.format\n        elif isinstance(m, C2f) and not any((saved_model, pb, tflite, edgetpu, tfjs)):\n            # EdgeTPU does not support FlexSplitV while split provides cleaner ONNX graph\n            m.forward = m.forward_split\n\n    y = None\n    for _ in range(2):\n        y = model(im)  # dry runs\n    if self.args.half and (engine or onnx) and self.device.type != \"cpu\":\n        im, model = im.half(), model.half()  # to FP16\n\n    # Filter warnings\n    warnings.filterwarnings(\"ignore\", category=torch.jit.TracerWarning)  # suppress TracerWarning\n    warnings.filterwarnings(\"ignore\", category=UserWarning)  # suppress shape prim::Constant missing ONNX warning\n    warnings.filterwarnings(\"ignore\", category=DeprecationWarning)  # suppress CoreML np.bool deprecation warning\n\n    # Assign\n    self.im = im\n    self.model = model\n    self.file = file\n    self.output_shape = (\n        tuple(y.shape)\n        if isinstance(y, torch.Tensor)\n        else tuple(tuple(x.shape if isinstance(x, torch.Tensor) else []) for x in y)\n    )\n    self.pretty_name = Path(self.model.yaml.get(\"yaml_file\", self.file)).stem.replace(\"yolo\", \"YOLO\")\n    data = model.args[\"data\"] if hasattr(model, \"args\") and isinstance(model.args, dict) else \"\"\n    description = f'Ultralytics {self.pretty_name} model {f\"trained on {data}\" if data else \"\"}'\n    self.metadata = {\n        \"description\": description,\n        \"author\": \"Ultralytics\",\n        \"license\": \"AGPL-3.0 https://ultralytics.com/license\",\n        \"date\": datetime.now().isoformat(),\n        \"version\": __version__,\n        \"stride\": int(max(model.stride)),\n        \"task\": model.task,\n        \"batch\": self.args.batch,\n        \"imgsz\": self.imgsz,\n        \"names\": model.names,\n    }  # model metadata\n    if model.task == \"pose\":\n        self.metadata[\"kpt_shape\"] = model.model[-1].kpt_shape\n\n    LOGGER.info(\n        f\"\\n{colorstr('PyTorch:')} starting from '{file}' with input shape {tuple(im.shape)} BCHW and \"\n        f'output shape(s) {self.output_shape} ({file_size(file):.1f} MB)'\n    )\n\n    # Exports\n    f = [\"\"] * len(fmts)  # exported filenames\n    if jit or ncnn:  # TorchScript\n        f[0], _ = self.export_torchscript()\n    if engine:  # TensorRT required before ONNX\n        f[1], _ = self.export_engine()\n    if onnx or xml:  # OpenVINO requires ONNX\n        f[2], _ = self.export_onnx()\n    if xml:  # OpenVINO\n        f[3], _ = self.export_openvino()\n    if coreml:  # CoreML\n        f[4], _ = self.export_coreml()\n    if any((saved_model, pb, tflite, edgetpu, tfjs)):  # TensorFlow formats\n        self.args.int8 |= edgetpu\n        f[5], keras_model = self.export_saved_model()\n        if pb or tfjs:  # pb prerequisite to tfjs\n            f[6], _ = self.export_pb(keras_model=keras_model)\n        if tflite:\n            f[7], _ = self.export_tflite(keras_model=keras_model, nms=False, agnostic_nms=self.args.agnostic_nms)\n        if edgetpu:\n            f[8], _ = self.export_edgetpu(tflite_model=Path(f[5]) / f\"{self.file.stem}_full_integer_quant.tflite\")\n        if tfjs:\n            f[9], _ = self.export_tfjs()\n    if paddle:  # PaddlePaddle\n        f[10], _ = self.export_paddle()\n    if ncnn:  # ncnn\n        f[11], _ = self.export_ncnn()\n\n    # Finish\n    f = [str(x) for x in f if x]  # filter out '' and None\n    if any(f):\n        f = str(Path(f[-1]))\n        square = self.imgsz[0] == self.imgsz[1]\n        s = (\n            \"\"\n            if square\n            else f\"WARNING \u26a0\ufe0f non-PyTorch val requires square images, 'imgsz={self.imgsz}' will not \"\n            f\"work. Use export 'imgsz={max(self.imgsz)}' if val is required.\"\n        )\n        imgsz = self.imgsz[0] if square else str(self.imgsz)[1:-1].replace(\" \", \"\")\n        predict_data = f\"data={data}\" if model.task == \"segment\" and fmt == \"pb\" else \"\"\n        q = \"int8\" if self.args.int8 else \"half\" if self.args.half else \"\"  # quantization\n        LOGGER.info(\n            f'\\nExport complete ({time.time() - t:.1f}s)'\n            f\"\\nResults saved to {colorstr('bold', file.parent.resolve())}\"\n            f'\\nPredict:         yolo predict task={model.task} model={f} imgsz={imgsz} {q} {predict_data}'\n            f'\\nValidate:        yolo val task={model.task} model={f} imgsz={imgsz} data={data} {q} {s}'\n            f'\\nVisualize:       https://netron.app'\n        )\n\n    self.run_callbacks(\"on_export_end\")\n    return f  # return list of exported files/dirs\n</code></pre>"},{"location":"reference/engine/exporter/#ultralytics.engine.exporter.Exporter.__init__","title":"<code>__init__(cfg=DEFAULT_CFG, overrides=None, _callbacks=None)</code>","text":"<p>Initializes the Exporter class.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>str</code> <p>Path to a configuration file. Defaults to DEFAULT_CFG.</p> <code>DEFAULT_CFG</code> <code>overrides</code> <code>dict</code> <p>Configuration overrides. Defaults to None.</p> <code>None</code> <code>_callbacks</code> <code>dict</code> <p>Dictionary of callback functions. Defaults to None.</p> <code>None</code> Source code in <code>ultralytics/engine/exporter.py</code> <pre><code>def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n    \"\"\"\n    Initializes the Exporter class.\n\n    Args:\n        cfg (str, optional): Path to a configuration file. Defaults to DEFAULT_CFG.\n        overrides (dict, optional): Configuration overrides. Defaults to None.\n        _callbacks (dict, optional): Dictionary of callback functions. Defaults to None.\n    \"\"\"\n    self.args = get_cfg(cfg, overrides)\n    if self.args.format.lower() in (\"coreml\", \"mlmodel\"):  # fix attempt for protobuf&lt;3.20.x errors\n        os.environ[\"PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION\"] = \"python\"  # must run before TensorBoard callback\n\n    self.callbacks = _callbacks or callbacks.get_default_callbacks()\n    callbacks.add_integration_callbacks(self)\n</code></pre>"},{"location":"reference/engine/exporter/#ultralytics.engine.exporter.Exporter.add_callback","title":"<code>add_callback(event, callback)</code>","text":"<p>Appends the given callback.</p> Source code in <code>ultralytics/engine/exporter.py</code> <pre><code>def add_callback(self, event: str, callback):\n    \"\"\"Appends the given callback.\"\"\"\n    self.callbacks[event].append(callback)\n</code></pre>"},{"location":"reference/engine/exporter/#ultralytics.engine.exporter.Exporter.export_coreml","title":"<code>export_coreml(prefix=colorstr('CoreML:'))</code>","text":"<p>YOLOv8 CoreML export.</p> Source code in <code>ultralytics/engine/exporter.py</code> <pre><code>@try_export\ndef export_coreml(self, prefix=colorstr(\"CoreML:\")):\n    \"\"\"YOLOv8 CoreML export.\"\"\"\n    mlmodel = self.args.format.lower() == \"mlmodel\"  # legacy *.mlmodel export format requested\n    check_requirements(\"coremltools&gt;=6.0,&lt;=6.2\" if mlmodel else \"coremltools&gt;=7.0\")\n    import coremltools as ct  # noqa\n\n    LOGGER.info(f\"\\n{prefix} starting export with coremltools {ct.__version__}...\")\n    f = self.file.with_suffix(\".mlmodel\" if mlmodel else \".mlpackage\")\n    if f.is_dir():\n        shutil.rmtree(f)\n\n    bias = [0.0, 0.0, 0.0]\n    scale = 1 / 255\n    classifier_config = None\n    if self.model.task == \"classify\":\n        classifier_config = ct.ClassifierConfig(list(self.model.names.values())) if self.args.nms else None\n        model = self.model\n    elif self.model.task == \"detect\":\n        model = IOSDetectModel(self.model, self.im) if self.args.nms else self.model\n    else:\n        if self.args.nms:\n            LOGGER.warning(f\"{prefix} WARNING \u26a0\ufe0f 'nms=True' is only available for Detect models like 'yolov8n.pt'.\")\n            # TODO CoreML Segment and Pose model pipelining\n        model = self.model\n\n    ts = torch.jit.trace(model.eval(), self.im, strict=False)  # TorchScript model\n    ct_model = ct.convert(\n        ts,\n        inputs=[ct.ImageType(\"image\", shape=self.im.shape, scale=scale, bias=bias)],\n        classifier_config=classifier_config,\n        convert_to=\"neuralnetwork\" if mlmodel else \"mlprogram\",\n    )\n    bits, mode = (8, \"kmeans\") if self.args.int8 else (16, \"linear\") if self.args.half else (32, None)\n    if bits &lt; 32:\n        if \"kmeans\" in mode:\n            check_requirements(\"scikit-learn\")  # scikit-learn package required for k-means quantization\n        if mlmodel:\n            ct_model = ct.models.neural_network.quantization_utils.quantize_weights(ct_model, bits, mode)\n        elif bits == 8:  # mlprogram already quantized to FP16\n            import coremltools.optimize.coreml as cto\n\n            op_config = cto.OpPalettizerConfig(mode=\"kmeans\", nbits=bits, weight_threshold=512)\n            config = cto.OptimizationConfig(global_config=op_config)\n            ct_model = cto.palettize_weights(ct_model, config=config)\n    if self.args.nms and self.model.task == \"detect\":\n        if mlmodel:\n            import platform\n\n            # coremltools&lt;=6.2 NMS export requires Python&lt;3.11\n            check_version(platform.python_version(), \"&lt;3.11\", name=\"Python \", hard=True)\n            weights_dir = None\n        else:\n            ct_model.save(str(f))  # save otherwise weights_dir does not exist\n            weights_dir = str(f / \"Data/com.apple.CoreML/weights\")\n        ct_model = self._pipeline_coreml(ct_model, weights_dir=weights_dir)\n\n    m = self.metadata  # metadata dict\n    ct_model.short_description = m.pop(\"description\")\n    ct_model.author = m.pop(\"author\")\n    ct_model.license = m.pop(\"license\")\n    ct_model.version = m.pop(\"version\")\n    ct_model.user_defined_metadata.update({k: str(v) for k, v in m.items()})\n    try:\n        ct_model.save(str(f))  # save *.mlpackage\n    except Exception as e:\n        LOGGER.warning(\n            f\"{prefix} WARNING \u26a0\ufe0f CoreML export to *.mlpackage failed ({e}), reverting to *.mlmodel export. \"\n            f\"Known coremltools Python 3.11 and Windows bugs https://github.com/apple/coremltools/issues/1928.\"\n        )\n        f = f.with_suffix(\".mlmodel\")\n        ct_model.save(str(f))\n    return f, ct_model\n</code></pre>"},{"location":"reference/engine/exporter/#ultralytics.engine.exporter.Exporter.export_edgetpu","title":"<code>export_edgetpu(tflite_model='', prefix=colorstr('Edge TPU:'))</code>","text":"<p>YOLOv8 Edge TPU export https://coral.ai/docs/edgetpu/models-intro/.</p> Source code in <code>ultralytics/engine/exporter.py</code> <pre><code>@try_export\ndef export_edgetpu(self, tflite_model=\"\", prefix=colorstr(\"Edge TPU:\")):\n    \"\"\"YOLOv8 Edge TPU export https://coral.ai/docs/edgetpu/models-intro/.\"\"\"\n    LOGGER.warning(f\"{prefix} WARNING \u26a0\ufe0f Edge TPU known bug https://github.com/ultralytics/ultralytics/issues/1185\")\n\n    cmd = \"edgetpu_compiler --version\"\n    help_url = \"https://coral.ai/docs/edgetpu/compiler/\"\n    assert LINUX, f\"export only supported on Linux. See {help_url}\"\n    if subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True).returncode != 0:\n        LOGGER.info(f\"\\n{prefix} export requires Edge TPU compiler. Attempting install from {help_url}\")\n        sudo = subprocess.run(\"sudo --version &gt;/dev/null\", shell=True).returncode == 0  # sudo installed on system\n        for c in (\n            \"curl https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -\",\n            'echo \"deb https://packages.cloud.google.com/apt coral-edgetpu-stable main\" | '\n            \"sudo tee /etc/apt/sources.list.d/coral-edgetpu.list\",\n            \"sudo apt-get update\",\n            \"sudo apt-get install edgetpu-compiler\",\n        ):\n            subprocess.run(c if sudo else c.replace(\"sudo \", \"\"), shell=True, check=True)\n    ver = subprocess.run(cmd, shell=True, capture_output=True, check=True).stdout.decode().split()[-1]\n\n    LOGGER.info(f\"\\n{prefix} starting export with Edge TPU compiler {ver}...\")\n    f = str(tflite_model).replace(\".tflite\", \"_edgetpu.tflite\")  # Edge TPU model\n\n    cmd = f'edgetpu_compiler -s -d -k 10 --out_dir \"{Path(f).parent}\" \"{tflite_model}\"'\n    LOGGER.info(f\"{prefix} running '{cmd}'\")\n    subprocess.run(cmd, shell=True)\n    self._add_tflite_metadata(f)\n    return f, None\n</code></pre>"},{"location":"reference/engine/exporter/#ultralytics.engine.exporter.Exporter.export_engine","title":"<code>export_engine(prefix=colorstr('TensorRT:'))</code>","text":"<p>YOLOv8 TensorRT export https://developer.nvidia.com/tensorrt.</p> Source code in <code>ultralytics/engine/exporter.py</code> <pre><code>@try_export\ndef export_engine(self, prefix=colorstr(\"TensorRT:\")):\n    \"\"\"YOLOv8 TensorRT export https://developer.nvidia.com/tensorrt.\"\"\"\n    assert self.im.device.type != \"cpu\", \"export running on CPU but must be on GPU, i.e. use 'device=0'\"\n    f_onnx, _ = self.export_onnx()  # run before trt import https://github.com/ultralytics/ultralytics/issues/7016\n\n    try:\n        import tensorrt as trt  # noqa\n    except ImportError:\n        if LINUX:\n            check_requirements(\"nvidia-tensorrt\", cmds=\"-U --index-url https://pypi.ngc.nvidia.com\")\n        import tensorrt as trt  # noqa\n\n    check_version(trt.__version__, \"7.0.0\", hard=True)  # require tensorrt&gt;=7.0.0\n\n    self.args.simplify = True\n\n    LOGGER.info(f\"\\n{prefix} starting export with TensorRT {trt.__version__}...\")\n    assert Path(f_onnx).exists(), f\"failed to export ONNX file: {f_onnx}\"\n    f = self.file.with_suffix(\".engine\")  # TensorRT engine file\n    logger = trt.Logger(trt.Logger.INFO)\n    if self.args.verbose:\n        logger.min_severity = trt.Logger.Severity.VERBOSE\n\n    builder = trt.Builder(logger)\n    config = builder.create_builder_config()\n    config.max_workspace_size = self.args.workspace * 1 &lt;&lt; 30\n    # config.set_memory_pool_limit(trt.MemoryPoolType.WORKSPACE, workspace &lt;&lt; 30)  # fix TRT 8.4 deprecation notice\n\n    flag = 1 &lt;&lt; int(trt.NetworkDefinitionCreationFlag.EXPLICIT_BATCH)\n    network = builder.create_network(flag)\n    parser = trt.OnnxParser(network, logger)\n    if not parser.parse_from_file(f_onnx):\n        raise RuntimeError(f\"failed to load ONNX file: {f_onnx}\")\n\n    inputs = [network.get_input(i) for i in range(network.num_inputs)]\n    outputs = [network.get_output(i) for i in range(network.num_outputs)]\n    for inp in inputs:\n        LOGGER.info(f'{prefix} input \"{inp.name}\" with shape{inp.shape} {inp.dtype}')\n    for out in outputs:\n        LOGGER.info(f'{prefix} output \"{out.name}\" with shape{out.shape} {out.dtype}')\n\n    if self.args.dynamic:\n        shape = self.im.shape\n        if shape[0] &lt;= 1:\n            LOGGER.warning(f\"{prefix} WARNING \u26a0\ufe0f 'dynamic=True' model requires max batch size, i.e. 'batch=16'\")\n        profile = builder.create_optimization_profile()\n        for inp in inputs:\n            profile.set_shape(inp.name, (1, *shape[1:]), (max(1, shape[0] // 2), *shape[1:]), shape)\n        config.add_optimization_profile(profile)\n\n    LOGGER.info(\n        f\"{prefix} building FP{16 if builder.platform_has_fast_fp16 and self.args.half else 32} engine as {f}\"\n    )\n    if builder.platform_has_fast_fp16 and self.args.half:\n        config.set_flag(trt.BuilderFlag.FP16)\n\n    del self.model\n    torch.cuda.empty_cache()\n\n    # Write file\n    with builder.build_engine(network, config) as engine, open(f, \"wb\") as t:\n        # Metadata\n        meta = json.dumps(self.metadata)\n        t.write(len(meta).to_bytes(4, byteorder=\"little\", signed=True))\n        t.write(meta.encode())\n        # Model\n        t.write(engine.serialize())\n\n    return f, None\n</code></pre>"},{"location":"reference/engine/exporter/#ultralytics.engine.exporter.Exporter.export_ncnn","title":"<code>export_ncnn(prefix=colorstr('ncnn:'))</code>","text":"<p>YOLOv8 ncnn export using PNNX https://github.com/pnnx/pnnx.</p> Source code in <code>ultralytics/engine/exporter.py</code> <pre><code>@try_export\ndef export_ncnn(self, prefix=colorstr(\"ncnn:\")):\n    \"\"\"\n    YOLOv8 ncnn export using PNNX https://github.com/pnnx/pnnx.\n    \"\"\"\n    check_requirements(\"git+https://github.com/Tencent/ncnn.git\" if ARM64 else \"ncnn\")  # requires ncnn\n    import ncnn  # noqa\n\n    LOGGER.info(f\"\\n{prefix} starting export with ncnn {ncnn.__version__}...\")\n    f = Path(str(self.file).replace(self.file.suffix, f\"_ncnn_model{os.sep}\"))\n    f_ts = self.file.with_suffix(\".torchscript\")\n\n    name = Path(\"pnnx.exe\" if WINDOWS else \"pnnx\")  # PNNX filename\n    pnnx = name if name.is_file() else ROOT / name\n    if not pnnx.is_file():\n        LOGGER.warning(\n            f\"{prefix} WARNING \u26a0\ufe0f PNNX not found. Attempting to download binary file from \"\n            \"https://github.com/pnnx/pnnx/.\\nNote PNNX Binary file must be placed in current working directory \"\n            f\"or in {ROOT}. See PNNX repo for full installation instructions.\"\n        )\n        system = [\"macos\"] if MACOS else [\"windows\"] if WINDOWS else [\"ubuntu\", \"linux\"]  # operating system\n        try:\n            _, assets = get_github_assets(repo=\"pnnx/pnnx\", retry=True)\n            url = [x for x in assets if any(s in x for s in system)][0]\n        except Exception as e:\n            url = f\"https://github.com/pnnx/pnnx/releases/download/20231127/pnnx-20231127-{system[0]}.zip\"\n            LOGGER.warning(f\"{prefix} WARNING \u26a0\ufe0f PNNX GitHub assets not found: {e}, using default {url}\")\n        asset = attempt_download_asset(url, repo=\"pnnx/pnnx\", release=\"latest\")\n        if check_is_path_safe(Path.cwd(), asset):  # avoid path traversal security vulnerability\n            unzip_dir = Path(asset).with_suffix(\"\")\n            (unzip_dir / name).rename(pnnx)  # move binary to ROOT\n            shutil.rmtree(unzip_dir)  # delete unzip dir\n            Path(asset).unlink()  # delete zip\n            pnnx.chmod(0o777)  # set read, write, and execute permissions for everyone\n\n    ncnn_args = [\n        f'ncnnparam={f / \"model.ncnn.param\"}',\n        f'ncnnbin={f / \"model.ncnn.bin\"}',\n        f'ncnnpy={f / \"model_ncnn.py\"}',\n    ]\n\n    pnnx_args = [\n        f'pnnxparam={f / \"model.pnnx.param\"}',\n        f'pnnxbin={f / \"model.pnnx.bin\"}',\n        f'pnnxpy={f / \"model_pnnx.py\"}',\n        f'pnnxonnx={f / \"model.pnnx.onnx\"}',\n    ]\n\n    cmd = [\n        str(pnnx),\n        str(f_ts),\n        *ncnn_args,\n        *pnnx_args,\n        f\"fp16={int(self.args.half)}\",\n        f\"device={self.device.type}\",\n        f'inputshape=\"{[self.args.batch, 3, *self.imgsz]}\"',\n    ]\n    f.mkdir(exist_ok=True)  # make ncnn_model directory\n    LOGGER.info(f\"{prefix} running '{' '.join(cmd)}'\")\n    subprocess.run(cmd, check=True)\n\n    # Remove debug files\n    pnnx_files = [x.split(\"=\")[-1] for x in pnnx_args]\n    for f_debug in (\"debug.bin\", \"debug.param\", \"debug2.bin\", \"debug2.param\", *pnnx_files):\n        Path(f_debug).unlink(missing_ok=True)\n\n    yaml_save(f / \"metadata.yaml\", self.metadata)  # add metadata.yaml\n    return str(f), None\n</code></pre>"},{"location":"reference/engine/exporter/#ultralytics.engine.exporter.Exporter.export_onnx","title":"<code>export_onnx(prefix=colorstr('ONNX:'))</code>","text":"<p>YOLOv8 ONNX export.</p> Source code in <code>ultralytics/engine/exporter.py</code> <pre><code>@try_export\ndef export_onnx(self, prefix=colorstr(\"ONNX:\")):\n    \"\"\"YOLOv8 ONNX export.\"\"\"\n    requirements = [\"onnx&gt;=1.12.0\"]\n    if self.args.simplify:\n        requirements += [\"onnxsim&gt;=0.4.33\", \"onnxruntime-gpu\" if torch.cuda.is_available() else \"onnxruntime\"]\n    check_requirements(requirements)\n    import onnx  # noqa\n\n    opset_version = self.args.opset or get_latest_opset()\n    LOGGER.info(f\"\\n{prefix} starting export with onnx {onnx.__version__} opset {opset_version}...\")\n    f = str(self.file.with_suffix(\".onnx\"))\n\n    output_names = [\"output0\", \"output1\"] if isinstance(self.model, SegmentationModel) else [\"output0\"]\n    dynamic = self.args.dynamic\n    if dynamic:\n        dynamic = {\"images\": {0: \"batch\", 2: \"height\", 3: \"width\"}}  # shape(1,3,640,640)\n        if isinstance(self.model, SegmentationModel):\n            dynamic[\"output0\"] = {0: \"batch\", 2: \"anchors\"}  # shape(1, 116, 8400)\n            dynamic[\"output1\"] = {0: \"batch\", 2: \"mask_height\", 3: \"mask_width\"}  # shape(1,32,160,160)\n        elif isinstance(self.model, DetectionModel):\n            dynamic[\"output0\"] = {0: \"batch\", 2: \"anchors\"}  # shape(1, 84, 8400)\n\n    torch.onnx.export(\n        self.model.cpu() if dynamic else self.model,  # dynamic=True only compatible with cpu\n        self.im.cpu() if dynamic else self.im,\n        f,\n        verbose=False,\n        opset_version=opset_version,\n        do_constant_folding=True,  # WARNING: DNN inference with torch&gt;=1.12 may require do_constant_folding=False\n        input_names=[\"images\"],\n        output_names=output_names,\n        dynamic_axes=dynamic or None,\n    )\n\n    # Checks\n    model_onnx = onnx.load(f)  # load onnx model\n    # onnx.checker.check_model(model_onnx)  # check onnx model\n\n    # Simplify\n    if self.args.simplify:\n        try:\n            import onnxsim\n\n            LOGGER.info(f\"{prefix} simplifying with onnxsim {onnxsim.__version__}...\")\n            # subprocess.run(f'onnxsim \"{f}\" \"{f}\"', shell=True)\n            model_onnx, check = onnxsim.simplify(model_onnx)\n            assert check, \"Simplified ONNX model could not be validated\"\n        except Exception as e:\n            LOGGER.info(f\"{prefix} simplifier failure: {e}\")\n\n    # Metadata\n    for k, v in self.metadata.items():\n        meta = model_onnx.metadata_props.add()\n        meta.key, meta.value = k, str(v)\n\n    onnx.save(model_onnx, f)\n    return f, model_onnx\n</code></pre>"},{"location":"reference/engine/exporter/#ultralytics.engine.exporter.Exporter.export_openvino","title":"<code>export_openvino(prefix=colorstr('OpenVINO:'))</code>","text":"<p>YOLOv8 OpenVINO export.</p> Source code in <code>ultralytics/engine/exporter.py</code> <pre><code>@try_export\ndef export_openvino(self, prefix=colorstr(\"OpenVINO:\")):\n    \"\"\"YOLOv8 OpenVINO export.\"\"\"\n    check_requirements(\"openvino-dev&gt;=2023.0\")  # requires openvino-dev: https://pypi.org/project/openvino-dev/\n    import openvino.runtime as ov  # noqa\n    from openvino.tools import mo  # noqa\n\n    LOGGER.info(f\"\\n{prefix} starting export with openvino {ov.__version__}...\")\n    f = str(self.file).replace(self.file.suffix, f\"_openvino_model{os.sep}\")\n    fq = str(self.file).replace(self.file.suffix, f\"_int8_openvino_model{os.sep}\")\n    f_onnx = self.file.with_suffix(\".onnx\")\n    f_ov = str(Path(f) / self.file.with_suffix(\".xml\").name)\n    fq_ov = str(Path(fq) / self.file.with_suffix(\".xml\").name)\n\n    def serialize(ov_model, file):\n        \"\"\"Set RT info, serialize and save metadata YAML.\"\"\"\n        ov_model.set_rt_info(\"YOLOv8\", [\"model_info\", \"model_type\"])\n        ov_model.set_rt_info(True, [\"model_info\", \"reverse_input_channels\"])\n        ov_model.set_rt_info(114, [\"model_info\", \"pad_value\"])\n        ov_model.set_rt_info([255.0], [\"model_info\", \"scale_values\"])\n        ov_model.set_rt_info(self.args.iou, [\"model_info\", \"iou_threshold\"])\n        ov_model.set_rt_info([v.replace(\" \", \"_\") for v in self.model.names.values()], [\"model_info\", \"labels\"])\n        if self.model.task != \"classify\":\n            ov_model.set_rt_info(\"fit_to_window_letterbox\", [\"model_info\", \"resize_type\"])\n\n        ov.serialize(ov_model, file)  # save\n        yaml_save(Path(file).parent / \"metadata.yaml\", self.metadata)  # add metadata.yaml\n\n    ov_model = mo.convert_model(\n        f_onnx, model_name=self.pretty_name, framework=\"onnx\", compress_to_fp16=self.args.half\n    )  # export\n\n    if self.args.int8:\n        assert self.args.data, \"INT8 export requires a data argument for calibration, i.e. 'data=coco8.yaml'\"\n        check_requirements(\"nncf&gt;=2.5.0\")\n        import nncf\n\n        def transform_fn(data_item):\n            \"\"\"Quantization transform function.\"\"\"\n            im = data_item[\"img\"].numpy().astype(np.float32) / 255.0  # uint8 to fp16/32 and 0 - 255 to 0.0 - 1.0\n            return np.expand_dims(im, 0) if im.ndim == 3 else im\n\n        # Generate calibration data for integer quantization\n        LOGGER.info(f\"{prefix} collecting INT8 calibration images from 'data={self.args.data}'\")\n        data = check_det_dataset(self.args.data)\n        dataset = YOLODataset(data[\"val\"], data=data, imgsz=self.imgsz[0], augment=False)\n        quantization_dataset = nncf.Dataset(dataset, transform_fn)\n        ignored_scope = nncf.IgnoredScope(types=[\"Multiply\", \"Subtract\", \"Sigmoid\"])  # ignore operation\n        quantized_ov_model = nncf.quantize(\n            ov_model, quantization_dataset, preset=nncf.QuantizationPreset.MIXED, ignored_scope=ignored_scope\n        )\n        serialize(quantized_ov_model, fq_ov)\n        return fq, None\n\n    serialize(ov_model, f_ov)\n    return f, None\n</code></pre>"},{"location":"reference/engine/exporter/#ultralytics.engine.exporter.Exporter.export_paddle","title":"<code>export_paddle(prefix=colorstr('PaddlePaddle:'))</code>","text":"<p>YOLOv8 Paddle export.</p> Source code in <code>ultralytics/engine/exporter.py</code> <pre><code>@try_export\ndef export_paddle(self, prefix=colorstr(\"PaddlePaddle:\")):\n    \"\"\"YOLOv8 Paddle export.\"\"\"\n    check_requirements((\"paddlepaddle\", \"x2paddle\"))\n    import x2paddle  # noqa\n    from x2paddle.convert import pytorch2paddle  # noqa\n\n    LOGGER.info(f\"\\n{prefix} starting export with X2Paddle {x2paddle.__version__}...\")\n    f = str(self.file).replace(self.file.suffix, f\"_paddle_model{os.sep}\")\n\n    pytorch2paddle(module=self.model, save_dir=f, jit_type=\"trace\", input_examples=[self.im])  # export\n    yaml_save(Path(f) / \"metadata.yaml\", self.metadata)  # add metadata.yaml\n    return f, None\n</code></pre>"},{"location":"reference/engine/exporter/#ultralytics.engine.exporter.Exporter.export_pb","title":"<code>export_pb(keras_model, prefix=colorstr('TensorFlow GraphDef:'))</code>","text":"<p>YOLOv8 TensorFlow GraphDef *.pb export https://github.com/leimao/Frozen_Graph_TensorFlow.</p> Source code in <code>ultralytics/engine/exporter.py</code> <pre><code>@try_export\ndef export_pb(self, keras_model, prefix=colorstr(\"TensorFlow GraphDef:\")):\n    \"\"\"YOLOv8 TensorFlow GraphDef *.pb export https://github.com/leimao/Frozen_Graph_TensorFlow.\"\"\"\n    import tensorflow as tf  # noqa\n    from tensorflow.python.framework.convert_to_constants import convert_variables_to_constants_v2  # noqa\n\n    LOGGER.info(f\"\\n{prefix} starting export with tensorflow {tf.__version__}...\")\n    f = self.file.with_suffix(\".pb\")\n\n    m = tf.function(lambda x: keras_model(x))  # full model\n    m = m.get_concrete_function(tf.TensorSpec(keras_model.inputs[0].shape, keras_model.inputs[0].dtype))\n    frozen_func = convert_variables_to_constants_v2(m)\n    frozen_func.graph.as_graph_def()\n    tf.io.write_graph(graph_or_graph_def=frozen_func.graph, logdir=str(f.parent), name=f.name, as_text=False)\n    return f, None\n</code></pre>"},{"location":"reference/engine/exporter/#ultralytics.engine.exporter.Exporter.export_saved_model","title":"<code>export_saved_model(prefix=colorstr('TensorFlow SavedModel:'))</code>","text":"<p>YOLOv8 TensorFlow SavedModel export.</p> Source code in <code>ultralytics/engine/exporter.py</code> <pre><code>@try_export\ndef export_saved_model(self, prefix=colorstr(\"TensorFlow SavedModel:\")):\n    \"\"\"YOLOv8 TensorFlow SavedModel export.\"\"\"\n    cuda = torch.cuda.is_available()\n    try:\n        import tensorflow as tf  # noqa\n    except ImportError:\n        check_requirements(f\"tensorflow{'-macos' if MACOS else '-aarch64' if ARM64 else '' if cuda else '-cpu'}\")\n        import tensorflow as tf  # noqa\n    check_requirements(\n        (\n            \"onnx\",\n            \"onnx2tf&gt;=1.15.4,&lt;=1.17.5\",\n            \"sng4onnx&gt;=1.0.1\",\n            \"onnxsim&gt;=0.4.33\",\n            \"onnx_graphsurgeon&gt;=0.3.26\",\n            \"tflite_support\",\n            \"onnxruntime-gpu\" if cuda else \"onnxruntime\",\n        ),\n        cmds=\"--extra-index-url https://pypi.ngc.nvidia.com\",\n    )  # onnx_graphsurgeon only on NVIDIA\n\n    LOGGER.info(f\"\\n{prefix} starting export with tensorflow {tf.__version__}...\")\n    check_version(\n        tf.__version__,\n        \"&lt;=2.13.1\",\n        name=\"tensorflow\",\n        verbose=True,\n        msg=\"https://github.com/ultralytics/ultralytics/issues/5161\",\n    )\n    f = Path(str(self.file).replace(self.file.suffix, \"_saved_model\"))\n    if f.is_dir():\n        import shutil\n\n        shutil.rmtree(f)  # delete output folder\n\n    # Pre-download calibration file to fix https://github.com/PINTO0309/onnx2tf/issues/545\n    onnx2tf_file = Path(\"calibration_image_sample_data_20x128x128x3_float32.npy\")\n    if not onnx2tf_file.exists():\n        attempt_download_asset(f\"{onnx2tf_file}.zip\", unzip=True, delete=True)\n\n    # Export to ONNX\n    self.args.simplify = True\n    f_onnx, _ = self.export_onnx()\n\n    # Export to TF\n    tmp_file = f / \"tmp_tflite_int8_calibration_images.npy\"  # int8 calibration images file\n    if self.args.int8:\n        verbosity = \"--verbosity info\"\n        if self.args.data:\n            # Generate calibration data for integer quantization\n            LOGGER.info(f\"{prefix} collecting INT8 calibration images from 'data={self.args.data}'\")\n            data = check_det_dataset(self.args.data)\n            dataset = YOLODataset(data[\"val\"], data=data, imgsz=self.imgsz[0], augment=False)\n            images = []\n            for i, batch in enumerate(dataset):\n                if i &gt;= 100:  # maximum number of calibration images\n                    break\n                im = batch[\"img\"].permute(1, 2, 0)[None]  # list to nparray, CHW to BHWC\n                images.append(im)\n            f.mkdir()\n            images = torch.cat(images, 0).float()\n            # mean = images.view(-1, 3).mean(0)  # imagenet mean [123.675, 116.28, 103.53]\n            # std = images.view(-1, 3).std(0)  # imagenet std [58.395, 57.12, 57.375]\n            np.save(str(tmp_file), images.numpy())  # BHWC\n            int8 = f'-oiqt -qt per-tensor -cind images \"{tmp_file}\" \"[[[[0, 0, 0]]]]\" \"[[[[255, 255, 255]]]]\"'\n        else:\n            int8 = \"-oiqt -qt per-tensor\"\n    else:\n        verbosity = \"--non_verbose\"\n        int8 = \"\"\n\n    cmd = f'onnx2tf -i \"{f_onnx}\" -o \"{f}\" -nuo {verbosity} {int8}'.strip()\n    LOGGER.info(f\"{prefix} running '{cmd}'\")\n    subprocess.run(cmd, shell=True)\n    yaml_save(f / \"metadata.yaml\", self.metadata)  # add metadata.yaml\n\n    # Remove/rename TFLite models\n    if self.args.int8:\n        tmp_file.unlink(missing_ok=True)\n        for file in f.rglob(\"*_dynamic_range_quant.tflite\"):\n            file.rename(file.with_name(file.stem.replace(\"_dynamic_range_quant\", \"_int8\") + file.suffix))\n        for file in f.rglob(\"*_integer_quant_with_int16_act.tflite\"):\n            file.unlink()  # delete extra fp16 activation TFLite files\n\n    # Add TFLite metadata\n    for file in f.rglob(\"*.tflite\"):\n        f.unlink() if \"quant_with_int16_act.tflite\" in str(f) else self._add_tflite_metadata(file)\n\n    return str(f), tf.saved_model.load(f, tags=None, options=None)  # load saved_model as Keras model\n</code></pre>"},{"location":"reference/engine/exporter/#ultralytics.engine.exporter.Exporter.export_tfjs","title":"<code>export_tfjs(prefix=colorstr('TensorFlow.js:'))</code>","text":"<p>YOLOv8 TensorFlow.js export.</p> Source code in <code>ultralytics/engine/exporter.py</code> <pre><code>@try_export\ndef export_tfjs(self, prefix=colorstr(\"TensorFlow.js:\")):\n    \"\"\"YOLOv8 TensorFlow.js export.\"\"\"\n    # JAX bug requiring install constraints in https://github.com/google/jax/issues/18978\n    check_requirements([\"jax&lt;=0.4.21\", \"jaxlib&lt;=0.4.21\", \"tensorflowjs\"])\n    import tensorflow as tf\n    import tensorflowjs as tfjs  # noqa\n\n    LOGGER.info(f\"\\n{prefix} starting export with tensorflowjs {tfjs.__version__}...\")\n    f = str(self.file).replace(self.file.suffix, \"_web_model\")  # js dir\n    f_pb = str(self.file.with_suffix(\".pb\"))  # *.pb path\n\n    gd = tf.Graph().as_graph_def()  # TF GraphDef\n    with open(f_pb, \"rb\") as file:\n        gd.ParseFromString(file.read())\n    outputs = \",\".join(gd_outputs(gd))\n    LOGGER.info(f\"\\n{prefix} output node names: {outputs}\")\n\n    quantization = \"--quantize_float16\" if self.args.half else \"--quantize_uint8\" if self.args.int8 else \"\"\n    with spaces_in_path(f_pb) as fpb_, spaces_in_path(f) as f_:  # exporter can not handle spaces in path\n        cmd = f'tensorflowjs_converter --input_format=tf_frozen_model {quantization} --output_node_names={outputs} \"{fpb_}\" \"{f_}\"'\n        LOGGER.info(f\"{prefix} running '{cmd}'\")\n        subprocess.run(cmd, shell=True)\n\n    if \" \" in f:\n        LOGGER.warning(f\"{prefix} WARNING \u26a0\ufe0f your model may not work correctly with spaces in path '{f}'.\")\n\n    # f_json = Path(f) / 'model.json'  # *.json path\n    # with open(f_json, 'w') as j:  # sort JSON Identity_* in ascending order\n    #     subst = re.sub(\n    #         r'{\"outputs\": {\"Identity.?.?\": {\"name\": \"Identity.?.?\"}, '\n    #         r'\"Identity.?.?\": {\"name\": \"Identity.?.?\"}, '\n    #         r'\"Identity.?.?\": {\"name\": \"Identity.?.?\"}, '\n    #         r'\"Identity.?.?\": {\"name\": \"Identity.?.?\"}}}',\n    #         r'{\"outputs\": {\"Identity\": {\"name\": \"Identity\"}, '\n    #         r'\"Identity_1\": {\"name\": \"Identity_1\"}, '\n    #         r'\"Identity_2\": {\"name\": \"Identity_2\"}, '\n    #         r'\"Identity_3\": {\"name\": \"Identity_3\"}}}',\n    #         f_json.read_text(),\n    #     )\n    #     j.write(subst)\n    yaml_save(Path(f) / \"metadata.yaml\", self.metadata)  # add metadata.yaml\n    return f, None\n</code></pre>"},{"location":"reference/engine/exporter/#ultralytics.engine.exporter.Exporter.export_tflite","title":"<code>export_tflite(keras_model, nms, agnostic_nms, prefix=colorstr('TensorFlow Lite:'))</code>","text":"<p>YOLOv8 TensorFlow Lite export.</p> Source code in <code>ultralytics/engine/exporter.py</code> <pre><code>@try_export\ndef export_tflite(self, keras_model, nms, agnostic_nms, prefix=colorstr(\"TensorFlow Lite:\")):\n    \"\"\"YOLOv8 TensorFlow Lite export.\"\"\"\n    import tensorflow as tf  # noqa\n\n    LOGGER.info(f\"\\n{prefix} starting export with tensorflow {tf.__version__}...\")\n    saved_model = Path(str(self.file).replace(self.file.suffix, \"_saved_model\"))\n    if self.args.int8:\n        f = saved_model / f\"{self.file.stem}_int8.tflite\"  # fp32 in/out\n    elif self.args.half:\n        f = saved_model / f\"{self.file.stem}_float16.tflite\"  # fp32 in/out\n    else:\n        f = saved_model / f\"{self.file.stem}_float32.tflite\"\n    return str(f), None\n</code></pre>"},{"location":"reference/engine/exporter/#ultralytics.engine.exporter.Exporter.export_torchscript","title":"<code>export_torchscript(prefix=colorstr('TorchScript:'))</code>","text":"<p>YOLOv8 TorchScript model export.</p> Source code in <code>ultralytics/engine/exporter.py</code> <pre><code>@try_export\ndef export_torchscript(self, prefix=colorstr(\"TorchScript:\")):\n    \"\"\"YOLOv8 TorchScript model export.\"\"\"\n    LOGGER.info(f\"\\n{prefix} starting export with torch {torch.__version__}...\")\n    f = self.file.with_suffix(\".torchscript\")\n\n    ts = torch.jit.trace(self.model, self.im, strict=False)\n    extra_files = {\"config.txt\": json.dumps(self.metadata)}  # torch._C.ExtraFilesMap()\n    if self.args.optimize:  # https://pytorch.org/tutorials/recipes/mobile_interpreter.html\n        LOGGER.info(f\"{prefix} optimizing for mobile...\")\n        from torch.utils.mobile_optimizer import optimize_for_mobile\n\n        optimize_for_mobile(ts)._save_for_lite_interpreter(str(f), _extra_files=extra_files)\n    else:\n        ts.save(str(f), _extra_files=extra_files)\n    return f, None\n</code></pre>"},{"location":"reference/engine/exporter/#ultralytics.engine.exporter.Exporter.run_callbacks","title":"<code>run_callbacks(event)</code>","text":"<p>Execute all callbacks for a given event.</p> Source code in <code>ultralytics/engine/exporter.py</code> <pre><code>def run_callbacks(self, event: str):\n    \"\"\"Execute all callbacks for a given event.\"\"\"\n    for callback in self.callbacks.get(event, []):\n        callback(self)\n</code></pre>"},{"location":"reference/engine/exporter/#ultralytics.engine.exporter.IOSDetectModel","title":"<code>ultralytics.engine.exporter.IOSDetectModel</code>","text":"<p>             Bases: <code>Module</code></p> <p>Wrap an Ultralytics YOLO model for Apple iOS CoreML export.</p> Source code in <code>ultralytics/engine/exporter.py</code> <pre><code>class IOSDetectModel(torch.nn.Module):\n    \"\"\"Wrap an Ultralytics YOLO model for Apple iOS CoreML export.\"\"\"\n\n    def __init__(self, model, im):\n        \"\"\"Initialize the IOSDetectModel class with a YOLO model and example image.\"\"\"\n        super().__init__()\n        _, _, h, w = im.shape  # batch, channel, height, width\n        self.model = model\n        self.nc = len(model.names)  # number of classes\n        if w == h:\n            self.normalize = 1.0 / w  # scalar\n        else:\n            self.normalize = torch.tensor([1.0 / w, 1.0 / h, 1.0 / w, 1.0 / h])  # broadcast (slower, smaller)\n\n    def forward(self, x):\n        \"\"\"Normalize predictions of object detection model with input size-dependent factors.\"\"\"\n        xywh, cls = self.model(x)[0].transpose(0, 1).split((4, self.nc), 1)\n        return cls, xywh * self.normalize  # confidence (3780, 80), coordinates (3780, 4)\n</code></pre>"},{"location":"reference/engine/exporter/#ultralytics.engine.exporter.IOSDetectModel.__init__","title":"<code>__init__(model, im)</code>","text":"<p>Initialize the IOSDetectModel class with a YOLO model and example image.</p> Source code in <code>ultralytics/engine/exporter.py</code> <pre><code>def __init__(self, model, im):\n    \"\"\"Initialize the IOSDetectModel class with a YOLO model and example image.\"\"\"\n    super().__init__()\n    _, _, h, w = im.shape  # batch, channel, height, width\n    self.model = model\n    self.nc = len(model.names)  # number of classes\n    if w == h:\n        self.normalize = 1.0 / w  # scalar\n    else:\n        self.normalize = torch.tensor([1.0 / w, 1.0 / h, 1.0 / w, 1.0 / h])  # broadcast (slower, smaller)\n</code></pre>"},{"location":"reference/engine/exporter/#ultralytics.engine.exporter.IOSDetectModel.forward","title":"<code>forward(x)</code>","text":"<p>Normalize predictions of object detection model with input size-dependent factors.</p> Source code in <code>ultralytics/engine/exporter.py</code> <pre><code>def forward(self, x):\n    \"\"\"Normalize predictions of object detection model with input size-dependent factors.\"\"\"\n    xywh, cls = self.model(x)[0].transpose(0, 1).split((4, self.nc), 1)\n    return cls, xywh * self.normalize  # confidence (3780, 80), coordinates (3780, 4)\n</code></pre>"},{"location":"reference/engine/exporter/#ultralytics.engine.exporter.export_formats","title":"<code>ultralytics.engine.exporter.export_formats()</code>","text":"<p>YOLOv8 export formats.</p> Source code in <code>ultralytics/engine/exporter.py</code> <pre><code>def export_formats():\n    \"\"\"YOLOv8 export formats.\"\"\"\n    import pandas\n\n    x = [\n        [\"PyTorch\", \"-\", \".pt\", True, True],\n        [\"TorchScript\", \"torchscript\", \".torchscript\", True, True],\n        [\"ONNX\", \"onnx\", \".onnx\", True, True],\n        [\"OpenVINO\", \"openvino\", \"_openvino_model\", True, False],\n        [\"TensorRT\", \"engine\", \".engine\", False, True],\n        [\"CoreML\", \"coreml\", \".mlpackage\", True, False],\n        [\"TensorFlow SavedModel\", \"saved_model\", \"_saved_model\", True, True],\n        [\"TensorFlow GraphDef\", \"pb\", \".pb\", True, True],\n        [\"TensorFlow Lite\", \"tflite\", \".tflite\", True, False],\n        [\"TensorFlow Edge TPU\", \"edgetpu\", \"_edgetpu.tflite\", True, False],\n        [\"TensorFlow.js\", \"tfjs\", \"_web_model\", True, False],\n        [\"PaddlePaddle\", \"paddle\", \"_paddle_model\", True, True],\n        [\"ncnn\", \"ncnn\", \"_ncnn_model\", True, True],\n    ]\n    return pandas.DataFrame(x, columns=[\"Format\", \"Argument\", \"Suffix\", \"CPU\", \"GPU\"])\n</code></pre>"},{"location":"reference/engine/exporter/#ultralytics.engine.exporter.gd_outputs","title":"<code>ultralytics.engine.exporter.gd_outputs(gd)</code>","text":"<p>TensorFlow GraphDef model output node names.</p> Source code in <code>ultralytics/engine/exporter.py</code> <pre><code>def gd_outputs(gd):\n    \"\"\"TensorFlow GraphDef model output node names.\"\"\"\n    name_list, input_list = [], []\n    for node in gd.node:  # tensorflow.core.framework.node_def_pb2.NodeDef\n        name_list.append(node.name)\n        input_list.extend(node.input)\n    return sorted(f\"{x}:0\" for x in list(set(name_list) - set(input_list)) if not x.startswith(\"NoOp\"))\n</code></pre>"},{"location":"reference/engine/exporter/#ultralytics.engine.exporter.try_export","title":"<code>ultralytics.engine.exporter.try_export(inner_func)</code>","text":"<p>YOLOv8 export decorator, i..e @try_export.</p> Source code in <code>ultralytics/engine/exporter.py</code> <pre><code>def try_export(inner_func):\n    \"\"\"YOLOv8 export decorator, i..e @try_export.\"\"\"\n    inner_args = get_default_args(inner_func)\n\n    def outer_func(*args, **kwargs):\n        \"\"\"Export a model.\"\"\"\n        prefix = inner_args[\"prefix\"]\n        try:\n            with Profile() as dt:\n                f, model = inner_func(*args, **kwargs)\n            LOGGER.info(f\"{prefix} export success \u2705 {dt.t:.1f}s, saved as '{f}' ({file_size(f):.1f} MB)\")\n            return f, model\n        except Exception as e:\n            LOGGER.info(f\"{prefix} export failure \u274c {dt.t:.1f}s: {e}\")\n            raise e\n\n    return outer_func\n</code></pre>"},{"location":"reference/engine/model/","title":"Reference for <code>ultralytics/engine/model.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/engine/model.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p>"},{"location":"reference/engine/model/#ultralytics.engine.model.Model","title":"<code>ultralytics.engine.model.Model</code>","text":"<p>             Bases: <code>Module</code></p> <p>A base class to unify APIs for all models.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>(str, Path)</code> <p>Path to the model file to load or create.</p> <code>'yolov8n.pt'</code> <code>task</code> <code>Any</code> <p>Task type for the YOLO model. Defaults to None.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>predictor</code> <code>Any</code> <p>The predictor object.</p> <code>model</code> <code>Any</code> <p>The model object.</p> <code>trainer</code> <code>Any</code> <p>The trainer object.</p> <code>task</code> <code>str</code> <p>The type of model task.</p> <code>ckpt</code> <code>Any</code> <p>The checkpoint object if the model loaded from *.pt file.</p> <code>cfg</code> <code>str</code> <p>The model configuration if loaded from *.yaml file.</p> <code>ckpt_path</code> <code>str</code> <p>The checkpoint file path.</p> <code>overrides</code> <code>dict</code> <p>Overrides for the trainer object.</p> <code>metrics</code> <code>Any</code> <p>The data for metrics.</p> <p>Methods:</p> Name Description <code>__call__</code> <p>Alias for the predict method.</p> <code>_new</code> <p>str, verbose:bool=True) -&gt; None: Initializes a new model and infers the task type from the model definitions.</p> <code>_load</code> <p>str, task:str='') -&gt; None: Initializes a new model and infers the task type from the model head.</p> <code>_check_is_pytorch_model</code> <p>Raises TypeError if the model is not a PyTorch model.</p> <code>reset</code> <p>Resets the model modules.</p> <code>info</code> <p>bool=False) -&gt; None: Logs the model info.</p> <code>fuse</code> <p>Fuses the model for faster inference.</p> <code>predict</code> <p>Performs prediction using the YOLO model.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>Results</code> <p>The prediction results.</p> Source code in <code>ultralytics/engine/model.py</code> <pre><code>class Model(nn.Module):\n    \"\"\"\n    A base class to unify APIs for all models.\n\n    Args:\n        model (str, Path): Path to the model file to load or create.\n        task (Any, optional): Task type for the YOLO model. Defaults to None.\n\n    Attributes:\n        predictor (Any): The predictor object.\n        model (Any): The model object.\n        trainer (Any): The trainer object.\n        task (str): The type of model task.\n        ckpt (Any): The checkpoint object if the model loaded from *.pt file.\n        cfg (str): The model configuration if loaded from *.yaml file.\n        ckpt_path (str): The checkpoint file path.\n        overrides (dict): Overrides for the trainer object.\n        metrics (Any): The data for metrics.\n\n    Methods:\n        __call__(source=None, stream=False, **kwargs):\n            Alias for the predict method.\n        _new(cfg:str, verbose:bool=True) -&gt; None:\n            Initializes a new model and infers the task type from the model definitions.\n        _load(weights:str, task:str='') -&gt; None:\n            Initializes a new model and infers the task type from the model head.\n        _check_is_pytorch_model() -&gt; None:\n            Raises TypeError if the model is not a PyTorch model.\n        reset() -&gt; None:\n            Resets the model modules.\n        info(verbose:bool=False) -&gt; None:\n            Logs the model info.\n        fuse() -&gt; None:\n            Fuses the model for faster inference.\n        predict(source=None, stream=False, **kwargs) -&gt; List[ultralytics.engine.results.Results]:\n            Performs prediction using the YOLO model.\n\n    Returns:\n        list(ultralytics.engine.results.Results): The prediction results.\n    \"\"\"\n\n    def __init__(self, model: Union[str, Path] = \"yolov8n.pt\", task=None) -&gt; None:\n        \"\"\"\n        Initializes the YOLO model.\n\n        Args:\n            model (Union[str, Path], optional): Path or name of the model to load or create. Defaults to 'yolov8n.pt'.\n            task (Any, optional): Task type for the YOLO model. Defaults to None.\n        \"\"\"\n        super().__init__()\n        self.callbacks = callbacks.get_default_callbacks()\n        self.predictor = None  # reuse predictor\n        self.model = None  # model object\n        self.trainer = None  # trainer object\n        self.ckpt = None  # if loaded from *.pt\n        self.cfg = None  # if loaded from *.yaml\n        self.ckpt_path = None\n        self.overrides = {}  # overrides for trainer object\n        self.metrics = None  # validation/training metrics\n        self.session = None  # HUB session\n        self.task = task  # task type\n        model = str(model).strip()  # strip spaces\n\n        # Check if Ultralytics HUB model from https://hub.ultralytics.com\n        if self.is_hub_model(model):\n            # Fetch model from HUB\n            self.session = self._get_hub_session(model)\n            model = self.session.model_file\n\n        # Check if Triton Server model\n        elif self.is_triton_model(model):\n            self.model = model\n            self.task = task\n            return\n\n        # Load or create new YOLO model\n        model = checks.check_model_file_from_stem(model)  # add suffix, i.e. yolov8n -&gt; yolov8n.pt\n        if Path(model).suffix in (\".yaml\", \".yml\"):\n            self._new(model, task)\n        else:\n            self._load(model, task)\n\n        self.model_name = model\n\n    def __call__(self, source=None, stream=False, **kwargs):\n        \"\"\"Calls the predict() method with given arguments to perform object detection.\"\"\"\n        return self.predict(source, stream, **kwargs)\n\n    @staticmethod\n    def _get_hub_session(model: str):\n        \"\"\"Creates a session for Hub Training.\"\"\"\n        from ultralytics.hub.session import HUBTrainingSession\n\n        session = HUBTrainingSession(model)\n        return session if session.client.authenticated else None\n\n    @staticmethod\n    def is_triton_model(model):\n        \"\"\"Is model a Triton Server URL string, i.e. &lt;scheme&gt;://&lt;netloc&gt;/&lt;endpoint&gt;/&lt;task_name&gt;\"\"\"\n        from urllib.parse import urlsplit\n\n        url = urlsplit(model)\n        return url.netloc and url.path and url.scheme in {\"http\", \"grpc\"}\n\n    @staticmethod\n    def is_hub_model(model):\n        \"\"\"Check if the provided model is a HUB model.\"\"\"\n        return any(\n            (\n                model.startswith(f\"{HUB_WEB_ROOT}/models/\"),  # i.e. https://hub.ultralytics.com/models/MODEL_ID\n                [len(x) for x in model.split(\"_\")] == [42, 20],  # APIKEY_MODELID\n                len(model) == 20 and not Path(model).exists() and all(x not in model for x in \"./\\\\\"),\n            )\n        )  # MODELID\n\n    def _new(self, cfg: str, task=None, model=None, verbose=True):\n        \"\"\"\n        Initializes a new model and infers the task type from the model definitions.\n\n        Args:\n            cfg (str): model configuration file\n            task (str | None): model task\n            model (BaseModel): Customized model.\n            verbose (bool): display model info on load\n        \"\"\"\n        cfg_dict = yaml_model_load(cfg)\n        self.cfg = cfg\n        self.task = task or guess_model_task(cfg_dict)\n        self.model = (model or self._smart_load(\"model\"))(cfg_dict, verbose=verbose and RANK == -1)  # build model\n        self.overrides[\"model\"] = self.cfg\n        self.overrides[\"task\"] = self.task\n\n        # Below added to allow export from YAMLs\n        self.model.args = {**DEFAULT_CFG_DICT, **self.overrides}  # combine default and model args (prefer model args)\n        self.model.task = self.task\n\n    def _load(self, weights: str, task=None):\n        \"\"\"\n        Initializes a new model and infers the task type from the model head.\n\n        Args:\n            weights (str): model checkpoint to be loaded\n            task (str | None): model task\n        \"\"\"\n        suffix = Path(weights).suffix\n        if suffix == \".pt\":\n            self.model, self.ckpt = attempt_load_one_weight(weights)\n            self.task = self.model.args[\"task\"]\n            self.overrides = self.model.args = self._reset_ckpt_args(self.model.args)\n            self.ckpt_path = self.model.pt_path\n        else:\n            weights = checks.check_file(weights)\n            self.model, self.ckpt = weights, None\n            self.task = task or guess_model_task(weights)\n            self.ckpt_path = weights\n        self.overrides[\"model\"] = weights\n        self.overrides[\"task\"] = self.task\n\n    def _check_is_pytorch_model(self):\n        \"\"\"Raises TypeError is model is not a PyTorch model.\"\"\"\n        pt_str = isinstance(self.model, (str, Path)) and Path(self.model).suffix == \".pt\"\n        pt_module = isinstance(self.model, nn.Module)\n        if not (pt_module or pt_str):\n            raise TypeError(\n                f\"model='{self.model}' should be a *.pt PyTorch model to run this method, but is a different format. \"\n                f\"PyTorch models can train, val, predict and export, i.e. 'model.train(data=...)', but exported \"\n                f\"formats like ONNX, TensorRT etc. only support 'predict' and 'val' modes, \"\n                f\"i.e. 'yolo predict model=yolov8n.onnx'.\\nTo run CUDA or MPS inference please pass the device \"\n                f\"argument directly in your inference command, i.e. 'model.predict(source=..., device=0)'\"\n            )\n\n    def reset_weights(self):\n        \"\"\"Resets the model modules parameters to randomly initialized values, losing all training information.\"\"\"\n        self._check_is_pytorch_model()\n        for m in self.model.modules():\n            if hasattr(m, \"reset_parameters\"):\n                m.reset_parameters()\n        for p in self.model.parameters():\n            p.requires_grad = True\n        return self\n\n    def load(self, weights=\"yolov8n.pt\"):\n        \"\"\"Transfers parameters with matching names and shapes from 'weights' to model.\"\"\"\n        self._check_is_pytorch_model()\n        if isinstance(weights, (str, Path)):\n            weights, self.ckpt = attempt_load_one_weight(weights)\n        self.model.load(weights)\n        return self\n\n    def info(self, detailed=False, verbose=True):\n        \"\"\"\n        Logs model info.\n\n        Args:\n            detailed (bool): Show detailed information about model.\n            verbose (bool): Controls verbosity.\n        \"\"\"\n        self._check_is_pytorch_model()\n        return self.model.info(detailed=detailed, verbose=verbose)\n\n    def fuse(self):\n        \"\"\"Fuse PyTorch Conv2d and BatchNorm2d layers.\"\"\"\n        self._check_is_pytorch_model()\n        self.model.fuse()\n\n    def embed(self, source=None, stream=False, **kwargs):\n        \"\"\"\n        Calls the predict() method and returns image embeddings.\n\n        Args:\n            source (str | int | PIL | np.ndarray): The source of the image to make predictions on.\n                Accepts all source types accepted by the YOLO model.\n            stream (bool): Whether to stream the predictions or not. Defaults to False.\n            **kwargs : Additional keyword arguments passed to the predictor.\n                Check the 'configuration' section in the documentation for all available options.\n\n        Returns:\n            (List[torch.Tensor]): A list of image embeddings.\n        \"\"\"\n        if not kwargs.get(\"embed\"):\n            kwargs[\"embed\"] = [len(self.model.model) - 2]  # embed second-to-last layer if no indices passed\n        return self.predict(source, stream, **kwargs)\n\n    def predict(self, source=None, stream=False, predictor=None, **kwargs):\n        \"\"\"\n        Perform prediction using the YOLO model.\n\n        Args:\n            source (str | int | PIL | np.ndarray): The source of the image to make predictions on.\n                Accepts all source types accepted by the YOLO model.\n            stream (bool): Whether to stream the predictions or not. Defaults to False.\n            predictor (BasePredictor): Customized predictor.\n            **kwargs : Additional keyword arguments passed to the predictor.\n                Check the 'configuration' section in the documentation for all available options.\n\n        Returns:\n            (List[ultralytics.engine.results.Results]): The prediction results.\n        \"\"\"\n        if source is None:\n            source = ASSETS\n            LOGGER.warning(f\"WARNING \u26a0\ufe0f 'source' is missing. Using 'source={source}'.\")\n\n        is_cli = (sys.argv[0].endswith(\"yolo\") or sys.argv[0].endswith(\"ultralytics\")) and any(\n            x in sys.argv for x in (\"predict\", \"track\", \"mode=predict\", \"mode=track\")\n        )\n\n        custom = {\"conf\": 0.25, \"save\": is_cli}  # method defaults\n        args = {**self.overrides, **custom, **kwargs, \"mode\": \"predict\"}  # highest priority args on the right\n        prompts = args.pop(\"prompts\", None)  # for SAM-type models\n\n        if not self.predictor:\n            self.predictor = predictor or self._smart_load(\"predictor\")(overrides=args, _callbacks=self.callbacks)\n            self.predictor.setup_model(model=self.model, verbose=is_cli)\n        else:  # only update args if predictor is already setup\n            self.predictor.args = get_cfg(self.predictor.args, args)\n            if \"project\" in args or \"name\" in args:\n                self.predictor.save_dir = get_save_dir(self.predictor.args)\n        if prompts and hasattr(self.predictor, \"set_prompts\"):  # for SAM-type models\n            self.predictor.set_prompts(prompts)\n        return self.predictor.predict_cli(source=source) if is_cli else self.predictor(source=source, stream=stream)\n\n    def track(self, source=None, stream=False, persist=False, **kwargs):\n        \"\"\"\n        Perform object tracking on the input source using the registered trackers.\n\n        Args:\n            source (str, optional): The input source for object tracking. Can be a file path or a video stream.\n            stream (bool, optional): Whether the input source is a video stream. Defaults to False.\n            persist (bool, optional): Whether to persist the trackers if they already exist. Defaults to False.\n            **kwargs (optional): Additional keyword arguments for the tracking process.\n\n        Returns:\n            (List[ultralytics.engine.results.Results]): The tracking results.\n        \"\"\"\n        if not hasattr(self.predictor, \"trackers\"):\n            from ultralytics.trackers import register_tracker\n\n            register_tracker(self, persist)\n        kwargs[\"conf\"] = kwargs.get(\"conf\") or 0.1  # ByteTrack-based method needs low confidence predictions as input\n        kwargs[\"mode\"] = \"track\"\n        return self.predict(source=source, stream=stream, **kwargs)\n\n    def val(self, validator=None, **kwargs):\n        \"\"\"\n        Validate a model on a given dataset.\n\n        Args:\n            validator (BaseValidator): Customized validator.\n            **kwargs : Any other args accepted by the validators. To see all args check 'configuration' section in docs\n        \"\"\"\n        custom = {\"rect\": True}  # method defaults\n        args = {**self.overrides, **custom, **kwargs, \"mode\": \"val\"}  # highest priority args on the right\n\n        validator = (validator or self._smart_load(\"validator\"))(args=args, _callbacks=self.callbacks)\n        validator(model=self.model)\n        self.metrics = validator.metrics\n        return validator.metrics\n\n    def benchmark(self, **kwargs):\n        \"\"\"\n        Benchmark a model on all export formats.\n\n        Args:\n            **kwargs : Any other args accepted by the validators. To see all args check 'configuration' section in docs\n        \"\"\"\n        self._check_is_pytorch_model()\n        from ultralytics.utils.benchmarks import benchmark\n\n        custom = {\"verbose\": False}  # method defaults\n        args = {**DEFAULT_CFG_DICT, **self.model.args, **custom, **kwargs, \"mode\": \"benchmark\"}\n        return benchmark(\n            model=self,\n            data=kwargs.get(\"data\"),  # if no 'data' argument passed set data=None for default datasets\n            imgsz=args[\"imgsz\"],\n            half=args[\"half\"],\n            int8=args[\"int8\"],\n            device=args[\"device\"],\n            verbose=kwargs.get(\"verbose\"),\n        )\n\n    def export(self, **kwargs):\n        \"\"\"\n        Export model.\n\n        Args:\n            **kwargs : Any other args accepted by the Exporter. To see all args check 'configuration' section in docs.\n        \"\"\"\n        self._check_is_pytorch_model()\n        from .exporter import Exporter\n\n        custom = {\"imgsz\": self.model.args[\"imgsz\"], \"batch\": 1, \"data\": None, \"verbose\": False}  # method defaults\n        args = {**self.overrides, **custom, **kwargs, \"mode\": \"export\"}  # highest priority args on the right\n        return Exporter(overrides=args, _callbacks=self.callbacks)(model=self.model)\n\n    def train(self, trainer=None, **kwargs):\n        \"\"\"\n        Trains the model on a given dataset.\n\n        Args:\n            trainer (BaseTrainer, optional): Customized trainer.\n            **kwargs (Any): Any number of arguments representing the training configuration.\n        \"\"\"\n        self._check_is_pytorch_model()\n        if hasattr(self.session, \"model\") and self.session.model.id:  # Ultralytics HUB session with loaded model\n            if any(kwargs):\n                LOGGER.warning(\"WARNING \u26a0\ufe0f using HUB training arguments, ignoring local training arguments.\")\n            kwargs = self.session.train_args  # overwrite kwargs\n\n        checks.check_pip_update_available()\n\n        overrides = yaml_load(checks.check_yaml(kwargs[\"cfg\"])) if kwargs.get(\"cfg\") else self.overrides\n        custom = {\"data\": DEFAULT_CFG_DICT[\"data\"] or TASK2DATA[self.task]}  # method defaults\n        args = {**overrides, **custom, **kwargs, \"mode\": \"train\"}  # highest priority args on the right\n        if args.get(\"resume\"):\n            args[\"resume\"] = self.ckpt_path\n\n        self.trainer = (trainer or self._smart_load(\"trainer\"))(overrides=args, _callbacks=self.callbacks)\n        if not args.get(\"resume\"):  # manually set model only if not resuming\n            self.trainer.model = self.trainer.get_model(weights=self.model if self.ckpt else None, cfg=self.model.yaml)\n            self.model = self.trainer.model\n\n            if SETTINGS[\"hub\"] is True and not self.session:\n                # Create a model in HUB\n                try:\n                    self.session = self._get_hub_session(self.model_name)\n                    if self.session:\n                        self.session.create_model(args)\n                        # Check model was created\n                        if not getattr(self.session.model, \"id\", None):\n                            self.session = None\n                except PermissionError:\n                    # Ignore permission error\n                    pass\n\n        self.trainer.hub_session = self.session  # attach optional HUB session\n        self.trainer.train()\n        # Update model and cfg after training\n        if RANK in (-1, 0):\n            ckpt = self.trainer.best if self.trainer.best.exists() else self.trainer.last\n            self.model, _ = attempt_load_one_weight(ckpt)\n            self.overrides = self.model.args\n            self.metrics = getattr(self.trainer.validator, \"metrics\", None)  # TODO: no metrics returned by DDP\n        return self.metrics\n\n    def tune(self, use_ray=False, iterations=10, *args, **kwargs):\n        \"\"\"\n        Runs hyperparameter tuning, optionally using Ray Tune. See ultralytics.utils.tuner.run_ray_tune for Args.\n\n        Returns:\n            (dict): A dictionary containing the results of the hyperparameter search.\n        \"\"\"\n        self._check_is_pytorch_model()\n        if use_ray:\n            from ultralytics.utils.tuner import run_ray_tune\n\n            return run_ray_tune(self, max_samples=iterations, *args, **kwargs)\n        else:\n            from .tuner import Tuner\n\n            custom = {}  # method defaults\n            args = {**self.overrides, **custom, **kwargs, \"mode\": \"train\"}  # highest priority args on the right\n            return Tuner(args=args, _callbacks=self.callbacks)(model=self, iterations=iterations)\n\n    def _apply(self, fn):\n        \"\"\"Apply to(), cpu(), cuda(), half(), float() to model tensors that are not parameters or registered buffers.\"\"\"\n        self._check_is_pytorch_model()\n        self = super()._apply(fn)  # noqa\n        self.predictor = None  # reset predictor as device may have changed\n        self.overrides[\"device\"] = self.device  # was str(self.device) i.e. device(type='cuda', index=0) -&gt; 'cuda:0'\n        return self\n\n    @property\n    def names(self):\n        \"\"\"Returns class names of the loaded model.\"\"\"\n        return self.model.names if hasattr(self.model, \"names\") else None\n\n    @property\n    def device(self):\n        \"\"\"Returns device if PyTorch model.\"\"\"\n        return next(self.model.parameters()).device if isinstance(self.model, nn.Module) else None\n\n    @property\n    def transforms(self):\n        \"\"\"Returns transform of the loaded model.\"\"\"\n        return self.model.transforms if hasattr(self.model, \"transforms\") else None\n\n    def add_callback(self, event: str, func):\n        \"\"\"Add a callback.\"\"\"\n        self.callbacks[event].append(func)\n\n    def clear_callback(self, event: str):\n        \"\"\"Clear all event callbacks.\"\"\"\n        self.callbacks[event] = []\n\n    def reset_callbacks(self):\n        \"\"\"Reset all registered callbacks.\"\"\"\n        for event in callbacks.default_callbacks.keys():\n            self.callbacks[event] = [callbacks.default_callbacks[event][0]]\n\n    @staticmethod\n    def _reset_ckpt_args(args):\n        \"\"\"Reset arguments when loading a PyTorch model.\"\"\"\n        include = {\"imgsz\", \"data\", \"task\", \"single_cls\"}  # only remember these arguments when loading a PyTorch model\n        return {k: v for k, v in args.items() if k in include}\n\n    # def __getattr__(self, attr):\n    #    \"\"\"Raises error if object has no requested attribute.\"\"\"\n    #    name = self.__class__.__name__\n    #    raise AttributeError(f\"'{name}' object has no attribute '{attr}'. See valid attributes below.\\n{self.__doc__}\")\n\n    def _smart_load(self, key):\n        \"\"\"Load model/trainer/validator/predictor.\"\"\"\n        try:\n            return self.task_map[self.task][key]\n        except Exception as e:\n            name = self.__class__.__name__\n            mode = inspect.stack()[1][3]  # get the function name.\n            raise NotImplementedError(\n                emojis(f\"WARNING \u26a0\ufe0f '{name}' model does not support '{mode}' mode for '{self.task}' task yet.\")\n            ) from e\n\n    @property\n    def task_map(self):\n        \"\"\"\n        Map head to model, trainer, validator, and predictor classes.\n\n        Returns:\n            task_map (dict): The map of model task to mode classes.\n        \"\"\"\n        raise NotImplementedError(\"Please provide task map for your model!\")\n</code></pre>"},{"location":"reference/engine/model/#ultralytics.engine.model.Model.device","title":"<code>device</code>  <code>property</code>","text":"<p>Returns device if PyTorch model.</p>"},{"location":"reference/engine/model/#ultralytics.engine.model.Model.names","title":"<code>names</code>  <code>property</code>","text":"<p>Returns class names of the loaded model.</p>"},{"location":"reference/engine/model/#ultralytics.engine.model.Model.task_map","title":"<code>task_map</code>  <code>property</code>","text":"<p>Map head to model, trainer, validator, and predictor classes.</p> <p>Returns:</p> Name Type Description <code>task_map</code> <code>dict</code> <p>The map of model task to mode classes.</p>"},{"location":"reference/engine/model/#ultralytics.engine.model.Model.transforms","title":"<code>transforms</code>  <code>property</code>","text":"<p>Returns transform of the loaded model.</p>"},{"location":"reference/engine/model/#ultralytics.engine.model.Model.__call__","title":"<code>__call__(source=None, stream=False, **kwargs)</code>","text":"<p>Calls the predict() method with given arguments to perform object detection.</p> Source code in <code>ultralytics/engine/model.py</code> <pre><code>def __call__(self, source=None, stream=False, **kwargs):\n    \"\"\"Calls the predict() method with given arguments to perform object detection.\"\"\"\n    return self.predict(source, stream, **kwargs)\n</code></pre>"},{"location":"reference/engine/model/#ultralytics.engine.model.Model.__init__","title":"<code>__init__(model='yolov8n.pt', task=None)</code>","text":"<p>Initializes the YOLO model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Union[str, Path]</code> <p>Path or name of the model to load or create. Defaults to 'yolov8n.pt'.</p> <code>'yolov8n.pt'</code> <code>task</code> <code>Any</code> <p>Task type for the YOLO model. Defaults to None.</p> <code>None</code> Source code in <code>ultralytics/engine/model.py</code> <pre><code>def __init__(self, model: Union[str, Path] = \"yolov8n.pt\", task=None) -&gt; None:\n    \"\"\"\n    Initializes the YOLO model.\n\n    Args:\n        model (Union[str, Path], optional): Path or name of the model to load or create. Defaults to 'yolov8n.pt'.\n        task (Any, optional): Task type for the YOLO model. Defaults to None.\n    \"\"\"\n    super().__init__()\n    self.callbacks = callbacks.get_default_callbacks()\n    self.predictor = None  # reuse predictor\n    self.model = None  # model object\n    self.trainer = None  # trainer object\n    self.ckpt = None  # if loaded from *.pt\n    self.cfg = None  # if loaded from *.yaml\n    self.ckpt_path = None\n    self.overrides = {}  # overrides for trainer object\n    self.metrics = None  # validation/training metrics\n    self.session = None  # HUB session\n    self.task = task  # task type\n    model = str(model).strip()  # strip spaces\n\n    # Check if Ultralytics HUB model from https://hub.ultralytics.com\n    if self.is_hub_model(model):\n        # Fetch model from HUB\n        self.session = self._get_hub_session(model)\n        model = self.session.model_file\n\n    # Check if Triton Server model\n    elif self.is_triton_model(model):\n        self.model = model\n        self.task = task\n        return\n\n    # Load or create new YOLO model\n    model = checks.check_model_file_from_stem(model)  # add suffix, i.e. yolov8n -&gt; yolov8n.pt\n    if Path(model).suffix in (\".yaml\", \".yml\"):\n        self._new(model, task)\n    else:\n        self._load(model, task)\n\n    self.model_name = model\n</code></pre>"},{"location":"reference/engine/model/#ultralytics.engine.model.Model.add_callback","title":"<code>add_callback(event, func)</code>","text":"<p>Add a callback.</p> Source code in <code>ultralytics/engine/model.py</code> <pre><code>def add_callback(self, event: str, func):\n    \"\"\"Add a callback.\"\"\"\n    self.callbacks[event].append(func)\n</code></pre>"},{"location":"reference/engine/model/#ultralytics.engine.model.Model.benchmark","title":"<code>benchmark(**kwargs)</code>","text":"<p>Benchmark a model on all export formats.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Any other args accepted by the validators. To see all args check 'configuration' section in docs</p> <code>{}</code> Source code in <code>ultralytics/engine/model.py</code> <pre><code>def benchmark(self, **kwargs):\n    \"\"\"\n    Benchmark a model on all export formats.\n\n    Args:\n        **kwargs : Any other args accepted by the validators. To see all args check 'configuration' section in docs\n    \"\"\"\n    self._check_is_pytorch_model()\n    from ultralytics.utils.benchmarks import benchmark\n\n    custom = {\"verbose\": False}  # method defaults\n    args = {**DEFAULT_CFG_DICT, **self.model.args, **custom, **kwargs, \"mode\": \"benchmark\"}\n    return benchmark(\n        model=self,\n        data=kwargs.get(\"data\"),  # if no 'data' argument passed set data=None for default datasets\n        imgsz=args[\"imgsz\"],\n        half=args[\"half\"],\n        int8=args[\"int8\"],\n        device=args[\"device\"],\n        verbose=kwargs.get(\"verbose\"),\n    )\n</code></pre>"},{"location":"reference/engine/model/#ultralytics.engine.model.Model.clear_callback","title":"<code>clear_callback(event)</code>","text":"<p>Clear all event callbacks.</p> Source code in <code>ultralytics/engine/model.py</code> <pre><code>def clear_callback(self, event: str):\n    \"\"\"Clear all event callbacks.\"\"\"\n    self.callbacks[event] = []\n</code></pre>"},{"location":"reference/engine/model/#ultralytics.engine.model.Model.embed","title":"<code>embed(source=None, stream=False, **kwargs)</code>","text":"<p>Calls the predict() method and returns image embeddings.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | int | PIL | ndarray</code> <p>The source of the image to make predictions on. Accepts all source types accepted by the YOLO model.</p> <code>None</code> <code>stream</code> <code>bool</code> <p>Whether to stream the predictions or not. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments passed to the predictor. Check the 'configuration' section in the documentation for all available options.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[Tensor]</code> <p>A list of image embeddings.</p> Source code in <code>ultralytics/engine/model.py</code> <pre><code>def embed(self, source=None, stream=False, **kwargs):\n    \"\"\"\n    Calls the predict() method and returns image embeddings.\n\n    Args:\n        source (str | int | PIL | np.ndarray): The source of the image to make predictions on.\n            Accepts all source types accepted by the YOLO model.\n        stream (bool): Whether to stream the predictions or not. Defaults to False.\n        **kwargs : Additional keyword arguments passed to the predictor.\n            Check the 'configuration' section in the documentation for all available options.\n\n    Returns:\n        (List[torch.Tensor]): A list of image embeddings.\n    \"\"\"\n    if not kwargs.get(\"embed\"):\n        kwargs[\"embed\"] = [len(self.model.model) - 2]  # embed second-to-last layer if no indices passed\n    return self.predict(source, stream, **kwargs)\n</code></pre>"},{"location":"reference/engine/model/#ultralytics.engine.model.Model.export","title":"<code>export(**kwargs)</code>","text":"<p>Export model.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Any other args accepted by the Exporter. To see all args check 'configuration' section in docs.</p> <code>{}</code> Source code in <code>ultralytics/engine/model.py</code> <pre><code>def export(self, **kwargs):\n    \"\"\"\n    Export model.\n\n    Args:\n        **kwargs : Any other args accepted by the Exporter. To see all args check 'configuration' section in docs.\n    \"\"\"\n    self._check_is_pytorch_model()\n    from .exporter import Exporter\n\n    custom = {\"imgsz\": self.model.args[\"imgsz\"], \"batch\": 1, \"data\": None, \"verbose\": False}  # method defaults\n    args = {**self.overrides, **custom, **kwargs, \"mode\": \"export\"}  # highest priority args on the right\n    return Exporter(overrides=args, _callbacks=self.callbacks)(model=self.model)\n</code></pre>"},{"location":"reference/engine/model/#ultralytics.engine.model.Model.fuse","title":"<code>fuse()</code>","text":"<p>Fuse PyTorch Conv2d and BatchNorm2d layers.</p> Source code in <code>ultralytics/engine/model.py</code> <pre><code>def fuse(self):\n    \"\"\"Fuse PyTorch Conv2d and BatchNorm2d layers.\"\"\"\n    self._check_is_pytorch_model()\n    self.model.fuse()\n</code></pre>"},{"location":"reference/engine/model/#ultralytics.engine.model.Model.info","title":"<code>info(detailed=False, verbose=True)</code>","text":"<p>Logs model info.</p> <p>Parameters:</p> Name Type Description Default <code>detailed</code> <code>bool</code> <p>Show detailed information about model.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Controls verbosity.</p> <code>True</code> Source code in <code>ultralytics/engine/model.py</code> <pre><code>def info(self, detailed=False, verbose=True):\n    \"\"\"\n    Logs model info.\n\n    Args:\n        detailed (bool): Show detailed information about model.\n        verbose (bool): Controls verbosity.\n    \"\"\"\n    self._check_is_pytorch_model()\n    return self.model.info(detailed=detailed, verbose=verbose)\n</code></pre>"},{"location":"reference/engine/model/#ultralytics.engine.model.Model.is_hub_model","title":"<code>is_hub_model(model)</code>  <code>staticmethod</code>","text":"<p>Check if the provided model is a HUB model.</p> Source code in <code>ultralytics/engine/model.py</code> <pre><code>@staticmethod\ndef is_hub_model(model):\n    \"\"\"Check if the provided model is a HUB model.\"\"\"\n    return any(\n        (\n            model.startswith(f\"{HUB_WEB_ROOT}/models/\"),  # i.e. https://hub.ultralytics.com/models/MODEL_ID\n            [len(x) for x in model.split(\"_\")] == [42, 20],  # APIKEY_MODELID\n            len(model) == 20 and not Path(model).exists() and all(x not in model for x in \"./\\\\\"),\n        )\n    )  # MODELID\n</code></pre>"},{"location":"reference/engine/model/#ultralytics.engine.model.Model.is_triton_model","title":"<code>is_triton_model(model)</code>  <code>staticmethod</code>","text":"<p>Is model a Triton Server URL string, i.e. ://// Source code in <code>ultralytics/engine/model.py</code> <pre><code>@staticmethod\ndef is_triton_model(model):\n    \"\"\"Is model a Triton Server URL string, i.e. &lt;scheme&gt;://&lt;netloc&gt;/&lt;endpoint&gt;/&lt;task_name&gt;\"\"\"\n    from urllib.parse import urlsplit\n\n    url = urlsplit(model)\n    return url.netloc and url.path and url.scheme in {\"http\", \"grpc\"}\n</code></pre> <p></p>"},{"location":"reference/engine/model/#ultralytics.engine.model.Model.load","title":"<code>load(weights='yolov8n.pt')</code>","text":"<p>Transfers parameters with matching names and shapes from 'weights' to model.</p> Source code in <code>ultralytics/engine/model.py</code> <pre><code>def load(self, weights=\"yolov8n.pt\"):\n    \"\"\"Transfers parameters with matching names and shapes from 'weights' to model.\"\"\"\n    self._check_is_pytorch_model()\n    if isinstance(weights, (str, Path)):\n        weights, self.ckpt = attempt_load_one_weight(weights)\n    self.model.load(weights)\n    return self\n</code></pre>"},{"location":"reference/engine/model/#ultralytics.engine.model.Model.predict","title":"<code>predict(source=None, stream=False, predictor=None, **kwargs)</code>","text":"<p>Perform prediction using the YOLO model.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | int | PIL | ndarray</code> <p>The source of the image to make predictions on. Accepts all source types accepted by the YOLO model.</p> <code>None</code> <code>stream</code> <code>bool</code> <p>Whether to stream the predictions or not. Defaults to False.</p> <code>False</code> <code>predictor</code> <code>BasePredictor</code> <p>Customized predictor.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments passed to the predictor. Check the 'configuration' section in the documentation for all available options.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[Results]</code> <p>The prediction results.</p> Source code in <code>ultralytics/engine/model.py</code> <pre><code>def predict(self, source=None, stream=False, predictor=None, **kwargs):\n    \"\"\"\n    Perform prediction using the YOLO model.\n\n    Args:\n        source (str | int | PIL | np.ndarray): The source of the image to make predictions on.\n            Accepts all source types accepted by the YOLO model.\n        stream (bool): Whether to stream the predictions or not. Defaults to False.\n        predictor (BasePredictor): Customized predictor.\n        **kwargs : Additional keyword arguments passed to the predictor.\n            Check the 'configuration' section in the documentation for all available options.\n\n    Returns:\n        (List[ultralytics.engine.results.Results]): The prediction results.\n    \"\"\"\n    if source is None:\n        source = ASSETS\n        LOGGER.warning(f\"WARNING \u26a0\ufe0f 'source' is missing. Using 'source={source}'.\")\n\n    is_cli = (sys.argv[0].endswith(\"yolo\") or sys.argv[0].endswith(\"ultralytics\")) and any(\n        x in sys.argv for x in (\"predict\", \"track\", \"mode=predict\", \"mode=track\")\n    )\n\n    custom = {\"conf\": 0.25, \"save\": is_cli}  # method defaults\n    args = {**self.overrides, **custom, **kwargs, \"mode\": \"predict\"}  # highest priority args on the right\n    prompts = args.pop(\"prompts\", None)  # for SAM-type models\n\n    if not self.predictor:\n        self.predictor = predictor or self._smart_load(\"predictor\")(overrides=args, _callbacks=self.callbacks)\n        self.predictor.setup_model(model=self.model, verbose=is_cli)\n    else:  # only update args if predictor is already setup\n        self.predictor.args = get_cfg(self.predictor.args, args)\n        if \"project\" in args or \"name\" in args:\n            self.predictor.save_dir = get_save_dir(self.predictor.args)\n    if prompts and hasattr(self.predictor, \"set_prompts\"):  # for SAM-type models\n        self.predictor.set_prompts(prompts)\n    return self.predictor.predict_cli(source=source) if is_cli else self.predictor(source=source, stream=stream)\n</code></pre>"},{"location":"reference/engine/model/#ultralytics.engine.model.Model.reset_callbacks","title":"<code>reset_callbacks()</code>","text":"<p>Reset all registered callbacks.</p> Source code in <code>ultralytics/engine/model.py</code> <pre><code>def reset_callbacks(self):\n    \"\"\"Reset all registered callbacks.\"\"\"\n    for event in callbacks.default_callbacks.keys():\n        self.callbacks[event] = [callbacks.default_callbacks[event][0]]\n</code></pre>"},{"location":"reference/engine/model/#ultralytics.engine.model.Model.reset_weights","title":"<code>reset_weights()</code>","text":"<p>Resets the model modules parameters to randomly initialized values, losing all training information.</p> Source code in <code>ultralytics/engine/model.py</code> <pre><code>def reset_weights(self):\n    \"\"\"Resets the model modules parameters to randomly initialized values, losing all training information.\"\"\"\n    self._check_is_pytorch_model()\n    for m in self.model.modules():\n        if hasattr(m, \"reset_parameters\"):\n            m.reset_parameters()\n    for p in self.model.parameters():\n        p.requires_grad = True\n    return self\n</code></pre>"},{"location":"reference/engine/model/#ultralytics.engine.model.Model.track","title":"<code>track(source=None, stream=False, persist=False, **kwargs)</code>","text":"<p>Perform object tracking on the input source using the registered trackers.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The input source for object tracking. Can be a file path or a video stream.</p> <code>None</code> <code>stream</code> <code>bool</code> <p>Whether the input source is a video stream. Defaults to False.</p> <code>False</code> <code>persist</code> <code>bool</code> <p>Whether to persist the trackers if they already exist. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <code>optional</code> <p>Additional keyword arguments for the tracking process.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[Results]</code> <p>The tracking results.</p> Source code in <code>ultralytics/engine/model.py</code> <pre><code>def track(self, source=None, stream=False, persist=False, **kwargs):\n    \"\"\"\n    Perform object tracking on the input source using the registered trackers.\n\n    Args:\n        source (str, optional): The input source for object tracking. Can be a file path or a video stream.\n        stream (bool, optional): Whether the input source is a video stream. Defaults to False.\n        persist (bool, optional): Whether to persist the trackers if they already exist. Defaults to False.\n        **kwargs (optional): Additional keyword arguments for the tracking process.\n\n    Returns:\n        (List[ultralytics.engine.results.Results]): The tracking results.\n    \"\"\"\n    if not hasattr(self.predictor, \"trackers\"):\n        from ultralytics.trackers import register_tracker\n\n        register_tracker(self, persist)\n    kwargs[\"conf\"] = kwargs.get(\"conf\") or 0.1  # ByteTrack-based method needs low confidence predictions as input\n    kwargs[\"mode\"] = \"track\"\n    return self.predict(source=source, stream=stream, **kwargs)\n</code></pre>"},{"location":"reference/engine/model/#ultralytics.engine.model.Model.train","title":"<code>train(trainer=None, **kwargs)</code>","text":"<p>Trains the model on a given dataset.</p> <p>Parameters:</p> Name Type Description Default <code>trainer</code> <code>BaseTrainer</code> <p>Customized trainer.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Any number of arguments representing the training configuration.</p> <code>{}</code> Source code in <code>ultralytics/engine/model.py</code> <pre><code>def train(self, trainer=None, **kwargs):\n    \"\"\"\n    Trains the model on a given dataset.\n\n    Args:\n        trainer (BaseTrainer, optional): Customized trainer.\n        **kwargs (Any): Any number of arguments representing the training configuration.\n    \"\"\"\n    self._check_is_pytorch_model()\n    if hasattr(self.session, \"model\") and self.session.model.id:  # Ultralytics HUB session with loaded model\n        if any(kwargs):\n            LOGGER.warning(\"WARNING \u26a0\ufe0f using HUB training arguments, ignoring local training arguments.\")\n        kwargs = self.session.train_args  # overwrite kwargs\n\n    checks.check_pip_update_available()\n\n    overrides = yaml_load(checks.check_yaml(kwargs[\"cfg\"])) if kwargs.get(\"cfg\") else self.overrides\n    custom = {\"data\": DEFAULT_CFG_DICT[\"data\"] or TASK2DATA[self.task]}  # method defaults\n    args = {**overrides, **custom, **kwargs, \"mode\": \"train\"}  # highest priority args on the right\n    if args.get(\"resume\"):\n        args[\"resume\"] = self.ckpt_path\n\n    self.trainer = (trainer or self._smart_load(\"trainer\"))(overrides=args, _callbacks=self.callbacks)\n    if not args.get(\"resume\"):  # manually set model only if not resuming\n        self.trainer.model = self.trainer.get_model(weights=self.model if self.ckpt else None, cfg=self.model.yaml)\n        self.model = self.trainer.model\n\n        if SETTINGS[\"hub\"] is True and not self.session:\n            # Create a model in HUB\n            try:\n                self.session = self._get_hub_session(self.model_name)\n                if self.session:\n                    self.session.create_model(args)\n                    # Check model was created\n                    if not getattr(self.session.model, \"id\", None):\n                        self.session = None\n            except PermissionError:\n                # Ignore permission error\n                pass\n\n    self.trainer.hub_session = self.session  # attach optional HUB session\n    self.trainer.train()\n    # Update model and cfg after training\n    if RANK in (-1, 0):\n        ckpt = self.trainer.best if self.trainer.best.exists() else self.trainer.last\n        self.model, _ = attempt_load_one_weight(ckpt)\n        self.overrides = self.model.args\n        self.metrics = getattr(self.trainer.validator, \"metrics\", None)  # TODO: no metrics returned by DDP\n    return self.metrics\n</code></pre>"},{"location":"reference/engine/model/#ultralytics.engine.model.Model.tune","title":"<code>tune(use_ray=False, iterations=10, *args, **kwargs)</code>","text":"<p>Runs hyperparameter tuning, optionally using Ray Tune. See ultralytics.utils.tuner.run_ray_tune for Args.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the results of the hyperparameter search.</p> Source code in <code>ultralytics/engine/model.py</code> <pre><code>def tune(self, use_ray=False, iterations=10, *args, **kwargs):\n    \"\"\"\n    Runs hyperparameter tuning, optionally using Ray Tune. See ultralytics.utils.tuner.run_ray_tune for Args.\n\n    Returns:\n        (dict): A dictionary containing the results of the hyperparameter search.\n    \"\"\"\n    self._check_is_pytorch_model()\n    if use_ray:\n        from ultralytics.utils.tuner import run_ray_tune\n\n        return run_ray_tune(self, max_samples=iterations, *args, **kwargs)\n    else:\n        from .tuner import Tuner\n\n        custom = {}  # method defaults\n        args = {**self.overrides, **custom, **kwargs, \"mode\": \"train\"}  # highest priority args on the right\n        return Tuner(args=args, _callbacks=self.callbacks)(model=self, iterations=iterations)\n</code></pre>"},{"location":"reference/engine/model/#ultralytics.engine.model.Model.val","title":"<code>val(validator=None, **kwargs)</code>","text":"<p>Validate a model on a given dataset.</p> <p>Parameters:</p> Name Type Description Default <code>validator</code> <code>BaseValidator</code> <p>Customized validator.</p> <code>None</code> <code>**kwargs</code> <p>Any other args accepted by the validators. To see all args check 'configuration' section in docs</p> <code>{}</code> Source code in <code>ultralytics/engine/model.py</code> <pre><code>def val(self, validator=None, **kwargs):\n    \"\"\"\n    Validate a model on a given dataset.\n\n    Args:\n        validator (BaseValidator): Customized validator.\n        **kwargs : Any other args accepted by the validators. To see all args check 'configuration' section in docs\n    \"\"\"\n    custom = {\"rect\": True}  # method defaults\n    args = {**self.overrides, **custom, **kwargs, \"mode\": \"val\"}  # highest priority args on the right\n\n    validator = (validator or self._smart_load(\"validator\"))(args=args, _callbacks=self.callbacks)\n    validator(model=self.model)\n    self.metrics = validator.metrics\n    return validator.metrics\n</code></pre>"},{"location":"reference/engine/predictor/","title":"Reference for <code>ultralytics/engine/predictor.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/engine/predictor.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/engine/predictor/#ultralytics.engine.predictor.BasePredictor","title":"<code>ultralytics.engine.predictor.BasePredictor</code>","text":"<p>BasePredictor.</p> <p>A base class for creating predictors.</p> <p>Attributes:</p> Name Type Description <code>args</code> <code>SimpleNamespace</code> <p>Configuration for the predictor.</p> <code>save_dir</code> <code>Path</code> <p>Directory to save results.</p> <code>done_warmup</code> <code>bool</code> <p>Whether the predictor has finished setup.</p> <code>model</code> <code>Module</code> <p>Model used for prediction.</p> <code>data</code> <code>dict</code> <p>Data configuration.</p> <code>device</code> <code>device</code> <p>Device used for prediction.</p> <code>dataset</code> <code>Dataset</code> <p>Dataset used for prediction.</p> <code>vid_path</code> <code>str</code> <p>Path to video file.</p> <code>vid_writer</code> <code>VideoWriter</code> <p>Video writer for saving video output.</p> <code>data_path</code> <code>str</code> <p>Path to data.</p> Source code in <code>ultralytics/engine/predictor.py</code> <pre><code>class BasePredictor:\n    \"\"\"\n    BasePredictor.\n\n    A base class for creating predictors.\n\n    Attributes:\n        args (SimpleNamespace): Configuration for the predictor.\n        save_dir (Path): Directory to save results.\n        done_warmup (bool): Whether the predictor has finished setup.\n        model (nn.Module): Model used for prediction.\n        data (dict): Data configuration.\n        device (torch.device): Device used for prediction.\n        dataset (Dataset): Dataset used for prediction.\n        vid_path (str): Path to video file.\n        vid_writer (cv2.VideoWriter): Video writer for saving video output.\n        data_path (str): Path to data.\n    \"\"\"\n\n    def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n        \"\"\"\n        Initializes the BasePredictor class.\n\n        Args:\n            cfg (str, optional): Path to a configuration file. Defaults to DEFAULT_CFG.\n            overrides (dict, optional): Configuration overrides. Defaults to None.\n        \"\"\"\n        self.args = get_cfg(cfg, overrides)\n        self.save_dir = get_save_dir(self.args)\n        if self.args.conf is None:\n            self.args.conf = 0.25  # default conf=0.25\n        self.done_warmup = False\n        if self.args.show:\n            self.args.show = check_imshow(warn=True)\n\n        # Usable if setup is done\n        self.model = None\n        self.data = self.args.data  # data_dict\n        self.imgsz = None\n        self.device = None\n        self.dataset = None\n        self.vid_path, self.vid_writer, self.vid_frame = None, None, None\n        self.plotted_img = None\n        self.data_path = None\n        self.source_type = None\n        self.batch = None\n        self.results = None\n        self.transforms = None\n        self.callbacks = _callbacks or callbacks.get_default_callbacks()\n        self.txt_path = None\n        self._lock = threading.Lock()  # for automatic thread-safe inference\n        callbacks.add_integration_callbacks(self)\n\n    def preprocess(self, im):\n        \"\"\"\n        Prepares input image before inference.\n\n        Args:\n            im (torch.Tensor | List(np.ndarray)): BCHW for tensor, [(HWC) x B] for list.\n        \"\"\"\n        not_tensor = not isinstance(im, torch.Tensor)\n        if not_tensor:\n            im = np.stack(self.pre_transform(im))\n            im = im[..., ::-1].transpose((0, 3, 1, 2))  # BGR to RGB, BHWC to BCHW, (n, 3, h, w)\n            im = np.ascontiguousarray(im)  # contiguous\n            im = torch.from_numpy(im)\n\n        im = im.to(self.device)\n        im = im.half() if self.model.fp16 else im.float()  # uint8 to fp16/32\n        if not_tensor:\n            im /= 255  # 0 - 255 to 0.0 - 1.0\n        return im\n\n    def inference(self, im, *args, **kwargs):\n        \"\"\"Runs inference on a given image using the specified model and arguments.\"\"\"\n        visualize = (\n            increment_path(self.save_dir / Path(self.batch[0][0]).stem, mkdir=True)\n            if self.args.visualize and (not self.source_type.tensor)\n            else False\n        )\n        return self.model(im, augment=self.args.augment, visualize=visualize, embed=self.args.embed, *args, **kwargs)\n\n    def pre_transform(self, im):\n        \"\"\"\n        Pre-transform input image before inference.\n\n        Args:\n            im (List(np.ndarray)): (N, 3, h, w) for tensor, [(h, w, 3) x N] for list.\n\n        Returns:\n            (list): A list of transformed images.\n        \"\"\"\n        same_shapes = all(x.shape == im[0].shape for x in im)\n        letterbox = LetterBox(self.imgsz, auto=same_shapes and self.model.pt, stride=self.model.stride)\n        return [letterbox(image=x) for x in im]\n\n    def write_results(self, idx, results, batch):\n        \"\"\"Write inference results to a file or directory.\"\"\"\n        p, im, _ = batch\n        log_string = \"\"\n        if len(im.shape) == 3:\n            im = im[None]  # expand for batch dim\n        if self.source_type.webcam or self.source_type.from_img or self.source_type.tensor:  # batch_size &gt;= 1\n            log_string += f\"{idx}: \"\n            frame = self.dataset.count\n        else:\n            frame = getattr(self.dataset, \"frame\", 0)\n        self.data_path = p\n        self.txt_path = str(self.save_dir / \"labels\" / p.stem) + (\"\" if self.dataset.mode == \"image\" else f\"_{frame}\")\n        log_string += \"%gx%g \" % im.shape[2:]  # print string\n        result = results[idx]\n        log_string += result.verbose()\n\n        if self.args.save or self.args.show:  # Add bbox to image\n            plot_args = {\n                \"line_width\": self.args.line_width,\n                \"boxes\": self.args.show_boxes,\n                \"conf\": self.args.show_conf,\n                \"labels\": self.args.show_labels,\n            }\n            if not self.args.retina_masks:\n                plot_args[\"im_gpu\"] = im[idx]\n            self.plotted_img = result.plot(**plot_args)\n        # Write\n        if self.args.save_txt:\n            result.save_txt(f\"{self.txt_path}.txt\", save_conf=self.args.save_conf)\n        if self.args.save_crop:\n            result.save_crop(\n                save_dir=self.save_dir / \"crops\",\n                file_name=self.data_path.stem + (\"\" if self.dataset.mode == \"image\" else f\"_{frame}\"),\n            )\n\n        return log_string\n\n    def postprocess(self, preds, img, orig_imgs):\n        \"\"\"Post-processes predictions for an image and returns them.\"\"\"\n        return preds\n\n    def __call__(self, source=None, model=None, stream=False, *args, **kwargs):\n        \"\"\"Performs inference on an image or stream.\"\"\"\n        self.stream = stream\n        if stream:\n            return self.stream_inference(source, model, *args, **kwargs)\n        else:\n            return list(self.stream_inference(source, model, *args, **kwargs))  # merge list of Result into one\n\n    def predict_cli(self, source=None, model=None):\n        \"\"\"\n        Method used for CLI prediction.\n\n        It uses always generator as outputs as not required by CLI mode.\n        \"\"\"\n        gen = self.stream_inference(source, model)\n        for _ in gen:  # running CLI inference without accumulating any outputs (do not modify)\n            pass\n\n    def setup_source(self, source):\n        \"\"\"Sets up source and inference mode.\"\"\"\n        self.imgsz = check_imgsz(self.args.imgsz, stride=self.model.stride, min_dim=2)  # check image size\n        self.transforms = (\n            getattr(\n                self.model.model,\n                \"transforms\",\n                classify_transforms(self.imgsz[0], crop_fraction=self.args.crop_fraction),\n            )\n            if self.args.task == \"classify\"\n            else None\n        )\n        self.dataset = load_inference_source(\n            source=source, imgsz=self.imgsz, vid_stride=self.args.vid_stride, buffer=self.args.stream_buffer\n        )\n        self.source_type = self.dataset.source_type\n        if not getattr(self, \"stream\", True) and (\n            self.dataset.mode == \"stream\"  # streams\n            or len(self.dataset) &gt; 1000  # images\n            or any(getattr(self.dataset, \"video_flag\", [False]))\n        ):  # videos\n            LOGGER.warning(STREAM_WARNING)\n        self.vid_path = [None] * self.dataset.bs\n        self.vid_writer = [None] * self.dataset.bs\n        self.vid_frame = [None] * self.dataset.bs\n\n    @smart_inference_mode()\n    def stream_inference(self, source=None, model=None, *args, **kwargs):\n        \"\"\"Streams real-time inference on camera feed and saves results to file.\"\"\"\n        if self.args.verbose:\n            LOGGER.info(\"\")\n\n        # Setup model\n        if not self.model:\n            self.setup_model(model)\n\n        with self._lock:  # for thread-safe inference\n            # Setup source every time predict is called\n            self.setup_source(source if source is not None else self.args.source)\n\n            # Check if save_dir/ label file exists\n            if self.args.save or self.args.save_txt:\n                (self.save_dir / \"labels\" if self.args.save_txt else self.save_dir).mkdir(parents=True, exist_ok=True)\n\n            # Warmup model\n            if not self.done_warmup:\n                self.model.warmup(imgsz=(1 if self.model.pt or self.model.triton else self.dataset.bs, 3, *self.imgsz))\n                self.done_warmup = True\n\n            self.seen, self.windows, self.batch, profilers = 0, [], None, (ops.Profile(), ops.Profile(), ops.Profile())\n            self.run_callbacks(\"on_predict_start\")\n\n            for batch in self.dataset:\n                self.run_callbacks(\"on_predict_batch_start\")\n                self.batch = batch\n                path, im0s, vid_cap, s = batch\n\n                # Preprocess\n                with profilers[0]:\n                    im = self.preprocess(im0s)\n\n                # Inference\n                with profilers[1]:\n                    preds = self.inference(im, *args, **kwargs)\n                    if self.args.embed:\n                        yield from [preds] if isinstance(preds, torch.Tensor) else preds  # yield embedding tensors\n                        continue\n\n                # Postprocess\n                with profilers[2]:\n                    self.results = self.postprocess(preds, im, im0s)\n\n                self.run_callbacks(\"on_predict_postprocess_end\")\n                # Visualize, save, write results\n                n = len(im0s)\n                for i in range(n):\n                    self.seen += 1\n                    self.results[i].speed = {\n                        \"preprocess\": profilers[0].dt * 1e3 / n,\n                        \"inference\": profilers[1].dt * 1e3 / n,\n                        \"postprocess\": profilers[2].dt * 1e3 / n,\n                    }\n                    p, im0 = path[i], None if self.source_type.tensor else im0s[i].copy()\n                    p = Path(p)\n\n                    if self.args.verbose or self.args.save or self.args.save_txt or self.args.show:\n                        s += self.write_results(i, self.results, (p, im, im0))\n                    if self.args.save or self.args.save_txt:\n                        self.results[i].save_dir = self.save_dir.__str__()\n                    if self.args.show and self.plotted_img is not None:\n                        self.show(p)\n                    if self.args.save and self.plotted_img is not None:\n                        self.save_preds(vid_cap, i, str(self.save_dir / p.name))\n\n                self.run_callbacks(\"on_predict_batch_end\")\n                yield from self.results\n\n                # Print time (inference-only)\n                if self.args.verbose:\n                    LOGGER.info(f\"{s}{profilers[1].dt * 1E3:.1f}ms\")\n\n        # Release assets\n        if isinstance(self.vid_writer[-1], cv2.VideoWriter):\n            self.vid_writer[-1].release()  # release final video writer\n\n        # Print results\n        if self.args.verbose and self.seen:\n            t = tuple(x.t / self.seen * 1e3 for x in profilers)  # speeds per image\n            LOGGER.info(\n                f\"Speed: %.1fms preprocess, %.1fms inference, %.1fms postprocess per image at shape \"\n                f\"{(1, 3, *im.shape[2:])}\" % t\n            )\n        if self.args.save or self.args.save_txt or self.args.save_crop:\n            nl = len(list(self.save_dir.glob(\"labels/*.txt\")))  # number of labels\n            s = f\"\\n{nl} label{'s' * (nl &gt; 1)} saved to {self.save_dir / 'labels'}\" if self.args.save_txt else \"\"\n            LOGGER.info(f\"Results saved to {colorstr('bold', self.save_dir)}{s}\")\n\n        self.run_callbacks(\"on_predict_end\")\n\n    def setup_model(self, model, verbose=True):\n        \"\"\"Initialize YOLO model with given parameters and set it to evaluation mode.\"\"\"\n        self.model = AutoBackend(\n            model or self.args.model,\n            device=select_device(self.args.device, verbose=verbose),\n            dnn=self.args.dnn,\n            data=self.args.data,\n            fp16=self.args.half,\n            fuse=True,\n            verbose=verbose,\n        )\n\n        self.device = self.model.device  # update device\n        self.args.half = self.model.fp16  # update half\n        self.model.eval()\n\n    def show(self, p):\n        \"\"\"Display an image in a window using OpenCV imshow().\"\"\"\n        im0 = self.plotted_img\n        if platform.system() == \"Linux\" and p not in self.windows:\n            self.windows.append(p)\n            cv2.namedWindow(str(p), cv2.WINDOW_NORMAL | cv2.WINDOW_KEEPRATIO)  # allow window resize (Linux)\n            cv2.resizeWindow(str(p), im0.shape[1], im0.shape[0])\n        cv2.imshow(str(p), im0)\n        cv2.waitKey(500 if self.batch[3].startswith(\"image\") else 1)  # 1 millisecond\n\n    def save_preds(self, vid_cap, idx, save_path):\n        \"\"\"Save video predictions as mp4 at specified path.\"\"\"\n        im0 = self.plotted_img\n        # Save imgs\n        if self.dataset.mode == \"image\":\n            cv2.imwrite(save_path, im0)\n        else:  # 'video' or 'stream'\n            frames_path = f'{save_path.split(\".\", 1)[0]}_frames/'\n            if self.vid_path[idx] != save_path:  # new video\n                self.vid_path[idx] = save_path\n                if self.args.save_frames:\n                    Path(frames_path).mkdir(parents=True, exist_ok=True)\n                    self.vid_frame[idx] = 0\n                if isinstance(self.vid_writer[idx], cv2.VideoWriter):\n                    self.vid_writer[idx].release()  # release previous video writer\n                if vid_cap:  # video\n                    fps = int(vid_cap.get(cv2.CAP_PROP_FPS))  # integer required, floats produce error in MP4 codec\n                    w = int(vid_cap.get(cv2.CAP_PROP_FRAME_WIDTH))\n                    h = int(vid_cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n                else:  # stream\n                    fps, w, h = 30, im0.shape[1], im0.shape[0]\n                suffix, fourcc = (\".mp4\", \"avc1\") if MACOS else (\".avi\", \"WMV2\") if WINDOWS else (\".avi\", \"MJPG\")\n                self.vid_writer[idx] = cv2.VideoWriter(\n                    str(Path(save_path).with_suffix(suffix)), cv2.VideoWriter_fourcc(*fourcc), fps, (w, h)\n                )\n            # Write video\n            self.vid_writer[idx].write(im0)\n\n            # Write frame\n            if self.args.save_frames:\n                cv2.imwrite(f\"{frames_path}{self.vid_frame[idx]}.jpg\", im0)\n                self.vid_frame[idx] += 1\n\n    def run_callbacks(self, event: str):\n        \"\"\"Runs all registered callbacks for a specific event.\"\"\"\n        for callback in self.callbacks.get(event, []):\n            callback(self)\n\n    def add_callback(self, event: str, func):\n        \"\"\"Add callback.\"\"\"\n        self.callbacks[event].append(func)\n</code></pre>"},{"location":"reference/engine/predictor/#ultralytics.engine.predictor.BasePredictor.__call__","title":"<code>__call__(source=None, model=None, stream=False, *args, **kwargs)</code>","text":"<p>Performs inference on an image or stream.</p> Source code in <code>ultralytics/engine/predictor.py</code> <pre><code>def __call__(self, source=None, model=None, stream=False, *args, **kwargs):\n    \"\"\"Performs inference on an image or stream.\"\"\"\n    self.stream = stream\n    if stream:\n        return self.stream_inference(source, model, *args, **kwargs)\n    else:\n        return list(self.stream_inference(source, model, *args, **kwargs))  # merge list of Result into one\n</code></pre>"},{"location":"reference/engine/predictor/#ultralytics.engine.predictor.BasePredictor.__init__","title":"<code>__init__(cfg=DEFAULT_CFG, overrides=None, _callbacks=None)</code>","text":"<p>Initializes the BasePredictor class.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>str</code> <p>Path to a configuration file. Defaults to DEFAULT_CFG.</p> <code>DEFAULT_CFG</code> <code>overrides</code> <code>dict</code> <p>Configuration overrides. Defaults to None.</p> <code>None</code> Source code in <code>ultralytics/engine/predictor.py</code> <pre><code>def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n    \"\"\"\n    Initializes the BasePredictor class.\n\n    Args:\n        cfg (str, optional): Path to a configuration file. Defaults to DEFAULT_CFG.\n        overrides (dict, optional): Configuration overrides. Defaults to None.\n    \"\"\"\n    self.args = get_cfg(cfg, overrides)\n    self.save_dir = get_save_dir(self.args)\n    if self.args.conf is None:\n        self.args.conf = 0.25  # default conf=0.25\n    self.done_warmup = False\n    if self.args.show:\n        self.args.show = check_imshow(warn=True)\n\n    # Usable if setup is done\n    self.model = None\n    self.data = self.args.data  # data_dict\n    self.imgsz = None\n    self.device = None\n    self.dataset = None\n    self.vid_path, self.vid_writer, self.vid_frame = None, None, None\n    self.plotted_img = None\n    self.data_path = None\n    self.source_type = None\n    self.batch = None\n    self.results = None\n    self.transforms = None\n    self.callbacks = _callbacks or callbacks.get_default_callbacks()\n    self.txt_path = None\n    self._lock = threading.Lock()  # for automatic thread-safe inference\n    callbacks.add_integration_callbacks(self)\n</code></pre>"},{"location":"reference/engine/predictor/#ultralytics.engine.predictor.BasePredictor.add_callback","title":"<code>add_callback(event, func)</code>","text":"<p>Add callback.</p> Source code in <code>ultralytics/engine/predictor.py</code> <pre><code>def add_callback(self, event: str, func):\n    \"\"\"Add callback.\"\"\"\n    self.callbacks[event].append(func)\n</code></pre>"},{"location":"reference/engine/predictor/#ultralytics.engine.predictor.BasePredictor.inference","title":"<code>inference(im, *args, **kwargs)</code>","text":"<p>Runs inference on a given image using the specified model and arguments.</p> Source code in <code>ultralytics/engine/predictor.py</code> <pre><code>def inference(self, im, *args, **kwargs):\n    \"\"\"Runs inference on a given image using the specified model and arguments.\"\"\"\n    visualize = (\n        increment_path(self.save_dir / Path(self.batch[0][0]).stem, mkdir=True)\n        if self.args.visualize and (not self.source_type.tensor)\n        else False\n    )\n    return self.model(im, augment=self.args.augment, visualize=visualize, embed=self.args.embed, *args, **kwargs)\n</code></pre>"},{"location":"reference/engine/predictor/#ultralytics.engine.predictor.BasePredictor.postprocess","title":"<code>postprocess(preds, img, orig_imgs)</code>","text":"<p>Post-processes predictions for an image and returns them.</p> Source code in <code>ultralytics/engine/predictor.py</code> <pre><code>def postprocess(self, preds, img, orig_imgs):\n    \"\"\"Post-processes predictions for an image and returns them.\"\"\"\n    return preds\n</code></pre>"},{"location":"reference/engine/predictor/#ultralytics.engine.predictor.BasePredictor.pre_transform","title":"<code>pre_transform(im)</code>","text":"<p>Pre-transform input image before inference.</p> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>List(np.ndarray</code> <p>(N, 3, h, w) for tensor, [(h, w, 3) x N] for list.</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of transformed images.</p> Source code in <code>ultralytics/engine/predictor.py</code> <pre><code>def pre_transform(self, im):\n    \"\"\"\n    Pre-transform input image before inference.\n\n    Args:\n        im (List(np.ndarray)): (N, 3, h, w) for tensor, [(h, w, 3) x N] for list.\n\n    Returns:\n        (list): A list of transformed images.\n    \"\"\"\n    same_shapes = all(x.shape == im[0].shape for x in im)\n    letterbox = LetterBox(self.imgsz, auto=same_shapes and self.model.pt, stride=self.model.stride)\n    return [letterbox(image=x) for x in im]\n</code></pre>"},{"location":"reference/engine/predictor/#ultralytics.engine.predictor.BasePredictor.predict_cli","title":"<code>predict_cli(source=None, model=None)</code>","text":"<p>Method used for CLI prediction.</p> <p>It uses always generator as outputs as not required by CLI mode.</p> Source code in <code>ultralytics/engine/predictor.py</code> <pre><code>def predict_cli(self, source=None, model=None):\n    \"\"\"\n    Method used for CLI prediction.\n\n    It uses always generator as outputs as not required by CLI mode.\n    \"\"\"\n    gen = self.stream_inference(source, model)\n    for _ in gen:  # running CLI inference without accumulating any outputs (do not modify)\n        pass\n</code></pre>"},{"location":"reference/engine/predictor/#ultralytics.engine.predictor.BasePredictor.preprocess","title":"<code>preprocess(im)</code>","text":"<p>Prepares input image before inference.</p> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>torch.Tensor | List(np.ndarray</code> <p>BCHW for tensor, [(HWC) x B] for list.</p> required Source code in <code>ultralytics/engine/predictor.py</code> <pre><code>def preprocess(self, im):\n    \"\"\"\n    Prepares input image before inference.\n\n    Args:\n        im (torch.Tensor | List(np.ndarray)): BCHW for tensor, [(HWC) x B] for list.\n    \"\"\"\n    not_tensor = not isinstance(im, torch.Tensor)\n    if not_tensor:\n        im = np.stack(self.pre_transform(im))\n        im = im[..., ::-1].transpose((0, 3, 1, 2))  # BGR to RGB, BHWC to BCHW, (n, 3, h, w)\n        im = np.ascontiguousarray(im)  # contiguous\n        im = torch.from_numpy(im)\n\n    im = im.to(self.device)\n    im = im.half() if self.model.fp16 else im.float()  # uint8 to fp16/32\n    if not_tensor:\n        im /= 255  # 0 - 255 to 0.0 - 1.0\n    return im\n</code></pre>"},{"location":"reference/engine/predictor/#ultralytics.engine.predictor.BasePredictor.run_callbacks","title":"<code>run_callbacks(event)</code>","text":"<p>Runs all registered callbacks for a specific event.</p> Source code in <code>ultralytics/engine/predictor.py</code> <pre><code>def run_callbacks(self, event: str):\n    \"\"\"Runs all registered callbacks for a specific event.\"\"\"\n    for callback in self.callbacks.get(event, []):\n        callback(self)\n</code></pre>"},{"location":"reference/engine/predictor/#ultralytics.engine.predictor.BasePredictor.save_preds","title":"<code>save_preds(vid_cap, idx, save_path)</code>","text":"<p>Save video predictions as mp4 at specified path.</p> Source code in <code>ultralytics/engine/predictor.py</code> <pre><code>def save_preds(self, vid_cap, idx, save_path):\n    \"\"\"Save video predictions as mp4 at specified path.\"\"\"\n    im0 = self.plotted_img\n    # Save imgs\n    if self.dataset.mode == \"image\":\n        cv2.imwrite(save_path, im0)\n    else:  # 'video' or 'stream'\n        frames_path = f'{save_path.split(\".\", 1)[0]}_frames/'\n        if self.vid_path[idx] != save_path:  # new video\n            self.vid_path[idx] = save_path\n            if self.args.save_frames:\n                Path(frames_path).mkdir(parents=True, exist_ok=True)\n                self.vid_frame[idx] = 0\n            if isinstance(self.vid_writer[idx], cv2.VideoWriter):\n                self.vid_writer[idx].release()  # release previous video writer\n            if vid_cap:  # video\n                fps = int(vid_cap.get(cv2.CAP_PROP_FPS))  # integer required, floats produce error in MP4 codec\n                w = int(vid_cap.get(cv2.CAP_PROP_FRAME_WIDTH))\n                h = int(vid_cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n            else:  # stream\n                fps, w, h = 30, im0.shape[1], im0.shape[0]\n            suffix, fourcc = (\".mp4\", \"avc1\") if MACOS else (\".avi\", \"WMV2\") if WINDOWS else (\".avi\", \"MJPG\")\n            self.vid_writer[idx] = cv2.VideoWriter(\n                str(Path(save_path).with_suffix(suffix)), cv2.VideoWriter_fourcc(*fourcc), fps, (w, h)\n            )\n        # Write video\n        self.vid_writer[idx].write(im0)\n\n        # Write frame\n        if self.args.save_frames:\n            cv2.imwrite(f\"{frames_path}{self.vid_frame[idx]}.jpg\", im0)\n            self.vid_frame[idx] += 1\n</code></pre>"},{"location":"reference/engine/predictor/#ultralytics.engine.predictor.BasePredictor.setup_model","title":"<code>setup_model(model, verbose=True)</code>","text":"<p>Initialize YOLO model with given parameters and set it to evaluation mode.</p> Source code in <code>ultralytics/engine/predictor.py</code> <pre><code>def setup_model(self, model, verbose=True):\n    \"\"\"Initialize YOLO model with given parameters and set it to evaluation mode.\"\"\"\n    self.model = AutoBackend(\n        model or self.args.model,\n        device=select_device(self.args.device, verbose=verbose),\n        dnn=self.args.dnn,\n        data=self.args.data,\n        fp16=self.args.half,\n        fuse=True,\n        verbose=verbose,\n    )\n\n    self.device = self.model.device  # update device\n    self.args.half = self.model.fp16  # update half\n    self.model.eval()\n</code></pre>"},{"location":"reference/engine/predictor/#ultralytics.engine.predictor.BasePredictor.setup_source","title":"<code>setup_source(source)</code>","text":"<p>Sets up source and inference mode.</p> Source code in <code>ultralytics/engine/predictor.py</code> <pre><code>def setup_source(self, source):\n    \"\"\"Sets up source and inference mode.\"\"\"\n    self.imgsz = check_imgsz(self.args.imgsz, stride=self.model.stride, min_dim=2)  # check image size\n    self.transforms = (\n        getattr(\n            self.model.model,\n            \"transforms\",\n            classify_transforms(self.imgsz[0], crop_fraction=self.args.crop_fraction),\n        )\n        if self.args.task == \"classify\"\n        else None\n    )\n    self.dataset = load_inference_source(\n        source=source, imgsz=self.imgsz, vid_stride=self.args.vid_stride, buffer=self.args.stream_buffer\n    )\n    self.source_type = self.dataset.source_type\n    if not getattr(self, \"stream\", True) and (\n        self.dataset.mode == \"stream\"  # streams\n        or len(self.dataset) &gt; 1000  # images\n        or any(getattr(self.dataset, \"video_flag\", [False]))\n    ):  # videos\n        LOGGER.warning(STREAM_WARNING)\n    self.vid_path = [None] * self.dataset.bs\n    self.vid_writer = [None] * self.dataset.bs\n    self.vid_frame = [None] * self.dataset.bs\n</code></pre>"},{"location":"reference/engine/predictor/#ultralytics.engine.predictor.BasePredictor.show","title":"<code>show(p)</code>","text":"<p>Display an image in a window using OpenCV imshow().</p> Source code in <code>ultralytics/engine/predictor.py</code> <pre><code>def show(self, p):\n    \"\"\"Display an image in a window using OpenCV imshow().\"\"\"\n    im0 = self.plotted_img\n    if platform.system() == \"Linux\" and p not in self.windows:\n        self.windows.append(p)\n        cv2.namedWindow(str(p), cv2.WINDOW_NORMAL | cv2.WINDOW_KEEPRATIO)  # allow window resize (Linux)\n        cv2.resizeWindow(str(p), im0.shape[1], im0.shape[0])\n    cv2.imshow(str(p), im0)\n    cv2.waitKey(500 if self.batch[3].startswith(\"image\") else 1)  # 1 millisecond\n</code></pre>"},{"location":"reference/engine/predictor/#ultralytics.engine.predictor.BasePredictor.stream_inference","title":"<code>stream_inference(source=None, model=None, *args, **kwargs)</code>","text":"<p>Streams real-time inference on camera feed and saves results to file.</p> Source code in <code>ultralytics/engine/predictor.py</code> <pre><code>@smart_inference_mode()\ndef stream_inference(self, source=None, model=None, *args, **kwargs):\n    \"\"\"Streams real-time inference on camera feed and saves results to file.\"\"\"\n    if self.args.verbose:\n        LOGGER.info(\"\")\n\n    # Setup model\n    if not self.model:\n        self.setup_model(model)\n\n    with self._lock:  # for thread-safe inference\n        # Setup source every time predict is called\n        self.setup_source(source if source is not None else self.args.source)\n\n        # Check if save_dir/ label file exists\n        if self.args.save or self.args.save_txt:\n            (self.save_dir / \"labels\" if self.args.save_txt else self.save_dir).mkdir(parents=True, exist_ok=True)\n\n        # Warmup model\n        if not self.done_warmup:\n            self.model.warmup(imgsz=(1 if self.model.pt or self.model.triton else self.dataset.bs, 3, *self.imgsz))\n            self.done_warmup = True\n\n        self.seen, self.windows, self.batch, profilers = 0, [], None, (ops.Profile(), ops.Profile(), ops.Profile())\n        self.run_callbacks(\"on_predict_start\")\n\n        for batch in self.dataset:\n            self.run_callbacks(\"on_predict_batch_start\")\n            self.batch = batch\n            path, im0s, vid_cap, s = batch\n\n            # Preprocess\n            with profilers[0]:\n                im = self.preprocess(im0s)\n\n            # Inference\n            with profilers[1]:\n                preds = self.inference(im, *args, **kwargs)\n                if self.args.embed:\n                    yield from [preds] if isinstance(preds, torch.Tensor) else preds  # yield embedding tensors\n                    continue\n\n            # Postprocess\n            with profilers[2]:\n                self.results = self.postprocess(preds, im, im0s)\n\n            self.run_callbacks(\"on_predict_postprocess_end\")\n            # Visualize, save, write results\n            n = len(im0s)\n            for i in range(n):\n                self.seen += 1\n                self.results[i].speed = {\n                    \"preprocess\": profilers[0].dt * 1e3 / n,\n                    \"inference\": profilers[1].dt * 1e3 / n,\n                    \"postprocess\": profilers[2].dt * 1e3 / n,\n                }\n                p, im0 = path[i], None if self.source_type.tensor else im0s[i].copy()\n                p = Path(p)\n\n                if self.args.verbose or self.args.save or self.args.save_txt or self.args.show:\n                    s += self.write_results(i, self.results, (p, im, im0))\n                if self.args.save or self.args.save_txt:\n                    self.results[i].save_dir = self.save_dir.__str__()\n                if self.args.show and self.plotted_img is not None:\n                    self.show(p)\n                if self.args.save and self.plotted_img is not None:\n                    self.save_preds(vid_cap, i, str(self.save_dir / p.name))\n\n            self.run_callbacks(\"on_predict_batch_end\")\n            yield from self.results\n\n            # Print time (inference-only)\n            if self.args.verbose:\n                LOGGER.info(f\"{s}{profilers[1].dt * 1E3:.1f}ms\")\n\n    # Release assets\n    if isinstance(self.vid_writer[-1], cv2.VideoWriter):\n        self.vid_writer[-1].release()  # release final video writer\n\n    # Print results\n    if self.args.verbose and self.seen:\n        t = tuple(x.t / self.seen * 1e3 for x in profilers)  # speeds per image\n        LOGGER.info(\n            f\"Speed: %.1fms preprocess, %.1fms inference, %.1fms postprocess per image at shape \"\n            f\"{(1, 3, *im.shape[2:])}\" % t\n        )\n    if self.args.save or self.args.save_txt or self.args.save_crop:\n        nl = len(list(self.save_dir.glob(\"labels/*.txt\")))  # number of labels\n        s = f\"\\n{nl} label{'s' * (nl &gt; 1)} saved to {self.save_dir / 'labels'}\" if self.args.save_txt else \"\"\n        LOGGER.info(f\"Results saved to {colorstr('bold', self.save_dir)}{s}\")\n\n    self.run_callbacks(\"on_predict_end\")\n</code></pre>"},{"location":"reference/engine/predictor/#ultralytics.engine.predictor.BasePredictor.write_results","title":"<code>write_results(idx, results, batch)</code>","text":"<p>Write inference results to a file or directory.</p> Source code in <code>ultralytics/engine/predictor.py</code> <pre><code>def write_results(self, idx, results, batch):\n    \"\"\"Write inference results to a file or directory.\"\"\"\n    p, im, _ = batch\n    log_string = \"\"\n    if len(im.shape) == 3:\n        im = im[None]  # expand for batch dim\n    if self.source_type.webcam or self.source_type.from_img or self.source_type.tensor:  # batch_size &gt;= 1\n        log_string += f\"{idx}: \"\n        frame = self.dataset.count\n    else:\n        frame = getattr(self.dataset, \"frame\", 0)\n    self.data_path = p\n    self.txt_path = str(self.save_dir / \"labels\" / p.stem) + (\"\" if self.dataset.mode == \"image\" else f\"_{frame}\")\n    log_string += \"%gx%g \" % im.shape[2:]  # print string\n    result = results[idx]\n    log_string += result.verbose()\n\n    if self.args.save or self.args.show:  # Add bbox to image\n        plot_args = {\n            \"line_width\": self.args.line_width,\n            \"boxes\": self.args.show_boxes,\n            \"conf\": self.args.show_conf,\n            \"labels\": self.args.show_labels,\n        }\n        if not self.args.retina_masks:\n            plot_args[\"im_gpu\"] = im[idx]\n        self.plotted_img = result.plot(**plot_args)\n    # Write\n    if self.args.save_txt:\n        result.save_txt(f\"{self.txt_path}.txt\", save_conf=self.args.save_conf)\n    if self.args.save_crop:\n        result.save_crop(\n            save_dir=self.save_dir / \"crops\",\n            file_name=self.data_path.stem + (\"\" if self.dataset.mode == \"image\" else f\"_{frame}\"),\n        )\n\n    return log_string\n</code></pre>"},{"location":"reference/engine/results/","title":"Reference for <code>ultralytics/engine/results.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/engine/results.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/engine/results/#ultralytics.engine.results.BaseTensor","title":"<code>ultralytics.engine.results.BaseTensor</code>","text":"<p>             Bases: <code>SimpleClass</code></p> <p>Base tensor class with additional methods for easy manipulation and device handling.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>class BaseTensor(SimpleClass):\n    \"\"\"Base tensor class with additional methods for easy manipulation and device handling.\"\"\"\n\n    def __init__(self, data, orig_shape) -&gt; None:\n        \"\"\"\n        Initialize BaseTensor with data and original shape.\n\n        Args:\n            data (torch.Tensor | np.ndarray): Predictions, such as bboxes, masks and keypoints.\n            orig_shape (tuple): Original shape of image.\n        \"\"\"\n        assert isinstance(data, (torch.Tensor, np.ndarray))\n        self.data = data\n        self.orig_shape = orig_shape\n\n    @property\n    def shape(self):\n        \"\"\"Return the shape of the data tensor.\"\"\"\n        return self.data.shape\n\n    def cpu(self):\n        \"\"\"Return a copy of the tensor on CPU memory.\"\"\"\n        return self if isinstance(self.data, np.ndarray) else self.__class__(self.data.cpu(), self.orig_shape)\n\n    def numpy(self):\n        \"\"\"Return a copy of the tensor as a numpy array.\"\"\"\n        return self if isinstance(self.data, np.ndarray) else self.__class__(self.data.numpy(), self.orig_shape)\n\n    def cuda(self):\n        \"\"\"Return a copy of the tensor on GPU memory.\"\"\"\n        return self.__class__(torch.as_tensor(self.data).cuda(), self.orig_shape)\n\n    def to(self, *args, **kwargs):\n        \"\"\"Return a copy of the tensor with the specified device and dtype.\"\"\"\n        return self.__class__(torch.as_tensor(self.data).to(*args, **kwargs), self.orig_shape)\n\n    def __len__(self):  # override len(results)\n        \"\"\"Return the length of the data tensor.\"\"\"\n        return len(self.data)\n\n    def __getitem__(self, idx):\n        \"\"\"Return a BaseTensor with the specified index of the data tensor.\"\"\"\n        return self.__class__(self.data[idx], self.orig_shape)\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.BaseTensor.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Return the shape of the data tensor.</p>"},{"location":"reference/engine/results/#ultralytics.engine.results.BaseTensor.__getitem__","title":"<code>__getitem__(idx)</code>","text":"<p>Return a BaseTensor with the specified index of the data tensor.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>def __getitem__(self, idx):\n    \"\"\"Return a BaseTensor with the specified index of the data tensor.\"\"\"\n    return self.__class__(self.data[idx], self.orig_shape)\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.BaseTensor.__init__","title":"<code>__init__(data, orig_shape)</code>","text":"<p>Initialize BaseTensor with data and original shape.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Tensor | ndarray</code> <p>Predictions, such as bboxes, masks and keypoints.</p> required <code>orig_shape</code> <code>tuple</code> <p>Original shape of image.</p> required Source code in <code>ultralytics/engine/results.py</code> <pre><code>def __init__(self, data, orig_shape) -&gt; None:\n    \"\"\"\n    Initialize BaseTensor with data and original shape.\n\n    Args:\n        data (torch.Tensor | np.ndarray): Predictions, such as bboxes, masks and keypoints.\n        orig_shape (tuple): Original shape of image.\n    \"\"\"\n    assert isinstance(data, (torch.Tensor, np.ndarray))\n    self.data = data\n    self.orig_shape = orig_shape\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.BaseTensor.__len__","title":"<code>__len__()</code>","text":"<p>Return the length of the data tensor.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>def __len__(self):  # override len(results)\n    \"\"\"Return the length of the data tensor.\"\"\"\n    return len(self.data)\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.BaseTensor.cpu","title":"<code>cpu()</code>","text":"<p>Return a copy of the tensor on CPU memory.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>def cpu(self):\n    \"\"\"Return a copy of the tensor on CPU memory.\"\"\"\n    return self if isinstance(self.data, np.ndarray) else self.__class__(self.data.cpu(), self.orig_shape)\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.BaseTensor.cuda","title":"<code>cuda()</code>","text":"<p>Return a copy of the tensor on GPU memory.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>def cuda(self):\n    \"\"\"Return a copy of the tensor on GPU memory.\"\"\"\n    return self.__class__(torch.as_tensor(self.data).cuda(), self.orig_shape)\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.BaseTensor.numpy","title":"<code>numpy()</code>","text":"<p>Return a copy of the tensor as a numpy array.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>def numpy(self):\n    \"\"\"Return a copy of the tensor as a numpy array.\"\"\"\n    return self if isinstance(self.data, np.ndarray) else self.__class__(self.data.numpy(), self.orig_shape)\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.BaseTensor.to","title":"<code>to(*args, **kwargs)</code>","text":"<p>Return a copy of the tensor with the specified device and dtype.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>def to(self, *args, **kwargs):\n    \"\"\"Return a copy of the tensor with the specified device and dtype.\"\"\"\n    return self.__class__(torch.as_tensor(self.data).to(*args, **kwargs), self.orig_shape)\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.Results","title":"<code>ultralytics.engine.results.Results</code>","text":"<p>             Bases: <code>SimpleClass</code></p> <p>A class for storing and manipulating inference results.</p> <p>Parameters:</p> Name Type Description Default <code>orig_img</code> <code>ndarray</code> <p>The original image as a numpy array.</p> required <code>path</code> <code>str</code> <p>The path to the image file.</p> required <code>names</code> <code>dict</code> <p>A dictionary of class names.</p> required <code>boxes</code> <code>tensor</code> <p>A 2D tensor of bounding box coordinates for each detection.</p> <code>None</code> <code>masks</code> <code>tensor</code> <p>A 3D tensor of detection masks, where each mask is a binary image.</p> <code>None</code> <code>probs</code> <code>tensor</code> <p>A 1D tensor of probabilities of each class for classification task.</p> <code>None</code> <code>keypoints</code> <code>List[List[float]]</code> <p>A list of detected keypoints for each object.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>orig_img</code> <code>ndarray</code> <p>The original image as a numpy array.</p> <code>orig_shape</code> <code>tuple</code> <p>The original image shape in (height, width) format.</p> <code>boxes</code> <code>Boxes</code> <p>A Boxes object containing the detection bounding boxes.</p> <code>masks</code> <code>Masks</code> <p>A Masks object containing the detection masks.</p> <code>probs</code> <code>Probs</code> <p>A Probs object containing probabilities of each class for classification task.</p> <code>keypoints</code> <code>Keypoints</code> <p>A Keypoints object containing detected keypoints for each object.</p> <code>speed</code> <code>dict</code> <p>A dictionary of preprocess, inference, and postprocess speeds in milliseconds per image.</p> <code>names</code> <code>dict</code> <p>A dictionary of class names.</p> <code>path</code> <code>str</code> <p>The path to the image file.</p> <code>_keys</code> <code>tuple</code> <p>A tuple of attribute names for non-empty attributes.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>class Results(SimpleClass):\n    \"\"\"\n    A class for storing and manipulating inference results.\n\n    Args:\n        orig_img (numpy.ndarray): The original image as a numpy array.\n        path (str): The path to the image file.\n        names (dict): A dictionary of class names.\n        boxes (torch.tensor, optional): A 2D tensor of bounding box coordinates for each detection.\n        masks (torch.tensor, optional): A 3D tensor of detection masks, where each mask is a binary image.\n        probs (torch.tensor, optional): A 1D tensor of probabilities of each class for classification task.\n        keypoints (List[List[float]], optional): A list of detected keypoints for each object.\n\n    Attributes:\n        orig_img (numpy.ndarray): The original image as a numpy array.\n        orig_shape (tuple): The original image shape in (height, width) format.\n        boxes (Boxes, optional): A Boxes object containing the detection bounding boxes.\n        masks (Masks, optional): A Masks object containing the detection masks.\n        probs (Probs, optional): A Probs object containing probabilities of each class for classification task.\n        keypoints (Keypoints, optional): A Keypoints object containing detected keypoints for each object.\n        speed (dict): A dictionary of preprocess, inference, and postprocess speeds in milliseconds per image.\n        names (dict): A dictionary of class names.\n        path (str): The path to the image file.\n        _keys (tuple): A tuple of attribute names for non-empty attributes.\n    \"\"\"\n\n    def __init__(self, orig_img, path, names, boxes=None, masks=None, probs=None, keypoints=None, obb=None) -&gt; None:\n        \"\"\"Initialize the Results class.\"\"\"\n        self.orig_img = orig_img\n        self.orig_shape = orig_img.shape[:2]\n        self.boxes = Boxes(boxes, self.orig_shape) if boxes is not None else None  # native size boxes\n        self.masks = Masks(masks, self.orig_shape) if masks is not None else None  # native size or imgsz masks\n        self.probs = Probs(probs) if probs is not None else None\n        self.keypoints = Keypoints(keypoints, self.orig_shape) if keypoints is not None else None\n        self.obb = OBB(obb, self.orig_shape) if obb is not None else None\n        self.speed = {\"preprocess\": None, \"inference\": None, \"postprocess\": None}  # milliseconds per image\n        self.names = names\n        self.path = path\n        self.save_dir = None\n        self._keys = \"boxes\", \"masks\", \"probs\", \"keypoints\", \"obb\"\n\n    def __getitem__(self, idx):\n        \"\"\"Return a Results object for the specified index.\"\"\"\n        return self._apply(\"__getitem__\", idx)\n\n    def __len__(self):\n        \"\"\"Return the number of detections in the Results object.\"\"\"\n        for k in self._keys:\n            v = getattr(self, k)\n            if v is not None:\n                return len(v)\n\n    def update(self, boxes=None, masks=None, probs=None):\n        \"\"\"Update the boxes, masks, and probs attributes of the Results object.\"\"\"\n        if boxes is not None:\n            self.boxes = Boxes(ops.clip_boxes(boxes, self.orig_shape), self.orig_shape)\n        if masks is not None:\n            self.masks = Masks(masks, self.orig_shape)\n        if probs is not None:\n            self.probs = probs\n\n    def _apply(self, fn, *args, **kwargs):\n        \"\"\"\n        Applies a function to all non-empty attributes and returns a new Results object with modified attributes. This\n        function is internally called by methods like .to(), .cuda(), .cpu(), etc.\n\n        Args:\n            fn (str): The name of the function to apply.\n            *args: Variable length argument list to pass to the function.\n            **kwargs: Arbitrary keyword arguments to pass to the function.\n\n        Returns:\n            Results: A new Results object with attributes modified by the applied function.\n        \"\"\"\n        r = self.new()\n        for k in self._keys:\n            v = getattr(self, k)\n            if v is not None:\n                setattr(r, k, getattr(v, fn)(*args, **kwargs))\n        return r\n\n    def cpu(self):\n        \"\"\"Return a copy of the Results object with all tensors on CPU memory.\"\"\"\n        return self._apply(\"cpu\")\n\n    def numpy(self):\n        \"\"\"Return a copy of the Results object with all tensors as numpy arrays.\"\"\"\n        return self._apply(\"numpy\")\n\n    def cuda(self):\n        \"\"\"Return a copy of the Results object with all tensors on GPU memory.\"\"\"\n        return self._apply(\"cuda\")\n\n    def to(self, *args, **kwargs):\n        \"\"\"Return a copy of the Results object with tensors on the specified device and dtype.\"\"\"\n        return self._apply(\"to\", *args, **kwargs)\n\n    def new(self):\n        \"\"\"Return a new Results object with the same image, path, and names.\"\"\"\n        return Results(orig_img=self.orig_img, path=self.path, names=self.names)\n\n    def plot(\n        self,\n        conf=True,\n        line_width=None,\n        font_size=None,\n        font=\"Arial.ttf\",\n        pil=False,\n        img=None,\n        im_gpu=None,\n        kpt_radius=5,\n        kpt_line=True,\n        labels=True,\n        boxes=True,\n        masks=True,\n        probs=True,\n    ):\n        \"\"\"\n        Plots the detection results on an input RGB image. Accepts a numpy array (cv2) or a PIL Image.\n\n        Args:\n            conf (bool): Whether to plot the detection confidence score.\n            line_width (float, optional): The line width of the bounding boxes. If None, it is scaled to the image size.\n            font_size (float, optional): The font size of the text. If None, it is scaled to the image size.\n            font (str): The font to use for the text.\n            pil (bool): Whether to return the image as a PIL Image.\n            img (numpy.ndarray): Plot to another image. if not, plot to original image.\n            im_gpu (torch.Tensor): Normalized image in gpu with shape (1, 3, 640, 640), for faster mask plotting.\n            kpt_radius (int, optional): Radius of the drawn keypoints. Default is 5.\n            kpt_line (bool): Whether to draw lines connecting keypoints.\n            labels (bool): Whether to plot the label of bounding boxes.\n            boxes (bool): Whether to plot the bounding boxes.\n            masks (bool): Whether to plot the masks.\n            probs (bool): Whether to plot classification probability\n\n        Returns:\n            (numpy.ndarray): A numpy array of the annotated image.\n\n        Example:\n            ```python\n            from PIL import Image\n            from ultralytics import YOLO\n\n            model = YOLO('yolov8n.pt')\n            results = model('bus.jpg')  # results list\n            for r in results:\n                im_array = r.plot()  # plot a BGR numpy array of predictions\n                im = Image.fromarray(im_array[..., ::-1])  # RGB PIL image\n                im.show()  # show image\n                im.save('results.jpg')  # save image\n            ```\n        \"\"\"\n        if img is None and isinstance(self.orig_img, torch.Tensor):\n            img = (self.orig_img[0].detach().permute(1, 2, 0).contiguous() * 255).to(torch.uint8).cpu().numpy()\n\n        names = self.names\n        is_obb = self.obb is not None\n        pred_boxes, show_boxes = self.obb if is_obb else self.boxes, boxes\n        pred_masks, show_masks = self.masks, masks\n        pred_probs, show_probs = self.probs, probs\n        annotator = Annotator(\n            deepcopy(self.orig_img if img is None else img),\n            line_width,\n            font_size,\n            font,\n            pil or (pred_probs is not None and show_probs),  # Classify tasks default to pil=True\n            example=names,\n        )\n\n        # Plot Segment results\n        if pred_masks and show_masks:\n            if im_gpu is None:\n                img = LetterBox(pred_masks.shape[1:])(image=annotator.result())\n                im_gpu = (\n                    torch.as_tensor(img, dtype=torch.float16, device=pred_masks.data.device)\n                    .permute(2, 0, 1)\n                    .flip(0)\n                    .contiguous()\n                    / 255\n                )\n            idx = pred_boxes.cls if pred_boxes else range(len(pred_masks))\n            annotator.masks(pred_masks.data, colors=[colors(x, True) for x in idx], im_gpu=im_gpu)\n\n        # Plot Detect results\n        if pred_boxes is not None and show_boxes:\n            for d in reversed(pred_boxes):\n                c, conf, id = int(d.cls), float(d.conf) if conf else None, None if d.id is None else int(d.id.item())\n                name = (\"\" if id is None else f\"id:{id} \") + names[c]\n                label = (f\"{name} {conf:.2f}\" if conf else name) if labels else None\n                box = d.xyxyxyxy.reshape(-1, 4, 2).squeeze() if is_obb else d.xyxy.squeeze()\n                annotator.box_label(box, label, color=colors(c, True), rotated=is_obb)\n\n        # Plot Classify results\n        if pred_probs is not None and show_probs:\n            text = \",\\n\".join(f\"{names[j] if names else j} {pred_probs.data[j]:.2f}\" for j in pred_probs.top5)\n            x = round(self.orig_shape[0] * 0.03)\n            annotator.text([x, x], text, txt_color=(255, 255, 255))  # TODO: allow setting colors\n\n        # Plot Pose results\n        if self.keypoints is not None:\n            for k in reversed(self.keypoints.data):\n                annotator.kpts(k, self.orig_shape, radius=kpt_radius, kpt_line=kpt_line)\n\n        return annotator.result()\n\n    def verbose(self):\n        \"\"\"Return log string for each task.\"\"\"\n        log_string = \"\"\n        probs = self.probs\n        boxes = self.boxes\n        if len(self) == 0:\n            return log_string if probs is not None else f\"{log_string}(no detections), \"\n        if probs is not None:\n            log_string += f\"{', '.join(f'{self.names[j]} {probs.data[j]:.2f}' for j in probs.top5)}, \"\n        if boxes:\n            for c in boxes.cls.unique():\n                n = (boxes.cls == c).sum()  # detections per class\n                log_string += f\"{n} {self.names[int(c)]}{'s' * (n &gt; 1)}, \"\n        return log_string\n\n    def save_txt(self, txt_file, save_conf=False):\n        \"\"\"\n        Save predictions into txt file.\n\n        Args:\n            txt_file (str): txt file path.\n            save_conf (bool): save confidence score or not.\n        \"\"\"\n        is_obb = self.obb is not None\n        boxes = self.obb if is_obb else self.boxes\n        masks = self.masks\n        probs = self.probs\n        kpts = self.keypoints\n        texts = []\n        if probs is not None:\n            # Classify\n            [texts.append(f\"{probs.data[j]:.2f} {self.names[j]}\") for j in probs.top5]\n        elif boxes:\n            # Detect/segment/pose\n            for j, d in enumerate(boxes):\n                c, conf, id = int(d.cls), float(d.conf), None if d.id is None else int(d.id.item())\n                line = (c, *(d.xyxyxyxyn.view(-1) if is_obb else d.xywhn.view(-1)))\n                if masks:\n                    seg = masks[j].xyn[0].copy().reshape(-1)  # reversed mask.xyn, (n,2) to (n*2)\n                    line = (c, *seg)\n                if kpts is not None:\n                    kpt = torch.cat((kpts[j].xyn, kpts[j].conf[..., None]), 2) if kpts[j].has_visible else kpts[j].xyn\n                    line += (*kpt.reshape(-1).tolist(),)\n                line += (conf,) * save_conf + (() if id is None else (id,))\n                texts.append((\"%g \" * len(line)).rstrip() % line)\n\n        if texts:\n            Path(txt_file).parent.mkdir(parents=True, exist_ok=True)  # make directory\n            with open(txt_file, \"a\") as f:\n                f.writelines(text + \"\\n\" for text in texts)\n\n    def save_crop(self, save_dir, file_name=Path(\"im.jpg\")):\n        \"\"\"\n        Save cropped predictions to `save_dir/cls/file_name.jpg`.\n\n        Args:\n            save_dir (str | pathlib.Path): Save path.\n            file_name (str | pathlib.Path): File name.\n        \"\"\"\n        if self.probs is not None:\n            LOGGER.warning(\"WARNING \u26a0\ufe0f Classify task do not support `save_crop`.\")\n            return\n        if self.obb is not None:\n            LOGGER.warning(\"WARNING \u26a0\ufe0f OBB task do not support `save_crop`.\")\n            return\n        for d in self.boxes:\n            save_one_box(\n                d.xyxy,\n                self.orig_img.copy(),\n                file=Path(save_dir) / self.names[int(d.cls)] / f\"{Path(file_name)}.jpg\",\n                BGR=True,\n            )\n\n    def tojson(self, normalize=False):\n        \"\"\"Convert the object to JSON format.\"\"\"\n        if self.probs is not None:\n            LOGGER.warning(\"Warning: Classify task do not support `tojson` yet.\")\n            return\n\n        import json\n\n        # Create list of detection dictionaries\n        results = []\n        data = self.boxes.data.cpu().tolist()\n        h, w = self.orig_shape if normalize else (1, 1)\n        for i, row in enumerate(data):  # xyxy, track_id if tracking, conf, class_id\n            box = {\"x1\": row[0] / w, \"y1\": row[1] / h, \"x2\": row[2] / w, \"y2\": row[3] / h}\n            conf = row[-2]\n            class_id = int(row[-1])\n            name = self.names[class_id]\n            result = {\"name\": name, \"class\": class_id, \"confidence\": conf, \"box\": box}\n            if self.boxes.is_track:\n                result[\"track_id\"] = int(row[-3])  # track ID\n            if self.masks:\n                x, y = self.masks.xy[i][:, 0], self.masks.xy[i][:, 1]  # numpy array\n                result[\"segments\"] = {\"x\": (x / w).tolist(), \"y\": (y / h).tolist()}\n            if self.keypoints is not None:\n                x, y, visible = self.keypoints[i].data[0].cpu().unbind(dim=1)  # torch Tensor\n                result[\"keypoints\"] = {\"x\": (x / w).tolist(), \"y\": (y / h).tolist(), \"visible\": visible.tolist()}\n            results.append(result)\n\n        # Convert detections to JSON\n        return json.dumps(results, indent=2)\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.Results.__getitem__","title":"<code>__getitem__(idx)</code>","text":"<p>Return a Results object for the specified index.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>def __getitem__(self, idx):\n    \"\"\"Return a Results object for the specified index.\"\"\"\n    return self._apply(\"__getitem__\", idx)\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.Results.__init__","title":"<code>__init__(orig_img, path, names, boxes=None, masks=None, probs=None, keypoints=None, obb=None)</code>","text":"<p>Initialize the Results class.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>def __init__(self, orig_img, path, names, boxes=None, masks=None, probs=None, keypoints=None, obb=None) -&gt; None:\n    \"\"\"Initialize the Results class.\"\"\"\n    self.orig_img = orig_img\n    self.orig_shape = orig_img.shape[:2]\n    self.boxes = Boxes(boxes, self.orig_shape) if boxes is not None else None  # native size boxes\n    self.masks = Masks(masks, self.orig_shape) if masks is not None else None  # native size or imgsz masks\n    self.probs = Probs(probs) if probs is not None else None\n    self.keypoints = Keypoints(keypoints, self.orig_shape) if keypoints is not None else None\n    self.obb = OBB(obb, self.orig_shape) if obb is not None else None\n    self.speed = {\"preprocess\": None, \"inference\": None, \"postprocess\": None}  # milliseconds per image\n    self.names = names\n    self.path = path\n    self.save_dir = None\n    self._keys = \"boxes\", \"masks\", \"probs\", \"keypoints\", \"obb\"\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.Results.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of detections in the Results object.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>def __len__(self):\n    \"\"\"Return the number of detections in the Results object.\"\"\"\n    for k in self._keys:\n        v = getattr(self, k)\n        if v is not None:\n            return len(v)\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.Results.cpu","title":"<code>cpu()</code>","text":"<p>Return a copy of the Results object with all tensors on CPU memory.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>def cpu(self):\n    \"\"\"Return a copy of the Results object with all tensors on CPU memory.\"\"\"\n    return self._apply(\"cpu\")\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.Results.cuda","title":"<code>cuda()</code>","text":"<p>Return a copy of the Results object with all tensors on GPU memory.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>def cuda(self):\n    \"\"\"Return a copy of the Results object with all tensors on GPU memory.\"\"\"\n    return self._apply(\"cuda\")\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.Results.new","title":"<code>new()</code>","text":"<p>Return a new Results object with the same image, path, and names.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>def new(self):\n    \"\"\"Return a new Results object with the same image, path, and names.\"\"\"\n    return Results(orig_img=self.orig_img, path=self.path, names=self.names)\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.Results.numpy","title":"<code>numpy()</code>","text":"<p>Return a copy of the Results object with all tensors as numpy arrays.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>def numpy(self):\n    \"\"\"Return a copy of the Results object with all tensors as numpy arrays.\"\"\"\n    return self._apply(\"numpy\")\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.Results.plot","title":"<code>plot(conf=True, line_width=None, font_size=None, font='Arial.ttf', pil=False, img=None, im_gpu=None, kpt_radius=5, kpt_line=True, labels=True, boxes=True, masks=True, probs=True)</code>","text":"<p>Plots the detection results on an input RGB image. Accepts a numpy array (cv2) or a PIL Image.</p> <p>Parameters:</p> Name Type Description Default <code>conf</code> <code>bool</code> <p>Whether to plot the detection confidence score.</p> <code>True</code> <code>line_width</code> <code>float</code> <p>The line width of the bounding boxes. If None, it is scaled to the image size.</p> <code>None</code> <code>font_size</code> <code>float</code> <p>The font size of the text. If None, it is scaled to the image size.</p> <code>None</code> <code>font</code> <code>str</code> <p>The font to use for the text.</p> <code>'Arial.ttf'</code> <code>pil</code> <code>bool</code> <p>Whether to return the image as a PIL Image.</p> <code>False</code> <code>img</code> <code>ndarray</code> <p>Plot to another image. if not, plot to original image.</p> <code>None</code> <code>im_gpu</code> <code>Tensor</code> <p>Normalized image in gpu with shape (1, 3, 640, 640), for faster mask plotting.</p> <code>None</code> <code>kpt_radius</code> <code>int</code> <p>Radius of the drawn keypoints. Default is 5.</p> <code>5</code> <code>kpt_line</code> <code>bool</code> <p>Whether to draw lines connecting keypoints.</p> <code>True</code> <code>labels</code> <code>bool</code> <p>Whether to plot the label of bounding boxes.</p> <code>True</code> <code>boxes</code> <code>bool</code> <p>Whether to plot the bounding boxes.</p> <code>True</code> <code>masks</code> <code>bool</code> <p>Whether to plot the masks.</p> <code>True</code> <code>probs</code> <code>bool</code> <p>Whether to plot classification probability</p> <code>True</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A numpy array of the annotated image.</p> Example <pre><code>from PIL import Image\nfrom ultralytics import YOLO\n\nmodel = YOLO('yolov8n.pt')\nresults = model('bus.jpg')  # results list\nfor r in results:\n    im_array = r.plot()  # plot a BGR numpy array of predictions\n    im = Image.fromarray(im_array[..., ::-1])  # RGB PIL image\n    im.show()  # show image\n    im.save('results.jpg')  # save image\n</code></pre> Source code in <code>ultralytics/engine/results.py</code> <pre><code>def plot(\n    self,\n    conf=True,\n    line_width=None,\n    font_size=None,\n    font=\"Arial.ttf\",\n    pil=False,\n    img=None,\n    im_gpu=None,\n    kpt_radius=5,\n    kpt_line=True,\n    labels=True,\n    boxes=True,\n    masks=True,\n    probs=True,\n):\n    \"\"\"\n    Plots the detection results on an input RGB image. Accepts a numpy array (cv2) or a PIL Image.\n\n    Args:\n        conf (bool): Whether to plot the detection confidence score.\n        line_width (float, optional): The line width of the bounding boxes. If None, it is scaled to the image size.\n        font_size (float, optional): The font size of the text. If None, it is scaled to the image size.\n        font (str): The font to use for the text.\n        pil (bool): Whether to return the image as a PIL Image.\n        img (numpy.ndarray): Plot to another image. if not, plot to original image.\n        im_gpu (torch.Tensor): Normalized image in gpu with shape (1, 3, 640, 640), for faster mask plotting.\n        kpt_radius (int, optional): Radius of the drawn keypoints. Default is 5.\n        kpt_line (bool): Whether to draw lines connecting keypoints.\n        labels (bool): Whether to plot the label of bounding boxes.\n        boxes (bool): Whether to plot the bounding boxes.\n        masks (bool): Whether to plot the masks.\n        probs (bool): Whether to plot classification probability\n\n    Returns:\n        (numpy.ndarray): A numpy array of the annotated image.\n\n    Example:\n        ```python\n        from PIL import Image\n        from ultralytics import YOLO\n\n        model = YOLO('yolov8n.pt')\n        results = model('bus.jpg')  # results list\n        for r in results:\n            im_array = r.plot()  # plot a BGR numpy array of predictions\n            im = Image.fromarray(im_array[..., ::-1])  # RGB PIL image\n            im.show()  # show image\n            im.save('results.jpg')  # save image\n        ```\n    \"\"\"\n    if img is None and isinstance(self.orig_img, torch.Tensor):\n        img = (self.orig_img[0].detach().permute(1, 2, 0).contiguous() * 255).to(torch.uint8).cpu().numpy()\n\n    names = self.names\n    is_obb = self.obb is not None\n    pred_boxes, show_boxes = self.obb if is_obb else self.boxes, boxes\n    pred_masks, show_masks = self.masks, masks\n    pred_probs, show_probs = self.probs, probs\n    annotator = Annotator(\n        deepcopy(self.orig_img if img is None else img),\n        line_width,\n        font_size,\n        font,\n        pil or (pred_probs is not None and show_probs),  # Classify tasks default to pil=True\n        example=names,\n    )\n\n    # Plot Segment results\n    if pred_masks and show_masks:\n        if im_gpu is None:\n            img = LetterBox(pred_masks.shape[1:])(image=annotator.result())\n            im_gpu = (\n                torch.as_tensor(img, dtype=torch.float16, device=pred_masks.data.device)\n                .permute(2, 0, 1)\n                .flip(0)\n                .contiguous()\n                / 255\n            )\n        idx = pred_boxes.cls if pred_boxes else range(len(pred_masks))\n        annotator.masks(pred_masks.data, colors=[colors(x, True) for x in idx], im_gpu=im_gpu)\n\n    # Plot Detect results\n    if pred_boxes is not None and show_boxes:\n        for d in reversed(pred_boxes):\n            c, conf, id = int(d.cls), float(d.conf) if conf else None, None if d.id is None else int(d.id.item())\n            name = (\"\" if id is None else f\"id:{id} \") + names[c]\n            label = (f\"{name} {conf:.2f}\" if conf else name) if labels else None\n            box = d.xyxyxyxy.reshape(-1, 4, 2).squeeze() if is_obb else d.xyxy.squeeze()\n            annotator.box_label(box, label, color=colors(c, True), rotated=is_obb)\n\n    # Plot Classify results\n    if pred_probs is not None and show_probs:\n        text = \",\\n\".join(f\"{names[j] if names else j} {pred_probs.data[j]:.2f}\" for j in pred_probs.top5)\n        x = round(self.orig_shape[0] * 0.03)\n        annotator.text([x, x], text, txt_color=(255, 255, 255))  # TODO: allow setting colors\n\n    # Plot Pose results\n    if self.keypoints is not None:\n        for k in reversed(self.keypoints.data):\n            annotator.kpts(k, self.orig_shape, radius=kpt_radius, kpt_line=kpt_line)\n\n    return annotator.result()\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.Results.save_crop","title":"<code>save_crop(save_dir, file_name=Path('im.jpg'))</code>","text":"<p>Save cropped predictions to <code>save_dir/cls/file_name.jpg</code>.</p> <p>Parameters:</p> Name Type Description Default <code>save_dir</code> <code>str | Path</code> <p>Save path.</p> required <code>file_name</code> <code>str | Path</code> <p>File name.</p> <code>Path('im.jpg')</code> Source code in <code>ultralytics/engine/results.py</code> <pre><code>def save_crop(self, save_dir, file_name=Path(\"im.jpg\")):\n    \"\"\"\n    Save cropped predictions to `save_dir/cls/file_name.jpg`.\n\n    Args:\n        save_dir (str | pathlib.Path): Save path.\n        file_name (str | pathlib.Path): File name.\n    \"\"\"\n    if self.probs is not None:\n        LOGGER.warning(\"WARNING \u26a0\ufe0f Classify task do not support `save_crop`.\")\n        return\n    if self.obb is not None:\n        LOGGER.warning(\"WARNING \u26a0\ufe0f OBB task do not support `save_crop`.\")\n        return\n    for d in self.boxes:\n        save_one_box(\n            d.xyxy,\n            self.orig_img.copy(),\n            file=Path(save_dir) / self.names[int(d.cls)] / f\"{Path(file_name)}.jpg\",\n            BGR=True,\n        )\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.Results.save_txt","title":"<code>save_txt(txt_file, save_conf=False)</code>","text":"<p>Save predictions into txt file.</p> <p>Parameters:</p> Name Type Description Default <code>txt_file</code> <code>str</code> <p>txt file path.</p> required <code>save_conf</code> <code>bool</code> <p>save confidence score or not.</p> <code>False</code> Source code in <code>ultralytics/engine/results.py</code> <pre><code>def save_txt(self, txt_file, save_conf=False):\n    \"\"\"\n    Save predictions into txt file.\n\n    Args:\n        txt_file (str): txt file path.\n        save_conf (bool): save confidence score or not.\n    \"\"\"\n    is_obb = self.obb is not None\n    boxes = self.obb if is_obb else self.boxes\n    masks = self.masks\n    probs = self.probs\n    kpts = self.keypoints\n    texts = []\n    if probs is not None:\n        # Classify\n        [texts.append(f\"{probs.data[j]:.2f} {self.names[j]}\") for j in probs.top5]\n    elif boxes:\n        # Detect/segment/pose\n        for j, d in enumerate(boxes):\n            c, conf, id = int(d.cls), float(d.conf), None if d.id is None else int(d.id.item())\n            line = (c, *(d.xyxyxyxyn.view(-1) if is_obb else d.xywhn.view(-1)))\n            if masks:\n                seg = masks[j].xyn[0].copy().reshape(-1)  # reversed mask.xyn, (n,2) to (n*2)\n                line = (c, *seg)\n            if kpts is not None:\n                kpt = torch.cat((kpts[j].xyn, kpts[j].conf[..., None]), 2) if kpts[j].has_visible else kpts[j].xyn\n                line += (*kpt.reshape(-1).tolist(),)\n            line += (conf,) * save_conf + (() if id is None else (id,))\n            texts.append((\"%g \" * len(line)).rstrip() % line)\n\n    if texts:\n        Path(txt_file).parent.mkdir(parents=True, exist_ok=True)  # make directory\n        with open(txt_file, \"a\") as f:\n            f.writelines(text + \"\\n\" for text in texts)\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.Results.to","title":"<code>to(*args, **kwargs)</code>","text":"<p>Return a copy of the Results object with tensors on the specified device and dtype.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>def to(self, *args, **kwargs):\n    \"\"\"Return a copy of the Results object with tensors on the specified device and dtype.\"\"\"\n    return self._apply(\"to\", *args, **kwargs)\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.Results.tojson","title":"<code>tojson(normalize=False)</code>","text":"<p>Convert the object to JSON format.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>def tojson(self, normalize=False):\n    \"\"\"Convert the object to JSON format.\"\"\"\n    if self.probs is not None:\n        LOGGER.warning(\"Warning: Classify task do not support `tojson` yet.\")\n        return\n\n    import json\n\n    # Create list of detection dictionaries\n    results = []\n    data = self.boxes.data.cpu().tolist()\n    h, w = self.orig_shape if normalize else (1, 1)\n    for i, row in enumerate(data):  # xyxy, track_id if tracking, conf, class_id\n        box = {\"x1\": row[0] / w, \"y1\": row[1] / h, \"x2\": row[2] / w, \"y2\": row[3] / h}\n        conf = row[-2]\n        class_id = int(row[-1])\n        name = self.names[class_id]\n        result = {\"name\": name, \"class\": class_id, \"confidence\": conf, \"box\": box}\n        if self.boxes.is_track:\n            result[\"track_id\"] = int(row[-3])  # track ID\n        if self.masks:\n            x, y = self.masks.xy[i][:, 0], self.masks.xy[i][:, 1]  # numpy array\n            result[\"segments\"] = {\"x\": (x / w).tolist(), \"y\": (y / h).tolist()}\n        if self.keypoints is not None:\n            x, y, visible = self.keypoints[i].data[0].cpu().unbind(dim=1)  # torch Tensor\n            result[\"keypoints\"] = {\"x\": (x / w).tolist(), \"y\": (y / h).tolist(), \"visible\": visible.tolist()}\n        results.append(result)\n\n    # Convert detections to JSON\n    return json.dumps(results, indent=2)\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.Results.update","title":"<code>update(boxes=None, masks=None, probs=None)</code>","text":"<p>Update the boxes, masks, and probs attributes of the Results object.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>def update(self, boxes=None, masks=None, probs=None):\n    \"\"\"Update the boxes, masks, and probs attributes of the Results object.\"\"\"\n    if boxes is not None:\n        self.boxes = Boxes(ops.clip_boxes(boxes, self.orig_shape), self.orig_shape)\n    if masks is not None:\n        self.masks = Masks(masks, self.orig_shape)\n    if probs is not None:\n        self.probs = probs\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.Results.verbose","title":"<code>verbose()</code>","text":"<p>Return log string for each task.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>def verbose(self):\n    \"\"\"Return log string for each task.\"\"\"\n    log_string = \"\"\n    probs = self.probs\n    boxes = self.boxes\n    if len(self) == 0:\n        return log_string if probs is not None else f\"{log_string}(no detections), \"\n    if probs is not None:\n        log_string += f\"{', '.join(f'{self.names[j]} {probs.data[j]:.2f}' for j in probs.top5)}, \"\n    if boxes:\n        for c in boxes.cls.unique():\n            n = (boxes.cls == c).sum()  # detections per class\n            log_string += f\"{n} {self.names[int(c)]}{'s' * (n &gt; 1)}, \"\n    return log_string\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.Boxes","title":"<code>ultralytics.engine.results.Boxes</code>","text":"<p>             Bases: <code>BaseTensor</code></p> <p>A class for storing and manipulating detection boxes.</p> <p>Parameters:</p> Name Type Description Default <code>boxes</code> <code>Tensor | ndarray</code> <p>A tensor or numpy array containing the detection boxes, with shape (num_boxes, 6) or (num_boxes, 7). The last two columns contain confidence and class values. If present, the third last column contains track IDs.</p> required <code>orig_shape</code> <code>tuple</code> <p>Original image size, in the format (height, width).</p> required <p>Attributes:</p> Name Type Description <code>xyxy</code> <code>Tensor | ndarray</code> <p>The boxes in xyxy format.</p> <code>conf</code> <code>Tensor | ndarray</code> <p>The confidence values of the boxes.</p> <code>cls</code> <code>Tensor | ndarray</code> <p>The class values of the boxes.</p> <code>id</code> <code>Tensor | ndarray</code> <p>The track IDs of the boxes (if available).</p> <code>xywh</code> <code>Tensor | ndarray</code> <p>The boxes in xywh format.</p> <code>xyxyn</code> <code>Tensor | ndarray</code> <p>The boxes in xyxy format normalized by original image size.</p> <code>xywhn</code> <code>Tensor | ndarray</code> <p>The boxes in xywh format normalized by original image size.</p> <code>data</code> <code>Tensor</code> <p>The raw bboxes tensor (alias for <code>boxes</code>).</p> <p>Methods:</p> Name Description <code>cpu</code> <p>Move the object to CPU memory.</p> <code>numpy</code> <p>Convert the object to a numpy array.</p> <code>cuda</code> <p>Move the object to CUDA memory.</p> <code>to</code> <p>Move the object to the specified device.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>class Boxes(BaseTensor):\n    \"\"\"\n    A class for storing and manipulating detection boxes.\n\n    Args:\n        boxes (torch.Tensor | numpy.ndarray): A tensor or numpy array containing the detection boxes,\n            with shape (num_boxes, 6) or (num_boxes, 7). The last two columns contain confidence and class values.\n            If present, the third last column contains track IDs.\n        orig_shape (tuple): Original image size, in the format (height, width).\n\n    Attributes:\n        xyxy (torch.Tensor | numpy.ndarray): The boxes in xyxy format.\n        conf (torch.Tensor | numpy.ndarray): The confidence values of the boxes.\n        cls (torch.Tensor | numpy.ndarray): The class values of the boxes.\n        id (torch.Tensor | numpy.ndarray): The track IDs of the boxes (if available).\n        xywh (torch.Tensor | numpy.ndarray): The boxes in xywh format.\n        xyxyn (torch.Tensor | numpy.ndarray): The boxes in xyxy format normalized by original image size.\n        xywhn (torch.Tensor | numpy.ndarray): The boxes in xywh format normalized by original image size.\n        data (torch.Tensor): The raw bboxes tensor (alias for `boxes`).\n\n    Methods:\n        cpu(): Move the object to CPU memory.\n        numpy(): Convert the object to a numpy array.\n        cuda(): Move the object to CUDA memory.\n        to(*args, **kwargs): Move the object to the specified device.\n    \"\"\"\n\n    def __init__(self, boxes, orig_shape) -&gt; None:\n        \"\"\"Initialize the Boxes class.\"\"\"\n        if boxes.ndim == 1:\n            boxes = boxes[None, :]\n        n = boxes.shape[-1]\n        assert n in (6, 7), f\"expected 6 or 7 values but got {n}\"  # xyxy, track_id, conf, cls\n        super().__init__(boxes, orig_shape)\n        self.is_track = n == 7\n        self.orig_shape = orig_shape\n\n    @property\n    def xyxy(self):\n        \"\"\"Return the boxes in xyxy format.\"\"\"\n        return self.data[:, :4]\n\n    @property\n    def conf(self):\n        \"\"\"Return the confidence values of the boxes.\"\"\"\n        return self.data[:, -2]\n\n    @property\n    def cls(self):\n        \"\"\"Return the class values of the boxes.\"\"\"\n        return self.data[:, -1]\n\n    @property\n    def id(self):\n        \"\"\"Return the track IDs of the boxes (if available).\"\"\"\n        return self.data[:, -3] if self.is_track else None\n\n    @property\n    @lru_cache(maxsize=2)  # maxsize 1 should suffice\n    def xywh(self):\n        \"\"\"Return the boxes in xywh format.\"\"\"\n        return ops.xyxy2xywh(self.xyxy)\n\n    @property\n    @lru_cache(maxsize=2)\n    def xyxyn(self):\n        \"\"\"Return the boxes in xyxy format normalized by original image size.\"\"\"\n        xyxy = self.xyxy.clone() if isinstance(self.xyxy, torch.Tensor) else np.copy(self.xyxy)\n        xyxy[..., [0, 2]] /= self.orig_shape[1]\n        xyxy[..., [1, 3]] /= self.orig_shape[0]\n        return xyxy\n\n    @property\n    @lru_cache(maxsize=2)\n    def xywhn(self):\n        \"\"\"Return the boxes in xywh format normalized by original image size.\"\"\"\n        xywh = ops.xyxy2xywh(self.xyxy)\n        xywh[..., [0, 2]] /= self.orig_shape[1]\n        xywh[..., [1, 3]] /= self.orig_shape[0]\n        return xywh\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.Boxes.cls","title":"<code>cls</code>  <code>property</code>","text":"<p>Return the class values of the boxes.</p>"},{"location":"reference/engine/results/#ultralytics.engine.results.Boxes.conf","title":"<code>conf</code>  <code>property</code>","text":"<p>Return the confidence values of the boxes.</p>"},{"location":"reference/engine/results/#ultralytics.engine.results.Boxes.id","title":"<code>id</code>  <code>property</code>","text":"<p>Return the track IDs of the boxes (if available).</p>"},{"location":"reference/engine/results/#ultralytics.engine.results.Boxes.xywh","title":"<code>xywh</code>  <code>cached</code> <code>property</code>","text":"<p>Return the boxes in xywh format.</p>"},{"location":"reference/engine/results/#ultralytics.engine.results.Boxes.xywhn","title":"<code>xywhn</code>  <code>cached</code> <code>property</code>","text":"<p>Return the boxes in xywh format normalized by original image size.</p>"},{"location":"reference/engine/results/#ultralytics.engine.results.Boxes.xyxy","title":"<code>xyxy</code>  <code>property</code>","text":"<p>Return the boxes in xyxy format.</p>"},{"location":"reference/engine/results/#ultralytics.engine.results.Boxes.xyxyn","title":"<code>xyxyn</code>  <code>cached</code> <code>property</code>","text":"<p>Return the boxes in xyxy format normalized by original image size.</p>"},{"location":"reference/engine/results/#ultralytics.engine.results.Boxes.__init__","title":"<code>__init__(boxes, orig_shape)</code>","text":"<p>Initialize the Boxes class.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>def __init__(self, boxes, orig_shape) -&gt; None:\n    \"\"\"Initialize the Boxes class.\"\"\"\n    if boxes.ndim == 1:\n        boxes = boxes[None, :]\n    n = boxes.shape[-1]\n    assert n in (6, 7), f\"expected 6 or 7 values but got {n}\"  # xyxy, track_id, conf, cls\n    super().__init__(boxes, orig_shape)\n    self.is_track = n == 7\n    self.orig_shape = orig_shape\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.Masks","title":"<code>ultralytics.engine.results.Masks</code>","text":"<p>             Bases: <code>BaseTensor</code></p> <p>A class for storing and manipulating detection masks.</p> <p>Attributes:</p> Name Type Description <code>xy</code> <code>list</code> <p>A list of segments in pixel coordinates.</p> <code>xyn</code> <code>list</code> <p>A list of normalized segments.</p> <p>Methods:</p> Name Description <code>cpu</code> <p>Returns the masks tensor on CPU memory.</p> <code>numpy</code> <p>Returns the masks tensor as a numpy array.</p> <code>cuda</code> <p>Returns the masks tensor on GPU memory.</p> <code>to</code> <p>Returns the masks tensor with the specified device and dtype.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>class Masks(BaseTensor):\n    \"\"\"\n    A class for storing and manipulating detection masks.\n\n    Attributes:\n        xy (list): A list of segments in pixel coordinates.\n        xyn (list): A list of normalized segments.\n\n    Methods:\n        cpu(): Returns the masks tensor on CPU memory.\n        numpy(): Returns the masks tensor as a numpy array.\n        cuda(): Returns the masks tensor on GPU memory.\n        to(device, dtype): Returns the masks tensor with the specified device and dtype.\n    \"\"\"\n\n    def __init__(self, masks, orig_shape) -&gt; None:\n        \"\"\"Initialize the Masks class with the given masks tensor and original image shape.\"\"\"\n        if masks.ndim == 2:\n            masks = masks[None, :]\n        super().__init__(masks, orig_shape)\n\n    @property\n    @lru_cache(maxsize=1)\n    def xyn(self):\n        \"\"\"Return normalized segments.\"\"\"\n        return [\n            ops.scale_coords(self.data.shape[1:], x, self.orig_shape, normalize=True)\n            for x in ops.masks2segments(self.data)\n        ]\n\n    @property\n    @lru_cache(maxsize=1)\n    def xy(self):\n        \"\"\"Return segments in pixel coordinates.\"\"\"\n        return [\n            ops.scale_coords(self.data.shape[1:], x, self.orig_shape, normalize=False)\n            for x in ops.masks2segments(self.data)\n        ]\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.Masks.xy","title":"<code>xy</code>  <code>cached</code> <code>property</code>","text":"<p>Return segments in pixel coordinates.</p>"},{"location":"reference/engine/results/#ultralytics.engine.results.Masks.xyn","title":"<code>xyn</code>  <code>cached</code> <code>property</code>","text":"<p>Return normalized segments.</p>"},{"location":"reference/engine/results/#ultralytics.engine.results.Masks.__init__","title":"<code>__init__(masks, orig_shape)</code>","text":"<p>Initialize the Masks class with the given masks tensor and original image shape.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>def __init__(self, masks, orig_shape) -&gt; None:\n    \"\"\"Initialize the Masks class with the given masks tensor and original image shape.\"\"\"\n    if masks.ndim == 2:\n        masks = masks[None, :]\n    super().__init__(masks, orig_shape)\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.Keypoints","title":"<code>ultralytics.engine.results.Keypoints</code>","text":"<p>             Bases: <code>BaseTensor</code></p> <p>A class for storing and manipulating detection keypoints.</p> <p>Attributes:</p> Name Type Description <code>xy</code> <code>Tensor</code> <p>A collection of keypoints containing x, y coordinates for each detection.</p> <code>xyn</code> <code>Tensor</code> <p>A normalized version of xy with coordinates in the range [0, 1].</p> <code>conf</code> <code>Tensor</code> <p>Confidence values associated with keypoints if available, otherwise None.</p> <p>Methods:</p> Name Description <code>cpu</code> <p>Returns a copy of the keypoints tensor on CPU memory.</p> <code>numpy</code> <p>Returns a copy of the keypoints tensor as a numpy array.</p> <code>cuda</code> <p>Returns a copy of the keypoints tensor on GPU memory.</p> <code>to</code> <p>Returns a copy of the keypoints tensor with the specified device and dtype.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>class Keypoints(BaseTensor):\n    \"\"\"\n    A class for storing and manipulating detection keypoints.\n\n    Attributes:\n        xy (torch.Tensor): A collection of keypoints containing x, y coordinates for each detection.\n        xyn (torch.Tensor): A normalized version of xy with coordinates in the range [0, 1].\n        conf (torch.Tensor): Confidence values associated with keypoints if available, otherwise None.\n\n    Methods:\n        cpu(): Returns a copy of the keypoints tensor on CPU memory.\n        numpy(): Returns a copy of the keypoints tensor as a numpy array.\n        cuda(): Returns a copy of the keypoints tensor on GPU memory.\n        to(device, dtype): Returns a copy of the keypoints tensor with the specified device and dtype.\n    \"\"\"\n\n    @smart_inference_mode()  # avoid keypoints &lt; conf in-place error\n    def __init__(self, keypoints, orig_shape) -&gt; None:\n        \"\"\"Initializes the Keypoints object with detection keypoints and original image size.\"\"\"\n        if keypoints.ndim == 2:\n            keypoints = keypoints[None, :]\n        if keypoints.shape[2] == 3:  # x, y, conf\n            mask = keypoints[..., 2] &lt; 0.5  # points with conf &lt; 0.5 (not visible)\n            keypoints[..., :2][mask] = 0\n        super().__init__(keypoints, orig_shape)\n        self.has_visible = self.data.shape[-1] == 3\n\n    @property\n    @lru_cache(maxsize=1)\n    def xy(self):\n        \"\"\"Returns x, y coordinates of keypoints.\"\"\"\n        return self.data[..., :2]\n\n    @property\n    @lru_cache(maxsize=1)\n    def xyn(self):\n        \"\"\"Returns normalized x, y coordinates of keypoints.\"\"\"\n        xy = self.xy.clone() if isinstance(self.xy, torch.Tensor) else np.copy(self.xy)\n        xy[..., 0] /= self.orig_shape[1]\n        xy[..., 1] /= self.orig_shape[0]\n        return xy\n\n    @property\n    @lru_cache(maxsize=1)\n    def conf(self):\n        \"\"\"Returns confidence values of keypoints if available, else None.\"\"\"\n        return self.data[..., 2] if self.has_visible else None\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.Keypoints.conf","title":"<code>conf</code>  <code>cached</code> <code>property</code>","text":"<p>Returns confidence values of keypoints if available, else None.</p>"},{"location":"reference/engine/results/#ultralytics.engine.results.Keypoints.xy","title":"<code>xy</code>  <code>cached</code> <code>property</code>","text":"<p>Returns x, y coordinates of keypoints.</p>"},{"location":"reference/engine/results/#ultralytics.engine.results.Keypoints.xyn","title":"<code>xyn</code>  <code>cached</code> <code>property</code>","text":"<p>Returns normalized x, y coordinates of keypoints.</p>"},{"location":"reference/engine/results/#ultralytics.engine.results.Keypoints.__init__","title":"<code>__init__(keypoints, orig_shape)</code>","text":"<p>Initializes the Keypoints object with detection keypoints and original image size.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>@smart_inference_mode()  # avoid keypoints &lt; conf in-place error\ndef __init__(self, keypoints, orig_shape) -&gt; None:\n    \"\"\"Initializes the Keypoints object with detection keypoints and original image size.\"\"\"\n    if keypoints.ndim == 2:\n        keypoints = keypoints[None, :]\n    if keypoints.shape[2] == 3:  # x, y, conf\n        mask = keypoints[..., 2] &lt; 0.5  # points with conf &lt; 0.5 (not visible)\n        keypoints[..., :2][mask] = 0\n    super().__init__(keypoints, orig_shape)\n    self.has_visible = self.data.shape[-1] == 3\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.Probs","title":"<code>ultralytics.engine.results.Probs</code>","text":"<p>             Bases: <code>BaseTensor</code></p> <p>A class for storing and manipulating classification predictions.</p> <p>Attributes:</p> Name Type Description <code>top1</code> <code>int</code> <p>Index of the top 1 class.</p> <code>top5</code> <code>list[int]</code> <p>Indices of the top 5 classes.</p> <code>top1conf</code> <code>Tensor</code> <p>Confidence of the top 1 class.</p> <code>top5conf</code> <code>Tensor</code> <p>Confidences of the top 5 classes.</p> <p>Methods:</p> Name Description <code>cpu</code> <p>Returns a copy of the probs tensor on CPU memory.</p> <code>numpy</code> <p>Returns a copy of the probs tensor as a numpy array.</p> <code>cuda</code> <p>Returns a copy of the probs tensor on GPU memory.</p> <code>to</code> <p>Returns a copy of the probs tensor with the specified device and dtype.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>class Probs(BaseTensor):\n    \"\"\"\n    A class for storing and manipulating classification predictions.\n\n    Attributes:\n        top1 (int): Index of the top 1 class.\n        top5 (list[int]): Indices of the top 5 classes.\n        top1conf (torch.Tensor): Confidence of the top 1 class.\n        top5conf (torch.Tensor): Confidences of the top 5 classes.\n\n    Methods:\n        cpu(): Returns a copy of the probs tensor on CPU memory.\n        numpy(): Returns a copy of the probs tensor as a numpy array.\n        cuda(): Returns a copy of the probs tensor on GPU memory.\n        to(): Returns a copy of the probs tensor with the specified device and dtype.\n    \"\"\"\n\n    def __init__(self, probs, orig_shape=None) -&gt; None:\n        \"\"\"Initialize the Probs class with classification probabilities and optional original shape of the image.\"\"\"\n        super().__init__(probs, orig_shape)\n\n    @property\n    @lru_cache(maxsize=1)\n    def top1(self):\n        \"\"\"Return the index of top 1.\"\"\"\n        return int(self.data.argmax())\n\n    @property\n    @lru_cache(maxsize=1)\n    def top5(self):\n        \"\"\"Return the indices of top 5.\"\"\"\n        return (-self.data).argsort(0)[:5].tolist()  # this way works with both torch and numpy.\n\n    @property\n    @lru_cache(maxsize=1)\n    def top1conf(self):\n        \"\"\"Return the confidence of top 1.\"\"\"\n        return self.data[self.top1]\n\n    @property\n    @lru_cache(maxsize=1)\n    def top5conf(self):\n        \"\"\"Return the confidences of top 5.\"\"\"\n        return self.data[self.top5]\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.Probs.top1","title":"<code>top1</code>  <code>cached</code> <code>property</code>","text":"<p>Return the index of top 1.</p>"},{"location":"reference/engine/results/#ultralytics.engine.results.Probs.top1conf","title":"<code>top1conf</code>  <code>cached</code> <code>property</code>","text":"<p>Return the confidence of top 1.</p>"},{"location":"reference/engine/results/#ultralytics.engine.results.Probs.top5","title":"<code>top5</code>  <code>cached</code> <code>property</code>","text":"<p>Return the indices of top 5.</p>"},{"location":"reference/engine/results/#ultralytics.engine.results.Probs.top5conf","title":"<code>top5conf</code>  <code>cached</code> <code>property</code>","text":"<p>Return the confidences of top 5.</p>"},{"location":"reference/engine/results/#ultralytics.engine.results.Probs.__init__","title":"<code>__init__(probs, orig_shape=None)</code>","text":"<p>Initialize the Probs class with classification probabilities and optional original shape of the image.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>def __init__(self, probs, orig_shape=None) -&gt; None:\n    \"\"\"Initialize the Probs class with classification probabilities and optional original shape of the image.\"\"\"\n    super().__init__(probs, orig_shape)\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.OBB","title":"<code>ultralytics.engine.results.OBB</code>","text":"<p>             Bases: <code>BaseTensor</code></p> <p>A class for storing and manipulating Oriented Bounding Boxes (OBB).</p> <p>Parameters:</p> Name Type Description Default <code>boxes</code> <code>Tensor | ndarray</code> <p>A tensor or numpy array containing the detection boxes, with shape (num_boxes, 7) or (num_boxes, 8). The last two columns contain confidence and class values. If present, the third last column contains track IDs, and the fifth column from the left contains rotation.</p> required <code>orig_shape</code> <code>tuple</code> <p>Original image size, in the format (height, width).</p> required <p>Attributes:</p> Name Type Description <code>xywhr</code> <code>Tensor | ndarray</code> <p>The boxes in [x_center, y_center, width, height, rotation] format.</p> <code>conf</code> <code>Tensor | ndarray</code> <p>The confidence values of the boxes.</p> <code>cls</code> <code>Tensor | ndarray</code> <p>The class values of the boxes.</p> <code>id</code> <code>Tensor | ndarray</code> <p>The track IDs of the boxes (if available).</p> <code>xyxyxyxy</code> <code>Tensor | ndarray</code> <p>The boxes in xyxyxyxy format normalized by original image size.</p> <code>data</code> <code>Tensor</code> <p>The raw OBB tensor (alias for <code>boxes</code>).</p> <p>Methods:</p> Name Description <code>cpu</code> <p>Move the object to CPU memory.</p> <code>numpy</code> <p>Convert the object to a numpy array.</p> <code>cuda</code> <p>Move the object to CUDA memory.</p> <code>to</code> <p>Move the object to the specified device.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>class OBB(BaseTensor):\n    \"\"\"\n    A class for storing and manipulating Oriented Bounding Boxes (OBB).\n\n    Args:\n        boxes (torch.Tensor | numpy.ndarray): A tensor or numpy array containing the detection boxes,\n            with shape (num_boxes, 7) or (num_boxes, 8). The last two columns contain confidence and class values.\n            If present, the third last column contains track IDs, and the fifth column from the left contains rotation.\n        orig_shape (tuple): Original image size, in the format (height, width).\n\n    Attributes:\n        xywhr (torch.Tensor | numpy.ndarray): The boxes in [x_center, y_center, width, height, rotation] format.\n        conf (torch.Tensor | numpy.ndarray): The confidence values of the boxes.\n        cls (torch.Tensor | numpy.ndarray): The class values of the boxes.\n        id (torch.Tensor | numpy.ndarray): The track IDs of the boxes (if available).\n        xyxyxyxy (torch.Tensor | numpy.ndarray): The boxes in xyxyxyxy format normalized by original image size.\n        data (torch.Tensor): The raw OBB tensor (alias for `boxes`).\n\n    Methods:\n        cpu(): Move the object to CPU memory.\n        numpy(): Convert the object to a numpy array.\n        cuda(): Move the object to CUDA memory.\n        to(*args, **kwargs): Move the object to the specified device.\n    \"\"\"\n\n    def __init__(self, boxes, orig_shape) -&gt; None:\n        \"\"\"Initialize the Boxes class.\"\"\"\n        if boxes.ndim == 1:\n            boxes = boxes[None, :]\n        n = boxes.shape[-1]\n        assert n in (7, 8), f\"expected 7 or 8 values but got {n}\"  # xywh, rotation, track_id, conf, cls\n        super().__init__(boxes, orig_shape)\n        self.is_track = n == 8\n        self.orig_shape = orig_shape\n\n    @property\n    def xywhr(self):\n        \"\"\"Return the rotated boxes in xywhr format.\"\"\"\n        return self.data[:, :5]\n\n    @property\n    def conf(self):\n        \"\"\"Return the confidence values of the boxes.\"\"\"\n        return self.data[:, -2]\n\n    @property\n    def cls(self):\n        \"\"\"Return the class values of the boxes.\"\"\"\n        return self.data[:, -1]\n\n    @property\n    def id(self):\n        \"\"\"Return the track IDs of the boxes (if available).\"\"\"\n        return self.data[:, -3] if self.is_track else None\n\n    @property\n    @lru_cache(maxsize=2)\n    def xyxyxyxy(self):\n        \"\"\"Return the boxes in xyxyxyxy format, (N, 4, 2).\"\"\"\n        return ops.xywhr2xyxyxyxy(self.xywhr)\n\n    @property\n    @lru_cache(maxsize=2)\n    def xyxyxyxyn(self):\n        \"\"\"Return the boxes in xyxyxyxy format, (N, 4, 2).\"\"\"\n        xyxyxyxyn = self.xyxyxyxy.clone() if isinstance(self.xyxyxyxy, torch.Tensor) else np.copy(self.xyxyxyxy)\n        xyxyxyxyn[..., 0] /= self.orig_shape[1]\n        xyxyxyxyn[..., 1] /= self.orig_shape[1]\n        return xyxyxyxyn\n\n    @property\n    @lru_cache(maxsize=2)\n    def xyxy(self):\n        \"\"\"Return the horizontal boxes in xyxy format, (N, 4).\"\"\"\n        # This way to fit both torch and numpy version\n        x1 = self.xyxyxyxy[..., 0].min(1).values\n        x2 = self.xyxyxyxy[..., 0].max(1).values\n        y1 = self.xyxyxyxy[..., 1].min(1).values\n        y2 = self.xyxyxyxy[..., 1].max(1).values\n        xyxy = [x1, y1, x2, y2]\n        return np.stack(xyxy, axis=-1) if isinstance(self.data, np.ndarray) else torch.stack(xyxy, dim=-1)\n</code></pre>"},{"location":"reference/engine/results/#ultralytics.engine.results.OBB.cls","title":"<code>cls</code>  <code>property</code>","text":"<p>Return the class values of the boxes.</p>"},{"location":"reference/engine/results/#ultralytics.engine.results.OBB.conf","title":"<code>conf</code>  <code>property</code>","text":"<p>Return the confidence values of the boxes.</p>"},{"location":"reference/engine/results/#ultralytics.engine.results.OBB.id","title":"<code>id</code>  <code>property</code>","text":"<p>Return the track IDs of the boxes (if available).</p>"},{"location":"reference/engine/results/#ultralytics.engine.results.OBB.xywhr","title":"<code>xywhr</code>  <code>property</code>","text":"<p>Return the rotated boxes in xywhr format.</p>"},{"location":"reference/engine/results/#ultralytics.engine.results.OBB.xyxy","title":"<code>xyxy</code>  <code>cached</code> <code>property</code>","text":"<p>Return the horizontal boxes in xyxy format, (N, 4).</p>"},{"location":"reference/engine/results/#ultralytics.engine.results.OBB.xyxyxyxy","title":"<code>xyxyxyxy</code>  <code>cached</code> <code>property</code>","text":"<p>Return the boxes in xyxyxyxy format, (N, 4, 2).</p>"},{"location":"reference/engine/results/#ultralytics.engine.results.OBB.xyxyxyxyn","title":"<code>xyxyxyxyn</code>  <code>cached</code> <code>property</code>","text":"<p>Return the boxes in xyxyxyxy format, (N, 4, 2).</p>"},{"location":"reference/engine/results/#ultralytics.engine.results.OBB.__init__","title":"<code>__init__(boxes, orig_shape)</code>","text":"<p>Initialize the Boxes class.</p> Source code in <code>ultralytics/engine/results.py</code> <pre><code>def __init__(self, boxes, orig_shape) -&gt; None:\n    \"\"\"Initialize the Boxes class.\"\"\"\n    if boxes.ndim == 1:\n        boxes = boxes[None, :]\n    n = boxes.shape[-1]\n    assert n in (7, 8), f\"expected 7 or 8 values but got {n}\"  # xywh, rotation, track_id, conf, cls\n    super().__init__(boxes, orig_shape)\n    self.is_track = n == 8\n    self.orig_shape = orig_shape\n</code></pre>"},{"location":"reference/engine/trainer/","title":"Reference for <code>ultralytics/engine/trainer.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/engine/trainer.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer","title":"<code>ultralytics.engine.trainer.BaseTrainer</code>","text":"<p>BaseTrainer.</p> <p>A base class for creating trainers.</p> <p>Attributes:</p> Name Type Description <code>args</code> <code>SimpleNamespace</code> <p>Configuration for the trainer.</p> <code>validator</code> <code>BaseValidator</code> <p>Validator instance.</p> <code>model</code> <code>Module</code> <p>Model instance.</p> <code>callbacks</code> <code>defaultdict</code> <p>Dictionary of callbacks.</p> <code>save_dir</code> <code>Path</code> <p>Directory to save results.</p> <code>wdir</code> <code>Path</code> <p>Directory to save weights.</p> <code>last</code> <code>Path</code> <p>Path to the last checkpoint.</p> <code>best</code> <code>Path</code> <p>Path to the best checkpoint.</p> <code>save_period</code> <code>int</code> <p>Save checkpoint every x epochs (disabled if &lt; 1).</p> <code>batch_size</code> <code>int</code> <p>Batch size for training.</p> <code>epochs</code> <code>int</code> <p>Number of epochs to train for.</p> <code>start_epoch</code> <code>int</code> <p>Starting epoch for training.</p> <code>device</code> <code>device</code> <p>Device to use for training.</p> <code>amp</code> <code>bool</code> <p>Flag to enable AMP (Automatic Mixed Precision).</p> <code>scaler</code> <code>GradScaler</code> <p>Gradient scaler for AMP.</p> <code>data</code> <code>str</code> <p>Path to data.</p> <code>trainset</code> <code>Dataset</code> <p>Training dataset.</p> <code>testset</code> <code>Dataset</code> <p>Testing dataset.</p> <code>ema</code> <code>Module</code> <p>EMA (Exponential Moving Average) of the model.</p> <code>resume</code> <code>bool</code> <p>Resume training from a checkpoint.</p> <code>lf</code> <code>Module</code> <p>Loss function.</p> <code>scheduler</code> <code>_LRScheduler</code> <p>Learning rate scheduler.</p> <code>best_fitness</code> <code>float</code> <p>The best fitness value achieved.</p> <code>fitness</code> <code>float</code> <p>Current fitness value.</p> <code>loss</code> <code>float</code> <p>Current loss value.</p> <code>tloss</code> <code>float</code> <p>Total loss value.</p> <code>loss_names</code> <code>list</code> <p>List of loss names.</p> <code>csv</code> <code>Path</code> <p>Path to results CSV file.</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>class BaseTrainer:\n    \"\"\"\n    BaseTrainer.\n\n    A base class for creating trainers.\n\n    Attributes:\n        args (SimpleNamespace): Configuration for the trainer.\n        validator (BaseValidator): Validator instance.\n        model (nn.Module): Model instance.\n        callbacks (defaultdict): Dictionary of callbacks.\n        save_dir (Path): Directory to save results.\n        wdir (Path): Directory to save weights.\n        last (Path): Path to the last checkpoint.\n        best (Path): Path to the best checkpoint.\n        save_period (int): Save checkpoint every x epochs (disabled if &lt; 1).\n        batch_size (int): Batch size for training.\n        epochs (int): Number of epochs to train for.\n        start_epoch (int): Starting epoch for training.\n        device (torch.device): Device to use for training.\n        amp (bool): Flag to enable AMP (Automatic Mixed Precision).\n        scaler (amp.GradScaler): Gradient scaler for AMP.\n        data (str): Path to data.\n        trainset (torch.utils.data.Dataset): Training dataset.\n        testset (torch.utils.data.Dataset): Testing dataset.\n        ema (nn.Module): EMA (Exponential Moving Average) of the model.\n        resume (bool): Resume training from a checkpoint.\n        lf (nn.Module): Loss function.\n        scheduler (torch.optim.lr_scheduler._LRScheduler): Learning rate scheduler.\n        best_fitness (float): The best fitness value achieved.\n        fitness (float): Current fitness value.\n        loss (float): Current loss value.\n        tloss (float): Total loss value.\n        loss_names (list): List of loss names.\n        csv (Path): Path to results CSV file.\n    \"\"\"\n\n    def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n        \"\"\"\n        Initializes the BaseTrainer class.\n\n        Args:\n            cfg (str, optional): Path to a configuration file. Defaults to DEFAULT_CFG.\n            overrides (dict, optional): Configuration overrides. Defaults to None.\n        \"\"\"\n        self.args = get_cfg(cfg, overrides)\n        self.check_resume(overrides)\n        self.device = select_device(self.args.device, self.args.batch)\n        self.validator = None\n        self.metrics = None\n        self.plots = {}\n        init_seeds(self.args.seed + 1 + RANK, deterministic=self.args.deterministic)\n\n        # Dirs\n        self.save_dir = get_save_dir(self.args)\n        self.args.name = self.save_dir.name  # update name for loggers\n        self.wdir = self.save_dir / \"weights\"  # weights dir\n        if RANK in (-1, 0):\n            self.wdir.mkdir(parents=True, exist_ok=True)  # make dir\n            self.args.save_dir = str(self.save_dir)\n            yaml_save(self.save_dir / \"args.yaml\", vars(self.args))  # save run args\n        self.last, self.best = self.wdir / \"last.pt\", self.wdir / \"best.pt\"  # checkpoint paths\n        self.save_period = self.args.save_period\n\n        self.batch_size = self.args.batch\n        self.epochs = self.args.epochs\n        self.start_epoch = 0\n        if RANK == -1:\n            print_args(vars(self.args))\n\n        # Device\n        if self.device.type in (\"cpu\", \"mps\"):\n            self.args.workers = 0  # faster CPU training as time dominated by inference, not dataloading\n\n        # Model and Dataset\n        self.model = check_model_file_from_stem(self.args.model)  # add suffix, i.e. yolov8n -&gt; yolov8n.pt\n        try:\n            if self.args.task == \"classify\":\n                self.data = check_cls_dataset(self.args.data)\n            elif self.args.data.split(\".\")[-1] in (\"yaml\", \"yml\") or self.args.task in (\"detect\", \"segment\", \"pose\"):\n                self.data = check_det_dataset(self.args.data)\n                if \"yaml_file\" in self.data:\n                    self.args.data = self.data[\"yaml_file\"]  # for validating 'yolo train data=url.zip' usage\n        except Exception as e:\n            raise RuntimeError(emojis(f\"Dataset '{clean_url(self.args.data)}' error \u274c {e}\")) from e\n\n        self.trainset, self.testset = self.get_dataset(self.data)\n        self.ema = None\n\n        # Optimization utils init\n        self.lf = None\n        self.scheduler = None\n\n        # Epoch level metrics\n        self.best_fitness = None\n        self.fitness = None\n        self.loss = None\n        self.tloss = None\n        self.loss_names = [\"Loss\"]\n        self.csv = self.save_dir / \"results.csv\"\n        self.plot_idx = [0, 1, 2]\n\n        # Callbacks\n        self.callbacks = _callbacks or callbacks.get_default_callbacks()\n        if RANK in (-1, 0):\n            callbacks.add_integration_callbacks(self)\n\n    def add_callback(self, event: str, callback):\n        \"\"\"Appends the given callback.\"\"\"\n        self.callbacks[event].append(callback)\n\n    def set_callback(self, event: str, callback):\n        \"\"\"Overrides the existing callbacks with the given callback.\"\"\"\n        self.callbacks[event] = [callback]\n\n    def run_callbacks(self, event: str):\n        \"\"\"Run all existing callbacks associated with a particular event.\"\"\"\n        for callback in self.callbacks.get(event, []):\n            callback(self)\n\n    def train(self):\n        \"\"\"Allow device='', device=None on Multi-GPU systems to default to device=0.\"\"\"\n        if isinstance(self.args.device, str) and len(self.args.device):  # i.e. device='0' or device='0,1,2,3'\n            world_size = len(self.args.device.split(\",\"))\n        elif isinstance(self.args.device, (tuple, list)):  # i.e. device=[0, 1, 2, 3] (multi-GPU from CLI is list)\n            world_size = len(self.args.device)\n        elif torch.cuda.is_available():  # i.e. device=None or device='' or device=number\n            world_size = 1  # default to device 0\n        else:  # i.e. device='cpu' or 'mps'\n            world_size = 0\n\n        # Run subprocess if DDP training, else train normally\n        if world_size &gt; 1 and \"LOCAL_RANK\" not in os.environ:\n            # Argument checks\n            if self.args.rect:\n                LOGGER.warning(\"WARNING \u26a0\ufe0f 'rect=True' is incompatible with Multi-GPU training, setting 'rect=False'\")\n                self.args.rect = False\n            if self.args.batch == -1:\n                LOGGER.warning(\n                    \"WARNING \u26a0\ufe0f 'batch=-1' for AutoBatch is incompatible with Multi-GPU training, setting \"\n                    \"default 'batch=16'\"\n                )\n                self.args.batch = 16\n\n            # Command\n            cmd, file = generate_ddp_command(world_size, self)\n            try:\n                LOGGER.info(f'{colorstr(\"DDP:\")} debug command {\" \".join(cmd)}')\n                subprocess.run(cmd, check=True)\n            except Exception as e:\n                raise e\n            finally:\n                ddp_cleanup(self, str(file))\n\n        else:\n            self._do_train(world_size)\n\n    def _setup_scheduler(self):\n        \"\"\"Initialize training learning rate scheduler.\"\"\"\n        if self.args.cos_lr:\n            self.lf = one_cycle(1, self.args.lrf, self.epochs)  # cosine 1-&gt;hyp['lrf']\n        else:\n            self.lf = lambda x: max(1 - x / self.epochs, 0) * (1.0 - self.args.lrf) + self.args.lrf  # linear\n        self.scheduler = optim.lr_scheduler.LambdaLR(self.optimizer, lr_lambda=self.lf)\n\n    def _setup_ddp(self, world_size):\n        \"\"\"Initializes and sets the DistributedDataParallel parameters for training.\"\"\"\n        torch.cuda.set_device(RANK)\n        self.device = torch.device(\"cuda\", RANK)\n        # LOGGER.info(f'DDP info: RANK {RANK}, WORLD_SIZE {world_size}, DEVICE {self.device}')\n        os.environ[\"NCCL_BLOCKING_WAIT\"] = \"1\"  # set to enforce timeout\n        dist.init_process_group(\n            \"nccl\" if dist.is_nccl_available() else \"gloo\",\n            timeout=timedelta(seconds=10800),  # 3 hours\n            rank=RANK,\n            world_size=world_size,\n        )\n\n    def _setup_train(self, world_size):\n        \"\"\"Builds dataloaders and optimizer on correct rank process.\"\"\"\n\n        # Model\n        self.run_callbacks(\"on_pretrain_routine_start\")\n        ckpt = self.setup_model()\n        self.model = self.model.to(self.device)\n        self.set_model_attributes()\n\n        # Freeze layers\n        freeze_list = (\n            self.args.freeze\n            if isinstance(self.args.freeze, list)\n            else range(self.args.freeze)\n            if isinstance(self.args.freeze, int)\n            else []\n        )\n        always_freeze_names = [\".dfl\"]  # always freeze these layers\n        freeze_layer_names = [f\"model.{x}.\" for x in freeze_list] + always_freeze_names\n        for k, v in self.model.named_parameters():\n            # v.register_hook(lambda x: torch.nan_to_num(x))  # NaN to 0 (commented for erratic training results)\n            if any(x in k for x in freeze_layer_names):\n                LOGGER.info(f\"Freezing layer '{k}'\")\n                v.requires_grad = False\n            elif not v.requires_grad:\n                LOGGER.info(\n                    f\"WARNING \u26a0\ufe0f setting 'requires_grad=True' for frozen layer '{k}'. \"\n                    \"See ultralytics.engine.trainer for customization of frozen layers.\"\n                )\n                v.requires_grad = True\n\n        # Check AMP\n        self.amp = torch.tensor(self.args.amp).to(self.device)  # True or False\n        if self.amp and RANK in (-1, 0):  # Single-GPU and DDP\n            callbacks_backup = callbacks.default_callbacks.copy()  # backup callbacks as check_amp() resets them\n            self.amp = torch.tensor(check_amp(self.model), device=self.device)\n            callbacks.default_callbacks = callbacks_backup  # restore callbacks\n        if RANK &gt; -1 and world_size &gt; 1:  # DDP\n            dist.broadcast(self.amp, src=0)  # broadcast the tensor from rank 0 to all other ranks (returns None)\n        self.amp = bool(self.amp)  # as boolean\n        self.scaler = torch.cuda.amp.GradScaler(enabled=self.amp)\n        if world_size &gt; 1:\n            self.model = nn.parallel.DistributedDataParallel(self.model, device_ids=[RANK])\n\n        # Check imgsz\n        gs = max(int(self.model.stride.max() if hasattr(self.model, \"stride\") else 32), 32)  # grid size (max stride)\n        self.args.imgsz = check_imgsz(self.args.imgsz, stride=gs, floor=gs, max_dim=1)\n        self.stride = gs  # for multi-scale training\n\n        # Batch size\n        if self.batch_size == -1 and RANK == -1:  # single-GPU only, estimate best batch size\n            self.args.batch = self.batch_size = check_train_batch_size(self.model, self.args.imgsz, self.amp)\n\n        # Dataloaders\n        batch_size = self.batch_size // max(world_size, 1)\n        self.train_loader = self.get_dataloader(self.trainset, batch_size=batch_size, rank=RANK, mode=\"train\")\n        if RANK in (-1, 0):\n            # NOTE: When training DOTA dataset, double batch size could get OOM cause some images got more than 2000 objects.\n            self.test_loader = self.get_dataloader(\n                self.testset, batch_size=batch_size if self.args.task == \"obb\" else batch_size * 2, rank=-1, mode=\"val\"\n            )\n            self.validator = self.get_validator()\n            metric_keys = self.validator.metrics.keys + self.label_loss_items(prefix=\"val\")\n            self.metrics = dict(zip(metric_keys, [0] * len(metric_keys)))\n            self.ema = ModelEMA(self.model)\n            if self.args.plots:\n                self.plot_training_labels()\n\n        # Optimizer\n        self.accumulate = max(round(self.args.nbs / self.batch_size), 1)  # accumulate loss before optimizing\n        weight_decay = self.args.weight_decay * self.batch_size * self.accumulate / self.args.nbs  # scale weight_decay\n        iterations = math.ceil(len(self.train_loader.dataset) / max(self.batch_size, self.args.nbs)) * self.epochs\n        self.optimizer = self.build_optimizer(\n            model=self.model,\n            name=self.args.optimizer,\n            lr=self.args.lr0,\n            momentum=self.args.momentum,\n            decay=weight_decay,\n            iterations=iterations,\n        )\n        # Scheduler\n        self._setup_scheduler()\n        self.stopper, self.stop = EarlyStopping(patience=self.args.patience), False\n        self.resume_training(ckpt)\n        self.scheduler.last_epoch = self.start_epoch - 1  # do not move\n        self.run_callbacks(\"on_pretrain_routine_end\")\n\n    def _do_train(self, world_size=1):\n        \"\"\"Train completed, evaluate and plot if specified by arguments.\"\"\"\n        if world_size &gt; 1:\n            self._setup_ddp(world_size)\n        self._setup_train(world_size)\n\n        nb = len(self.train_loader)  # number of batches\n        nw = max(round(self.args.warmup_epochs * nb), 100) if self.args.warmup_epochs &gt; 0 else -1  # warmup iterations\n        last_opt_step = -1\n        self.epoch_time = None\n        self.epoch_time_start = time.time()\n        self.train_time_start = time.time()\n        self.run_callbacks(\"on_train_start\")\n        LOGGER.info(\n            f'Image sizes {self.args.imgsz} train, {self.args.imgsz} val\\n'\n            f'Using {self.train_loader.num_workers * (world_size or 1)} dataloader workers\\n'\n            f\"Logging results to {colorstr('bold', self.save_dir)}\\n\"\n            f'Starting training for '\n            f'{self.args.time} hours...'\n            if self.args.time\n            else f\"{self.epochs} epochs...\"\n        )\n        if self.args.close_mosaic:\n            base_idx = (self.epochs - self.args.close_mosaic) * nb\n            self.plot_idx.extend([base_idx, base_idx + 1, base_idx + 2])\n        epoch = self.epochs  # predefine for resume fully trained model edge cases\n        for epoch in range(self.start_epoch, self.epochs):\n            self.epoch = epoch\n            self.run_callbacks(\"on_train_epoch_start\")\n            self.model.train()\n            if RANK != -1:\n                self.train_loader.sampler.set_epoch(epoch)\n            pbar = enumerate(self.train_loader)\n            # Update dataloader attributes (optional)\n            if epoch == (self.epochs - self.args.close_mosaic):\n                self._close_dataloader_mosaic()\n                self.train_loader.reset()\n\n            if RANK in (-1, 0):\n                LOGGER.info(self.progress_string())\n                pbar = TQDM(enumerate(self.train_loader), total=nb)\n            self.tloss = None\n            self.optimizer.zero_grad()\n            for i, batch in pbar:\n                self.run_callbacks(\"on_train_batch_start\")\n                # Warmup\n                ni = i + nb * epoch\n                if ni &lt;= nw:\n                    xi = [0, nw]  # x interp\n                    self.accumulate = max(1, int(np.interp(ni, xi, [1, self.args.nbs / self.batch_size]).round()))\n                    for j, x in enumerate(self.optimizer.param_groups):\n                        # Bias lr falls from 0.1 to lr0, all other lrs rise from 0.0 to lr0\n                        x[\"lr\"] = np.interp(\n                            ni, xi, [self.args.warmup_bias_lr if j == 0 else 0.0, x[\"initial_lr\"] * self.lf(epoch)]\n                        )\n                        if \"momentum\" in x:\n                            x[\"momentum\"] = np.interp(ni, xi, [self.args.warmup_momentum, self.args.momentum])\n\n                # Forward\n                with torch.cuda.amp.autocast(self.amp):\n                    batch = self.preprocess_batch(batch)\n                    self.loss, self.loss_items = self.model(batch)\n                    if RANK != -1:\n                        self.loss *= world_size\n                    self.tloss = (\n                        (self.tloss * i + self.loss_items) / (i + 1) if self.tloss is not None else self.loss_items\n                    )\n\n                # Backward\n                self.scaler.scale(self.loss).backward()\n\n                # Optimize - https://pytorch.org/docs/master/notes/amp_examples.html\n                if ni - last_opt_step &gt;= self.accumulate:\n                    self.optimizer_step()\n                    last_opt_step = ni\n\n                    # Timed stopping\n                    if self.args.time:\n                        self.stop = (time.time() - self.train_time_start) &gt; (self.args.time * 3600)\n                        if RANK != -1:  # if DDP training\n                            broadcast_list = [self.stop if RANK == 0 else None]\n                            dist.broadcast_object_list(broadcast_list, 0)  # broadcast 'stop' to all ranks\n                            self.stop = broadcast_list[0]\n                        if self.stop:  # training time exceeded\n                            break\n\n                # Log\n                mem = f\"{torch.cuda.memory_reserved() / 1E9 if torch.cuda.is_available() else 0:.3g}G\"  # (GB)\n                loss_len = self.tloss.shape[0] if len(self.tloss.size()) else 1\n                losses = self.tloss if loss_len &gt; 1 else torch.unsqueeze(self.tloss, 0)\n                if RANK in (-1, 0):\n                    pbar.set_description(\n                        (\"%11s\" * 2 + \"%11.4g\" * (2 + loss_len))\n                        % (f\"{epoch + 1}/{self.epochs}\", mem, *losses, batch[\"cls\"].shape[0], batch[\"img\"].shape[-1])\n                    )\n                    self.run_callbacks(\"on_batch_end\")\n                    if self.args.plots and ni in self.plot_idx:\n                        self.plot_training_samples(batch, ni)\n\n                self.run_callbacks(\"on_train_batch_end\")\n\n            self.lr = {f\"lr/pg{ir}\": x[\"lr\"] for ir, x in enumerate(self.optimizer.param_groups)}  # for loggers\n            self.run_callbacks(\"on_train_epoch_end\")\n            if RANK in (-1, 0):\n                final_epoch = epoch + 1 == self.epochs\n                self.ema.update_attr(self.model, include=[\"yaml\", \"nc\", \"args\", \"names\", \"stride\", \"class_weights\"])\n\n                # Validation\n                if self.args.val or final_epoch or self.stopper.possible_stop or self.stop:\n                    self.metrics, self.fitness = self.validate()\n                self.save_metrics(metrics={**self.label_loss_items(self.tloss), **self.metrics, **self.lr})\n                self.stop |= self.stopper(epoch + 1, self.fitness)\n                if self.args.time:\n                    self.stop |= (time.time() - self.train_time_start) &gt; (self.args.time * 3600)\n\n                # Save model\n                if self.args.save or final_epoch:\n                    self.save_model()\n                    self.run_callbacks(\"on_model_save\")\n\n            # Scheduler\n            t = time.time()\n            self.epoch_time = t - self.epoch_time_start\n            self.epoch_time_start = t\n            with warnings.catch_warnings():\n                warnings.simplefilter(\"ignore\")  # suppress 'Detected lr_scheduler.step() before optimizer.step()'\n                if self.args.time:\n                    mean_epoch_time = (t - self.train_time_start) / (epoch - self.start_epoch + 1)\n                    self.epochs = self.args.epochs = math.ceil(self.args.time * 3600 / mean_epoch_time)\n                    self._setup_scheduler()\n                    self.scheduler.last_epoch = self.epoch  # do not move\n                    self.stop |= epoch &gt;= self.epochs  # stop if exceeded epochs\n                self.scheduler.step()\n            self.run_callbacks(\"on_fit_epoch_end\")\n            torch.cuda.empty_cache()  # clear GPU memory at end of epoch, may help reduce CUDA out of memory errors\n\n            # Early Stopping\n            if RANK != -1:  # if DDP training\n                broadcast_list = [self.stop if RANK == 0 else None]\n                dist.broadcast_object_list(broadcast_list, 0)  # broadcast 'stop' to all ranks\n                self.stop = broadcast_list[0]\n            if self.stop:\n                break  # must break all DDP ranks\n\n        if RANK in (-1, 0):\n            # Do final val with best.pt\n            LOGGER.info(\n                f\"\\n{epoch - self.start_epoch + 1} epochs completed in \"\n                f\"{(time.time() - self.train_time_start) / 3600:.3f} hours.\"\n            )\n            self.final_eval()\n            if self.args.plots:\n                self.plot_metrics()\n            self.run_callbacks(\"on_train_end\")\n        torch.cuda.empty_cache()\n        self.run_callbacks(\"teardown\")\n\n    def save_model(self):\n        \"\"\"Save model training checkpoints with additional metadata.\"\"\"\n        import pandas as pd  # scope for faster startup\n\n        metrics = {**self.metrics, **{\"fitness\": self.fitness}}\n        results = {k.strip(): v for k, v in pd.read_csv(self.csv).to_dict(orient=\"list\").items()}\n        ckpt = {\n            \"epoch\": self.epoch,\n            \"best_fitness\": self.best_fitness,\n            \"model\": deepcopy(de_parallel(self.model)).half(),\n            \"ema\": deepcopy(self.ema.ema).half(),\n            \"updates\": self.ema.updates,\n            \"optimizer\": self.optimizer.state_dict(),\n            \"train_args\": vars(self.args),  # save as dict\n            \"train_metrics\": metrics,\n            \"train_results\": results,\n            \"date\": datetime.now().isoformat(),\n            \"version\": __version__,\n        }\n\n        # Save last and best\n        torch.save(ckpt, self.last)\n        if self.best_fitness == self.fitness:\n            torch.save(ckpt, self.best)\n        if (self.save_period &gt; 0) and (self.epoch &gt; 0) and (self.epoch % self.save_period == 0):\n            torch.save(ckpt, self.wdir / f\"epoch{self.epoch}.pt\")\n\n    @staticmethod\n    def get_dataset(data):\n        \"\"\"\n        Get train, val path from data dict if it exists.\n\n        Returns None if data format is not recognized.\n        \"\"\"\n        return data[\"train\"], data.get(\"val\") or data.get(\"test\")\n\n    def setup_model(self):\n        \"\"\"Load/create/download model for any task.\"\"\"\n        if isinstance(self.model, torch.nn.Module):  # if model is loaded beforehand. No setup needed\n            return\n\n        model, weights = self.model, None\n        ckpt = None\n        if str(model).endswith(\".pt\"):\n            weights, ckpt = attempt_load_one_weight(model)\n            cfg = ckpt[\"model\"].yaml\n        else:\n            cfg = model\n        self.model = self.get_model(cfg=cfg, weights=weights, verbose=RANK == -1)  # calls Model(cfg, weights)\n        return ckpt\n\n    def optimizer_step(self):\n        \"\"\"Perform a single step of the training optimizer with gradient clipping and EMA update.\"\"\"\n        self.scaler.unscale_(self.optimizer)  # unscale gradients\n        torch.nn.utils.clip_grad_norm_(self.model.parameters(), max_norm=10.0)  # clip gradients\n        self.scaler.step(self.optimizer)\n        self.scaler.update()\n        self.optimizer.zero_grad()\n        if self.ema:\n            self.ema.update(self.model)\n\n    def preprocess_batch(self, batch):\n        \"\"\"Allows custom preprocessing model inputs and ground truths depending on task type.\"\"\"\n        return batch\n\n    def validate(self):\n        \"\"\"\n        Runs validation on test set using self.validator.\n\n        The returned dict is expected to contain \"fitness\" key.\n        \"\"\"\n        metrics = self.validator(self)\n        fitness = metrics.pop(\"fitness\", -self.loss.detach().cpu().numpy())  # use loss as fitness measure if not found\n        if not self.best_fitness or self.best_fitness &lt; fitness:\n            self.best_fitness = fitness\n        return metrics, fitness\n\n    def get_model(self, cfg=None, weights=None, verbose=True):\n        \"\"\"Get model and raise NotImplementedError for loading cfg files.\"\"\"\n        raise NotImplementedError(\"This task trainer doesn't support loading cfg files\")\n\n    def get_validator(self):\n        \"\"\"Returns a NotImplementedError when the get_validator function is called.\"\"\"\n        raise NotImplementedError(\"get_validator function not implemented in trainer\")\n\n    def get_dataloader(self, dataset_path, batch_size=16, rank=0, mode=\"train\"):\n        \"\"\"Returns dataloader derived from torch.data.Dataloader.\"\"\"\n        raise NotImplementedError(\"get_dataloader function not implemented in trainer\")\n\n    def build_dataset(self, img_path, mode=\"train\", batch=None):\n        \"\"\"Build dataset.\"\"\"\n        raise NotImplementedError(\"build_dataset function not implemented in trainer\")\n\n    def label_loss_items(self, loss_items=None, prefix=\"train\"):\n        \"\"\"Returns a loss dict with labelled training loss items tensor.\"\"\"\n        # Not needed for classification but necessary for segmentation &amp; detection\n        return {\"loss\": loss_items} if loss_items is not None else [\"loss\"]\n\n    def set_model_attributes(self):\n        \"\"\"To set or update model parameters before training.\"\"\"\n        self.model.names = self.data[\"names\"]\n\n    def build_targets(self, preds, targets):\n        \"\"\"Builds target tensors for training YOLO model.\"\"\"\n        pass\n\n    def progress_string(self):\n        \"\"\"Returns a string describing training progress.\"\"\"\n        return \"\"\n\n    # TODO: may need to put these following functions into callback\n    def plot_training_samples(self, batch, ni):\n        \"\"\"Plots training samples during YOLO training.\"\"\"\n        pass\n\n    def plot_training_labels(self):\n        \"\"\"Plots training labels for YOLO model.\"\"\"\n        pass\n\n    def save_metrics(self, metrics):\n        \"\"\"Saves training metrics to a CSV file.\"\"\"\n        keys, vals = list(metrics.keys()), list(metrics.values())\n        n = len(metrics) + 1  # number of cols\n        s = \"\" if self.csv.exists() else ((\"%23s,\" * n % tuple([\"epoch\"] + keys)).rstrip(\",\") + \"\\n\")  # header\n        with open(self.csv, \"a\") as f:\n            f.write(s + (\"%23.5g,\" * n % tuple([self.epoch + 1] + vals)).rstrip(\",\") + \"\\n\")\n\n    def plot_metrics(self):\n        \"\"\"Plot and display metrics visually.\"\"\"\n        pass\n\n    def on_plot(self, name, data=None):\n        \"\"\"Registers plots (e.g. to be consumed in callbacks)\"\"\"\n        path = Path(name)\n        self.plots[path] = {\"data\": data, \"timestamp\": time.time()}\n\n    def final_eval(self):\n        \"\"\"Performs final evaluation and validation for object detection YOLO model.\"\"\"\n        for f in self.last, self.best:\n            if f.exists():\n                strip_optimizer(f)  # strip optimizers\n                if f is self.best:\n                    LOGGER.info(f\"\\nValidating {f}...\")\n                    self.validator.args.plots = self.args.plots\n                    self.metrics = self.validator(model=f)\n                    self.metrics.pop(\"fitness\", None)\n                    self.run_callbacks(\"on_fit_epoch_end\")\n\n    def check_resume(self, overrides):\n        \"\"\"Check if resume checkpoint exists and update arguments accordingly.\"\"\"\n        resume = self.args.resume\n        if resume:\n            try:\n                exists = isinstance(resume, (str, Path)) and Path(resume).exists()\n                last = Path(check_file(resume) if exists else get_latest_run())\n\n                # Check that resume data YAML exists, otherwise strip to force re-download of dataset\n                ckpt_args = attempt_load_weights(last).args\n                if not Path(ckpt_args[\"data\"]).exists():\n                    ckpt_args[\"data\"] = self.args.data\n\n                resume = True\n                self.args = get_cfg(ckpt_args)\n                self.args.model = str(last)  # reinstate model\n                for k in \"imgsz\", \"batch\":  # allow arg updates to reduce memory on resume if crashed due to CUDA OOM\n                    if k in overrides:\n                        setattr(self.args, k, overrides[k])\n\n            except Exception as e:\n                raise FileNotFoundError(\n                    \"Resume checkpoint not found. Please pass a valid checkpoint to resume from, \"\n                    \"i.e. 'yolo train resume model=path/to/last.pt'\"\n                ) from e\n        self.resume = resume\n\n    def resume_training(self, ckpt):\n        \"\"\"Resume YOLO training from given epoch and best fitness.\"\"\"\n        if ckpt is None:\n            return\n        best_fitness = 0.0\n        start_epoch = ckpt[\"epoch\"] + 1\n        if ckpt[\"optimizer\"] is not None:\n            self.optimizer.load_state_dict(ckpt[\"optimizer\"])  # optimizer\n            best_fitness = ckpt[\"best_fitness\"]\n        if self.ema and ckpt.get(\"ema\"):\n            self.ema.ema.load_state_dict(ckpt[\"ema\"].float().state_dict())  # EMA\n            self.ema.updates = ckpt[\"updates\"]\n        if self.resume:\n            assert start_epoch &gt; 0, (\n                f\"{self.args.model} training to {self.epochs} epochs is finished, nothing to resume.\\n\"\n                f\"Start a new training without resuming, i.e. 'yolo train model={self.args.model}'\"\n            )\n            LOGGER.info(\n                f\"Resuming training from {self.args.model} from epoch {start_epoch + 1} to {self.epochs} total epochs\"\n            )\n        if self.epochs &lt; start_epoch:\n            LOGGER.info(\n                f\"{self.model} has been trained for {ckpt['epoch']} epochs. Fine-tuning for {self.epochs} more epochs.\"\n            )\n            self.epochs += ckpt[\"epoch\"]  # finetune additional epochs\n        self.best_fitness = best_fitness\n        self.start_epoch = start_epoch\n        if start_epoch &gt; (self.epochs - self.args.close_mosaic):\n            self._close_dataloader_mosaic()\n\n    def _close_dataloader_mosaic(self):\n        \"\"\"Update dataloaders to stop using mosaic augmentation.\"\"\"\n        if hasattr(self.train_loader.dataset, \"mosaic\"):\n            self.train_loader.dataset.mosaic = False\n        if hasattr(self.train_loader.dataset, \"close_mosaic\"):\n            LOGGER.info(\"Closing dataloader mosaic\")\n            self.train_loader.dataset.close_mosaic(hyp=self.args)\n\n    def build_optimizer(self, model, name=\"auto\", lr=0.001, momentum=0.9, decay=1e-5, iterations=1e5):\n        \"\"\"\n        Constructs an optimizer for the given model, based on the specified optimizer name, learning rate, momentum,\n        weight decay, and number of iterations.\n\n        Args:\n            model (torch.nn.Module): The model for which to build an optimizer.\n            name (str, optional): The name of the optimizer to use. If 'auto', the optimizer is selected\n                based on the number of iterations. Default: 'auto'.\n            lr (float, optional): The learning rate for the optimizer. Default: 0.001.\n            momentum (float, optional): The momentum factor for the optimizer. Default: 0.9.\n            decay (float, optional): The weight decay for the optimizer. Default: 1e-5.\n            iterations (float, optional): The number of iterations, which determines the optimizer if\n                name is 'auto'. Default: 1e5.\n\n        Returns:\n            (torch.optim.Optimizer): The constructed optimizer.\n        \"\"\"\n\n        g = [], [], []  # optimizer parameter groups\n        bn = tuple(v for k, v in nn.__dict__.items() if \"Norm\" in k)  # normalization layers, i.e. BatchNorm2d()\n        if name == \"auto\":\n            LOGGER.info(\n                f\"{colorstr('optimizer:')} 'optimizer=auto' found, \"\n                f\"ignoring 'lr0={self.args.lr0}' and 'momentum={self.args.momentum}' and \"\n                f\"determining best 'optimizer', 'lr0' and 'momentum' automatically... \"\n            )\n            nc = getattr(model, \"nc\", 10)  # number of classes\n            lr_fit = round(0.002 * 5 / (4 + nc), 6)  # lr0 fit equation to 6 decimal places\n            name, lr, momentum = (\"SGD\", 0.01, 0.9) if iterations &gt; 10000 else (\"AdamW\", lr_fit, 0.9)\n            self.args.warmup_bias_lr = 0.0  # no higher than 0.01 for Adam\n\n        for module_name, module in model.named_modules():\n            for param_name, param in module.named_parameters(recurse=False):\n                fullname = f\"{module_name}.{param_name}\" if module_name else param_name\n                if \"bias\" in fullname:  # bias (no decay)\n                    g[2].append(param)\n                elif isinstance(module, bn):  # weight (no decay)\n                    g[1].append(param)\n                else:  # weight (with decay)\n                    g[0].append(param)\n\n        if name in (\"Adam\", \"Adamax\", \"AdamW\", \"NAdam\", \"RAdam\"):\n            optimizer = getattr(optim, name, optim.Adam)(g[2], lr=lr, betas=(momentum, 0.999), weight_decay=0.0)\n        elif name == \"RMSProp\":\n            optimizer = optim.RMSprop(g[2], lr=lr, momentum=momentum)\n        elif name == \"SGD\":\n            optimizer = optim.SGD(g[2], lr=lr, momentum=momentum, nesterov=True)\n        else:\n            raise NotImplementedError(\n                f\"Optimizer '{name}' not found in list of available optimizers \"\n                f\"[Adam, AdamW, NAdam, RAdam, RMSProp, SGD, auto].\"\n                \"To request support for addition optimizers please visit https://github.com/ultralytics/ultralytics.\"\n            )\n\n        optimizer.add_param_group({\"params\": g[0], \"weight_decay\": decay})  # add g0 with weight_decay\n        optimizer.add_param_group({\"params\": g[1], \"weight_decay\": 0.0})  # add g1 (BatchNorm2d weights)\n        LOGGER.info(\n            f\"{colorstr('optimizer:')} {type(optimizer).__name__}(lr={lr}, momentum={momentum}) with parameter groups \"\n            f'{len(g[1])} weight(decay=0.0), {len(g[0])} weight(decay={decay}), {len(g[2])} bias(decay=0.0)'\n        )\n        return optimizer\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.__init__","title":"<code>__init__(cfg=DEFAULT_CFG, overrides=None, _callbacks=None)</code>","text":"<p>Initializes the BaseTrainer class.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>str</code> <p>Path to a configuration file. Defaults to DEFAULT_CFG.</p> <code>DEFAULT_CFG</code> <code>overrides</code> <code>dict</code> <p>Configuration overrides. Defaults to None.</p> <code>None</code> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n    \"\"\"\n    Initializes the BaseTrainer class.\n\n    Args:\n        cfg (str, optional): Path to a configuration file. Defaults to DEFAULT_CFG.\n        overrides (dict, optional): Configuration overrides. Defaults to None.\n    \"\"\"\n    self.args = get_cfg(cfg, overrides)\n    self.check_resume(overrides)\n    self.device = select_device(self.args.device, self.args.batch)\n    self.validator = None\n    self.metrics = None\n    self.plots = {}\n    init_seeds(self.args.seed + 1 + RANK, deterministic=self.args.deterministic)\n\n    # Dirs\n    self.save_dir = get_save_dir(self.args)\n    self.args.name = self.save_dir.name  # update name for loggers\n    self.wdir = self.save_dir / \"weights\"  # weights dir\n    if RANK in (-1, 0):\n        self.wdir.mkdir(parents=True, exist_ok=True)  # make dir\n        self.args.save_dir = str(self.save_dir)\n        yaml_save(self.save_dir / \"args.yaml\", vars(self.args))  # save run args\n    self.last, self.best = self.wdir / \"last.pt\", self.wdir / \"best.pt\"  # checkpoint paths\n    self.save_period = self.args.save_period\n\n    self.batch_size = self.args.batch\n    self.epochs = self.args.epochs\n    self.start_epoch = 0\n    if RANK == -1:\n        print_args(vars(self.args))\n\n    # Device\n    if self.device.type in (\"cpu\", \"mps\"):\n        self.args.workers = 0  # faster CPU training as time dominated by inference, not dataloading\n\n    # Model and Dataset\n    self.model = check_model_file_from_stem(self.args.model)  # add suffix, i.e. yolov8n -&gt; yolov8n.pt\n    try:\n        if self.args.task == \"classify\":\n            self.data = check_cls_dataset(self.args.data)\n        elif self.args.data.split(\".\")[-1] in (\"yaml\", \"yml\") or self.args.task in (\"detect\", \"segment\", \"pose\"):\n            self.data = check_det_dataset(self.args.data)\n            if \"yaml_file\" in self.data:\n                self.args.data = self.data[\"yaml_file\"]  # for validating 'yolo train data=url.zip' usage\n    except Exception as e:\n        raise RuntimeError(emojis(f\"Dataset '{clean_url(self.args.data)}' error \u274c {e}\")) from e\n\n    self.trainset, self.testset = self.get_dataset(self.data)\n    self.ema = None\n\n    # Optimization utils init\n    self.lf = None\n    self.scheduler = None\n\n    # Epoch level metrics\n    self.best_fitness = None\n    self.fitness = None\n    self.loss = None\n    self.tloss = None\n    self.loss_names = [\"Loss\"]\n    self.csv = self.save_dir / \"results.csv\"\n    self.plot_idx = [0, 1, 2]\n\n    # Callbacks\n    self.callbacks = _callbacks or callbacks.get_default_callbacks()\n    if RANK in (-1, 0):\n        callbacks.add_integration_callbacks(self)\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.add_callback","title":"<code>add_callback(event, callback)</code>","text":"<p>Appends the given callback.</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>def add_callback(self, event: str, callback):\n    \"\"\"Appends the given callback.\"\"\"\n    self.callbacks[event].append(callback)\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.build_dataset","title":"<code>build_dataset(img_path, mode='train', batch=None)</code>","text":"<p>Build dataset.</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>def build_dataset(self, img_path, mode=\"train\", batch=None):\n    \"\"\"Build dataset.\"\"\"\n    raise NotImplementedError(\"build_dataset function not implemented in trainer\")\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.build_optimizer","title":"<code>build_optimizer(model, name='auto', lr=0.001, momentum=0.9, decay=1e-05, iterations=100000.0)</code>","text":"<p>Constructs an optimizer for the given model, based on the specified optimizer name, learning rate, momentum, weight decay, and number of iterations.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Module</code> <p>The model for which to build an optimizer.</p> required <code>name</code> <code>str</code> <p>The name of the optimizer to use. If 'auto', the optimizer is selected based on the number of iterations. Default: 'auto'.</p> <code>'auto'</code> <code>lr</code> <code>float</code> <p>The learning rate for the optimizer. Default: 0.001.</p> <code>0.001</code> <code>momentum</code> <code>float</code> <p>The momentum factor for the optimizer. Default: 0.9.</p> <code>0.9</code> <code>decay</code> <code>float</code> <p>The weight decay for the optimizer. Default: 1e-5.</p> <code>1e-05</code> <code>iterations</code> <code>float</code> <p>The number of iterations, which determines the optimizer if name is 'auto'. Default: 1e5.</p> <code>100000.0</code> <p>Returns:</p> Type Description <code>Optimizer</code> <p>The constructed optimizer.</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>def build_optimizer(self, model, name=\"auto\", lr=0.001, momentum=0.9, decay=1e-5, iterations=1e5):\n    \"\"\"\n    Constructs an optimizer for the given model, based on the specified optimizer name, learning rate, momentum,\n    weight decay, and number of iterations.\n\n    Args:\n        model (torch.nn.Module): The model for which to build an optimizer.\n        name (str, optional): The name of the optimizer to use. If 'auto', the optimizer is selected\n            based on the number of iterations. Default: 'auto'.\n        lr (float, optional): The learning rate for the optimizer. Default: 0.001.\n        momentum (float, optional): The momentum factor for the optimizer. Default: 0.9.\n        decay (float, optional): The weight decay for the optimizer. Default: 1e-5.\n        iterations (float, optional): The number of iterations, which determines the optimizer if\n            name is 'auto'. Default: 1e5.\n\n    Returns:\n        (torch.optim.Optimizer): The constructed optimizer.\n    \"\"\"\n\n    g = [], [], []  # optimizer parameter groups\n    bn = tuple(v for k, v in nn.__dict__.items() if \"Norm\" in k)  # normalization layers, i.e. BatchNorm2d()\n    if name == \"auto\":\n        LOGGER.info(\n            f\"{colorstr('optimizer:')} 'optimizer=auto' found, \"\n            f\"ignoring 'lr0={self.args.lr0}' and 'momentum={self.args.momentum}' and \"\n            f\"determining best 'optimizer', 'lr0' and 'momentum' automatically... \"\n        )\n        nc = getattr(model, \"nc\", 10)  # number of classes\n        lr_fit = round(0.002 * 5 / (4 + nc), 6)  # lr0 fit equation to 6 decimal places\n        name, lr, momentum = (\"SGD\", 0.01, 0.9) if iterations &gt; 10000 else (\"AdamW\", lr_fit, 0.9)\n        self.args.warmup_bias_lr = 0.0  # no higher than 0.01 for Adam\n\n    for module_name, module in model.named_modules():\n        for param_name, param in module.named_parameters(recurse=False):\n            fullname = f\"{module_name}.{param_name}\" if module_name else param_name\n            if \"bias\" in fullname:  # bias (no decay)\n                g[2].append(param)\n            elif isinstance(module, bn):  # weight (no decay)\n                g[1].append(param)\n            else:  # weight (with decay)\n                g[0].append(param)\n\n    if name in (\"Adam\", \"Adamax\", \"AdamW\", \"NAdam\", \"RAdam\"):\n        optimizer = getattr(optim, name, optim.Adam)(g[2], lr=lr, betas=(momentum, 0.999), weight_decay=0.0)\n    elif name == \"RMSProp\":\n        optimizer = optim.RMSprop(g[2], lr=lr, momentum=momentum)\n    elif name == \"SGD\":\n        optimizer = optim.SGD(g[2], lr=lr, momentum=momentum, nesterov=True)\n    else:\n        raise NotImplementedError(\n            f\"Optimizer '{name}' not found in list of available optimizers \"\n            f\"[Adam, AdamW, NAdam, RAdam, RMSProp, SGD, auto].\"\n            \"To request support for addition optimizers please visit https://github.com/ultralytics/ultralytics.\"\n        )\n\n    optimizer.add_param_group({\"params\": g[0], \"weight_decay\": decay})  # add g0 with weight_decay\n    optimizer.add_param_group({\"params\": g[1], \"weight_decay\": 0.0})  # add g1 (BatchNorm2d weights)\n    LOGGER.info(\n        f\"{colorstr('optimizer:')} {type(optimizer).__name__}(lr={lr}, momentum={momentum}) with parameter groups \"\n        f'{len(g[1])} weight(decay=0.0), {len(g[0])} weight(decay={decay}), {len(g[2])} bias(decay=0.0)'\n    )\n    return optimizer\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.build_targets","title":"<code>build_targets(preds, targets)</code>","text":"<p>Builds target tensors for training YOLO model.</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>def build_targets(self, preds, targets):\n    \"\"\"Builds target tensors for training YOLO model.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.check_resume","title":"<code>check_resume(overrides)</code>","text":"<p>Check if resume checkpoint exists and update arguments accordingly.</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>def check_resume(self, overrides):\n    \"\"\"Check if resume checkpoint exists and update arguments accordingly.\"\"\"\n    resume = self.args.resume\n    if resume:\n        try:\n            exists = isinstance(resume, (str, Path)) and Path(resume).exists()\n            last = Path(check_file(resume) if exists else get_latest_run())\n\n            # Check that resume data YAML exists, otherwise strip to force re-download of dataset\n            ckpt_args = attempt_load_weights(last).args\n            if not Path(ckpt_args[\"data\"]).exists():\n                ckpt_args[\"data\"] = self.args.data\n\n            resume = True\n            self.args = get_cfg(ckpt_args)\n            self.args.model = str(last)  # reinstate model\n            for k in \"imgsz\", \"batch\":  # allow arg updates to reduce memory on resume if crashed due to CUDA OOM\n                if k in overrides:\n                    setattr(self.args, k, overrides[k])\n\n        except Exception as e:\n            raise FileNotFoundError(\n                \"Resume checkpoint not found. Please pass a valid checkpoint to resume from, \"\n                \"i.e. 'yolo train resume model=path/to/last.pt'\"\n            ) from e\n    self.resume = resume\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.final_eval","title":"<code>final_eval()</code>","text":"<p>Performs final evaluation and validation for object detection YOLO model.</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>def final_eval(self):\n    \"\"\"Performs final evaluation and validation for object detection YOLO model.\"\"\"\n    for f in self.last, self.best:\n        if f.exists():\n            strip_optimizer(f)  # strip optimizers\n            if f is self.best:\n                LOGGER.info(f\"\\nValidating {f}...\")\n                self.validator.args.plots = self.args.plots\n                self.metrics = self.validator(model=f)\n                self.metrics.pop(\"fitness\", None)\n                self.run_callbacks(\"on_fit_epoch_end\")\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.get_dataloader","title":"<code>get_dataloader(dataset_path, batch_size=16, rank=0, mode='train')</code>","text":"<p>Returns dataloader derived from torch.data.Dataloader.</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>def get_dataloader(self, dataset_path, batch_size=16, rank=0, mode=\"train\"):\n    \"\"\"Returns dataloader derived from torch.data.Dataloader.\"\"\"\n    raise NotImplementedError(\"get_dataloader function not implemented in trainer\")\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.get_dataset","title":"<code>get_dataset(data)</code>  <code>staticmethod</code>","text":"<p>Get train, val path from data dict if it exists.</p> <p>Returns None if data format is not recognized.</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>@staticmethod\ndef get_dataset(data):\n    \"\"\"\n    Get train, val path from data dict if it exists.\n\n    Returns None if data format is not recognized.\n    \"\"\"\n    return data[\"train\"], data.get(\"val\") or data.get(\"test\")\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.get_model","title":"<code>get_model(cfg=None, weights=None, verbose=True)</code>","text":"<p>Get model and raise NotImplementedError for loading cfg files.</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>def get_model(self, cfg=None, weights=None, verbose=True):\n    \"\"\"Get model and raise NotImplementedError for loading cfg files.\"\"\"\n    raise NotImplementedError(\"This task trainer doesn't support loading cfg files\")\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.get_validator","title":"<code>get_validator()</code>","text":"<p>Returns a NotImplementedError when the get_validator function is called.</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>def get_validator(self):\n    \"\"\"Returns a NotImplementedError when the get_validator function is called.\"\"\"\n    raise NotImplementedError(\"get_validator function not implemented in trainer\")\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.label_loss_items","title":"<code>label_loss_items(loss_items=None, prefix='train')</code>","text":"<p>Returns a loss dict with labelled training loss items tensor.</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>def label_loss_items(self, loss_items=None, prefix=\"train\"):\n    \"\"\"Returns a loss dict with labelled training loss items tensor.\"\"\"\n    # Not needed for classification but necessary for segmentation &amp; detection\n    return {\"loss\": loss_items} if loss_items is not None else [\"loss\"]\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.on_plot","title":"<code>on_plot(name, data=None)</code>","text":"<p>Registers plots (e.g. to be consumed in callbacks)</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>def on_plot(self, name, data=None):\n    \"\"\"Registers plots (e.g. to be consumed in callbacks)\"\"\"\n    path = Path(name)\n    self.plots[path] = {\"data\": data, \"timestamp\": time.time()}\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.optimizer_step","title":"<code>optimizer_step()</code>","text":"<p>Perform a single step of the training optimizer with gradient clipping and EMA update.</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>def optimizer_step(self):\n    \"\"\"Perform a single step of the training optimizer with gradient clipping and EMA update.\"\"\"\n    self.scaler.unscale_(self.optimizer)  # unscale gradients\n    torch.nn.utils.clip_grad_norm_(self.model.parameters(), max_norm=10.0)  # clip gradients\n    self.scaler.step(self.optimizer)\n    self.scaler.update()\n    self.optimizer.zero_grad()\n    if self.ema:\n        self.ema.update(self.model)\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.plot_metrics","title":"<code>plot_metrics()</code>","text":"<p>Plot and display metrics visually.</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>def plot_metrics(self):\n    \"\"\"Plot and display metrics visually.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.plot_training_labels","title":"<code>plot_training_labels()</code>","text":"<p>Plots training labels for YOLO model.</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>def plot_training_labels(self):\n    \"\"\"Plots training labels for YOLO model.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.plot_training_samples","title":"<code>plot_training_samples(batch, ni)</code>","text":"<p>Plots training samples during YOLO training.</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>def plot_training_samples(self, batch, ni):\n    \"\"\"Plots training samples during YOLO training.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.preprocess_batch","title":"<code>preprocess_batch(batch)</code>","text":"<p>Allows custom preprocessing model inputs and ground truths depending on task type.</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>def preprocess_batch(self, batch):\n    \"\"\"Allows custom preprocessing model inputs and ground truths depending on task type.\"\"\"\n    return batch\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.progress_string","title":"<code>progress_string()</code>","text":"<p>Returns a string describing training progress.</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>def progress_string(self):\n    \"\"\"Returns a string describing training progress.\"\"\"\n    return \"\"\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.resume_training","title":"<code>resume_training(ckpt)</code>","text":"<p>Resume YOLO training from given epoch and best fitness.</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>def resume_training(self, ckpt):\n    \"\"\"Resume YOLO training from given epoch and best fitness.\"\"\"\n    if ckpt is None:\n        return\n    best_fitness = 0.0\n    start_epoch = ckpt[\"epoch\"] + 1\n    if ckpt[\"optimizer\"] is not None:\n        self.optimizer.load_state_dict(ckpt[\"optimizer\"])  # optimizer\n        best_fitness = ckpt[\"best_fitness\"]\n    if self.ema and ckpt.get(\"ema\"):\n        self.ema.ema.load_state_dict(ckpt[\"ema\"].float().state_dict())  # EMA\n        self.ema.updates = ckpt[\"updates\"]\n    if self.resume:\n        assert start_epoch &gt; 0, (\n            f\"{self.args.model} training to {self.epochs} epochs is finished, nothing to resume.\\n\"\n            f\"Start a new training without resuming, i.e. 'yolo train model={self.args.model}'\"\n        )\n        LOGGER.info(\n            f\"Resuming training from {self.args.model} from epoch {start_epoch + 1} to {self.epochs} total epochs\"\n        )\n    if self.epochs &lt; start_epoch:\n        LOGGER.info(\n            f\"{self.model} has been trained for {ckpt['epoch']} epochs. Fine-tuning for {self.epochs} more epochs.\"\n        )\n        self.epochs += ckpt[\"epoch\"]  # finetune additional epochs\n    self.best_fitness = best_fitness\n    self.start_epoch = start_epoch\n    if start_epoch &gt; (self.epochs - self.args.close_mosaic):\n        self._close_dataloader_mosaic()\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.run_callbacks","title":"<code>run_callbacks(event)</code>","text":"<p>Run all existing callbacks associated with a particular event.</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>def run_callbacks(self, event: str):\n    \"\"\"Run all existing callbacks associated with a particular event.\"\"\"\n    for callback in self.callbacks.get(event, []):\n        callback(self)\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.save_metrics","title":"<code>save_metrics(metrics)</code>","text":"<p>Saves training metrics to a CSV file.</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>def save_metrics(self, metrics):\n    \"\"\"Saves training metrics to a CSV file.\"\"\"\n    keys, vals = list(metrics.keys()), list(metrics.values())\n    n = len(metrics) + 1  # number of cols\n    s = \"\" if self.csv.exists() else ((\"%23s,\" * n % tuple([\"epoch\"] + keys)).rstrip(\",\") + \"\\n\")  # header\n    with open(self.csv, \"a\") as f:\n        f.write(s + (\"%23.5g,\" * n % tuple([self.epoch + 1] + vals)).rstrip(\",\") + \"\\n\")\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.save_model","title":"<code>save_model()</code>","text":"<p>Save model training checkpoints with additional metadata.</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>def save_model(self):\n    \"\"\"Save model training checkpoints with additional metadata.\"\"\"\n    import pandas as pd  # scope for faster startup\n\n    metrics = {**self.metrics, **{\"fitness\": self.fitness}}\n    results = {k.strip(): v for k, v in pd.read_csv(self.csv).to_dict(orient=\"list\").items()}\n    ckpt = {\n        \"epoch\": self.epoch,\n        \"best_fitness\": self.best_fitness,\n        \"model\": deepcopy(de_parallel(self.model)).half(),\n        \"ema\": deepcopy(self.ema.ema).half(),\n        \"updates\": self.ema.updates,\n        \"optimizer\": self.optimizer.state_dict(),\n        \"train_args\": vars(self.args),  # save as dict\n        \"train_metrics\": metrics,\n        \"train_results\": results,\n        \"date\": datetime.now().isoformat(),\n        \"version\": __version__,\n    }\n\n    # Save last and best\n    torch.save(ckpt, self.last)\n    if self.best_fitness == self.fitness:\n        torch.save(ckpt, self.best)\n    if (self.save_period &gt; 0) and (self.epoch &gt; 0) and (self.epoch % self.save_period == 0):\n        torch.save(ckpt, self.wdir / f\"epoch{self.epoch}.pt\")\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.set_callback","title":"<code>set_callback(event, callback)</code>","text":"<p>Overrides the existing callbacks with the given callback.</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>def set_callback(self, event: str, callback):\n    \"\"\"Overrides the existing callbacks with the given callback.\"\"\"\n    self.callbacks[event] = [callback]\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.set_model_attributes","title":"<code>set_model_attributes()</code>","text":"<p>To set or update model parameters before training.</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>def set_model_attributes(self):\n    \"\"\"To set or update model parameters before training.\"\"\"\n    self.model.names = self.data[\"names\"]\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.setup_model","title":"<code>setup_model()</code>","text":"<p>Load/create/download model for any task.</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>def setup_model(self):\n    \"\"\"Load/create/download model for any task.\"\"\"\n    if isinstance(self.model, torch.nn.Module):  # if model is loaded beforehand. No setup needed\n        return\n\n    model, weights = self.model, None\n    ckpt = None\n    if str(model).endswith(\".pt\"):\n        weights, ckpt = attempt_load_one_weight(model)\n        cfg = ckpt[\"model\"].yaml\n    else:\n        cfg = model\n    self.model = self.get_model(cfg=cfg, weights=weights, verbose=RANK == -1)  # calls Model(cfg, weights)\n    return ckpt\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.train","title":"<code>train()</code>","text":"<p>Allow device='', device=None on Multi-GPU systems to default to device=0.</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>def train(self):\n    \"\"\"Allow device='', device=None on Multi-GPU systems to default to device=0.\"\"\"\n    if isinstance(self.args.device, str) and len(self.args.device):  # i.e. device='0' or device='0,1,2,3'\n        world_size = len(self.args.device.split(\",\"))\n    elif isinstance(self.args.device, (tuple, list)):  # i.e. device=[0, 1, 2, 3] (multi-GPU from CLI is list)\n        world_size = len(self.args.device)\n    elif torch.cuda.is_available():  # i.e. device=None or device='' or device=number\n        world_size = 1  # default to device 0\n    else:  # i.e. device='cpu' or 'mps'\n        world_size = 0\n\n    # Run subprocess if DDP training, else train normally\n    if world_size &gt; 1 and \"LOCAL_RANK\" not in os.environ:\n        # Argument checks\n        if self.args.rect:\n            LOGGER.warning(\"WARNING \u26a0\ufe0f 'rect=True' is incompatible with Multi-GPU training, setting 'rect=False'\")\n            self.args.rect = False\n        if self.args.batch == -1:\n            LOGGER.warning(\n                \"WARNING \u26a0\ufe0f 'batch=-1' for AutoBatch is incompatible with Multi-GPU training, setting \"\n                \"default 'batch=16'\"\n            )\n            self.args.batch = 16\n\n        # Command\n        cmd, file = generate_ddp_command(world_size, self)\n        try:\n            LOGGER.info(f'{colorstr(\"DDP:\")} debug command {\" \".join(cmd)}')\n            subprocess.run(cmd, check=True)\n        except Exception as e:\n            raise e\n        finally:\n            ddp_cleanup(self, str(file))\n\n    else:\n        self._do_train(world_size)\n</code></pre>"},{"location":"reference/engine/trainer/#ultralytics.engine.trainer.BaseTrainer.validate","title":"<code>validate()</code>","text":"<p>Runs validation on test set using self.validator.</p> <p>The returned dict is expected to contain \"fitness\" key.</p> Source code in <code>ultralytics/engine/trainer.py</code> <pre><code>def validate(self):\n    \"\"\"\n    Runs validation on test set using self.validator.\n\n    The returned dict is expected to contain \"fitness\" key.\n    \"\"\"\n    metrics = self.validator(self)\n    fitness = metrics.pop(\"fitness\", -self.loss.detach().cpu().numpy())  # use loss as fitness measure if not found\n    if not self.best_fitness or self.best_fitness &lt; fitness:\n        self.best_fitness = fitness\n    return metrics, fitness\n</code></pre>"},{"location":"reference/engine/tuner/","title":"Reference for <code>ultralytics/engine/tuner.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/engine/tuner.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/engine/tuner/#ultralytics.engine.tuner.Tuner","title":"<code>ultralytics.engine.tuner.Tuner</code>","text":"<p>Class responsible for hyperparameter tuning of YOLO models.</p> <p>The class evolves YOLO model hyperparameters over a given number of iterations by mutating them according to the search space and retraining the model to evaluate their performance.</p> <p>Attributes:</p> Name Type Description <code>space</code> <code>dict</code> <p>Hyperparameter search space containing bounds and scaling factors for mutation.</p> <code>tune_dir</code> <code>Path</code> <p>Directory where evolution logs and results will be saved.</p> <code>tune_csv</code> <code>Path</code> <p>Path to the CSV file where evolution logs are saved.</p> <p>Methods:</p> Name Description <code>_mutate</code> <p>dict) -&gt; dict: Mutates the given hyperparameters within the bounds specified in <code>self.space</code>.</p> <code>__call__</code> <p>Executes the hyperparameter evolution across multiple iterations.</p> Example <p>Tune hyperparameters for YOLOv8n on COCO8 at imgsz=640 and epochs=30 for 300 tuning iterations. <pre><code>from ultralytics import YOLO\n\nmodel = YOLO('yolov8n.pt')\nmodel.tune(data='coco8.yaml', epochs=10, iterations=300, optimizer='AdamW', plots=False, save=False, val=False)\n</code></pre></p> <p>Tune with custom search space. <pre><code>from ultralytics import YOLO\n\nmodel = YOLO('yolov8n.pt')\nmodel.tune(space={key1: val1, key2: val2})  # custom search space dictionary\n</code></pre></p> Source code in <code>ultralytics/engine/tuner.py</code> <pre><code>class Tuner:\n    \"\"\"\n    Class responsible for hyperparameter tuning of YOLO models.\n\n    The class evolves YOLO model hyperparameters over a given number of iterations\n    by mutating them according to the search space and retraining the model to evaluate their performance.\n\n    Attributes:\n        space (dict): Hyperparameter search space containing bounds and scaling factors for mutation.\n        tune_dir (Path): Directory where evolution logs and results will be saved.\n        tune_csv (Path): Path to the CSV file where evolution logs are saved.\n\n    Methods:\n        _mutate(hyp: dict) -&gt; dict:\n            Mutates the given hyperparameters within the bounds specified in `self.space`.\n\n        __call__():\n            Executes the hyperparameter evolution across multiple iterations.\n\n    Example:\n        Tune hyperparameters for YOLOv8n on COCO8 at imgsz=640 and epochs=30 for 300 tuning iterations.\n        ```python\n        from ultralytics import YOLO\n\n        model = YOLO('yolov8n.pt')\n        model.tune(data='coco8.yaml', epochs=10, iterations=300, optimizer='AdamW', plots=False, save=False, val=False)\n        ```\n\n        Tune with custom search space.\n        ```python\n        from ultralytics import YOLO\n\n        model = YOLO('yolov8n.pt')\n        model.tune(space={key1: val1, key2: val2})  # custom search space dictionary\n        ```\n    \"\"\"\n\n    def __init__(self, args=DEFAULT_CFG, _callbacks=None):\n        \"\"\"\n        Initialize the Tuner with configurations.\n\n        Args:\n            args (dict, optional): Configuration for hyperparameter evolution.\n        \"\"\"\n        self.space = args.pop(\"space\", None) or {  # key: (min, max, gain(optional))\n            # 'optimizer': tune.choice(['SGD', 'Adam', 'AdamW', 'NAdam', 'RAdam', 'RMSProp']),\n            \"lr0\": (1e-5, 1e-1),  # initial learning rate (i.e. SGD=1E-2, Adam=1E-3)\n            \"lrf\": (0.0001, 0.1),  # final OneCycleLR learning rate (lr0 * lrf)\n            \"momentum\": (0.7, 0.98, 0.3),  # SGD momentum/Adam beta1\n            \"weight_decay\": (0.0, 0.001),  # optimizer weight decay 5e-4\n            \"warmup_epochs\": (0.0, 5.0),  # warmup epochs (fractions ok)\n            \"warmup_momentum\": (0.0, 0.95),  # warmup initial momentum\n            \"box\": (1.0, 20.0),  # box loss gain\n            \"cls\": (0.2, 4.0),  # cls loss gain (scale with pixels)\n            \"dfl\": (0.4, 6.0),  # dfl loss gain\n            \"hsv_h\": (0.0, 0.1),  # image HSV-Hue augmentation (fraction)\n            \"hsv_s\": (0.0, 0.9),  # image HSV-Saturation augmentation (fraction)\n            \"hsv_v\": (0.0, 0.9),  # image HSV-Value augmentation (fraction)\n            \"degrees\": (0.0, 45.0),  # image rotation (+/- deg)\n            \"translate\": (0.0, 0.9),  # image translation (+/- fraction)\n            \"scale\": (0.0, 0.95),  # image scale (+/- gain)\n            \"shear\": (0.0, 10.0),  # image shear (+/- deg)\n            \"perspective\": (0.0, 0.001),  # image perspective (+/- fraction), range 0-0.001\n            \"flipud\": (0.0, 1.0),  # image flip up-down (probability)\n            \"fliplr\": (0.0, 1.0),  # image flip left-right (probability)\n            \"mosaic\": (0.0, 1.0),  # image mixup (probability)\n            \"mixup\": (0.0, 1.0),  # image mixup (probability)\n            \"copy_paste\": (0.0, 1.0),  # segment copy-paste (probability)\n        }\n        self.args = get_cfg(overrides=args)\n        self.tune_dir = get_save_dir(self.args, name=\"tune\")\n        self.tune_csv = self.tune_dir / \"tune_results.csv\"\n        self.callbacks = _callbacks or callbacks.get_default_callbacks()\n        self.prefix = colorstr(\"Tuner: \")\n        callbacks.add_integration_callbacks(self)\n        LOGGER.info(\n            f\"{self.prefix}Initialized Tuner instance with 'tune_dir={self.tune_dir}'\\n\"\n            f\"{self.prefix}\ud83d\udca1 Learn about tuning at https://docs.ultralytics.com/guides/hyperparameter-tuning\"\n        )\n\n    def _mutate(self, parent=\"single\", n=5, mutation=0.8, sigma=0.2):\n        \"\"\"\n        Mutates the hyperparameters based on bounds and scaling factors specified in `self.space`.\n\n        Args:\n            parent (str): Parent selection method: 'single' or 'weighted'.\n            n (int): Number of parents to consider.\n            mutation (float): Probability of a parameter mutation in any given iteration.\n            sigma (float): Standard deviation for Gaussian random number generator.\n\n        Returns:\n            (dict): A dictionary containing mutated hyperparameters.\n        \"\"\"\n        if self.tune_csv.exists():  # if CSV file exists: select best hyps and mutate\n            # Select parent(s)\n            x = np.loadtxt(self.tune_csv, ndmin=2, delimiter=\",\", skiprows=1)\n            fitness = x[:, 0]  # first column\n            n = min(n, len(x))  # number of previous results to consider\n            x = x[np.argsort(-fitness)][:n]  # top n mutations\n            w = x[:, 0] - x[:, 0].min() + 1e-6  # weights (sum &gt; 0)\n            if parent == \"single\" or len(x) == 1:\n                # x = x[random.randint(0, n - 1)]  # random selection\n                x = x[random.choices(range(n), weights=w)[0]]  # weighted selection\n            elif parent == \"weighted\":\n                x = (x * w.reshape(n, 1)).sum(0) / w.sum()  # weighted combination\n\n            # Mutate\n            r = np.random  # method\n            r.seed(int(time.time()))\n            g = np.array([v[2] if len(v) == 3 else 1.0 for k, v in self.space.items()])  # gains 0-1\n            ng = len(self.space)\n            v = np.ones(ng)\n            while all(v == 1):  # mutate until a change occurs (prevent duplicates)\n                v = (g * (r.random(ng) &lt; mutation) * r.randn(ng) * r.random() * sigma + 1).clip(0.3, 3.0)\n            hyp = {k: float(x[i + 1] * v[i]) for i, k in enumerate(self.space.keys())}\n        else:\n            hyp = {k: getattr(self.args, k) for k in self.space.keys()}\n\n        # Constrain to limits\n        for k, v in self.space.items():\n            hyp[k] = max(hyp[k], v[0])  # lower limit\n            hyp[k] = min(hyp[k], v[1])  # upper limit\n            hyp[k] = round(hyp[k], 5)  # significant digits\n\n        return hyp\n\n    def __call__(self, model=None, iterations=10, cleanup=True):\n        \"\"\"\n        Executes the hyperparameter evolution process when the Tuner instance is called.\n\n        This method iterates through the number of iterations, performing the following steps in each iteration:\n        1. Load the existing hyperparameters or initialize new ones.\n        2. Mutate the hyperparameters using the `mutate` method.\n        3. Train a YOLO model with the mutated hyperparameters.\n        4. Log the fitness score and mutated hyperparameters to a CSV file.\n\n        Args:\n           model (Model): A pre-initialized YOLO model to be used for training.\n           iterations (int): The number of generations to run the evolution for.\n           cleanup (bool): Whether to delete iteration weights to reduce storage space used during tuning.\n\n        Note:\n           The method utilizes the `self.tune_csv` Path object to read and log hyperparameters and fitness scores.\n           Ensure this path is set correctly in the Tuner instance.\n        \"\"\"\n\n        t0 = time.time()\n        best_save_dir, best_metrics = None, None\n        (self.tune_dir / \"weights\").mkdir(parents=True, exist_ok=True)\n        for i in range(iterations):\n            # Mutate hyperparameters\n            mutated_hyp = self._mutate()\n            LOGGER.info(f\"{self.prefix}Starting iteration {i + 1}/{iterations} with hyperparameters: {mutated_hyp}\")\n\n            metrics = {}\n            train_args = {**vars(self.args), **mutated_hyp}\n            save_dir = get_save_dir(get_cfg(train_args))\n            weights_dir = save_dir / \"weights\"\n            ckpt_file = weights_dir / (\"best.pt\" if (weights_dir / \"best.pt\").exists() else \"last.pt\")\n            try:\n                # Train YOLO model with mutated hyperparameters (run in subprocess to avoid dataloader hang)\n                cmd = [\"yolo\", \"train\", *(f\"{k}={v}\" for k, v in train_args.items())]\n                return_code = subprocess.run(cmd, check=True).returncode\n                metrics = torch.load(ckpt_file)[\"train_metrics\"]\n                assert return_code == 0, \"training failed\"\n\n            except Exception as e:\n                LOGGER.warning(f\"WARNING \u274c\ufe0f training failure for hyperparameter tuning iteration {i + 1}\\n{e}\")\n\n            # Save results and mutated_hyp to CSV\n            fitness = metrics.get(\"fitness\", 0.0)\n            log_row = [round(fitness, 5)] + [mutated_hyp[k] for k in self.space.keys()]\n            headers = \"\" if self.tune_csv.exists() else (\",\".join([\"fitness\"] + list(self.space.keys())) + \"\\n\")\n            with open(self.tune_csv, \"a\") as f:\n                f.write(headers + \",\".join(map(str, log_row)) + \"\\n\")\n\n            # Get best results\n            x = np.loadtxt(self.tune_csv, ndmin=2, delimiter=\",\", skiprows=1)\n            fitness = x[:, 0]  # first column\n            best_idx = fitness.argmax()\n            best_is_current = best_idx == i\n            if best_is_current:\n                best_save_dir = save_dir\n                best_metrics = {k: round(v, 5) for k, v in metrics.items()}\n                for ckpt in weights_dir.glob(\"*.pt\"):\n                    shutil.copy2(ckpt, self.tune_dir / \"weights\")\n            elif cleanup:\n                shutil.rmtree(ckpt_file.parent)  # remove iteration weights/ dir to reduce storage space\n\n            # Plot tune results\n            plot_tune_results(self.tune_csv)\n\n            # Save and print tune results\n            header = (\n                f'{self.prefix}{i + 1}/{iterations} iterations complete \u2705 ({time.time() - t0:.2f}s)\\n'\n                f'{self.prefix}Results saved to {colorstr(\"bold\", self.tune_dir)}\\n'\n                f'{self.prefix}Best fitness={fitness[best_idx]} observed at iteration {best_idx + 1}\\n'\n                f'{self.prefix}Best fitness metrics are {best_metrics}\\n'\n                f'{self.prefix}Best fitness model is {best_save_dir}\\n'\n                f'{self.prefix}Best fitness hyperparameters are printed below.\\n'\n            )\n            LOGGER.info(\"\\n\" + header)\n            data = {k: float(x[best_idx, i + 1]) for i, k in enumerate(self.space.keys())}\n            yaml_save(\n                self.tune_dir / \"best_hyperparameters.yaml\",\n                data=data,\n                header=remove_colorstr(header.replace(self.prefix, \"# \")) + \"\\n\",\n            )\n            yaml_print(self.tune_dir / \"best_hyperparameters.yaml\")\n</code></pre>"},{"location":"reference/engine/tuner/#ultralytics.engine.tuner.Tuner.__call__","title":"<code>__call__(model=None, iterations=10, cleanup=True)</code>","text":"<p>Executes the hyperparameter evolution process when the Tuner instance is called.</p> <p>This method iterates through the number of iterations, performing the following steps in each iteration: 1. Load the existing hyperparameters or initialize new ones. 2. Mutate the hyperparameters using the <code>mutate</code> method. 3. Train a YOLO model with the mutated hyperparameters. 4. Log the fitness score and mutated hyperparameters to a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>A pre-initialized YOLO model to be used for training.</p> <code>None</code> <code>iterations</code> <code>int</code> <p>The number of generations to run the evolution for.</p> <code>10</code> <code>cleanup</code> <code>bool</code> <p>Whether to delete iteration weights to reduce storage space used during tuning.</p> <code>True</code> Note <p>The method utilizes the <code>self.tune_csv</code> Path object to read and log hyperparameters and fitness scores. Ensure this path is set correctly in the Tuner instance.</p> Source code in <code>ultralytics/engine/tuner.py</code> <pre><code>def __call__(self, model=None, iterations=10, cleanup=True):\n    \"\"\"\n    Executes the hyperparameter evolution process when the Tuner instance is called.\n\n    This method iterates through the number of iterations, performing the following steps in each iteration:\n    1. Load the existing hyperparameters or initialize new ones.\n    2. Mutate the hyperparameters using the `mutate` method.\n    3. Train a YOLO model with the mutated hyperparameters.\n    4. Log the fitness score and mutated hyperparameters to a CSV file.\n\n    Args:\n       model (Model): A pre-initialized YOLO model to be used for training.\n       iterations (int): The number of generations to run the evolution for.\n       cleanup (bool): Whether to delete iteration weights to reduce storage space used during tuning.\n\n    Note:\n       The method utilizes the `self.tune_csv` Path object to read and log hyperparameters and fitness scores.\n       Ensure this path is set correctly in the Tuner instance.\n    \"\"\"\n\n    t0 = time.time()\n    best_save_dir, best_metrics = None, None\n    (self.tune_dir / \"weights\").mkdir(parents=True, exist_ok=True)\n    for i in range(iterations):\n        # Mutate hyperparameters\n        mutated_hyp = self._mutate()\n        LOGGER.info(f\"{self.prefix}Starting iteration {i + 1}/{iterations} with hyperparameters: {mutated_hyp}\")\n\n        metrics = {}\n        train_args = {**vars(self.args), **mutated_hyp}\n        save_dir = get_save_dir(get_cfg(train_args))\n        weights_dir = save_dir / \"weights\"\n        ckpt_file = weights_dir / (\"best.pt\" if (weights_dir / \"best.pt\").exists() else \"last.pt\")\n        try:\n            # Train YOLO model with mutated hyperparameters (run in subprocess to avoid dataloader hang)\n            cmd = [\"yolo\", \"train\", *(f\"{k}={v}\" for k, v in train_args.items())]\n            return_code = subprocess.run(cmd, check=True).returncode\n            metrics = torch.load(ckpt_file)[\"train_metrics\"]\n            assert return_code == 0, \"training failed\"\n\n        except Exception as e:\n            LOGGER.warning(f\"WARNING \u274c\ufe0f training failure for hyperparameter tuning iteration {i + 1}\\n{e}\")\n\n        # Save results and mutated_hyp to CSV\n        fitness = metrics.get(\"fitness\", 0.0)\n        log_row = [round(fitness, 5)] + [mutated_hyp[k] for k in self.space.keys()]\n        headers = \"\" if self.tune_csv.exists() else (\",\".join([\"fitness\"] + list(self.space.keys())) + \"\\n\")\n        with open(self.tune_csv, \"a\") as f:\n            f.write(headers + \",\".join(map(str, log_row)) + \"\\n\")\n\n        # Get best results\n        x = np.loadtxt(self.tune_csv, ndmin=2, delimiter=\",\", skiprows=1)\n        fitness = x[:, 0]  # first column\n        best_idx = fitness.argmax()\n        best_is_current = best_idx == i\n        if best_is_current:\n            best_save_dir = save_dir\n            best_metrics = {k: round(v, 5) for k, v in metrics.items()}\n            for ckpt in weights_dir.glob(\"*.pt\"):\n                shutil.copy2(ckpt, self.tune_dir / \"weights\")\n        elif cleanup:\n            shutil.rmtree(ckpt_file.parent)  # remove iteration weights/ dir to reduce storage space\n\n        # Plot tune results\n        plot_tune_results(self.tune_csv)\n\n        # Save and print tune results\n        header = (\n            f'{self.prefix}{i + 1}/{iterations} iterations complete \u2705 ({time.time() - t0:.2f}s)\\n'\n            f'{self.prefix}Results saved to {colorstr(\"bold\", self.tune_dir)}\\n'\n            f'{self.prefix}Best fitness={fitness[best_idx]} observed at iteration {best_idx + 1}\\n'\n            f'{self.prefix}Best fitness metrics are {best_metrics}\\n'\n            f'{self.prefix}Best fitness model is {best_save_dir}\\n'\n            f'{self.prefix}Best fitness hyperparameters are printed below.\\n'\n        )\n        LOGGER.info(\"\\n\" + header)\n        data = {k: float(x[best_idx, i + 1]) for i, k in enumerate(self.space.keys())}\n        yaml_save(\n            self.tune_dir / \"best_hyperparameters.yaml\",\n            data=data,\n            header=remove_colorstr(header.replace(self.prefix, \"# \")) + \"\\n\",\n        )\n        yaml_print(self.tune_dir / \"best_hyperparameters.yaml\")\n</code></pre>"},{"location":"reference/engine/tuner/#ultralytics.engine.tuner.Tuner.__init__","title":"<code>__init__(args=DEFAULT_CFG, _callbacks=None)</code>","text":"<p>Initialize the Tuner with configurations.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>dict</code> <p>Configuration for hyperparameter evolution.</p> <code>DEFAULT_CFG</code> Source code in <code>ultralytics/engine/tuner.py</code> <pre><code>def __init__(self, args=DEFAULT_CFG, _callbacks=None):\n    \"\"\"\n    Initialize the Tuner with configurations.\n\n    Args:\n        args (dict, optional): Configuration for hyperparameter evolution.\n    \"\"\"\n    self.space = args.pop(\"space\", None) or {  # key: (min, max, gain(optional))\n        # 'optimizer': tune.choice(['SGD', 'Adam', 'AdamW', 'NAdam', 'RAdam', 'RMSProp']),\n        \"lr0\": (1e-5, 1e-1),  # initial learning rate (i.e. SGD=1E-2, Adam=1E-3)\n        \"lrf\": (0.0001, 0.1),  # final OneCycleLR learning rate (lr0 * lrf)\n        \"momentum\": (0.7, 0.98, 0.3),  # SGD momentum/Adam beta1\n        \"weight_decay\": (0.0, 0.001),  # optimizer weight decay 5e-4\n        \"warmup_epochs\": (0.0, 5.0),  # warmup epochs (fractions ok)\n        \"warmup_momentum\": (0.0, 0.95),  # warmup initial momentum\n        \"box\": (1.0, 20.0),  # box loss gain\n        \"cls\": (0.2, 4.0),  # cls loss gain (scale with pixels)\n        \"dfl\": (0.4, 6.0),  # dfl loss gain\n        \"hsv_h\": (0.0, 0.1),  # image HSV-Hue augmentation (fraction)\n        \"hsv_s\": (0.0, 0.9),  # image HSV-Saturation augmentation (fraction)\n        \"hsv_v\": (0.0, 0.9),  # image HSV-Value augmentation (fraction)\n        \"degrees\": (0.0, 45.0),  # image rotation (+/- deg)\n        \"translate\": (0.0, 0.9),  # image translation (+/- fraction)\n        \"scale\": (0.0, 0.95),  # image scale (+/- gain)\n        \"shear\": (0.0, 10.0),  # image shear (+/- deg)\n        \"perspective\": (0.0, 0.001),  # image perspective (+/- fraction), range 0-0.001\n        \"flipud\": (0.0, 1.0),  # image flip up-down (probability)\n        \"fliplr\": (0.0, 1.0),  # image flip left-right (probability)\n        \"mosaic\": (0.0, 1.0),  # image mixup (probability)\n        \"mixup\": (0.0, 1.0),  # image mixup (probability)\n        \"copy_paste\": (0.0, 1.0),  # segment copy-paste (probability)\n    }\n    self.args = get_cfg(overrides=args)\n    self.tune_dir = get_save_dir(self.args, name=\"tune\")\n    self.tune_csv = self.tune_dir / \"tune_results.csv\"\n    self.callbacks = _callbacks or callbacks.get_default_callbacks()\n    self.prefix = colorstr(\"Tuner: \")\n    callbacks.add_integration_callbacks(self)\n    LOGGER.info(\n        f\"{self.prefix}Initialized Tuner instance with 'tune_dir={self.tune_dir}'\\n\"\n        f\"{self.prefix}\ud83d\udca1 Learn about tuning at https://docs.ultralytics.com/guides/hyperparameter-tuning\"\n    )\n</code></pre>"},{"location":"reference/engine/validator/","title":"Reference for <code>ultralytics/engine/validator.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/engine/validator.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/engine/validator/#ultralytics.engine.validator.BaseValidator","title":"<code>ultralytics.engine.validator.BaseValidator</code>","text":"<p>BaseValidator.</p> <p>A base class for creating validators.</p> <p>Attributes:</p> Name Type Description <code>args</code> <code>SimpleNamespace</code> <p>Configuration for the validator.</p> <code>dataloader</code> <code>DataLoader</code> <p>Dataloader to use for validation.</p> <code>pbar</code> <code>tqdm</code> <p>Progress bar to update during validation.</p> <code>model</code> <code>Module</code> <p>Model to validate.</p> <code>data</code> <code>dict</code> <p>Data dictionary.</p> <code>device</code> <code>device</code> <p>Device to use for validation.</p> <code>batch_i</code> <code>int</code> <p>Current batch index.</p> <code>training</code> <code>bool</code> <p>Whether the model is in training mode.</p> <code>names</code> <code>dict</code> <p>Class names.</p> <code>seen</code> <p>Records the number of images seen so far during validation.</p> <code>stats</code> <p>Placeholder for statistics during validation.</p> <code>confusion_matrix</code> <p>Placeholder for a confusion matrix.</p> <code>nc</code> <p>Number of classes.</p> <code>iouv</code> <p>(torch.Tensor): IoU thresholds from 0.50 to 0.95 in spaces of 0.05.</p> <code>jdict</code> <code>dict</code> <p>Dictionary to store JSON validation results.</p> <code>speed</code> <code>dict</code> <p>Dictionary with keys 'preprocess', 'inference', 'loss', 'postprocess' and their respective           batch processing times in milliseconds.</p> <code>save_dir</code> <code>Path</code> <p>Directory to save results.</p> <code>plots</code> <code>dict</code> <p>Dictionary to store plots for visualization.</p> <code>callbacks</code> <code>dict</code> <p>Dictionary to store various callback functions.</p> Source code in <code>ultralytics/engine/validator.py</code> <pre><code>class BaseValidator:\n    \"\"\"\n    BaseValidator.\n\n    A base class for creating validators.\n\n    Attributes:\n        args (SimpleNamespace): Configuration for the validator.\n        dataloader (DataLoader): Dataloader to use for validation.\n        pbar (tqdm): Progress bar to update during validation.\n        model (nn.Module): Model to validate.\n        data (dict): Data dictionary.\n        device (torch.device): Device to use for validation.\n        batch_i (int): Current batch index.\n        training (bool): Whether the model is in training mode.\n        names (dict): Class names.\n        seen: Records the number of images seen so far during validation.\n        stats: Placeholder for statistics during validation.\n        confusion_matrix: Placeholder for a confusion matrix.\n        nc: Number of classes.\n        iouv: (torch.Tensor): IoU thresholds from 0.50 to 0.95 in spaces of 0.05.\n        jdict (dict): Dictionary to store JSON validation results.\n        speed (dict): Dictionary with keys 'preprocess', 'inference', 'loss', 'postprocess' and their respective\n                      batch processing times in milliseconds.\n        save_dir (Path): Directory to save results.\n        plots (dict): Dictionary to store plots for visualization.\n        callbacks (dict): Dictionary to store various callback functions.\n    \"\"\"\n\n    def __init__(self, dataloader=None, save_dir=None, pbar=None, args=None, _callbacks=None):\n        \"\"\"\n        Initializes a BaseValidator instance.\n\n        Args:\n            dataloader (torch.utils.data.DataLoader): Dataloader to be used for validation.\n            save_dir (Path, optional): Directory to save results.\n            pbar (tqdm.tqdm): Progress bar for displaying progress.\n            args (SimpleNamespace): Configuration for the validator.\n            _callbacks (dict): Dictionary to store various callback functions.\n        \"\"\"\n        self.args = get_cfg(overrides=args)\n        self.dataloader = dataloader\n        self.pbar = pbar\n        self.stride = None\n        self.data = None\n        self.device = None\n        self.batch_i = None\n        self.training = True\n        self.names = None\n        self.seen = None\n        self.stats = None\n        self.confusion_matrix = None\n        self.nc = None\n        self.iouv = None\n        self.jdict = None\n        self.speed = {\"preprocess\": 0.0, \"inference\": 0.0, \"loss\": 0.0, \"postprocess\": 0.0}\n\n        self.save_dir = save_dir or get_save_dir(self.args)\n        (self.save_dir / \"labels\" if self.args.save_txt else self.save_dir).mkdir(parents=True, exist_ok=True)\n        if self.args.conf is None:\n            self.args.conf = 0.001  # default conf=0.001\n        self.args.imgsz = check_imgsz(self.args.imgsz, max_dim=1)\n\n        self.plots = {}\n        self.callbacks = _callbacks or callbacks.get_default_callbacks()\n\n    @smart_inference_mode()\n    def __call__(self, trainer=None, model=None):\n        \"\"\"Supports validation of a pre-trained model if passed or a model being trained if trainer is passed (trainer\n        gets priority).\n        \"\"\"\n        self.training = trainer is not None\n        augment = self.args.augment and (not self.training)\n        if self.training:\n            self.device = trainer.device\n            self.data = trainer.data\n            self.args.half = self.device.type != \"cpu\"  # force FP16 val during training\n            model = trainer.ema.ema or trainer.model\n            model = model.half() if self.args.half else model.float()\n            # self.model = model\n            self.loss = torch.zeros_like(trainer.loss_items, device=trainer.device)\n            self.args.plots &amp;= trainer.stopper.possible_stop or (trainer.epoch == trainer.epochs - 1)\n            model.eval()\n        else:\n            callbacks.add_integration_callbacks(self)\n            model = AutoBackend(\n                model or self.args.model,\n                device=select_device(self.args.device, self.args.batch),\n                dnn=self.args.dnn,\n                data=self.args.data,\n                fp16=self.args.half,\n            )\n            # self.model = model\n            self.device = model.device  # update device\n            self.args.half = model.fp16  # update half\n            stride, pt, jit, engine = model.stride, model.pt, model.jit, model.engine\n            imgsz = check_imgsz(self.args.imgsz, stride=stride)\n            if engine:\n                self.args.batch = model.batch_size\n            elif not pt and not jit:\n                self.args.batch = 1  # export.py models default to batch-size 1\n                LOGGER.info(f\"Forcing batch=1 square inference (1,3,{imgsz},{imgsz}) for non-PyTorch models\")\n\n            if str(self.args.data).split(\".\")[-1] in (\"yaml\", \"yml\"):\n                self.data = check_det_dataset(self.args.data)\n            elif self.args.task == \"classify\":\n                self.data = check_cls_dataset(self.args.data, split=self.args.split)\n            else:\n                raise FileNotFoundError(emojis(f\"Dataset '{self.args.data}' for task={self.args.task} not found \u274c\"))\n\n            if self.device.type in (\"cpu\", \"mps\"):\n                self.args.workers = 0  # faster CPU val as time dominated by inference, not dataloading\n            if not pt:\n                self.args.rect = False\n            self.stride = model.stride  # used in get_dataloader() for padding\n            self.dataloader = self.dataloader or self.get_dataloader(self.data.get(self.args.split), self.args.batch)\n\n            model.eval()\n            model.warmup(imgsz=(1 if pt else self.args.batch, 3, imgsz, imgsz))  # warmup\n\n        self.run_callbacks(\"on_val_start\")\n        dt = Profile(), Profile(), Profile(), Profile()\n        bar = TQDM(self.dataloader, desc=self.get_desc(), total=len(self.dataloader))\n        self.init_metrics(de_parallel(model))\n        self.jdict = []  # empty before each val\n        for batch_i, batch in enumerate(bar):\n            self.run_callbacks(\"on_val_batch_start\")\n            self.batch_i = batch_i\n            # Preprocess\n            with dt[0]:\n                batch = self.preprocess(batch)\n\n            # Inference\n            with dt[1]:\n                preds = model(batch[\"img\"], augment=augment)\n\n            # Loss\n            with dt[2]:\n                if self.training:\n                    self.loss += model.loss(batch, preds)[1]\n\n            # Postprocess\n            with dt[3]:\n                preds = self.postprocess(preds)\n\n            self.update_metrics(preds, batch)\n            if self.args.plots and batch_i &lt; 3:\n                self.plot_val_samples(batch, batch_i)\n                self.plot_predictions(batch, preds, batch_i)\n\n            self.run_callbacks(\"on_val_batch_end\")\n        stats = self.get_stats()\n        self.check_stats(stats)\n        self.speed = dict(zip(self.speed.keys(), (x.t / len(self.dataloader.dataset) * 1e3 for x in dt)))\n        self.finalize_metrics()\n        self.print_results()\n        self.run_callbacks(\"on_val_end\")\n        if self.training:\n            model.float()\n            results = {**stats, **trainer.label_loss_items(self.loss.cpu() / len(self.dataloader), prefix=\"val\")}\n            return {k: round(float(v), 5) for k, v in results.items()}  # return results as 5 decimal place floats\n        else:\n            LOGGER.info(\n                \"Speed: %.1fms preprocess, %.1fms inference, %.1fms loss, %.1fms postprocess per image\"\n                % tuple(self.speed.values())\n            )\n            if self.args.save_json and self.jdict:\n                with open(str(self.save_dir / \"predictions.json\"), \"w\") as f:\n                    LOGGER.info(f\"Saving {f.name}...\")\n                    json.dump(self.jdict, f)  # flatten and save\n                stats = self.eval_json(stats)  # update stats\n            if self.args.plots or self.args.save_json:\n                LOGGER.info(f\"Results saved to {colorstr('bold', self.save_dir)}\")\n            return stats\n\n    def match_predictions(self, pred_classes, true_classes, iou, use_scipy=False):\n        \"\"\"\n        Matches predictions to ground truth objects (pred_classes, true_classes) using IoU.\n\n        Args:\n            pred_classes (torch.Tensor): Predicted class indices of shape(N,).\n            true_classes (torch.Tensor): Target class indices of shape(M,).\n            iou (torch.Tensor): An NxM tensor containing the pairwise IoU values for predictions and ground of truth\n            use_scipy (bool): Whether to use scipy for matching (more precise).\n\n        Returns:\n            (torch.Tensor): Correct tensor of shape(N,10) for 10 IoU thresholds.\n        \"\"\"\n        # Dx10 matrix, where D - detections, 10 - IoU thresholds\n        correct = np.zeros((pred_classes.shape[0], self.iouv.shape[0])).astype(bool)\n        # LxD matrix where L - labels (rows), D - detections (columns)\n        correct_class = true_classes[:, None] == pred_classes\n        iou = iou * correct_class  # zero out the wrong classes\n        iou = iou.cpu().numpy()\n        for i, threshold in enumerate(self.iouv.cpu().tolist()):\n            if use_scipy:\n                # WARNING: known issue that reduces mAP in https://github.com/ultralytics/ultralytics/pull/4708\n                import scipy  # scope import to avoid importing for all commands\n\n                cost_matrix = iou * (iou &gt;= threshold)\n                if cost_matrix.any():\n                    labels_idx, detections_idx = scipy.optimize.linear_sum_assignment(cost_matrix, maximize=True)\n                    valid = cost_matrix[labels_idx, detections_idx] &gt; 0\n                    if valid.any():\n                        correct[detections_idx[valid], i] = True\n            else:\n                matches = np.nonzero(iou &gt;= threshold)  # IoU &gt; threshold and classes match\n                matches = np.array(matches).T\n                if matches.shape[0]:\n                    if matches.shape[0] &gt; 1:\n                        matches = matches[iou[matches[:, 0], matches[:, 1]].argsort()[::-1]]\n                        matches = matches[np.unique(matches[:, 1], return_index=True)[1]]\n                        # matches = matches[matches[:, 2].argsort()[::-1]]\n                        matches = matches[np.unique(matches[:, 0], return_index=True)[1]]\n                    correct[matches[:, 1].astype(int), i] = True\n        return torch.tensor(correct, dtype=torch.bool, device=pred_classes.device)\n\n    def add_callback(self, event: str, callback):\n        \"\"\"Appends the given callback.\"\"\"\n        self.callbacks[event].append(callback)\n\n    def run_callbacks(self, event: str):\n        \"\"\"Runs all callbacks associated with a specified event.\"\"\"\n        for callback in self.callbacks.get(event, []):\n            callback(self)\n\n    def get_dataloader(self, dataset_path, batch_size):\n        \"\"\"Get data loader from dataset path and batch size.\"\"\"\n        raise NotImplementedError(\"get_dataloader function not implemented for this validator\")\n\n    def build_dataset(self, img_path):\n        \"\"\"Build dataset.\"\"\"\n        raise NotImplementedError(\"build_dataset function not implemented in validator\")\n\n    def preprocess(self, batch):\n        \"\"\"Preprocesses an input batch.\"\"\"\n        return batch\n\n    def postprocess(self, preds):\n        \"\"\"Describes and summarizes the purpose of 'postprocess()' but no details mentioned.\"\"\"\n        return preds\n\n    def init_metrics(self, model):\n        \"\"\"Initialize performance metrics for the YOLO model.\"\"\"\n        pass\n\n    def update_metrics(self, preds, batch):\n        \"\"\"Updates metrics based on predictions and batch.\"\"\"\n        pass\n\n    def finalize_metrics(self, *args, **kwargs):\n        \"\"\"Finalizes and returns all metrics.\"\"\"\n        pass\n\n    def get_stats(self):\n        \"\"\"Returns statistics about the model's performance.\"\"\"\n        return {}\n\n    def check_stats(self, stats):\n        \"\"\"Checks statistics.\"\"\"\n        pass\n\n    def print_results(self):\n        \"\"\"Prints the results of the model's predictions.\"\"\"\n        pass\n\n    def get_desc(self):\n        \"\"\"Get description of the YOLO model.\"\"\"\n        pass\n\n    @property\n    def metric_keys(self):\n        \"\"\"Returns the metric keys used in YOLO training/validation.\"\"\"\n        return []\n\n    def on_plot(self, name, data=None):\n        \"\"\"Registers plots (e.g. to be consumed in callbacks)\"\"\"\n        self.plots[Path(name)] = {\"data\": data, \"timestamp\": time.time()}\n\n    # TODO: may need to put these following functions into callback\n    def plot_val_samples(self, batch, ni):\n        \"\"\"Plots validation samples during training.\"\"\"\n        pass\n\n    def plot_predictions(self, batch, preds, ni):\n        \"\"\"Plots YOLO model predictions on batch images.\"\"\"\n        pass\n\n    def pred_to_json(self, preds, batch):\n        \"\"\"Convert predictions to JSON format.\"\"\"\n        pass\n\n    def eval_json(self, stats):\n        \"\"\"Evaluate and return JSON format of prediction statistics.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/engine/validator/#ultralytics.engine.validator.BaseValidator.metric_keys","title":"<code>metric_keys</code>  <code>property</code>","text":"<p>Returns the metric keys used in YOLO training/validation.</p>"},{"location":"reference/engine/validator/#ultralytics.engine.validator.BaseValidator.__call__","title":"<code>__call__(trainer=None, model=None)</code>","text":"<p>Supports validation of a pre-trained model if passed or a model being trained if trainer is passed (trainer gets priority).</p> Source code in <code>ultralytics/engine/validator.py</code> <pre><code>@smart_inference_mode()\ndef __call__(self, trainer=None, model=None):\n    \"\"\"Supports validation of a pre-trained model if passed or a model being trained if trainer is passed (trainer\n    gets priority).\n    \"\"\"\n    self.training = trainer is not None\n    augment = self.args.augment and (not self.training)\n    if self.training:\n        self.device = trainer.device\n        self.data = trainer.data\n        self.args.half = self.device.type != \"cpu\"  # force FP16 val during training\n        model = trainer.ema.ema or trainer.model\n        model = model.half() if self.args.half else model.float()\n        # self.model = model\n        self.loss = torch.zeros_like(trainer.loss_items, device=trainer.device)\n        self.args.plots &amp;= trainer.stopper.possible_stop or (trainer.epoch == trainer.epochs - 1)\n        model.eval()\n    else:\n        callbacks.add_integration_callbacks(self)\n        model = AutoBackend(\n            model or self.args.model,\n            device=select_device(self.args.device, self.args.batch),\n            dnn=self.args.dnn,\n            data=self.args.data,\n            fp16=self.args.half,\n        )\n        # self.model = model\n        self.device = model.device  # update device\n        self.args.half = model.fp16  # update half\n        stride, pt, jit, engine = model.stride, model.pt, model.jit, model.engine\n        imgsz = check_imgsz(self.args.imgsz, stride=stride)\n        if engine:\n            self.args.batch = model.batch_size\n        elif not pt and not jit:\n            self.args.batch = 1  # export.py models default to batch-size 1\n            LOGGER.info(f\"Forcing batch=1 square inference (1,3,{imgsz},{imgsz}) for non-PyTorch models\")\n\n        if str(self.args.data).split(\".\")[-1] in (\"yaml\", \"yml\"):\n            self.data = check_det_dataset(self.args.data)\n        elif self.args.task == \"classify\":\n            self.data = check_cls_dataset(self.args.data, split=self.args.split)\n        else:\n            raise FileNotFoundError(emojis(f\"Dataset '{self.args.data}' for task={self.args.task} not found \u274c\"))\n\n        if self.device.type in (\"cpu\", \"mps\"):\n            self.args.workers = 0  # faster CPU val as time dominated by inference, not dataloading\n        if not pt:\n            self.args.rect = False\n        self.stride = model.stride  # used in get_dataloader() for padding\n        self.dataloader = self.dataloader or self.get_dataloader(self.data.get(self.args.split), self.args.batch)\n\n        model.eval()\n        model.warmup(imgsz=(1 if pt else self.args.batch, 3, imgsz, imgsz))  # warmup\n\n    self.run_callbacks(\"on_val_start\")\n    dt = Profile(), Profile(), Profile(), Profile()\n    bar = TQDM(self.dataloader, desc=self.get_desc(), total=len(self.dataloader))\n    self.init_metrics(de_parallel(model))\n    self.jdict = []  # empty before each val\n    for batch_i, batch in enumerate(bar):\n        self.run_callbacks(\"on_val_batch_start\")\n        self.batch_i = batch_i\n        # Preprocess\n        with dt[0]:\n            batch = self.preprocess(batch)\n\n        # Inference\n        with dt[1]:\n            preds = model(batch[\"img\"], augment=augment)\n\n        # Loss\n        with dt[2]:\n            if self.training:\n                self.loss += model.loss(batch, preds)[1]\n\n        # Postprocess\n        with dt[3]:\n            preds = self.postprocess(preds)\n\n        self.update_metrics(preds, batch)\n        if self.args.plots and batch_i &lt; 3:\n            self.plot_val_samples(batch, batch_i)\n            self.plot_predictions(batch, preds, batch_i)\n\n        self.run_callbacks(\"on_val_batch_end\")\n    stats = self.get_stats()\n    self.check_stats(stats)\n    self.speed = dict(zip(self.speed.keys(), (x.t / len(self.dataloader.dataset) * 1e3 for x in dt)))\n    self.finalize_metrics()\n    self.print_results()\n    self.run_callbacks(\"on_val_end\")\n    if self.training:\n        model.float()\n        results = {**stats, **trainer.label_loss_items(self.loss.cpu() / len(self.dataloader), prefix=\"val\")}\n        return {k: round(float(v), 5) for k, v in results.items()}  # return results as 5 decimal place floats\n    else:\n        LOGGER.info(\n            \"Speed: %.1fms preprocess, %.1fms inference, %.1fms loss, %.1fms postprocess per image\"\n            % tuple(self.speed.values())\n        )\n        if self.args.save_json and self.jdict:\n            with open(str(self.save_dir / \"predictions.json\"), \"w\") as f:\n                LOGGER.info(f\"Saving {f.name}...\")\n                json.dump(self.jdict, f)  # flatten and save\n            stats = self.eval_json(stats)  # update stats\n        if self.args.plots or self.args.save_json:\n            LOGGER.info(f\"Results saved to {colorstr('bold', self.save_dir)}\")\n        return stats\n</code></pre>"},{"location":"reference/engine/validator/#ultralytics.engine.validator.BaseValidator.__init__","title":"<code>__init__(dataloader=None, save_dir=None, pbar=None, args=None, _callbacks=None)</code>","text":"<p>Initializes a BaseValidator instance.</p> <p>Parameters:</p> Name Type Description Default <code>dataloader</code> <code>DataLoader</code> <p>Dataloader to be used for validation.</p> <code>None</code> <code>save_dir</code> <code>Path</code> <p>Directory to save results.</p> <code>None</code> <code>pbar</code> <code>tqdm</code> <p>Progress bar for displaying progress.</p> <code>None</code> <code>args</code> <code>SimpleNamespace</code> <p>Configuration for the validator.</p> <code>None</code> <code>_callbacks</code> <code>dict</code> <p>Dictionary to store various callback functions.</p> <code>None</code> Source code in <code>ultralytics/engine/validator.py</code> <pre><code>def __init__(self, dataloader=None, save_dir=None, pbar=None, args=None, _callbacks=None):\n    \"\"\"\n    Initializes a BaseValidator instance.\n\n    Args:\n        dataloader (torch.utils.data.DataLoader): Dataloader to be used for validation.\n        save_dir (Path, optional): Directory to save results.\n        pbar (tqdm.tqdm): Progress bar for displaying progress.\n        args (SimpleNamespace): Configuration for the validator.\n        _callbacks (dict): Dictionary to store various callback functions.\n    \"\"\"\n    self.args = get_cfg(overrides=args)\n    self.dataloader = dataloader\n    self.pbar = pbar\n    self.stride = None\n    self.data = None\n    self.device = None\n    self.batch_i = None\n    self.training = True\n    self.names = None\n    self.seen = None\n    self.stats = None\n    self.confusion_matrix = None\n    self.nc = None\n    self.iouv = None\n    self.jdict = None\n    self.speed = {\"preprocess\": 0.0, \"inference\": 0.0, \"loss\": 0.0, \"postprocess\": 0.0}\n\n    self.save_dir = save_dir or get_save_dir(self.args)\n    (self.save_dir / \"labels\" if self.args.save_txt else self.save_dir).mkdir(parents=True, exist_ok=True)\n    if self.args.conf is None:\n        self.args.conf = 0.001  # default conf=0.001\n    self.args.imgsz = check_imgsz(self.args.imgsz, max_dim=1)\n\n    self.plots = {}\n    self.callbacks = _callbacks or callbacks.get_default_callbacks()\n</code></pre>"},{"location":"reference/engine/validator/#ultralytics.engine.validator.BaseValidator.add_callback","title":"<code>add_callback(event, callback)</code>","text":"<p>Appends the given callback.</p> Source code in <code>ultralytics/engine/validator.py</code> <pre><code>def add_callback(self, event: str, callback):\n    \"\"\"Appends the given callback.\"\"\"\n    self.callbacks[event].append(callback)\n</code></pre>"},{"location":"reference/engine/validator/#ultralytics.engine.validator.BaseValidator.build_dataset","title":"<code>build_dataset(img_path)</code>","text":"<p>Build dataset.</p> Source code in <code>ultralytics/engine/validator.py</code> <pre><code>def build_dataset(self, img_path):\n    \"\"\"Build dataset.\"\"\"\n    raise NotImplementedError(\"build_dataset function not implemented in validator\")\n</code></pre>"},{"location":"reference/engine/validator/#ultralytics.engine.validator.BaseValidator.check_stats","title":"<code>check_stats(stats)</code>","text":"<p>Checks statistics.</p> Source code in <code>ultralytics/engine/validator.py</code> <pre><code>def check_stats(self, stats):\n    \"\"\"Checks statistics.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/engine/validator/#ultralytics.engine.validator.BaseValidator.eval_json","title":"<code>eval_json(stats)</code>","text":"<p>Evaluate and return JSON format of prediction statistics.</p> Source code in <code>ultralytics/engine/validator.py</code> <pre><code>def eval_json(self, stats):\n    \"\"\"Evaluate and return JSON format of prediction statistics.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/engine/validator/#ultralytics.engine.validator.BaseValidator.finalize_metrics","title":"<code>finalize_metrics(*args, **kwargs)</code>","text":"<p>Finalizes and returns all metrics.</p> Source code in <code>ultralytics/engine/validator.py</code> <pre><code>def finalize_metrics(self, *args, **kwargs):\n    \"\"\"Finalizes and returns all metrics.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/engine/validator/#ultralytics.engine.validator.BaseValidator.get_dataloader","title":"<code>get_dataloader(dataset_path, batch_size)</code>","text":"<p>Get data loader from dataset path and batch size.</p> Source code in <code>ultralytics/engine/validator.py</code> <pre><code>def get_dataloader(self, dataset_path, batch_size):\n    \"\"\"Get data loader from dataset path and batch size.\"\"\"\n    raise NotImplementedError(\"get_dataloader function not implemented for this validator\")\n</code></pre>"},{"location":"reference/engine/validator/#ultralytics.engine.validator.BaseValidator.get_desc","title":"<code>get_desc()</code>","text":"<p>Get description of the YOLO model.</p> Source code in <code>ultralytics/engine/validator.py</code> <pre><code>def get_desc(self):\n    \"\"\"Get description of the YOLO model.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/engine/validator/#ultralytics.engine.validator.BaseValidator.get_stats","title":"<code>get_stats()</code>","text":"<p>Returns statistics about the model's performance.</p> Source code in <code>ultralytics/engine/validator.py</code> <pre><code>def get_stats(self):\n    \"\"\"Returns statistics about the model's performance.\"\"\"\n    return {}\n</code></pre>"},{"location":"reference/engine/validator/#ultralytics.engine.validator.BaseValidator.init_metrics","title":"<code>init_metrics(model)</code>","text":"<p>Initialize performance metrics for the YOLO model.</p> Source code in <code>ultralytics/engine/validator.py</code> <pre><code>def init_metrics(self, model):\n    \"\"\"Initialize performance metrics for the YOLO model.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/engine/validator/#ultralytics.engine.validator.BaseValidator.match_predictions","title":"<code>match_predictions(pred_classes, true_classes, iou, use_scipy=False)</code>","text":"<p>Matches predictions to ground truth objects (pred_classes, true_classes) using IoU.</p> <p>Parameters:</p> Name Type Description Default <code>pred_classes</code> <code>Tensor</code> <p>Predicted class indices of shape(N,).</p> required <code>true_classes</code> <code>Tensor</code> <p>Target class indices of shape(M,).</p> required <code>iou</code> <code>Tensor</code> <p>An NxM tensor containing the pairwise IoU values for predictions and ground of truth</p> required <code>use_scipy</code> <code>bool</code> <p>Whether to use scipy for matching (more precise).</p> <code>False</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>Correct tensor of shape(N,10) for 10 IoU thresholds.</p> Source code in <code>ultralytics/engine/validator.py</code> <pre><code>def match_predictions(self, pred_classes, true_classes, iou, use_scipy=False):\n    \"\"\"\n    Matches predictions to ground truth objects (pred_classes, true_classes) using IoU.\n\n    Args:\n        pred_classes (torch.Tensor): Predicted class indices of shape(N,).\n        true_classes (torch.Tensor): Target class indices of shape(M,).\n        iou (torch.Tensor): An NxM tensor containing the pairwise IoU values for predictions and ground of truth\n        use_scipy (bool): Whether to use scipy for matching (more precise).\n\n    Returns:\n        (torch.Tensor): Correct tensor of shape(N,10) for 10 IoU thresholds.\n    \"\"\"\n    # Dx10 matrix, where D - detections, 10 - IoU thresholds\n    correct = np.zeros((pred_classes.shape[0], self.iouv.shape[0])).astype(bool)\n    # LxD matrix where L - labels (rows), D - detections (columns)\n    correct_class = true_classes[:, None] == pred_classes\n    iou = iou * correct_class  # zero out the wrong classes\n    iou = iou.cpu().numpy()\n    for i, threshold in enumerate(self.iouv.cpu().tolist()):\n        if use_scipy:\n            # WARNING: known issue that reduces mAP in https://github.com/ultralytics/ultralytics/pull/4708\n            import scipy  # scope import to avoid importing for all commands\n\n            cost_matrix = iou * (iou &gt;= threshold)\n            if cost_matrix.any():\n                labels_idx, detections_idx = scipy.optimize.linear_sum_assignment(cost_matrix, maximize=True)\n                valid = cost_matrix[labels_idx, detections_idx] &gt; 0\n                if valid.any():\n                    correct[detections_idx[valid], i] = True\n        else:\n            matches = np.nonzero(iou &gt;= threshold)  # IoU &gt; threshold and classes match\n            matches = np.array(matches).T\n            if matches.shape[0]:\n                if matches.shape[0] &gt; 1:\n                    matches = matches[iou[matches[:, 0], matches[:, 1]].argsort()[::-1]]\n                    matches = matches[np.unique(matches[:, 1], return_index=True)[1]]\n                    # matches = matches[matches[:, 2].argsort()[::-1]]\n                    matches = matches[np.unique(matches[:, 0], return_index=True)[1]]\n                correct[matches[:, 1].astype(int), i] = True\n    return torch.tensor(correct, dtype=torch.bool, device=pred_classes.device)\n</code></pre>"},{"location":"reference/engine/validator/#ultralytics.engine.validator.BaseValidator.on_plot","title":"<code>on_plot(name, data=None)</code>","text":"<p>Registers plots (e.g. to be consumed in callbacks)</p> Source code in <code>ultralytics/engine/validator.py</code> <pre><code>def on_plot(self, name, data=None):\n    \"\"\"Registers plots (e.g. to be consumed in callbacks)\"\"\"\n    self.plots[Path(name)] = {\"data\": data, \"timestamp\": time.time()}\n</code></pre>"},{"location":"reference/engine/validator/#ultralytics.engine.validator.BaseValidator.plot_predictions","title":"<code>plot_predictions(batch, preds, ni)</code>","text":"<p>Plots YOLO model predictions on batch images.</p> Source code in <code>ultralytics/engine/validator.py</code> <pre><code>def plot_predictions(self, batch, preds, ni):\n    \"\"\"Plots YOLO model predictions on batch images.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/engine/validator/#ultralytics.engine.validator.BaseValidator.plot_val_samples","title":"<code>plot_val_samples(batch, ni)</code>","text":"<p>Plots validation samples during training.</p> Source code in <code>ultralytics/engine/validator.py</code> <pre><code>def plot_val_samples(self, batch, ni):\n    \"\"\"Plots validation samples during training.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/engine/validator/#ultralytics.engine.validator.BaseValidator.postprocess","title":"<code>postprocess(preds)</code>","text":"<p>Describes and summarizes the purpose of 'postprocess()' but no details mentioned.</p> Source code in <code>ultralytics/engine/validator.py</code> <pre><code>def postprocess(self, preds):\n    \"\"\"Describes and summarizes the purpose of 'postprocess()' but no details mentioned.\"\"\"\n    return preds\n</code></pre>"},{"location":"reference/engine/validator/#ultralytics.engine.validator.BaseValidator.pred_to_json","title":"<code>pred_to_json(preds, batch)</code>","text":"<p>Convert predictions to JSON format.</p> Source code in <code>ultralytics/engine/validator.py</code> <pre><code>def pred_to_json(self, preds, batch):\n    \"\"\"Convert predictions to JSON format.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/engine/validator/#ultralytics.engine.validator.BaseValidator.preprocess","title":"<code>preprocess(batch)</code>","text":"<p>Preprocesses an input batch.</p> Source code in <code>ultralytics/engine/validator.py</code> <pre><code>def preprocess(self, batch):\n    \"\"\"Preprocesses an input batch.\"\"\"\n    return batch\n</code></pre>"},{"location":"reference/engine/validator/#ultralytics.engine.validator.BaseValidator.print_results","title":"<code>print_results()</code>","text":"<p>Prints the results of the model's predictions.</p> Source code in <code>ultralytics/engine/validator.py</code> <pre><code>def print_results(self):\n    \"\"\"Prints the results of the model's predictions.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/engine/validator/#ultralytics.engine.validator.BaseValidator.run_callbacks","title":"<code>run_callbacks(event)</code>","text":"<p>Runs all callbacks associated with a specified event.</p> Source code in <code>ultralytics/engine/validator.py</code> <pre><code>def run_callbacks(self, event: str):\n    \"\"\"Runs all callbacks associated with a specified event.\"\"\"\n    for callback in self.callbacks.get(event, []):\n        callback(self)\n</code></pre>"},{"location":"reference/engine/validator/#ultralytics.engine.validator.BaseValidator.update_metrics","title":"<code>update_metrics(preds, batch)</code>","text":"<p>Updates metrics based on predictions and batch.</p> Source code in <code>ultralytics/engine/validator.py</code> <pre><code>def update_metrics(self, preds, batch):\n    \"\"\"Updates metrics based on predictions and batch.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/hub/__init__/","title":"Reference for <code>ultralytics/hub/__init__.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/hub/init.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/hub/__init__/#ultralytics.hub.login","title":"<code>ultralytics.hub.login(api_key=None, save=True)</code>","text":"<p>Log in to the Ultralytics HUB API using the provided API key.</p> <p>The session is not stored; a new session is created when needed using the saved SETTINGS or the HUB_API_KEY environment variable if successfully authenticated.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The API key to use for authentication. If not provided, it will be retrieved from SETTINGS or HUB_API_KEY environment variable.</p> <code>None</code> <code>save</code> <code>bool</code> <p>Whether to save the API key to SETTINGS if authentication is successful.</p> <code>True</code> <p>Returns:     bool: True if authentication is successful, False otherwise.</p> Source code in <code>ultralytics/hub/__init__.py</code> <pre><code>def login(api_key: str = None, save=True) -&gt; bool:\n    \"\"\"\n    Log in to the Ultralytics HUB API using the provided API key.\n\n    The session is not stored; a new session is created when needed using the saved SETTINGS or the HUB_API_KEY environment variable if successfully authenticated.\n\n    Args:\n        api_key (str, optional): The API key to use for authentication. If not provided, it will be retrieved from SETTINGS or HUB_API_KEY environment variable.\n        save (bool, optional): Whether to save the API key to SETTINGS if authentication is successful.\n    Returns:\n        bool: True if authentication is successful, False otherwise.\n    \"\"\"\n    api_key_url = f\"{HUB_WEB_ROOT}/settings?tab=api+keys\"  # set the redirect URL\n    saved_key = SETTINGS.get(\"api_key\")\n    active_key = api_key or saved_key\n    credentials = {\"api_key\": active_key} if active_key and active_key != \"\" else None  # set credentials\n\n    client = HUBClient(credentials)  # initialize HUBClient\n\n    if client.authenticated:\n        # Successfully authenticated with HUB\n\n        if save and client.api_key != saved_key:\n            SETTINGS.update({\"api_key\": client.api_key})  # update settings with valid API key\n\n        # Set message based on whether key was provided or retrieved from settings\n        log_message = (\n            \"New authentication successful \u2705\" if client.api_key == api_key or not credentials else \"Authenticated \u2705\"\n        )\n        LOGGER.info(f\"{PREFIX}{log_message}\")\n\n        return True\n    else:\n        # Failed to authenticate with HUB\n        LOGGER.info(f\"{PREFIX}Retrieve API key from {api_key_url}\")\n        return False\n</code></pre>"},{"location":"reference/hub/__init__/#ultralytics.hub.logout","title":"<code>ultralytics.hub.logout()</code>","text":"<p>Log out of Ultralytics HUB by removing the API key from the settings file. To log in again, use 'yolo hub login'.</p> Example <pre><code>from ultralytics import hub\n\nhub.logout()\n</code></pre> Source code in <code>ultralytics/hub/__init__.py</code> <pre><code>def logout():\n    \"\"\"\n    Log out of Ultralytics HUB by removing the API key from the settings file. To log in again, use 'yolo hub login'.\n\n    Example:\n        ```python\n        from ultralytics import hub\n\n        hub.logout()\n        ```\n    \"\"\"\n    SETTINGS[\"api_key\"] = \"\"\n    SETTINGS.save()\n    LOGGER.info(f\"{PREFIX}logged out \u2705. To log in again, use 'yolo hub login'.\")\n</code></pre>"},{"location":"reference/hub/__init__/#ultralytics.hub.reset_model","title":"<code>ultralytics.hub.reset_model(model_id='')</code>","text":"<p>Reset a trained model to an untrained state.</p> Source code in <code>ultralytics/hub/__init__.py</code> <pre><code>def reset_model(model_id=\"\"):\n    \"\"\"Reset a trained model to an untrained state.\"\"\"\n    r = requests.post(f\"{HUB_API_ROOT}/model-reset\", json={\"modelId\": model_id}, headers={\"x-api-key\": Auth().api_key})\n    if r.status_code == 200:\n        LOGGER.info(f\"{PREFIX}Model reset successfully\")\n        return\n    LOGGER.warning(f\"{PREFIX}Model reset failure {r.status_code} {r.reason}\")\n</code></pre>"},{"location":"reference/hub/__init__/#ultralytics.hub.export_fmts_hub","title":"<code>ultralytics.hub.export_fmts_hub()</code>","text":"<p>Returns a list of HUB-supported export formats.</p> Source code in <code>ultralytics/hub/__init__.py</code> <pre><code>def export_fmts_hub():\n    \"\"\"Returns a list of HUB-supported export formats.\"\"\"\n    from ultralytics.engine.exporter import export_formats\n\n    return list(export_formats()[\"Argument\"][1:]) + [\"ultralytics_tflite\", \"ultralytics_coreml\"]\n</code></pre>"},{"location":"reference/hub/__init__/#ultralytics.hub.export_model","title":"<code>ultralytics.hub.export_model(model_id='', format='torchscript')</code>","text":"<p>Export a model to all formats.</p> Source code in <code>ultralytics/hub/__init__.py</code> <pre><code>def export_model(model_id=\"\", format=\"torchscript\"):\n    \"\"\"Export a model to all formats.\"\"\"\n    assert format in export_fmts_hub(), f\"Unsupported export format '{format}', valid formats are {export_fmts_hub()}\"\n    r = requests.post(\n        f\"{HUB_API_ROOT}/v1/models/{model_id}/export\", json={\"format\": format}, headers={\"x-api-key\": Auth().api_key}\n    )\n    assert r.status_code == 200, f\"{PREFIX}{format} export failure {r.status_code} {r.reason}\"\n    LOGGER.info(f\"{PREFIX}{format} export started \u2705\")\n</code></pre>"},{"location":"reference/hub/__init__/#ultralytics.hub.get_export","title":"<code>ultralytics.hub.get_export(model_id='', format='torchscript')</code>","text":"<p>Get an exported model dictionary with download URL.</p> Source code in <code>ultralytics/hub/__init__.py</code> <pre><code>def get_export(model_id=\"\", format=\"torchscript\"):\n    \"\"\"Get an exported model dictionary with download URL.\"\"\"\n    assert format in export_fmts_hub(), f\"Unsupported export format '{format}', valid formats are {export_fmts_hub()}\"\n    r = requests.post(\n        f\"{HUB_API_ROOT}/get-export\",\n        json={\"apiKey\": Auth().api_key, \"modelId\": model_id, \"format\": format},\n        headers={\"x-api-key\": Auth().api_key},\n    )\n    assert r.status_code == 200, f\"{PREFIX}{format} get_export failure {r.status_code} {r.reason}\"\n    return r.json()\n</code></pre>"},{"location":"reference/hub/__init__/#ultralytics.hub.check_dataset","title":"<code>ultralytics.hub.check_dataset(path='', task='detect')</code>","text":"<p>Function for error-checking HUB dataset Zip file before upload. It checks a dataset for errors before it is uploaded to the HUB. Usage examples are given below.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to data.zip (with data.yaml inside data.zip). Defaults to ''.</p> <code>''</code> <code>task</code> <code>str</code> <p>Dataset task. Options are 'detect', 'segment', 'pose', 'classify'. Defaults to 'detect'.</p> <code>'detect'</code> Example <pre><code>from ultralytics.hub import check_dataset\n\ncheck_dataset('path/to/coco8.zip', task='detect')  # detect dataset\ncheck_dataset('path/to/coco8-seg.zip', task='segment')  # segment dataset\ncheck_dataset('path/to/coco8-pose.zip', task='pose')  # pose dataset\n</code></pre> Source code in <code>ultralytics/hub/__init__.py</code> <pre><code>def check_dataset(path=\"\", task=\"detect\"):\n    \"\"\"\n    Function for error-checking HUB dataset Zip file before upload. It checks a dataset for errors before it is uploaded\n    to the HUB. Usage examples are given below.\n\n    Args:\n        path (str, optional): Path to data.zip (with data.yaml inside data.zip). Defaults to ''.\n        task (str, optional): Dataset task. Options are 'detect', 'segment', 'pose', 'classify'. Defaults to 'detect'.\n\n    Example:\n        ```python\n        from ultralytics.hub import check_dataset\n\n        check_dataset('path/to/coco8.zip', task='detect')  # detect dataset\n        check_dataset('path/to/coco8-seg.zip', task='segment')  # segment dataset\n        check_dataset('path/to/coco8-pose.zip', task='pose')  # pose dataset\n        ```\n    \"\"\"\n    HUBDatasetStats(path=path, task=task).get_json()\n    LOGGER.info(f\"Checks completed correctly \u2705. Upload this dataset to {HUB_WEB_ROOT}/datasets/.\")\n</code></pre>"},{"location":"reference/hub/auth/","title":"Reference for <code>ultralytics/hub/auth.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/hub/auth.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/hub/auth/#ultralytics.hub.auth.Auth","title":"<code>ultralytics.hub.auth.Auth</code>","text":"<p>Manages authentication processes including API key handling, cookie-based authentication, and header generation.</p> <p>The class supports different methods of authentication: 1. Directly using an API key. 2. Authenticating using browser cookies (specifically in Google Colab). 3. Prompting the user to enter an API key.</p> <p>Attributes:</p> Name Type Description <code>id_token</code> <code>str or bool</code> <p>Token used for identity verification, initialized as False.</p> <code>api_key</code> <code>str or bool</code> <p>API key for authentication, initialized as False.</p> <code>model_key</code> <code>bool</code> <p>Placeholder for model key, initialized as False.</p> Source code in <code>ultralytics/hub/auth.py</code> <pre><code>class Auth:\n    \"\"\"\n    Manages authentication processes including API key handling, cookie-based authentication, and header generation.\n\n    The class supports different methods of authentication:\n    1. Directly using an API key.\n    2. Authenticating using browser cookies (specifically in Google Colab).\n    3. Prompting the user to enter an API key.\n\n    Attributes:\n        id_token (str or bool): Token used for identity verification, initialized as False.\n        api_key (str or bool): API key for authentication, initialized as False.\n        model_key (bool): Placeholder for model key, initialized as False.\n    \"\"\"\n\n    id_token = api_key = model_key = False\n\n    def __init__(self, api_key=\"\", verbose=False):\n        \"\"\"\n        Initialize the Auth class with an optional API key.\n\n        Args:\n            api_key (str, optional): May be an API key or a combination API key and model ID, i.e. key_id\n        \"\"\"\n        # Split the input API key in case it contains a combined key_model and keep only the API key part\n        api_key = api_key.split(\"_\")[0]\n\n        # Set API key attribute as value passed or SETTINGS API key if none passed\n        self.api_key = api_key or SETTINGS.get(\"api_key\", \"\")\n\n        # If an API key is provided\n        if self.api_key:\n            # If the provided API key matches the API key in the SETTINGS\n            if self.api_key == SETTINGS.get(\"api_key\"):\n                # Log that the user is already logged in\n                if verbose:\n                    LOGGER.info(f\"{PREFIX}Authenticated \u2705\")\n                return\n            else:\n                # Attempt to authenticate with the provided API key\n                success = self.authenticate()\n        # If the API key is not provided and the environment is a Google Colab notebook\n        elif is_colab():\n            # Attempt to authenticate using browser cookies\n            success = self.auth_with_cookies()\n        else:\n            # Request an API key\n            success = self.request_api_key()\n\n        # Update SETTINGS with the new API key after successful authentication\n        if success:\n            SETTINGS.update({\"api_key\": self.api_key})\n            # Log that the new login was successful\n            if verbose:\n                LOGGER.info(f\"{PREFIX}New authentication successful \u2705\")\n        elif verbose:\n            LOGGER.info(f\"{PREFIX}Retrieve API key from {API_KEY_URL}\")\n\n    def request_api_key(self, max_attempts=3):\n        \"\"\"\n        Prompt the user to input their API key.\n\n        Returns the model ID.\n        \"\"\"\n        import getpass\n\n        for attempts in range(max_attempts):\n            LOGGER.info(f\"{PREFIX}Login. Attempt {attempts + 1} of {max_attempts}\")\n            input_key = getpass.getpass(f\"Enter API key from {API_KEY_URL} \")\n            self.api_key = input_key.split(\"_\")[0]  # remove model id if present\n            if self.authenticate():\n                return True\n        raise ConnectionError(emojis(f\"{PREFIX}Failed to authenticate \u274c\"))\n\n    def authenticate(self) -&gt; bool:\n        \"\"\"\n        Attempt to authenticate with the server using either id_token or API key.\n\n        Returns:\n            bool: True if authentication is successful, False otherwise.\n        \"\"\"\n        try:\n            if header := self.get_auth_header():\n                r = requests.post(f\"{HUB_API_ROOT}/v1/auth\", headers=header)\n                if not r.json().get(\"success\", False):\n                    raise ConnectionError(\"Unable to authenticate.\")\n                return True\n            raise ConnectionError(\"User has not authenticated locally.\")\n        except ConnectionError:\n            self.id_token = self.api_key = False  # reset invalid\n            LOGGER.warning(f\"{PREFIX}Invalid API key \u26a0\ufe0f\")\n            return False\n\n    def auth_with_cookies(self) -&gt; bool:\n        \"\"\"\n        Attempt to fetch authentication via cookies and set id_token. User must be logged in to HUB and running in a\n        supported browser.\n\n        Returns:\n            bool: True if authentication is successful, False otherwise.\n        \"\"\"\n        if not is_colab():\n            return False  # Currently only works with Colab\n        try:\n            authn = request_with_credentials(f\"{HUB_API_ROOT}/v1/auth/auto\")\n            if authn.get(\"success\", False):\n                self.id_token = authn.get(\"data\", {}).get(\"idToken\", None)\n                self.authenticate()\n                return True\n            raise ConnectionError(\"Unable to fetch browser authentication details.\")\n        except ConnectionError:\n            self.id_token = False  # reset invalid\n            return False\n\n    def get_auth_header(self):\n        \"\"\"\n        Get the authentication header for making API requests.\n\n        Returns:\n            (dict): The authentication header if id_token or API key is set, None otherwise.\n        \"\"\"\n        if self.id_token:\n            return {\"authorization\": f\"Bearer {self.id_token}\"}\n        elif self.api_key:\n            return {\"x-api-key\": self.api_key}\n</code></pre>"},{"location":"reference/hub/auth/#ultralytics.hub.auth.Auth.__init__","title":"<code>__init__(api_key='', verbose=False)</code>","text":"<p>Initialize the Auth class with an optional API key.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>May be an API key or a combination API key and model ID, i.e. key_id</p> <code>''</code> Source code in <code>ultralytics/hub/auth.py</code> <pre><code>def __init__(self, api_key=\"\", verbose=False):\n    \"\"\"\n    Initialize the Auth class with an optional API key.\n\n    Args:\n        api_key (str, optional): May be an API key or a combination API key and model ID, i.e. key_id\n    \"\"\"\n    # Split the input API key in case it contains a combined key_model and keep only the API key part\n    api_key = api_key.split(\"_\")[0]\n\n    # Set API key attribute as value passed or SETTINGS API key if none passed\n    self.api_key = api_key or SETTINGS.get(\"api_key\", \"\")\n\n    # If an API key is provided\n    if self.api_key:\n        # If the provided API key matches the API key in the SETTINGS\n        if self.api_key == SETTINGS.get(\"api_key\"):\n            # Log that the user is already logged in\n            if verbose:\n                LOGGER.info(f\"{PREFIX}Authenticated \u2705\")\n            return\n        else:\n            # Attempt to authenticate with the provided API key\n            success = self.authenticate()\n    # If the API key is not provided and the environment is a Google Colab notebook\n    elif is_colab():\n        # Attempt to authenticate using browser cookies\n        success = self.auth_with_cookies()\n    else:\n        # Request an API key\n        success = self.request_api_key()\n\n    # Update SETTINGS with the new API key after successful authentication\n    if success:\n        SETTINGS.update({\"api_key\": self.api_key})\n        # Log that the new login was successful\n        if verbose:\n            LOGGER.info(f\"{PREFIX}New authentication successful \u2705\")\n    elif verbose:\n        LOGGER.info(f\"{PREFIX}Retrieve API key from {API_KEY_URL}\")\n</code></pre>"},{"location":"reference/hub/auth/#ultralytics.hub.auth.Auth.auth_with_cookies","title":"<code>auth_with_cookies()</code>","text":"<p>Attempt to fetch authentication via cookies and set id_token. User must be logged in to HUB and running in a supported browser.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if authentication is successful, False otherwise.</p> Source code in <code>ultralytics/hub/auth.py</code> <pre><code>def auth_with_cookies(self) -&gt; bool:\n    \"\"\"\n    Attempt to fetch authentication via cookies and set id_token. User must be logged in to HUB and running in a\n    supported browser.\n\n    Returns:\n        bool: True if authentication is successful, False otherwise.\n    \"\"\"\n    if not is_colab():\n        return False  # Currently only works with Colab\n    try:\n        authn = request_with_credentials(f\"{HUB_API_ROOT}/v1/auth/auto\")\n        if authn.get(\"success\", False):\n            self.id_token = authn.get(\"data\", {}).get(\"idToken\", None)\n            self.authenticate()\n            return True\n        raise ConnectionError(\"Unable to fetch browser authentication details.\")\n    except ConnectionError:\n        self.id_token = False  # reset invalid\n        return False\n</code></pre>"},{"location":"reference/hub/auth/#ultralytics.hub.auth.Auth.authenticate","title":"<code>authenticate()</code>","text":"<p>Attempt to authenticate with the server using either id_token or API key.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if authentication is successful, False otherwise.</p> Source code in <code>ultralytics/hub/auth.py</code> <pre><code>def authenticate(self) -&gt; bool:\n    \"\"\"\n    Attempt to authenticate with the server using either id_token or API key.\n\n    Returns:\n        bool: True if authentication is successful, False otherwise.\n    \"\"\"\n    try:\n        if header := self.get_auth_header():\n            r = requests.post(f\"{HUB_API_ROOT}/v1/auth\", headers=header)\n            if not r.json().get(\"success\", False):\n                raise ConnectionError(\"Unable to authenticate.\")\n            return True\n        raise ConnectionError(\"User has not authenticated locally.\")\n    except ConnectionError:\n        self.id_token = self.api_key = False  # reset invalid\n        LOGGER.warning(f\"{PREFIX}Invalid API key \u26a0\ufe0f\")\n        return False\n</code></pre>"},{"location":"reference/hub/auth/#ultralytics.hub.auth.Auth.get_auth_header","title":"<code>get_auth_header()</code>","text":"<p>Get the authentication header for making API requests.</p> <p>Returns:</p> Type Description <code>dict</code> <p>The authentication header if id_token or API key is set, None otherwise.</p> Source code in <code>ultralytics/hub/auth.py</code> <pre><code>def get_auth_header(self):\n    \"\"\"\n    Get the authentication header for making API requests.\n\n    Returns:\n        (dict): The authentication header if id_token or API key is set, None otherwise.\n    \"\"\"\n    if self.id_token:\n        return {\"authorization\": f\"Bearer {self.id_token}\"}\n    elif self.api_key:\n        return {\"x-api-key\": self.api_key}\n</code></pre>"},{"location":"reference/hub/auth/#ultralytics.hub.auth.Auth.request_api_key","title":"<code>request_api_key(max_attempts=3)</code>","text":"<p>Prompt the user to input their API key.</p> <p>Returns the model ID.</p> Source code in <code>ultralytics/hub/auth.py</code> <pre><code>def request_api_key(self, max_attempts=3):\n    \"\"\"\n    Prompt the user to input their API key.\n\n    Returns the model ID.\n    \"\"\"\n    import getpass\n\n    for attempts in range(max_attempts):\n        LOGGER.info(f\"{PREFIX}Login. Attempt {attempts + 1} of {max_attempts}\")\n        input_key = getpass.getpass(f\"Enter API key from {API_KEY_URL} \")\n        self.api_key = input_key.split(\"_\")[0]  # remove model id if present\n        if self.authenticate():\n            return True\n    raise ConnectionError(emojis(f\"{PREFIX}Failed to authenticate \u274c\"))\n</code></pre>"},{"location":"reference/hub/session/","title":"Reference for <code>ultralytics/hub/session.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/hub/session.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/hub/session/#ultralytics.hub.session.HUBTrainingSession","title":"<code>ultralytics.hub.session.HUBTrainingSession</code>","text":"<p>HUB training session for Ultralytics HUB YOLO models. Handles model initialization, heartbeats, and checkpointing.</p> <p>Attributes:</p> Name Type Description <code>agent_id</code> <code>str</code> <p>Identifier for the instance communicating with the server.</p> <code>model_id</code> <code>str</code> <p>Identifier for the YOLO model being trained.</p> <code>model_url</code> <code>str</code> <p>URL for the model in Ultralytics HUB.</p> <code>api_url</code> <code>str</code> <p>API URL for the model in Ultralytics HUB.</p> <code>auth_header</code> <code>dict</code> <p>Authentication header for the Ultralytics HUB API requests.</p> <code>rate_limits</code> <code>dict</code> <p>Rate limits for different API calls (in seconds).</p> <code>timers</code> <code>dict</code> <p>Timers for rate limiting.</p> <code>metrics_queue</code> <code>dict</code> <p>Queue for the model's metrics.</p> <code>model</code> <code>dict</code> <p>Model data fetched from Ultralytics HUB.</p> <code>alive</code> <code>bool</code> <p>Indicates if the heartbeat loop is active.</p> Source code in <code>ultralytics/hub/session.py</code> <pre><code>class HUBTrainingSession:\n    \"\"\"\n    HUB training session for Ultralytics HUB YOLO models. Handles model initialization, heartbeats, and checkpointing.\n\n    Attributes:\n        agent_id (str): Identifier for the instance communicating with the server.\n        model_id (str): Identifier for the YOLO model being trained.\n        model_url (str): URL for the model in Ultralytics HUB.\n        api_url (str): API URL for the model in Ultralytics HUB.\n        auth_header (dict): Authentication header for the Ultralytics HUB API requests.\n        rate_limits (dict): Rate limits for different API calls (in seconds).\n        timers (dict): Timers for rate limiting.\n        metrics_queue (dict): Queue for the model's metrics.\n        model (dict): Model data fetched from Ultralytics HUB.\n        alive (bool): Indicates if the heartbeat loop is active.\n    \"\"\"\n\n    def __init__(self, identifier):\n        \"\"\"\n        Initialize the HUBTrainingSession with the provided model identifier.\n\n        Args:\n            identifier (str): Model identifier used to initialize the HUB training session.\n                It can be a URL string or a model key with specific format.\n\n        Raises:\n            ValueError: If the provided model identifier is invalid.\n            ConnectionError: If connecting with global API key is not supported.\n        \"\"\"\n        self.rate_limits = {\n            \"metrics\": 3.0,\n            \"ckpt\": 900.0,\n            \"heartbeat\": 300.0,\n        }  # rate limits (seconds)\n        self.metrics_queue = {}  # holds metrics for each epoch until upload\n        self.timers = {}  # holds timers in ultralytics/utils/callbacks/hub.py\n\n        # Parse input\n        api_key, model_id, self.filename = self._parse_identifier(identifier)\n\n        # Get credentials\n        active_key = api_key or SETTINGS.get(\"api_key\")\n        credentials = {\"api_key\": active_key} if active_key else None  # set credentials\n\n        # Initialize client\n        self.client = HUBClient(credentials)\n\n        if model_id:\n            self.load_model(model_id)  # load existing model\n        else:\n            self.model = self.client.model()  # load empty model\n\n    def load_model(self, model_id):\n        # Initialize model\n        self.model = self.client.model(model_id)\n        self.model_url = f\"{HUB_WEB_ROOT}/models/{self.model.id}\"\n\n        self._set_train_args()\n\n        # Start heartbeats for HUB to monitor agent\n        self.model.start_heartbeat(self.rate_limits[\"heartbeat\"])\n        LOGGER.info(f\"{PREFIX}View model at {self.model_url} \ud83d\ude80\")\n\n    def create_model(self, model_args):\n        # Initialize model\n        payload = {\n            \"config\": {\n                \"batchSize\": model_args.get(\"batch\", -1),\n                \"epochs\": model_args.get(\"epochs\", 300),\n                \"imageSize\": model_args.get(\"imgsz\", 640),\n                \"patience\": model_args.get(\"patience\", 100),\n                \"device\": model_args.get(\"device\", \"\"),\n                \"cache\": model_args.get(\"cache\", \"ram\"),\n            },\n            \"dataset\": {\"name\": model_args.get(\"data\")},\n            \"lineage\": {\n                \"architecture\": {\n                    \"name\": self.filename.replace(\".pt\", \"\").replace(\".yaml\", \"\"),\n                },\n                \"parent\": {},\n            },\n            \"meta\": {\"name\": self.filename},\n        }\n\n        if self.filename.endswith(\".pt\"):\n            payload[\"lineage\"][\"parent\"][\"name\"] = self.filename\n\n        self.model.create_model(payload)\n\n        # Model could not be created\n        # TODO: improve error handling\n        if not self.model.id:\n            return\n\n        self.model_url = f\"{HUB_WEB_ROOT}/models/{self.model.id}\"\n\n        # Start heartbeats for HUB to monitor agent\n        self.model.start_heartbeat(self.rate_limits[\"heartbeat\"])\n\n        LOGGER.info(f\"{PREFIX}View model at {self.model_url} \ud83d\ude80\")\n\n    def _parse_identifier(self, identifier):\n        \"\"\"\n        Parses the given identifier to determine the type of identifier and extract relevant components.\n\n        The method supports different identifier formats:\n            - A HUB URL, which starts with HUB_WEB_ROOT followed by '/models/'\n            - An identifier containing an API key and a model ID separated by an underscore\n            - An identifier that is solely a model ID of a fixed length\n            - A local filename that ends with '.pt' or '.yaml'\n\n        Args:\n            identifier (str): The identifier string to be parsed.\n\n        Returns:\n            (tuple): A tuple containing the API key, model ID, and filename as applicable.\n\n        Raises:\n            HUBModelError: If the identifier format is not recognized.\n        \"\"\"\n\n        # Initialize variables\n        api_key, model_id, filename = None, None, None\n\n        # Check if identifier is a HUB URL\n        if identifier.startswith(f\"{HUB_WEB_ROOT}/models/\"):\n            # Extract the model_id after the HUB_WEB_ROOT URL\n            model_id = identifier.split(f\"{HUB_WEB_ROOT}/models/\")[-1]\n        else:\n            # Split the identifier based on underscores only if it's not a HUB URL\n            parts = identifier.split(\"_\")\n\n            # Check if identifier is in the format of API key and model ID\n            if len(parts) == 2 and len(parts[0]) == 42 and len(parts[1]) == 20:\n                api_key, model_id = parts\n            # Check if identifier is a single model ID\n            elif len(parts) == 1 and len(parts[0]) == 20:\n                model_id = parts[0]\n            # Check if identifier is a local filename\n            elif identifier.endswith(\".pt\") or identifier.endswith(\".yaml\"):\n                filename = identifier\n            else:\n                raise HUBModelError(\n                    f\"model='{identifier}' could not be parsed. Check format is correct. \"\n                    f\"Supported formats are Ultralytics HUB URL, apiKey_modelId, modelId, local pt or yaml file.\"\n                )\n\n        return api_key, model_id, filename\n\n    def _set_train_args(self, **kwargs):\n        if self.model.is_trained():\n            # Model is already trained\n            raise ValueError(emojis(f\"Model is already trained and uploaded to {self.model_url} \ud83d\ude80\"))\n\n        if self.model.is_resumable():\n            # Model has saved weights\n            self.train_args = {\"data\": self.model.get_dataset_url(), \"resume\": True}\n            self.model_file = self.model.get_weights_url(\"last\")\n        else:\n            # Model has no saved weights\n            def get_train_args(config):\n                return {\n                    \"batch\": config[\"batchSize\"],\n                    \"epochs\": config[\"epochs\"],\n                    \"imgsz\": config[\"imageSize\"],\n                    \"patience\": config[\"patience\"],\n                    \"device\": config[\"device\"],\n                    \"cache\": config[\"cache\"],\n                    \"data\": self.model.get_dataset_url(),\n                }\n\n            self.train_args = get_train_args(self.model.data.get(\"config\"))\n            # Set the model file as either a *.pt or *.yaml file\n            self.model_file = (\n                self.model.get_weights_url(\"parent\") if self.model.is_pretrained() else self.model.get_architecture()\n            )\n\n        if not self.train_args.get(\"data\"):\n            raise ValueError(\"Dataset may still be processing. Please wait a minute and try again.\")  # RF fix\n\n        self.model_file = checks.check_yolov5u_filename(self.model_file, verbose=False)  # YOLOv5-&gt;YOLOv5u\n        self.model_id = self.model.id\n\n    def request_queue(\n        self,\n        request_func,\n        retry=3,\n        timeout=30,\n        thread=True,\n        verbose=True,\n        progress_total=None,\n        *args,\n        **kwargs,\n    ):\n        def retry_request():\n            t0 = time.time()  # Record the start time for the timeout\n            for i in range(retry + 1):\n                if (time.time() - t0) &gt; timeout:\n                    LOGGER.warning(f\"{PREFIX}Timeout for request reached. {HELP_MSG}\")\n                    break  # Timeout reached, exit loop\n\n                response = request_func(*args, **kwargs)\n                if progress_total:\n                    self._show_upload_progress(progress_total, response)\n\n                if response is None:\n                    LOGGER.warning(f\"{PREFIX}Received no response from the request. {HELP_MSG}\")\n                    time.sleep(2**i)  # Exponential backoff before retrying\n                    continue  # Skip further processing and retry\n\n                if HTTPStatus.OK &lt;= response.status_code &lt; HTTPStatus.MULTIPLE_CHOICES:\n                    return response  # Success, no need to retry\n\n                if i == 0:\n                    # Initial attempt, check status code and provide messages\n                    message = self._get_failure_message(response, retry, timeout)\n\n                    if verbose:\n                        LOGGER.warning(f\"{PREFIX}{message} {HELP_MSG} ({response.status_code})\")\n\n                if not self._should_retry(response.status_code):\n                    LOGGER.warning(f\"{PREFIX}Request failed. {HELP_MSG} ({response.status_code}\")\n                    break  # Not an error that should be retried, exit loop\n\n                time.sleep(2**i)  # Exponential backoff for retries\n\n            return response\n\n        if thread:\n            # Start a new thread to run the retry_request function\n            threading.Thread(target=retry_request, daemon=True).start()\n        else:\n            # If running in the main thread, call retry_request directly\n            return retry_request()\n\n    def _should_retry(self, status_code):\n        # Status codes that trigger retries\n        retry_codes = {\n            HTTPStatus.REQUEST_TIMEOUT,\n            HTTPStatus.BAD_GATEWAY,\n            HTTPStatus.GATEWAY_TIMEOUT,\n        }\n        return True if status_code in retry_codes else False\n\n    def _get_failure_message(self, response: requests.Response, retry: int, timeout: int):\n        \"\"\"\n        Generate a retry message based on the response status code.\n\n        Args:\n            response: The HTTP response object.\n            retry: The number of retry attempts allowed.\n            timeout: The maximum timeout duration.\n\n        Returns:\n            str: The retry message.\n        \"\"\"\n        if self._should_retry(response.status_code):\n            return f\"Retrying {retry}x for {timeout}s.\" if retry else \"\"\n        elif response.status_code == HTTPStatus.TOO_MANY_REQUESTS:  # rate limit\n            headers = response.headers\n            return (\n                f\"Rate limit reached ({headers['X-RateLimit-Remaining']}/{headers['X-RateLimit-Limit']}). \"\n                f\"Please retry after {headers['Retry-After']}s.\"\n            )\n        else:\n            try:\n                return response.json().get(\"message\", \"No JSON message.\")\n            except AttributeError:\n                return \"Unable to read JSON.\"\n\n    def upload_metrics(self):\n        \"\"\"Upload model metrics to Ultralytics HUB.\"\"\"\n        return self.request_queue(self.model.upload_metrics, metrics=self.metrics_queue.copy(), thread=True)\n\n    def upload_model(\n        self,\n        epoch: int,\n        weights: str,\n        is_best: bool = False,\n        map: float = 0.0,\n        final: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Upload a model checkpoint to Ultralytics HUB.\n\n        Args:\n            epoch (int): The current training epoch.\n            weights (str): Path to the model weights file.\n            is_best (bool): Indicates if the current model is the best one so far.\n            map (float): Mean average precision of the model.\n            final (bool): Indicates if the model is the final model after training.\n        \"\"\"\n        if Path(weights).is_file():\n            progress_total = Path(weights).stat().st_size if final else None  # Only show progress if final\n            self.request_queue(\n                self.model.upload_model,\n                epoch=epoch,\n                weights=weights,\n                is_best=is_best,\n                map=map,\n                final=final,\n                retry=10,\n                timeout=3600,\n                thread=not final,\n                progress_total=progress_total,\n            )\n        else:\n            LOGGER.warning(f\"{PREFIX}WARNING \u26a0\ufe0f Model upload issue. Missing model {weights}.\")\n\n    def _show_upload_progress(self, content_length: int, response: requests.Response) -&gt; None:\n        \"\"\"\n        Display a progress bar to track the upload progress of a file download.\n\n        Args:\n            content_length (int): The total size of the content to be downloaded in bytes.\n            response (requests.Response): The response object from the file download request.\n\n        Returns:\n            (None)\n        \"\"\"\n        with TQDM(total=content_length, unit=\"B\", unit_scale=True, unit_divisor=1024) as pbar:\n            for data in response.iter_content(chunk_size=1024):\n                pbar.update(len(data))\n</code></pre>"},{"location":"reference/hub/session/#ultralytics.hub.session.HUBTrainingSession.__init__","title":"<code>__init__(identifier)</code>","text":"<p>Initialize the HUBTrainingSession with the provided model identifier.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>str</code> <p>Model identifier used to initialize the HUB training session. It can be a URL string or a model key with specific format.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided model identifier is invalid.</p> <code>ConnectionError</code> <p>If connecting with global API key is not supported.</p> Source code in <code>ultralytics/hub/session.py</code> <pre><code>def __init__(self, identifier):\n    \"\"\"\n    Initialize the HUBTrainingSession with the provided model identifier.\n\n    Args:\n        identifier (str): Model identifier used to initialize the HUB training session.\n            It can be a URL string or a model key with specific format.\n\n    Raises:\n        ValueError: If the provided model identifier is invalid.\n        ConnectionError: If connecting with global API key is not supported.\n    \"\"\"\n    self.rate_limits = {\n        \"metrics\": 3.0,\n        \"ckpt\": 900.0,\n        \"heartbeat\": 300.0,\n    }  # rate limits (seconds)\n    self.metrics_queue = {}  # holds metrics for each epoch until upload\n    self.timers = {}  # holds timers in ultralytics/utils/callbacks/hub.py\n\n    # Parse input\n    api_key, model_id, self.filename = self._parse_identifier(identifier)\n\n    # Get credentials\n    active_key = api_key or SETTINGS.get(\"api_key\")\n    credentials = {\"api_key\": active_key} if active_key else None  # set credentials\n\n    # Initialize client\n    self.client = HUBClient(credentials)\n\n    if model_id:\n        self.load_model(model_id)  # load existing model\n    else:\n        self.model = self.client.model()  # load empty model\n</code></pre>"},{"location":"reference/hub/session/#ultralytics.hub.session.HUBTrainingSession.upload_metrics","title":"<code>upload_metrics()</code>","text":"<p>Upload model metrics to Ultralytics HUB.</p> Source code in <code>ultralytics/hub/session.py</code> <pre><code>def upload_metrics(self):\n    \"\"\"Upload model metrics to Ultralytics HUB.\"\"\"\n    return self.request_queue(self.model.upload_metrics, metrics=self.metrics_queue.copy(), thread=True)\n</code></pre>"},{"location":"reference/hub/session/#ultralytics.hub.session.HUBTrainingSession.upload_model","title":"<code>upload_model(epoch, weights, is_best=False, map=0.0, final=False)</code>","text":"<p>Upload a model checkpoint to Ultralytics HUB.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>int</code> <p>The current training epoch.</p> required <code>weights</code> <code>str</code> <p>Path to the model weights file.</p> required <code>is_best</code> <code>bool</code> <p>Indicates if the current model is the best one so far.</p> <code>False</code> <code>map</code> <code>float</code> <p>Mean average precision of the model.</p> <code>0.0</code> <code>final</code> <code>bool</code> <p>Indicates if the model is the final model after training.</p> <code>False</code> Source code in <code>ultralytics/hub/session.py</code> <pre><code>def upload_model(\n    self,\n    epoch: int,\n    weights: str,\n    is_best: bool = False,\n    map: float = 0.0,\n    final: bool = False,\n) -&gt; None:\n    \"\"\"\n    Upload a model checkpoint to Ultralytics HUB.\n\n    Args:\n        epoch (int): The current training epoch.\n        weights (str): Path to the model weights file.\n        is_best (bool): Indicates if the current model is the best one so far.\n        map (float): Mean average precision of the model.\n        final (bool): Indicates if the model is the final model after training.\n    \"\"\"\n    if Path(weights).is_file():\n        progress_total = Path(weights).stat().st_size if final else None  # Only show progress if final\n        self.request_queue(\n            self.model.upload_model,\n            epoch=epoch,\n            weights=weights,\n            is_best=is_best,\n            map=map,\n            final=final,\n            retry=10,\n            timeout=3600,\n            thread=not final,\n            progress_total=progress_total,\n        )\n    else:\n        LOGGER.warning(f\"{PREFIX}WARNING \u26a0\ufe0f Model upload issue. Missing model {weights}.\")\n</code></pre>"},{"location":"reference/hub/utils/","title":"Reference for <code>ultralytics/hub/utils.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/hub/utils.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/hub/utils/#ultralytics.hub.utils.Events","title":"<code>ultralytics.hub.utils.Events</code>","text":"<p>A class for collecting anonymous event analytics. Event analytics are enabled when sync=True in settings and disabled when sync=False. Run 'yolo settings' to see and update settings YAML file.</p> <p>Attributes:</p> Name Type Description <code>url</code> <code>str</code> <p>The URL to send anonymous events.</p> <code>rate_limit</code> <code>float</code> <p>The rate limit in seconds for sending events.</p> <code>metadata</code> <code>dict</code> <p>A dictionary containing metadata about the environment.</p> <code>enabled</code> <code>bool</code> <p>A flag to enable or disable Events based on certain conditions.</p> Source code in <code>ultralytics/hub/utils.py</code> <pre><code>class Events:\n    \"\"\"\n    A class for collecting anonymous event analytics. Event analytics are enabled when sync=True in settings and\n    disabled when sync=False. Run 'yolo settings' to see and update settings YAML file.\n\n    Attributes:\n        url (str): The URL to send anonymous events.\n        rate_limit (float): The rate limit in seconds for sending events.\n        metadata (dict): A dictionary containing metadata about the environment.\n        enabled (bool): A flag to enable or disable Events based on certain conditions.\n    \"\"\"\n\n    url = \"https://www.google-analytics.com/mp/collect?measurement_id=G-X8NCJYTQXM&amp;api_secret=QLQrATrNSwGRFRLE-cbHJw\"\n\n    def __init__(self):\n        \"\"\"Initializes the Events object with default values for events, rate_limit, and metadata.\"\"\"\n        self.events = []  # events list\n        self.rate_limit = 60.0  # rate limit (seconds)\n        self.t = 0.0  # rate limit timer (seconds)\n        self.metadata = {\n            \"cli\": Path(sys.argv[0]).name == \"yolo\",\n            \"install\": \"git\" if is_git_dir() else \"pip\" if is_pip_package() else \"other\",\n            \"python\": \".\".join(platform.python_version_tuple()[:2]),  # i.e. 3.10\n            \"version\": __version__,\n            \"env\": ENVIRONMENT,\n            \"session_id\": round(random.random() * 1e15),\n            \"engagement_time_msec\": 1000,\n        }\n        self.enabled = (\n            SETTINGS[\"sync\"]\n            and RANK in (-1, 0)\n            and not TESTS_RUNNING\n            and ONLINE\n            and (is_pip_package() or get_git_origin_url() == \"https://github.com/ultralytics/ultralytics.git\")\n        )\n\n    def __call__(self, cfg):\n        \"\"\"\n        Attempts to add a new event to the events list and send events if the rate limit is reached.\n\n        Args:\n            cfg (IterableSimpleNamespace): The configuration object containing mode and task information.\n        \"\"\"\n        if not self.enabled:\n            # Events disabled, do nothing\n            return\n\n        # Attempt to add to events\n        if len(self.events) &lt; 25:  # Events list limited to 25 events (drop any events past this)\n            params = {\n                **self.metadata,\n                \"task\": cfg.task,\n                \"model\": cfg.model if cfg.model in GITHUB_ASSETS_NAMES else \"custom\",\n            }\n            if cfg.mode == \"export\":\n                params[\"format\"] = cfg.format\n            self.events.append({\"name\": cfg.mode, \"params\": params})\n\n        # Check rate limit\n        t = time.time()\n        if (t - self.t) &lt; self.rate_limit:\n            # Time is under rate limiter, wait to send\n            return\n\n        # Time is over rate limiter, send now\n        data = {\"client_id\": SETTINGS[\"uuid\"], \"events\": self.events}  # SHA-256 anonymized UUID hash and events list\n\n        # POST equivalent to requests.post(self.url, json=data)\n        smart_request(\"post\", self.url, json=data, retry=0, verbose=False)\n\n        # Reset events and rate limit timer\n        self.events = []\n        self.t = t\n</code></pre>"},{"location":"reference/hub/utils/#ultralytics.hub.utils.Events.__call__","title":"<code>__call__(cfg)</code>","text":"<p>Attempts to add a new event to the events list and send events if the rate limit is reached.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>IterableSimpleNamespace</code> <p>The configuration object containing mode and task information.</p> required Source code in <code>ultralytics/hub/utils.py</code> <pre><code>def __call__(self, cfg):\n    \"\"\"\n    Attempts to add a new event to the events list and send events if the rate limit is reached.\n\n    Args:\n        cfg (IterableSimpleNamespace): The configuration object containing mode and task information.\n    \"\"\"\n    if not self.enabled:\n        # Events disabled, do nothing\n        return\n\n    # Attempt to add to events\n    if len(self.events) &lt; 25:  # Events list limited to 25 events (drop any events past this)\n        params = {\n            **self.metadata,\n            \"task\": cfg.task,\n            \"model\": cfg.model if cfg.model in GITHUB_ASSETS_NAMES else \"custom\",\n        }\n        if cfg.mode == \"export\":\n            params[\"format\"] = cfg.format\n        self.events.append({\"name\": cfg.mode, \"params\": params})\n\n    # Check rate limit\n    t = time.time()\n    if (t - self.t) &lt; self.rate_limit:\n        # Time is under rate limiter, wait to send\n        return\n\n    # Time is over rate limiter, send now\n    data = {\"client_id\": SETTINGS[\"uuid\"], \"events\": self.events}  # SHA-256 anonymized UUID hash and events list\n\n    # POST equivalent to requests.post(self.url, json=data)\n    smart_request(\"post\", self.url, json=data, retry=0, verbose=False)\n\n    # Reset events and rate limit timer\n    self.events = []\n    self.t = t\n</code></pre>"},{"location":"reference/hub/utils/#ultralytics.hub.utils.Events.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the Events object with default values for events, rate_limit, and metadata.</p> Source code in <code>ultralytics/hub/utils.py</code> <pre><code>def __init__(self):\n    \"\"\"Initializes the Events object with default values for events, rate_limit, and metadata.\"\"\"\n    self.events = []  # events list\n    self.rate_limit = 60.0  # rate limit (seconds)\n    self.t = 0.0  # rate limit timer (seconds)\n    self.metadata = {\n        \"cli\": Path(sys.argv[0]).name == \"yolo\",\n        \"install\": \"git\" if is_git_dir() else \"pip\" if is_pip_package() else \"other\",\n        \"python\": \".\".join(platform.python_version_tuple()[:2]),  # i.e. 3.10\n        \"version\": __version__,\n        \"env\": ENVIRONMENT,\n        \"session_id\": round(random.random() * 1e15),\n        \"engagement_time_msec\": 1000,\n    }\n    self.enabled = (\n        SETTINGS[\"sync\"]\n        and RANK in (-1, 0)\n        and not TESTS_RUNNING\n        and ONLINE\n        and (is_pip_package() or get_git_origin_url() == \"https://github.com/ultralytics/ultralytics.git\")\n    )\n</code></pre>"},{"location":"reference/hub/utils/#ultralytics.hub.utils.request_with_credentials","title":"<code>ultralytics.hub.utils.request_with_credentials(url)</code>","text":"<p>Make an AJAX request with cookies attached in a Google Colab environment.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to make the request to.</p> required <p>Returns:</p> Type Description <code>any</code> <p>The response data from the AJAX request.</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the function is not run in a Google Colab environment.</p> Source code in <code>ultralytics/hub/utils.py</code> <pre><code>def request_with_credentials(url: str) -&gt; any:\n    \"\"\"\n    Make an AJAX request with cookies attached in a Google Colab environment.\n\n    Args:\n        url (str): The URL to make the request to.\n\n    Returns:\n        (any): The response data from the AJAX request.\n\n    Raises:\n        OSError: If the function is not run in a Google Colab environment.\n    \"\"\"\n    if not is_colab():\n        raise OSError(\"request_with_credentials() must run in a Colab environment\")\n    from google.colab import output  # noqa\n    from IPython import display  # noqa\n\n    display.display(\n        display.Javascript(\n            \"\"\"\n            window._hub_tmp = new Promise((resolve, reject) =&gt; {\n                const timeout = setTimeout(() =&gt; reject(\"Failed authenticating existing browser session\"), 5000)\n                fetch(\"%s\", {\n                    method: 'POST',\n                    credentials: 'include'\n                })\n                    .then((response) =&gt; resolve(response.json()))\n                    .then((json) =&gt; {\n                    clearTimeout(timeout);\n                    }).catch((err) =&gt; {\n                    clearTimeout(timeout);\n                    reject(err);\n                });\n            });\n            \"\"\"\n            % url\n        )\n    )\n    return output.eval_js(\"_hub_tmp\")\n</code></pre>"},{"location":"reference/hub/utils/#ultralytics.hub.utils.requests_with_progress","title":"<code>ultralytics.hub.utils.requests_with_progress(method, url, **kwargs)</code>","text":"<p>Make an HTTP request using the specified method and URL, with an optional progress bar.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The HTTP method to use (e.g. 'GET', 'POST').</p> required <code>url</code> <code>str</code> <p>The URL to send the request to.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to pass to the underlying <code>requests.request</code> function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>The response object from the HTTP request.</p> Note <ul> <li>If 'progress' is set to True, the progress bar will display the download progress for responses with a known content length.</li> <li>If 'progress' is a number then progress bar will display assuming content length = progress.</li> </ul> Source code in <code>ultralytics/hub/utils.py</code> <pre><code>def requests_with_progress(method, url, **kwargs):\n    \"\"\"\n    Make an HTTP request using the specified method and URL, with an optional progress bar.\n\n    Args:\n        method (str): The HTTP method to use (e.g. 'GET', 'POST').\n        url (str): The URL to send the request to.\n        **kwargs (dict): Additional keyword arguments to pass to the underlying `requests.request` function.\n\n    Returns:\n        (requests.Response): The response object from the HTTP request.\n\n    Note:\n        - If 'progress' is set to True, the progress bar will display the download progress for responses with a known\n        content length.\n        - If 'progress' is a number then progress bar will display assuming content length = progress.\n    \"\"\"\n    progress = kwargs.pop(\"progress\", False)\n    if not progress:\n        return requests.request(method, url, **kwargs)\n    response = requests.request(method, url, stream=True, **kwargs)\n    total = int(response.headers.get(\"content-length\", 0) if isinstance(progress, bool) else progress)  # total size\n    try:\n        pbar = TQDM(total=total, unit=\"B\", unit_scale=True, unit_divisor=1024)\n        for data in response.iter_content(chunk_size=1024):\n            pbar.update(len(data))\n        pbar.close()\n    except requests.exceptions.ChunkedEncodingError:  # avoid 'Connection broken: IncompleteRead' warnings\n        response.close()\n    return response\n</code></pre>"},{"location":"reference/hub/utils/#ultralytics.hub.utils.smart_request","title":"<code>ultralytics.hub.utils.smart_request(method, url, retry=3, timeout=30, thread=True, code=-1, verbose=True, progress=False, **kwargs)</code>","text":"<p>Makes an HTTP request using the 'requests' library, with exponential backoff retries up to a specified timeout.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The HTTP method to use for the request. Choices are 'post' and 'get'.</p> required <code>url</code> <code>str</code> <p>The URL to make the request to.</p> required <code>retry</code> <code>int</code> <p>Number of retries to attempt before giving up. Default is 3.</p> <code>3</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds after which the function will give up retrying. Default is 30.</p> <code>30</code> <code>thread</code> <code>bool</code> <p>Whether to execute the request in a separate daemon thread. Default is True.</p> <code>True</code> <code>code</code> <code>int</code> <p>An identifier for the request, used for logging purposes. Default is -1.</p> <code>-1</code> <code>verbose</code> <code>bool</code> <p>A flag to determine whether to print out to console or not. Default is True.</p> <code>True</code> <code>progress</code> <code>bool</code> <p>Whether to show a progress bar during the request. Default is False.</p> <code>False</code> <code>**kwargs</code> <code>dict</code> <p>Keyword arguments to be passed to the requests function specified in method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>The HTTP response object. If the request is executed in a separate thread, returns None.</p> Source code in <code>ultralytics/hub/utils.py</code> <pre><code>def smart_request(method, url, retry=3, timeout=30, thread=True, code=-1, verbose=True, progress=False, **kwargs):\n    \"\"\"\n    Makes an HTTP request using the 'requests' library, with exponential backoff retries up to a specified timeout.\n\n    Args:\n        method (str): The HTTP method to use for the request. Choices are 'post' and 'get'.\n        url (str): The URL to make the request to.\n        retry (int, optional): Number of retries to attempt before giving up. Default is 3.\n        timeout (int, optional): Timeout in seconds after which the function will give up retrying. Default is 30.\n        thread (bool, optional): Whether to execute the request in a separate daemon thread. Default is True.\n        code (int, optional): An identifier for the request, used for logging purposes. Default is -1.\n        verbose (bool, optional): A flag to determine whether to print out to console or not. Default is True.\n        progress (bool, optional): Whether to show a progress bar during the request. Default is False.\n        **kwargs (dict): Keyword arguments to be passed to the requests function specified in method.\n\n    Returns:\n        (requests.Response): The HTTP response object. If the request is executed in a separate thread, returns None.\n    \"\"\"\n    retry_codes = (408, 500)  # retry only these codes\n\n    @TryExcept(verbose=verbose)\n    def func(func_method, func_url, **func_kwargs):\n        \"\"\"Make HTTP requests with retries and timeouts, with optional progress tracking.\"\"\"\n        r = None  # response\n        t0 = time.time()  # initial time for timer\n        for i in range(retry + 1):\n            if (time.time() - t0) &gt; timeout:\n                break\n            r = requests_with_progress(func_method, func_url, **func_kwargs)  # i.e. get(url, data, json, files)\n            if r.status_code &lt; 300:  # return codes in the 2xx range are generally considered \"good\" or \"successful\"\n                break\n            try:\n                m = r.json().get(\"message\", \"No JSON message.\")\n            except AttributeError:\n                m = \"Unable to read JSON.\"\n            if i == 0:\n                if r.status_code in retry_codes:\n                    m += f\" Retrying {retry}x for {timeout}s.\" if retry else \"\"\n                elif r.status_code == 429:  # rate limit\n                    h = r.headers  # response headers\n                    m = (\n                        f\"Rate limit reached ({h['X-RateLimit-Remaining']}/{h['X-RateLimit-Limit']}). \"\n                        f\"Please retry after {h['Retry-After']}s.\"\n                    )\n                if verbose:\n                    LOGGER.warning(f\"{PREFIX}{m} {HELP_MSG} ({r.status_code} #{code})\")\n                if r.status_code not in retry_codes:\n                    return r\n            time.sleep(2**i)  # exponential standoff\n        return r\n\n    args = method, url\n    kwargs[\"progress\"] = progress\n    if thread:\n        threading.Thread(target=func, args=args, kwargs=kwargs, daemon=True).start()\n    else:\n        return func(*args, **kwargs)\n</code></pre>"},{"location":"reference/models/fastsam/model/","title":"Reference for <code>ultralytics/models/fastsam/model.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/fastsam/model.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/fastsam/model/#ultralytics.models.fastsam.model.FastSAM","title":"<code>ultralytics.models.fastsam.model.FastSAM</code>","text":"<p>             Bases: <code>Model</code></p> <p>FastSAM model interface.</p> Example <pre><code>from ultralytics import FastSAM\n\nmodel = FastSAM('last.pt')\nresults = model.predict('ultralytics/assets/bus.jpg')\n</code></pre> Source code in <code>ultralytics/models/fastsam/model.py</code> <pre><code>class FastSAM(Model):\n    \"\"\"\n    FastSAM model interface.\n\n    Example:\n        ```python\n        from ultralytics import FastSAM\n\n        model = FastSAM('last.pt')\n        results = model.predict('ultralytics/assets/bus.jpg')\n        ```\n    \"\"\"\n\n    def __init__(self, model=\"FastSAM-x.pt\"):\n        \"\"\"Call the __init__ method of the parent class (YOLO) with the updated default model.\"\"\"\n        if str(model) == \"FastSAM.pt\":\n            model = \"FastSAM-x.pt\"\n        assert Path(model).suffix not in (\".yaml\", \".yml\"), \"FastSAM models only support pre-trained models.\"\n        super().__init__(model=model, task=\"segment\")\n\n    @property\n    def task_map(self):\n        \"\"\"Returns a dictionary mapping segment task to corresponding predictor and validator classes.\"\"\"\n        return {\"segment\": {\"predictor\": FastSAMPredictor, \"validator\": FastSAMValidator}}\n</code></pre>"},{"location":"reference/models/fastsam/model/#ultralytics.models.fastsam.model.FastSAM.task_map","title":"<code>task_map</code>  <code>property</code>","text":"<p>Returns a dictionary mapping segment task to corresponding predictor and validator classes.</p>"},{"location":"reference/models/fastsam/model/#ultralytics.models.fastsam.model.FastSAM.__init__","title":"<code>__init__(model='FastSAM-x.pt')</code>","text":"<p>Call the init method of the parent class (YOLO) with the updated default model.</p> Source code in <code>ultralytics/models/fastsam/model.py</code> <pre><code>def __init__(self, model=\"FastSAM-x.pt\"):\n    \"\"\"Call the __init__ method of the parent class (YOLO) with the updated default model.\"\"\"\n    if str(model) == \"FastSAM.pt\":\n        model = \"FastSAM-x.pt\"\n    assert Path(model).suffix not in (\".yaml\", \".yml\"), \"FastSAM models only support pre-trained models.\"\n    super().__init__(model=model, task=\"segment\")\n</code></pre>"},{"location":"reference/models/fastsam/predict/","title":"Reference for <code>ultralytics/models/fastsam/predict.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/fastsam/predict.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/fastsam/predict/#ultralytics.models.fastsam.predict.FastSAMPredictor","title":"<code>ultralytics.models.fastsam.predict.FastSAMPredictor</code>","text":"<p>             Bases: <code>DetectionPredictor</code></p> <p>FastSAMPredictor is specialized for fast SAM (Segment Anything Model) segmentation prediction tasks in Ultralytics YOLO framework.</p> <p>This class extends the DetectionPredictor, customizing the prediction pipeline specifically for fast SAM. It adjusts post-processing steps to incorporate mask prediction and non-max suppression while optimizing for single-class segmentation.</p> <p>Attributes:</p> Name Type Description <code>cfg</code> <code>dict</code> <p>Configuration parameters for prediction.</p> <code>overrides</code> <code>dict</code> <p>Optional parameter overrides for custom behavior.</p> <code>_callbacks</code> <code>dict</code> <p>Optional list of callback functions to be invoked during prediction.</p> Source code in <code>ultralytics/models/fastsam/predict.py</code> <pre><code>class FastSAMPredictor(DetectionPredictor):\n    \"\"\"\n    FastSAMPredictor is specialized for fast SAM (Segment Anything Model) segmentation prediction tasks in Ultralytics\n    YOLO framework.\n\n    This class extends the DetectionPredictor, customizing the prediction pipeline specifically for fast SAM.\n    It adjusts post-processing steps to incorporate mask prediction and non-max suppression while optimizing\n    for single-class segmentation.\n\n    Attributes:\n        cfg (dict): Configuration parameters for prediction.\n        overrides (dict, optional): Optional parameter overrides for custom behavior.\n        _callbacks (dict, optional): Optional list of callback functions to be invoked during prediction.\n    \"\"\"\n\n    def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n        \"\"\"\n        Initializes the FastSAMPredictor class, inheriting from DetectionPredictor and setting the task to 'segment'.\n\n        Args:\n            cfg (dict): Configuration parameters for prediction.\n            overrides (dict, optional): Optional parameter overrides for custom behavior.\n            _callbacks (dict, optional): Optional list of callback functions to be invoked during prediction.\n        \"\"\"\n        super().__init__(cfg, overrides, _callbacks)\n        self.args.task = \"segment\"\n\n    def postprocess(self, preds, img, orig_imgs):\n        \"\"\"\n        Perform post-processing steps on predictions, including non-max suppression and scaling boxes to original image\n        size, and returns the final results.\n\n        Args:\n            preds (list): The raw output predictions from the model.\n            img (torch.Tensor): The processed image tensor.\n            orig_imgs (list | torch.Tensor): The original image or list of images.\n\n        Returns:\n            (list): A list of Results objects, each containing processed boxes, masks, and other metadata.\n        \"\"\"\n        p = ops.non_max_suppression(\n            preds[0],\n            self.args.conf,\n            self.args.iou,\n            agnostic=self.args.agnostic_nms,\n            max_det=self.args.max_det,\n            nc=1,  # set to 1 class since SAM has no class predictions\n            classes=self.args.classes,\n        )\n        full_box = torch.zeros(p[0].shape[1], device=p[0].device)\n        full_box[2], full_box[3], full_box[4], full_box[6:] = img.shape[3], img.shape[2], 1.0, 1.0\n        full_box = full_box.view(1, -1)\n        critical_iou_index = bbox_iou(full_box[0][:4], p[0][:, :4], iou_thres=0.9, image_shape=img.shape[2:])\n        if critical_iou_index.numel() != 0:\n            full_box[0][4] = p[0][critical_iou_index][:, 4]\n            full_box[0][6:] = p[0][critical_iou_index][:, 6:]\n            p[0][critical_iou_index] = full_box\n\n        if not isinstance(orig_imgs, list):  # input images are a torch.Tensor, not a list\n            orig_imgs = ops.convert_torch2numpy_batch(orig_imgs)\n\n        results = []\n        proto = preds[1][-1] if len(preds[1]) == 3 else preds[1]  # second output is len 3 if pt, but only 1 if exported\n        for i, pred in enumerate(p):\n            orig_img = orig_imgs[i]\n            img_path = self.batch[0][i]\n            if not len(pred):  # save empty boxes\n                masks = None\n            elif self.args.retina_masks:\n                pred[:, :4] = ops.scale_boxes(img.shape[2:], pred[:, :4], orig_img.shape)\n                masks = ops.process_mask_native(proto[i], pred[:, 6:], pred[:, :4], orig_img.shape[:2])  # HWC\n            else:\n                masks = ops.process_mask(proto[i], pred[:, 6:], pred[:, :4], img.shape[2:], upsample=True)  # HWC\n                pred[:, :4] = ops.scale_boxes(img.shape[2:], pred[:, :4], orig_img.shape)\n            results.append(Results(orig_img, path=img_path, names=self.model.names, boxes=pred[:, :6], masks=masks))\n        return results\n</code></pre>"},{"location":"reference/models/fastsam/predict/#ultralytics.models.fastsam.predict.FastSAMPredictor.__init__","title":"<code>__init__(cfg=DEFAULT_CFG, overrides=None, _callbacks=None)</code>","text":"<p>Initializes the FastSAMPredictor class, inheriting from DetectionPredictor and setting the task to 'segment'.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>dict</code> <p>Configuration parameters for prediction.</p> <code>DEFAULT_CFG</code> <code>overrides</code> <code>dict</code> <p>Optional parameter overrides for custom behavior.</p> <code>None</code> <code>_callbacks</code> <code>dict</code> <p>Optional list of callback functions to be invoked during prediction.</p> <code>None</code> Source code in <code>ultralytics/models/fastsam/predict.py</code> <pre><code>def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n    \"\"\"\n    Initializes the FastSAMPredictor class, inheriting from DetectionPredictor and setting the task to 'segment'.\n\n    Args:\n        cfg (dict): Configuration parameters for prediction.\n        overrides (dict, optional): Optional parameter overrides for custom behavior.\n        _callbacks (dict, optional): Optional list of callback functions to be invoked during prediction.\n    \"\"\"\n    super().__init__(cfg, overrides, _callbacks)\n    self.args.task = \"segment\"\n</code></pre>"},{"location":"reference/models/fastsam/predict/#ultralytics.models.fastsam.predict.FastSAMPredictor.postprocess","title":"<code>postprocess(preds, img, orig_imgs)</code>","text":"<p>Perform post-processing steps on predictions, including non-max suppression and scaling boxes to original image size, and returns the final results.</p> <p>Parameters:</p> Name Type Description Default <code>preds</code> <code>list</code> <p>The raw output predictions from the model.</p> required <code>img</code> <code>Tensor</code> <p>The processed image tensor.</p> required <code>orig_imgs</code> <code>list | Tensor</code> <p>The original image or list of images.</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of Results objects, each containing processed boxes, masks, and other metadata.</p> Source code in <code>ultralytics/models/fastsam/predict.py</code> <pre><code>def postprocess(self, preds, img, orig_imgs):\n    \"\"\"\n    Perform post-processing steps on predictions, including non-max suppression and scaling boxes to original image\n    size, and returns the final results.\n\n    Args:\n        preds (list): The raw output predictions from the model.\n        img (torch.Tensor): The processed image tensor.\n        orig_imgs (list | torch.Tensor): The original image or list of images.\n\n    Returns:\n        (list): A list of Results objects, each containing processed boxes, masks, and other metadata.\n    \"\"\"\n    p = ops.non_max_suppression(\n        preds[0],\n        self.args.conf,\n        self.args.iou,\n        agnostic=self.args.agnostic_nms,\n        max_det=self.args.max_det,\n        nc=1,  # set to 1 class since SAM has no class predictions\n        classes=self.args.classes,\n    )\n    full_box = torch.zeros(p[0].shape[1], device=p[0].device)\n    full_box[2], full_box[3], full_box[4], full_box[6:] = img.shape[3], img.shape[2], 1.0, 1.0\n    full_box = full_box.view(1, -1)\n    critical_iou_index = bbox_iou(full_box[0][:4], p[0][:, :4], iou_thres=0.9, image_shape=img.shape[2:])\n    if critical_iou_index.numel() != 0:\n        full_box[0][4] = p[0][critical_iou_index][:, 4]\n        full_box[0][6:] = p[0][critical_iou_index][:, 6:]\n        p[0][critical_iou_index] = full_box\n\n    if not isinstance(orig_imgs, list):  # input images are a torch.Tensor, not a list\n        orig_imgs = ops.convert_torch2numpy_batch(orig_imgs)\n\n    results = []\n    proto = preds[1][-1] if len(preds[1]) == 3 else preds[1]  # second output is len 3 if pt, but only 1 if exported\n    for i, pred in enumerate(p):\n        orig_img = orig_imgs[i]\n        img_path = self.batch[0][i]\n        if not len(pred):  # save empty boxes\n            masks = None\n        elif self.args.retina_masks:\n            pred[:, :4] = ops.scale_boxes(img.shape[2:], pred[:, :4], orig_img.shape)\n            masks = ops.process_mask_native(proto[i], pred[:, 6:], pred[:, :4], orig_img.shape[:2])  # HWC\n        else:\n            masks = ops.process_mask(proto[i], pred[:, 6:], pred[:, :4], img.shape[2:], upsample=True)  # HWC\n            pred[:, :4] = ops.scale_boxes(img.shape[2:], pred[:, :4], orig_img.shape)\n        results.append(Results(orig_img, path=img_path, names=self.model.names, boxes=pred[:, :6], masks=masks))\n    return results\n</code></pre>"},{"location":"reference/models/fastsam/prompt/","title":"Reference for <code>ultralytics/models/fastsam/prompt.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/fastsam/prompt.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/fastsam/prompt/#ultralytics.models.fastsam.prompt.FastSAMPrompt","title":"<code>ultralytics.models.fastsam.prompt.FastSAMPrompt</code>","text":"<p>Fast Segment Anything Model class for image annotation and visualization.</p> <p>Attributes:</p> Name Type Description <code>device</code> <code>str</code> <p>Computing device ('cuda' or 'cpu').</p> <code>results</code> <p>Object detection or segmentation results.</p> <code>source</code> <p>Source image or image path.</p> <code>clip</code> <p>CLIP model for linear assignment.</p> Source code in <code>ultralytics/models/fastsam/prompt.py</code> <pre><code>class FastSAMPrompt:\n    \"\"\"\n    Fast Segment Anything Model class for image annotation and visualization.\n\n    Attributes:\n        device (str): Computing device ('cuda' or 'cpu').\n        results: Object detection or segmentation results.\n        source: Source image or image path.\n        clip: CLIP model for linear assignment.\n    \"\"\"\n\n    def __init__(self, source, results, device=\"cuda\") -&gt; None:\n        \"\"\"Initializes FastSAMPrompt with given source, results and device, and assigns clip for linear assignment.\"\"\"\n        self.device = device\n        self.results = results\n        self.source = source\n\n        # Import and assign clip\n        try:\n            import clip  # for linear_assignment\n        except ImportError:\n            from ultralytics.utils.checks import check_requirements\n\n            check_requirements(\"git+https://github.com/openai/CLIP.git\")\n            import clip\n        self.clip = clip\n\n    @staticmethod\n    def _segment_image(image, bbox):\n        \"\"\"Segments the given image according to the provided bounding box coordinates.\"\"\"\n        image_array = np.array(image)\n        segmented_image_array = np.zeros_like(image_array)\n        x1, y1, x2, y2 = bbox\n        segmented_image_array[y1:y2, x1:x2] = image_array[y1:y2, x1:x2]\n        segmented_image = Image.fromarray(segmented_image_array)\n        black_image = Image.new(\"RGB\", image.size, (255, 255, 255))\n        # transparency_mask = np.zeros_like((), dtype=np.uint8)\n        transparency_mask = np.zeros((image_array.shape[0], image_array.shape[1]), dtype=np.uint8)\n        transparency_mask[y1:y2, x1:x2] = 255\n        transparency_mask_image = Image.fromarray(transparency_mask, mode=\"L\")\n        black_image.paste(segmented_image, mask=transparency_mask_image)\n        return black_image\n\n    @staticmethod\n    def _format_results(result, filter=0):\n        \"\"\"Formats detection results into list of annotations each containing ID, segmentation, bounding box, score and\n        area.\n        \"\"\"\n        annotations = []\n        n = len(result.masks.data) if result.masks is not None else 0\n        for i in range(n):\n            mask = result.masks.data[i] == 1.0\n            if torch.sum(mask) &gt;= filter:\n                annotation = {\n                    \"id\": i,\n                    \"segmentation\": mask.cpu().numpy(),\n                    \"bbox\": result.boxes.data[i],\n                    \"score\": result.boxes.conf[i],\n                }\n                annotation[\"area\"] = annotation[\"segmentation\"].sum()\n                annotations.append(annotation)\n        return annotations\n\n    @staticmethod\n    def _get_bbox_from_mask(mask):\n        \"\"\"Applies morphological transformations to the mask, displays it, and if with_contours is True, draws\n        contours.\n        \"\"\"\n        mask = mask.astype(np.uint8)\n        contours, hierarchy = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        x1, y1, w, h = cv2.boundingRect(contours[0])\n        x2, y2 = x1 + w, y1 + h\n        if len(contours) &gt; 1:\n            for b in contours:\n                x_t, y_t, w_t, h_t = cv2.boundingRect(b)\n                x1 = min(x1, x_t)\n                y1 = min(y1, y_t)\n                x2 = max(x2, x_t + w_t)\n                y2 = max(y2, y_t + h_t)\n        return [x1, y1, x2, y2]\n\n    def plot(\n        self,\n        annotations,\n        output,\n        bbox=None,\n        points=None,\n        point_label=None,\n        mask_random_color=True,\n        better_quality=True,\n        retina=False,\n        with_contours=True,\n    ):\n        \"\"\"\n        Plots annotations, bounding boxes, and points on images and saves the output.\n\n        Args:\n            annotations (list): Annotations to be plotted.\n            output (str or Path): Output directory for saving the plots.\n            bbox (list, optional): Bounding box coordinates [x1, y1, x2, y2]. Defaults to None.\n            points (list, optional): Points to be plotted. Defaults to None.\n            point_label (list, optional): Labels for the points. Defaults to None.\n            mask_random_color (bool, optional): Whether to use random color for masks. Defaults to True.\n            better_quality (bool, optional): Whether to apply morphological transformations for better mask quality. Defaults to True.\n            retina (bool, optional): Whether to use retina mask. Defaults to False.\n            with_contours (bool, optional): Whether to plot contours. Defaults to True.\n        \"\"\"\n        pbar = TQDM(annotations, total=len(annotations))\n        for ann in pbar:\n            result_name = os.path.basename(ann.path)\n            image = ann.orig_img[..., ::-1]  # BGR to RGB\n            original_h, original_w = ann.orig_shape\n            # For macOS only\n            # plt.switch_backend('TkAgg')\n            plt.figure(figsize=(original_w / 100, original_h / 100))\n            # Add subplot with no margin.\n            plt.subplots_adjust(top=1, bottom=0, right=1, left=0, hspace=0, wspace=0)\n            plt.margins(0, 0)\n            plt.gca().xaxis.set_major_locator(plt.NullLocator())\n            plt.gca().yaxis.set_major_locator(plt.NullLocator())\n            plt.imshow(image)\n\n            if ann.masks is not None:\n                masks = ann.masks.data\n                if better_quality:\n                    if isinstance(masks[0], torch.Tensor):\n                        masks = np.array(masks.cpu())\n                    for i, mask in enumerate(masks):\n                        mask = cv2.morphologyEx(mask.astype(np.uint8), cv2.MORPH_CLOSE, np.ones((3, 3), np.uint8))\n                        masks[i] = cv2.morphologyEx(mask.astype(np.uint8), cv2.MORPH_OPEN, np.ones((8, 8), np.uint8))\n\n                self.fast_show_mask(\n                    masks,\n                    plt.gca(),\n                    random_color=mask_random_color,\n                    bbox=bbox,\n                    points=points,\n                    pointlabel=point_label,\n                    retinamask=retina,\n                    target_height=original_h,\n                    target_width=original_w,\n                )\n\n                if with_contours:\n                    contour_all = []\n                    temp = np.zeros((original_h, original_w, 1))\n                    for i, mask in enumerate(masks):\n                        mask = mask.astype(np.uint8)\n                        if not retina:\n                            mask = cv2.resize(mask, (original_w, original_h), interpolation=cv2.INTER_NEAREST)\n                        contours, _ = cv2.findContours(mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n                        contour_all.extend(iter(contours))\n                    cv2.drawContours(temp, contour_all, -1, (255, 255, 255), 2)\n                    color = np.array([0 / 255, 0 / 255, 1.0, 0.8])\n                    contour_mask = temp / 255 * color.reshape(1, 1, -1)\n                    plt.imshow(contour_mask)\n\n            # Save the figure\n            save_path = Path(output) / result_name\n            save_path.parent.mkdir(exist_ok=True, parents=True)\n            plt.axis(\"off\")\n            plt.savefig(save_path, bbox_inches=\"tight\", pad_inches=0, transparent=True)\n            plt.close()\n            pbar.set_description(f\"Saving {result_name} to {save_path}\")\n\n    @staticmethod\n    def fast_show_mask(\n        annotation,\n        ax,\n        random_color=False,\n        bbox=None,\n        points=None,\n        pointlabel=None,\n        retinamask=True,\n        target_height=960,\n        target_width=960,\n    ):\n        \"\"\"\n        Quickly shows the mask annotations on the given matplotlib axis.\n\n        Args:\n            annotation (array-like): Mask annotation.\n            ax (matplotlib.axes.Axes): Matplotlib axis.\n            random_color (bool, optional): Whether to use random color for masks. Defaults to False.\n            bbox (list, optional): Bounding box coordinates [x1, y1, x2, y2]. Defaults to None.\n            points (list, optional): Points to be plotted. Defaults to None.\n            pointlabel (list, optional): Labels for the points. Defaults to None.\n            retinamask (bool, optional): Whether to use retina mask. Defaults to True.\n            target_height (int, optional): Target height for resizing. Defaults to 960.\n            target_width (int, optional): Target width for resizing. Defaults to 960.\n        \"\"\"\n        n, h, w = annotation.shape  # batch, height, width\n\n        areas = np.sum(annotation, axis=(1, 2))\n        annotation = annotation[np.argsort(areas)]\n\n        index = (annotation != 0).argmax(axis=0)\n        if random_color:\n            color = np.random.random((n, 1, 1, 3))\n        else:\n            color = np.ones((n, 1, 1, 3)) * np.array([30 / 255, 144 / 255, 1.0])\n        transparency = np.ones((n, 1, 1, 1)) * 0.6\n        visual = np.concatenate([color, transparency], axis=-1)\n        mask_image = np.expand_dims(annotation, -1) * visual\n\n        show = np.zeros((h, w, 4))\n        h_indices, w_indices = np.meshgrid(np.arange(h), np.arange(w), indexing=\"ij\")\n        indices = (index[h_indices, w_indices], h_indices, w_indices, slice(None))\n\n        show[h_indices, w_indices, :] = mask_image[indices]\n        if bbox is not None:\n            x1, y1, x2, y2 = bbox\n            ax.add_patch(plt.Rectangle((x1, y1), x2 - x1, y2 - y1, fill=False, edgecolor=\"b\", linewidth=1))\n        # Draw point\n        if points is not None:\n            plt.scatter(\n                [point[0] for i, point in enumerate(points) if pointlabel[i] == 1],\n                [point[1] for i, point in enumerate(points) if pointlabel[i] == 1],\n                s=20,\n                c=\"y\",\n            )\n            plt.scatter(\n                [point[0] for i, point in enumerate(points) if pointlabel[i] == 0],\n                [point[1] for i, point in enumerate(points) if pointlabel[i] == 0],\n                s=20,\n                c=\"m\",\n            )\n\n        if not retinamask:\n            show = cv2.resize(show, (target_width, target_height), interpolation=cv2.INTER_NEAREST)\n        ax.imshow(show)\n\n    @torch.no_grad()\n    def retrieve(self, model, preprocess, elements, search_text: str, device) -&gt; int:\n        \"\"\"Processes images and text with a model, calculates similarity, and returns softmax score.\"\"\"\n        preprocessed_images = [preprocess(image).to(device) for image in elements]\n        tokenized_text = self.clip.tokenize([search_text]).to(device)\n        stacked_images = torch.stack(preprocessed_images)\n        image_features = model.encode_image(stacked_images)\n        text_features = model.encode_text(tokenized_text)\n        image_features /= image_features.norm(dim=-1, keepdim=True)\n        text_features /= text_features.norm(dim=-1, keepdim=True)\n        probs = 100.0 * image_features @ text_features.T\n        return probs[:, 0].softmax(dim=0)\n\n    def _crop_image(self, format_results):\n        \"\"\"Crops an image based on provided annotation format and returns cropped images and related data.\"\"\"\n        if os.path.isdir(self.source):\n            raise ValueError(f\"'{self.source}' is a directory, not a valid source for this function.\")\n        image = Image.fromarray(cv2.cvtColor(self.results[0].orig_img, cv2.COLOR_BGR2RGB))\n        ori_w, ori_h = image.size\n        annotations = format_results\n        mask_h, mask_w = annotations[0][\"segmentation\"].shape\n        if ori_w != mask_w or ori_h != mask_h:\n            image = image.resize((mask_w, mask_h))\n        cropped_boxes = []\n        cropped_images = []\n        not_crop = []\n        filter_id = []\n        for _, mask in enumerate(annotations):\n            if np.sum(mask[\"segmentation\"]) &lt;= 100:\n                filter_id.append(_)\n                continue\n            bbox = self._get_bbox_from_mask(mask[\"segmentation\"])  # bbox from mask\n            cropped_boxes.append(self._segment_image(image, bbox))  # save cropped image\n            cropped_images.append(bbox)  # save cropped image bbox\n\n        return cropped_boxes, cropped_images, not_crop, filter_id, annotations\n\n    def box_prompt(self, bbox):\n        \"\"\"Modifies the bounding box properties and calculates IoU between masks and bounding box.\"\"\"\n        if self.results[0].masks is not None:\n            assert bbox[2] != 0 and bbox[3] != 0\n            if os.path.isdir(self.source):\n                raise ValueError(f\"'{self.source}' is a directory, not a valid source for this function.\")\n            masks = self.results[0].masks.data\n            target_height, target_width = self.results[0].orig_shape\n            h = masks.shape[1]\n            w = masks.shape[2]\n            if h != target_height or w != target_width:\n                bbox = [\n                    int(bbox[0] * w / target_width),\n                    int(bbox[1] * h / target_height),\n                    int(bbox[2] * w / target_width),\n                    int(bbox[3] * h / target_height),\n                ]\n            bbox[0] = max(round(bbox[0]), 0)\n            bbox[1] = max(round(bbox[1]), 0)\n            bbox[2] = min(round(bbox[2]), w)\n            bbox[3] = min(round(bbox[3]), h)\n\n            # IoUs = torch.zeros(len(masks), dtype=torch.float32)\n            bbox_area = (bbox[3] - bbox[1]) * (bbox[2] - bbox[0])\n\n            masks_area = torch.sum(masks[:, bbox[1] : bbox[3], bbox[0] : bbox[2]], dim=(1, 2))\n            orig_masks_area = torch.sum(masks, dim=(1, 2))\n\n            union = bbox_area + orig_masks_area - masks_area\n            iou = masks_area / union\n            max_iou_index = torch.argmax(iou)\n\n            self.results[0].masks.data = torch.tensor(np.array([masks[max_iou_index].cpu().numpy()]))\n        return self.results\n\n    def point_prompt(self, points, pointlabel):  # numpy\n        \"\"\"Adjusts points on detected masks based on user input and returns the modified results.\"\"\"\n        if self.results[0].masks is not None:\n            if os.path.isdir(self.source):\n                raise ValueError(f\"'{self.source}' is a directory, not a valid source for this function.\")\n            masks = self._format_results(self.results[0], 0)\n            target_height, target_width = self.results[0].orig_shape\n            h = masks[0][\"segmentation\"].shape[0]\n            w = masks[0][\"segmentation\"].shape[1]\n            if h != target_height or w != target_width:\n                points = [[int(point[0] * w / target_width), int(point[1] * h / target_height)] for point in points]\n            onemask = np.zeros((h, w))\n            for annotation in masks:\n                mask = annotation[\"segmentation\"] if isinstance(annotation, dict) else annotation\n                for i, point in enumerate(points):\n                    if mask[point[1], point[0]] == 1 and pointlabel[i] == 1:\n                        onemask += mask\n                    if mask[point[1], point[0]] == 1 and pointlabel[i] == 0:\n                        onemask -= mask\n            onemask = onemask &gt;= 1\n            self.results[0].masks.data = torch.tensor(np.array([onemask]))\n        return self.results\n\n    def text_prompt(self, text):\n        \"\"\"Processes a text prompt, applies it to existing results and returns the updated results.\"\"\"\n        if self.results[0].masks is not None:\n            format_results = self._format_results(self.results[0], 0)\n            cropped_boxes, cropped_images, not_crop, filter_id, annotations = self._crop_image(format_results)\n            clip_model, preprocess = self.clip.load(\"ViT-B/32\", device=self.device)\n            scores = self.retrieve(clip_model, preprocess, cropped_boxes, text, device=self.device)\n            max_idx = scores.argsort()\n            max_idx = max_idx[-1]\n            max_idx += sum(np.array(filter_id) &lt;= int(max_idx))\n            self.results[0].masks.data = torch.tensor(np.array([annotations[max_idx][\"segmentation\"]]))\n        return self.results\n\n    def everything_prompt(self):\n        \"\"\"Returns the processed results from the previous methods in the class.\"\"\"\n        return self.results\n</code></pre>"},{"location":"reference/models/fastsam/prompt/#ultralytics.models.fastsam.prompt.FastSAMPrompt.__init__","title":"<code>__init__(source, results, device='cuda')</code>","text":"<p>Initializes FastSAMPrompt with given source, results and device, and assigns clip for linear assignment.</p> Source code in <code>ultralytics/models/fastsam/prompt.py</code> <pre><code>def __init__(self, source, results, device=\"cuda\") -&gt; None:\n    \"\"\"Initializes FastSAMPrompt with given source, results and device, and assigns clip for linear assignment.\"\"\"\n    self.device = device\n    self.results = results\n    self.source = source\n\n    # Import and assign clip\n    try:\n        import clip  # for linear_assignment\n    except ImportError:\n        from ultralytics.utils.checks import check_requirements\n\n        check_requirements(\"git+https://github.com/openai/CLIP.git\")\n        import clip\n    self.clip = clip\n</code></pre>"},{"location":"reference/models/fastsam/prompt/#ultralytics.models.fastsam.prompt.FastSAMPrompt.box_prompt","title":"<code>box_prompt(bbox)</code>","text":"<p>Modifies the bounding box properties and calculates IoU between masks and bounding box.</p> Source code in <code>ultralytics/models/fastsam/prompt.py</code> <pre><code>def box_prompt(self, bbox):\n    \"\"\"Modifies the bounding box properties and calculates IoU between masks and bounding box.\"\"\"\n    if self.results[0].masks is not None:\n        assert bbox[2] != 0 and bbox[3] != 0\n        if os.path.isdir(self.source):\n            raise ValueError(f\"'{self.source}' is a directory, not a valid source for this function.\")\n        masks = self.results[0].masks.data\n        target_height, target_width = self.results[0].orig_shape\n        h = masks.shape[1]\n        w = masks.shape[2]\n        if h != target_height or w != target_width:\n            bbox = [\n                int(bbox[0] * w / target_width),\n                int(bbox[1] * h / target_height),\n                int(bbox[2] * w / target_width),\n                int(bbox[3] * h / target_height),\n            ]\n        bbox[0] = max(round(bbox[0]), 0)\n        bbox[1] = max(round(bbox[1]), 0)\n        bbox[2] = min(round(bbox[2]), w)\n        bbox[3] = min(round(bbox[3]), h)\n\n        # IoUs = torch.zeros(len(masks), dtype=torch.float32)\n        bbox_area = (bbox[3] - bbox[1]) * (bbox[2] - bbox[0])\n\n        masks_area = torch.sum(masks[:, bbox[1] : bbox[3], bbox[0] : bbox[2]], dim=(1, 2))\n        orig_masks_area = torch.sum(masks, dim=(1, 2))\n\n        union = bbox_area + orig_masks_area - masks_area\n        iou = masks_area / union\n        max_iou_index = torch.argmax(iou)\n\n        self.results[0].masks.data = torch.tensor(np.array([masks[max_iou_index].cpu().numpy()]))\n    return self.results\n</code></pre>"},{"location":"reference/models/fastsam/prompt/#ultralytics.models.fastsam.prompt.FastSAMPrompt.everything_prompt","title":"<code>everything_prompt()</code>","text":"<p>Returns the processed results from the previous methods in the class.</p> Source code in <code>ultralytics/models/fastsam/prompt.py</code> <pre><code>def everything_prompt(self):\n    \"\"\"Returns the processed results from the previous methods in the class.\"\"\"\n    return self.results\n</code></pre>"},{"location":"reference/models/fastsam/prompt/#ultralytics.models.fastsam.prompt.FastSAMPrompt.fast_show_mask","title":"<code>fast_show_mask(annotation, ax, random_color=False, bbox=None, points=None, pointlabel=None, retinamask=True, target_height=960, target_width=960)</code>  <code>staticmethod</code>","text":"<p>Quickly shows the mask annotations on the given matplotlib axis.</p> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>array - like</code> <p>Mask annotation.</p> required <code>ax</code> <code>Axes</code> <p>Matplotlib axis.</p> required <code>random_color</code> <code>bool</code> <p>Whether to use random color for masks. Defaults to False.</p> <code>False</code> <code>bbox</code> <code>list</code> <p>Bounding box coordinates [x1, y1, x2, y2]. Defaults to None.</p> <code>None</code> <code>points</code> <code>list</code> <p>Points to be plotted. Defaults to None.</p> <code>None</code> <code>pointlabel</code> <code>list</code> <p>Labels for the points. Defaults to None.</p> <code>None</code> <code>retinamask</code> <code>bool</code> <p>Whether to use retina mask. Defaults to True.</p> <code>True</code> <code>target_height</code> <code>int</code> <p>Target height for resizing. Defaults to 960.</p> <code>960</code> <code>target_width</code> <code>int</code> <p>Target width for resizing. Defaults to 960.</p> <code>960</code> Source code in <code>ultralytics/models/fastsam/prompt.py</code> <pre><code>@staticmethod\ndef fast_show_mask(\n    annotation,\n    ax,\n    random_color=False,\n    bbox=None,\n    points=None,\n    pointlabel=None,\n    retinamask=True,\n    target_height=960,\n    target_width=960,\n):\n    \"\"\"\n    Quickly shows the mask annotations on the given matplotlib axis.\n\n    Args:\n        annotation (array-like): Mask annotation.\n        ax (matplotlib.axes.Axes): Matplotlib axis.\n        random_color (bool, optional): Whether to use random color for masks. Defaults to False.\n        bbox (list, optional): Bounding box coordinates [x1, y1, x2, y2]. Defaults to None.\n        points (list, optional): Points to be plotted. Defaults to None.\n        pointlabel (list, optional): Labels for the points. Defaults to None.\n        retinamask (bool, optional): Whether to use retina mask. Defaults to True.\n        target_height (int, optional): Target height for resizing. Defaults to 960.\n        target_width (int, optional): Target width for resizing. Defaults to 960.\n    \"\"\"\n    n, h, w = annotation.shape  # batch, height, width\n\n    areas = np.sum(annotation, axis=(1, 2))\n    annotation = annotation[np.argsort(areas)]\n\n    index = (annotation != 0).argmax(axis=0)\n    if random_color:\n        color = np.random.random((n, 1, 1, 3))\n    else:\n        color = np.ones((n, 1, 1, 3)) * np.array([30 / 255, 144 / 255, 1.0])\n    transparency = np.ones((n, 1, 1, 1)) * 0.6\n    visual = np.concatenate([color, transparency], axis=-1)\n    mask_image = np.expand_dims(annotation, -1) * visual\n\n    show = np.zeros((h, w, 4))\n    h_indices, w_indices = np.meshgrid(np.arange(h), np.arange(w), indexing=\"ij\")\n    indices = (index[h_indices, w_indices], h_indices, w_indices, slice(None))\n\n    show[h_indices, w_indices, :] = mask_image[indices]\n    if bbox is not None:\n        x1, y1, x2, y2 = bbox\n        ax.add_patch(plt.Rectangle((x1, y1), x2 - x1, y2 - y1, fill=False, edgecolor=\"b\", linewidth=1))\n    # Draw point\n    if points is not None:\n        plt.scatter(\n            [point[0] for i, point in enumerate(points) if pointlabel[i] == 1],\n            [point[1] for i, point in enumerate(points) if pointlabel[i] == 1],\n            s=20,\n            c=\"y\",\n        )\n        plt.scatter(\n            [point[0] for i, point in enumerate(points) if pointlabel[i] == 0],\n            [point[1] for i, point in enumerate(points) if pointlabel[i] == 0],\n            s=20,\n            c=\"m\",\n        )\n\n    if not retinamask:\n        show = cv2.resize(show, (target_width, target_height), interpolation=cv2.INTER_NEAREST)\n    ax.imshow(show)\n</code></pre>"},{"location":"reference/models/fastsam/prompt/#ultralytics.models.fastsam.prompt.FastSAMPrompt.plot","title":"<code>plot(annotations, output, bbox=None, points=None, point_label=None, mask_random_color=True, better_quality=True, retina=False, with_contours=True)</code>","text":"<p>Plots annotations, bounding boxes, and points on images and saves the output.</p> <p>Parameters:</p> Name Type Description Default <code>annotations</code> <code>list</code> <p>Annotations to be plotted.</p> required <code>output</code> <code>str or Path</code> <p>Output directory for saving the plots.</p> required <code>bbox</code> <code>list</code> <p>Bounding box coordinates [x1, y1, x2, y2]. Defaults to None.</p> <code>None</code> <code>points</code> <code>list</code> <p>Points to be plotted. Defaults to None.</p> <code>None</code> <code>point_label</code> <code>list</code> <p>Labels for the points. Defaults to None.</p> <code>None</code> <code>mask_random_color</code> <code>bool</code> <p>Whether to use random color for masks. Defaults to True.</p> <code>True</code> <code>better_quality</code> <code>bool</code> <p>Whether to apply morphological transformations for better mask quality. Defaults to True.</p> <code>True</code> <code>retina</code> <code>bool</code> <p>Whether to use retina mask. Defaults to False.</p> <code>False</code> <code>with_contours</code> <code>bool</code> <p>Whether to plot contours. Defaults to True.</p> <code>True</code> Source code in <code>ultralytics/models/fastsam/prompt.py</code> <pre><code>def plot(\n    self,\n    annotations,\n    output,\n    bbox=None,\n    points=None,\n    point_label=None,\n    mask_random_color=True,\n    better_quality=True,\n    retina=False,\n    with_contours=True,\n):\n    \"\"\"\n    Plots annotations, bounding boxes, and points on images and saves the output.\n\n    Args:\n        annotations (list): Annotations to be plotted.\n        output (str or Path): Output directory for saving the plots.\n        bbox (list, optional): Bounding box coordinates [x1, y1, x2, y2]. Defaults to None.\n        points (list, optional): Points to be plotted. Defaults to None.\n        point_label (list, optional): Labels for the points. Defaults to None.\n        mask_random_color (bool, optional): Whether to use random color for masks. Defaults to True.\n        better_quality (bool, optional): Whether to apply morphological transformations for better mask quality. Defaults to True.\n        retina (bool, optional): Whether to use retina mask. Defaults to False.\n        with_contours (bool, optional): Whether to plot contours. Defaults to True.\n    \"\"\"\n    pbar = TQDM(annotations, total=len(annotations))\n    for ann in pbar:\n        result_name = os.path.basename(ann.path)\n        image = ann.orig_img[..., ::-1]  # BGR to RGB\n        original_h, original_w = ann.orig_shape\n        # For macOS only\n        # plt.switch_backend('TkAgg')\n        plt.figure(figsize=(original_w / 100, original_h / 100))\n        # Add subplot with no margin.\n        plt.subplots_adjust(top=1, bottom=0, right=1, left=0, hspace=0, wspace=0)\n        plt.margins(0, 0)\n        plt.gca().xaxis.set_major_locator(plt.NullLocator())\n        plt.gca().yaxis.set_major_locator(plt.NullLocator())\n        plt.imshow(image)\n\n        if ann.masks is not None:\n            masks = ann.masks.data\n            if better_quality:\n                if isinstance(masks[0], torch.Tensor):\n                    masks = np.array(masks.cpu())\n                for i, mask in enumerate(masks):\n                    mask = cv2.morphologyEx(mask.astype(np.uint8), cv2.MORPH_CLOSE, np.ones((3, 3), np.uint8))\n                    masks[i] = cv2.morphologyEx(mask.astype(np.uint8), cv2.MORPH_OPEN, np.ones((8, 8), np.uint8))\n\n            self.fast_show_mask(\n                masks,\n                plt.gca(),\n                random_color=mask_random_color,\n                bbox=bbox,\n                points=points,\n                pointlabel=point_label,\n                retinamask=retina,\n                target_height=original_h,\n                target_width=original_w,\n            )\n\n            if with_contours:\n                contour_all = []\n                temp = np.zeros((original_h, original_w, 1))\n                for i, mask in enumerate(masks):\n                    mask = mask.astype(np.uint8)\n                    if not retina:\n                        mask = cv2.resize(mask, (original_w, original_h), interpolation=cv2.INTER_NEAREST)\n                    contours, _ = cv2.findContours(mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n                    contour_all.extend(iter(contours))\n                cv2.drawContours(temp, contour_all, -1, (255, 255, 255), 2)\n                color = np.array([0 / 255, 0 / 255, 1.0, 0.8])\n                contour_mask = temp / 255 * color.reshape(1, 1, -1)\n                plt.imshow(contour_mask)\n\n        # Save the figure\n        save_path = Path(output) / result_name\n        save_path.parent.mkdir(exist_ok=True, parents=True)\n        plt.axis(\"off\")\n        plt.savefig(save_path, bbox_inches=\"tight\", pad_inches=0, transparent=True)\n        plt.close()\n        pbar.set_description(f\"Saving {result_name} to {save_path}\")\n</code></pre>"},{"location":"reference/models/fastsam/prompt/#ultralytics.models.fastsam.prompt.FastSAMPrompt.point_prompt","title":"<code>point_prompt(points, pointlabel)</code>","text":"<p>Adjusts points on detected masks based on user input and returns the modified results.</p> Source code in <code>ultralytics/models/fastsam/prompt.py</code> <pre><code>def point_prompt(self, points, pointlabel):  # numpy\n    \"\"\"Adjusts points on detected masks based on user input and returns the modified results.\"\"\"\n    if self.results[0].masks is not None:\n        if os.path.isdir(self.source):\n            raise ValueError(f\"'{self.source}' is a directory, not a valid source for this function.\")\n        masks = self._format_results(self.results[0], 0)\n        target_height, target_width = self.results[0].orig_shape\n        h = masks[0][\"segmentation\"].shape[0]\n        w = masks[0][\"segmentation\"].shape[1]\n        if h != target_height or w != target_width:\n            points = [[int(point[0] * w / target_width), int(point[1] * h / target_height)] for point in points]\n        onemask = np.zeros((h, w))\n        for annotation in masks:\n            mask = annotation[\"segmentation\"] if isinstance(annotation, dict) else annotation\n            for i, point in enumerate(points):\n                if mask[point[1], point[0]] == 1 and pointlabel[i] == 1:\n                    onemask += mask\n                if mask[point[1], point[0]] == 1 and pointlabel[i] == 0:\n                    onemask -= mask\n        onemask = onemask &gt;= 1\n        self.results[0].masks.data = torch.tensor(np.array([onemask]))\n    return self.results\n</code></pre>"},{"location":"reference/models/fastsam/prompt/#ultralytics.models.fastsam.prompt.FastSAMPrompt.retrieve","title":"<code>retrieve(model, preprocess, elements, search_text, device)</code>","text":"<p>Processes images and text with a model, calculates similarity, and returns softmax score.</p> Source code in <code>ultralytics/models/fastsam/prompt.py</code> <pre><code>@torch.no_grad()\ndef retrieve(self, model, preprocess, elements, search_text: str, device) -&gt; int:\n    \"\"\"Processes images and text with a model, calculates similarity, and returns softmax score.\"\"\"\n    preprocessed_images = [preprocess(image).to(device) for image in elements]\n    tokenized_text = self.clip.tokenize([search_text]).to(device)\n    stacked_images = torch.stack(preprocessed_images)\n    image_features = model.encode_image(stacked_images)\n    text_features = model.encode_text(tokenized_text)\n    image_features /= image_features.norm(dim=-1, keepdim=True)\n    text_features /= text_features.norm(dim=-1, keepdim=True)\n    probs = 100.0 * image_features @ text_features.T\n    return probs[:, 0].softmax(dim=0)\n</code></pre>"},{"location":"reference/models/fastsam/prompt/#ultralytics.models.fastsam.prompt.FastSAMPrompt.text_prompt","title":"<code>text_prompt(text)</code>","text":"<p>Processes a text prompt, applies it to existing results and returns the updated results.</p> Source code in <code>ultralytics/models/fastsam/prompt.py</code> <pre><code>def text_prompt(self, text):\n    \"\"\"Processes a text prompt, applies it to existing results and returns the updated results.\"\"\"\n    if self.results[0].masks is not None:\n        format_results = self._format_results(self.results[0], 0)\n        cropped_boxes, cropped_images, not_crop, filter_id, annotations = self._crop_image(format_results)\n        clip_model, preprocess = self.clip.load(\"ViT-B/32\", device=self.device)\n        scores = self.retrieve(clip_model, preprocess, cropped_boxes, text, device=self.device)\n        max_idx = scores.argsort()\n        max_idx = max_idx[-1]\n        max_idx += sum(np.array(filter_id) &lt;= int(max_idx))\n        self.results[0].masks.data = torch.tensor(np.array([annotations[max_idx][\"segmentation\"]]))\n    return self.results\n</code></pre>"},{"location":"reference/models/fastsam/utils/","title":"Reference for <code>ultralytics/models/fastsam/utils.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/fastsam/utils.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p>"},{"location":"reference/models/fastsam/utils/#ultralytics.models.fastsam.utils.adjust_bboxes_to_image_border","title":"<code>ultralytics.models.fastsam.utils.adjust_bboxes_to_image_border(boxes, image_shape, threshold=20)</code>","text":"<p>Adjust bounding boxes to stick to image border if they are within a certain threshold.</p> <p>Parameters:</p> Name Type Description Default <code>boxes</code> <code>Tensor</code> <p>(n, 4)</p> required <code>image_shape</code> <code>tuple</code> <p>(height, width)</p> required <code>threshold</code> <code>int</code> <p>pixel threshold</p> <code>20</code> <p>Returns:</p> Name Type Description <code>adjusted_boxes</code> <code>Tensor</code> <p>adjusted bounding boxes</p> Source code in <code>ultralytics/models/fastsam/utils.py</code> <pre><code>def adjust_bboxes_to_image_border(boxes, image_shape, threshold=20):\n    \"\"\"\n    Adjust bounding boxes to stick to image border if they are within a certain threshold.\n\n    Args:\n        boxes (torch.Tensor): (n, 4)\n        image_shape (tuple): (height, width)\n        threshold (int): pixel threshold\n\n    Returns:\n        adjusted_boxes (torch.Tensor): adjusted bounding boxes\n    \"\"\"\n\n    # Image dimensions\n    h, w = image_shape\n\n    # Adjust boxes\n    boxes[boxes[:, 0] &lt; threshold, 0] = 0  # x1\n    boxes[boxes[:, 1] &lt; threshold, 1] = 0  # y1\n    boxes[boxes[:, 2] &gt; w - threshold, 2] = w  # x2\n    boxes[boxes[:, 3] &gt; h - threshold, 3] = h  # y2\n    return boxes\n</code></pre>"},{"location":"reference/models/fastsam/utils/#ultralytics.models.fastsam.utils.bbox_iou","title":"<code>ultralytics.models.fastsam.utils.bbox_iou(box1, boxes, iou_thres=0.9, image_shape=(640, 640), raw_output=False)</code>","text":"<p>Compute the Intersection-Over-Union of a bounding box with respect to an array of other bounding boxes.</p> <p>Parameters:</p> Name Type Description Default <code>box1</code> <code>Tensor</code> <p>(4, )</p> required <code>boxes</code> <code>Tensor</code> <p>(n, 4)</p> required <code>iou_thres</code> <code>float</code> <p>IoU threshold</p> <code>0.9</code> <code>image_shape</code> <code>tuple</code> <p>(height, width)</p> <code>(640, 640)</code> <code>raw_output</code> <code>bool</code> <p>If True, return the raw IoU values instead of the indices</p> <code>False</code> <p>Returns:</p> Name Type Description <code>high_iou_indices</code> <code>Tensor</code> <p>Indices of boxes with IoU &gt; thres</p> Source code in <code>ultralytics/models/fastsam/utils.py</code> <pre><code>def bbox_iou(box1, boxes, iou_thres=0.9, image_shape=(640, 640), raw_output=False):\n    \"\"\"\n    Compute the Intersection-Over-Union of a bounding box with respect to an array of other bounding boxes.\n\n    Args:\n        box1 (torch.Tensor): (4, )\n        boxes (torch.Tensor): (n, 4)\n        iou_thres (float): IoU threshold\n        image_shape (tuple): (height, width)\n        raw_output (bool): If True, return the raw IoU values instead of the indices\n\n    Returns:\n        high_iou_indices (torch.Tensor): Indices of boxes with IoU &gt; thres\n    \"\"\"\n    boxes = adjust_bboxes_to_image_border(boxes, image_shape)\n    # Obtain coordinates for intersections\n    x1 = torch.max(box1[0], boxes[:, 0])\n    y1 = torch.max(box1[1], boxes[:, 1])\n    x2 = torch.min(box1[2], boxes[:, 2])\n    y2 = torch.min(box1[3], boxes[:, 3])\n\n    # Compute the area of intersection\n    intersection = (x2 - x1).clamp(0) * (y2 - y1).clamp(0)\n\n    # Compute the area of both individual boxes\n    box1_area = (box1[2] - box1[0]) * (box1[3] - box1[1])\n    box2_area = (boxes[:, 2] - boxes[:, 0]) * (boxes[:, 3] - boxes[:, 1])\n\n    # Compute the area of union\n    union = box1_area + box2_area - intersection\n\n    # Compute the IoU\n    iou = intersection / union  # Should be shape (n, )\n    if raw_output:\n        return 0 if iou.numel() == 0 else iou\n\n    # return indices of boxes with IoU &gt; thres\n    return torch.nonzero(iou &gt; iou_thres).flatten()\n</code></pre>"},{"location":"reference/models/fastsam/val/","title":"Reference for <code>ultralytics/models/fastsam/val.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/fastsam/val.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/fastsam/val/#ultralytics.models.fastsam.val.FastSAMValidator","title":"<code>ultralytics.models.fastsam.val.FastSAMValidator</code>","text":"<p>             Bases: <code>SegmentationValidator</code></p> <p>Custom validation class for fast SAM (Segment Anything Model) segmentation in Ultralytics YOLO framework.</p> <p>Extends the SegmentationValidator class, customizing the validation process specifically for fast SAM. This class sets the task to 'segment' and uses the SegmentMetrics for evaluation. Additionally, plotting features are disabled to avoid errors during validation.</p> <p>Attributes:</p> Name Type Description <code>dataloader</code> <p>The data loader object used for validation.</p> <code>save_dir</code> <code>str</code> <p>The directory where validation results will be saved.</p> <code>pbar</code> <code>str</code> <p>A progress bar object.</p> <code>args</code> <code>str</code> <p>Additional arguments for customization.</p> <code>_callbacks</code> <code>str</code> <p>List of callback functions to be invoked during validation.</p> Source code in <code>ultralytics/models/fastsam/val.py</code> <pre><code>class FastSAMValidator(SegmentationValidator):\n    \"\"\"\n    Custom validation class for fast SAM (Segment Anything Model) segmentation in Ultralytics YOLO framework.\n\n    Extends the SegmentationValidator class, customizing the validation process specifically for fast SAM. This class\n    sets the task to 'segment' and uses the SegmentMetrics for evaluation. Additionally, plotting features are disabled\n    to avoid errors during validation.\n\n    Attributes:\n        dataloader: The data loader object used for validation.\n        save_dir (str): The directory where validation results will be saved.\n        pbar: A progress bar object.\n        args: Additional arguments for customization.\n        _callbacks: List of callback functions to be invoked during validation.\n    \"\"\"\n\n    def __init__(self, dataloader=None, save_dir=None, pbar=None, args=None, _callbacks=None):\n        \"\"\"\n        Initialize the FastSAMValidator class, setting the task to 'segment' and metrics to SegmentMetrics.\n\n        Args:\n            dataloader (torch.utils.data.DataLoader): Dataloader to be used for validation.\n            save_dir (Path, optional): Directory to save results.\n            pbar (tqdm.tqdm): Progress bar for displaying progress.\n            args (SimpleNamespace): Configuration for the validator.\n            _callbacks (dict): Dictionary to store various callback functions.\n\n        Notes:\n            Plots for ConfusionMatrix and other related metrics are disabled in this class to avoid errors.\n        \"\"\"\n        super().__init__(dataloader, save_dir, pbar, args, _callbacks)\n        self.args.task = \"segment\"\n        self.args.plots = False  # disable ConfusionMatrix and other plots to avoid errors\n        self.metrics = SegmentMetrics(save_dir=self.save_dir, on_plot=self.on_plot)\n</code></pre>"},{"location":"reference/models/fastsam/val/#ultralytics.models.fastsam.val.FastSAMValidator.__init__","title":"<code>__init__(dataloader=None, save_dir=None, pbar=None, args=None, _callbacks=None)</code>","text":"<p>Initialize the FastSAMValidator class, setting the task to 'segment' and metrics to SegmentMetrics.</p> <p>Parameters:</p> Name Type Description Default <code>dataloader</code> <code>DataLoader</code> <p>Dataloader to be used for validation.</p> <code>None</code> <code>save_dir</code> <code>Path</code> <p>Directory to save results.</p> <code>None</code> <code>pbar</code> <code>tqdm</code> <p>Progress bar for displaying progress.</p> <code>None</code> <code>args</code> <code>SimpleNamespace</code> <p>Configuration for the validator.</p> <code>None</code> <code>_callbacks</code> <code>dict</code> <p>Dictionary to store various callback functions.</p> <code>None</code> Notes <p>Plots for ConfusionMatrix and other related metrics are disabled in this class to avoid errors.</p> Source code in <code>ultralytics/models/fastsam/val.py</code> <pre><code>def __init__(self, dataloader=None, save_dir=None, pbar=None, args=None, _callbacks=None):\n    \"\"\"\n    Initialize the FastSAMValidator class, setting the task to 'segment' and metrics to SegmentMetrics.\n\n    Args:\n        dataloader (torch.utils.data.DataLoader): Dataloader to be used for validation.\n        save_dir (Path, optional): Directory to save results.\n        pbar (tqdm.tqdm): Progress bar for displaying progress.\n        args (SimpleNamespace): Configuration for the validator.\n        _callbacks (dict): Dictionary to store various callback functions.\n\n    Notes:\n        Plots for ConfusionMatrix and other related metrics are disabled in this class to avoid errors.\n    \"\"\"\n    super().__init__(dataloader, save_dir, pbar, args, _callbacks)\n    self.args.task = \"segment\"\n    self.args.plots = False  # disable ConfusionMatrix and other plots to avoid errors\n    self.metrics = SegmentMetrics(save_dir=self.save_dir, on_plot=self.on_plot)\n</code></pre>"},{"location":"reference/models/nas/model/","title":"Reference for <code>ultralytics/models/nas/model.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/nas/model.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/nas/model/#ultralytics.models.nas.model.NAS","title":"<code>ultralytics.models.nas.model.NAS</code>","text":"<p>             Bases: <code>Model</code></p> <p>YOLO NAS model for object detection.</p> <p>This class provides an interface for the YOLO-NAS models and extends the <code>Model</code> class from Ultralytics engine. It is designed to facilitate the task of object detection using pre-trained or custom-trained YOLO-NAS models.</p> Example <pre><code>from ultralytics import NAS\n\nmodel = NAS('yolo_nas_s')\nresults = model.predict('ultralytics/assets/bus.jpg')\n</code></pre> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>Path to the pre-trained model or model name. Defaults to 'yolo_nas_s.pt'.</p> Note <p>YOLO-NAS models only support pre-trained models. Do not provide YAML configuration files.</p> Source code in <code>ultralytics/models/nas/model.py</code> <pre><code>class NAS(Model):\n    \"\"\"\n    YOLO NAS model for object detection.\n\n    This class provides an interface for the YOLO-NAS models and extends the `Model` class from Ultralytics engine.\n    It is designed to facilitate the task of object detection using pre-trained or custom-trained YOLO-NAS models.\n\n    Example:\n        ```python\n        from ultralytics import NAS\n\n        model = NAS('yolo_nas_s')\n        results = model.predict('ultralytics/assets/bus.jpg')\n        ```\n\n    Attributes:\n        model (str): Path to the pre-trained model or model name. Defaults to 'yolo_nas_s.pt'.\n\n    Note:\n        YOLO-NAS models only support pre-trained models. Do not provide YAML configuration files.\n    \"\"\"\n\n    def __init__(self, model=\"yolo_nas_s.pt\") -&gt; None:\n        \"\"\"Initializes the NAS model with the provided or default 'yolo_nas_s.pt' model.\"\"\"\n        assert Path(model).suffix not in (\".yaml\", \".yml\"), \"YOLO-NAS models only support pre-trained models.\"\n        super().__init__(model, task=\"detect\")\n\n    @smart_inference_mode()\n    def _load(self, weights: str, task: str):\n        \"\"\"Loads an existing NAS model weights or creates a new NAS model with pretrained weights if not provided.\"\"\"\n        import super_gradients\n\n        suffix = Path(weights).suffix\n        if suffix == \".pt\":\n            self.model = torch.load(weights)\n        elif suffix == \"\":\n            self.model = super_gradients.training.models.get(weights, pretrained_weights=\"coco\")\n        # Standardize model\n        self.model.fuse = lambda verbose=True: self.model\n        self.model.stride = torch.tensor([32])\n        self.model.names = dict(enumerate(self.model._class_names))\n        self.model.is_fused = lambda: False  # for info()\n        self.model.yaml = {}  # for info()\n        self.model.pt_path = weights  # for export()\n        self.model.task = \"detect\"  # for export()\n\n    def info(self, detailed=False, verbose=True):\n        \"\"\"\n        Logs model info.\n\n        Args:\n            detailed (bool): Show detailed information about model.\n            verbose (bool): Controls verbosity.\n        \"\"\"\n        return model_info(self.model, detailed=detailed, verbose=verbose, imgsz=640)\n\n    @property\n    def task_map(self):\n        \"\"\"Returns a dictionary mapping tasks to respective predictor and validator classes.\"\"\"\n        return {\"detect\": {\"predictor\": NASPredictor, \"validator\": NASValidator}}\n</code></pre>"},{"location":"reference/models/nas/model/#ultralytics.models.nas.model.NAS.task_map","title":"<code>task_map</code>  <code>property</code>","text":"<p>Returns a dictionary mapping tasks to respective predictor and validator classes.</p>"},{"location":"reference/models/nas/model/#ultralytics.models.nas.model.NAS.__init__","title":"<code>__init__(model='yolo_nas_s.pt')</code>","text":"<p>Initializes the NAS model with the provided or default 'yolo_nas_s.pt' model.</p> Source code in <code>ultralytics/models/nas/model.py</code> <pre><code>def __init__(self, model=\"yolo_nas_s.pt\") -&gt; None:\n    \"\"\"Initializes the NAS model with the provided or default 'yolo_nas_s.pt' model.\"\"\"\n    assert Path(model).suffix not in (\".yaml\", \".yml\"), \"YOLO-NAS models only support pre-trained models.\"\n    super().__init__(model, task=\"detect\")\n</code></pre>"},{"location":"reference/models/nas/model/#ultralytics.models.nas.model.NAS.info","title":"<code>info(detailed=False, verbose=True)</code>","text":"<p>Logs model info.</p> <p>Parameters:</p> Name Type Description Default <code>detailed</code> <code>bool</code> <p>Show detailed information about model.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Controls verbosity.</p> <code>True</code> Source code in <code>ultralytics/models/nas/model.py</code> <pre><code>def info(self, detailed=False, verbose=True):\n    \"\"\"\n    Logs model info.\n\n    Args:\n        detailed (bool): Show detailed information about model.\n        verbose (bool): Controls verbosity.\n    \"\"\"\n    return model_info(self.model, detailed=detailed, verbose=verbose, imgsz=640)\n</code></pre>"},{"location":"reference/models/nas/predict/","title":"Reference for <code>ultralytics/models/nas/predict.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/nas/predict.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/nas/predict/#ultralytics.models.nas.predict.NASPredictor","title":"<code>ultralytics.models.nas.predict.NASPredictor</code>","text":"<p>             Bases: <code>BasePredictor</code></p> <p>Ultralytics YOLO NAS Predictor for object detection.</p> <p>This class extends the <code>BasePredictor</code> from Ultralytics engine and is responsible for post-processing the raw predictions generated by the YOLO NAS models. It applies operations like non-maximum suppression and scaling the bounding boxes to fit the original image dimensions.</p> <p>Attributes:</p> Name Type Description <code>args</code> <code>Namespace</code> <p>Namespace containing various configurations for post-processing.</p> Example <pre><code>from ultralytics import NAS\n\nmodel = NAS('yolo_nas_s')\npredictor = model.predictor\n# Assumes that raw_preds, img, orig_imgs are available\nresults = predictor.postprocess(raw_preds, img, orig_imgs)\n</code></pre> Note <p>Typically, this class is not instantiated directly. It is used internally within the <code>NAS</code> class.</p> Source code in <code>ultralytics/models/nas/predict.py</code> <pre><code>class NASPredictor(BasePredictor):\n    \"\"\"\n    Ultralytics YOLO NAS Predictor for object detection.\n\n    This class extends the `BasePredictor` from Ultralytics engine and is responsible for post-processing the\n    raw predictions generated by the YOLO NAS models. It applies operations like non-maximum suppression and\n    scaling the bounding boxes to fit the original image dimensions.\n\n    Attributes:\n        args (Namespace): Namespace containing various configurations for post-processing.\n\n    Example:\n        ```python\n        from ultralytics import NAS\n\n        model = NAS('yolo_nas_s')\n        predictor = model.predictor\n        # Assumes that raw_preds, img, orig_imgs are available\n        results = predictor.postprocess(raw_preds, img, orig_imgs)\n        ```\n\n    Note:\n        Typically, this class is not instantiated directly. It is used internally within the `NAS` class.\n    \"\"\"\n\n    def postprocess(self, preds_in, img, orig_imgs):\n        \"\"\"Postprocess predictions and returns a list of Results objects.\"\"\"\n\n        # Cat boxes and class scores\n        boxes = ops.xyxy2xywh(preds_in[0][0])\n        preds = torch.cat((boxes, preds_in[0][1]), -1).permute(0, 2, 1)\n\n        preds = ops.non_max_suppression(\n            preds,\n            self.args.conf,\n            self.args.iou,\n            agnostic=self.args.agnostic_nms,\n            max_det=self.args.max_det,\n            classes=self.args.classes,\n        )\n\n        if not isinstance(orig_imgs, list):  # input images are a torch.Tensor, not a list\n            orig_imgs = ops.convert_torch2numpy_batch(orig_imgs)\n\n        results = []\n        for i, pred in enumerate(preds):\n            orig_img = orig_imgs[i]\n            pred[:, :4] = ops.scale_boxes(img.shape[2:], pred[:, :4], orig_img.shape)\n            img_path = self.batch[0][i]\n            results.append(Results(orig_img, path=img_path, names=self.model.names, boxes=pred))\n        return results\n</code></pre>"},{"location":"reference/models/nas/predict/#ultralytics.models.nas.predict.NASPredictor.postprocess","title":"<code>postprocess(preds_in, img, orig_imgs)</code>","text":"<p>Postprocess predictions and returns a list of Results objects.</p> Source code in <code>ultralytics/models/nas/predict.py</code> <pre><code>def postprocess(self, preds_in, img, orig_imgs):\n    \"\"\"Postprocess predictions and returns a list of Results objects.\"\"\"\n\n    # Cat boxes and class scores\n    boxes = ops.xyxy2xywh(preds_in[0][0])\n    preds = torch.cat((boxes, preds_in[0][1]), -1).permute(0, 2, 1)\n\n    preds = ops.non_max_suppression(\n        preds,\n        self.args.conf,\n        self.args.iou,\n        agnostic=self.args.agnostic_nms,\n        max_det=self.args.max_det,\n        classes=self.args.classes,\n    )\n\n    if not isinstance(orig_imgs, list):  # input images are a torch.Tensor, not a list\n        orig_imgs = ops.convert_torch2numpy_batch(orig_imgs)\n\n    results = []\n    for i, pred in enumerate(preds):\n        orig_img = orig_imgs[i]\n        pred[:, :4] = ops.scale_boxes(img.shape[2:], pred[:, :4], orig_img.shape)\n        img_path = self.batch[0][i]\n        results.append(Results(orig_img, path=img_path, names=self.model.names, boxes=pred))\n    return results\n</code></pre>"},{"location":"reference/models/nas/val/","title":"Reference for <code>ultralytics/models/nas/val.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/nas/val.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/nas/val/#ultralytics.models.nas.val.NASValidator","title":"<code>ultralytics.models.nas.val.NASValidator</code>","text":"<p>             Bases: <code>DetectionValidator</code></p> <p>Ultralytics YOLO NAS Validator for object detection.</p> <p>Extends <code>DetectionValidator</code> from the Ultralytics models package and is designed to post-process the raw predictions generated by YOLO NAS models. It performs non-maximum suppression to remove overlapping and low-confidence boxes, ultimately producing the final detections.</p> <p>Attributes:</p> Name Type Description <code>args</code> <code>Namespace</code> <p>Namespace containing various configurations for post-processing, such as confidence and IoU thresholds.</p> <code>lb</code> <code>Tensor</code> <p>Optional tensor for multilabel NMS.</p> Example <pre><code>from ultralytics import NAS\n\nmodel = NAS('yolo_nas_s')\nvalidator = model.validator\n# Assumes that raw_preds are available\nfinal_preds = validator.postprocess(raw_preds)\n</code></pre> Note <p>This class is generally not instantiated directly but is used internally within the <code>NAS</code> class.</p> Source code in <code>ultralytics/models/nas/val.py</code> <pre><code>class NASValidator(DetectionValidator):\n    \"\"\"\n    Ultralytics YOLO NAS Validator for object detection.\n\n    Extends `DetectionValidator` from the Ultralytics models package and is designed to post-process the raw predictions\n    generated by YOLO NAS models. It performs non-maximum suppression to remove overlapping and low-confidence boxes,\n    ultimately producing the final detections.\n\n    Attributes:\n        args (Namespace): Namespace containing various configurations for post-processing, such as confidence and IoU thresholds.\n        lb (torch.Tensor): Optional tensor for multilabel NMS.\n\n    Example:\n        ```python\n        from ultralytics import NAS\n\n        model = NAS('yolo_nas_s')\n        validator = model.validator\n        # Assumes that raw_preds are available\n        final_preds = validator.postprocess(raw_preds)\n        ```\n\n    Note:\n        This class is generally not instantiated directly but is used internally within the `NAS` class.\n    \"\"\"\n\n    def postprocess(self, preds_in):\n        \"\"\"Apply Non-maximum suppression to prediction outputs.\"\"\"\n        boxes = ops.xyxy2xywh(preds_in[0][0])\n        preds = torch.cat((boxes, preds_in[0][1]), -1).permute(0, 2, 1)\n        return ops.non_max_suppression(\n            preds,\n            self.args.conf,\n            self.args.iou,\n            labels=self.lb,\n            multi_label=False,\n            agnostic=self.args.single_cls,\n            max_det=self.args.max_det,\n            max_time_img=0.5,\n        )\n</code></pre>"},{"location":"reference/models/nas/val/#ultralytics.models.nas.val.NASValidator.postprocess","title":"<code>postprocess(preds_in)</code>","text":"<p>Apply Non-maximum suppression to prediction outputs.</p> Source code in <code>ultralytics/models/nas/val.py</code> <pre><code>def postprocess(self, preds_in):\n    \"\"\"Apply Non-maximum suppression to prediction outputs.\"\"\"\n    boxes = ops.xyxy2xywh(preds_in[0][0])\n    preds = torch.cat((boxes, preds_in[0][1]), -1).permute(0, 2, 1)\n    return ops.non_max_suppression(\n        preds,\n        self.args.conf,\n        self.args.iou,\n        labels=self.lb,\n        multi_label=False,\n        agnostic=self.args.single_cls,\n        max_det=self.args.max_det,\n        max_time_img=0.5,\n    )\n</code></pre>"},{"location":"reference/models/rtdetr/model/","title":"Reference for <code>ultralytics/models/rtdetr/model.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/rtdetr/model.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/rtdetr/model/#ultralytics.models.rtdetr.model.RTDETR","title":"<code>ultralytics.models.rtdetr.model.RTDETR</code>","text":"<p>             Bases: <code>Model</code></p> <p>Interface for Baidu's RT-DETR model. This Vision Transformer-based object detector provides real-time performance with high accuracy. It supports efficient hybrid encoding, IoU-aware query selection, and adaptable inference speed.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>Path to the pre-trained model. Defaults to 'rtdetr-l.pt'.</p> Source code in <code>ultralytics/models/rtdetr/model.py</code> <pre><code>class RTDETR(Model):\n    \"\"\"\n    Interface for Baidu's RT-DETR model. This Vision Transformer-based object detector provides real-time performance\n    with high accuracy. It supports efficient hybrid encoding, IoU-aware query selection, and adaptable inference speed.\n\n    Attributes:\n        model (str): Path to the pre-trained model. Defaults to 'rtdetr-l.pt'.\n    \"\"\"\n\n    def __init__(self, model=\"rtdetr-l.pt\") -&gt; None:\n        \"\"\"\n        Initializes the RT-DETR model with the given pre-trained model file. Supports .pt and .yaml formats.\n\n        Args:\n            model (str): Path to the pre-trained model. Defaults to 'rtdetr-l.pt'.\n\n        Raises:\n            NotImplementedError: If the model file extension is not 'pt', 'yaml', or 'yml'.\n        \"\"\"\n        if model and model.split(\".\")[-1] not in (\"pt\", \"yaml\", \"yml\"):\n            raise NotImplementedError(\"RT-DETR only supports creating from *.pt, *.yaml, or *.yml files.\")\n        super().__init__(model=model, task=\"detect\")\n\n    @property\n    def task_map(self) -&gt; dict:\n        \"\"\"\n        Returns a task map for RT-DETR, associating tasks with corresponding Ultralytics classes.\n\n        Returns:\n            dict: A dictionary mapping task names to Ultralytics task classes for the RT-DETR model.\n        \"\"\"\n        return {\n            \"detect\": {\n                \"predictor\": RTDETRPredictor,\n                \"validator\": RTDETRValidator,\n                \"trainer\": RTDETRTrainer,\n                \"model\": RTDETRDetectionModel,\n            }\n        }\n</code></pre>"},{"location":"reference/models/rtdetr/model/#ultralytics.models.rtdetr.model.RTDETR.task_map","title":"<code>task_map: dict</code>  <code>property</code>","text":"<p>Returns a task map for RT-DETR, associating tasks with corresponding Ultralytics classes.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary mapping task names to Ultralytics task classes for the RT-DETR model.</p>"},{"location":"reference/models/rtdetr/model/#ultralytics.models.rtdetr.model.RTDETR.__init__","title":"<code>__init__(model='rtdetr-l.pt')</code>","text":"<p>Initializes the RT-DETR model with the given pre-trained model file. Supports .pt and .yaml formats.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>Path to the pre-trained model. Defaults to 'rtdetr-l.pt'.</p> <code>'rtdetr-l.pt'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the model file extension is not 'pt', 'yaml', or 'yml'.</p> Source code in <code>ultralytics/models/rtdetr/model.py</code> <pre><code>def __init__(self, model=\"rtdetr-l.pt\") -&gt; None:\n    \"\"\"\n    Initializes the RT-DETR model with the given pre-trained model file. Supports .pt and .yaml formats.\n\n    Args:\n        model (str): Path to the pre-trained model. Defaults to 'rtdetr-l.pt'.\n\n    Raises:\n        NotImplementedError: If the model file extension is not 'pt', 'yaml', or 'yml'.\n    \"\"\"\n    if model and model.split(\".\")[-1] not in (\"pt\", \"yaml\", \"yml\"):\n        raise NotImplementedError(\"RT-DETR only supports creating from *.pt, *.yaml, or *.yml files.\")\n    super().__init__(model=model, task=\"detect\")\n</code></pre>"},{"location":"reference/models/rtdetr/predict/","title":"Reference for <code>ultralytics/models/rtdetr/predict.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/rtdetr/predict.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/rtdetr/predict/#ultralytics.models.rtdetr.predict.RTDETRPredictor","title":"<code>ultralytics.models.rtdetr.predict.RTDETRPredictor</code>","text":"<p>             Bases: <code>BasePredictor</code></p> <p>RT-DETR (Real-Time Detection Transformer) Predictor extending the BasePredictor class for making predictions using Baidu's RT-DETR model.</p> <p>This class leverages the power of Vision Transformers to provide real-time object detection while maintaining high accuracy. It supports key features like efficient hybrid encoding and IoU-aware query selection.</p> Example <pre><code>from ultralytics.utils import ASSETS\nfrom ultralytics.models.rtdetr import RTDETRPredictor\n\nargs = dict(model='rtdetr-l.pt', source=ASSETS)\npredictor = RTDETRPredictor(overrides=args)\npredictor.predict_cli()\n</code></pre> <p>Attributes:</p> Name Type Description <code>imgsz</code> <code>int</code> <p>Image size for inference (must be square and scale-filled).</p> <code>args</code> <code>dict</code> <p>Argument overrides for the predictor.</p> Source code in <code>ultralytics/models/rtdetr/predict.py</code> <pre><code>class RTDETRPredictor(BasePredictor):\n    \"\"\"\n    RT-DETR (Real-Time Detection Transformer) Predictor extending the BasePredictor class for making predictions using\n    Baidu's RT-DETR model.\n\n    This class leverages the power of Vision Transformers to provide real-time object detection while maintaining\n    high accuracy. It supports key features like efficient hybrid encoding and IoU-aware query selection.\n\n    Example:\n        ```python\n        from ultralytics.utils import ASSETS\n        from ultralytics.models.rtdetr import RTDETRPredictor\n\n        args = dict(model='rtdetr-l.pt', source=ASSETS)\n        predictor = RTDETRPredictor(overrides=args)\n        predictor.predict_cli()\n        ```\n\n    Attributes:\n        imgsz (int): Image size for inference (must be square and scale-filled).\n        args (dict): Argument overrides for the predictor.\n    \"\"\"\n\n    def postprocess(self, preds, img, orig_imgs):\n        \"\"\"\n        Postprocess the raw predictions from the model to generate bounding boxes and confidence scores.\n\n        The method filters detections based on confidence and class if specified in `self.args`.\n\n        Args:\n            preds (torch.Tensor): Raw predictions from the model.\n            img (torch.Tensor): Processed input images.\n            orig_imgs (list or torch.Tensor): Original, unprocessed images.\n\n        Returns:\n            (list[Results]): A list of Results objects containing the post-processed bounding boxes, confidence scores,\n                and class labels.\n        \"\"\"\n        nd = preds[0].shape[-1]\n        bboxes, scores = preds[0].split((4, nd - 4), dim=-1)\n\n        if not isinstance(orig_imgs, list):  # input images are a torch.Tensor, not a list\n            orig_imgs = ops.convert_torch2numpy_batch(orig_imgs)\n\n        results = []\n        for i, bbox in enumerate(bboxes):  # (300, 4)\n            bbox = ops.xywh2xyxy(bbox)\n            score, cls = scores[i].max(-1, keepdim=True)  # (300, 1)\n            idx = score.squeeze(-1) &gt; self.args.conf  # (300, )\n            if self.args.classes is not None:\n                idx = (cls == torch.tensor(self.args.classes, device=cls.device)).any(1) &amp; idx\n            pred = torch.cat([bbox, score, cls], dim=-1)[idx]  # filter\n            orig_img = orig_imgs[i]\n            oh, ow = orig_img.shape[:2]\n            pred[..., [0, 2]] *= ow\n            pred[..., [1, 3]] *= oh\n            img_path = self.batch[0][i]\n            results.append(Results(orig_img, path=img_path, names=self.model.names, boxes=pred))\n        return results\n\n    def pre_transform(self, im):\n        \"\"\"\n        Pre-transforms the input images before feeding them into the model for inference. The input images are\n        letterboxed to ensure a square aspect ratio and scale-filled. The size must be square(640) and scaleFilled.\n\n        Args:\n            im (list[np.ndarray] |torch.Tensor): Input images of shape (N,3,h,w) for tensor, [(h,w,3) x N] for list.\n\n        Returns:\n            (list): List of pre-transformed images ready for model inference.\n        \"\"\"\n        letterbox = LetterBox(self.imgsz, auto=False, scaleFill=True)\n        return [letterbox(image=x) for x in im]\n</code></pre>"},{"location":"reference/models/rtdetr/predict/#ultralytics.models.rtdetr.predict.RTDETRPredictor.postprocess","title":"<code>postprocess(preds, img, orig_imgs)</code>","text":"<p>Postprocess the raw predictions from the model to generate bounding boxes and confidence scores.</p> <p>The method filters detections based on confidence and class if specified in <code>self.args</code>.</p> <p>Parameters:</p> Name Type Description Default <code>preds</code> <code>Tensor</code> <p>Raw predictions from the model.</p> required <code>img</code> <code>Tensor</code> <p>Processed input images.</p> required <code>orig_imgs</code> <code>list or Tensor</code> <p>Original, unprocessed images.</p> required <p>Returns:</p> Type Description <code>list[Results]</code> <p>A list of Results objects containing the post-processed bounding boxes, confidence scores, and class labels.</p> Source code in <code>ultralytics/models/rtdetr/predict.py</code> <pre><code>def postprocess(self, preds, img, orig_imgs):\n    \"\"\"\n    Postprocess the raw predictions from the model to generate bounding boxes and confidence scores.\n\n    The method filters detections based on confidence and class if specified in `self.args`.\n\n    Args:\n        preds (torch.Tensor): Raw predictions from the model.\n        img (torch.Tensor): Processed input images.\n        orig_imgs (list or torch.Tensor): Original, unprocessed images.\n\n    Returns:\n        (list[Results]): A list of Results objects containing the post-processed bounding boxes, confidence scores,\n            and class labels.\n    \"\"\"\n    nd = preds[0].shape[-1]\n    bboxes, scores = preds[0].split((4, nd - 4), dim=-1)\n\n    if not isinstance(orig_imgs, list):  # input images are a torch.Tensor, not a list\n        orig_imgs = ops.convert_torch2numpy_batch(orig_imgs)\n\n    results = []\n    for i, bbox in enumerate(bboxes):  # (300, 4)\n        bbox = ops.xywh2xyxy(bbox)\n        score, cls = scores[i].max(-1, keepdim=True)  # (300, 1)\n        idx = score.squeeze(-1) &gt; self.args.conf  # (300, )\n        if self.args.classes is not None:\n            idx = (cls == torch.tensor(self.args.classes, device=cls.device)).any(1) &amp; idx\n        pred = torch.cat([bbox, score, cls], dim=-1)[idx]  # filter\n        orig_img = orig_imgs[i]\n        oh, ow = orig_img.shape[:2]\n        pred[..., [0, 2]] *= ow\n        pred[..., [1, 3]] *= oh\n        img_path = self.batch[0][i]\n        results.append(Results(orig_img, path=img_path, names=self.model.names, boxes=pred))\n    return results\n</code></pre>"},{"location":"reference/models/rtdetr/predict/#ultralytics.models.rtdetr.predict.RTDETRPredictor.pre_transform","title":"<code>pre_transform(im)</code>","text":"<p>Pre-transforms the input images before feeding them into the model for inference. The input images are letterboxed to ensure a square aspect ratio and scale-filled. The size must be square(640) and scaleFilled.</p> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>list[ndarray] | Tensor</code> <p>Input images of shape (N,3,h,w) for tensor, [(h,w,3) x N] for list.</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of pre-transformed images ready for model inference.</p> Source code in <code>ultralytics/models/rtdetr/predict.py</code> <pre><code>def pre_transform(self, im):\n    \"\"\"\n    Pre-transforms the input images before feeding them into the model for inference. The input images are\n    letterboxed to ensure a square aspect ratio and scale-filled. The size must be square(640) and scaleFilled.\n\n    Args:\n        im (list[np.ndarray] |torch.Tensor): Input images of shape (N,3,h,w) for tensor, [(h,w,3) x N] for list.\n\n    Returns:\n        (list): List of pre-transformed images ready for model inference.\n    \"\"\"\n    letterbox = LetterBox(self.imgsz, auto=False, scaleFill=True)\n    return [letterbox(image=x) for x in im]\n</code></pre>"},{"location":"reference/models/rtdetr/train/","title":"Reference for <code>ultralytics/models/rtdetr/train.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/rtdetr/train.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/rtdetr/train/#ultralytics.models.rtdetr.train.RTDETRTrainer","title":"<code>ultralytics.models.rtdetr.train.RTDETRTrainer</code>","text":"<p>             Bases: <code>DetectionTrainer</code></p> <p>Trainer class for the RT-DETR model developed by Baidu for real-time object detection. Extends the DetectionTrainer class for YOLO to adapt to the specific features and architecture of RT-DETR. This model leverages Vision Transformers and has capabilities like IoU-aware query selection and adaptable inference speed.</p> Notes <ul> <li>F.grid_sample used in RT-DETR does not support the <code>deterministic=True</code> argument.</li> <li>AMP training can lead to NaN outputs and may produce errors during bipartite graph matching.</li> </ul> Example <pre><code>from ultralytics.models.rtdetr.train import RTDETRTrainer\n\nargs = dict(model='rtdetr-l.yaml', data='coco8.yaml', imgsz=640, epochs=3)\ntrainer = RTDETRTrainer(overrides=args)\ntrainer.train()\n</code></pre> Source code in <code>ultralytics/models/rtdetr/train.py</code> <pre><code>class RTDETRTrainer(DetectionTrainer):\n    \"\"\"\n    Trainer class for the RT-DETR model developed by Baidu for real-time object detection. Extends the DetectionTrainer\n    class for YOLO to adapt to the specific features and architecture of RT-DETR. This model leverages Vision\n    Transformers and has capabilities like IoU-aware query selection and adaptable inference speed.\n\n    Notes:\n        - F.grid_sample used in RT-DETR does not support the `deterministic=True` argument.\n        - AMP training can lead to NaN outputs and may produce errors during bipartite graph matching.\n\n    Example:\n        ```python\n        from ultralytics.models.rtdetr.train import RTDETRTrainer\n\n        args = dict(model='rtdetr-l.yaml', data='coco8.yaml', imgsz=640, epochs=3)\n        trainer = RTDETRTrainer(overrides=args)\n        trainer.train()\n        ```\n    \"\"\"\n\n    def get_model(self, cfg=None, weights=None, verbose=True):\n        \"\"\"\n        Initialize and return an RT-DETR model for object detection tasks.\n\n        Args:\n            cfg (dict, optional): Model configuration. Defaults to None.\n            weights (str, optional): Path to pre-trained model weights. Defaults to None.\n            verbose (bool): Verbose logging if True. Defaults to True.\n\n        Returns:\n            (RTDETRDetectionModel): Initialized model.\n        \"\"\"\n        model = RTDETRDetectionModel(cfg, nc=self.data[\"nc\"], verbose=verbose and RANK == -1)\n        if weights:\n            model.load(weights)\n        return model\n\n    def build_dataset(self, img_path, mode=\"val\", batch=None):\n        \"\"\"\n        Build and return an RT-DETR dataset for training or validation.\n\n        Args:\n            img_path (str): Path to the folder containing images.\n            mode (str): Dataset mode, either 'train' or 'val'.\n            batch (int, optional): Batch size for rectangle training. Defaults to None.\n\n        Returns:\n            (RTDETRDataset): Dataset object for the specific mode.\n        \"\"\"\n        return RTDETRDataset(\n            img_path=img_path,\n            imgsz=self.args.imgsz,\n            batch_size=batch,\n            augment=mode == \"train\",\n            hyp=self.args,\n            rect=False,\n            cache=self.args.cache or None,\n            prefix=colorstr(f\"{mode}: \"),\n            data=self.data,\n        )\n\n    def get_validator(self):\n        \"\"\"\n        Returns a DetectionValidator suitable for RT-DETR model validation.\n\n        Returns:\n            (RTDETRValidator): Validator object for model validation.\n        \"\"\"\n        self.loss_names = \"giou_loss\", \"cls_loss\", \"l1_loss\"\n        return RTDETRValidator(self.test_loader, save_dir=self.save_dir, args=copy(self.args))\n\n    def preprocess_batch(self, batch):\n        \"\"\"\n        Preprocess a batch of images. Scales and converts the images to float format.\n\n        Args:\n            batch (dict): Dictionary containing a batch of images, bboxes, and labels.\n\n        Returns:\n            (dict): Preprocessed batch.\n        \"\"\"\n        batch = super().preprocess_batch(batch)\n        bs = len(batch[\"img\"])\n        batch_idx = batch[\"batch_idx\"]\n        gt_bbox, gt_class = [], []\n        for i in range(bs):\n            gt_bbox.append(batch[\"bboxes\"][batch_idx == i].to(batch_idx.device))\n            gt_class.append(batch[\"cls\"][batch_idx == i].to(device=batch_idx.device, dtype=torch.long))\n        return batch\n</code></pre>"},{"location":"reference/models/rtdetr/train/#ultralytics.models.rtdetr.train.RTDETRTrainer.build_dataset","title":"<code>build_dataset(img_path, mode='val', batch=None)</code>","text":"<p>Build and return an RT-DETR dataset for training or validation.</p> <p>Parameters:</p> Name Type Description Default <code>img_path</code> <code>str</code> <p>Path to the folder containing images.</p> required <code>mode</code> <code>str</code> <p>Dataset mode, either 'train' or 'val'.</p> <code>'val'</code> <code>batch</code> <code>int</code> <p>Batch size for rectangle training. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>RTDETRDataset</code> <p>Dataset object for the specific mode.</p> Source code in <code>ultralytics/models/rtdetr/train.py</code> <pre><code>def build_dataset(self, img_path, mode=\"val\", batch=None):\n    \"\"\"\n    Build and return an RT-DETR dataset for training or validation.\n\n    Args:\n        img_path (str): Path to the folder containing images.\n        mode (str): Dataset mode, either 'train' or 'val'.\n        batch (int, optional): Batch size for rectangle training. Defaults to None.\n\n    Returns:\n        (RTDETRDataset): Dataset object for the specific mode.\n    \"\"\"\n    return RTDETRDataset(\n        img_path=img_path,\n        imgsz=self.args.imgsz,\n        batch_size=batch,\n        augment=mode == \"train\",\n        hyp=self.args,\n        rect=False,\n        cache=self.args.cache or None,\n        prefix=colorstr(f\"{mode}: \"),\n        data=self.data,\n    )\n</code></pre>"},{"location":"reference/models/rtdetr/train/#ultralytics.models.rtdetr.train.RTDETRTrainer.get_model","title":"<code>get_model(cfg=None, weights=None, verbose=True)</code>","text":"<p>Initialize and return an RT-DETR model for object detection tasks.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>dict</code> <p>Model configuration. Defaults to None.</p> <code>None</code> <code>weights</code> <code>str</code> <p>Path to pre-trained model weights. Defaults to None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Verbose logging if True. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>RTDETRDetectionModel</code> <p>Initialized model.</p> Source code in <code>ultralytics/models/rtdetr/train.py</code> <pre><code>def get_model(self, cfg=None, weights=None, verbose=True):\n    \"\"\"\n    Initialize and return an RT-DETR model for object detection tasks.\n\n    Args:\n        cfg (dict, optional): Model configuration. Defaults to None.\n        weights (str, optional): Path to pre-trained model weights. Defaults to None.\n        verbose (bool): Verbose logging if True. Defaults to True.\n\n    Returns:\n        (RTDETRDetectionModel): Initialized model.\n    \"\"\"\n    model = RTDETRDetectionModel(cfg, nc=self.data[\"nc\"], verbose=verbose and RANK == -1)\n    if weights:\n        model.load(weights)\n    return model\n</code></pre>"},{"location":"reference/models/rtdetr/train/#ultralytics.models.rtdetr.train.RTDETRTrainer.get_validator","title":"<code>get_validator()</code>","text":"<p>Returns a DetectionValidator suitable for RT-DETR model validation.</p> <p>Returns:</p> Type Description <code>RTDETRValidator</code> <p>Validator object for model validation.</p> Source code in <code>ultralytics/models/rtdetr/train.py</code> <pre><code>def get_validator(self):\n    \"\"\"\n    Returns a DetectionValidator suitable for RT-DETR model validation.\n\n    Returns:\n        (RTDETRValidator): Validator object for model validation.\n    \"\"\"\n    self.loss_names = \"giou_loss\", \"cls_loss\", \"l1_loss\"\n    return RTDETRValidator(self.test_loader, save_dir=self.save_dir, args=copy(self.args))\n</code></pre>"},{"location":"reference/models/rtdetr/train/#ultralytics.models.rtdetr.train.RTDETRTrainer.preprocess_batch","title":"<code>preprocess_batch(batch)</code>","text":"<p>Preprocess a batch of images. Scales and converts the images to float format.</p> <p>Parameters:</p> Name Type Description Default <code>batch</code> <code>dict</code> <p>Dictionary containing a batch of images, bboxes, and labels.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Preprocessed batch.</p> Source code in <code>ultralytics/models/rtdetr/train.py</code> <pre><code>def preprocess_batch(self, batch):\n    \"\"\"\n    Preprocess a batch of images. Scales and converts the images to float format.\n\n    Args:\n        batch (dict): Dictionary containing a batch of images, bboxes, and labels.\n\n    Returns:\n        (dict): Preprocessed batch.\n    \"\"\"\n    batch = super().preprocess_batch(batch)\n    bs = len(batch[\"img\"])\n    batch_idx = batch[\"batch_idx\"]\n    gt_bbox, gt_class = [], []\n    for i in range(bs):\n        gt_bbox.append(batch[\"bboxes\"][batch_idx == i].to(batch_idx.device))\n        gt_class.append(batch[\"cls\"][batch_idx == i].to(device=batch_idx.device, dtype=torch.long))\n    return batch\n</code></pre>"},{"location":"reference/models/rtdetr/val/","title":"Reference for <code>ultralytics/models/rtdetr/val.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/rtdetr/val.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p>"},{"location":"reference/models/rtdetr/val/#ultralytics.models.rtdetr.val.RTDETRDataset","title":"<code>ultralytics.models.rtdetr.val.RTDETRDataset</code>","text":"<p>             Bases: <code>YOLODataset</code></p> <p>Real-Time DEtection and TRacking (RT-DETR) dataset class extending the base YOLODataset class.</p> <p>This specialized dataset class is designed for use with the RT-DETR object detection model and is optimized for real-time detection and tracking tasks.</p> Source code in <code>ultralytics/models/rtdetr/val.py</code> <pre><code>class RTDETRDataset(YOLODataset):\n    \"\"\"\n    Real-Time DEtection and TRacking (RT-DETR) dataset class extending the base YOLODataset class.\n\n    This specialized dataset class is designed for use with the RT-DETR object detection model and is optimized for\n    real-time detection and tracking tasks.\n    \"\"\"\n\n    def __init__(self, *args, data=None, **kwargs):\n        \"\"\"Initialize the RTDETRDataset class by inheriting from the YOLODataset class.\"\"\"\n        super().__init__(*args, data=data, **kwargs)\n\n    # NOTE: add stretch version load_image for RTDETR mosaic\n    def load_image(self, i, rect_mode=False):\n        \"\"\"Loads 1 image from dataset index 'i', returns (im, resized hw).\"\"\"\n        return super().load_image(i=i, rect_mode=rect_mode)\n\n    def build_transforms(self, hyp=None):\n        \"\"\"Temporary, only for evaluation.\"\"\"\n        if self.augment:\n            hyp.mosaic = hyp.mosaic if self.augment and not self.rect else 0.0\n            hyp.mixup = hyp.mixup if self.augment and not self.rect else 0.0\n            transforms = v8_transforms(self, self.imgsz, hyp, stretch=True)\n        else:\n            # transforms = Compose([LetterBox(new_shape=(self.imgsz, self.imgsz), auto=False, scaleFill=True)])\n            transforms = Compose([])\n        transforms.append(\n            Format(\n                bbox_format=\"xywh\",\n                normalize=True,\n                return_mask=self.use_segments,\n                return_keypoint=self.use_keypoints,\n                batch_idx=True,\n                mask_ratio=hyp.mask_ratio,\n                mask_overlap=hyp.overlap_mask,\n            )\n        )\n        return transforms\n</code></pre>"},{"location":"reference/models/rtdetr/val/#ultralytics.models.rtdetr.val.RTDETRDataset.__init__","title":"<code>__init__(*args, data=None, **kwargs)</code>","text":"<p>Initialize the RTDETRDataset class by inheriting from the YOLODataset class.</p> Source code in <code>ultralytics/models/rtdetr/val.py</code> <pre><code>def __init__(self, *args, data=None, **kwargs):\n    \"\"\"Initialize the RTDETRDataset class by inheriting from the YOLODataset class.\"\"\"\n    super().__init__(*args, data=data, **kwargs)\n</code></pre>"},{"location":"reference/models/rtdetr/val/#ultralytics.models.rtdetr.val.RTDETRDataset.build_transforms","title":"<code>build_transforms(hyp=None)</code>","text":"<p>Temporary, only for evaluation.</p> Source code in <code>ultralytics/models/rtdetr/val.py</code> <pre><code>def build_transforms(self, hyp=None):\n    \"\"\"Temporary, only for evaluation.\"\"\"\n    if self.augment:\n        hyp.mosaic = hyp.mosaic if self.augment and not self.rect else 0.0\n        hyp.mixup = hyp.mixup if self.augment and not self.rect else 0.0\n        transforms = v8_transforms(self, self.imgsz, hyp, stretch=True)\n    else:\n        # transforms = Compose([LetterBox(new_shape=(self.imgsz, self.imgsz), auto=False, scaleFill=True)])\n        transforms = Compose([])\n    transforms.append(\n        Format(\n            bbox_format=\"xywh\",\n            normalize=True,\n            return_mask=self.use_segments,\n            return_keypoint=self.use_keypoints,\n            batch_idx=True,\n            mask_ratio=hyp.mask_ratio,\n            mask_overlap=hyp.overlap_mask,\n        )\n    )\n    return transforms\n</code></pre>"},{"location":"reference/models/rtdetr/val/#ultralytics.models.rtdetr.val.RTDETRDataset.load_image","title":"<code>load_image(i, rect_mode=False)</code>","text":"<p>Loads 1 image from dataset index 'i', returns (im, resized hw).</p> Source code in <code>ultralytics/models/rtdetr/val.py</code> <pre><code>def load_image(self, i, rect_mode=False):\n    \"\"\"Loads 1 image from dataset index 'i', returns (im, resized hw).\"\"\"\n    return super().load_image(i=i, rect_mode=rect_mode)\n</code></pre>"},{"location":"reference/models/rtdetr/val/#ultralytics.models.rtdetr.val.RTDETRValidator","title":"<code>ultralytics.models.rtdetr.val.RTDETRValidator</code>","text":"<p>             Bases: <code>DetectionValidator</code></p> <p>RTDETRValidator extends the DetectionValidator class to provide validation capabilities specifically tailored for the RT-DETR (Real-Time DETR) object detection model.</p> <p>The class allows building of an RTDETR-specific dataset for validation, applies Non-maximum suppression for post-processing, and updates evaluation metrics accordingly.</p> Example <pre><code>from ultralytics.models.rtdetr import RTDETRValidator\n\nargs = dict(model='rtdetr-l.pt', data='coco8.yaml')\nvalidator = RTDETRValidator(args=args)\nvalidator()\n</code></pre> Note <p>For further details on the attributes and methods, refer to the parent DetectionValidator class.</p> Source code in <code>ultralytics/models/rtdetr/val.py</code> <pre><code>class RTDETRValidator(DetectionValidator):\n    \"\"\"\n    RTDETRValidator extends the DetectionValidator class to provide validation capabilities specifically tailored for\n    the RT-DETR (Real-Time DETR) object detection model.\n\n    The class allows building of an RTDETR-specific dataset for validation, applies Non-maximum suppression for\n    post-processing, and updates evaluation metrics accordingly.\n\n    Example:\n        ```python\n        from ultralytics.models.rtdetr import RTDETRValidator\n\n        args = dict(model='rtdetr-l.pt', data='coco8.yaml')\n        validator = RTDETRValidator(args=args)\n        validator()\n        ```\n\n    Note:\n        For further details on the attributes and methods, refer to the parent DetectionValidator class.\n    \"\"\"\n\n    def build_dataset(self, img_path, mode=\"val\", batch=None):\n        \"\"\"\n        Build an RTDETR Dataset.\n\n        Args:\n            img_path (str): Path to the folder containing images.\n            mode (str): `train` mode or `val` mode, users are able to customize different augmentations for each mode.\n            batch (int, optional): Size of batches, this is for `rect`. Defaults to None.\n        \"\"\"\n        return RTDETRDataset(\n            img_path=img_path,\n            imgsz=self.args.imgsz,\n            batch_size=batch,\n            augment=False,  # no augmentation\n            hyp=self.args,\n            rect=False,  # no rect\n            cache=self.args.cache or None,\n            prefix=colorstr(f\"{mode}: \"),\n            data=self.data,\n        )\n\n    def postprocess(self, preds):\n        \"\"\"Apply Non-maximum suppression to prediction outputs.\"\"\"\n        bs, _, nd = preds[0].shape\n        bboxes, scores = preds[0].split((4, nd - 4), dim=-1)\n        bboxes *= self.args.imgsz\n        outputs = [torch.zeros((0, 6), device=bboxes.device)] * bs\n        for i, bbox in enumerate(bboxes):  # (300, 4)\n            bbox = ops.xywh2xyxy(bbox)\n            score, cls = scores[i].max(-1)  # (300, )\n            # Do not need threshold for evaluation as only got 300 boxes here\n            # idx = score &gt; self.args.conf\n            pred = torch.cat([bbox, score[..., None], cls[..., None]], dim=-1)  # filter\n            # Sort by confidence to correctly get internal metrics\n            pred = pred[score.argsort(descending=True)]\n            outputs[i] = pred  # [idx]\n\n        return outputs\n\n    def _prepare_batch(self, si, batch):\n        \"\"\"Prepares a batch for training or inference by applying transformations.\"\"\"\n        idx = batch[\"batch_idx\"] == si\n        cls = batch[\"cls\"][idx].squeeze(-1)\n        bbox = batch[\"bboxes\"][idx]\n        ori_shape = batch[\"ori_shape\"][si]\n        imgsz = batch[\"img\"].shape[2:]\n        ratio_pad = batch[\"ratio_pad\"][si]\n        if len(cls):\n            bbox = ops.xywh2xyxy(bbox)  # target boxes\n            bbox[..., [0, 2]] *= ori_shape[1]  # native-space pred\n            bbox[..., [1, 3]] *= ori_shape[0]  # native-space pred\n        prepared_batch = dict(cls=cls, bbox=bbox, ori_shape=ori_shape, imgsz=imgsz, ratio_pad=ratio_pad)\n        return prepared_batch\n\n    def _prepare_pred(self, pred, pbatch):\n        \"\"\"Prepares and returns a batch with transformed bounding boxes and class labels.\"\"\"\n        predn = pred.clone()\n        predn[..., [0, 2]] *= pbatch[\"ori_shape\"][1] / self.args.imgsz  # native-space pred\n        predn[..., [1, 3]] *= pbatch[\"ori_shape\"][0] / self.args.imgsz  # native-space pred\n        return predn.float()\n</code></pre>"},{"location":"reference/models/rtdetr/val/#ultralytics.models.rtdetr.val.RTDETRValidator.build_dataset","title":"<code>build_dataset(img_path, mode='val', batch=None)</code>","text":"<p>Build an RTDETR Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>img_path</code> <code>str</code> <p>Path to the folder containing images.</p> required <code>mode</code> <code>str</code> <p><code>train</code> mode or <code>val</code> mode, users are able to customize different augmentations for each mode.</p> <code>'val'</code> <code>batch</code> <code>int</code> <p>Size of batches, this is for <code>rect</code>. Defaults to None.</p> <code>None</code> Source code in <code>ultralytics/models/rtdetr/val.py</code> <pre><code>def build_dataset(self, img_path, mode=\"val\", batch=None):\n    \"\"\"\n    Build an RTDETR Dataset.\n\n    Args:\n        img_path (str): Path to the folder containing images.\n        mode (str): `train` mode or `val` mode, users are able to customize different augmentations for each mode.\n        batch (int, optional): Size of batches, this is for `rect`. Defaults to None.\n    \"\"\"\n    return RTDETRDataset(\n        img_path=img_path,\n        imgsz=self.args.imgsz,\n        batch_size=batch,\n        augment=False,  # no augmentation\n        hyp=self.args,\n        rect=False,  # no rect\n        cache=self.args.cache or None,\n        prefix=colorstr(f\"{mode}: \"),\n        data=self.data,\n    )\n</code></pre>"},{"location":"reference/models/rtdetr/val/#ultralytics.models.rtdetr.val.RTDETRValidator.postprocess","title":"<code>postprocess(preds)</code>","text":"<p>Apply Non-maximum suppression to prediction outputs.</p> Source code in <code>ultralytics/models/rtdetr/val.py</code> <pre><code>def postprocess(self, preds):\n    \"\"\"Apply Non-maximum suppression to prediction outputs.\"\"\"\n    bs, _, nd = preds[0].shape\n    bboxes, scores = preds[0].split((4, nd - 4), dim=-1)\n    bboxes *= self.args.imgsz\n    outputs = [torch.zeros((0, 6), device=bboxes.device)] * bs\n    for i, bbox in enumerate(bboxes):  # (300, 4)\n        bbox = ops.xywh2xyxy(bbox)\n        score, cls = scores[i].max(-1)  # (300, )\n        # Do not need threshold for evaluation as only got 300 boxes here\n        # idx = score &gt; self.args.conf\n        pred = torch.cat([bbox, score[..., None], cls[..., None]], dim=-1)  # filter\n        # Sort by confidence to correctly get internal metrics\n        pred = pred[score.argsort(descending=True)]\n        outputs[i] = pred  # [idx]\n\n    return outputs\n</code></pre>"},{"location":"reference/models/sam/amg/","title":"Reference for <code>ultralytics/models/sam/amg.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/sam/amg.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/models/sam/amg/#ultralytics.models.sam.amg.is_box_near_crop_edge","title":"<code>ultralytics.models.sam.amg.is_box_near_crop_edge(boxes, crop_box, orig_box, atol=20.0)</code>","text":"<p>Return a boolean tensor indicating if boxes are near the crop edge.</p> Source code in <code>ultralytics/models/sam/amg.py</code> <pre><code>def is_box_near_crop_edge(\n    boxes: torch.Tensor, crop_box: List[int], orig_box: List[int], atol: float = 20.0\n) -&gt; torch.Tensor:\n    \"\"\"Return a boolean tensor indicating if boxes are near the crop edge.\"\"\"\n    crop_box_torch = torch.as_tensor(crop_box, dtype=torch.float, device=boxes.device)\n    orig_box_torch = torch.as_tensor(orig_box, dtype=torch.float, device=boxes.device)\n    boxes = uncrop_boxes_xyxy(boxes, crop_box).float()\n    near_crop_edge = torch.isclose(boxes, crop_box_torch[None, :], atol=atol, rtol=0)\n    near_image_edge = torch.isclose(boxes, orig_box_torch[None, :], atol=atol, rtol=0)\n    near_crop_edge = torch.logical_and(near_crop_edge, ~near_image_edge)\n    return torch.any(near_crop_edge, dim=1)\n</code></pre>"},{"location":"reference/models/sam/amg/#ultralytics.models.sam.amg.batch_iterator","title":"<code>ultralytics.models.sam.amg.batch_iterator(batch_size, *args)</code>","text":"<p>Yield batches of data from the input arguments.</p> Source code in <code>ultralytics/models/sam/amg.py</code> <pre><code>def batch_iterator(batch_size: int, *args) -&gt; Generator[List[Any], None, None]:\n    \"\"\"Yield batches of data from the input arguments.\"\"\"\n    assert args and all(len(a) == len(args[0]) for a in args), \"Batched iteration must have same-size inputs.\"\n    n_batches = len(args[0]) // batch_size + int(len(args[0]) % batch_size != 0)\n    for b in range(n_batches):\n        yield [arg[b * batch_size : (b + 1) * batch_size] for arg in args]\n</code></pre>"},{"location":"reference/models/sam/amg/#ultralytics.models.sam.amg.calculate_stability_score","title":"<code>ultralytics.models.sam.amg.calculate_stability_score(masks, mask_threshold, threshold_offset)</code>","text":"<p>Computes the stability score for a batch of masks.</p> <p>The stability score is the IoU between the binary masks obtained by thresholding the predicted mask logits at high and low values.</p> Source code in <code>ultralytics/models/sam/amg.py</code> <pre><code>def calculate_stability_score(masks: torch.Tensor, mask_threshold: float, threshold_offset: float) -&gt; torch.Tensor:\n    \"\"\"\n    Computes the stability score for a batch of masks.\n\n    The stability score is the IoU between the binary masks obtained by thresholding the predicted mask logits at high\n    and low values.\n    \"\"\"\n    # One mask is always contained inside the other.\n    # Save memory by preventing unnecessary cast to torch.int64\n    intersections = (masks &gt; (mask_threshold + threshold_offset)).sum(-1, dtype=torch.int16).sum(-1, dtype=torch.int32)\n    unions = (masks &gt; (mask_threshold - threshold_offset)).sum(-1, dtype=torch.int16).sum(-1, dtype=torch.int32)\n    return intersections / unions\n</code></pre>"},{"location":"reference/models/sam/amg/#ultralytics.models.sam.amg.build_point_grid","title":"<code>ultralytics.models.sam.amg.build_point_grid(n_per_side)</code>","text":"<p>Generate a 2D grid of evenly spaced points in the range [0,1]x[0,1].</p> Source code in <code>ultralytics/models/sam/amg.py</code> <pre><code>def build_point_grid(n_per_side: int) -&gt; np.ndarray:\n    \"\"\"Generate a 2D grid of evenly spaced points in the range [0,1]x[0,1].\"\"\"\n    offset = 1 / (2 * n_per_side)\n    points_one_side = np.linspace(offset, 1 - offset, n_per_side)\n    points_x = np.tile(points_one_side[None, :], (n_per_side, 1))\n    points_y = np.tile(points_one_side[:, None], (1, n_per_side))\n    return np.stack([points_x, points_y], axis=-1).reshape(-1, 2)\n</code></pre>"},{"location":"reference/models/sam/amg/#ultralytics.models.sam.amg.build_all_layer_point_grids","title":"<code>ultralytics.models.sam.amg.build_all_layer_point_grids(n_per_side, n_layers, scale_per_layer)</code>","text":"<p>Generate point grids for all crop layers.</p> Source code in <code>ultralytics/models/sam/amg.py</code> <pre><code>def build_all_layer_point_grids(n_per_side: int, n_layers: int, scale_per_layer: int) -&gt; List[np.ndarray]:\n    \"\"\"Generate point grids for all crop layers.\"\"\"\n    return [build_point_grid(int(n_per_side / (scale_per_layer**i))) for i in range(n_layers + 1)]\n</code></pre>"},{"location":"reference/models/sam/amg/#ultralytics.models.sam.amg.generate_crop_boxes","title":"<code>ultralytics.models.sam.amg.generate_crop_boxes(im_size, n_layers, overlap_ratio)</code>","text":"<p>Generates a list of crop boxes of different sizes.</p> <p>Each layer has (2i)2 boxes for the ith layer.</p> Source code in <code>ultralytics/models/sam/amg.py</code> <pre><code>def generate_crop_boxes(\n    im_size: Tuple[int, ...], n_layers: int, overlap_ratio: float\n) -&gt; Tuple[List[List[int]], List[int]]:\n    \"\"\"\n    Generates a list of crop boxes of different sizes.\n\n    Each layer has (2**i)**2 boxes for the ith layer.\n    \"\"\"\n    crop_boxes, layer_idxs = [], []\n    im_h, im_w = im_size\n    short_side = min(im_h, im_w)\n\n    # Original image\n    crop_boxes.append([0, 0, im_w, im_h])\n    layer_idxs.append(0)\n\n    def crop_len(orig_len, n_crops, overlap):\n        \"\"\"Crops bounding boxes to the size of the input image.\"\"\"\n        return int(math.ceil((overlap * (n_crops - 1) + orig_len) / n_crops))\n\n    for i_layer in range(n_layers):\n        n_crops_per_side = 2 ** (i_layer + 1)\n        overlap = int(overlap_ratio * short_side * (2 / n_crops_per_side))\n\n        crop_w = crop_len(im_w, n_crops_per_side, overlap)\n        crop_h = crop_len(im_h, n_crops_per_side, overlap)\n\n        crop_box_x0 = [int((crop_w - overlap) * i) for i in range(n_crops_per_side)]\n        crop_box_y0 = [int((crop_h - overlap) * i) for i in range(n_crops_per_side)]\n\n        # Crops in XYWH format\n        for x0, y0 in product(crop_box_x0, crop_box_y0):\n            box = [x0, y0, min(x0 + crop_w, im_w), min(y0 + crop_h, im_h)]\n            crop_boxes.append(box)\n            layer_idxs.append(i_layer + 1)\n\n    return crop_boxes, layer_idxs\n</code></pre>"},{"location":"reference/models/sam/amg/#ultralytics.models.sam.amg.uncrop_boxes_xyxy","title":"<code>ultralytics.models.sam.amg.uncrop_boxes_xyxy(boxes, crop_box)</code>","text":"<p>Uncrop bounding boxes by adding the crop box offset.</p> Source code in <code>ultralytics/models/sam/amg.py</code> <pre><code>def uncrop_boxes_xyxy(boxes: torch.Tensor, crop_box: List[int]) -&gt; torch.Tensor:\n    \"\"\"Uncrop bounding boxes by adding the crop box offset.\"\"\"\n    x0, y0, _, _ = crop_box\n    offset = torch.tensor([[x0, y0, x0, y0]], device=boxes.device)\n    # Check if boxes has a channel dimension\n    if len(boxes.shape) == 3:\n        offset = offset.unsqueeze(1)\n    return boxes + offset\n</code></pre>"},{"location":"reference/models/sam/amg/#ultralytics.models.sam.amg.uncrop_points","title":"<code>ultralytics.models.sam.amg.uncrop_points(points, crop_box)</code>","text":"<p>Uncrop points by adding the crop box offset.</p> Source code in <code>ultralytics/models/sam/amg.py</code> <pre><code>def uncrop_points(points: torch.Tensor, crop_box: List[int]) -&gt; torch.Tensor:\n    \"\"\"Uncrop points by adding the crop box offset.\"\"\"\n    x0, y0, _, _ = crop_box\n    offset = torch.tensor([[x0, y0]], device=points.device)\n    # Check if points has a channel dimension\n    if len(points.shape) == 3:\n        offset = offset.unsqueeze(1)\n    return points + offset\n</code></pre>"},{"location":"reference/models/sam/amg/#ultralytics.models.sam.amg.uncrop_masks","title":"<code>ultralytics.models.sam.amg.uncrop_masks(masks, crop_box, orig_h, orig_w)</code>","text":"<p>Uncrop masks by padding them to the original image size.</p> Source code in <code>ultralytics/models/sam/amg.py</code> <pre><code>def uncrop_masks(masks: torch.Tensor, crop_box: List[int], orig_h: int, orig_w: int) -&gt; torch.Tensor:\n    \"\"\"Uncrop masks by padding them to the original image size.\"\"\"\n    x0, y0, x1, y1 = crop_box\n    if x0 == 0 and y0 == 0 and x1 == orig_w and y1 == orig_h:\n        return masks\n    # Coordinate transform masks\n    pad_x, pad_y = orig_w - (x1 - x0), orig_h - (y1 - y0)\n    pad = (x0, pad_x - x0, y0, pad_y - y0)\n    return torch.nn.functional.pad(masks, pad, value=0)\n</code></pre>"},{"location":"reference/models/sam/amg/#ultralytics.models.sam.amg.remove_small_regions","title":"<code>ultralytics.models.sam.amg.remove_small_regions(mask, area_thresh, mode)</code>","text":"<p>Remove small disconnected regions or holes in a mask, returning the mask and a modification indicator.</p> Source code in <code>ultralytics/models/sam/amg.py</code> <pre><code>def remove_small_regions(mask: np.ndarray, area_thresh: float, mode: str) -&gt; Tuple[np.ndarray, bool]:\n    \"\"\"Remove small disconnected regions or holes in a mask, returning the mask and a modification indicator.\"\"\"\n    import cv2  # type: ignore\n\n    assert mode in {\"holes\", \"islands\"}\n    correct_holes = mode == \"holes\"\n    working_mask = (correct_holes ^ mask).astype(np.uint8)\n    n_labels, regions, stats, _ = cv2.connectedComponentsWithStats(working_mask, 8)\n    sizes = stats[:, -1][1:]  # Row 0 is background label\n    small_regions = [i + 1 for i, s in enumerate(sizes) if s &lt; area_thresh]\n    if not small_regions:\n        return mask, False\n    fill_labels = [0] + small_regions\n    if not correct_holes:\n        # If every region is below threshold, keep largest\n        fill_labels = [i for i in range(n_labels) if i not in fill_labels] or [int(np.argmax(sizes)) + 1]\n    mask = np.isin(regions, fill_labels)\n    return mask, True\n</code></pre>"},{"location":"reference/models/sam/amg/#ultralytics.models.sam.amg.batched_mask_to_box","title":"<code>ultralytics.models.sam.amg.batched_mask_to_box(masks)</code>","text":"<p>Calculates boxes in XYXY format around masks.</p> <p>Return [0,0,0,0] for an empty mask. For input shape C1xC2x...xHxW, the output shape is C1xC2x...x4.</p> Source code in <code>ultralytics/models/sam/amg.py</code> <pre><code>def batched_mask_to_box(masks: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"\n    Calculates boxes in XYXY format around masks.\n\n    Return [0,0,0,0] for an empty mask. For input shape C1xC2x...xHxW, the output shape is C1xC2x...x4.\n    \"\"\"\n    # torch.max below raises an error on empty inputs, just skip in this case\n    if torch.numel(masks) == 0:\n        return torch.zeros(*masks.shape[:-2], 4, device=masks.device)\n\n    # Normalize shape to CxHxW\n    shape = masks.shape\n    h, w = shape[-2:]\n    masks = masks.flatten(0, -3) if len(shape) &gt; 2 else masks.unsqueeze(0)\n    # Get top and bottom edges\n    in_height, _ = torch.max(masks, dim=-1)\n    in_height_coords = in_height * torch.arange(h, device=in_height.device)[None, :]\n    bottom_edges, _ = torch.max(in_height_coords, dim=-1)\n    in_height_coords = in_height_coords + h * (~in_height)\n    top_edges, _ = torch.min(in_height_coords, dim=-1)\n\n    # Get left and right edges\n    in_width, _ = torch.max(masks, dim=-2)\n    in_width_coords = in_width * torch.arange(w, device=in_width.device)[None, :]\n    right_edges, _ = torch.max(in_width_coords, dim=-1)\n    in_width_coords = in_width_coords + w * (~in_width)\n    left_edges, _ = torch.min(in_width_coords, dim=-1)\n\n    # If the mask is empty the right edge will be to the left of the left edge.\n    # Replace these boxes with [0, 0, 0, 0]\n    empty_filter = (right_edges &lt; left_edges) | (bottom_edges &lt; top_edges)\n    out = torch.stack([left_edges, top_edges, right_edges, bottom_edges], dim=-1)\n    out = out * (~empty_filter).unsqueeze(-1)\n\n    # Return to original shape\n    return out.reshape(*shape[:-2], 4) if len(shape) &gt; 2 else out[0]\n</code></pre>"},{"location":"reference/models/sam/build/","title":"Reference for <code>ultralytics/models/sam/build.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/sam/build.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/models/sam/build/#ultralytics.models.sam.build.build_sam_vit_h","title":"<code>ultralytics.models.sam.build.build_sam_vit_h(checkpoint=None)</code>","text":"<p>Build and return a Segment Anything Model (SAM) h-size model.</p> Source code in <code>ultralytics/models/sam/build.py</code> <pre><code>def build_sam_vit_h(checkpoint=None):\n    \"\"\"Build and return a Segment Anything Model (SAM) h-size model.\"\"\"\n    return _build_sam(\n        encoder_embed_dim=1280,\n        encoder_depth=32,\n        encoder_num_heads=16,\n        encoder_global_attn_indexes=[7, 15, 23, 31],\n        checkpoint=checkpoint,\n    )\n</code></pre>"},{"location":"reference/models/sam/build/#ultralytics.models.sam.build.build_sam_vit_l","title":"<code>ultralytics.models.sam.build.build_sam_vit_l(checkpoint=None)</code>","text":"<p>Build and return a Segment Anything Model (SAM) l-size model.</p> Source code in <code>ultralytics/models/sam/build.py</code> <pre><code>def build_sam_vit_l(checkpoint=None):\n    \"\"\"Build and return a Segment Anything Model (SAM) l-size model.\"\"\"\n    return _build_sam(\n        encoder_embed_dim=1024,\n        encoder_depth=24,\n        encoder_num_heads=16,\n        encoder_global_attn_indexes=[5, 11, 17, 23],\n        checkpoint=checkpoint,\n    )\n</code></pre>"},{"location":"reference/models/sam/build/#ultralytics.models.sam.build.build_sam_vit_b","title":"<code>ultralytics.models.sam.build.build_sam_vit_b(checkpoint=None)</code>","text":"<p>Build and return a Segment Anything Model (SAM) b-size model.</p> Source code in <code>ultralytics/models/sam/build.py</code> <pre><code>def build_sam_vit_b(checkpoint=None):\n    \"\"\"Build and return a Segment Anything Model (SAM) b-size model.\"\"\"\n    return _build_sam(\n        encoder_embed_dim=768,\n        encoder_depth=12,\n        encoder_num_heads=12,\n        encoder_global_attn_indexes=[2, 5, 8, 11],\n        checkpoint=checkpoint,\n    )\n</code></pre>"},{"location":"reference/models/sam/build/#ultralytics.models.sam.build.build_mobile_sam","title":"<code>ultralytics.models.sam.build.build_mobile_sam(checkpoint=None)</code>","text":"<p>Build and return Mobile Segment Anything Model (Mobile-SAM).</p> Source code in <code>ultralytics/models/sam/build.py</code> <pre><code>def build_mobile_sam(checkpoint=None):\n    \"\"\"Build and return Mobile Segment Anything Model (Mobile-SAM).\"\"\"\n    return _build_sam(\n        encoder_embed_dim=[64, 128, 160, 320],\n        encoder_depth=[2, 2, 6, 2],\n        encoder_num_heads=[2, 4, 5, 10],\n        encoder_global_attn_indexes=None,\n        mobile_sam=True,\n        checkpoint=checkpoint,\n    )\n</code></pre>"},{"location":"reference/models/sam/build/#ultralytics.models.sam.build._build_sam","title":"<code>ultralytics.models.sam.build._build_sam(encoder_embed_dim, encoder_depth, encoder_num_heads, encoder_global_attn_indexes, checkpoint=None, mobile_sam=False)</code>","text":"<p>Builds the selected SAM model architecture.</p> Source code in <code>ultralytics/models/sam/build.py</code> <pre><code>def _build_sam(\n    encoder_embed_dim, encoder_depth, encoder_num_heads, encoder_global_attn_indexes, checkpoint=None, mobile_sam=False\n):\n    \"\"\"Builds the selected SAM model architecture.\"\"\"\n    prompt_embed_dim = 256\n    image_size = 1024\n    vit_patch_size = 16\n    image_embedding_size = image_size // vit_patch_size\n    image_encoder = (\n        TinyViT(\n            img_size=1024,\n            in_chans=3,\n            num_classes=1000,\n            embed_dims=encoder_embed_dim,\n            depths=encoder_depth,\n            num_heads=encoder_num_heads,\n            window_sizes=[7, 7, 14, 7],\n            mlp_ratio=4.0,\n            drop_rate=0.0,\n            drop_path_rate=0.0,\n            use_checkpoint=False,\n            mbconv_expand_ratio=4.0,\n            local_conv_size=3,\n            layer_lr_decay=0.8,\n        )\n        if mobile_sam\n        else ImageEncoderViT(\n            depth=encoder_depth,\n            embed_dim=encoder_embed_dim,\n            img_size=image_size,\n            mlp_ratio=4,\n            norm_layer=partial(torch.nn.LayerNorm, eps=1e-6),\n            num_heads=encoder_num_heads,\n            patch_size=vit_patch_size,\n            qkv_bias=True,\n            use_rel_pos=True,\n            global_attn_indexes=encoder_global_attn_indexes,\n            window_size=14,\n            out_chans=prompt_embed_dim,\n        )\n    )\n    sam = Sam(\n        image_encoder=image_encoder,\n        prompt_encoder=PromptEncoder(\n            embed_dim=prompt_embed_dim,\n            image_embedding_size=(image_embedding_size, image_embedding_size),\n            input_image_size=(image_size, image_size),\n            mask_in_chans=16,\n        ),\n        mask_decoder=MaskDecoder(\n            num_multimask_outputs=3,\n            transformer=TwoWayTransformer(\n                depth=2,\n                embedding_dim=prompt_embed_dim,\n                mlp_dim=2048,\n                num_heads=8,\n            ),\n            transformer_dim=prompt_embed_dim,\n            iou_head_depth=3,\n            iou_head_hidden_dim=256,\n        ),\n        pixel_mean=[123.675, 116.28, 103.53],\n        pixel_std=[58.395, 57.12, 57.375],\n    )\n    if checkpoint is not None:\n        checkpoint = attempt_download_asset(checkpoint)\n        with open(checkpoint, \"rb\") as f:\n            state_dict = torch.load(f)\n        sam.load_state_dict(state_dict)\n    sam.eval()\n    # sam.load_state_dict(torch.load(checkpoint), strict=True)\n    # sam.eval()\n    return sam\n</code></pre>"},{"location":"reference/models/sam/build/#ultralytics.models.sam.build.build_sam","title":"<code>ultralytics.models.sam.build.build_sam(ckpt='sam_b.pt')</code>","text":"<p>Build a SAM model specified by ckpt.</p> Source code in <code>ultralytics/models/sam/build.py</code> <pre><code>def build_sam(ckpt=\"sam_b.pt\"):\n    \"\"\"Build a SAM model specified by ckpt.\"\"\"\n    model_builder = None\n    ckpt = str(ckpt)  # to allow Path ckpt types\n    for k in sam_model_map.keys():\n        if ckpt.endswith(k):\n            model_builder = sam_model_map.get(k)\n\n    if not model_builder:\n        raise FileNotFoundError(f\"{ckpt} is not a supported SAM model. Available models are: \\n {sam_model_map.keys()}\")\n\n    return model_builder(ckpt)\n</code></pre>"},{"location":"reference/models/sam/model/","title":"Reference for <code>ultralytics/models/sam/model.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/sam/model.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/sam/model/#ultralytics.models.sam.model.SAM","title":"<code>ultralytics.models.sam.model.SAM</code>","text":"<p>             Bases: <code>Model</code></p> <p>SAM (Segment Anything Model) interface class.</p> <p>SAM is designed for promptable real-time image segmentation. It can be used with a variety of prompts such as bounding boxes, points, or labels. The model has capabilities for zero-shot performance and is trained on the SA-1B dataset.</p> Source code in <code>ultralytics/models/sam/model.py</code> <pre><code>class SAM(Model):\n    \"\"\"\n    SAM (Segment Anything Model) interface class.\n\n    SAM is designed for promptable real-time image segmentation. It can be used with a variety of prompts such as\n    bounding boxes, points, or labels. The model has capabilities for zero-shot performance and is trained on the SA-1B\n    dataset.\n    \"\"\"\n\n    def __init__(self, model=\"sam_b.pt\") -&gt; None:\n        \"\"\"\n        Initializes the SAM model with a pre-trained model file.\n\n        Args:\n            model (str): Path to the pre-trained SAM model file. File should have a .pt or .pth extension.\n\n        Raises:\n            NotImplementedError: If the model file extension is not .pt or .pth.\n        \"\"\"\n        if model and Path(model).suffix not in (\".pt\", \".pth\"):\n            raise NotImplementedError(\"SAM prediction requires pre-trained *.pt or *.pth model.\")\n        super().__init__(model=model, task=\"segment\")\n\n    def _load(self, weights: str, task=None):\n        \"\"\"\n        Loads the specified weights into the SAM model.\n\n        Args:\n            weights (str): Path to the weights file.\n            task (str, optional): Task name. Defaults to None.\n        \"\"\"\n        self.model = build_sam(weights)\n\n    def predict(self, source, stream=False, bboxes=None, points=None, labels=None, **kwargs):\n        \"\"\"\n        Performs segmentation prediction on the given image or video source.\n\n        Args:\n            source (str): Path to the image or video file, or a PIL.Image object, or a numpy.ndarray object.\n            stream (bool, optional): If True, enables real-time streaming. Defaults to False.\n            bboxes (list, optional): List of bounding box coordinates for prompted segmentation. Defaults to None.\n            points (list, optional): List of points for prompted segmentation. Defaults to None.\n            labels (list, optional): List of labels for prompted segmentation. Defaults to None.\n\n        Returns:\n            (list): The model predictions.\n        \"\"\"\n        overrides = dict(conf=0.25, task=\"segment\", mode=\"predict\", imgsz=1024)\n        kwargs.update(overrides)\n        prompts = dict(bboxes=bboxes, points=points, labels=labels)\n        return super().predict(source, stream, prompts=prompts, **kwargs)\n\n    def __call__(self, source=None, stream=False, bboxes=None, points=None, labels=None, **kwargs):\n        \"\"\"\n        Alias for the 'predict' method.\n\n        Args:\n            source (str): Path to the image or video file, or a PIL.Image object, or a numpy.ndarray object.\n            stream (bool, optional): If True, enables real-time streaming. Defaults to False.\n            bboxes (list, optional): List of bounding box coordinates for prompted segmentation. Defaults to None.\n            points (list, optional): List of points for prompted segmentation. Defaults to None.\n            labels (list, optional): List of labels for prompted segmentation. Defaults to None.\n\n        Returns:\n            (list): The model predictions.\n        \"\"\"\n        return self.predict(source, stream, bboxes, points, labels, **kwargs)\n\n    def info(self, detailed=False, verbose=True):\n        \"\"\"\n        Logs information about the SAM model.\n\n        Args:\n            detailed (bool, optional): If True, displays detailed information about the model. Defaults to False.\n            verbose (bool, optional): If True, displays information on the console. Defaults to True.\n\n        Returns:\n            (tuple): A tuple containing the model's information.\n        \"\"\"\n        return model_info(self.model, detailed=detailed, verbose=verbose)\n\n    @property\n    def task_map(self):\n        \"\"\"\n        Provides a mapping from the 'segment' task to its corresponding 'Predictor'.\n\n        Returns:\n            (dict): A dictionary mapping the 'segment' task to its corresponding 'Predictor'.\n        \"\"\"\n        return {\"segment\": {\"predictor\": Predictor}}\n</code></pre>"},{"location":"reference/models/sam/model/#ultralytics.models.sam.model.SAM.task_map","title":"<code>task_map</code>  <code>property</code>","text":"<p>Provides a mapping from the 'segment' task to its corresponding 'Predictor'.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary mapping the 'segment' task to its corresponding 'Predictor'.</p>"},{"location":"reference/models/sam/model/#ultralytics.models.sam.model.SAM.__call__","title":"<code>__call__(source=None, stream=False, bboxes=None, points=None, labels=None, **kwargs)</code>","text":"<p>Alias for the 'predict' method.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Path to the image or video file, or a PIL.Image object, or a numpy.ndarray object.</p> <code>None</code> <code>stream</code> <code>bool</code> <p>If True, enables real-time streaming. Defaults to False.</p> <code>False</code> <code>bboxes</code> <code>list</code> <p>List of bounding box coordinates for prompted segmentation. Defaults to None.</p> <code>None</code> <code>points</code> <code>list</code> <p>List of points for prompted segmentation. Defaults to None.</p> <code>None</code> <code>labels</code> <code>list</code> <p>List of labels for prompted segmentation. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>The model predictions.</p> Source code in <code>ultralytics/models/sam/model.py</code> <pre><code>def __call__(self, source=None, stream=False, bboxes=None, points=None, labels=None, **kwargs):\n    \"\"\"\n    Alias for the 'predict' method.\n\n    Args:\n        source (str): Path to the image or video file, or a PIL.Image object, or a numpy.ndarray object.\n        stream (bool, optional): If True, enables real-time streaming. Defaults to False.\n        bboxes (list, optional): List of bounding box coordinates for prompted segmentation. Defaults to None.\n        points (list, optional): List of points for prompted segmentation. Defaults to None.\n        labels (list, optional): List of labels for prompted segmentation. Defaults to None.\n\n    Returns:\n        (list): The model predictions.\n    \"\"\"\n    return self.predict(source, stream, bboxes, points, labels, **kwargs)\n</code></pre>"},{"location":"reference/models/sam/model/#ultralytics.models.sam.model.SAM.__init__","title":"<code>__init__(model='sam_b.pt')</code>","text":"<p>Initializes the SAM model with a pre-trained model file.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>Path to the pre-trained SAM model file. File should have a .pt or .pth extension.</p> <code>'sam_b.pt'</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the model file extension is not .pt or .pth.</p> Source code in <code>ultralytics/models/sam/model.py</code> <pre><code>def __init__(self, model=\"sam_b.pt\") -&gt; None:\n    \"\"\"\n    Initializes the SAM model with a pre-trained model file.\n\n    Args:\n        model (str): Path to the pre-trained SAM model file. File should have a .pt or .pth extension.\n\n    Raises:\n        NotImplementedError: If the model file extension is not .pt or .pth.\n    \"\"\"\n    if model and Path(model).suffix not in (\".pt\", \".pth\"):\n        raise NotImplementedError(\"SAM prediction requires pre-trained *.pt or *.pth model.\")\n    super().__init__(model=model, task=\"segment\")\n</code></pre>"},{"location":"reference/models/sam/model/#ultralytics.models.sam.model.SAM.info","title":"<code>info(detailed=False, verbose=True)</code>","text":"<p>Logs information about the SAM model.</p> <p>Parameters:</p> Name Type Description Default <code>detailed</code> <code>bool</code> <p>If True, displays detailed information about the model. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>If True, displays information on the console. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the model's information.</p> Source code in <code>ultralytics/models/sam/model.py</code> <pre><code>def info(self, detailed=False, verbose=True):\n    \"\"\"\n    Logs information about the SAM model.\n\n    Args:\n        detailed (bool, optional): If True, displays detailed information about the model. Defaults to False.\n        verbose (bool, optional): If True, displays information on the console. Defaults to True.\n\n    Returns:\n        (tuple): A tuple containing the model's information.\n    \"\"\"\n    return model_info(self.model, detailed=detailed, verbose=verbose)\n</code></pre>"},{"location":"reference/models/sam/model/#ultralytics.models.sam.model.SAM.predict","title":"<code>predict(source, stream=False, bboxes=None, points=None, labels=None, **kwargs)</code>","text":"<p>Performs segmentation prediction on the given image or video source.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Path to the image or video file, or a PIL.Image object, or a numpy.ndarray object.</p> required <code>stream</code> <code>bool</code> <p>If True, enables real-time streaming. Defaults to False.</p> <code>False</code> <code>bboxes</code> <code>list</code> <p>List of bounding box coordinates for prompted segmentation. Defaults to None.</p> <code>None</code> <code>points</code> <code>list</code> <p>List of points for prompted segmentation. Defaults to None.</p> <code>None</code> <code>labels</code> <code>list</code> <p>List of labels for prompted segmentation. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>The model predictions.</p> Source code in <code>ultralytics/models/sam/model.py</code> <pre><code>def predict(self, source, stream=False, bboxes=None, points=None, labels=None, **kwargs):\n    \"\"\"\n    Performs segmentation prediction on the given image or video source.\n\n    Args:\n        source (str): Path to the image or video file, or a PIL.Image object, or a numpy.ndarray object.\n        stream (bool, optional): If True, enables real-time streaming. Defaults to False.\n        bboxes (list, optional): List of bounding box coordinates for prompted segmentation. Defaults to None.\n        points (list, optional): List of points for prompted segmentation. Defaults to None.\n        labels (list, optional): List of labels for prompted segmentation. Defaults to None.\n\n    Returns:\n        (list): The model predictions.\n    \"\"\"\n    overrides = dict(conf=0.25, task=\"segment\", mode=\"predict\", imgsz=1024)\n    kwargs.update(overrides)\n    prompts = dict(bboxes=bboxes, points=points, labels=labels)\n    return super().predict(source, stream, prompts=prompts, **kwargs)\n</code></pre>"},{"location":"reference/models/sam/predict/","title":"Reference for <code>ultralytics/models/sam/predict.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/sam/predict.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/sam/predict/#ultralytics.models.sam.predict.Predictor","title":"<code>ultralytics.models.sam.predict.Predictor</code>","text":"<p>             Bases: <code>BasePredictor</code></p> <p>Predictor class for the Segment Anything Model (SAM), extending BasePredictor.</p> <p>The class provides an interface for model inference tailored to image segmentation tasks. With advanced architecture and promptable segmentation capabilities, it facilitates flexible and real-time mask generation. The class is capable of working with various types of prompts such as bounding boxes, points, and low-resolution masks.</p> <p>Attributes:</p> Name Type Description <code>cfg</code> <code>dict</code> <p>Configuration dictionary specifying model and task-related parameters.</p> <code>overrides</code> <code>dict</code> <p>Dictionary containing values that override the default configuration.</p> <code>_callbacks</code> <code>dict</code> <p>Dictionary of user-defined callback functions to augment behavior.</p> <code>args</code> <code>namespace</code> <p>Namespace to hold command-line arguments or other operational variables.</p> <code>im</code> <code>Tensor</code> <p>Preprocessed input image tensor.</p> <code>features</code> <code>Tensor</code> <p>Extracted image features used for inference.</p> <code>prompts</code> <code>dict</code> <p>Collection of various prompt types, such as bounding boxes and points.</p> <code>segment_all</code> <code>bool</code> <p>Flag to control whether to segment all objects in the image or only specified ones.</p> Source code in <code>ultralytics/models/sam/predict.py</code> <pre><code>class Predictor(BasePredictor):\n    \"\"\"\n    Predictor class for the Segment Anything Model (SAM), extending BasePredictor.\n\n    The class provides an interface for model inference tailored to image segmentation tasks.\n    With advanced architecture and promptable segmentation capabilities, it facilitates flexible and real-time\n    mask generation. The class is capable of working with various types of prompts such as bounding boxes,\n    points, and low-resolution masks.\n\n    Attributes:\n        cfg (dict): Configuration dictionary specifying model and task-related parameters.\n        overrides (dict): Dictionary containing values that override the default configuration.\n        _callbacks (dict): Dictionary of user-defined callback functions to augment behavior.\n        args (namespace): Namespace to hold command-line arguments or other operational variables.\n        im (torch.Tensor): Preprocessed input image tensor.\n        features (torch.Tensor): Extracted image features used for inference.\n        prompts (dict): Collection of various prompt types, such as bounding boxes and points.\n        segment_all (bool): Flag to control whether to segment all objects in the image or only specified ones.\n    \"\"\"\n\n    def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n        \"\"\"\n        Initialize the Predictor with configuration, overrides, and callbacks.\n\n        The method sets up the Predictor object and applies any configuration overrides or callbacks provided. It\n        initializes task-specific settings for SAM, such as retina_masks being set to True for optimal results.\n\n        Args:\n            cfg (dict): Configuration dictionary.\n            overrides (dict, optional): Dictionary of values to override default configuration.\n            _callbacks (dict, optional): Dictionary of callback functions to customize behavior.\n        \"\"\"\n        if overrides is None:\n            overrides = {}\n        overrides.update(dict(task=\"segment\", mode=\"predict\", imgsz=1024))\n        super().__init__(cfg, overrides, _callbacks)\n        self.args.retina_masks = True\n        self.im = None\n        self.features = None\n        self.prompts = {}\n        self.segment_all = False\n\n    def preprocess(self, im):\n        \"\"\"\n        Preprocess the input image for model inference.\n\n        The method prepares the input image by applying transformations and normalization.\n        It supports both torch.Tensor and list of np.ndarray as input formats.\n\n        Args:\n            im (torch.Tensor | List[np.ndarray]): BCHW tensor format or list of HWC numpy arrays.\n\n        Returns:\n            (torch.Tensor): The preprocessed image tensor.\n        \"\"\"\n        if self.im is not None:\n            return self.im\n        not_tensor = not isinstance(im, torch.Tensor)\n        if not_tensor:\n            im = np.stack(self.pre_transform(im))\n            im = im[..., ::-1].transpose((0, 3, 1, 2))\n            im = np.ascontiguousarray(im)\n            im = torch.from_numpy(im)\n\n        im = im.to(self.device)\n        im = im.half() if self.model.fp16 else im.float()\n        if not_tensor:\n            im = (im - self.mean) / self.std\n        return im\n\n    def pre_transform(self, im):\n        \"\"\"\n        Perform initial transformations on the input image for preprocessing.\n\n        The method applies transformations such as resizing to prepare the image for further preprocessing.\n        Currently, batched inference is not supported; hence the list length should be 1.\n\n        Args:\n            im (List[np.ndarray]): List containing images in HWC numpy array format.\n\n        Returns:\n            (List[np.ndarray]): List of transformed images.\n        \"\"\"\n        assert len(im) == 1, \"SAM model does not currently support batched inference\"\n        letterbox = LetterBox(self.args.imgsz, auto=False, center=False)\n        return [letterbox(image=x) for x in im]\n\n    def inference(self, im, bboxes=None, points=None, labels=None, masks=None, multimask_output=False, *args, **kwargs):\n        \"\"\"\n        Perform image segmentation inference based on the given input cues, using the currently loaded image. This\n        method leverages SAM's (Segment Anything Model) architecture consisting of image encoder, prompt encoder, and\n        mask decoder for real-time and promptable segmentation tasks.\n\n        Args:\n            im (torch.Tensor): The preprocessed input image in tensor format, with shape (N, C, H, W).\n            bboxes (np.ndarray | List, optional): Bounding boxes with shape (N, 4), in XYXY format.\n            points (np.ndarray | List, optional): Points indicating object locations with shape (N, 2), in pixel coordinates.\n            labels (np.ndarray | List, optional): Labels for point prompts, shape (N, ). 1 for foreground and 0 for background.\n            masks (np.ndarray, optional): Low-resolution masks from previous predictions. Shape should be (N, H, W). For SAM, H=W=256.\n            multimask_output (bool, optional): Flag to return multiple masks. Helpful for ambiguous prompts. Defaults to False.\n\n        Returns:\n            (tuple): Contains the following three elements.\n                - np.ndarray: The output masks in shape CxHxW, where C is the number of generated masks.\n                - np.ndarray: An array of length C containing quality scores predicted by the model for each mask.\n                - np.ndarray: Low-resolution logits of shape CxHxW for subsequent inference, where H=W=256.\n        \"\"\"\n        # Override prompts if any stored in self.prompts\n        bboxes = self.prompts.pop(\"bboxes\", bboxes)\n        points = self.prompts.pop(\"points\", points)\n        masks = self.prompts.pop(\"masks\", masks)\n\n        if all(i is None for i in [bboxes, points, masks]):\n            return self.generate(im, *args, **kwargs)\n\n        return self.prompt_inference(im, bboxes, points, labels, masks, multimask_output)\n\n    def prompt_inference(self, im, bboxes=None, points=None, labels=None, masks=None, multimask_output=False):\n        \"\"\"\n        Internal function for image segmentation inference based on cues like bounding boxes, points, and masks.\n        Leverages SAM's specialized architecture for prompt-based, real-time segmentation.\n\n        Args:\n            im (torch.Tensor): The preprocessed input image in tensor format, with shape (N, C, H, W).\n            bboxes (np.ndarray | List, optional): Bounding boxes with shape (N, 4), in XYXY format.\n            points (np.ndarray | List, optional): Points indicating object locations with shape (N, 2), in pixel coordinates.\n            labels (np.ndarray | List, optional): Labels for point prompts, shape (N, ). 1 for foreground and 0 for background.\n            masks (np.ndarray, optional): Low-resolution masks from previous predictions. Shape should be (N, H, W). For SAM, H=W=256.\n            multimask_output (bool, optional): Flag to return multiple masks. Helpful for ambiguous prompts. Defaults to False.\n\n        Returns:\n            (tuple): Contains the following three elements.\n                - np.ndarray: The output masks in shape CxHxW, where C is the number of generated masks.\n                - np.ndarray: An array of length C containing quality scores predicted by the model for each mask.\n                - np.ndarray: Low-resolution logits of shape CxHxW for subsequent inference, where H=W=256.\n        \"\"\"\n        features = self.model.image_encoder(im) if self.features is None else self.features\n\n        src_shape, dst_shape = self.batch[1][0].shape[:2], im.shape[2:]\n        r = 1.0 if self.segment_all else min(dst_shape[0] / src_shape[0], dst_shape[1] / src_shape[1])\n        # Transform input prompts\n        if points is not None:\n            points = torch.as_tensor(points, dtype=torch.float32, device=self.device)\n            points = points[None] if points.ndim == 1 else points\n            # Assuming labels are all positive if users don't pass labels.\n            if labels is None:\n                labels = np.ones(points.shape[0])\n            labels = torch.as_tensor(labels, dtype=torch.int32, device=self.device)\n            points *= r\n            # (N, 2) --&gt; (N, 1, 2), (N, ) --&gt; (N, 1)\n            points, labels = points[:, None, :], labels[:, None]\n        if bboxes is not None:\n            bboxes = torch.as_tensor(bboxes, dtype=torch.float32, device=self.device)\n            bboxes = bboxes[None] if bboxes.ndim == 1 else bboxes\n            bboxes *= r\n        if masks is not None:\n            masks = torch.as_tensor(masks, dtype=torch.float32, device=self.device).unsqueeze(1)\n\n        points = (points, labels) if points is not None else None\n        # Embed prompts\n        sparse_embeddings, dense_embeddings = self.model.prompt_encoder(points=points, boxes=bboxes, masks=masks)\n\n        # Predict masks\n        pred_masks, pred_scores = self.model.mask_decoder(\n            image_embeddings=features,\n            image_pe=self.model.prompt_encoder.get_dense_pe(),\n            sparse_prompt_embeddings=sparse_embeddings,\n            dense_prompt_embeddings=dense_embeddings,\n            multimask_output=multimask_output,\n        )\n\n        # (N, d, H, W) --&gt; (N*d, H, W), (N, d) --&gt; (N*d, )\n        # `d` could be 1 or 3 depends on `multimask_output`.\n        return pred_masks.flatten(0, 1), pred_scores.flatten(0, 1)\n\n    def generate(\n        self,\n        im,\n        crop_n_layers=0,\n        crop_overlap_ratio=512 / 1500,\n        crop_downscale_factor=1,\n        point_grids=None,\n        points_stride=32,\n        points_batch_size=64,\n        conf_thres=0.88,\n        stability_score_thresh=0.95,\n        stability_score_offset=0.95,\n        crop_nms_thresh=0.7,\n    ):\n        \"\"\"\n        Perform image segmentation using the Segment Anything Model (SAM).\n\n        This function segments an entire image into constituent parts by leveraging SAM's advanced architecture\n        and real-time performance capabilities. It can optionally work on image crops for finer segmentation.\n\n        Args:\n            im (torch.Tensor): Input tensor representing the preprocessed image with dimensions (N, C, H, W).\n            crop_n_layers (int): Specifies the number of layers for additional mask predictions on image crops.\n                                 Each layer produces 2**i_layer number of image crops.\n            crop_overlap_ratio (float): Determines the extent of overlap between crops. Scaled down in subsequent layers.\n            crop_downscale_factor (int): Scaling factor for the number of sampled points-per-side in each layer.\n            point_grids (list[np.ndarray], optional): Custom grids for point sampling normalized to [0,1].\n                                                      Used in the nth crop layer.\n            points_stride (int, optional): Number of points to sample along each side of the image.\n                                           Exclusive with 'point_grids'.\n            points_batch_size (int): Batch size for the number of points processed simultaneously.\n            conf_thres (float): Confidence threshold [0,1] for filtering based on the model's mask quality prediction.\n            stability_score_thresh (float): Stability threshold [0,1] for mask filtering based on mask stability.\n            stability_score_offset (float): Offset value for calculating stability score.\n            crop_nms_thresh (float): IoU cutoff for Non-Maximum Suppression (NMS) to remove duplicate masks between crops.\n\n        Returns:\n            (tuple): A tuple containing segmented masks, confidence scores, and bounding boxes.\n        \"\"\"\n        self.segment_all = True\n        ih, iw = im.shape[2:]\n        crop_regions, layer_idxs = generate_crop_boxes((ih, iw), crop_n_layers, crop_overlap_ratio)\n        if point_grids is None:\n            point_grids = build_all_layer_point_grids(points_stride, crop_n_layers, crop_downscale_factor)\n        pred_masks, pred_scores, pred_bboxes, region_areas = [], [], [], []\n        for crop_region, layer_idx in zip(crop_regions, layer_idxs):\n            x1, y1, x2, y2 = crop_region\n            w, h = x2 - x1, y2 - y1\n            area = torch.tensor(w * h, device=im.device)\n            points_scale = np.array([[w, h]])  # w, h\n            # Crop image and interpolate to input size\n            crop_im = F.interpolate(im[..., y1:y2, x1:x2], (ih, iw), mode=\"bilinear\", align_corners=False)\n            # (num_points, 2)\n            points_for_image = point_grids[layer_idx] * points_scale\n            crop_masks, crop_scores, crop_bboxes = [], [], []\n            for (points,) in batch_iterator(points_batch_size, points_for_image):\n                pred_mask, pred_score = self.prompt_inference(crop_im, points=points, multimask_output=True)\n                # Interpolate predicted masks to input size\n                pred_mask = F.interpolate(pred_mask[None], (h, w), mode=\"bilinear\", align_corners=False)[0]\n                idx = pred_score &gt; conf_thres\n                pred_mask, pred_score = pred_mask[idx], pred_score[idx]\n\n                stability_score = calculate_stability_score(\n                    pred_mask, self.model.mask_threshold, stability_score_offset\n                )\n                idx = stability_score &gt; stability_score_thresh\n                pred_mask, pred_score = pred_mask[idx], pred_score[idx]\n                # Bool type is much more memory-efficient.\n                pred_mask = pred_mask &gt; self.model.mask_threshold\n                # (N, 4)\n                pred_bbox = batched_mask_to_box(pred_mask).float()\n                keep_mask = ~is_box_near_crop_edge(pred_bbox, crop_region, [0, 0, iw, ih])\n                if not torch.all(keep_mask):\n                    pred_bbox, pred_mask, pred_score = pred_bbox[keep_mask], pred_mask[keep_mask], pred_score[keep_mask]\n\n                crop_masks.append(pred_mask)\n                crop_bboxes.append(pred_bbox)\n                crop_scores.append(pred_score)\n\n            # Do nms within this crop\n            crop_masks = torch.cat(crop_masks)\n            crop_bboxes = torch.cat(crop_bboxes)\n            crop_scores = torch.cat(crop_scores)\n            keep = torchvision.ops.nms(crop_bboxes, crop_scores, self.args.iou)  # NMS\n            crop_bboxes = uncrop_boxes_xyxy(crop_bboxes[keep], crop_region)\n            crop_masks = uncrop_masks(crop_masks[keep], crop_region, ih, iw)\n            crop_scores = crop_scores[keep]\n\n            pred_masks.append(crop_masks)\n            pred_bboxes.append(crop_bboxes)\n            pred_scores.append(crop_scores)\n            region_areas.append(area.expand(len(crop_masks)))\n\n        pred_masks = torch.cat(pred_masks)\n        pred_bboxes = torch.cat(pred_bboxes)\n        pred_scores = torch.cat(pred_scores)\n        region_areas = torch.cat(region_areas)\n\n        # Remove duplicate masks between crops\n        if len(crop_regions) &gt; 1:\n            scores = 1 / region_areas\n            keep = torchvision.ops.nms(pred_bboxes, scores, crop_nms_thresh)\n            pred_masks, pred_bboxes, pred_scores = pred_masks[keep], pred_bboxes[keep], pred_scores[keep]\n\n        return pred_masks, pred_scores, pred_bboxes\n\n    def setup_model(self, model, verbose=True):\n        \"\"\"\n        Initializes the Segment Anything Model (SAM) for inference.\n\n        This method sets up the SAM model by allocating it to the appropriate device and initializing the necessary\n        parameters for image normalization and other Ultralytics compatibility settings.\n\n        Args:\n            model (torch.nn.Module): A pre-trained SAM model. If None, a model will be built based on configuration.\n            verbose (bool): If True, prints selected device information.\n\n        Attributes:\n            model (torch.nn.Module): The SAM model allocated to the chosen device for inference.\n            device (torch.device): The device to which the model and tensors are allocated.\n            mean (torch.Tensor): The mean values for image normalization.\n            std (torch.Tensor): The standard deviation values for image normalization.\n        \"\"\"\n        device = select_device(self.args.device, verbose=verbose)\n        if model is None:\n            model = build_sam(self.args.model)\n        model.eval()\n        self.model = model.to(device)\n        self.device = device\n        self.mean = torch.tensor([123.675, 116.28, 103.53]).view(-1, 1, 1).to(device)\n        self.std = torch.tensor([58.395, 57.12, 57.375]).view(-1, 1, 1).to(device)\n\n        # Ultralytics compatibility settings\n        self.model.pt = False\n        self.model.triton = False\n        self.model.stride = 32\n        self.model.fp16 = False\n        self.done_warmup = True\n\n    def postprocess(self, preds, img, orig_imgs):\n        \"\"\"\n        Post-processes SAM's inference outputs to generate object detection masks and bounding boxes.\n\n        The method scales masks and boxes to the original image size and applies a threshold to the mask predictions. The\n        SAM model uses advanced architecture and promptable segmentation tasks to achieve real-time performance.\n\n        Args:\n            preds (tuple): The output from SAM model inference, containing masks, scores, and optional bounding boxes.\n            img (torch.Tensor): The processed input image tensor.\n            orig_imgs (list | torch.Tensor): The original, unprocessed images.\n\n        Returns:\n            (list): List of Results objects containing detection masks, bounding boxes, and other metadata.\n        \"\"\"\n        # (N, 1, H, W), (N, 1)\n        pred_masks, pred_scores = preds[:2]\n        pred_bboxes = preds[2] if self.segment_all else None\n        names = dict(enumerate(str(i) for i in range(len(pred_masks))))\n\n        if not isinstance(orig_imgs, list):  # input images are a torch.Tensor, not a list\n            orig_imgs = ops.convert_torch2numpy_batch(orig_imgs)\n\n        results = []\n        for i, masks in enumerate([pred_masks]):\n            orig_img = orig_imgs[i]\n            if pred_bboxes is not None:\n                pred_bboxes = ops.scale_boxes(img.shape[2:], pred_bboxes.float(), orig_img.shape, padding=False)\n                cls = torch.arange(len(pred_masks), dtype=torch.int32, device=pred_masks.device)\n                pred_bboxes = torch.cat([pred_bboxes, pred_scores[:, None], cls[:, None]], dim=-1)\n\n            masks = ops.scale_masks(masks[None].float(), orig_img.shape[:2], padding=False)[0]\n            masks = masks &gt; self.model.mask_threshold  # to bool\n            img_path = self.batch[0][i]\n            results.append(Results(orig_img, path=img_path, names=names, masks=masks, boxes=pred_bboxes))\n        # Reset segment-all mode.\n        self.segment_all = False\n        return results\n\n    def setup_source(self, source):\n        \"\"\"\n        Sets up the data source for inference.\n\n        This method configures the data source from which images will be fetched for inference. The source could be a\n        directory, a video file, or other types of image data sources.\n\n        Args:\n            source (str | Path): The path to the image data source for inference.\n        \"\"\"\n        if source is not None:\n            super().setup_source(source)\n\n    def set_image(self, image):\n        \"\"\"\n        Preprocesses and sets a single image for inference.\n\n        This function sets up the model if not already initialized, configures the data source to the specified image,\n        and preprocesses the image for feature extraction. Only one image can be set at a time.\n\n        Args:\n            image (str | np.ndarray): Image file path as a string, or a np.ndarray image read by cv2.\n\n        Raises:\n            AssertionError: If more than one image is set.\n        \"\"\"\n        if self.model is None:\n            model = build_sam(self.args.model)\n            self.setup_model(model)\n        self.setup_source(image)\n        assert len(self.dataset) == 1, \"`set_image` only supports setting one image!\"\n        for batch in self.dataset:\n            im = self.preprocess(batch[1])\n            self.features = self.model.image_encoder(im)\n            self.im = im\n            break\n\n    def set_prompts(self, prompts):\n        \"\"\"Set prompts in advance.\"\"\"\n        self.prompts = prompts\n\n    def reset_image(self):\n        \"\"\"Resets the image and its features to None.\"\"\"\n        self.im = None\n        self.features = None\n\n    @staticmethod\n    def remove_small_regions(masks, min_area=0, nms_thresh=0.7):\n        \"\"\"\n        Perform post-processing on segmentation masks generated by the Segment Anything Model (SAM). Specifically, this\n        function removes small disconnected regions and holes from the input masks, and then performs Non-Maximum\n        Suppression (NMS) to eliminate any newly created duplicate boxes.\n\n        Args:\n            masks (torch.Tensor): A tensor containing the masks to be processed. Shape should be (N, H, W), where N is\n                                  the number of masks, H is height, and W is width.\n            min_area (int): The minimum area below which disconnected regions and holes will be removed. Defaults to 0.\n            nms_thresh (float): The IoU threshold for the NMS algorithm. Defaults to 0.7.\n\n        Returns:\n            (tuple([torch.Tensor, List[int]])):\n                - new_masks (torch.Tensor): The processed masks with small regions removed. Shape is (N, H, W).\n                - keep (List[int]): The indices of the remaining masks post-NMS, which can be used to filter the boxes.\n        \"\"\"\n        if len(masks) == 0:\n            return masks\n\n        # Filter small disconnected regions and holes\n        new_masks = []\n        scores = []\n        for mask in masks:\n            mask = mask.cpu().numpy().astype(np.uint8)\n            mask, changed = remove_small_regions(mask, min_area, mode=\"holes\")\n            unchanged = not changed\n            mask, changed = remove_small_regions(mask, min_area, mode=\"islands\")\n            unchanged = unchanged and not changed\n\n            new_masks.append(torch.as_tensor(mask).unsqueeze(0))\n            # Give score=0 to changed masks and 1 to unchanged masks so NMS prefers masks not needing postprocessing\n            scores.append(float(unchanged))\n\n        # Recalculate boxes and remove any new duplicates\n        new_masks = torch.cat(new_masks, dim=0)\n        boxes = batched_mask_to_box(new_masks)\n        keep = torchvision.ops.nms(boxes.float(), torch.as_tensor(scores), nms_thresh)\n\n        return new_masks[keep].to(device=masks.device, dtype=masks.dtype), keep\n</code></pre>"},{"location":"reference/models/sam/predict/#ultralytics.models.sam.predict.Predictor.__init__","title":"<code>__init__(cfg=DEFAULT_CFG, overrides=None, _callbacks=None)</code>","text":"<p>Initialize the Predictor with configuration, overrides, and callbacks.</p> <p>The method sets up the Predictor object and applies any configuration overrides or callbacks provided. It initializes task-specific settings for SAM, such as retina_masks being set to True for optimal results.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>dict</code> <p>Configuration dictionary.</p> <code>DEFAULT_CFG</code> <code>overrides</code> <code>dict</code> <p>Dictionary of values to override default configuration.</p> <code>None</code> <code>_callbacks</code> <code>dict</code> <p>Dictionary of callback functions to customize behavior.</p> <code>None</code> Source code in <code>ultralytics/models/sam/predict.py</code> <pre><code>def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n    \"\"\"\n    Initialize the Predictor with configuration, overrides, and callbacks.\n\n    The method sets up the Predictor object and applies any configuration overrides or callbacks provided. It\n    initializes task-specific settings for SAM, such as retina_masks being set to True for optimal results.\n\n    Args:\n        cfg (dict): Configuration dictionary.\n        overrides (dict, optional): Dictionary of values to override default configuration.\n        _callbacks (dict, optional): Dictionary of callback functions to customize behavior.\n    \"\"\"\n    if overrides is None:\n        overrides = {}\n    overrides.update(dict(task=\"segment\", mode=\"predict\", imgsz=1024))\n    super().__init__(cfg, overrides, _callbacks)\n    self.args.retina_masks = True\n    self.im = None\n    self.features = None\n    self.prompts = {}\n    self.segment_all = False\n</code></pre>"},{"location":"reference/models/sam/predict/#ultralytics.models.sam.predict.Predictor.generate","title":"<code>generate(im, crop_n_layers=0, crop_overlap_ratio=512 / 1500, crop_downscale_factor=1, point_grids=None, points_stride=32, points_batch_size=64, conf_thres=0.88, stability_score_thresh=0.95, stability_score_offset=0.95, crop_nms_thresh=0.7)</code>","text":"<p>Perform image segmentation using the Segment Anything Model (SAM).</p> <p>This function segments an entire image into constituent parts by leveraging SAM's advanced architecture and real-time performance capabilities. It can optionally work on image crops for finer segmentation.</p> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>Tensor</code> <p>Input tensor representing the preprocessed image with dimensions (N, C, H, W).</p> required <code>crop_n_layers</code> <code>int</code> <p>Specifies the number of layers for additional mask predictions on image crops.                  Each layer produces 2**i_layer number of image crops.</p> <code>0</code> <code>crop_overlap_ratio</code> <code>float</code> <p>Determines the extent of overlap between crops. Scaled down in subsequent layers.</p> <code>512 / 1500</code> <code>crop_downscale_factor</code> <code>int</code> <p>Scaling factor for the number of sampled points-per-side in each layer.</p> <code>1</code> <code>point_grids</code> <code>list[ndarray]</code> <p>Custom grids for point sampling normalized to [0,1].                                       Used in the nth crop layer.</p> <code>None</code> <code>points_stride</code> <code>int</code> <p>Number of points to sample along each side of the image.                            Exclusive with 'point_grids'.</p> <code>32</code> <code>points_batch_size</code> <code>int</code> <p>Batch size for the number of points processed simultaneously.</p> <code>64</code> <code>conf_thres</code> <code>float</code> <p>Confidence threshold [0,1] for filtering based on the model's mask quality prediction.</p> <code>0.88</code> <code>stability_score_thresh</code> <code>float</code> <p>Stability threshold [0,1] for mask filtering based on mask stability.</p> <code>0.95</code> <code>stability_score_offset</code> <code>float</code> <p>Offset value for calculating stability score.</p> <code>0.95</code> <code>crop_nms_thresh</code> <code>float</code> <p>IoU cutoff for Non-Maximum Suppression (NMS) to remove duplicate masks between crops.</p> <code>0.7</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing segmented masks, confidence scores, and bounding boxes.</p> Source code in <code>ultralytics/models/sam/predict.py</code> <pre><code>def generate(\n    self,\n    im,\n    crop_n_layers=0,\n    crop_overlap_ratio=512 / 1500,\n    crop_downscale_factor=1,\n    point_grids=None,\n    points_stride=32,\n    points_batch_size=64,\n    conf_thres=0.88,\n    stability_score_thresh=0.95,\n    stability_score_offset=0.95,\n    crop_nms_thresh=0.7,\n):\n    \"\"\"\n    Perform image segmentation using the Segment Anything Model (SAM).\n\n    This function segments an entire image into constituent parts by leveraging SAM's advanced architecture\n    and real-time performance capabilities. It can optionally work on image crops for finer segmentation.\n\n    Args:\n        im (torch.Tensor): Input tensor representing the preprocessed image with dimensions (N, C, H, W).\n        crop_n_layers (int): Specifies the number of layers for additional mask predictions on image crops.\n                             Each layer produces 2**i_layer number of image crops.\n        crop_overlap_ratio (float): Determines the extent of overlap between crops. Scaled down in subsequent layers.\n        crop_downscale_factor (int): Scaling factor for the number of sampled points-per-side in each layer.\n        point_grids (list[np.ndarray], optional): Custom grids for point sampling normalized to [0,1].\n                                                  Used in the nth crop layer.\n        points_stride (int, optional): Number of points to sample along each side of the image.\n                                       Exclusive with 'point_grids'.\n        points_batch_size (int): Batch size for the number of points processed simultaneously.\n        conf_thres (float): Confidence threshold [0,1] for filtering based on the model's mask quality prediction.\n        stability_score_thresh (float): Stability threshold [0,1] for mask filtering based on mask stability.\n        stability_score_offset (float): Offset value for calculating stability score.\n        crop_nms_thresh (float): IoU cutoff for Non-Maximum Suppression (NMS) to remove duplicate masks between crops.\n\n    Returns:\n        (tuple): A tuple containing segmented masks, confidence scores, and bounding boxes.\n    \"\"\"\n    self.segment_all = True\n    ih, iw = im.shape[2:]\n    crop_regions, layer_idxs = generate_crop_boxes((ih, iw), crop_n_layers, crop_overlap_ratio)\n    if point_grids is None:\n        point_grids = build_all_layer_point_grids(points_stride, crop_n_layers, crop_downscale_factor)\n    pred_masks, pred_scores, pred_bboxes, region_areas = [], [], [], []\n    for crop_region, layer_idx in zip(crop_regions, layer_idxs):\n        x1, y1, x2, y2 = crop_region\n        w, h = x2 - x1, y2 - y1\n        area = torch.tensor(w * h, device=im.device)\n        points_scale = np.array([[w, h]])  # w, h\n        # Crop image and interpolate to input size\n        crop_im = F.interpolate(im[..., y1:y2, x1:x2], (ih, iw), mode=\"bilinear\", align_corners=False)\n        # (num_points, 2)\n        points_for_image = point_grids[layer_idx] * points_scale\n        crop_masks, crop_scores, crop_bboxes = [], [], []\n        for (points,) in batch_iterator(points_batch_size, points_for_image):\n            pred_mask, pred_score = self.prompt_inference(crop_im, points=points, multimask_output=True)\n            # Interpolate predicted masks to input size\n            pred_mask = F.interpolate(pred_mask[None], (h, w), mode=\"bilinear\", align_corners=False)[0]\n            idx = pred_score &gt; conf_thres\n            pred_mask, pred_score = pred_mask[idx], pred_score[idx]\n\n            stability_score = calculate_stability_score(\n                pred_mask, self.model.mask_threshold, stability_score_offset\n            )\n            idx = stability_score &gt; stability_score_thresh\n            pred_mask, pred_score = pred_mask[idx], pred_score[idx]\n            # Bool type is much more memory-efficient.\n            pred_mask = pred_mask &gt; self.model.mask_threshold\n            # (N, 4)\n            pred_bbox = batched_mask_to_box(pred_mask).float()\n            keep_mask = ~is_box_near_crop_edge(pred_bbox, crop_region, [0, 0, iw, ih])\n            if not torch.all(keep_mask):\n                pred_bbox, pred_mask, pred_score = pred_bbox[keep_mask], pred_mask[keep_mask], pred_score[keep_mask]\n\n            crop_masks.append(pred_mask)\n            crop_bboxes.append(pred_bbox)\n            crop_scores.append(pred_score)\n\n        # Do nms within this crop\n        crop_masks = torch.cat(crop_masks)\n        crop_bboxes = torch.cat(crop_bboxes)\n        crop_scores = torch.cat(crop_scores)\n        keep = torchvision.ops.nms(crop_bboxes, crop_scores, self.args.iou)  # NMS\n        crop_bboxes = uncrop_boxes_xyxy(crop_bboxes[keep], crop_region)\n        crop_masks = uncrop_masks(crop_masks[keep], crop_region, ih, iw)\n        crop_scores = crop_scores[keep]\n\n        pred_masks.append(crop_masks)\n        pred_bboxes.append(crop_bboxes)\n        pred_scores.append(crop_scores)\n        region_areas.append(area.expand(len(crop_masks)))\n\n    pred_masks = torch.cat(pred_masks)\n    pred_bboxes = torch.cat(pred_bboxes)\n    pred_scores = torch.cat(pred_scores)\n    region_areas = torch.cat(region_areas)\n\n    # Remove duplicate masks between crops\n    if len(crop_regions) &gt; 1:\n        scores = 1 / region_areas\n        keep = torchvision.ops.nms(pred_bboxes, scores, crop_nms_thresh)\n        pred_masks, pred_bboxes, pred_scores = pred_masks[keep], pred_bboxes[keep], pred_scores[keep]\n\n    return pred_masks, pred_scores, pred_bboxes\n</code></pre>"},{"location":"reference/models/sam/predict/#ultralytics.models.sam.predict.Predictor.inference","title":"<code>inference(im, bboxes=None, points=None, labels=None, masks=None, multimask_output=False, *args, **kwargs)</code>","text":"<p>Perform image segmentation inference based on the given input cues, using the currently loaded image. This method leverages SAM's (Segment Anything Model) architecture consisting of image encoder, prompt encoder, and mask decoder for real-time and promptable segmentation tasks.</p> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>Tensor</code> <p>The preprocessed input image in tensor format, with shape (N, C, H, W).</p> required <code>bboxes</code> <code>ndarray | List</code> <p>Bounding boxes with shape (N, 4), in XYXY format.</p> <code>None</code> <code>points</code> <code>ndarray | List</code> <p>Points indicating object locations with shape (N, 2), in pixel coordinates.</p> <code>None</code> <code>labels</code> <code>ndarray | List</code> <p>Labels for point prompts, shape (N, ). 1 for foreground and 0 for background.</p> <code>None</code> <code>masks</code> <code>ndarray</code> <p>Low-resolution masks from previous predictions. Shape should be (N, H, W). For SAM, H=W=256.</p> <code>None</code> <code>multimask_output</code> <code>bool</code> <p>Flag to return multiple masks. Helpful for ambiguous prompts. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Contains the following three elements. - np.ndarray: The output masks in shape CxHxW, where C is the number of generated masks. - np.ndarray: An array of length C containing quality scores predicted by the model for each mask. - np.ndarray: Low-resolution logits of shape CxHxW for subsequent inference, where H=W=256.</p> Source code in <code>ultralytics/models/sam/predict.py</code> <pre><code>def inference(self, im, bboxes=None, points=None, labels=None, masks=None, multimask_output=False, *args, **kwargs):\n    \"\"\"\n    Perform image segmentation inference based on the given input cues, using the currently loaded image. This\n    method leverages SAM's (Segment Anything Model) architecture consisting of image encoder, prompt encoder, and\n    mask decoder for real-time and promptable segmentation tasks.\n\n    Args:\n        im (torch.Tensor): The preprocessed input image in tensor format, with shape (N, C, H, W).\n        bboxes (np.ndarray | List, optional): Bounding boxes with shape (N, 4), in XYXY format.\n        points (np.ndarray | List, optional): Points indicating object locations with shape (N, 2), in pixel coordinates.\n        labels (np.ndarray | List, optional): Labels for point prompts, shape (N, ). 1 for foreground and 0 for background.\n        masks (np.ndarray, optional): Low-resolution masks from previous predictions. Shape should be (N, H, W). For SAM, H=W=256.\n        multimask_output (bool, optional): Flag to return multiple masks. Helpful for ambiguous prompts. Defaults to False.\n\n    Returns:\n        (tuple): Contains the following three elements.\n            - np.ndarray: The output masks in shape CxHxW, where C is the number of generated masks.\n            - np.ndarray: An array of length C containing quality scores predicted by the model for each mask.\n            - np.ndarray: Low-resolution logits of shape CxHxW for subsequent inference, where H=W=256.\n    \"\"\"\n    # Override prompts if any stored in self.prompts\n    bboxes = self.prompts.pop(\"bboxes\", bboxes)\n    points = self.prompts.pop(\"points\", points)\n    masks = self.prompts.pop(\"masks\", masks)\n\n    if all(i is None for i in [bboxes, points, masks]):\n        return self.generate(im, *args, **kwargs)\n\n    return self.prompt_inference(im, bboxes, points, labels, masks, multimask_output)\n</code></pre>"},{"location":"reference/models/sam/predict/#ultralytics.models.sam.predict.Predictor.postprocess","title":"<code>postprocess(preds, img, orig_imgs)</code>","text":"<p>Post-processes SAM's inference outputs to generate object detection masks and bounding boxes.</p> <p>The method scales masks and boxes to the original image size and applies a threshold to the mask predictions. The SAM model uses advanced architecture and promptable segmentation tasks to achieve real-time performance.</p> <p>Parameters:</p> Name Type Description Default <code>preds</code> <code>tuple</code> <p>The output from SAM model inference, containing masks, scores, and optional bounding boxes.</p> required <code>img</code> <code>Tensor</code> <p>The processed input image tensor.</p> required <code>orig_imgs</code> <code>list | Tensor</code> <p>The original, unprocessed images.</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of Results objects containing detection masks, bounding boxes, and other metadata.</p> Source code in <code>ultralytics/models/sam/predict.py</code> <pre><code>def postprocess(self, preds, img, orig_imgs):\n    \"\"\"\n    Post-processes SAM's inference outputs to generate object detection masks and bounding boxes.\n\n    The method scales masks and boxes to the original image size and applies a threshold to the mask predictions. The\n    SAM model uses advanced architecture and promptable segmentation tasks to achieve real-time performance.\n\n    Args:\n        preds (tuple): The output from SAM model inference, containing masks, scores, and optional bounding boxes.\n        img (torch.Tensor): The processed input image tensor.\n        orig_imgs (list | torch.Tensor): The original, unprocessed images.\n\n    Returns:\n        (list): List of Results objects containing detection masks, bounding boxes, and other metadata.\n    \"\"\"\n    # (N, 1, H, W), (N, 1)\n    pred_masks, pred_scores = preds[:2]\n    pred_bboxes = preds[2] if self.segment_all else None\n    names = dict(enumerate(str(i) for i in range(len(pred_masks))))\n\n    if not isinstance(orig_imgs, list):  # input images are a torch.Tensor, not a list\n        orig_imgs = ops.convert_torch2numpy_batch(orig_imgs)\n\n    results = []\n    for i, masks in enumerate([pred_masks]):\n        orig_img = orig_imgs[i]\n        if pred_bboxes is not None:\n            pred_bboxes = ops.scale_boxes(img.shape[2:], pred_bboxes.float(), orig_img.shape, padding=False)\n            cls = torch.arange(len(pred_masks), dtype=torch.int32, device=pred_masks.device)\n            pred_bboxes = torch.cat([pred_bboxes, pred_scores[:, None], cls[:, None]], dim=-1)\n\n        masks = ops.scale_masks(masks[None].float(), orig_img.shape[:2], padding=False)[0]\n        masks = masks &gt; self.model.mask_threshold  # to bool\n        img_path = self.batch[0][i]\n        results.append(Results(orig_img, path=img_path, names=names, masks=masks, boxes=pred_bboxes))\n    # Reset segment-all mode.\n    self.segment_all = False\n    return results\n</code></pre>"},{"location":"reference/models/sam/predict/#ultralytics.models.sam.predict.Predictor.pre_transform","title":"<code>pre_transform(im)</code>","text":"<p>Perform initial transformations on the input image for preprocessing.</p> <p>The method applies transformations such as resizing to prepare the image for further preprocessing. Currently, batched inference is not supported; hence the list length should be 1.</p> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>List[ndarray]</code> <p>List containing images in HWC numpy array format.</p> required <p>Returns:</p> Type Description <code>List[ndarray]</code> <p>List of transformed images.</p> Source code in <code>ultralytics/models/sam/predict.py</code> <pre><code>def pre_transform(self, im):\n    \"\"\"\n    Perform initial transformations on the input image for preprocessing.\n\n    The method applies transformations such as resizing to prepare the image for further preprocessing.\n    Currently, batched inference is not supported; hence the list length should be 1.\n\n    Args:\n        im (List[np.ndarray]): List containing images in HWC numpy array format.\n\n    Returns:\n        (List[np.ndarray]): List of transformed images.\n    \"\"\"\n    assert len(im) == 1, \"SAM model does not currently support batched inference\"\n    letterbox = LetterBox(self.args.imgsz, auto=False, center=False)\n    return [letterbox(image=x) for x in im]\n</code></pre>"},{"location":"reference/models/sam/predict/#ultralytics.models.sam.predict.Predictor.preprocess","title":"<code>preprocess(im)</code>","text":"<p>Preprocess the input image for model inference.</p> <p>The method prepares the input image by applying transformations and normalization. It supports both torch.Tensor and list of np.ndarray as input formats.</p> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>Tensor | List[ndarray]</code> <p>BCHW tensor format or list of HWC numpy arrays.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The preprocessed image tensor.</p> Source code in <code>ultralytics/models/sam/predict.py</code> <pre><code>def preprocess(self, im):\n    \"\"\"\n    Preprocess the input image for model inference.\n\n    The method prepares the input image by applying transformations and normalization.\n    It supports both torch.Tensor and list of np.ndarray as input formats.\n\n    Args:\n        im (torch.Tensor | List[np.ndarray]): BCHW tensor format or list of HWC numpy arrays.\n\n    Returns:\n        (torch.Tensor): The preprocessed image tensor.\n    \"\"\"\n    if self.im is not None:\n        return self.im\n    not_tensor = not isinstance(im, torch.Tensor)\n    if not_tensor:\n        im = np.stack(self.pre_transform(im))\n        im = im[..., ::-1].transpose((0, 3, 1, 2))\n        im = np.ascontiguousarray(im)\n        im = torch.from_numpy(im)\n\n    im = im.to(self.device)\n    im = im.half() if self.model.fp16 else im.float()\n    if not_tensor:\n        im = (im - self.mean) / self.std\n    return im\n</code></pre>"},{"location":"reference/models/sam/predict/#ultralytics.models.sam.predict.Predictor.prompt_inference","title":"<code>prompt_inference(im, bboxes=None, points=None, labels=None, masks=None, multimask_output=False)</code>","text":"<p>Internal function for image segmentation inference based on cues like bounding boxes, points, and masks. Leverages SAM's specialized architecture for prompt-based, real-time segmentation.</p> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>Tensor</code> <p>The preprocessed input image in tensor format, with shape (N, C, H, W).</p> required <code>bboxes</code> <code>ndarray | List</code> <p>Bounding boxes with shape (N, 4), in XYXY format.</p> <code>None</code> <code>points</code> <code>ndarray | List</code> <p>Points indicating object locations with shape (N, 2), in pixel coordinates.</p> <code>None</code> <code>labels</code> <code>ndarray | List</code> <p>Labels for point prompts, shape (N, ). 1 for foreground and 0 for background.</p> <code>None</code> <code>masks</code> <code>ndarray</code> <p>Low-resolution masks from previous predictions. Shape should be (N, H, W). For SAM, H=W=256.</p> <code>None</code> <code>multimask_output</code> <code>bool</code> <p>Flag to return multiple masks. Helpful for ambiguous prompts. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Contains the following three elements. - np.ndarray: The output masks in shape CxHxW, where C is the number of generated masks. - np.ndarray: An array of length C containing quality scores predicted by the model for each mask. - np.ndarray: Low-resolution logits of shape CxHxW for subsequent inference, where H=W=256.</p> Source code in <code>ultralytics/models/sam/predict.py</code> <pre><code>def prompt_inference(self, im, bboxes=None, points=None, labels=None, masks=None, multimask_output=False):\n    \"\"\"\n    Internal function for image segmentation inference based on cues like bounding boxes, points, and masks.\n    Leverages SAM's specialized architecture for prompt-based, real-time segmentation.\n\n    Args:\n        im (torch.Tensor): The preprocessed input image in tensor format, with shape (N, C, H, W).\n        bboxes (np.ndarray | List, optional): Bounding boxes with shape (N, 4), in XYXY format.\n        points (np.ndarray | List, optional): Points indicating object locations with shape (N, 2), in pixel coordinates.\n        labels (np.ndarray | List, optional): Labels for point prompts, shape (N, ). 1 for foreground and 0 for background.\n        masks (np.ndarray, optional): Low-resolution masks from previous predictions. Shape should be (N, H, W). For SAM, H=W=256.\n        multimask_output (bool, optional): Flag to return multiple masks. Helpful for ambiguous prompts. Defaults to False.\n\n    Returns:\n        (tuple): Contains the following three elements.\n            - np.ndarray: The output masks in shape CxHxW, where C is the number of generated masks.\n            - np.ndarray: An array of length C containing quality scores predicted by the model for each mask.\n            - np.ndarray: Low-resolution logits of shape CxHxW for subsequent inference, where H=W=256.\n    \"\"\"\n    features = self.model.image_encoder(im) if self.features is None else self.features\n\n    src_shape, dst_shape = self.batch[1][0].shape[:2], im.shape[2:]\n    r = 1.0 if self.segment_all else min(dst_shape[0] / src_shape[0], dst_shape[1] / src_shape[1])\n    # Transform input prompts\n    if points is not None:\n        points = torch.as_tensor(points, dtype=torch.float32, device=self.device)\n        points = points[None] if points.ndim == 1 else points\n        # Assuming labels are all positive if users don't pass labels.\n        if labels is None:\n            labels = np.ones(points.shape[0])\n        labels = torch.as_tensor(labels, dtype=torch.int32, device=self.device)\n        points *= r\n        # (N, 2) --&gt; (N, 1, 2), (N, ) --&gt; (N, 1)\n        points, labels = points[:, None, :], labels[:, None]\n    if bboxes is not None:\n        bboxes = torch.as_tensor(bboxes, dtype=torch.float32, device=self.device)\n        bboxes = bboxes[None] if bboxes.ndim == 1 else bboxes\n        bboxes *= r\n    if masks is not None:\n        masks = torch.as_tensor(masks, dtype=torch.float32, device=self.device).unsqueeze(1)\n\n    points = (points, labels) if points is not None else None\n    # Embed prompts\n    sparse_embeddings, dense_embeddings = self.model.prompt_encoder(points=points, boxes=bboxes, masks=masks)\n\n    # Predict masks\n    pred_masks, pred_scores = self.model.mask_decoder(\n        image_embeddings=features,\n        image_pe=self.model.prompt_encoder.get_dense_pe(),\n        sparse_prompt_embeddings=sparse_embeddings,\n        dense_prompt_embeddings=dense_embeddings,\n        multimask_output=multimask_output,\n    )\n\n    # (N, d, H, W) --&gt; (N*d, H, W), (N, d) --&gt; (N*d, )\n    # `d` could be 1 or 3 depends on `multimask_output`.\n    return pred_masks.flatten(0, 1), pred_scores.flatten(0, 1)\n</code></pre>"},{"location":"reference/models/sam/predict/#ultralytics.models.sam.predict.Predictor.remove_small_regions","title":"<code>remove_small_regions(masks, min_area=0, nms_thresh=0.7)</code>  <code>staticmethod</code>","text":"<p>Perform post-processing on segmentation masks generated by the Segment Anything Model (SAM). Specifically, this function removes small disconnected regions and holes from the input masks, and then performs Non-Maximum Suppression (NMS) to eliminate any newly created duplicate boxes.</p> <p>Parameters:</p> Name Type Description Default <code>masks</code> <code>Tensor</code> <p>A tensor containing the masks to be processed. Shape should be (N, H, W), where N is                   the number of masks, H is height, and W is width.</p> required <code>min_area</code> <code>int</code> <p>The minimum area below which disconnected regions and holes will be removed. Defaults to 0.</p> <code>0</code> <code>nms_thresh</code> <code>float</code> <p>The IoU threshold for the NMS algorithm. Defaults to 0.7.</p> <code>0.7</code> <p>Returns:</p> Type Description <code>tuple([Tensor, List[int]])</code> <ul> <li>new_masks (torch.Tensor): The processed masks with small regions removed. Shape is (N, H, W).</li> <li>keep (List[int]): The indices of the remaining masks post-NMS, which can be used to filter the boxes.</li> </ul> Source code in <code>ultralytics/models/sam/predict.py</code> <pre><code>@staticmethod\ndef remove_small_regions(masks, min_area=0, nms_thresh=0.7):\n    \"\"\"\n    Perform post-processing on segmentation masks generated by the Segment Anything Model (SAM). Specifically, this\n    function removes small disconnected regions and holes from the input masks, and then performs Non-Maximum\n    Suppression (NMS) to eliminate any newly created duplicate boxes.\n\n    Args:\n        masks (torch.Tensor): A tensor containing the masks to be processed. Shape should be (N, H, W), where N is\n                              the number of masks, H is height, and W is width.\n        min_area (int): The minimum area below which disconnected regions and holes will be removed. Defaults to 0.\n        nms_thresh (float): The IoU threshold for the NMS algorithm. Defaults to 0.7.\n\n    Returns:\n        (tuple([torch.Tensor, List[int]])):\n            - new_masks (torch.Tensor): The processed masks with small regions removed. Shape is (N, H, W).\n            - keep (List[int]): The indices of the remaining masks post-NMS, which can be used to filter the boxes.\n    \"\"\"\n    if len(masks) == 0:\n        return masks\n\n    # Filter small disconnected regions and holes\n    new_masks = []\n    scores = []\n    for mask in masks:\n        mask = mask.cpu().numpy().astype(np.uint8)\n        mask, changed = remove_small_regions(mask, min_area, mode=\"holes\")\n        unchanged = not changed\n        mask, changed = remove_small_regions(mask, min_area, mode=\"islands\")\n        unchanged = unchanged and not changed\n\n        new_masks.append(torch.as_tensor(mask).unsqueeze(0))\n        # Give score=0 to changed masks and 1 to unchanged masks so NMS prefers masks not needing postprocessing\n        scores.append(float(unchanged))\n\n    # Recalculate boxes and remove any new duplicates\n    new_masks = torch.cat(new_masks, dim=0)\n    boxes = batched_mask_to_box(new_masks)\n    keep = torchvision.ops.nms(boxes.float(), torch.as_tensor(scores), nms_thresh)\n\n    return new_masks[keep].to(device=masks.device, dtype=masks.dtype), keep\n</code></pre>"},{"location":"reference/models/sam/predict/#ultralytics.models.sam.predict.Predictor.reset_image","title":"<code>reset_image()</code>","text":"<p>Resets the image and its features to None.</p> Source code in <code>ultralytics/models/sam/predict.py</code> <pre><code>def reset_image(self):\n    \"\"\"Resets the image and its features to None.\"\"\"\n    self.im = None\n    self.features = None\n</code></pre>"},{"location":"reference/models/sam/predict/#ultralytics.models.sam.predict.Predictor.set_image","title":"<code>set_image(image)</code>","text":"<p>Preprocesses and sets a single image for inference.</p> <p>This function sets up the model if not already initialized, configures the data source to the specified image, and preprocesses the image for feature extraction. Only one image can be set at a time.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str | ndarray</code> <p>Image file path as a string, or a np.ndarray image read by cv2.</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>If more than one image is set.</p> Source code in <code>ultralytics/models/sam/predict.py</code> <pre><code>def set_image(self, image):\n    \"\"\"\n    Preprocesses and sets a single image for inference.\n\n    This function sets up the model if not already initialized, configures the data source to the specified image,\n    and preprocesses the image for feature extraction. Only one image can be set at a time.\n\n    Args:\n        image (str | np.ndarray): Image file path as a string, or a np.ndarray image read by cv2.\n\n    Raises:\n        AssertionError: If more than one image is set.\n    \"\"\"\n    if self.model is None:\n        model = build_sam(self.args.model)\n        self.setup_model(model)\n    self.setup_source(image)\n    assert len(self.dataset) == 1, \"`set_image` only supports setting one image!\"\n    for batch in self.dataset:\n        im = self.preprocess(batch[1])\n        self.features = self.model.image_encoder(im)\n        self.im = im\n        break\n</code></pre>"},{"location":"reference/models/sam/predict/#ultralytics.models.sam.predict.Predictor.set_prompts","title":"<code>set_prompts(prompts)</code>","text":"<p>Set prompts in advance.</p> Source code in <code>ultralytics/models/sam/predict.py</code> <pre><code>def set_prompts(self, prompts):\n    \"\"\"Set prompts in advance.\"\"\"\n    self.prompts = prompts\n</code></pre>"},{"location":"reference/models/sam/predict/#ultralytics.models.sam.predict.Predictor.setup_model","title":"<code>setup_model(model, verbose=True)</code>","text":"<p>Initializes the Segment Anything Model (SAM) for inference.</p> <p>This method sets up the SAM model by allocating it to the appropriate device and initializing the necessary parameters for image normalization and other Ultralytics compatibility settings.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Module</code> <p>A pre-trained SAM model. If None, a model will be built based on configuration.</p> required <code>verbose</code> <code>bool</code> <p>If True, prints selected device information.</p> <code>True</code> <p>Attributes:</p> Name Type Description <code>model</code> <code>Module</code> <p>The SAM model allocated to the chosen device for inference.</p> <code>device</code> <code>device</code> <p>The device to which the model and tensors are allocated.</p> <code>mean</code> <code>Tensor</code> <p>The mean values for image normalization.</p> <code>std</code> <code>Tensor</code> <p>The standard deviation values for image normalization.</p> Source code in <code>ultralytics/models/sam/predict.py</code> <pre><code>def setup_model(self, model, verbose=True):\n    \"\"\"\n    Initializes the Segment Anything Model (SAM) for inference.\n\n    This method sets up the SAM model by allocating it to the appropriate device and initializing the necessary\n    parameters for image normalization and other Ultralytics compatibility settings.\n\n    Args:\n        model (torch.nn.Module): A pre-trained SAM model. If None, a model will be built based on configuration.\n        verbose (bool): If True, prints selected device information.\n\n    Attributes:\n        model (torch.nn.Module): The SAM model allocated to the chosen device for inference.\n        device (torch.device): The device to which the model and tensors are allocated.\n        mean (torch.Tensor): The mean values for image normalization.\n        std (torch.Tensor): The standard deviation values for image normalization.\n    \"\"\"\n    device = select_device(self.args.device, verbose=verbose)\n    if model is None:\n        model = build_sam(self.args.model)\n    model.eval()\n    self.model = model.to(device)\n    self.device = device\n    self.mean = torch.tensor([123.675, 116.28, 103.53]).view(-1, 1, 1).to(device)\n    self.std = torch.tensor([58.395, 57.12, 57.375]).view(-1, 1, 1).to(device)\n\n    # Ultralytics compatibility settings\n    self.model.pt = False\n    self.model.triton = False\n    self.model.stride = 32\n    self.model.fp16 = False\n    self.done_warmup = True\n</code></pre>"},{"location":"reference/models/sam/predict/#ultralytics.models.sam.predict.Predictor.setup_source","title":"<code>setup_source(source)</code>","text":"<p>Sets up the data source for inference.</p> <p>This method configures the data source from which images will be fetched for inference. The source could be a directory, a video file, or other types of image data sources.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | Path</code> <p>The path to the image data source for inference.</p> required Source code in <code>ultralytics/models/sam/predict.py</code> <pre><code>def setup_source(self, source):\n    \"\"\"\n    Sets up the data source for inference.\n\n    This method configures the data source from which images will be fetched for inference. The source could be a\n    directory, a video file, or other types of image data sources.\n\n    Args:\n        source (str | Path): The path to the image data source for inference.\n    \"\"\"\n    if source is not None:\n        super().setup_source(source)\n</code></pre>"},{"location":"reference/models/sam/modules/decoders/","title":"Reference for <code>ultralytics/models/sam/modules/decoders.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/sam/modules/decoders.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p>"},{"location":"reference/models/sam/modules/decoders/#ultralytics.models.sam.modules.decoders.MaskDecoder","title":"<code>ultralytics.models.sam.modules.decoders.MaskDecoder</code>","text":"<p>             Bases: <code>Module</code></p> <p>Decoder module for generating masks and their associated quality scores, using a transformer architecture to predict masks given image and prompt embeddings.</p> <p>Attributes:</p> Name Type Description <code>transformer_dim</code> <code>int</code> <p>Channel dimension for the transformer module.</p> <code>transformer</code> <code>Module</code> <p>The transformer module used for mask prediction.</p> <code>num_multimask_outputs</code> <code>int</code> <p>Number of masks to predict for disambiguating masks.</p> <code>iou_token</code> <code>Embedding</code> <p>Embedding for the IoU token.</p> <code>num_mask_tokens</code> <code>int</code> <p>Number of mask tokens.</p> <code>mask_tokens</code> <code>Embedding</code> <p>Embedding for the mask tokens.</p> <code>output_upscaling</code> <code>Sequential</code> <p>Neural network sequence for upscaling the output.</p> <code>output_hypernetworks_mlps</code> <code>ModuleList</code> <p>Hypernetwork MLPs for generating masks.</p> <code>iou_prediction_head</code> <code>Module</code> <p>MLP for predicting mask quality.</p> Source code in <code>ultralytics/models/sam/modules/decoders.py</code> <pre><code>class MaskDecoder(nn.Module):\n    \"\"\"\n    Decoder module for generating masks and their associated quality scores, using a transformer architecture to predict\n    masks given image and prompt embeddings.\n\n    Attributes:\n        transformer_dim (int): Channel dimension for the transformer module.\n        transformer (nn.Module): The transformer module used for mask prediction.\n        num_multimask_outputs (int): Number of masks to predict for disambiguating masks.\n        iou_token (nn.Embedding): Embedding for the IoU token.\n        num_mask_tokens (int): Number of mask tokens.\n        mask_tokens (nn.Embedding): Embedding for the mask tokens.\n        output_upscaling (nn.Sequential): Neural network sequence for upscaling the output.\n        output_hypernetworks_mlps (nn.ModuleList): Hypernetwork MLPs for generating masks.\n        iou_prediction_head (nn.Module): MLP for predicting mask quality.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        transformer_dim: int,\n        transformer: nn.Module,\n        num_multimask_outputs: int = 3,\n        activation: Type[nn.Module] = nn.GELU,\n        iou_head_depth: int = 3,\n        iou_head_hidden_dim: int = 256,\n    ) -&gt; None:\n        \"\"\"\n        Predicts masks given an image and prompt embeddings, using a transformer architecture.\n\n        Args:\n            transformer_dim (int): the channel dimension of the transformer module\n            transformer (nn.Module): the transformer used to predict masks\n            num_multimask_outputs (int): the number of masks to predict when disambiguating masks\n            activation (nn.Module): the type of activation to use when upscaling masks\n            iou_head_depth (int): the depth of the MLP used to predict mask quality\n            iou_head_hidden_dim (int): the hidden dimension of the MLP used to predict mask quality\n        \"\"\"\n        super().__init__()\n        self.transformer_dim = transformer_dim\n        self.transformer = transformer\n\n        self.num_multimask_outputs = num_multimask_outputs\n\n        self.iou_token = nn.Embedding(1, transformer_dim)\n        self.num_mask_tokens = num_multimask_outputs + 1\n        self.mask_tokens = nn.Embedding(self.num_mask_tokens, transformer_dim)\n\n        self.output_upscaling = nn.Sequential(\n            nn.ConvTranspose2d(transformer_dim, transformer_dim // 4, kernel_size=2, stride=2),\n            LayerNorm2d(transformer_dim // 4),\n            activation(),\n            nn.ConvTranspose2d(transformer_dim // 4, transformer_dim // 8, kernel_size=2, stride=2),\n            activation(),\n        )\n        self.output_hypernetworks_mlps = nn.ModuleList(\n            [MLP(transformer_dim, transformer_dim, transformer_dim // 8, 3) for _ in range(self.num_mask_tokens)]\n        )\n\n        self.iou_prediction_head = MLP(transformer_dim, iou_head_hidden_dim, self.num_mask_tokens, iou_head_depth)\n\n    def forward(\n        self,\n        image_embeddings: torch.Tensor,\n        image_pe: torch.Tensor,\n        sparse_prompt_embeddings: torch.Tensor,\n        dense_prompt_embeddings: torch.Tensor,\n        multimask_output: bool,\n    ) -&gt; Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"\n        Predict masks given image and prompt embeddings.\n\n        Args:\n            image_embeddings (torch.Tensor): the embeddings from the image encoder\n            image_pe (torch.Tensor): positional encoding with the shape of image_embeddings\n            sparse_prompt_embeddings (torch.Tensor): the embeddings of the points and boxes\n            dense_prompt_embeddings (torch.Tensor): the embeddings of the mask inputs\n            multimask_output (bool): Whether to return multiple masks or a single mask.\n\n        Returns:\n            torch.Tensor: batched predicted masks\n            torch.Tensor: batched predictions of mask quality\n        \"\"\"\n        masks, iou_pred = self.predict_masks(\n            image_embeddings=image_embeddings,\n            image_pe=image_pe,\n            sparse_prompt_embeddings=sparse_prompt_embeddings,\n            dense_prompt_embeddings=dense_prompt_embeddings,\n        )\n\n        # Select the correct mask or masks for output\n        mask_slice = slice(1, None) if multimask_output else slice(0, 1)\n        masks = masks[:, mask_slice, :, :]\n        iou_pred = iou_pred[:, mask_slice]\n\n        # Prepare output\n        return masks, iou_pred\n\n    def predict_masks(\n        self,\n        image_embeddings: torch.Tensor,\n        image_pe: torch.Tensor,\n        sparse_prompt_embeddings: torch.Tensor,\n        dense_prompt_embeddings: torch.Tensor,\n    ) -&gt; Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"\n        Predicts masks.\n\n        See 'forward' for more details.\n        \"\"\"\n        # Concatenate output tokens\n        output_tokens = torch.cat([self.iou_token.weight, self.mask_tokens.weight], dim=0)\n        output_tokens = output_tokens.unsqueeze(0).expand(sparse_prompt_embeddings.size(0), -1, -1)\n        tokens = torch.cat((output_tokens, sparse_prompt_embeddings), dim=1)\n\n        # Expand per-image data in batch direction to be per-mask\n        src = torch.repeat_interleave(image_embeddings, tokens.shape[0], dim=0)\n        src = src + dense_prompt_embeddings\n        pos_src = torch.repeat_interleave(image_pe, tokens.shape[0], dim=0)\n        b, c, h, w = src.shape\n\n        # Run the transformer\n        hs, src = self.transformer(src, pos_src, tokens)\n        iou_token_out = hs[:, 0, :]\n        mask_tokens_out = hs[:, 1 : (1 + self.num_mask_tokens), :]\n\n        # Upscale mask embeddings and predict masks using the mask tokens\n        src = src.transpose(1, 2).view(b, c, h, w)\n        upscaled_embedding = self.output_upscaling(src)\n        hyper_in_list: List[torch.Tensor] = [\n            self.output_hypernetworks_mlps[i](mask_tokens_out[:, i, :]) for i in range(self.num_mask_tokens)\n        ]\n        hyper_in = torch.stack(hyper_in_list, dim=1)\n        b, c, h, w = upscaled_embedding.shape\n        masks = (hyper_in @ upscaled_embedding.view(b, c, h * w)).view(b, -1, h, w)\n\n        # Generate mask quality predictions\n        iou_pred = self.iou_prediction_head(iou_token_out)\n\n        return masks, iou_pred\n</code></pre>"},{"location":"reference/models/sam/modules/decoders/#ultralytics.models.sam.modules.decoders.MaskDecoder.__init__","title":"<code>__init__(*, transformer_dim, transformer, num_multimask_outputs=3, activation=nn.GELU, iou_head_depth=3, iou_head_hidden_dim=256)</code>","text":"<p>Predicts masks given an image and prompt embeddings, using a transformer architecture.</p> <p>Parameters:</p> Name Type Description Default <code>transformer_dim</code> <code>int</code> <p>the channel dimension of the transformer module</p> required <code>transformer</code> <code>Module</code> <p>the transformer used to predict masks</p> required <code>num_multimask_outputs</code> <code>int</code> <p>the number of masks to predict when disambiguating masks</p> <code>3</code> <code>activation</code> <code>Module</code> <p>the type of activation to use when upscaling masks</p> <code>GELU</code> <code>iou_head_depth</code> <code>int</code> <p>the depth of the MLP used to predict mask quality</p> <code>3</code> <code>iou_head_hidden_dim</code> <code>int</code> <p>the hidden dimension of the MLP used to predict mask quality</p> <code>256</code> Source code in <code>ultralytics/models/sam/modules/decoders.py</code> <pre><code>def __init__(\n    self,\n    *,\n    transformer_dim: int,\n    transformer: nn.Module,\n    num_multimask_outputs: int = 3,\n    activation: Type[nn.Module] = nn.GELU,\n    iou_head_depth: int = 3,\n    iou_head_hidden_dim: int = 256,\n) -&gt; None:\n    \"\"\"\n    Predicts masks given an image and prompt embeddings, using a transformer architecture.\n\n    Args:\n        transformer_dim (int): the channel dimension of the transformer module\n        transformer (nn.Module): the transformer used to predict masks\n        num_multimask_outputs (int): the number of masks to predict when disambiguating masks\n        activation (nn.Module): the type of activation to use when upscaling masks\n        iou_head_depth (int): the depth of the MLP used to predict mask quality\n        iou_head_hidden_dim (int): the hidden dimension of the MLP used to predict mask quality\n    \"\"\"\n    super().__init__()\n    self.transformer_dim = transformer_dim\n    self.transformer = transformer\n\n    self.num_multimask_outputs = num_multimask_outputs\n\n    self.iou_token = nn.Embedding(1, transformer_dim)\n    self.num_mask_tokens = num_multimask_outputs + 1\n    self.mask_tokens = nn.Embedding(self.num_mask_tokens, transformer_dim)\n\n    self.output_upscaling = nn.Sequential(\n        nn.ConvTranspose2d(transformer_dim, transformer_dim // 4, kernel_size=2, stride=2),\n        LayerNorm2d(transformer_dim // 4),\n        activation(),\n        nn.ConvTranspose2d(transformer_dim // 4, transformer_dim // 8, kernel_size=2, stride=2),\n        activation(),\n    )\n    self.output_hypernetworks_mlps = nn.ModuleList(\n        [MLP(transformer_dim, transformer_dim, transformer_dim // 8, 3) for _ in range(self.num_mask_tokens)]\n    )\n\n    self.iou_prediction_head = MLP(transformer_dim, iou_head_hidden_dim, self.num_mask_tokens, iou_head_depth)\n</code></pre>"},{"location":"reference/models/sam/modules/decoders/#ultralytics.models.sam.modules.decoders.MaskDecoder.forward","title":"<code>forward(image_embeddings, image_pe, sparse_prompt_embeddings, dense_prompt_embeddings, multimask_output)</code>","text":"<p>Predict masks given image and prompt embeddings.</p> <p>Parameters:</p> Name Type Description Default <code>image_embeddings</code> <code>Tensor</code> <p>the embeddings from the image encoder</p> required <code>image_pe</code> <code>Tensor</code> <p>positional encoding with the shape of image_embeddings</p> required <code>sparse_prompt_embeddings</code> <code>Tensor</code> <p>the embeddings of the points and boxes</p> required <code>dense_prompt_embeddings</code> <code>Tensor</code> <p>the embeddings of the mask inputs</p> required <code>multimask_output</code> <code>bool</code> <p>Whether to return multiple masks or a single mask.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor: batched predicted masks</p> <code>Tensor</code> <p>torch.Tensor: batched predictions of mask quality</p> Source code in <code>ultralytics/models/sam/modules/decoders.py</code> <pre><code>def forward(\n    self,\n    image_embeddings: torch.Tensor,\n    image_pe: torch.Tensor,\n    sparse_prompt_embeddings: torch.Tensor,\n    dense_prompt_embeddings: torch.Tensor,\n    multimask_output: bool,\n) -&gt; Tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Predict masks given image and prompt embeddings.\n\n    Args:\n        image_embeddings (torch.Tensor): the embeddings from the image encoder\n        image_pe (torch.Tensor): positional encoding with the shape of image_embeddings\n        sparse_prompt_embeddings (torch.Tensor): the embeddings of the points and boxes\n        dense_prompt_embeddings (torch.Tensor): the embeddings of the mask inputs\n        multimask_output (bool): Whether to return multiple masks or a single mask.\n\n    Returns:\n        torch.Tensor: batched predicted masks\n        torch.Tensor: batched predictions of mask quality\n    \"\"\"\n    masks, iou_pred = self.predict_masks(\n        image_embeddings=image_embeddings,\n        image_pe=image_pe,\n        sparse_prompt_embeddings=sparse_prompt_embeddings,\n        dense_prompt_embeddings=dense_prompt_embeddings,\n    )\n\n    # Select the correct mask or masks for output\n    mask_slice = slice(1, None) if multimask_output else slice(0, 1)\n    masks = masks[:, mask_slice, :, :]\n    iou_pred = iou_pred[:, mask_slice]\n\n    # Prepare output\n    return masks, iou_pred\n</code></pre>"},{"location":"reference/models/sam/modules/decoders/#ultralytics.models.sam.modules.decoders.MaskDecoder.predict_masks","title":"<code>predict_masks(image_embeddings, image_pe, sparse_prompt_embeddings, dense_prompt_embeddings)</code>","text":"<p>Predicts masks.</p> <p>See 'forward' for more details.</p> Source code in <code>ultralytics/models/sam/modules/decoders.py</code> <pre><code>def predict_masks(\n    self,\n    image_embeddings: torch.Tensor,\n    image_pe: torch.Tensor,\n    sparse_prompt_embeddings: torch.Tensor,\n    dense_prompt_embeddings: torch.Tensor,\n) -&gt; Tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Predicts masks.\n\n    See 'forward' for more details.\n    \"\"\"\n    # Concatenate output tokens\n    output_tokens = torch.cat([self.iou_token.weight, self.mask_tokens.weight], dim=0)\n    output_tokens = output_tokens.unsqueeze(0).expand(sparse_prompt_embeddings.size(0), -1, -1)\n    tokens = torch.cat((output_tokens, sparse_prompt_embeddings), dim=1)\n\n    # Expand per-image data in batch direction to be per-mask\n    src = torch.repeat_interleave(image_embeddings, tokens.shape[0], dim=0)\n    src = src + dense_prompt_embeddings\n    pos_src = torch.repeat_interleave(image_pe, tokens.shape[0], dim=0)\n    b, c, h, w = src.shape\n\n    # Run the transformer\n    hs, src = self.transformer(src, pos_src, tokens)\n    iou_token_out = hs[:, 0, :]\n    mask_tokens_out = hs[:, 1 : (1 + self.num_mask_tokens), :]\n\n    # Upscale mask embeddings and predict masks using the mask tokens\n    src = src.transpose(1, 2).view(b, c, h, w)\n    upscaled_embedding = self.output_upscaling(src)\n    hyper_in_list: List[torch.Tensor] = [\n        self.output_hypernetworks_mlps[i](mask_tokens_out[:, i, :]) for i in range(self.num_mask_tokens)\n    ]\n    hyper_in = torch.stack(hyper_in_list, dim=1)\n    b, c, h, w = upscaled_embedding.shape\n    masks = (hyper_in @ upscaled_embedding.view(b, c, h * w)).view(b, -1, h, w)\n\n    # Generate mask quality predictions\n    iou_pred = self.iou_prediction_head(iou_token_out)\n\n    return masks, iou_pred\n</code></pre>"},{"location":"reference/models/sam/modules/decoders/#ultralytics.models.sam.modules.decoders.MLP","title":"<code>ultralytics.models.sam.modules.decoders.MLP</code>","text":"<p>             Bases: <code>Module</code></p> <p>MLP (Multi-Layer Perceptron) model lightly adapted from https://github.com/facebookresearch/MaskFormer/blob/main/mask_former/modeling/transformer/transformer_predictor.py</p> Source code in <code>ultralytics/models/sam/modules/decoders.py</code> <pre><code>class MLP(nn.Module):\n    \"\"\"\n    MLP (Multi-Layer Perceptron) model lightly adapted from\n    https://github.com/facebookresearch/MaskFormer/blob/main/mask_former/modeling/transformer/transformer_predictor.py\n    \"\"\"\n\n    def __init__(\n        self,\n        input_dim: int,\n        hidden_dim: int,\n        output_dim: int,\n        num_layers: int,\n        sigmoid_output: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Initializes the MLP (Multi-Layer Perceptron) model.\n\n        Args:\n            input_dim (int): The dimensionality of the input features.\n            hidden_dim (int): The dimensionality of the hidden layers.\n            output_dim (int): The dimensionality of the output layer.\n            num_layers (int): The number of hidden layers.\n            sigmoid_output (bool, optional): Apply a sigmoid activation to the output layer. Defaults to False.\n        \"\"\"\n        super().__init__()\n        self.num_layers = num_layers\n        h = [hidden_dim] * (num_layers - 1)\n        self.layers = nn.ModuleList(nn.Linear(n, k) for n, k in zip([input_dim] + h, h + [output_dim]))\n        self.sigmoid_output = sigmoid_output\n\n    def forward(self, x):\n        \"\"\"Executes feedforward within the neural network module and applies activation.\"\"\"\n        for i, layer in enumerate(self.layers):\n            x = F.relu(layer(x)) if i &lt; self.num_layers - 1 else layer(x)\n        if self.sigmoid_output:\n            x = torch.sigmoid(x)\n        return x\n</code></pre>"},{"location":"reference/models/sam/modules/decoders/#ultralytics.models.sam.modules.decoders.MLP.__init__","title":"<code>__init__(input_dim, hidden_dim, output_dim, num_layers, sigmoid_output=False)</code>","text":"<p>Initializes the MLP (Multi-Layer Perceptron) model.</p> <p>Parameters:</p> Name Type Description Default <code>input_dim</code> <code>int</code> <p>The dimensionality of the input features.</p> required <code>hidden_dim</code> <code>int</code> <p>The dimensionality of the hidden layers.</p> required <code>output_dim</code> <code>int</code> <p>The dimensionality of the output layer.</p> required <code>num_layers</code> <code>int</code> <p>The number of hidden layers.</p> required <code>sigmoid_output</code> <code>bool</code> <p>Apply a sigmoid activation to the output layer. Defaults to False.</p> <code>False</code> Source code in <code>ultralytics/models/sam/modules/decoders.py</code> <pre><code>def __init__(\n    self,\n    input_dim: int,\n    hidden_dim: int,\n    output_dim: int,\n    num_layers: int,\n    sigmoid_output: bool = False,\n) -&gt; None:\n    \"\"\"\n    Initializes the MLP (Multi-Layer Perceptron) model.\n\n    Args:\n        input_dim (int): The dimensionality of the input features.\n        hidden_dim (int): The dimensionality of the hidden layers.\n        output_dim (int): The dimensionality of the output layer.\n        num_layers (int): The number of hidden layers.\n        sigmoid_output (bool, optional): Apply a sigmoid activation to the output layer. Defaults to False.\n    \"\"\"\n    super().__init__()\n    self.num_layers = num_layers\n    h = [hidden_dim] * (num_layers - 1)\n    self.layers = nn.ModuleList(nn.Linear(n, k) for n, k in zip([input_dim] + h, h + [output_dim]))\n    self.sigmoid_output = sigmoid_output\n</code></pre>"},{"location":"reference/models/sam/modules/decoders/#ultralytics.models.sam.modules.decoders.MLP.forward","title":"<code>forward(x)</code>","text":"<p>Executes feedforward within the neural network module and applies activation.</p> Source code in <code>ultralytics/models/sam/modules/decoders.py</code> <pre><code>def forward(self, x):\n    \"\"\"Executes feedforward within the neural network module and applies activation.\"\"\"\n    for i, layer in enumerate(self.layers):\n        x = F.relu(layer(x)) if i &lt; self.num_layers - 1 else layer(x)\n    if self.sigmoid_output:\n        x = torch.sigmoid(x)\n    return x\n</code></pre>"},{"location":"reference/models/sam/modules/encoders/","title":"Reference for <code>ultralytics/models/sam/modules/encoders.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/sam/modules/encoders.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/models/sam/modules/encoders/#ultralytics.models.sam.modules.encoders.ImageEncoderViT","title":"<code>ultralytics.models.sam.modules.encoders.ImageEncoderViT</code>","text":"<p>             Bases: <code>Module</code></p> <p>An image encoder using Vision Transformer (ViT) architecture for encoding an image into a compact latent space. The encoder takes an image, splits it into patches, and processes these patches through a series of transformer blocks. The encoded patches are then processed through a neck to generate the final encoded representation.</p> <p>This class and its supporting functions below lightly adapted from the ViTDet backbone available at https://github.com/facebookresearch/detectron2/blob/main/detectron2/modeling/backbone/vit.py.</p> <p>Attributes:</p> Name Type Description <code>img_size</code> <code>int</code> <p>Dimension of input images, assumed to be square.</p> <code>patch_embed</code> <code>PatchEmbed</code> <p>Module for patch embedding.</p> <code>pos_embed</code> <code>Parameter</code> <p>Absolute positional embedding for patches.</p> <code>blocks</code> <code>ModuleList</code> <p>List of transformer blocks for processing patch embeddings.</p> <code>neck</code> <code>Sequential</code> <p>Neck module to further process the output.</p> Source code in <code>ultralytics/models/sam/modules/encoders.py</code> <pre><code>class ImageEncoderViT(nn.Module):\n    \"\"\"\n    An image encoder using Vision Transformer (ViT) architecture for encoding an image into a compact latent space. The\n    encoder takes an image, splits it into patches, and processes these patches through a series of transformer blocks.\n    The encoded patches are then processed through a neck to generate the final encoded representation.\n\n    This class and its supporting functions below lightly adapted from the ViTDet backbone available at\n    https://github.com/facebookresearch/detectron2/blob/main/detectron2/modeling/backbone/vit.py.\n\n    Attributes:\n        img_size (int): Dimension of input images, assumed to be square.\n        patch_embed (PatchEmbed): Module for patch embedding.\n        pos_embed (nn.Parameter, optional): Absolute positional embedding for patches.\n        blocks (nn.ModuleList): List of transformer blocks for processing patch embeddings.\n        neck (nn.Sequential): Neck module to further process the output.\n    \"\"\"\n\n    def __init__(\n        self,\n        img_size: int = 1024,\n        patch_size: int = 16,\n        in_chans: int = 3,\n        embed_dim: int = 768,\n        depth: int = 12,\n        num_heads: int = 12,\n        mlp_ratio: float = 4.0,\n        out_chans: int = 256,\n        qkv_bias: bool = True,\n        norm_layer: Type[nn.Module] = nn.LayerNorm,\n        act_layer: Type[nn.Module] = nn.GELU,\n        use_abs_pos: bool = True,\n        use_rel_pos: bool = False,\n        rel_pos_zero_init: bool = True,\n        window_size: int = 0,\n        global_attn_indexes: Tuple[int, ...] = (),\n    ) -&gt; None:\n        \"\"\"\n        Args:\n            img_size (int): Input image size.\n            patch_size (int): Patch size.\n            in_chans (int): Number of input image channels.\n            embed_dim (int): Patch embedding dimension.\n            depth (int): Depth of ViT.\n            num_heads (int): Number of attention heads in each ViT block.\n            mlp_ratio (float): Ratio of mlp hidden dim to embedding dim.\n            qkv_bias (bool): If True, add a learnable bias to query, key, value.\n            norm_layer (nn.Module): Normalization layer.\n            act_layer (nn.Module): Activation layer.\n            use_abs_pos (bool): If True, use absolute positional embeddings.\n            use_rel_pos (bool): If True, add relative positional embeddings to the attention map.\n            rel_pos_zero_init (bool): If True, zero initialize relative positional parameters.\n            window_size (int): Window size for window attention blocks.\n            global_attn_indexes (list): Indexes for blocks using global attention.\n        \"\"\"\n        super().__init__()\n        self.img_size = img_size\n\n        self.patch_embed = PatchEmbed(\n            kernel_size=(patch_size, patch_size),\n            stride=(patch_size, patch_size),\n            in_chans=in_chans,\n            embed_dim=embed_dim,\n        )\n\n        self.pos_embed: Optional[nn.Parameter] = None\n        if use_abs_pos:\n            # Initialize absolute positional embedding with pretrain image size.\n            self.pos_embed = nn.Parameter(torch.zeros(1, img_size // patch_size, img_size // patch_size, embed_dim))\n\n        self.blocks = nn.ModuleList()\n        for i in range(depth):\n            block = Block(\n                dim=embed_dim,\n                num_heads=num_heads,\n                mlp_ratio=mlp_ratio,\n                qkv_bias=qkv_bias,\n                norm_layer=norm_layer,\n                act_layer=act_layer,\n                use_rel_pos=use_rel_pos,\n                rel_pos_zero_init=rel_pos_zero_init,\n                window_size=window_size if i not in global_attn_indexes else 0,\n                input_size=(img_size // patch_size, img_size // patch_size),\n            )\n            self.blocks.append(block)\n\n        self.neck = nn.Sequential(\n            nn.Conv2d(\n                embed_dim,\n                out_chans,\n                kernel_size=1,\n                bias=False,\n            ),\n            LayerNorm2d(out_chans),\n            nn.Conv2d(\n                out_chans,\n                out_chans,\n                kernel_size=3,\n                padding=1,\n                bias=False,\n            ),\n            LayerNorm2d(out_chans),\n        )\n\n    def forward(self, x: torch.Tensor) -&gt; torch.Tensor:\n        \"\"\"Processes input through patch embedding, applies positional embedding if present, and passes through blocks\n        and neck.\n        \"\"\"\n        x = self.patch_embed(x)\n        if self.pos_embed is not None:\n            x = x + self.pos_embed\n        for blk in self.blocks:\n            x = blk(x)\n        return self.neck(x.permute(0, 3, 1, 2))\n</code></pre>"},{"location":"reference/models/sam/modules/encoders/#ultralytics.models.sam.modules.encoders.ImageEncoderViT.__init__","title":"<code>__init__(img_size=1024, patch_size=16, in_chans=3, embed_dim=768, depth=12, num_heads=12, mlp_ratio=4.0, out_chans=256, qkv_bias=True, norm_layer=nn.LayerNorm, act_layer=nn.GELU, use_abs_pos=True, use_rel_pos=False, rel_pos_zero_init=True, window_size=0, global_attn_indexes=())</code>","text":"<p>Parameters:</p> Name Type Description Default <code>img_size</code> <code>int</code> <p>Input image size.</p> <code>1024</code> <code>patch_size</code> <code>int</code> <p>Patch size.</p> <code>16</code> <code>in_chans</code> <code>int</code> <p>Number of input image channels.</p> <code>3</code> <code>embed_dim</code> <code>int</code> <p>Patch embedding dimension.</p> <code>768</code> <code>depth</code> <code>int</code> <p>Depth of ViT.</p> <code>12</code> <code>num_heads</code> <code>int</code> <p>Number of attention heads in each ViT block.</p> <code>12</code> <code>mlp_ratio</code> <code>float</code> <p>Ratio of mlp hidden dim to embedding dim.</p> <code>4.0</code> <code>qkv_bias</code> <code>bool</code> <p>If True, add a learnable bias to query, key, value.</p> <code>True</code> <code>norm_layer</code> <code>Module</code> <p>Normalization layer.</p> <code>LayerNorm</code> <code>act_layer</code> <code>Module</code> <p>Activation layer.</p> <code>GELU</code> <code>use_abs_pos</code> <code>bool</code> <p>If True, use absolute positional embeddings.</p> <code>True</code> <code>use_rel_pos</code> <code>bool</code> <p>If True, add relative positional embeddings to the attention map.</p> <code>False</code> <code>rel_pos_zero_init</code> <code>bool</code> <p>If True, zero initialize relative positional parameters.</p> <code>True</code> <code>window_size</code> <code>int</code> <p>Window size for window attention blocks.</p> <code>0</code> <code>global_attn_indexes</code> <code>list</code> <p>Indexes for blocks using global attention.</p> <code>()</code> Source code in <code>ultralytics/models/sam/modules/encoders.py</code> <pre><code>def __init__(\n    self,\n    img_size: int = 1024,\n    patch_size: int = 16,\n    in_chans: int = 3,\n    embed_dim: int = 768,\n    depth: int = 12,\n    num_heads: int = 12,\n    mlp_ratio: float = 4.0,\n    out_chans: int = 256,\n    qkv_bias: bool = True,\n    norm_layer: Type[nn.Module] = nn.LayerNorm,\n    act_layer: Type[nn.Module] = nn.GELU,\n    use_abs_pos: bool = True,\n    use_rel_pos: bool = False,\n    rel_pos_zero_init: bool = True,\n    window_size: int = 0,\n    global_attn_indexes: Tuple[int, ...] = (),\n) -&gt; None:\n    \"\"\"\n    Args:\n        img_size (int): Input image size.\n        patch_size (int): Patch size.\n        in_chans (int): Number of input image channels.\n        embed_dim (int): Patch embedding dimension.\n        depth (int): Depth of ViT.\n        num_heads (int): Number of attention heads in each ViT block.\n        mlp_ratio (float): Ratio of mlp hidden dim to embedding dim.\n        qkv_bias (bool): If True, add a learnable bias to query, key, value.\n        norm_layer (nn.Module): Normalization layer.\n        act_layer (nn.Module): Activation layer.\n        use_abs_pos (bool): If True, use absolute positional embeddings.\n        use_rel_pos (bool): If True, add relative positional embeddings to the attention map.\n        rel_pos_zero_init (bool): If True, zero initialize relative positional parameters.\n        window_size (int): Window size for window attention blocks.\n        global_attn_indexes (list): Indexes for blocks using global attention.\n    \"\"\"\n    super().__init__()\n    self.img_size = img_size\n\n    self.patch_embed = PatchEmbed(\n        kernel_size=(patch_size, patch_size),\n        stride=(patch_size, patch_size),\n        in_chans=in_chans,\n        embed_dim=embed_dim,\n    )\n\n    self.pos_embed: Optional[nn.Parameter] = None\n    if use_abs_pos:\n        # Initialize absolute positional embedding with pretrain image size.\n        self.pos_embed = nn.Parameter(torch.zeros(1, img_size // patch_size, img_size // patch_size, embed_dim))\n\n    self.blocks = nn.ModuleList()\n    for i in range(depth):\n        block = Block(\n            dim=embed_dim,\n            num_heads=num_heads,\n            mlp_ratio=mlp_ratio,\n            qkv_bias=qkv_bias,\n            norm_layer=norm_layer,\n            act_layer=act_layer,\n            use_rel_pos=use_rel_pos,\n            rel_pos_zero_init=rel_pos_zero_init,\n            window_size=window_size if i not in global_attn_indexes else 0,\n            input_size=(img_size // patch_size, img_size // patch_size),\n        )\n        self.blocks.append(block)\n\n    self.neck = nn.Sequential(\n        nn.Conv2d(\n            embed_dim,\n            out_chans,\n            kernel_size=1,\n            bias=False,\n        ),\n        LayerNorm2d(out_chans),\n        nn.Conv2d(\n            out_chans,\n            out_chans,\n            kernel_size=3,\n            padding=1,\n            bias=False,\n        ),\n        LayerNorm2d(out_chans),\n    )\n</code></pre>"},{"location":"reference/models/sam/modules/encoders/#ultralytics.models.sam.modules.encoders.ImageEncoderViT.forward","title":"<code>forward(x)</code>","text":"<p>Processes input through patch embedding, applies positional embedding if present, and passes through blocks and neck.</p> Source code in <code>ultralytics/models/sam/modules/encoders.py</code> <pre><code>def forward(self, x: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"Processes input through patch embedding, applies positional embedding if present, and passes through blocks\n    and neck.\n    \"\"\"\n    x = self.patch_embed(x)\n    if self.pos_embed is not None:\n        x = x + self.pos_embed\n    for blk in self.blocks:\n        x = blk(x)\n    return self.neck(x.permute(0, 3, 1, 2))\n</code></pre>"},{"location":"reference/models/sam/modules/encoders/#ultralytics.models.sam.modules.encoders.PromptEncoder","title":"<code>ultralytics.models.sam.modules.encoders.PromptEncoder</code>","text":"<p>             Bases: <code>Module</code></p> <p>Encodes different types of prompts, including points, boxes, and masks, for input to SAM's mask decoder. The encoder produces both sparse and dense embeddings for the input prompts.</p> <p>Attributes:</p> Name Type Description <code>embed_dim</code> <code>int</code> <p>Dimension of the embeddings.</p> <code>input_image_size</code> <code>Tuple[int, int]</code> <p>Size of the input image as (H, W).</p> <code>image_embedding_size</code> <code>Tuple[int, int]</code> <p>Spatial size of the image embedding as (H, W).</p> <code>pe_layer</code> <code>PositionEmbeddingRandom</code> <p>Module for random position embedding.</p> <code>num_point_embeddings</code> <code>int</code> <p>Number of point embeddings for different types of points.</p> <code>point_embeddings</code> <code>ModuleList</code> <p>List of point embeddings.</p> <code>not_a_point_embed</code> <code>Embedding</code> <p>Embedding for points that are not a part of any label.</p> <code>mask_input_size</code> <code>Tuple[int, int]</code> <p>Size of the input mask.</p> <code>mask_downscaling</code> <code>Sequential</code> <p>Neural network for downscaling the mask.</p> <code>no_mask_embed</code> <code>Embedding</code> <p>Embedding for cases where no mask is provided.</p> Source code in <code>ultralytics/models/sam/modules/encoders.py</code> <pre><code>class PromptEncoder(nn.Module):\n    \"\"\"\n    Encodes different types of prompts, including points, boxes, and masks, for input to SAM's mask decoder. The encoder\n    produces both sparse and dense embeddings for the input prompts.\n\n    Attributes:\n        embed_dim (int): Dimension of the embeddings.\n        input_image_size (Tuple[int, int]): Size of the input image as (H, W).\n        image_embedding_size (Tuple[int, int]): Spatial size of the image embedding as (H, W).\n        pe_layer (PositionEmbeddingRandom): Module for random position embedding.\n        num_point_embeddings (int): Number of point embeddings for different types of points.\n        point_embeddings (nn.ModuleList): List of point embeddings.\n        not_a_point_embed (nn.Embedding): Embedding for points that are not a part of any label.\n        mask_input_size (Tuple[int, int]): Size of the input mask.\n        mask_downscaling (nn.Sequential): Neural network for downscaling the mask.\n        no_mask_embed (nn.Embedding): Embedding for cases where no mask is provided.\n    \"\"\"\n\n    def __init__(\n        self,\n        embed_dim: int,\n        image_embedding_size: Tuple[int, int],\n        input_image_size: Tuple[int, int],\n        mask_in_chans: int,\n        activation: Type[nn.Module] = nn.GELU,\n    ) -&gt; None:\n        \"\"\"\n        Encodes prompts for input to SAM's mask decoder.\n\n        Args:\n          embed_dim (int): The prompts' embedding dimension\n          image_embedding_size (tuple(int, int)): The spatial size of the\n            image embedding, as (H, W).\n          input_image_size (int): The padded size of the image as input\n            to the image encoder, as (H, W).\n          mask_in_chans (int): The number of hidden channels used for\n            encoding input masks.\n          activation (nn.Module): The activation to use when encoding\n            input masks.\n        \"\"\"\n        super().__init__()\n        self.embed_dim = embed_dim\n        self.input_image_size = input_image_size\n        self.image_embedding_size = image_embedding_size\n        self.pe_layer = PositionEmbeddingRandom(embed_dim // 2)\n\n        self.num_point_embeddings: int = 4  # pos/neg point + 2 box corners\n        point_embeddings = [nn.Embedding(1, embed_dim) for _ in range(self.num_point_embeddings)]\n        self.point_embeddings = nn.ModuleList(point_embeddings)\n        self.not_a_point_embed = nn.Embedding(1, embed_dim)\n\n        self.mask_input_size = (4 * image_embedding_size[0], 4 * image_embedding_size[1])\n        self.mask_downscaling = nn.Sequential(\n            nn.Conv2d(1, mask_in_chans // 4, kernel_size=2, stride=2),\n            LayerNorm2d(mask_in_chans // 4),\n            activation(),\n            nn.Conv2d(mask_in_chans // 4, mask_in_chans, kernel_size=2, stride=2),\n            LayerNorm2d(mask_in_chans),\n            activation(),\n            nn.Conv2d(mask_in_chans, embed_dim, kernel_size=1),\n        )\n        self.no_mask_embed = nn.Embedding(1, embed_dim)\n\n    def get_dense_pe(self) -&gt; torch.Tensor:\n        \"\"\"\n        Returns the positional encoding used to encode point prompts, applied to a dense set of points the shape of the\n        image encoding.\n\n        Returns:\n          torch.Tensor: Positional encoding with shape 1x(embed_dim)x(embedding_h)x(embedding_w)\n        \"\"\"\n        return self.pe_layer(self.image_embedding_size).unsqueeze(0)\n\n    def _embed_points(\n        self,\n        points: torch.Tensor,\n        labels: torch.Tensor,\n        pad: bool,\n    ) -&gt; torch.Tensor:\n        \"\"\"Embeds point prompts.\"\"\"\n        points = points + 0.5  # Shift to center of pixel\n        if pad:\n            padding_point = torch.zeros((points.shape[0], 1, 2), device=points.device)\n            padding_label = -torch.ones((labels.shape[0], 1), device=labels.device)\n            points = torch.cat([points, padding_point], dim=1)\n            labels = torch.cat([labels, padding_label], dim=1)\n        point_embedding = self.pe_layer.forward_with_coords(points, self.input_image_size)\n        point_embedding[labels == -1] = 0.0\n        point_embedding[labels == -1] += self.not_a_point_embed.weight\n        point_embedding[labels == 0] += self.point_embeddings[0].weight\n        point_embedding[labels == 1] += self.point_embeddings[1].weight\n        return point_embedding\n\n    def _embed_boxes(self, boxes: torch.Tensor) -&gt; torch.Tensor:\n        \"\"\"Embeds box prompts.\"\"\"\n        boxes = boxes + 0.5  # Shift to center of pixel\n        coords = boxes.reshape(-1, 2, 2)\n        corner_embedding = self.pe_layer.forward_with_coords(coords, self.input_image_size)\n        corner_embedding[:, 0, :] += self.point_embeddings[2].weight\n        corner_embedding[:, 1, :] += self.point_embeddings[3].weight\n        return corner_embedding\n\n    def _embed_masks(self, masks: torch.Tensor) -&gt; torch.Tensor:\n        \"\"\"Embeds mask inputs.\"\"\"\n        return self.mask_downscaling(masks)\n\n    def _get_batch_size(\n        self,\n        points: Optional[Tuple[torch.Tensor, torch.Tensor]],\n        boxes: Optional[torch.Tensor],\n        masks: Optional[torch.Tensor],\n    ) -&gt; int:\n        \"\"\"Gets the batch size of the output given the batch size of the input prompts.\"\"\"\n        if points is not None:\n            return points[0].shape[0]\n        elif boxes is not None:\n            return boxes.shape[0]\n        elif masks is not None:\n            return masks.shape[0]\n        else:\n            return 1\n\n    def _get_device(self) -&gt; torch.device:\n        \"\"\"Returns the device of the first point embedding's weight tensor.\"\"\"\n        return self.point_embeddings[0].weight.device\n\n    def forward(\n        self,\n        points: Optional[Tuple[torch.Tensor, torch.Tensor]],\n        boxes: Optional[torch.Tensor],\n        masks: Optional[torch.Tensor],\n    ) -&gt; Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"\n        Embeds different types of prompts, returning both sparse and dense embeddings.\n\n        Args:\n          points (tuple(torch.Tensor, torch.Tensor), None): point coordinates and labels to embed.\n          boxes (torch.Tensor, None): boxes to embed\n          masks (torch.Tensor, None): masks to embed\n\n        Returns:\n          torch.Tensor: sparse embeddings for the points and boxes, with shape BxNx(embed_dim), where N is determined\n            by the number of input points and boxes.\n          torch.Tensor: dense embeddings for the masks, in the shape Bx(embed_dim)x(embed_H)x(embed_W)\n        \"\"\"\n        bs = self._get_batch_size(points, boxes, masks)\n        sparse_embeddings = torch.empty((bs, 0, self.embed_dim), device=self._get_device())\n        if points is not None:\n            coords, labels = points\n            point_embeddings = self._embed_points(coords, labels, pad=(boxes is None))\n            sparse_embeddings = torch.cat([sparse_embeddings, point_embeddings], dim=1)\n        if boxes is not None:\n            box_embeddings = self._embed_boxes(boxes)\n            sparse_embeddings = torch.cat([sparse_embeddings, box_embeddings], dim=1)\n\n        if masks is not None:\n            dense_embeddings = self._embed_masks(masks)\n        else:\n            dense_embeddings = self.no_mask_embed.weight.reshape(1, -1, 1, 1).expand(\n                bs, -1, self.image_embedding_size[0], self.image_embedding_size[1]\n            )\n\n        return sparse_embeddings, dense_embeddings\n</code></pre>"},{"location":"reference/models/sam/modules/encoders/#ultralytics.models.sam.modules.encoders.PromptEncoder.__init__","title":"<code>__init__(embed_dim, image_embedding_size, input_image_size, mask_in_chans, activation=nn.GELU)</code>","text":"<p>Encodes prompts for input to SAM's mask decoder.</p> <p>Parameters:</p> Name Type Description Default <code>embed_dim</code> <code>int</code> <p>The prompts' embedding dimension</p> required <code>image_embedding_size</code> <code>tuple(int, int</code> <p>The spatial size of the image embedding, as (H, W).</p> required <code>input_image_size</code> <code>int</code> <p>The padded size of the image as input to the image encoder, as (H, W).</p> required <code>mask_in_chans</code> <code>int</code> <p>The number of hidden channels used for encoding input masks.</p> required <code>activation</code> <code>Module</code> <p>The activation to use when encoding input masks.</p> <code>GELU</code> Source code in <code>ultralytics/models/sam/modules/encoders.py</code> <pre><code>def __init__(\n    self,\n    embed_dim: int,\n    image_embedding_size: Tuple[int, int],\n    input_image_size: Tuple[int, int],\n    mask_in_chans: int,\n    activation: Type[nn.Module] = nn.GELU,\n) -&gt; None:\n    \"\"\"\n    Encodes prompts for input to SAM's mask decoder.\n\n    Args:\n      embed_dim (int): The prompts' embedding dimension\n      image_embedding_size (tuple(int, int)): The spatial size of the\n        image embedding, as (H, W).\n      input_image_size (int): The padded size of the image as input\n        to the image encoder, as (H, W).\n      mask_in_chans (int): The number of hidden channels used for\n        encoding input masks.\n      activation (nn.Module): The activation to use when encoding\n        input masks.\n    \"\"\"\n    super().__init__()\n    self.embed_dim = embed_dim\n    self.input_image_size = input_image_size\n    self.image_embedding_size = image_embedding_size\n    self.pe_layer = PositionEmbeddingRandom(embed_dim // 2)\n\n    self.num_point_embeddings: int = 4  # pos/neg point + 2 box corners\n    point_embeddings = [nn.Embedding(1, embed_dim) for _ in range(self.num_point_embeddings)]\n    self.point_embeddings = nn.ModuleList(point_embeddings)\n    self.not_a_point_embed = nn.Embedding(1, embed_dim)\n\n    self.mask_input_size = (4 * image_embedding_size[0], 4 * image_embedding_size[1])\n    self.mask_downscaling = nn.Sequential(\n        nn.Conv2d(1, mask_in_chans // 4, kernel_size=2, stride=2),\n        LayerNorm2d(mask_in_chans // 4),\n        activation(),\n        nn.Conv2d(mask_in_chans // 4, mask_in_chans, kernel_size=2, stride=2),\n        LayerNorm2d(mask_in_chans),\n        activation(),\n        nn.Conv2d(mask_in_chans, embed_dim, kernel_size=1),\n    )\n    self.no_mask_embed = nn.Embedding(1, embed_dim)\n</code></pre>"},{"location":"reference/models/sam/modules/encoders/#ultralytics.models.sam.modules.encoders.PromptEncoder.forward","title":"<code>forward(points, boxes, masks)</code>","text":"<p>Embeds different types of prompts, returning both sparse and dense embeddings.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>(tuple(Tensor, Tensor), None)</code> <p>point coordinates and labels to embed.</p> required <code>boxes</code> <code>(Tensor, None)</code> <p>boxes to embed</p> required <code>masks</code> <code>(Tensor, None)</code> <p>masks to embed</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor: sparse embeddings for the points and boxes, with shape BxNx(embed_dim), where N is determined by the number of input points and boxes.</p> <code>Tensor</code> <p>torch.Tensor: dense embeddings for the masks, in the shape Bx(embed_dim)x(embed_H)x(embed_W)</p> Source code in <code>ultralytics/models/sam/modules/encoders.py</code> <pre><code>def forward(\n    self,\n    points: Optional[Tuple[torch.Tensor, torch.Tensor]],\n    boxes: Optional[torch.Tensor],\n    masks: Optional[torch.Tensor],\n) -&gt; Tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Embeds different types of prompts, returning both sparse and dense embeddings.\n\n    Args:\n      points (tuple(torch.Tensor, torch.Tensor), None): point coordinates and labels to embed.\n      boxes (torch.Tensor, None): boxes to embed\n      masks (torch.Tensor, None): masks to embed\n\n    Returns:\n      torch.Tensor: sparse embeddings for the points and boxes, with shape BxNx(embed_dim), where N is determined\n        by the number of input points and boxes.\n      torch.Tensor: dense embeddings for the masks, in the shape Bx(embed_dim)x(embed_H)x(embed_W)\n    \"\"\"\n    bs = self._get_batch_size(points, boxes, masks)\n    sparse_embeddings = torch.empty((bs, 0, self.embed_dim), device=self._get_device())\n    if points is not None:\n        coords, labels = points\n        point_embeddings = self._embed_points(coords, labels, pad=(boxes is None))\n        sparse_embeddings = torch.cat([sparse_embeddings, point_embeddings], dim=1)\n    if boxes is not None:\n        box_embeddings = self._embed_boxes(boxes)\n        sparse_embeddings = torch.cat([sparse_embeddings, box_embeddings], dim=1)\n\n    if masks is not None:\n        dense_embeddings = self._embed_masks(masks)\n    else:\n        dense_embeddings = self.no_mask_embed.weight.reshape(1, -1, 1, 1).expand(\n            bs, -1, self.image_embedding_size[0], self.image_embedding_size[1]\n        )\n\n    return sparse_embeddings, dense_embeddings\n</code></pre>"},{"location":"reference/models/sam/modules/encoders/#ultralytics.models.sam.modules.encoders.PromptEncoder.get_dense_pe","title":"<code>get_dense_pe()</code>","text":"<p>Returns the positional encoding used to encode point prompts, applied to a dense set of points the shape of the image encoding.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor: Positional encoding with shape 1x(embed_dim)x(embedding_h)x(embedding_w)</p> Source code in <code>ultralytics/models/sam/modules/encoders.py</code> <pre><code>def get_dense_pe(self) -&gt; torch.Tensor:\n    \"\"\"\n    Returns the positional encoding used to encode point prompts, applied to a dense set of points the shape of the\n    image encoding.\n\n    Returns:\n      torch.Tensor: Positional encoding with shape 1x(embed_dim)x(embedding_h)x(embedding_w)\n    \"\"\"\n    return self.pe_layer(self.image_embedding_size).unsqueeze(0)\n</code></pre>"},{"location":"reference/models/sam/modules/encoders/#ultralytics.models.sam.modules.encoders.PositionEmbeddingRandom","title":"<code>ultralytics.models.sam.modules.encoders.PositionEmbeddingRandom</code>","text":"<p>             Bases: <code>Module</code></p> <p>Positional encoding using random spatial frequencies.</p> Source code in <code>ultralytics/models/sam/modules/encoders.py</code> <pre><code>class PositionEmbeddingRandom(nn.Module):\n    \"\"\"Positional encoding using random spatial frequencies.\"\"\"\n\n    def __init__(self, num_pos_feats: int = 64, scale: Optional[float] = None) -&gt; None:\n        \"\"\"Initializes a position embedding using random spatial frequencies.\"\"\"\n        super().__init__()\n        if scale is None or scale &lt;= 0.0:\n            scale = 1.0\n        self.register_buffer(\"positional_encoding_gaussian_matrix\", scale * torch.randn((2, num_pos_feats)))\n\n        # Set non-deterministic for forward() error 'cumsum_cuda_kernel does not have a deterministic implementation'\n        torch.use_deterministic_algorithms(False)\n        torch.backends.cudnn.deterministic = False\n\n    def _pe_encoding(self, coords: torch.Tensor) -&gt; torch.Tensor:\n        \"\"\"Positionally encode points that are normalized to [0,1].\"\"\"\n        # Assuming coords are in [0, 1]^2 square and have d_1 x ... x d_n x 2 shape\n        coords = 2 * coords - 1\n        coords = coords @ self.positional_encoding_gaussian_matrix\n        coords = 2 * np.pi * coords\n        # Outputs d_1 x ... x d_n x C shape\n        return torch.cat([torch.sin(coords), torch.cos(coords)], dim=-1)\n\n    def forward(self, size: Tuple[int, int]) -&gt; torch.Tensor:\n        \"\"\"Generate positional encoding for a grid of the specified size.\"\"\"\n        h, w = size\n        device: Any = self.positional_encoding_gaussian_matrix.device\n        grid = torch.ones((h, w), device=device, dtype=torch.float32)\n        y_embed = grid.cumsum(dim=0) - 0.5\n        x_embed = grid.cumsum(dim=1) - 0.5\n        y_embed = y_embed / h\n        x_embed = x_embed / w\n\n        pe = self._pe_encoding(torch.stack([x_embed, y_embed], dim=-1))\n        return pe.permute(2, 0, 1)  # C x H x W\n\n    def forward_with_coords(self, coords_input: torch.Tensor, image_size: Tuple[int, int]) -&gt; torch.Tensor:\n        \"\"\"Positionally encode points that are not normalized to [0,1].\"\"\"\n        coords = coords_input.clone()\n        coords[:, :, 0] = coords[:, :, 0] / image_size[1]\n        coords[:, :, 1] = coords[:, :, 1] / image_size[0]\n        return self._pe_encoding(coords.to(torch.float))  # B x N x C\n</code></pre>"},{"location":"reference/models/sam/modules/encoders/#ultralytics.models.sam.modules.encoders.PositionEmbeddingRandom.__init__","title":"<code>__init__(num_pos_feats=64, scale=None)</code>","text":"<p>Initializes a position embedding using random spatial frequencies.</p> Source code in <code>ultralytics/models/sam/modules/encoders.py</code> <pre><code>def __init__(self, num_pos_feats: int = 64, scale: Optional[float] = None) -&gt; None:\n    \"\"\"Initializes a position embedding using random spatial frequencies.\"\"\"\n    super().__init__()\n    if scale is None or scale &lt;= 0.0:\n        scale = 1.0\n    self.register_buffer(\"positional_encoding_gaussian_matrix\", scale * torch.randn((2, num_pos_feats)))\n\n    # Set non-deterministic for forward() error 'cumsum_cuda_kernel does not have a deterministic implementation'\n    torch.use_deterministic_algorithms(False)\n    torch.backends.cudnn.deterministic = False\n</code></pre>"},{"location":"reference/models/sam/modules/encoders/#ultralytics.models.sam.modules.encoders.PositionEmbeddingRandom.forward","title":"<code>forward(size)</code>","text":"<p>Generate positional encoding for a grid of the specified size.</p> Source code in <code>ultralytics/models/sam/modules/encoders.py</code> <pre><code>def forward(self, size: Tuple[int, int]) -&gt; torch.Tensor:\n    \"\"\"Generate positional encoding for a grid of the specified size.\"\"\"\n    h, w = size\n    device: Any = self.positional_encoding_gaussian_matrix.device\n    grid = torch.ones((h, w), device=device, dtype=torch.float32)\n    y_embed = grid.cumsum(dim=0) - 0.5\n    x_embed = grid.cumsum(dim=1) - 0.5\n    y_embed = y_embed / h\n    x_embed = x_embed / w\n\n    pe = self._pe_encoding(torch.stack([x_embed, y_embed], dim=-1))\n    return pe.permute(2, 0, 1)  # C x H x W\n</code></pre>"},{"location":"reference/models/sam/modules/encoders/#ultralytics.models.sam.modules.encoders.PositionEmbeddingRandom.forward_with_coords","title":"<code>forward_with_coords(coords_input, image_size)</code>","text":"<p>Positionally encode points that are not normalized to [0,1].</p> Source code in <code>ultralytics/models/sam/modules/encoders.py</code> <pre><code>def forward_with_coords(self, coords_input: torch.Tensor, image_size: Tuple[int, int]) -&gt; torch.Tensor:\n    \"\"\"Positionally encode points that are not normalized to [0,1].\"\"\"\n    coords = coords_input.clone()\n    coords[:, :, 0] = coords[:, :, 0] / image_size[1]\n    coords[:, :, 1] = coords[:, :, 1] / image_size[0]\n    return self._pe_encoding(coords.to(torch.float))  # B x N x C\n</code></pre>"},{"location":"reference/models/sam/modules/encoders/#ultralytics.models.sam.modules.encoders.Block","title":"<code>ultralytics.models.sam.modules.encoders.Block</code>","text":"<p>             Bases: <code>Module</code></p> <p>Transformer blocks with support of window attention and residual propagation blocks.</p> Source code in <code>ultralytics/models/sam/modules/encoders.py</code> <pre><code>class Block(nn.Module):\n    \"\"\"Transformer blocks with support of window attention and residual propagation blocks.\"\"\"\n\n    def __init__(\n        self,\n        dim: int,\n        num_heads: int,\n        mlp_ratio: float = 4.0,\n        qkv_bias: bool = True,\n        norm_layer: Type[nn.Module] = nn.LayerNorm,\n        act_layer: Type[nn.Module] = nn.GELU,\n        use_rel_pos: bool = False,\n        rel_pos_zero_init: bool = True,\n        window_size: int = 0,\n        input_size: Optional[Tuple[int, int]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Args:\n            dim (int): Number of input channels.\n            num_heads (int): Number of attention heads in each ViT block.\n            mlp_ratio (float): Ratio of mlp hidden dim to embedding dim.\n            qkv_bias (bool): If True, add a learnable bias to query, key, value.\n            norm_layer (nn.Module): Normalization layer.\n            act_layer (nn.Module): Activation layer.\n            use_rel_pos (bool): If True, add relative positional embeddings to the attention map.\n            rel_pos_zero_init (bool): If True, zero initialize relative positional parameters.\n            window_size (int): Window size for window attention blocks. If it equals 0, then\n                use global attention.\n            input_size (tuple(int, int), None): Input resolution for calculating the relative\n                positional parameter size.\n        \"\"\"\n        super().__init__()\n        self.norm1 = norm_layer(dim)\n        self.attn = Attention(\n            dim,\n            num_heads=num_heads,\n            qkv_bias=qkv_bias,\n            use_rel_pos=use_rel_pos,\n            rel_pos_zero_init=rel_pos_zero_init,\n            input_size=input_size if window_size == 0 else (window_size, window_size),\n        )\n\n        self.norm2 = norm_layer(dim)\n        self.mlp = MLPBlock(embedding_dim=dim, mlp_dim=int(dim * mlp_ratio), act=act_layer)\n\n        self.window_size = window_size\n\n    def forward(self, x: torch.Tensor) -&gt; torch.Tensor:\n        \"\"\"Executes a forward pass through the transformer block with window attention and non-overlapping windows.\"\"\"\n        shortcut = x\n        x = self.norm1(x)\n        # Window partition\n        if self.window_size &gt; 0:\n            H, W = x.shape[1], x.shape[2]\n            x, pad_hw = window_partition(x, self.window_size)\n\n        x = self.attn(x)\n        # Reverse window partition\n        if self.window_size &gt; 0:\n            x = window_unpartition(x, self.window_size, pad_hw, (H, W))\n\n        x = shortcut + x\n        return x + self.mlp(self.norm2(x))\n</code></pre>"},{"location":"reference/models/sam/modules/encoders/#ultralytics.models.sam.modules.encoders.Block.__init__","title":"<code>__init__(dim, num_heads, mlp_ratio=4.0, qkv_bias=True, norm_layer=nn.LayerNorm, act_layer=nn.GELU, use_rel_pos=False, rel_pos_zero_init=True, window_size=0, input_size=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>Number of input channels.</p> required <code>num_heads</code> <code>int</code> <p>Number of attention heads in each ViT block.</p> required <code>mlp_ratio</code> <code>float</code> <p>Ratio of mlp hidden dim to embedding dim.</p> <code>4.0</code> <code>qkv_bias</code> <code>bool</code> <p>If True, add a learnable bias to query, key, value.</p> <code>True</code> <code>norm_layer</code> <code>Module</code> <p>Normalization layer.</p> <code>LayerNorm</code> <code>act_layer</code> <code>Module</code> <p>Activation layer.</p> <code>GELU</code> <code>use_rel_pos</code> <code>bool</code> <p>If True, add relative positional embeddings to the attention map.</p> <code>False</code> <code>rel_pos_zero_init</code> <code>bool</code> <p>If True, zero initialize relative positional parameters.</p> <code>True</code> <code>window_size</code> <code>int</code> <p>Window size for window attention blocks. If it equals 0, then use global attention.</p> <code>0</code> <code>input_size</code> <code>(tuple(int, int), None)</code> <p>Input resolution for calculating the relative positional parameter size.</p> <code>None</code> Source code in <code>ultralytics/models/sam/modules/encoders.py</code> <pre><code>def __init__(\n    self,\n    dim: int,\n    num_heads: int,\n    mlp_ratio: float = 4.0,\n    qkv_bias: bool = True,\n    norm_layer: Type[nn.Module] = nn.LayerNorm,\n    act_layer: Type[nn.Module] = nn.GELU,\n    use_rel_pos: bool = False,\n    rel_pos_zero_init: bool = True,\n    window_size: int = 0,\n    input_size: Optional[Tuple[int, int]] = None,\n) -&gt; None:\n    \"\"\"\n    Args:\n        dim (int): Number of input channels.\n        num_heads (int): Number of attention heads in each ViT block.\n        mlp_ratio (float): Ratio of mlp hidden dim to embedding dim.\n        qkv_bias (bool): If True, add a learnable bias to query, key, value.\n        norm_layer (nn.Module): Normalization layer.\n        act_layer (nn.Module): Activation layer.\n        use_rel_pos (bool): If True, add relative positional embeddings to the attention map.\n        rel_pos_zero_init (bool): If True, zero initialize relative positional parameters.\n        window_size (int): Window size for window attention blocks. If it equals 0, then\n            use global attention.\n        input_size (tuple(int, int), None): Input resolution for calculating the relative\n            positional parameter size.\n    \"\"\"\n    super().__init__()\n    self.norm1 = norm_layer(dim)\n    self.attn = Attention(\n        dim,\n        num_heads=num_heads,\n        qkv_bias=qkv_bias,\n        use_rel_pos=use_rel_pos,\n        rel_pos_zero_init=rel_pos_zero_init,\n        input_size=input_size if window_size == 0 else (window_size, window_size),\n    )\n\n    self.norm2 = norm_layer(dim)\n    self.mlp = MLPBlock(embedding_dim=dim, mlp_dim=int(dim * mlp_ratio), act=act_layer)\n\n    self.window_size = window_size\n</code></pre>"},{"location":"reference/models/sam/modules/encoders/#ultralytics.models.sam.modules.encoders.Block.forward","title":"<code>forward(x)</code>","text":"<p>Executes a forward pass through the transformer block with window attention and non-overlapping windows.</p> Source code in <code>ultralytics/models/sam/modules/encoders.py</code> <pre><code>def forward(self, x: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"Executes a forward pass through the transformer block with window attention and non-overlapping windows.\"\"\"\n    shortcut = x\n    x = self.norm1(x)\n    # Window partition\n    if self.window_size &gt; 0:\n        H, W = x.shape[1], x.shape[2]\n        x, pad_hw = window_partition(x, self.window_size)\n\n    x = self.attn(x)\n    # Reverse window partition\n    if self.window_size &gt; 0:\n        x = window_unpartition(x, self.window_size, pad_hw, (H, W))\n\n    x = shortcut + x\n    return x + self.mlp(self.norm2(x))\n</code></pre>"},{"location":"reference/models/sam/modules/encoders/#ultralytics.models.sam.modules.encoders.Attention","title":"<code>ultralytics.models.sam.modules.encoders.Attention</code>","text":"<p>             Bases: <code>Module</code></p> <p>Multi-head Attention block with relative position embeddings.</p> Source code in <code>ultralytics/models/sam/modules/encoders.py</code> <pre><code>class Attention(nn.Module):\n    \"\"\"Multi-head Attention block with relative position embeddings.\"\"\"\n\n    def __init__(\n        self,\n        dim: int,\n        num_heads: int = 8,\n        qkv_bias: bool = True,\n        use_rel_pos: bool = False,\n        rel_pos_zero_init: bool = True,\n        input_size: Optional[Tuple[int, int]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize Attention module.\n\n        Args:\n            dim (int): Number of input channels.\n            num_heads (int): Number of attention heads.\n            qkv_bias (bool):  If True, add a learnable bias to query, key, value.\n            rel_pos_zero_init (bool): If True, zero initialize relative positional parameters.\n            input_size (tuple(int, int), None): Input resolution for calculating the relative\n                positional parameter size.\n        \"\"\"\n        super().__init__()\n        self.num_heads = num_heads\n        head_dim = dim // num_heads\n        self.scale = head_dim**-0.5\n\n        self.qkv = nn.Linear(dim, dim * 3, bias=qkv_bias)\n        self.proj = nn.Linear(dim, dim)\n\n        self.use_rel_pos = use_rel_pos\n        if self.use_rel_pos:\n            assert input_size is not None, \"Input size must be provided if using relative positional encoding.\"\n            # Initialize relative positional embeddings\n            self.rel_pos_h = nn.Parameter(torch.zeros(2 * input_size[0] - 1, head_dim))\n            self.rel_pos_w = nn.Parameter(torch.zeros(2 * input_size[1] - 1, head_dim))\n\n    def forward(self, x: torch.Tensor) -&gt; torch.Tensor:\n        \"\"\"Applies the forward operation including attention, normalization, MLP, and indexing within window limits.\"\"\"\n        B, H, W, _ = x.shape\n        # qkv with shape (3, B, nHead, H * W, C)\n        qkv = self.qkv(x).reshape(B, H * W, 3, self.num_heads, -1).permute(2, 0, 3, 1, 4)\n        # q, k, v with shape (B * nHead, H * W, C)\n        q, k, v = qkv.reshape(3, B * self.num_heads, H * W, -1).unbind(0)\n\n        attn = (q * self.scale) @ k.transpose(-2, -1)\n\n        if self.use_rel_pos:\n            attn = add_decomposed_rel_pos(attn, q, self.rel_pos_h, self.rel_pos_w, (H, W), (H, W))\n\n        attn = attn.softmax(dim=-1)\n        x = (attn @ v).view(B, self.num_heads, H, W, -1).permute(0, 2, 3, 1, 4).reshape(B, H, W, -1)\n        return self.proj(x)\n</code></pre>"},{"location":"reference/models/sam/modules/encoders/#ultralytics.models.sam.modules.encoders.Attention.__init__","title":"<code>__init__(dim, num_heads=8, qkv_bias=True, use_rel_pos=False, rel_pos_zero_init=True, input_size=None)</code>","text":"<p>Initialize Attention module.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>Number of input channels.</p> required <code>num_heads</code> <code>int</code> <p>Number of attention heads.</p> <code>8</code> <code>qkv_bias</code> <code>bool</code> <p>If True, add a learnable bias to query, key, value.</p> <code>True</code> <code>rel_pos_zero_init</code> <code>bool</code> <p>If True, zero initialize relative positional parameters.</p> <code>True</code> <code>input_size</code> <code>(tuple(int, int), None)</code> <p>Input resolution for calculating the relative positional parameter size.</p> <code>None</code> Source code in <code>ultralytics/models/sam/modules/encoders.py</code> <pre><code>def __init__(\n    self,\n    dim: int,\n    num_heads: int = 8,\n    qkv_bias: bool = True,\n    use_rel_pos: bool = False,\n    rel_pos_zero_init: bool = True,\n    input_size: Optional[Tuple[int, int]] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize Attention module.\n\n    Args:\n        dim (int): Number of input channels.\n        num_heads (int): Number of attention heads.\n        qkv_bias (bool):  If True, add a learnable bias to query, key, value.\n        rel_pos_zero_init (bool): If True, zero initialize relative positional parameters.\n        input_size (tuple(int, int), None): Input resolution for calculating the relative\n            positional parameter size.\n    \"\"\"\n    super().__init__()\n    self.num_heads = num_heads\n    head_dim = dim // num_heads\n    self.scale = head_dim**-0.5\n\n    self.qkv = nn.Linear(dim, dim * 3, bias=qkv_bias)\n    self.proj = nn.Linear(dim, dim)\n\n    self.use_rel_pos = use_rel_pos\n    if self.use_rel_pos:\n        assert input_size is not None, \"Input size must be provided if using relative positional encoding.\"\n        # Initialize relative positional embeddings\n        self.rel_pos_h = nn.Parameter(torch.zeros(2 * input_size[0] - 1, head_dim))\n        self.rel_pos_w = nn.Parameter(torch.zeros(2 * input_size[1] - 1, head_dim))\n</code></pre>"},{"location":"reference/models/sam/modules/encoders/#ultralytics.models.sam.modules.encoders.Attention.forward","title":"<code>forward(x)</code>","text":"<p>Applies the forward operation including attention, normalization, MLP, and indexing within window limits.</p> Source code in <code>ultralytics/models/sam/modules/encoders.py</code> <pre><code>def forward(self, x: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"Applies the forward operation including attention, normalization, MLP, and indexing within window limits.\"\"\"\n    B, H, W, _ = x.shape\n    # qkv with shape (3, B, nHead, H * W, C)\n    qkv = self.qkv(x).reshape(B, H * W, 3, self.num_heads, -1).permute(2, 0, 3, 1, 4)\n    # q, k, v with shape (B * nHead, H * W, C)\n    q, k, v = qkv.reshape(3, B * self.num_heads, H * W, -1).unbind(0)\n\n    attn = (q * self.scale) @ k.transpose(-2, -1)\n\n    if self.use_rel_pos:\n        attn = add_decomposed_rel_pos(attn, q, self.rel_pos_h, self.rel_pos_w, (H, W), (H, W))\n\n    attn = attn.softmax(dim=-1)\n    x = (attn @ v).view(B, self.num_heads, H, W, -1).permute(0, 2, 3, 1, 4).reshape(B, H, W, -1)\n    return self.proj(x)\n</code></pre>"},{"location":"reference/models/sam/modules/encoders/#ultralytics.models.sam.modules.encoders.PatchEmbed","title":"<code>ultralytics.models.sam.modules.encoders.PatchEmbed</code>","text":"<p>             Bases: <code>Module</code></p> <p>Image to Patch Embedding.</p> Source code in <code>ultralytics/models/sam/modules/encoders.py</code> <pre><code>class PatchEmbed(nn.Module):\n    \"\"\"Image to Patch Embedding.\"\"\"\n\n    def __init__(\n        self,\n        kernel_size: Tuple[int, int] = (16, 16),\n        stride: Tuple[int, int] = (16, 16),\n        padding: Tuple[int, int] = (0, 0),\n        in_chans: int = 3,\n        embed_dim: int = 768,\n    ) -&gt; None:\n        \"\"\"\n        Initialize PatchEmbed module.\n\n        Args:\n            kernel_size (Tuple): kernel size of the projection layer.\n            stride (Tuple): stride of the projection layer.\n            padding (Tuple): padding size of the projection layer.\n            in_chans (int): Number of input image channels.\n            embed_dim (int): Patch embedding dimension.\n        \"\"\"\n        super().__init__()\n\n        self.proj = nn.Conv2d(in_chans, embed_dim, kernel_size=kernel_size, stride=stride, padding=padding)\n\n    def forward(self, x: torch.Tensor) -&gt; torch.Tensor:\n        \"\"\"Computes patch embedding by applying convolution and transposing resulting tensor.\"\"\"\n        return self.proj(x).permute(0, 2, 3, 1)  # B C H W -&gt; B H W C\n</code></pre>"},{"location":"reference/models/sam/modules/encoders/#ultralytics.models.sam.modules.encoders.PatchEmbed.__init__","title":"<code>__init__(kernel_size=(16, 16), stride=(16, 16), padding=(0, 0), in_chans=3, embed_dim=768)</code>","text":"<p>Initialize PatchEmbed module.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>Tuple</code> <p>kernel size of the projection layer.</p> <code>(16, 16)</code> <code>stride</code> <code>Tuple</code> <p>stride of the projection layer.</p> <code>(16, 16)</code> <code>padding</code> <code>Tuple</code> <p>padding size of the projection layer.</p> <code>(0, 0)</code> <code>in_chans</code> <code>int</code> <p>Number of input image channels.</p> <code>3</code> <code>embed_dim</code> <code>int</code> <p>Patch embedding dimension.</p> <code>768</code> Source code in <code>ultralytics/models/sam/modules/encoders.py</code> <pre><code>def __init__(\n    self,\n    kernel_size: Tuple[int, int] = (16, 16),\n    stride: Tuple[int, int] = (16, 16),\n    padding: Tuple[int, int] = (0, 0),\n    in_chans: int = 3,\n    embed_dim: int = 768,\n) -&gt; None:\n    \"\"\"\n    Initialize PatchEmbed module.\n\n    Args:\n        kernel_size (Tuple): kernel size of the projection layer.\n        stride (Tuple): stride of the projection layer.\n        padding (Tuple): padding size of the projection layer.\n        in_chans (int): Number of input image channels.\n        embed_dim (int): Patch embedding dimension.\n    \"\"\"\n    super().__init__()\n\n    self.proj = nn.Conv2d(in_chans, embed_dim, kernel_size=kernel_size, stride=stride, padding=padding)\n</code></pre>"},{"location":"reference/models/sam/modules/encoders/#ultralytics.models.sam.modules.encoders.PatchEmbed.forward","title":"<code>forward(x)</code>","text":"<p>Computes patch embedding by applying convolution and transposing resulting tensor.</p> Source code in <code>ultralytics/models/sam/modules/encoders.py</code> <pre><code>def forward(self, x: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"Computes patch embedding by applying convolution and transposing resulting tensor.\"\"\"\n    return self.proj(x).permute(0, 2, 3, 1)  # B C H W -&gt; B H W C\n</code></pre>"},{"location":"reference/models/sam/modules/encoders/#ultralytics.models.sam.modules.encoders.window_partition","title":"<code>ultralytics.models.sam.modules.encoders.window_partition(x, window_size)</code>","text":"<p>Partition into non-overlapping windows with padding if needed. Args:     x (tensor): input tokens with [B, H, W, C].     window_size (int): window size.</p> <p>Returns:</p> Name Type Description <code>windows</code> <code>Tensor</code> <p>windows after partition with [B * num_windows, window_size, window_size, C].</p> <code>(Hp, Wp)</code> <p>padded height and width before partition</p> Source code in <code>ultralytics/models/sam/modules/encoders.py</code> <pre><code>def window_partition(x: torch.Tensor, window_size: int) -&gt; Tuple[torch.Tensor, Tuple[int, int]]:\n    \"\"\"\n    Partition into non-overlapping windows with padding if needed.\n    Args:\n        x (tensor): input tokens with [B, H, W, C].\n        window_size (int): window size.\n\n    Returns:\n        windows: windows after partition with [B * num_windows, window_size, window_size, C].\n        (Hp, Wp): padded height and width before partition\n    \"\"\"\n    B, H, W, C = x.shape\n\n    pad_h = (window_size - H % window_size) % window_size\n    pad_w = (window_size - W % window_size) % window_size\n    if pad_h &gt; 0 or pad_w &gt; 0:\n        x = F.pad(x, (0, 0, 0, pad_w, 0, pad_h))\n    Hp, Wp = H + pad_h, W + pad_w\n\n    x = x.view(B, Hp // window_size, window_size, Wp // window_size, window_size, C)\n    windows = x.permute(0, 1, 3, 2, 4, 5).contiguous().view(-1, window_size, window_size, C)\n    return windows, (Hp, Wp)\n</code></pre>"},{"location":"reference/models/sam/modules/encoders/#ultralytics.models.sam.modules.encoders.window_unpartition","title":"<code>ultralytics.models.sam.modules.encoders.window_unpartition(windows, window_size, pad_hw, hw)</code>","text":"<p>Window unpartition into original sequences and removing padding.</p> <p>Parameters:</p> Name Type Description Default <code>windows</code> <code>tensor</code> <p>input tokens with [B * num_windows, window_size, window_size, C].</p> required <code>window_size</code> <code>int</code> <p>window size.</p> required <code>pad_hw</code> <code>Tuple</code> <p>padded height and width (Hp, Wp).</p> required <code>hw</code> <code>Tuple</code> <p>original height and width (H, W) before padding.</p> required <p>Returns:</p> Name Type Description <code>x</code> <code>Tensor</code> <p>unpartitioned sequences with [B, H, W, C].</p> Source code in <code>ultralytics/models/sam/modules/encoders.py</code> <pre><code>def window_unpartition(\n    windows: torch.Tensor, window_size: int, pad_hw: Tuple[int, int], hw: Tuple[int, int]\n) -&gt; torch.Tensor:\n    \"\"\"\n    Window unpartition into original sequences and removing padding.\n\n    Args:\n        windows (tensor): input tokens with [B * num_windows, window_size, window_size, C].\n        window_size (int): window size.\n        pad_hw (Tuple): padded height and width (Hp, Wp).\n        hw (Tuple): original height and width (H, W) before padding.\n\n    Returns:\n        x: unpartitioned sequences with [B, H, W, C].\n    \"\"\"\n    Hp, Wp = pad_hw\n    H, W = hw\n    B = windows.shape[0] // (Hp * Wp // window_size // window_size)\n    x = windows.view(B, Hp // window_size, Wp // window_size, window_size, window_size, -1)\n    x = x.permute(0, 1, 3, 2, 4, 5).contiguous().view(B, Hp, Wp, -1)\n\n    if Hp &gt; H or Wp &gt; W:\n        x = x[:, :H, :W, :].contiguous()\n    return x\n</code></pre>"},{"location":"reference/models/sam/modules/encoders/#ultralytics.models.sam.modules.encoders.get_rel_pos","title":"<code>ultralytics.models.sam.modules.encoders.get_rel_pos(q_size, k_size, rel_pos)</code>","text":"<p>Get relative positional embeddings according to the relative positions of query and key sizes.</p> <p>Parameters:</p> Name Type Description Default <code>q_size</code> <code>int</code> <p>size of query q.</p> required <code>k_size</code> <code>int</code> <p>size of key k.</p> required <code>rel_pos</code> <code>Tensor</code> <p>relative position embeddings (L, C).</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>Extracted positional embeddings according to relative positions.</p> Source code in <code>ultralytics/models/sam/modules/encoders.py</code> <pre><code>def get_rel_pos(q_size: int, k_size: int, rel_pos: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"\n    Get relative positional embeddings according to the relative positions of query and key sizes.\n\n    Args:\n        q_size (int): size of query q.\n        k_size (int): size of key k.\n        rel_pos (Tensor): relative position embeddings (L, C).\n\n    Returns:\n        Extracted positional embeddings according to relative positions.\n    \"\"\"\n    max_rel_dist = int(2 * max(q_size, k_size) - 1)\n    # Interpolate rel pos if needed.\n    if rel_pos.shape[0] != max_rel_dist:\n        # Interpolate rel pos.\n        rel_pos_resized = F.interpolate(\n            rel_pos.reshape(1, rel_pos.shape[0], -1).permute(0, 2, 1),\n            size=max_rel_dist,\n            mode=\"linear\",\n        )\n        rel_pos_resized = rel_pos_resized.reshape(-1, max_rel_dist).permute(1, 0)\n    else:\n        rel_pos_resized = rel_pos\n\n    # Scale the coords with short length if shapes for q and k are different.\n    q_coords = torch.arange(q_size)[:, None] * max(k_size / q_size, 1.0)\n    k_coords = torch.arange(k_size)[None, :] * max(q_size / k_size, 1.0)\n    relative_coords = (q_coords - k_coords) + (k_size - 1) * max(q_size / k_size, 1.0)\n\n    return rel_pos_resized[relative_coords.long()]\n</code></pre>"},{"location":"reference/models/sam/modules/encoders/#ultralytics.models.sam.modules.encoders.add_decomposed_rel_pos","title":"<code>ultralytics.models.sam.modules.encoders.add_decomposed_rel_pos(attn, q, rel_pos_h, rel_pos_w, q_size, k_size)</code>","text":"<p>Calculate decomposed Relative Positional Embeddings from mvitv2 paper at https://github.com/facebookresearch/mvit/blob/main/mvit/models/attention.py.</p> <p>Parameters:</p> Name Type Description Default <code>attn</code> <code>Tensor</code> <p>attention map.</p> required <code>q</code> <code>Tensor</code> <p>query q in the attention layer with shape (B, q_h * q_w, C).</p> required <code>rel_pos_h</code> <code>Tensor</code> <p>relative position embeddings (Lh, C) for height axis.</p> required <code>rel_pos_w</code> <code>Tensor</code> <p>relative position embeddings (Lw, C) for width axis.</p> required <code>q_size</code> <code>Tuple</code> <p>spatial sequence size of query q with (q_h, q_w).</p> required <code>k_size</code> <code>Tuple</code> <p>spatial sequence size of key k with (k_h, k_w).</p> required <p>Returns:</p> Name Type Description <code>attn</code> <code>Tensor</code> <p>attention map with added relative positional embeddings.</p> Source code in <code>ultralytics/models/sam/modules/encoders.py</code> <pre><code>def add_decomposed_rel_pos(\n    attn: torch.Tensor,\n    q: torch.Tensor,\n    rel_pos_h: torch.Tensor,\n    rel_pos_w: torch.Tensor,\n    q_size: Tuple[int, int],\n    k_size: Tuple[int, int],\n) -&gt; torch.Tensor:\n    \"\"\"\n    Calculate decomposed Relative Positional Embeddings from mvitv2 paper at\n    https://github.com/facebookresearch/mvit/blob/main/mvit/models/attention.py.\n\n    Args:\n        attn (Tensor): attention map.\n        q (Tensor): query q in the attention layer with shape (B, q_h * q_w, C).\n        rel_pos_h (Tensor): relative position embeddings (Lh, C) for height axis.\n        rel_pos_w (Tensor): relative position embeddings (Lw, C) for width axis.\n        q_size (Tuple): spatial sequence size of query q with (q_h, q_w).\n        k_size (Tuple): spatial sequence size of key k with (k_h, k_w).\n\n    Returns:\n        attn (Tensor): attention map with added relative positional embeddings.\n    \"\"\"\n    q_h, q_w = q_size\n    k_h, k_w = k_size\n    Rh = get_rel_pos(q_h, k_h, rel_pos_h)\n    Rw = get_rel_pos(q_w, k_w, rel_pos_w)\n\n    B, _, dim = q.shape\n    r_q = q.reshape(B, q_h, q_w, dim)\n    rel_h = torch.einsum(\"bhwc,hkc-&gt;bhwk\", r_q, Rh)\n    rel_w = torch.einsum(\"bhwc,wkc-&gt;bhwk\", r_q, Rw)\n\n    attn = (attn.view(B, q_h, q_w, k_h, k_w) + rel_h[:, :, :, :, None] + rel_w[:, :, :, None, :]).view(\n        B, q_h * q_w, k_h * k_w\n    )\n\n    return attn\n</code></pre>"},{"location":"reference/models/sam/modules/sam/","title":"Reference for <code>ultralytics/models/sam/modules/sam.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/sam/modules/sam.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/sam/modules/sam/#ultralytics.models.sam.modules.sam.Sam","title":"<code>ultralytics.models.sam.modules.sam.Sam</code>","text":"<p>             Bases: <code>Module</code></p> <p>Sam (Segment Anything Model) is designed for object segmentation tasks. It uses image encoders to generate image embeddings, and prompt encoders to encode various types of input prompts. These embeddings are then used by the mask decoder to predict object masks.</p> <p>Attributes:</p> Name Type Description <code>mask_threshold</code> <code>float</code> <p>Threshold value for mask prediction.</p> <code>image_format</code> <code>str</code> <p>Format of the input image, default is 'RGB'.</p> <code>image_encoder</code> <code>ImageEncoderViT</code> <p>The backbone used to encode the image into embeddings.</p> <code>prompt_encoder</code> <code>PromptEncoder</code> <p>Encodes various types of input prompts.</p> <code>mask_decoder</code> <code>MaskDecoder</code> <p>Predicts object masks from the image and prompt embeddings.</p> <code>pixel_mean</code> <code>List[float]</code> <p>Mean pixel values for image normalization.</p> <code>pixel_std</code> <code>List[float]</code> <p>Standard deviation values for image normalization.</p> Source code in <code>ultralytics/models/sam/modules/sam.py</code> <pre><code>class Sam(nn.Module):\n    \"\"\"\n    Sam (Segment Anything Model) is designed for object segmentation tasks. It uses image encoders to generate image\n    embeddings, and prompt encoders to encode various types of input prompts. These embeddings are then used by the mask\n    decoder to predict object masks.\n\n    Attributes:\n        mask_threshold (float): Threshold value for mask prediction.\n        image_format (str): Format of the input image, default is 'RGB'.\n        image_encoder (ImageEncoderViT): The backbone used to encode the image into embeddings.\n        prompt_encoder (PromptEncoder): Encodes various types of input prompts.\n        mask_decoder (MaskDecoder): Predicts object masks from the image and prompt embeddings.\n        pixel_mean (List[float]): Mean pixel values for image normalization.\n        pixel_std (List[float]): Standard deviation values for image normalization.\n    \"\"\"\n\n    mask_threshold: float = 0.0\n    image_format: str = \"RGB\"\n\n    def __init__(\n        self,\n        image_encoder: ImageEncoderViT,\n        prompt_encoder: PromptEncoder,\n        mask_decoder: MaskDecoder,\n        pixel_mean: List[float] = (123.675, 116.28, 103.53),\n        pixel_std: List[float] = (58.395, 57.12, 57.375),\n    ) -&gt; None:\n        \"\"\"\n        Initialize the Sam class to predict object masks from an image and input prompts.\n\n        Note:\n            All forward() operations moved to SAMPredictor.\n\n        Args:\n            image_encoder (ImageEncoderViT): The backbone used to encode the image into image embeddings.\n            prompt_encoder (PromptEncoder): Encodes various types of input prompts.\n            mask_decoder (MaskDecoder): Predicts masks from the image embeddings and encoded prompts.\n            pixel_mean (List[float], optional): Mean values for normalizing pixels in the input image. Defaults to\n                (123.675, 116.28, 103.53).\n            pixel_std (List[float], optional): Std values for normalizing pixels in the input image. Defaults to\n                (58.395, 57.12, 57.375).\n        \"\"\"\n        super().__init__()\n        self.image_encoder = image_encoder\n        self.prompt_encoder = prompt_encoder\n        self.mask_decoder = mask_decoder\n        self.register_buffer(\"pixel_mean\", torch.Tensor(pixel_mean).view(-1, 1, 1), False)\n        self.register_buffer(\"pixel_std\", torch.Tensor(pixel_std).view(-1, 1, 1), False)\n</code></pre>"},{"location":"reference/models/sam/modules/sam/#ultralytics.models.sam.modules.sam.Sam.__init__","title":"<code>__init__(image_encoder, prompt_encoder, mask_decoder, pixel_mean=(123.675, 116.28, 103.53), pixel_std=(58.395, 57.12, 57.375))</code>","text":"<p>Initialize the Sam class to predict object masks from an image and input prompts.</p> Note <p>All forward() operations moved to SAMPredictor.</p> <p>Parameters:</p> Name Type Description Default <code>image_encoder</code> <code>ImageEncoderViT</code> <p>The backbone used to encode the image into image embeddings.</p> required <code>prompt_encoder</code> <code>PromptEncoder</code> <p>Encodes various types of input prompts.</p> required <code>mask_decoder</code> <code>MaskDecoder</code> <p>Predicts masks from the image embeddings and encoded prompts.</p> required <code>pixel_mean</code> <code>List[float]</code> <p>Mean values for normalizing pixels in the input image. Defaults to (123.675, 116.28, 103.53).</p> <code>(123.675, 116.28, 103.53)</code> <code>pixel_std</code> <code>List[float]</code> <p>Std values for normalizing pixels in the input image. Defaults to (58.395, 57.12, 57.375).</p> <code>(58.395, 57.12, 57.375)</code> Source code in <code>ultralytics/models/sam/modules/sam.py</code> <pre><code>def __init__(\n    self,\n    image_encoder: ImageEncoderViT,\n    prompt_encoder: PromptEncoder,\n    mask_decoder: MaskDecoder,\n    pixel_mean: List[float] = (123.675, 116.28, 103.53),\n    pixel_std: List[float] = (58.395, 57.12, 57.375),\n) -&gt; None:\n    \"\"\"\n    Initialize the Sam class to predict object masks from an image and input prompts.\n\n    Note:\n        All forward() operations moved to SAMPredictor.\n\n    Args:\n        image_encoder (ImageEncoderViT): The backbone used to encode the image into image embeddings.\n        prompt_encoder (PromptEncoder): Encodes various types of input prompts.\n        mask_decoder (MaskDecoder): Predicts masks from the image embeddings and encoded prompts.\n        pixel_mean (List[float], optional): Mean values for normalizing pixels in the input image. Defaults to\n            (123.675, 116.28, 103.53).\n        pixel_std (List[float], optional): Std values for normalizing pixels in the input image. Defaults to\n            (58.395, 57.12, 57.375).\n    \"\"\"\n    super().__init__()\n    self.image_encoder = image_encoder\n    self.prompt_encoder = prompt_encoder\n    self.mask_decoder = mask_decoder\n    self.register_buffer(\"pixel_mean\", torch.Tensor(pixel_mean).view(-1, 1, 1), False)\n    self.register_buffer(\"pixel_std\", torch.Tensor(pixel_std).view(-1, 1, 1), False)\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/","title":"Reference for <code>ultralytics/models/sam/modules/tiny_encoder.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/sam/modules/tiny_encoder.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.Conv2d_BN","title":"<code>ultralytics.models.sam.modules.tiny_encoder.Conv2d_BN</code>","text":"<p>             Bases: <code>Sequential</code></p> <p>A sequential container that performs 2D convolution followed by batch normalization.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>class Conv2d_BN(torch.nn.Sequential):\n    \"\"\"A sequential container that performs 2D convolution followed by batch normalization.\"\"\"\n\n    def __init__(self, a, b, ks=1, stride=1, pad=0, dilation=1, groups=1, bn_weight_init=1):\n        \"\"\"Initializes the MBConv model with given input channels, output channels, expansion ratio, activation, and\n        drop path.\n        \"\"\"\n        super().__init__()\n        self.add_module(\"c\", torch.nn.Conv2d(a, b, ks, stride, pad, dilation, groups, bias=False))\n        bn = torch.nn.BatchNorm2d(b)\n        torch.nn.init.constant_(bn.weight, bn_weight_init)\n        torch.nn.init.constant_(bn.bias, 0)\n        self.add_module(\"bn\", bn)\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.Conv2d_BN.__init__","title":"<code>__init__(a, b, ks=1, stride=1, pad=0, dilation=1, groups=1, bn_weight_init=1)</code>","text":"<p>Initializes the MBConv model with given input channels, output channels, expansion ratio, activation, and drop path.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>def __init__(self, a, b, ks=1, stride=1, pad=0, dilation=1, groups=1, bn_weight_init=1):\n    \"\"\"Initializes the MBConv model with given input channels, output channels, expansion ratio, activation, and\n    drop path.\n    \"\"\"\n    super().__init__()\n    self.add_module(\"c\", torch.nn.Conv2d(a, b, ks, stride, pad, dilation, groups, bias=False))\n    bn = torch.nn.BatchNorm2d(b)\n    torch.nn.init.constant_(bn.weight, bn_weight_init)\n    torch.nn.init.constant_(bn.bias, 0)\n    self.add_module(\"bn\", bn)\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.PatchEmbed","title":"<code>ultralytics.models.sam.modules.tiny_encoder.PatchEmbed</code>","text":"<p>             Bases: <code>Module</code></p> <p>Embeds images into patches and projects them into a specified embedding dimension.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>class PatchEmbed(nn.Module):\n    \"\"\"Embeds images into patches and projects them into a specified embedding dimension.\"\"\"\n\n    def __init__(self, in_chans, embed_dim, resolution, activation):\n        \"\"\"Initialize the PatchMerging class with specified input, output dimensions, resolution and activation\n        function.\n        \"\"\"\n        super().__init__()\n        img_size: Tuple[int, int] = to_2tuple(resolution)\n        self.patches_resolution = (img_size[0] // 4, img_size[1] // 4)\n        self.num_patches = self.patches_resolution[0] * self.patches_resolution[1]\n        self.in_chans = in_chans\n        self.embed_dim = embed_dim\n        n = embed_dim\n        self.seq = nn.Sequential(\n            Conv2d_BN(in_chans, n // 2, 3, 2, 1),\n            activation(),\n            Conv2d_BN(n // 2, n, 3, 2, 1),\n        )\n\n    def forward(self, x):\n        \"\"\"Runs input tensor 'x' through the PatchMerging model's sequence of operations.\"\"\"\n        return self.seq(x)\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.PatchEmbed.__init__","title":"<code>__init__(in_chans, embed_dim, resolution, activation)</code>","text":"<p>Initialize the PatchMerging class with specified input, output dimensions, resolution and activation function.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>def __init__(self, in_chans, embed_dim, resolution, activation):\n    \"\"\"Initialize the PatchMerging class with specified input, output dimensions, resolution and activation\n    function.\n    \"\"\"\n    super().__init__()\n    img_size: Tuple[int, int] = to_2tuple(resolution)\n    self.patches_resolution = (img_size[0] // 4, img_size[1] // 4)\n    self.num_patches = self.patches_resolution[0] * self.patches_resolution[1]\n    self.in_chans = in_chans\n    self.embed_dim = embed_dim\n    n = embed_dim\n    self.seq = nn.Sequential(\n        Conv2d_BN(in_chans, n // 2, 3, 2, 1),\n        activation(),\n        Conv2d_BN(n // 2, n, 3, 2, 1),\n    )\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.PatchEmbed.forward","title":"<code>forward(x)</code>","text":"<p>Runs input tensor 'x' through the PatchMerging model's sequence of operations.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>def forward(self, x):\n    \"\"\"Runs input tensor 'x' through the PatchMerging model's sequence of operations.\"\"\"\n    return self.seq(x)\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.MBConv","title":"<code>ultralytics.models.sam.modules.tiny_encoder.MBConv</code>","text":"<p>             Bases: <code>Module</code></p> <p>Mobile Inverted Bottleneck Conv (MBConv) layer, part of the EfficientNet architecture.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>class MBConv(nn.Module):\n    \"\"\"Mobile Inverted Bottleneck Conv (MBConv) layer, part of the EfficientNet architecture.\"\"\"\n\n    def __init__(self, in_chans, out_chans, expand_ratio, activation, drop_path):\n        \"\"\"Initializes a convolutional layer with specified dimensions, input resolution, depth, and activation\n        function.\n        \"\"\"\n        super().__init__()\n        self.in_chans = in_chans\n        self.hidden_chans = int(in_chans * expand_ratio)\n        self.out_chans = out_chans\n\n        self.conv1 = Conv2d_BN(in_chans, self.hidden_chans, ks=1)\n        self.act1 = activation()\n\n        self.conv2 = Conv2d_BN(self.hidden_chans, self.hidden_chans, ks=3, stride=1, pad=1, groups=self.hidden_chans)\n        self.act2 = activation()\n\n        self.conv3 = Conv2d_BN(self.hidden_chans, out_chans, ks=1, bn_weight_init=0.0)\n        self.act3 = activation()\n\n        # NOTE: `DropPath` is needed only for training.\n        # self.drop_path = DropPath(drop_path) if drop_path &gt; 0. else nn.Identity()\n        self.drop_path = nn.Identity()\n\n    def forward(self, x):\n        \"\"\"Implements the forward pass for the model architecture.\"\"\"\n        shortcut = x\n        x = self.conv1(x)\n        x = self.act1(x)\n        x = self.conv2(x)\n        x = self.act2(x)\n        x = self.conv3(x)\n        x = self.drop_path(x)\n        x += shortcut\n        return self.act3(x)\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.MBConv.__init__","title":"<code>__init__(in_chans, out_chans, expand_ratio, activation, drop_path)</code>","text":"<p>Initializes a convolutional layer with specified dimensions, input resolution, depth, and activation function.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>def __init__(self, in_chans, out_chans, expand_ratio, activation, drop_path):\n    \"\"\"Initializes a convolutional layer with specified dimensions, input resolution, depth, and activation\n    function.\n    \"\"\"\n    super().__init__()\n    self.in_chans = in_chans\n    self.hidden_chans = int(in_chans * expand_ratio)\n    self.out_chans = out_chans\n\n    self.conv1 = Conv2d_BN(in_chans, self.hidden_chans, ks=1)\n    self.act1 = activation()\n\n    self.conv2 = Conv2d_BN(self.hidden_chans, self.hidden_chans, ks=3, stride=1, pad=1, groups=self.hidden_chans)\n    self.act2 = activation()\n\n    self.conv3 = Conv2d_BN(self.hidden_chans, out_chans, ks=1, bn_weight_init=0.0)\n    self.act3 = activation()\n\n    # NOTE: `DropPath` is needed only for training.\n    # self.drop_path = DropPath(drop_path) if drop_path &gt; 0. else nn.Identity()\n    self.drop_path = nn.Identity()\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.MBConv.forward","title":"<code>forward(x)</code>","text":"<p>Implements the forward pass for the model architecture.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>def forward(self, x):\n    \"\"\"Implements the forward pass for the model architecture.\"\"\"\n    shortcut = x\n    x = self.conv1(x)\n    x = self.act1(x)\n    x = self.conv2(x)\n    x = self.act2(x)\n    x = self.conv3(x)\n    x = self.drop_path(x)\n    x += shortcut\n    return self.act3(x)\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.PatchMerging","title":"<code>ultralytics.models.sam.modules.tiny_encoder.PatchMerging</code>","text":"<p>             Bases: <code>Module</code></p> <p>Merges neighboring patches in the feature map and projects to a new dimension.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>class PatchMerging(nn.Module):\n    \"\"\"Merges neighboring patches in the feature map and projects to a new dimension.\"\"\"\n\n    def __init__(self, input_resolution, dim, out_dim, activation):\n        \"\"\"Initializes the ConvLayer with specific dimension, input resolution, depth, activation, drop path, and other\n        optional parameters.\n        \"\"\"\n        super().__init__()\n\n        self.input_resolution = input_resolution\n        self.dim = dim\n        self.out_dim = out_dim\n        self.act = activation()\n        self.conv1 = Conv2d_BN(dim, out_dim, 1, 1, 0)\n        stride_c = 1 if out_dim in [320, 448, 576] else 2\n        self.conv2 = Conv2d_BN(out_dim, out_dim, 3, stride_c, 1, groups=out_dim)\n        self.conv3 = Conv2d_BN(out_dim, out_dim, 1, 1, 0)\n\n    def forward(self, x):\n        \"\"\"Applies forward pass on the input utilizing convolution and activation layers, and returns the result.\"\"\"\n        if x.ndim == 3:\n            H, W = self.input_resolution\n            B = len(x)\n            # (B, C, H, W)\n            x = x.view(B, H, W, -1).permute(0, 3, 1, 2)\n\n        x = self.conv1(x)\n        x = self.act(x)\n\n        x = self.conv2(x)\n        x = self.act(x)\n        x = self.conv3(x)\n        return x.flatten(2).transpose(1, 2)\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.PatchMerging.__init__","title":"<code>__init__(input_resolution, dim, out_dim, activation)</code>","text":"<p>Initializes the ConvLayer with specific dimension, input resolution, depth, activation, drop path, and other optional parameters.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>def __init__(self, input_resolution, dim, out_dim, activation):\n    \"\"\"Initializes the ConvLayer with specific dimension, input resolution, depth, activation, drop path, and other\n    optional parameters.\n    \"\"\"\n    super().__init__()\n\n    self.input_resolution = input_resolution\n    self.dim = dim\n    self.out_dim = out_dim\n    self.act = activation()\n    self.conv1 = Conv2d_BN(dim, out_dim, 1, 1, 0)\n    stride_c = 1 if out_dim in [320, 448, 576] else 2\n    self.conv2 = Conv2d_BN(out_dim, out_dim, 3, stride_c, 1, groups=out_dim)\n    self.conv3 = Conv2d_BN(out_dim, out_dim, 1, 1, 0)\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.PatchMerging.forward","title":"<code>forward(x)</code>","text":"<p>Applies forward pass on the input utilizing convolution and activation layers, and returns the result.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>def forward(self, x):\n    \"\"\"Applies forward pass on the input utilizing convolution and activation layers, and returns the result.\"\"\"\n    if x.ndim == 3:\n        H, W = self.input_resolution\n        B = len(x)\n        # (B, C, H, W)\n        x = x.view(B, H, W, -1).permute(0, 3, 1, 2)\n\n    x = self.conv1(x)\n    x = self.act(x)\n\n    x = self.conv2(x)\n    x = self.act(x)\n    x = self.conv3(x)\n    return x.flatten(2).transpose(1, 2)\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.ConvLayer","title":"<code>ultralytics.models.sam.modules.tiny_encoder.ConvLayer</code>","text":"<p>             Bases: <code>Module</code></p> <p>Convolutional Layer featuring multiple MobileNetV3-style inverted bottleneck convolutions (MBConv).</p> <p>Optionally applies downsample operations to the output, and provides support for gradient checkpointing.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>class ConvLayer(nn.Module):\n    \"\"\"\n    Convolutional Layer featuring multiple MobileNetV3-style inverted bottleneck convolutions (MBConv).\n\n    Optionally applies downsample operations to the output, and provides support for gradient checkpointing.\n    \"\"\"\n\n    def __init__(\n        self,\n        dim,\n        input_resolution,\n        depth,\n        activation,\n        drop_path=0.0,\n        downsample=None,\n        use_checkpoint=False,\n        out_dim=None,\n        conv_expand_ratio=4.0,\n    ):\n        \"\"\"\n        Initializes the ConvLayer with the given dimensions and settings.\n\n        Args:\n            dim (int): The dimensionality of the input and output.\n            input_resolution (Tuple[int, int]): The resolution of the input image.\n            depth (int): The number of MBConv layers in the block.\n            activation (Callable): Activation function applied after each convolution.\n            drop_path (Union[float, List[float]]): Drop path rate. Single float or a list of floats for each MBConv.\n            downsample (Optional[Callable]): Function for downsampling the output. None to skip downsampling.\n            use_checkpoint (bool): Whether to use gradient checkpointing to save memory.\n            out_dim (Optional[int]): The dimensionality of the output. None means it will be the same as `dim`.\n            conv_expand_ratio (float): Expansion ratio for the MBConv layers.\n        \"\"\"\n        super().__init__()\n        self.dim = dim\n        self.input_resolution = input_resolution\n        self.depth = depth\n        self.use_checkpoint = use_checkpoint\n\n        # Build blocks\n        self.blocks = nn.ModuleList(\n            [\n                MBConv(\n                    dim,\n                    dim,\n                    conv_expand_ratio,\n                    activation,\n                    drop_path[i] if isinstance(drop_path, list) else drop_path,\n                )\n                for i in range(depth)\n            ]\n        )\n\n        # Patch merging layer\n        self.downsample = (\n            None\n            if downsample is None\n            else downsample(input_resolution, dim=dim, out_dim=out_dim, activation=activation)\n        )\n\n    def forward(self, x):\n        \"\"\"Processes the input through a series of convolutional layers and returns the activated output.\"\"\"\n        for blk in self.blocks:\n            x = checkpoint.checkpoint(blk, x) if self.use_checkpoint else blk(x)\n        return x if self.downsample is None else self.downsample(x)\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.ConvLayer.__init__","title":"<code>__init__(dim, input_resolution, depth, activation, drop_path=0.0, downsample=None, use_checkpoint=False, out_dim=None, conv_expand_ratio=4.0)</code>","text":"<p>Initializes the ConvLayer with the given dimensions and settings.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>The dimensionality of the input and output.</p> required <code>input_resolution</code> <code>Tuple[int, int]</code> <p>The resolution of the input image.</p> required <code>depth</code> <code>int</code> <p>The number of MBConv layers in the block.</p> required <code>activation</code> <code>Callable</code> <p>Activation function applied after each convolution.</p> required <code>drop_path</code> <code>Union[float, List[float]]</code> <p>Drop path rate. Single float or a list of floats for each MBConv.</p> <code>0.0</code> <code>downsample</code> <code>Optional[Callable]</code> <p>Function for downsampling the output. None to skip downsampling.</p> <code>None</code> <code>use_checkpoint</code> <code>bool</code> <p>Whether to use gradient checkpointing to save memory.</p> <code>False</code> <code>out_dim</code> <code>Optional[int]</code> <p>The dimensionality of the output. None means it will be the same as <code>dim</code>.</p> <code>None</code> <code>conv_expand_ratio</code> <code>float</code> <p>Expansion ratio for the MBConv layers.</p> <code>4.0</code> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>def __init__(\n    self,\n    dim,\n    input_resolution,\n    depth,\n    activation,\n    drop_path=0.0,\n    downsample=None,\n    use_checkpoint=False,\n    out_dim=None,\n    conv_expand_ratio=4.0,\n):\n    \"\"\"\n    Initializes the ConvLayer with the given dimensions and settings.\n\n    Args:\n        dim (int): The dimensionality of the input and output.\n        input_resolution (Tuple[int, int]): The resolution of the input image.\n        depth (int): The number of MBConv layers in the block.\n        activation (Callable): Activation function applied after each convolution.\n        drop_path (Union[float, List[float]]): Drop path rate. Single float or a list of floats for each MBConv.\n        downsample (Optional[Callable]): Function for downsampling the output. None to skip downsampling.\n        use_checkpoint (bool): Whether to use gradient checkpointing to save memory.\n        out_dim (Optional[int]): The dimensionality of the output. None means it will be the same as `dim`.\n        conv_expand_ratio (float): Expansion ratio for the MBConv layers.\n    \"\"\"\n    super().__init__()\n    self.dim = dim\n    self.input_resolution = input_resolution\n    self.depth = depth\n    self.use_checkpoint = use_checkpoint\n\n    # Build blocks\n    self.blocks = nn.ModuleList(\n        [\n            MBConv(\n                dim,\n                dim,\n                conv_expand_ratio,\n                activation,\n                drop_path[i] if isinstance(drop_path, list) else drop_path,\n            )\n            for i in range(depth)\n        ]\n    )\n\n    # Patch merging layer\n    self.downsample = (\n        None\n        if downsample is None\n        else downsample(input_resolution, dim=dim, out_dim=out_dim, activation=activation)\n    )\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.ConvLayer.forward","title":"<code>forward(x)</code>","text":"<p>Processes the input through a series of convolutional layers and returns the activated output.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>def forward(self, x):\n    \"\"\"Processes the input through a series of convolutional layers and returns the activated output.\"\"\"\n    for blk in self.blocks:\n        x = checkpoint.checkpoint(blk, x) if self.use_checkpoint else blk(x)\n    return x if self.downsample is None else self.downsample(x)\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.Mlp","title":"<code>ultralytics.models.sam.modules.tiny_encoder.Mlp</code>","text":"<p>             Bases: <code>Module</code></p> <p>Multi-layer Perceptron (MLP) for transformer architectures.</p> <p>This layer takes an input with in_features, applies layer normalization and two fully-connected layers.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>class Mlp(nn.Module):\n    \"\"\"\n    Multi-layer Perceptron (MLP) for transformer architectures.\n\n    This layer takes an input with in_features, applies layer normalization and two fully-connected layers.\n    \"\"\"\n\n    def __init__(self, in_features, hidden_features=None, out_features=None, act_layer=nn.GELU, drop=0.0):\n        \"\"\"Initializes Attention module with the given parameters including dimension, key_dim, number of heads, etc.\"\"\"\n        super().__init__()\n        out_features = out_features or in_features\n        hidden_features = hidden_features or in_features\n        self.norm = nn.LayerNorm(in_features)\n        self.fc1 = nn.Linear(in_features, hidden_features)\n        self.fc2 = nn.Linear(hidden_features, out_features)\n        self.act = act_layer()\n        self.drop = nn.Dropout(drop)\n\n    def forward(self, x):\n        \"\"\"Applies operations on input x and returns modified x, runs downsample if not None.\"\"\"\n        x = self.norm(x)\n        x = self.fc1(x)\n        x = self.act(x)\n        x = self.drop(x)\n        x = self.fc2(x)\n        return self.drop(x)\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.Mlp.__init__","title":"<code>__init__(in_features, hidden_features=None, out_features=None, act_layer=nn.GELU, drop=0.0)</code>","text":"<p>Initializes Attention module with the given parameters including dimension, key_dim, number of heads, etc.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>def __init__(self, in_features, hidden_features=None, out_features=None, act_layer=nn.GELU, drop=0.0):\n    \"\"\"Initializes Attention module with the given parameters including dimension, key_dim, number of heads, etc.\"\"\"\n    super().__init__()\n    out_features = out_features or in_features\n    hidden_features = hidden_features or in_features\n    self.norm = nn.LayerNorm(in_features)\n    self.fc1 = nn.Linear(in_features, hidden_features)\n    self.fc2 = nn.Linear(hidden_features, out_features)\n    self.act = act_layer()\n    self.drop = nn.Dropout(drop)\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.Mlp.forward","title":"<code>forward(x)</code>","text":"<p>Applies operations on input x and returns modified x, runs downsample if not None.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>def forward(self, x):\n    \"\"\"Applies operations on input x and returns modified x, runs downsample if not None.\"\"\"\n    x = self.norm(x)\n    x = self.fc1(x)\n    x = self.act(x)\n    x = self.drop(x)\n    x = self.fc2(x)\n    return self.drop(x)\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.Attention","title":"<code>ultralytics.models.sam.modules.tiny_encoder.Attention</code>","text":"<p>             Bases: <code>Module</code></p> <p>Multi-head attention module with support for spatial awareness, applying attention biases based on spatial resolution. Implements trainable attention biases for each unique offset between spatial positions in the resolution grid.</p> <p>Attributes:</p> Name Type Description <code>ab</code> <code>Tensor</code> <p>Cached attention biases for inference, deleted during training.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>class Attention(torch.nn.Module):\n    \"\"\"\n    Multi-head attention module with support for spatial awareness, applying attention biases based on spatial\n    resolution. Implements trainable attention biases for each unique offset between spatial positions in the resolution\n    grid.\n\n    Attributes:\n        ab (Tensor, optional): Cached attention biases for inference, deleted during training.\n    \"\"\"\n\n    def __init__(\n        self,\n        dim,\n        key_dim,\n        num_heads=8,\n        attn_ratio=4,\n        resolution=(14, 14),\n    ):\n        \"\"\"\n        Initializes the Attention module.\n\n        Args:\n            dim (int): The dimensionality of the input and output.\n            key_dim (int): The dimensionality of the keys and queries.\n            num_heads (int, optional): Number of attention heads. Default is 8.\n            attn_ratio (float, optional): Attention ratio, affecting the dimensions of the value vectors. Default is 4.\n            resolution (Tuple[int, int], optional): Spatial resolution of the input feature map. Default is (14, 14).\n\n        Raises:\n            AssertionError: If `resolution` is not a tuple of length 2.\n        \"\"\"\n        super().__init__()\n\n        assert isinstance(resolution, tuple) and len(resolution) == 2\n        self.num_heads = num_heads\n        self.scale = key_dim**-0.5\n        self.key_dim = key_dim\n        self.nh_kd = nh_kd = key_dim * num_heads\n        self.d = int(attn_ratio * key_dim)\n        self.dh = int(attn_ratio * key_dim) * num_heads\n        self.attn_ratio = attn_ratio\n        h = self.dh + nh_kd * 2\n\n        self.norm = nn.LayerNorm(dim)\n        self.qkv = nn.Linear(dim, h)\n        self.proj = nn.Linear(self.dh, dim)\n\n        points = list(itertools.product(range(resolution[0]), range(resolution[1])))\n        N = len(points)\n        attention_offsets = {}\n        idxs = []\n        for p1 in points:\n            for p2 in points:\n                offset = (abs(p1[0] - p2[0]), abs(p1[1] - p2[1]))\n                if offset not in attention_offsets:\n                    attention_offsets[offset] = len(attention_offsets)\n                idxs.append(attention_offsets[offset])\n        self.attention_biases = torch.nn.Parameter(torch.zeros(num_heads, len(attention_offsets)))\n        self.register_buffer(\"attention_bias_idxs\", torch.LongTensor(idxs).view(N, N), persistent=False)\n\n    @torch.no_grad()\n    def train(self, mode=True):\n        \"\"\"Sets the module in training mode and handles attribute 'ab' based on the mode.\"\"\"\n        super().train(mode)\n        if mode and hasattr(self, \"ab\"):\n            del self.ab\n        else:\n            self.ab = self.attention_biases[:, self.attention_bias_idxs]\n\n    def forward(self, x):  # x\n        \"\"\"Performs forward pass over the input tensor 'x' by applying normalization and querying keys/values.\"\"\"\n        B, N, _ = x.shape  # B, N, C\n\n        # Normalization\n        x = self.norm(x)\n\n        qkv = self.qkv(x)\n        # (B, N, num_heads, d)\n        q, k, v = qkv.view(B, N, self.num_heads, -1).split([self.key_dim, self.key_dim, self.d], dim=3)\n        # (B, num_heads, N, d)\n        q = q.permute(0, 2, 1, 3)\n        k = k.permute(0, 2, 1, 3)\n        v = v.permute(0, 2, 1, 3)\n        self.ab = self.ab.to(self.attention_biases.device)\n\n        attn = (q @ k.transpose(-2, -1)) * self.scale + (\n            self.attention_biases[:, self.attention_bias_idxs] if self.training else self.ab\n        )\n        attn = attn.softmax(dim=-1)\n        x = (attn @ v).transpose(1, 2).reshape(B, N, self.dh)\n        return self.proj(x)\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.Attention.__init__","title":"<code>__init__(dim, key_dim, num_heads=8, attn_ratio=4, resolution=(14, 14))</code>","text":"<p>Initializes the Attention module.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>The dimensionality of the input and output.</p> required <code>key_dim</code> <code>int</code> <p>The dimensionality of the keys and queries.</p> required <code>num_heads</code> <code>int</code> <p>Number of attention heads. Default is 8.</p> <code>8</code> <code>attn_ratio</code> <code>float</code> <p>Attention ratio, affecting the dimensions of the value vectors. Default is 4.</p> <code>4</code> <code>resolution</code> <code>Tuple[int, int]</code> <p>Spatial resolution of the input feature map. Default is (14, 14).</p> <code>(14, 14)</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>resolution</code> is not a tuple of length 2.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>def __init__(\n    self,\n    dim,\n    key_dim,\n    num_heads=8,\n    attn_ratio=4,\n    resolution=(14, 14),\n):\n    \"\"\"\n    Initializes the Attention module.\n\n    Args:\n        dim (int): The dimensionality of the input and output.\n        key_dim (int): The dimensionality of the keys and queries.\n        num_heads (int, optional): Number of attention heads. Default is 8.\n        attn_ratio (float, optional): Attention ratio, affecting the dimensions of the value vectors. Default is 4.\n        resolution (Tuple[int, int], optional): Spatial resolution of the input feature map. Default is (14, 14).\n\n    Raises:\n        AssertionError: If `resolution` is not a tuple of length 2.\n    \"\"\"\n    super().__init__()\n\n    assert isinstance(resolution, tuple) and len(resolution) == 2\n    self.num_heads = num_heads\n    self.scale = key_dim**-0.5\n    self.key_dim = key_dim\n    self.nh_kd = nh_kd = key_dim * num_heads\n    self.d = int(attn_ratio * key_dim)\n    self.dh = int(attn_ratio * key_dim) * num_heads\n    self.attn_ratio = attn_ratio\n    h = self.dh + nh_kd * 2\n\n    self.norm = nn.LayerNorm(dim)\n    self.qkv = nn.Linear(dim, h)\n    self.proj = nn.Linear(self.dh, dim)\n\n    points = list(itertools.product(range(resolution[0]), range(resolution[1])))\n    N = len(points)\n    attention_offsets = {}\n    idxs = []\n    for p1 in points:\n        for p2 in points:\n            offset = (abs(p1[0] - p2[0]), abs(p1[1] - p2[1]))\n            if offset not in attention_offsets:\n                attention_offsets[offset] = len(attention_offsets)\n            idxs.append(attention_offsets[offset])\n    self.attention_biases = torch.nn.Parameter(torch.zeros(num_heads, len(attention_offsets)))\n    self.register_buffer(\"attention_bias_idxs\", torch.LongTensor(idxs).view(N, N), persistent=False)\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.Attention.forward","title":"<code>forward(x)</code>","text":"<p>Performs forward pass over the input tensor 'x' by applying normalization and querying keys/values.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>def forward(self, x):  # x\n    \"\"\"Performs forward pass over the input tensor 'x' by applying normalization and querying keys/values.\"\"\"\n    B, N, _ = x.shape  # B, N, C\n\n    # Normalization\n    x = self.norm(x)\n\n    qkv = self.qkv(x)\n    # (B, N, num_heads, d)\n    q, k, v = qkv.view(B, N, self.num_heads, -1).split([self.key_dim, self.key_dim, self.d], dim=3)\n    # (B, num_heads, N, d)\n    q = q.permute(0, 2, 1, 3)\n    k = k.permute(0, 2, 1, 3)\n    v = v.permute(0, 2, 1, 3)\n    self.ab = self.ab.to(self.attention_biases.device)\n\n    attn = (q @ k.transpose(-2, -1)) * self.scale + (\n        self.attention_biases[:, self.attention_bias_idxs] if self.training else self.ab\n    )\n    attn = attn.softmax(dim=-1)\n    x = (attn @ v).transpose(1, 2).reshape(B, N, self.dh)\n    return self.proj(x)\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.Attention.train","title":"<code>train(mode=True)</code>","text":"<p>Sets the module in training mode and handles attribute 'ab' based on the mode.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>@torch.no_grad()\ndef train(self, mode=True):\n    \"\"\"Sets the module in training mode and handles attribute 'ab' based on the mode.\"\"\"\n    super().train(mode)\n    if mode and hasattr(self, \"ab\"):\n        del self.ab\n    else:\n        self.ab = self.attention_biases[:, self.attention_bias_idxs]\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.TinyViTBlock","title":"<code>ultralytics.models.sam.modules.tiny_encoder.TinyViTBlock</code>","text":"<p>             Bases: <code>Module</code></p> <p>TinyViT Block that applies self-attention and a local convolution to the input.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>class TinyViTBlock(nn.Module):\n    \"\"\"TinyViT Block that applies self-attention and a local convolution to the input.\"\"\"\n\n    def __init__(\n        self,\n        dim,\n        input_resolution,\n        num_heads,\n        window_size=7,\n        mlp_ratio=4.0,\n        drop=0.0,\n        drop_path=0.0,\n        local_conv_size=3,\n        activation=nn.GELU,\n    ):\n        \"\"\"\n        Initializes the TinyViTBlock.\n\n        Args:\n            dim (int): The dimensionality of the input and output.\n            input_resolution (Tuple[int, int]): Spatial resolution of the input feature map.\n            num_heads (int): Number of attention heads.\n            window_size (int, optional): Window size for attention. Default is 7.\n            mlp_ratio (float, optional): Ratio of mlp hidden dim to embedding dim. Default is 4.\n            drop (float, optional): Dropout rate. Default is 0.\n            drop_path (float, optional): Stochastic depth rate. Default is 0.\n            local_conv_size (int, optional): The kernel size of the local convolution. Default is 3.\n            activation (torch.nn, optional): Activation function for MLP. Default is nn.GELU.\n\n        Raises:\n            AssertionError: If `window_size` is not greater than 0.\n            AssertionError: If `dim` is not divisible by `num_heads`.\n        \"\"\"\n        super().__init__()\n        self.dim = dim\n        self.input_resolution = input_resolution\n        self.num_heads = num_heads\n        assert window_size &gt; 0, \"window_size must be greater than 0\"\n        self.window_size = window_size\n        self.mlp_ratio = mlp_ratio\n\n        # NOTE: `DropPath` is needed only for training.\n        # self.drop_path = DropPath(drop_path) if drop_path &gt; 0. else nn.Identity()\n        self.drop_path = nn.Identity()\n\n        assert dim % num_heads == 0, \"dim must be divisible by num_heads\"\n        head_dim = dim // num_heads\n\n        window_resolution = (window_size, window_size)\n        self.attn = Attention(dim, head_dim, num_heads, attn_ratio=1, resolution=window_resolution)\n\n        mlp_hidden_dim = int(dim * mlp_ratio)\n        mlp_activation = activation\n        self.mlp = Mlp(in_features=dim, hidden_features=mlp_hidden_dim, act_layer=mlp_activation, drop=drop)\n\n        pad = local_conv_size // 2\n        self.local_conv = Conv2d_BN(dim, dim, ks=local_conv_size, stride=1, pad=pad, groups=dim)\n\n    def forward(self, x):\n        \"\"\"Applies attention-based transformation or padding to input 'x' before passing it through a local\n        convolution.\n        \"\"\"\n        H, W = self.input_resolution\n        B, L, C = x.shape\n        assert L == H * W, \"input feature has wrong size\"\n        res_x = x\n        if H == self.window_size and W == self.window_size:\n            x = self.attn(x)\n        else:\n            x = x.view(B, H, W, C)\n            pad_b = (self.window_size - H % self.window_size) % self.window_size\n            pad_r = (self.window_size - W % self.window_size) % self.window_size\n            padding = pad_b &gt; 0 or pad_r &gt; 0\n\n            if padding:\n                x = F.pad(x, (0, 0, 0, pad_r, 0, pad_b))\n\n            pH, pW = H + pad_b, W + pad_r\n            nH = pH // self.window_size\n            nW = pW // self.window_size\n            # Window partition\n            x = (\n                x.view(B, nH, self.window_size, nW, self.window_size, C)\n                .transpose(2, 3)\n                .reshape(B * nH * nW, self.window_size * self.window_size, C)\n            )\n            x = self.attn(x)\n            # Window reverse\n            x = x.view(B, nH, nW, self.window_size, self.window_size, C).transpose(2, 3).reshape(B, pH, pW, C)\n\n            if padding:\n                x = x[:, :H, :W].contiguous()\n\n            x = x.view(B, L, C)\n\n        x = res_x + self.drop_path(x)\n\n        x = x.transpose(1, 2).reshape(B, C, H, W)\n        x = self.local_conv(x)\n        x = x.view(B, C, L).transpose(1, 2)\n\n        return x + self.drop_path(self.mlp(x))\n\n    def extra_repr(self) -&gt; str:\n        \"\"\"Returns a formatted string representing the TinyViTBlock's parameters: dimension, input resolution, number of\n        attentions heads, window size, and MLP ratio.\n        \"\"\"\n        return (\n            f\"dim={self.dim}, input_resolution={self.input_resolution}, num_heads={self.num_heads}, \"\n            f\"window_size={self.window_size}, mlp_ratio={self.mlp_ratio}\"\n        )\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.TinyViTBlock.__init__","title":"<code>__init__(dim, input_resolution, num_heads, window_size=7, mlp_ratio=4.0, drop=0.0, drop_path=0.0, local_conv_size=3, activation=nn.GELU)</code>","text":"<p>Initializes the TinyViTBlock.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>The dimensionality of the input and output.</p> required <code>input_resolution</code> <code>Tuple[int, int]</code> <p>Spatial resolution of the input feature map.</p> required <code>num_heads</code> <code>int</code> <p>Number of attention heads.</p> required <code>window_size</code> <code>int</code> <p>Window size for attention. Default is 7.</p> <code>7</code> <code>mlp_ratio</code> <code>float</code> <p>Ratio of mlp hidden dim to embedding dim. Default is 4.</p> <code>4.0</code> <code>drop</code> <code>float</code> <p>Dropout rate. Default is 0.</p> <code>0.0</code> <code>drop_path</code> <code>float</code> <p>Stochastic depth rate. Default is 0.</p> <code>0.0</code> <code>local_conv_size</code> <code>int</code> <p>The kernel size of the local convolution. Default is 3.</p> <code>3</code> <code>activation</code> <code>nn</code> <p>Activation function for MLP. Default is nn.GELU.</p> <code>GELU</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>window_size</code> is not greater than 0.</p> <code>AssertionError</code> <p>If <code>dim</code> is not divisible by <code>num_heads</code>.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>def __init__(\n    self,\n    dim,\n    input_resolution,\n    num_heads,\n    window_size=7,\n    mlp_ratio=4.0,\n    drop=0.0,\n    drop_path=0.0,\n    local_conv_size=3,\n    activation=nn.GELU,\n):\n    \"\"\"\n    Initializes the TinyViTBlock.\n\n    Args:\n        dim (int): The dimensionality of the input and output.\n        input_resolution (Tuple[int, int]): Spatial resolution of the input feature map.\n        num_heads (int): Number of attention heads.\n        window_size (int, optional): Window size for attention. Default is 7.\n        mlp_ratio (float, optional): Ratio of mlp hidden dim to embedding dim. Default is 4.\n        drop (float, optional): Dropout rate. Default is 0.\n        drop_path (float, optional): Stochastic depth rate. Default is 0.\n        local_conv_size (int, optional): The kernel size of the local convolution. Default is 3.\n        activation (torch.nn, optional): Activation function for MLP. Default is nn.GELU.\n\n    Raises:\n        AssertionError: If `window_size` is not greater than 0.\n        AssertionError: If `dim` is not divisible by `num_heads`.\n    \"\"\"\n    super().__init__()\n    self.dim = dim\n    self.input_resolution = input_resolution\n    self.num_heads = num_heads\n    assert window_size &gt; 0, \"window_size must be greater than 0\"\n    self.window_size = window_size\n    self.mlp_ratio = mlp_ratio\n\n    # NOTE: `DropPath` is needed only for training.\n    # self.drop_path = DropPath(drop_path) if drop_path &gt; 0. else nn.Identity()\n    self.drop_path = nn.Identity()\n\n    assert dim % num_heads == 0, \"dim must be divisible by num_heads\"\n    head_dim = dim // num_heads\n\n    window_resolution = (window_size, window_size)\n    self.attn = Attention(dim, head_dim, num_heads, attn_ratio=1, resolution=window_resolution)\n\n    mlp_hidden_dim = int(dim * mlp_ratio)\n    mlp_activation = activation\n    self.mlp = Mlp(in_features=dim, hidden_features=mlp_hidden_dim, act_layer=mlp_activation, drop=drop)\n\n    pad = local_conv_size // 2\n    self.local_conv = Conv2d_BN(dim, dim, ks=local_conv_size, stride=1, pad=pad, groups=dim)\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.TinyViTBlock.extra_repr","title":"<code>extra_repr()</code>","text":"<p>Returns a formatted string representing the TinyViTBlock's parameters: dimension, input resolution, number of attentions heads, window size, and MLP ratio.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>def extra_repr(self) -&gt; str:\n    \"\"\"Returns a formatted string representing the TinyViTBlock's parameters: dimension, input resolution, number of\n    attentions heads, window size, and MLP ratio.\n    \"\"\"\n    return (\n        f\"dim={self.dim}, input_resolution={self.input_resolution}, num_heads={self.num_heads}, \"\n        f\"window_size={self.window_size}, mlp_ratio={self.mlp_ratio}\"\n    )\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.TinyViTBlock.forward","title":"<code>forward(x)</code>","text":"<p>Applies attention-based transformation or padding to input 'x' before passing it through a local convolution.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>def forward(self, x):\n    \"\"\"Applies attention-based transformation or padding to input 'x' before passing it through a local\n    convolution.\n    \"\"\"\n    H, W = self.input_resolution\n    B, L, C = x.shape\n    assert L == H * W, \"input feature has wrong size\"\n    res_x = x\n    if H == self.window_size and W == self.window_size:\n        x = self.attn(x)\n    else:\n        x = x.view(B, H, W, C)\n        pad_b = (self.window_size - H % self.window_size) % self.window_size\n        pad_r = (self.window_size - W % self.window_size) % self.window_size\n        padding = pad_b &gt; 0 or pad_r &gt; 0\n\n        if padding:\n            x = F.pad(x, (0, 0, 0, pad_r, 0, pad_b))\n\n        pH, pW = H + pad_b, W + pad_r\n        nH = pH // self.window_size\n        nW = pW // self.window_size\n        # Window partition\n        x = (\n            x.view(B, nH, self.window_size, nW, self.window_size, C)\n            .transpose(2, 3)\n            .reshape(B * nH * nW, self.window_size * self.window_size, C)\n        )\n        x = self.attn(x)\n        # Window reverse\n        x = x.view(B, nH, nW, self.window_size, self.window_size, C).transpose(2, 3).reshape(B, pH, pW, C)\n\n        if padding:\n            x = x[:, :H, :W].contiguous()\n\n        x = x.view(B, L, C)\n\n    x = res_x + self.drop_path(x)\n\n    x = x.transpose(1, 2).reshape(B, C, H, W)\n    x = self.local_conv(x)\n    x = x.view(B, C, L).transpose(1, 2)\n\n    return x + self.drop_path(self.mlp(x))\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.BasicLayer","title":"<code>ultralytics.models.sam.modules.tiny_encoder.BasicLayer</code>","text":"<p>             Bases: <code>Module</code></p> <p>A basic TinyViT layer for one stage in a TinyViT architecture.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>class BasicLayer(nn.Module):\n    \"\"\"A basic TinyViT layer for one stage in a TinyViT architecture.\"\"\"\n\n    def __init__(\n        self,\n        dim,\n        input_resolution,\n        depth,\n        num_heads,\n        window_size,\n        mlp_ratio=4.0,\n        drop=0.0,\n        drop_path=0.0,\n        downsample=None,\n        use_checkpoint=False,\n        local_conv_size=3,\n        activation=nn.GELU,\n        out_dim=None,\n    ):\n        \"\"\"\n        Initializes the BasicLayer.\n\n        Args:\n            dim (int): The dimensionality of the input and output.\n            input_resolution (Tuple[int, int]): Spatial resolution of the input feature map.\n            depth (int): Number of TinyViT blocks.\n            num_heads (int): Number of attention heads.\n            window_size (int): Local window size.\n            mlp_ratio (float, optional): Ratio of mlp hidden dim to embedding dim. Default is 4.\n            drop (float, optional): Dropout rate. Default is 0.\n            drop_path (float | tuple[float], optional): Stochastic depth rate. Default is 0.\n            downsample (nn.Module | None, optional): Downsample layer at the end of the layer. Default is None.\n            use_checkpoint (bool, optional): Whether to use checkpointing to save memory. Default is False.\n            local_conv_size (int, optional): Kernel size of the local convolution. Default is 3.\n            activation (torch.nn, optional): Activation function for MLP. Default is nn.GELU.\n            out_dim (int | None, optional): The output dimension of the layer. Default is None.\n\n        Raises:\n            ValueError: If `drop_path` is a list of float but its length doesn't match `depth`.\n        \"\"\"\n        super().__init__()\n        self.dim = dim\n        self.input_resolution = input_resolution\n        self.depth = depth\n        self.use_checkpoint = use_checkpoint\n\n        # Build blocks\n        self.blocks = nn.ModuleList(\n            [\n                TinyViTBlock(\n                    dim=dim,\n                    input_resolution=input_resolution,\n                    num_heads=num_heads,\n                    window_size=window_size,\n                    mlp_ratio=mlp_ratio,\n                    drop=drop,\n                    drop_path=drop_path[i] if isinstance(drop_path, list) else drop_path,\n                    local_conv_size=local_conv_size,\n                    activation=activation,\n                )\n                for i in range(depth)\n            ]\n        )\n\n        # Patch merging layer\n        self.downsample = (\n            None\n            if downsample is None\n            else downsample(input_resolution, dim=dim, out_dim=out_dim, activation=activation)\n        )\n\n    def forward(self, x):\n        \"\"\"Performs forward propagation on the input tensor and returns a normalized tensor.\"\"\"\n        for blk in self.blocks:\n            x = checkpoint.checkpoint(blk, x) if self.use_checkpoint else blk(x)\n        return x if self.downsample is None else self.downsample(x)\n\n    def extra_repr(self) -&gt; str:\n        \"\"\"Returns a string representation of the extra_repr function with the layer's parameters.\"\"\"\n        return f\"dim={self.dim}, input_resolution={self.input_resolution}, depth={self.depth}\"\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.BasicLayer.__init__","title":"<code>__init__(dim, input_resolution, depth, num_heads, window_size, mlp_ratio=4.0, drop=0.0, drop_path=0.0, downsample=None, use_checkpoint=False, local_conv_size=3, activation=nn.GELU, out_dim=None)</code>","text":"<p>Initializes the BasicLayer.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>The dimensionality of the input and output.</p> required <code>input_resolution</code> <code>Tuple[int, int]</code> <p>Spatial resolution of the input feature map.</p> required <code>depth</code> <code>int</code> <p>Number of TinyViT blocks.</p> required <code>num_heads</code> <code>int</code> <p>Number of attention heads.</p> required <code>window_size</code> <code>int</code> <p>Local window size.</p> required <code>mlp_ratio</code> <code>float</code> <p>Ratio of mlp hidden dim to embedding dim. Default is 4.</p> <code>4.0</code> <code>drop</code> <code>float</code> <p>Dropout rate. Default is 0.</p> <code>0.0</code> <code>drop_path</code> <code>float | tuple[float]</code> <p>Stochastic depth rate. Default is 0.</p> <code>0.0</code> <code>downsample</code> <code>Module | None</code> <p>Downsample layer at the end of the layer. Default is None.</p> <code>None</code> <code>use_checkpoint</code> <code>bool</code> <p>Whether to use checkpointing to save memory. Default is False.</p> <code>False</code> <code>local_conv_size</code> <code>int</code> <p>Kernel size of the local convolution. Default is 3.</p> <code>3</code> <code>activation</code> <code>nn</code> <p>Activation function for MLP. Default is nn.GELU.</p> <code>GELU</code> <code>out_dim</code> <code>int | None</code> <p>The output dimension of the layer. Default is None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>drop_path</code> is a list of float but its length doesn't match <code>depth</code>.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>def __init__(\n    self,\n    dim,\n    input_resolution,\n    depth,\n    num_heads,\n    window_size,\n    mlp_ratio=4.0,\n    drop=0.0,\n    drop_path=0.0,\n    downsample=None,\n    use_checkpoint=False,\n    local_conv_size=3,\n    activation=nn.GELU,\n    out_dim=None,\n):\n    \"\"\"\n    Initializes the BasicLayer.\n\n    Args:\n        dim (int): The dimensionality of the input and output.\n        input_resolution (Tuple[int, int]): Spatial resolution of the input feature map.\n        depth (int): Number of TinyViT blocks.\n        num_heads (int): Number of attention heads.\n        window_size (int): Local window size.\n        mlp_ratio (float, optional): Ratio of mlp hidden dim to embedding dim. Default is 4.\n        drop (float, optional): Dropout rate. Default is 0.\n        drop_path (float | tuple[float], optional): Stochastic depth rate. Default is 0.\n        downsample (nn.Module | None, optional): Downsample layer at the end of the layer. Default is None.\n        use_checkpoint (bool, optional): Whether to use checkpointing to save memory. Default is False.\n        local_conv_size (int, optional): Kernel size of the local convolution. Default is 3.\n        activation (torch.nn, optional): Activation function for MLP. Default is nn.GELU.\n        out_dim (int | None, optional): The output dimension of the layer. Default is None.\n\n    Raises:\n        ValueError: If `drop_path` is a list of float but its length doesn't match `depth`.\n    \"\"\"\n    super().__init__()\n    self.dim = dim\n    self.input_resolution = input_resolution\n    self.depth = depth\n    self.use_checkpoint = use_checkpoint\n\n    # Build blocks\n    self.blocks = nn.ModuleList(\n        [\n            TinyViTBlock(\n                dim=dim,\n                input_resolution=input_resolution,\n                num_heads=num_heads,\n                window_size=window_size,\n                mlp_ratio=mlp_ratio,\n                drop=drop,\n                drop_path=drop_path[i] if isinstance(drop_path, list) else drop_path,\n                local_conv_size=local_conv_size,\n                activation=activation,\n            )\n            for i in range(depth)\n        ]\n    )\n\n    # Patch merging layer\n    self.downsample = (\n        None\n        if downsample is None\n        else downsample(input_resolution, dim=dim, out_dim=out_dim, activation=activation)\n    )\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.BasicLayer.extra_repr","title":"<code>extra_repr()</code>","text":"<p>Returns a string representation of the extra_repr function with the layer's parameters.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>def extra_repr(self) -&gt; str:\n    \"\"\"Returns a string representation of the extra_repr function with the layer's parameters.\"\"\"\n    return f\"dim={self.dim}, input_resolution={self.input_resolution}, depth={self.depth}\"\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.BasicLayer.forward","title":"<code>forward(x)</code>","text":"<p>Performs forward propagation on the input tensor and returns a normalized tensor.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>def forward(self, x):\n    \"\"\"Performs forward propagation on the input tensor and returns a normalized tensor.\"\"\"\n    for blk in self.blocks:\n        x = checkpoint.checkpoint(blk, x) if self.use_checkpoint else blk(x)\n    return x if self.downsample is None else self.downsample(x)\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.LayerNorm2d","title":"<code>ultralytics.models.sam.modules.tiny_encoder.LayerNorm2d</code>","text":"<p>             Bases: <code>Module</code></p> <p>A PyTorch implementation of Layer Normalization in 2D.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>class LayerNorm2d(nn.Module):\n    \"\"\"A PyTorch implementation of Layer Normalization in 2D.\"\"\"\n\n    def __init__(self, num_channels: int, eps: float = 1e-6) -&gt; None:\n        \"\"\"Initialize LayerNorm2d with the number of channels and an optional epsilon.\"\"\"\n        super().__init__()\n        self.weight = nn.Parameter(torch.ones(num_channels))\n        self.bias = nn.Parameter(torch.zeros(num_channels))\n        self.eps = eps\n\n    def forward(self, x: torch.Tensor) -&gt; torch.Tensor:\n        \"\"\"Perform a forward pass, normalizing the input tensor.\"\"\"\n        u = x.mean(1, keepdim=True)\n        s = (x - u).pow(2).mean(1, keepdim=True)\n        x = (x - u) / torch.sqrt(s + self.eps)\n        return self.weight[:, None, None] * x + self.bias[:, None, None]\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.LayerNorm2d.__init__","title":"<code>__init__(num_channels, eps=1e-06)</code>","text":"<p>Initialize LayerNorm2d with the number of channels and an optional epsilon.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>def __init__(self, num_channels: int, eps: float = 1e-6) -&gt; None:\n    \"\"\"Initialize LayerNorm2d with the number of channels and an optional epsilon.\"\"\"\n    super().__init__()\n    self.weight = nn.Parameter(torch.ones(num_channels))\n    self.bias = nn.Parameter(torch.zeros(num_channels))\n    self.eps = eps\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.LayerNorm2d.forward","title":"<code>forward(x)</code>","text":"<p>Perform a forward pass, normalizing the input tensor.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>def forward(self, x: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"Perform a forward pass, normalizing the input tensor.\"\"\"\n    u = x.mean(1, keepdim=True)\n    s = (x - u).pow(2).mean(1, keepdim=True)\n    x = (x - u) / torch.sqrt(s + self.eps)\n    return self.weight[:, None, None] * x + self.bias[:, None, None]\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.TinyViT","title":"<code>ultralytics.models.sam.modules.tiny_encoder.TinyViT</code>","text":"<p>             Bases: <code>Module</code></p> <p>The TinyViT architecture for vision tasks.</p> <p>Attributes:</p> Name Type Description <code>img_size</code> <code>int</code> <p>Input image size.</p> <code>in_chans</code> <code>int</code> <p>Number of input channels.</p> <code>num_classes</code> <code>int</code> <p>Number of classification classes.</p> <code>embed_dims</code> <code>List[int]</code> <p>List of embedding dimensions for each layer.</p> <code>depths</code> <code>List[int]</code> <p>List of depths for each layer.</p> <code>num_heads</code> <code>List[int]</code> <p>List of number of attention heads for each layer.</p> <code>window_sizes</code> <code>List[int]</code> <p>List of window sizes for each layer.</p> <code>mlp_ratio</code> <code>float</code> <p>Ratio of MLP hidden dimension to embedding dimension.</p> <code>drop_rate</code> <code>float</code> <p>Dropout rate for drop layers.</p> <code>drop_path_rate</code> <code>float</code> <p>Drop path rate for stochastic depth.</p> <code>use_checkpoint</code> <code>bool</code> <p>Use checkpointing for efficient memory usage.</p> <code>mbconv_expand_ratio</code> <code>float</code> <p>Expansion ratio for MBConv layer.</p> <code>local_conv_size</code> <code>int</code> <p>Local convolution kernel size.</p> <code>layer_lr_decay</code> <code>float</code> <p>Layer-wise learning rate decay.</p> Note <p>This implementation is generalized to accept a list of depths, attention heads, embedding dimensions and window sizes, which allows you to create a \"stack\" of TinyViT models of varying configurations.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>class TinyViT(nn.Module):\n    \"\"\"\n    The TinyViT architecture for vision tasks.\n\n    Attributes:\n        img_size (int): Input image size.\n        in_chans (int): Number of input channels.\n        num_classes (int): Number of classification classes.\n        embed_dims (List[int]): List of embedding dimensions for each layer.\n        depths (List[int]): List of depths for each layer.\n        num_heads (List[int]): List of number of attention heads for each layer.\n        window_sizes (List[int]): List of window sizes for each layer.\n        mlp_ratio (float): Ratio of MLP hidden dimension to embedding dimension.\n        drop_rate (float): Dropout rate for drop layers.\n        drop_path_rate (float): Drop path rate for stochastic depth.\n        use_checkpoint (bool): Use checkpointing for efficient memory usage.\n        mbconv_expand_ratio (float): Expansion ratio for MBConv layer.\n        local_conv_size (int): Local convolution kernel size.\n        layer_lr_decay (float): Layer-wise learning rate decay.\n\n    Note:\n        This implementation is generalized to accept a list of depths, attention heads,\n        embedding dimensions and window sizes, which allows you to create a\n        \"stack\" of TinyViT models of varying configurations.\n    \"\"\"\n\n    def __init__(\n        self,\n        img_size=224,\n        in_chans=3,\n        num_classes=1000,\n        embed_dims=[96, 192, 384, 768],\n        depths=[2, 2, 6, 2],\n        num_heads=[3, 6, 12, 24],\n        window_sizes=[7, 7, 14, 7],\n        mlp_ratio=4.0,\n        drop_rate=0.0,\n        drop_path_rate=0.1,\n        use_checkpoint=False,\n        mbconv_expand_ratio=4.0,\n        local_conv_size=3,\n        layer_lr_decay=1.0,\n    ):\n        \"\"\"\n        Initializes the TinyViT model.\n\n        Args:\n            img_size (int, optional): The input image size. Defaults to 224.\n            in_chans (int, optional): Number of input channels. Defaults to 3.\n            num_classes (int, optional): Number of classification classes. Defaults to 1000.\n            embed_dims (List[int], optional): List of embedding dimensions for each layer. Defaults to [96, 192, 384, 768].\n            depths (List[int], optional): List of depths for each layer. Defaults to [2, 2, 6, 2].\n            num_heads (List[int], optional): List of number of attention heads for each layer. Defaults to [3, 6, 12, 24].\n            window_sizes (List[int], optional): List of window sizes for each layer. Defaults to [7, 7, 14, 7].\n            mlp_ratio (float, optional): Ratio of MLP hidden dimension to embedding dimension. Defaults to 4.\n            drop_rate (float, optional): Dropout rate. Defaults to 0.\n            drop_path_rate (float, optional): Drop path rate for stochastic depth. Defaults to 0.1.\n            use_checkpoint (bool, optional): Whether to use checkpointing for efficient memory usage. Defaults to False.\n            mbconv_expand_ratio (float, optional): Expansion ratio for MBConv layer. Defaults to 4.0.\n            local_conv_size (int, optional): Local convolution kernel size. Defaults to 3.\n            layer_lr_decay (float, optional): Layer-wise learning rate decay. Defaults to 1.0.\n        \"\"\"\n        super().__init__()\n        self.img_size = img_size\n        self.num_classes = num_classes\n        self.depths = depths\n        self.num_layers = len(depths)\n        self.mlp_ratio = mlp_ratio\n\n        activation = nn.GELU\n\n        self.patch_embed = PatchEmbed(\n            in_chans=in_chans, embed_dim=embed_dims[0], resolution=img_size, activation=activation\n        )\n\n        patches_resolution = self.patch_embed.patches_resolution\n        self.patches_resolution = patches_resolution\n\n        # Stochastic depth\n        dpr = [x.item() for x in torch.linspace(0, drop_path_rate, sum(depths))]  # stochastic depth decay rule\n\n        # Build layers\n        self.layers = nn.ModuleList()\n        for i_layer in range(self.num_layers):\n            kwargs = dict(\n                dim=embed_dims[i_layer],\n                input_resolution=(\n                    patches_resolution[0] // (2 ** (i_layer - 1 if i_layer == 3 else i_layer)),\n                    patches_resolution[1] // (2 ** (i_layer - 1 if i_layer == 3 else i_layer)),\n                ),\n                #   input_resolution=(patches_resolution[0] // (2 ** i_layer),\n                #                     patches_resolution[1] // (2 ** i_layer)),\n                depth=depths[i_layer],\n                drop_path=dpr[sum(depths[:i_layer]) : sum(depths[: i_layer + 1])],\n                downsample=PatchMerging if (i_layer &lt; self.num_layers - 1) else None,\n                use_checkpoint=use_checkpoint,\n                out_dim=embed_dims[min(i_layer + 1, len(embed_dims) - 1)],\n                activation=activation,\n            )\n            if i_layer == 0:\n                layer = ConvLayer(conv_expand_ratio=mbconv_expand_ratio, **kwargs)\n            else:\n                layer = BasicLayer(\n                    num_heads=num_heads[i_layer],\n                    window_size=window_sizes[i_layer],\n                    mlp_ratio=self.mlp_ratio,\n                    drop=drop_rate,\n                    local_conv_size=local_conv_size,\n                    **kwargs,\n                )\n            self.layers.append(layer)\n\n        # Classifier head\n        self.norm_head = nn.LayerNorm(embed_dims[-1])\n        self.head = nn.Linear(embed_dims[-1], num_classes) if num_classes &gt; 0 else torch.nn.Identity()\n\n        # Init weights\n        self.apply(self._init_weights)\n        self.set_layer_lr_decay(layer_lr_decay)\n        self.neck = nn.Sequential(\n            nn.Conv2d(\n                embed_dims[-1],\n                256,\n                kernel_size=1,\n                bias=False,\n            ),\n            LayerNorm2d(256),\n            nn.Conv2d(\n                256,\n                256,\n                kernel_size=3,\n                padding=1,\n                bias=False,\n            ),\n            LayerNorm2d(256),\n        )\n\n    def set_layer_lr_decay(self, layer_lr_decay):\n        \"\"\"Sets the learning rate decay for each layer in the TinyViT model.\"\"\"\n        decay_rate = layer_lr_decay\n\n        # Layers -&gt; blocks (depth)\n        depth = sum(self.depths)\n        lr_scales = [decay_rate ** (depth - i - 1) for i in range(depth)]\n\n        def _set_lr_scale(m, scale):\n            \"\"\"Sets the learning rate scale for each layer in the model based on the layer's depth.\"\"\"\n            for p in m.parameters():\n                p.lr_scale = scale\n\n        self.patch_embed.apply(lambda x: _set_lr_scale(x, lr_scales[0]))\n        i = 0\n        for layer in self.layers:\n            for block in layer.blocks:\n                block.apply(lambda x: _set_lr_scale(x, lr_scales[i]))\n                i += 1\n            if layer.downsample is not None:\n                layer.downsample.apply(lambda x: _set_lr_scale(x, lr_scales[i - 1]))\n        assert i == depth\n        for m in [self.norm_head, self.head]:\n            m.apply(lambda x: _set_lr_scale(x, lr_scales[-1]))\n\n        for k, p in self.named_parameters():\n            p.param_name = k\n\n        def _check_lr_scale(m):\n            \"\"\"Checks if the learning rate scale attribute is present in module's parameters.\"\"\"\n            for p in m.parameters():\n                assert hasattr(p, \"lr_scale\"), p.param_name\n\n        self.apply(_check_lr_scale)\n\n    def _init_weights(self, m):\n        \"\"\"Initializes weights for linear layers and layer normalization in the given module.\"\"\"\n        if isinstance(m, nn.Linear):\n            # NOTE: This initialization is needed only for training.\n            # trunc_normal_(m.weight, std=.02)\n            if m.bias is not None:\n                nn.init.constant_(m.bias, 0)\n        elif isinstance(m, nn.LayerNorm):\n            nn.init.constant_(m.bias, 0)\n            nn.init.constant_(m.weight, 1.0)\n\n    @torch.jit.ignore\n    def no_weight_decay_keywords(self):\n        \"\"\"Returns a dictionary of parameter names where weight decay should not be applied.\"\"\"\n        return {\"attention_biases\"}\n\n    def forward_features(self, x):\n        \"\"\"Runs the input through the model layers and returns the transformed output.\"\"\"\n        x = self.patch_embed(x)  # x input is (N, C, H, W)\n\n        x = self.layers[0](x)\n        start_i = 1\n\n        for i in range(start_i, len(self.layers)):\n            layer = self.layers[i]\n            x = layer(x)\n        B, _, C = x.size()\n        x = x.view(B, 64, 64, C)\n        x = x.permute(0, 3, 1, 2)\n        return self.neck(x)\n\n    def forward(self, x):\n        \"\"\"Executes a forward pass on the input tensor through the constructed model layers.\"\"\"\n        return self.forward_features(x)\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.TinyViT.__init__","title":"<code>__init__(img_size=224, in_chans=3, num_classes=1000, embed_dims=[96, 192, 384, 768], depths=[2, 2, 6, 2], num_heads=[3, 6, 12, 24], window_sizes=[7, 7, 14, 7], mlp_ratio=4.0, drop_rate=0.0, drop_path_rate=0.1, use_checkpoint=False, mbconv_expand_ratio=4.0, local_conv_size=3, layer_lr_decay=1.0)</code>","text":"<p>Initializes the TinyViT model.</p> <p>Parameters:</p> Name Type Description Default <code>img_size</code> <code>int</code> <p>The input image size. Defaults to 224.</p> <code>224</code> <code>in_chans</code> <code>int</code> <p>Number of input channels. Defaults to 3.</p> <code>3</code> <code>num_classes</code> <code>int</code> <p>Number of classification classes. Defaults to 1000.</p> <code>1000</code> <code>embed_dims</code> <code>List[int]</code> <p>List of embedding dimensions for each layer. Defaults to [96, 192, 384, 768].</p> <code>[96, 192, 384, 768]</code> <code>depths</code> <code>List[int]</code> <p>List of depths for each layer. Defaults to [2, 2, 6, 2].</p> <code>[2, 2, 6, 2]</code> <code>num_heads</code> <code>List[int]</code> <p>List of number of attention heads for each layer. Defaults to [3, 6, 12, 24].</p> <code>[3, 6, 12, 24]</code> <code>window_sizes</code> <code>List[int]</code> <p>List of window sizes for each layer. Defaults to [7, 7, 14, 7].</p> <code>[7, 7, 14, 7]</code> <code>mlp_ratio</code> <code>float</code> <p>Ratio of MLP hidden dimension to embedding dimension. Defaults to 4.</p> <code>4.0</code> <code>drop_rate</code> <code>float</code> <p>Dropout rate. Defaults to 0.</p> <code>0.0</code> <code>drop_path_rate</code> <code>float</code> <p>Drop path rate for stochastic depth. Defaults to 0.1.</p> <code>0.1</code> <code>use_checkpoint</code> <code>bool</code> <p>Whether to use checkpointing for efficient memory usage. Defaults to False.</p> <code>False</code> <code>mbconv_expand_ratio</code> <code>float</code> <p>Expansion ratio for MBConv layer. Defaults to 4.0.</p> <code>4.0</code> <code>local_conv_size</code> <code>int</code> <p>Local convolution kernel size. Defaults to 3.</p> <code>3</code> <code>layer_lr_decay</code> <code>float</code> <p>Layer-wise learning rate decay. Defaults to 1.0.</p> <code>1.0</code> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>def __init__(\n    self,\n    img_size=224,\n    in_chans=3,\n    num_classes=1000,\n    embed_dims=[96, 192, 384, 768],\n    depths=[2, 2, 6, 2],\n    num_heads=[3, 6, 12, 24],\n    window_sizes=[7, 7, 14, 7],\n    mlp_ratio=4.0,\n    drop_rate=0.0,\n    drop_path_rate=0.1,\n    use_checkpoint=False,\n    mbconv_expand_ratio=4.0,\n    local_conv_size=3,\n    layer_lr_decay=1.0,\n):\n    \"\"\"\n    Initializes the TinyViT model.\n\n    Args:\n        img_size (int, optional): The input image size. Defaults to 224.\n        in_chans (int, optional): Number of input channels. Defaults to 3.\n        num_classes (int, optional): Number of classification classes. Defaults to 1000.\n        embed_dims (List[int], optional): List of embedding dimensions for each layer. Defaults to [96, 192, 384, 768].\n        depths (List[int], optional): List of depths for each layer. Defaults to [2, 2, 6, 2].\n        num_heads (List[int], optional): List of number of attention heads for each layer. Defaults to [3, 6, 12, 24].\n        window_sizes (List[int], optional): List of window sizes for each layer. Defaults to [7, 7, 14, 7].\n        mlp_ratio (float, optional): Ratio of MLP hidden dimension to embedding dimension. Defaults to 4.\n        drop_rate (float, optional): Dropout rate. Defaults to 0.\n        drop_path_rate (float, optional): Drop path rate for stochastic depth. Defaults to 0.1.\n        use_checkpoint (bool, optional): Whether to use checkpointing for efficient memory usage. Defaults to False.\n        mbconv_expand_ratio (float, optional): Expansion ratio for MBConv layer. Defaults to 4.0.\n        local_conv_size (int, optional): Local convolution kernel size. Defaults to 3.\n        layer_lr_decay (float, optional): Layer-wise learning rate decay. Defaults to 1.0.\n    \"\"\"\n    super().__init__()\n    self.img_size = img_size\n    self.num_classes = num_classes\n    self.depths = depths\n    self.num_layers = len(depths)\n    self.mlp_ratio = mlp_ratio\n\n    activation = nn.GELU\n\n    self.patch_embed = PatchEmbed(\n        in_chans=in_chans, embed_dim=embed_dims[0], resolution=img_size, activation=activation\n    )\n\n    patches_resolution = self.patch_embed.patches_resolution\n    self.patches_resolution = patches_resolution\n\n    # Stochastic depth\n    dpr = [x.item() for x in torch.linspace(0, drop_path_rate, sum(depths))]  # stochastic depth decay rule\n\n    # Build layers\n    self.layers = nn.ModuleList()\n    for i_layer in range(self.num_layers):\n        kwargs = dict(\n            dim=embed_dims[i_layer],\n            input_resolution=(\n                patches_resolution[0] // (2 ** (i_layer - 1 if i_layer == 3 else i_layer)),\n                patches_resolution[1] // (2 ** (i_layer - 1 if i_layer == 3 else i_layer)),\n            ),\n            #   input_resolution=(patches_resolution[0] // (2 ** i_layer),\n            #                     patches_resolution[1] // (2 ** i_layer)),\n            depth=depths[i_layer],\n            drop_path=dpr[sum(depths[:i_layer]) : sum(depths[: i_layer + 1])],\n            downsample=PatchMerging if (i_layer &lt; self.num_layers - 1) else None,\n            use_checkpoint=use_checkpoint,\n            out_dim=embed_dims[min(i_layer + 1, len(embed_dims) - 1)],\n            activation=activation,\n        )\n        if i_layer == 0:\n            layer = ConvLayer(conv_expand_ratio=mbconv_expand_ratio, **kwargs)\n        else:\n            layer = BasicLayer(\n                num_heads=num_heads[i_layer],\n                window_size=window_sizes[i_layer],\n                mlp_ratio=self.mlp_ratio,\n                drop=drop_rate,\n                local_conv_size=local_conv_size,\n                **kwargs,\n            )\n        self.layers.append(layer)\n\n    # Classifier head\n    self.norm_head = nn.LayerNorm(embed_dims[-1])\n    self.head = nn.Linear(embed_dims[-1], num_classes) if num_classes &gt; 0 else torch.nn.Identity()\n\n    # Init weights\n    self.apply(self._init_weights)\n    self.set_layer_lr_decay(layer_lr_decay)\n    self.neck = nn.Sequential(\n        nn.Conv2d(\n            embed_dims[-1],\n            256,\n            kernel_size=1,\n            bias=False,\n        ),\n        LayerNorm2d(256),\n        nn.Conv2d(\n            256,\n            256,\n            kernel_size=3,\n            padding=1,\n            bias=False,\n        ),\n        LayerNorm2d(256),\n    )\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.TinyViT.forward","title":"<code>forward(x)</code>","text":"<p>Executes a forward pass on the input tensor through the constructed model layers.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>def forward(self, x):\n    \"\"\"Executes a forward pass on the input tensor through the constructed model layers.\"\"\"\n    return self.forward_features(x)\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.TinyViT.forward_features","title":"<code>forward_features(x)</code>","text":"<p>Runs the input through the model layers and returns the transformed output.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>def forward_features(self, x):\n    \"\"\"Runs the input through the model layers and returns the transformed output.\"\"\"\n    x = self.patch_embed(x)  # x input is (N, C, H, W)\n\n    x = self.layers[0](x)\n    start_i = 1\n\n    for i in range(start_i, len(self.layers)):\n        layer = self.layers[i]\n        x = layer(x)\n    B, _, C = x.size()\n    x = x.view(B, 64, 64, C)\n    x = x.permute(0, 3, 1, 2)\n    return self.neck(x)\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.TinyViT.no_weight_decay_keywords","title":"<code>no_weight_decay_keywords()</code>","text":"<p>Returns a dictionary of parameter names where weight decay should not be applied.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>@torch.jit.ignore\ndef no_weight_decay_keywords(self):\n    \"\"\"Returns a dictionary of parameter names where weight decay should not be applied.\"\"\"\n    return {\"attention_biases\"}\n</code></pre>"},{"location":"reference/models/sam/modules/tiny_encoder/#ultralytics.models.sam.modules.tiny_encoder.TinyViT.set_layer_lr_decay","title":"<code>set_layer_lr_decay(layer_lr_decay)</code>","text":"<p>Sets the learning rate decay for each layer in the TinyViT model.</p> Source code in <code>ultralytics/models/sam/modules/tiny_encoder.py</code> <pre><code>def set_layer_lr_decay(self, layer_lr_decay):\n    \"\"\"Sets the learning rate decay for each layer in the TinyViT model.\"\"\"\n    decay_rate = layer_lr_decay\n\n    # Layers -&gt; blocks (depth)\n    depth = sum(self.depths)\n    lr_scales = [decay_rate ** (depth - i - 1) for i in range(depth)]\n\n    def _set_lr_scale(m, scale):\n        \"\"\"Sets the learning rate scale for each layer in the model based on the layer's depth.\"\"\"\n        for p in m.parameters():\n            p.lr_scale = scale\n\n    self.patch_embed.apply(lambda x: _set_lr_scale(x, lr_scales[0]))\n    i = 0\n    for layer in self.layers:\n        for block in layer.blocks:\n            block.apply(lambda x: _set_lr_scale(x, lr_scales[i]))\n            i += 1\n        if layer.downsample is not None:\n            layer.downsample.apply(lambda x: _set_lr_scale(x, lr_scales[i - 1]))\n    assert i == depth\n    for m in [self.norm_head, self.head]:\n        m.apply(lambda x: _set_lr_scale(x, lr_scales[-1]))\n\n    for k, p in self.named_parameters():\n        p.param_name = k\n\n    def _check_lr_scale(m):\n        \"\"\"Checks if the learning rate scale attribute is present in module's parameters.\"\"\"\n        for p in m.parameters():\n            assert hasattr(p, \"lr_scale\"), p.param_name\n\n    self.apply(_check_lr_scale)\n</code></pre>"},{"location":"reference/models/sam/modules/transformer/","title":"Reference for <code>ultralytics/models/sam/modules/transformer.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/sam/modules/transformer.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/models/sam/modules/transformer/#ultralytics.models.sam.modules.transformer.TwoWayTransformer","title":"<code>ultralytics.models.sam.modules.transformer.TwoWayTransformer</code>","text":"<p>             Bases: <code>Module</code></p> <p>A Two-Way Transformer module that enables the simultaneous attention to both image and query points. This class serves as a specialized transformer decoder that attends to an input image using queries whose positional embedding is supplied. This is particularly useful for tasks like object detection, image segmentation, and point cloud processing.</p> <p>Attributes:</p> Name Type Description <code>depth</code> <code>int</code> <p>The number of layers in the transformer.</p> <code>embedding_dim</code> <code>int</code> <p>The channel dimension for the input embeddings.</p> <code>num_heads</code> <code>int</code> <p>The number of heads for multihead attention.</p> <code>mlp_dim</code> <code>int</code> <p>The internal channel dimension for the MLP block.</p> <code>layers</code> <code>ModuleList</code> <p>The list of TwoWayAttentionBlock layers that make up the transformer.</p> <code>final_attn_token_to_image</code> <code>Attention</code> <p>The final attention layer applied from the queries to the image.</p> <code>norm_final_attn</code> <code>LayerNorm</code> <p>The layer normalization applied to the final queries.</p> Source code in <code>ultralytics/models/sam/modules/transformer.py</code> <pre><code>class TwoWayTransformer(nn.Module):\n    \"\"\"\n    A Two-Way Transformer module that enables the simultaneous attention to both image and query points. This class\n    serves as a specialized transformer decoder that attends to an input image using queries whose positional embedding\n    is supplied. This is particularly useful for tasks like object detection, image segmentation, and point cloud\n    processing.\n\n    Attributes:\n        depth (int): The number of layers in the transformer.\n        embedding_dim (int): The channel dimension for the input embeddings.\n        num_heads (int): The number of heads for multihead attention.\n        mlp_dim (int): The internal channel dimension for the MLP block.\n        layers (nn.ModuleList): The list of TwoWayAttentionBlock layers that make up the transformer.\n        final_attn_token_to_image (Attention): The final attention layer applied from the queries to the image.\n        norm_final_attn (nn.LayerNorm): The layer normalization applied to the final queries.\n    \"\"\"\n\n    def __init__(\n        self,\n        depth: int,\n        embedding_dim: int,\n        num_heads: int,\n        mlp_dim: int,\n        activation: Type[nn.Module] = nn.ReLU,\n        attention_downsample_rate: int = 2,\n    ) -&gt; None:\n        \"\"\"\n        A transformer decoder that attends to an input image using queries whose positional embedding is supplied.\n\n        Args:\n          depth (int): number of layers in the transformer\n          embedding_dim (int): the channel dimension for the input embeddings\n          num_heads (int): the number of heads for multihead attention. Must\n            divide embedding_dim\n          mlp_dim (int): the channel dimension internal to the MLP block\n          activation (nn.Module): the activation to use in the MLP block\n        \"\"\"\n        super().__init__()\n        self.depth = depth\n        self.embedding_dim = embedding_dim\n        self.num_heads = num_heads\n        self.mlp_dim = mlp_dim\n        self.layers = nn.ModuleList()\n\n        for i in range(depth):\n            self.layers.append(\n                TwoWayAttentionBlock(\n                    embedding_dim=embedding_dim,\n                    num_heads=num_heads,\n                    mlp_dim=mlp_dim,\n                    activation=activation,\n                    attention_downsample_rate=attention_downsample_rate,\n                    skip_first_layer_pe=(i == 0),\n                )\n            )\n\n        self.final_attn_token_to_image = Attention(embedding_dim, num_heads, downsample_rate=attention_downsample_rate)\n        self.norm_final_attn = nn.LayerNorm(embedding_dim)\n\n    def forward(\n        self,\n        image_embedding: Tensor,\n        image_pe: Tensor,\n        point_embedding: Tensor,\n    ) -&gt; Tuple[Tensor, Tensor]:\n        \"\"\"\n        Args:\n          image_embedding (torch.Tensor): image to attend to. Should be shape B x embedding_dim x h x w for any h and w.\n          image_pe (torch.Tensor): the positional encoding to add to the image. Must have same shape as image_embedding.\n          point_embedding (torch.Tensor): the embedding to add to the query points.\n            Must have shape B x N_points x embedding_dim for any N_points.\n\n        Returns:\n          (torch.Tensor): the processed point_embedding\n          (torch.Tensor): the processed image_embedding\n        \"\"\"\n        # BxCxHxW -&gt; BxHWxC == B x N_image_tokens x C\n        bs, c, h, w = image_embedding.shape\n        image_embedding = image_embedding.flatten(2).permute(0, 2, 1)\n        image_pe = image_pe.flatten(2).permute(0, 2, 1)\n\n        # Prepare queries\n        queries = point_embedding\n        keys = image_embedding\n\n        # Apply transformer blocks and final layernorm\n        for layer in self.layers:\n            queries, keys = layer(\n                queries=queries,\n                keys=keys,\n                query_pe=point_embedding,\n                key_pe=image_pe,\n            )\n\n        # Apply the final attention layer from the points to the image\n        q = queries + point_embedding\n        k = keys + image_pe\n        attn_out = self.final_attn_token_to_image(q=q, k=k, v=keys)\n        queries = queries + attn_out\n        queries = self.norm_final_attn(queries)\n\n        return queries, keys\n</code></pre>"},{"location":"reference/models/sam/modules/transformer/#ultralytics.models.sam.modules.transformer.TwoWayTransformer.__init__","title":"<code>__init__(depth, embedding_dim, num_heads, mlp_dim, activation=nn.ReLU, attention_downsample_rate=2)</code>","text":"<p>A transformer decoder that attends to an input image using queries whose positional embedding is supplied.</p> <p>Parameters:</p> Name Type Description Default <code>depth</code> <code>int</code> <p>number of layers in the transformer</p> required <code>embedding_dim</code> <code>int</code> <p>the channel dimension for the input embeddings</p> required <code>num_heads</code> <code>int</code> <p>the number of heads for multihead attention. Must divide embedding_dim</p> required <code>mlp_dim</code> <code>int</code> <p>the channel dimension internal to the MLP block</p> required <code>activation</code> <code>Module</code> <p>the activation to use in the MLP block</p> <code>ReLU</code> Source code in <code>ultralytics/models/sam/modules/transformer.py</code> <pre><code>def __init__(\n    self,\n    depth: int,\n    embedding_dim: int,\n    num_heads: int,\n    mlp_dim: int,\n    activation: Type[nn.Module] = nn.ReLU,\n    attention_downsample_rate: int = 2,\n) -&gt; None:\n    \"\"\"\n    A transformer decoder that attends to an input image using queries whose positional embedding is supplied.\n\n    Args:\n      depth (int): number of layers in the transformer\n      embedding_dim (int): the channel dimension for the input embeddings\n      num_heads (int): the number of heads for multihead attention. Must\n        divide embedding_dim\n      mlp_dim (int): the channel dimension internal to the MLP block\n      activation (nn.Module): the activation to use in the MLP block\n    \"\"\"\n    super().__init__()\n    self.depth = depth\n    self.embedding_dim = embedding_dim\n    self.num_heads = num_heads\n    self.mlp_dim = mlp_dim\n    self.layers = nn.ModuleList()\n\n    for i in range(depth):\n        self.layers.append(\n            TwoWayAttentionBlock(\n                embedding_dim=embedding_dim,\n                num_heads=num_heads,\n                mlp_dim=mlp_dim,\n                activation=activation,\n                attention_downsample_rate=attention_downsample_rate,\n                skip_first_layer_pe=(i == 0),\n            )\n        )\n\n    self.final_attn_token_to_image = Attention(embedding_dim, num_heads, downsample_rate=attention_downsample_rate)\n    self.norm_final_attn = nn.LayerNorm(embedding_dim)\n</code></pre>"},{"location":"reference/models/sam/modules/transformer/#ultralytics.models.sam.modules.transformer.TwoWayTransformer.forward","title":"<code>forward(image_embedding, image_pe, point_embedding)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>image_embedding</code> <code>Tensor</code> <p>image to attend to. Should be shape B x embedding_dim x h x w for any h and w.</p> required <code>image_pe</code> <code>Tensor</code> <p>the positional encoding to add to the image. Must have same shape as image_embedding.</p> required <code>point_embedding</code> <code>Tensor</code> <p>the embedding to add to the query points. Must have shape B x N_points x embedding_dim for any N_points.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>the processed point_embedding</p> <code>Tensor</code> <p>the processed image_embedding</p> Source code in <code>ultralytics/models/sam/modules/transformer.py</code> <pre><code>def forward(\n    self,\n    image_embedding: Tensor,\n    image_pe: Tensor,\n    point_embedding: Tensor,\n) -&gt; Tuple[Tensor, Tensor]:\n    \"\"\"\n    Args:\n      image_embedding (torch.Tensor): image to attend to. Should be shape B x embedding_dim x h x w for any h and w.\n      image_pe (torch.Tensor): the positional encoding to add to the image. Must have same shape as image_embedding.\n      point_embedding (torch.Tensor): the embedding to add to the query points.\n        Must have shape B x N_points x embedding_dim for any N_points.\n\n    Returns:\n      (torch.Tensor): the processed point_embedding\n      (torch.Tensor): the processed image_embedding\n    \"\"\"\n    # BxCxHxW -&gt; BxHWxC == B x N_image_tokens x C\n    bs, c, h, w = image_embedding.shape\n    image_embedding = image_embedding.flatten(2).permute(0, 2, 1)\n    image_pe = image_pe.flatten(2).permute(0, 2, 1)\n\n    # Prepare queries\n    queries = point_embedding\n    keys = image_embedding\n\n    # Apply transformer blocks and final layernorm\n    for layer in self.layers:\n        queries, keys = layer(\n            queries=queries,\n            keys=keys,\n            query_pe=point_embedding,\n            key_pe=image_pe,\n        )\n\n    # Apply the final attention layer from the points to the image\n    q = queries + point_embedding\n    k = keys + image_pe\n    attn_out = self.final_attn_token_to_image(q=q, k=k, v=keys)\n    queries = queries + attn_out\n    queries = self.norm_final_attn(queries)\n\n    return queries, keys\n</code></pre>"},{"location":"reference/models/sam/modules/transformer/#ultralytics.models.sam.modules.transformer.TwoWayAttentionBlock","title":"<code>ultralytics.models.sam.modules.transformer.TwoWayAttentionBlock</code>","text":"<p>             Bases: <code>Module</code></p> <p>An attention block that performs both self-attention and cross-attention in two directions: queries to keys and keys to queries. This block consists of four main layers: (1) self-attention on sparse inputs, (2) cross-attention of sparse inputs to dense inputs, (3) an MLP block on sparse inputs, and (4) cross-attention of dense inputs to sparse inputs.</p> <p>Attributes:</p> Name Type Description <code>self_attn</code> <code>Attention</code> <p>The self-attention layer for the queries.</p> <code>norm1</code> <code>LayerNorm</code> <p>Layer normalization following the first attention block.</p> <code>cross_attn_token_to_image</code> <code>Attention</code> <p>Cross-attention layer from queries to keys.</p> <code>norm2</code> <code>LayerNorm</code> <p>Layer normalization following the second attention block.</p> <code>mlp</code> <code>MLPBlock</code> <p>MLP block that transforms the query embeddings.</p> <code>norm3</code> <code>LayerNorm</code> <p>Layer normalization following the MLP block.</p> <code>norm4</code> <code>LayerNorm</code> <p>Layer normalization following the third attention block.</p> <code>cross_attn_image_to_token</code> <code>Attention</code> <p>Cross-attention layer from keys to queries.</p> <code>skip_first_layer_pe</code> <code>bool</code> <p>Whether to skip the positional encoding in the first layer.</p> Source code in <code>ultralytics/models/sam/modules/transformer.py</code> <pre><code>class TwoWayAttentionBlock(nn.Module):\n    \"\"\"\n    An attention block that performs both self-attention and cross-attention in two directions: queries to keys and\n    keys to queries. This block consists of four main layers: (1) self-attention on sparse inputs, (2) cross-attention\n    of sparse inputs to dense inputs, (3) an MLP block on sparse inputs, and (4) cross-attention of dense inputs to\n    sparse inputs.\n\n    Attributes:\n        self_attn (Attention): The self-attention layer for the queries.\n        norm1 (nn.LayerNorm): Layer normalization following the first attention block.\n        cross_attn_token_to_image (Attention): Cross-attention layer from queries to keys.\n        norm2 (nn.LayerNorm): Layer normalization following the second attention block.\n        mlp (MLPBlock): MLP block that transforms the query embeddings.\n        norm3 (nn.LayerNorm): Layer normalization following the MLP block.\n        norm4 (nn.LayerNorm): Layer normalization following the third attention block.\n        cross_attn_image_to_token (Attention): Cross-attention layer from keys to queries.\n        skip_first_layer_pe (bool): Whether to skip the positional encoding in the first layer.\n    \"\"\"\n\n    def __init__(\n        self,\n        embedding_dim: int,\n        num_heads: int,\n        mlp_dim: int = 2048,\n        activation: Type[nn.Module] = nn.ReLU,\n        attention_downsample_rate: int = 2,\n        skip_first_layer_pe: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        A transformer block with four layers: (1) self-attention of sparse inputs, (2) cross attention of sparse\n        inputs to dense inputs, (3) mlp block on sparse inputs, and (4) cross attention of dense inputs to sparse\n        inputs.\n\n        Args:\n          embedding_dim (int): the channel dimension of the embeddings\n          num_heads (int): the number of heads in the attention layers\n          mlp_dim (int): the hidden dimension of the mlp block\n          activation (nn.Module): the activation of the mlp block\n          skip_first_layer_pe (bool): skip the PE on the first layer\n        \"\"\"\n        super().__init__()\n        self.self_attn = Attention(embedding_dim, num_heads)\n        self.norm1 = nn.LayerNorm(embedding_dim)\n\n        self.cross_attn_token_to_image = Attention(embedding_dim, num_heads, downsample_rate=attention_downsample_rate)\n        self.norm2 = nn.LayerNorm(embedding_dim)\n\n        self.mlp = MLPBlock(embedding_dim, mlp_dim, activation)\n        self.norm3 = nn.LayerNorm(embedding_dim)\n\n        self.norm4 = nn.LayerNorm(embedding_dim)\n        self.cross_attn_image_to_token = Attention(embedding_dim, num_heads, downsample_rate=attention_downsample_rate)\n\n        self.skip_first_layer_pe = skip_first_layer_pe\n\n    def forward(self, queries: Tensor, keys: Tensor, query_pe: Tensor, key_pe: Tensor) -&gt; Tuple[Tensor, Tensor]:\n        \"\"\"Apply self-attention and cross-attention to queries and keys and return the processed embeddings.\"\"\"\n\n        # Self attention block\n        if self.skip_first_layer_pe:\n            queries = self.self_attn(q=queries, k=queries, v=queries)\n        else:\n            q = queries + query_pe\n            attn_out = self.self_attn(q=q, k=q, v=queries)\n            queries = queries + attn_out\n        queries = self.norm1(queries)\n\n        # Cross attention block, tokens attending to image embedding\n        q = queries + query_pe\n        k = keys + key_pe\n        attn_out = self.cross_attn_token_to_image(q=q, k=k, v=keys)\n        queries = queries + attn_out\n        queries = self.norm2(queries)\n\n        # MLP block\n        mlp_out = self.mlp(queries)\n        queries = queries + mlp_out\n        queries = self.norm3(queries)\n\n        # Cross attention block, image embedding attending to tokens\n        q = queries + query_pe\n        k = keys + key_pe\n        attn_out = self.cross_attn_image_to_token(q=k, k=q, v=queries)\n        keys = keys + attn_out\n        keys = self.norm4(keys)\n\n        return queries, keys\n</code></pre>"},{"location":"reference/models/sam/modules/transformer/#ultralytics.models.sam.modules.transformer.TwoWayAttentionBlock.__init__","title":"<code>__init__(embedding_dim, num_heads, mlp_dim=2048, activation=nn.ReLU, attention_downsample_rate=2, skip_first_layer_pe=False)</code>","text":"<p>A transformer block with four layers: (1) self-attention of sparse inputs, (2) cross attention of sparse inputs to dense inputs, (3) mlp block on sparse inputs, and (4) cross attention of dense inputs to sparse inputs.</p> <p>Parameters:</p> Name Type Description Default <code>embedding_dim</code> <code>int</code> <p>the channel dimension of the embeddings</p> required <code>num_heads</code> <code>int</code> <p>the number of heads in the attention layers</p> required <code>mlp_dim</code> <code>int</code> <p>the hidden dimension of the mlp block</p> <code>2048</code> <code>activation</code> <code>Module</code> <p>the activation of the mlp block</p> <code>ReLU</code> <code>skip_first_layer_pe</code> <code>bool</code> <p>skip the PE on the first layer</p> <code>False</code> Source code in <code>ultralytics/models/sam/modules/transformer.py</code> <pre><code>def __init__(\n    self,\n    embedding_dim: int,\n    num_heads: int,\n    mlp_dim: int = 2048,\n    activation: Type[nn.Module] = nn.ReLU,\n    attention_downsample_rate: int = 2,\n    skip_first_layer_pe: bool = False,\n) -&gt; None:\n    \"\"\"\n    A transformer block with four layers: (1) self-attention of sparse inputs, (2) cross attention of sparse\n    inputs to dense inputs, (3) mlp block on sparse inputs, and (4) cross attention of dense inputs to sparse\n    inputs.\n\n    Args:\n      embedding_dim (int): the channel dimension of the embeddings\n      num_heads (int): the number of heads in the attention layers\n      mlp_dim (int): the hidden dimension of the mlp block\n      activation (nn.Module): the activation of the mlp block\n      skip_first_layer_pe (bool): skip the PE on the first layer\n    \"\"\"\n    super().__init__()\n    self.self_attn = Attention(embedding_dim, num_heads)\n    self.norm1 = nn.LayerNorm(embedding_dim)\n\n    self.cross_attn_token_to_image = Attention(embedding_dim, num_heads, downsample_rate=attention_downsample_rate)\n    self.norm2 = nn.LayerNorm(embedding_dim)\n\n    self.mlp = MLPBlock(embedding_dim, mlp_dim, activation)\n    self.norm3 = nn.LayerNorm(embedding_dim)\n\n    self.norm4 = nn.LayerNorm(embedding_dim)\n    self.cross_attn_image_to_token = Attention(embedding_dim, num_heads, downsample_rate=attention_downsample_rate)\n\n    self.skip_first_layer_pe = skip_first_layer_pe\n</code></pre>"},{"location":"reference/models/sam/modules/transformer/#ultralytics.models.sam.modules.transformer.TwoWayAttentionBlock.forward","title":"<code>forward(queries, keys, query_pe, key_pe)</code>","text":"<p>Apply self-attention and cross-attention to queries and keys and return the processed embeddings.</p> Source code in <code>ultralytics/models/sam/modules/transformer.py</code> <pre><code>def forward(self, queries: Tensor, keys: Tensor, query_pe: Tensor, key_pe: Tensor) -&gt; Tuple[Tensor, Tensor]:\n    \"\"\"Apply self-attention and cross-attention to queries and keys and return the processed embeddings.\"\"\"\n\n    # Self attention block\n    if self.skip_first_layer_pe:\n        queries = self.self_attn(q=queries, k=queries, v=queries)\n    else:\n        q = queries + query_pe\n        attn_out = self.self_attn(q=q, k=q, v=queries)\n        queries = queries + attn_out\n    queries = self.norm1(queries)\n\n    # Cross attention block, tokens attending to image embedding\n    q = queries + query_pe\n    k = keys + key_pe\n    attn_out = self.cross_attn_token_to_image(q=q, k=k, v=keys)\n    queries = queries + attn_out\n    queries = self.norm2(queries)\n\n    # MLP block\n    mlp_out = self.mlp(queries)\n    queries = queries + mlp_out\n    queries = self.norm3(queries)\n\n    # Cross attention block, image embedding attending to tokens\n    q = queries + query_pe\n    k = keys + key_pe\n    attn_out = self.cross_attn_image_to_token(q=k, k=q, v=queries)\n    keys = keys + attn_out\n    keys = self.norm4(keys)\n\n    return queries, keys\n</code></pre>"},{"location":"reference/models/sam/modules/transformer/#ultralytics.models.sam.modules.transformer.Attention","title":"<code>ultralytics.models.sam.modules.transformer.Attention</code>","text":"<p>             Bases: <code>Module</code></p> <p>An attention layer that allows for downscaling the size of the embedding after projection to queries, keys, and values.</p> Source code in <code>ultralytics/models/sam/modules/transformer.py</code> <pre><code>class Attention(nn.Module):\n    \"\"\"An attention layer that allows for downscaling the size of the embedding after projection to queries, keys, and\n    values.\n    \"\"\"\n\n    def __init__(\n        self,\n        embedding_dim: int,\n        num_heads: int,\n        downsample_rate: int = 1,\n    ) -&gt; None:\n        \"\"\"\n        Initializes the Attention model with the given dimensions and settings.\n\n        Args:\n            embedding_dim (int): The dimensionality of the input embeddings.\n            num_heads (int): The number of attention heads.\n            downsample_rate (int, optional): The factor by which the internal dimensions are downsampled. Defaults to 1.\n\n        Raises:\n            AssertionError: If 'num_heads' does not evenly divide the internal dimension (embedding_dim / downsample_rate).\n        \"\"\"\n        super().__init__()\n        self.embedding_dim = embedding_dim\n        self.internal_dim = embedding_dim // downsample_rate\n        self.num_heads = num_heads\n        assert self.internal_dim % num_heads == 0, \"num_heads must divide embedding_dim.\"\n\n        self.q_proj = nn.Linear(embedding_dim, self.internal_dim)\n        self.k_proj = nn.Linear(embedding_dim, self.internal_dim)\n        self.v_proj = nn.Linear(embedding_dim, self.internal_dim)\n        self.out_proj = nn.Linear(self.internal_dim, embedding_dim)\n\n    @staticmethod\n    def _separate_heads(x: Tensor, num_heads: int) -&gt; Tensor:\n        \"\"\"Separate the input tensor into the specified number of attention heads.\"\"\"\n        b, n, c = x.shape\n        x = x.reshape(b, n, num_heads, c // num_heads)\n        return x.transpose(1, 2)  # B x N_heads x N_tokens x C_per_head\n\n    @staticmethod\n    def _recombine_heads(x: Tensor) -&gt; Tensor:\n        \"\"\"Recombine the separated attention heads into a single tensor.\"\"\"\n        b, n_heads, n_tokens, c_per_head = x.shape\n        x = x.transpose(1, 2)\n        return x.reshape(b, n_tokens, n_heads * c_per_head)  # B x N_tokens x C\n\n    def forward(self, q: Tensor, k: Tensor, v: Tensor) -&gt; Tensor:\n        \"\"\"Compute the attention output given the input query, key, and value tensors.\"\"\"\n\n        # Input projections\n        q = self.q_proj(q)\n        k = self.k_proj(k)\n        v = self.v_proj(v)\n\n        # Separate into heads\n        q = self._separate_heads(q, self.num_heads)\n        k = self._separate_heads(k, self.num_heads)\n        v = self._separate_heads(v, self.num_heads)\n\n        # Attention\n        _, _, _, c_per_head = q.shape\n        attn = q @ k.permute(0, 1, 3, 2)  # B x N_heads x N_tokens x N_tokens\n        attn = attn / math.sqrt(c_per_head)\n        attn = torch.softmax(attn, dim=-1)\n\n        # Get output\n        out = attn @ v\n        out = self._recombine_heads(out)\n        return self.out_proj(out)\n</code></pre>"},{"location":"reference/models/sam/modules/transformer/#ultralytics.models.sam.modules.transformer.Attention.__init__","title":"<code>__init__(embedding_dim, num_heads, downsample_rate=1)</code>","text":"<p>Initializes the Attention model with the given dimensions and settings.</p> <p>Parameters:</p> Name Type Description Default <code>embedding_dim</code> <code>int</code> <p>The dimensionality of the input embeddings.</p> required <code>num_heads</code> <code>int</code> <p>The number of attention heads.</p> required <code>downsample_rate</code> <code>int</code> <p>The factor by which the internal dimensions are downsampled. Defaults to 1.</p> <code>1</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If 'num_heads' does not evenly divide the internal dimension (embedding_dim / downsample_rate).</p> Source code in <code>ultralytics/models/sam/modules/transformer.py</code> <pre><code>def __init__(\n    self,\n    embedding_dim: int,\n    num_heads: int,\n    downsample_rate: int = 1,\n) -&gt; None:\n    \"\"\"\n    Initializes the Attention model with the given dimensions and settings.\n\n    Args:\n        embedding_dim (int): The dimensionality of the input embeddings.\n        num_heads (int): The number of attention heads.\n        downsample_rate (int, optional): The factor by which the internal dimensions are downsampled. Defaults to 1.\n\n    Raises:\n        AssertionError: If 'num_heads' does not evenly divide the internal dimension (embedding_dim / downsample_rate).\n    \"\"\"\n    super().__init__()\n    self.embedding_dim = embedding_dim\n    self.internal_dim = embedding_dim // downsample_rate\n    self.num_heads = num_heads\n    assert self.internal_dim % num_heads == 0, \"num_heads must divide embedding_dim.\"\n\n    self.q_proj = nn.Linear(embedding_dim, self.internal_dim)\n    self.k_proj = nn.Linear(embedding_dim, self.internal_dim)\n    self.v_proj = nn.Linear(embedding_dim, self.internal_dim)\n    self.out_proj = nn.Linear(self.internal_dim, embedding_dim)\n</code></pre>"},{"location":"reference/models/sam/modules/transformer/#ultralytics.models.sam.modules.transformer.Attention.forward","title":"<code>forward(q, k, v)</code>","text":"<p>Compute the attention output given the input query, key, and value tensors.</p> Source code in <code>ultralytics/models/sam/modules/transformer.py</code> <pre><code>def forward(self, q: Tensor, k: Tensor, v: Tensor) -&gt; Tensor:\n    \"\"\"Compute the attention output given the input query, key, and value tensors.\"\"\"\n\n    # Input projections\n    q = self.q_proj(q)\n    k = self.k_proj(k)\n    v = self.v_proj(v)\n\n    # Separate into heads\n    q = self._separate_heads(q, self.num_heads)\n    k = self._separate_heads(k, self.num_heads)\n    v = self._separate_heads(v, self.num_heads)\n\n    # Attention\n    _, _, _, c_per_head = q.shape\n    attn = q @ k.permute(0, 1, 3, 2)  # B x N_heads x N_tokens x N_tokens\n    attn = attn / math.sqrt(c_per_head)\n    attn = torch.softmax(attn, dim=-1)\n\n    # Get output\n    out = attn @ v\n    out = self._recombine_heads(out)\n    return self.out_proj(out)\n</code></pre>"},{"location":"reference/models/utils/loss/","title":"Reference for <code>ultralytics/models/utils/loss.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/utils/loss.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p>"},{"location":"reference/models/utils/loss/#ultralytics.models.utils.loss.DETRLoss","title":"<code>ultralytics.models.utils.loss.DETRLoss</code>","text":"<p>             Bases: <code>Module</code></p> <p>DETR (DEtection TRansformer) Loss class. This class calculates and returns the different loss components for the DETR object detection model. It computes classification loss, bounding box loss, GIoU loss, and optionally auxiliary losses.</p> <p>Attributes:</p> Name Type Description <code>nc</code> <code>int</code> <p>The number of classes.</p> <code>loss_gain</code> <code>dict</code> <p>Coefficients for different loss components.</p> <code>aux_loss</code> <code>bool</code> <p>Whether to compute auxiliary losses.</p> <code>use_fl</code> <code>bool</code> <p>Use FocalLoss or not.</p> <code>use_vfl</code> <code>bool</code> <p>Use VarifocalLoss or not.</p> <code>use_uni_match</code> <code>bool</code> <p>Whether to use a fixed layer to assign labels for the auxiliary branch.</p> <code>uni_match_ind</code> <code>int</code> <p>The fixed indices of a layer to use if <code>use_uni_match</code> is True.</p> <code>matcher</code> <code>HungarianMatcher</code> <p>Object to compute matching cost and indices.</p> <code>fl</code> <code>FocalLoss or None</code> <p>Focal Loss object if <code>use_fl</code> is True, otherwise None.</p> <code>vfl</code> <code>VarifocalLoss or None</code> <p>Varifocal Loss object if <code>use_vfl</code> is True, otherwise None.</p> <code>device</code> <code>device</code> <p>Device on which tensors are stored.</p> Source code in <code>ultralytics/models/utils/loss.py</code> <pre><code>class DETRLoss(nn.Module):\n    \"\"\"\n    DETR (DEtection TRansformer) Loss class. This class calculates and returns the different loss components for the\n    DETR object detection model. It computes classification loss, bounding box loss, GIoU loss, and optionally auxiliary\n    losses.\n\n    Attributes:\n        nc (int): The number of classes.\n        loss_gain (dict): Coefficients for different loss components.\n        aux_loss (bool): Whether to compute auxiliary losses.\n        use_fl (bool): Use FocalLoss or not.\n        use_vfl (bool): Use VarifocalLoss or not.\n        use_uni_match (bool): Whether to use a fixed layer to assign labels for the auxiliary branch.\n        uni_match_ind (int): The fixed indices of a layer to use if `use_uni_match` is True.\n        matcher (HungarianMatcher): Object to compute matching cost and indices.\n        fl (FocalLoss or None): Focal Loss object if `use_fl` is True, otherwise None.\n        vfl (VarifocalLoss or None): Varifocal Loss object if `use_vfl` is True, otherwise None.\n        device (torch.device): Device on which tensors are stored.\n    \"\"\"\n\n    def __init__(\n        self, nc=80, loss_gain=None, aux_loss=True, use_fl=True, use_vfl=False, use_uni_match=False, uni_match_ind=0\n    ):\n        \"\"\"\n        DETR loss function.\n\n        Args:\n            nc (int): The number of classes.\n            loss_gain (dict): The coefficient of loss.\n            aux_loss (bool): If 'aux_loss = True', loss at each decoder layer are to be used.\n            use_vfl (bool): Use VarifocalLoss or not.\n            use_uni_match (bool): Whether to use a fixed layer to assign labels for auxiliary branch.\n            uni_match_ind (int): The fixed indices of a layer.\n        \"\"\"\n        super().__init__()\n\n        if loss_gain is None:\n            loss_gain = {\"class\": 1, \"bbox\": 5, \"giou\": 2, \"no_object\": 0.1, \"mask\": 1, \"dice\": 1}\n        self.nc = nc\n        self.matcher = HungarianMatcher(cost_gain={\"class\": 2, \"bbox\": 5, \"giou\": 2})\n        self.loss_gain = loss_gain\n        self.aux_loss = aux_loss\n        self.fl = FocalLoss() if use_fl else None\n        self.vfl = VarifocalLoss() if use_vfl else None\n\n        self.use_uni_match = use_uni_match\n        self.uni_match_ind = uni_match_ind\n        self.device = None\n\n    def _get_loss_class(self, pred_scores, targets, gt_scores, num_gts, postfix=\"\"):\n        \"\"\"Computes the classification loss based on predictions, target values, and ground truth scores.\"\"\"\n        # Logits: [b, query, num_classes], gt_class: list[[n, 1]]\n        name_class = f\"loss_class{postfix}\"\n        bs, nq = pred_scores.shape[:2]\n        # one_hot = F.one_hot(targets, self.nc + 1)[..., :-1]  # (bs, num_queries, num_classes)\n        one_hot = torch.zeros((bs, nq, self.nc + 1), dtype=torch.int64, device=targets.device)\n        one_hot.scatter_(2, targets.unsqueeze(-1), 1)\n        one_hot = one_hot[..., :-1]\n        gt_scores = gt_scores.view(bs, nq, 1) * one_hot\n\n        if self.fl:\n            if num_gts and self.vfl:\n                loss_cls = self.vfl(pred_scores, gt_scores, one_hot)\n            else:\n                loss_cls = self.fl(pred_scores, one_hot.float())\n            loss_cls /= max(num_gts, 1) / nq\n        else:\n            loss_cls = nn.BCEWithLogitsLoss(reduction=\"none\")(pred_scores, gt_scores).mean(1).sum()  # YOLO CLS loss\n\n        return {name_class: loss_cls.squeeze() * self.loss_gain[\"class\"]}\n\n    def _get_loss_bbox(self, pred_bboxes, gt_bboxes, postfix=\"\"):\n        \"\"\"Calculates and returns the bounding box loss and GIoU loss for the predicted and ground truth bounding\n        boxes.\n        \"\"\"\n        # Boxes: [b, query, 4], gt_bbox: list[[n, 4]]\n        name_bbox = f\"loss_bbox{postfix}\"\n        name_giou = f\"loss_giou{postfix}\"\n\n        loss = {}\n        if len(gt_bboxes) == 0:\n            loss[name_bbox] = torch.tensor(0.0, device=self.device)\n            loss[name_giou] = torch.tensor(0.0, device=self.device)\n            return loss\n\n        loss[name_bbox] = self.loss_gain[\"bbox\"] * F.l1_loss(pred_bboxes, gt_bboxes, reduction=\"sum\") / len(gt_bboxes)\n        loss[name_giou] = 1.0 - bbox_iou(pred_bboxes, gt_bboxes, xywh=True, GIoU=True)\n        loss[name_giou] = loss[name_giou].sum() / len(gt_bboxes)\n        loss[name_giou] = self.loss_gain[\"giou\"] * loss[name_giou]\n        return {k: v.squeeze() for k, v in loss.items()}\n\n    # This function is for future RT-DETR Segment models\n    # def _get_loss_mask(self, masks, gt_mask, match_indices, postfix=''):\n    #     # masks: [b, query, h, w], gt_mask: list[[n, H, W]]\n    #     name_mask = f'loss_mask{postfix}'\n    #     name_dice = f'loss_dice{postfix}'\n    #\n    #     loss = {}\n    #     if sum(len(a) for a in gt_mask) == 0:\n    #         loss[name_mask] = torch.tensor(0., device=self.device)\n    #         loss[name_dice] = torch.tensor(0., device=self.device)\n    #         return loss\n    #\n    #     num_gts = len(gt_mask)\n    #     src_masks, target_masks = self._get_assigned_bboxes(masks, gt_mask, match_indices)\n    #     src_masks = F.interpolate(src_masks.unsqueeze(0), size=target_masks.shape[-2:], mode='bilinear')[0]\n    #     # TODO: torch does not have `sigmoid_focal_loss`, but it's not urgent since we don't use mask branch for now.\n    #     loss[name_mask] = self.loss_gain['mask'] * F.sigmoid_focal_loss(src_masks, target_masks,\n    #                                                                     torch.tensor([num_gts], dtype=torch.float32))\n    #     loss[name_dice] = self.loss_gain['dice'] * self._dice_loss(src_masks, target_masks, num_gts)\n    #     return loss\n\n    # This function is for future RT-DETR Segment models\n    # @staticmethod\n    # def _dice_loss(inputs, targets, num_gts):\n    #     inputs = F.sigmoid(inputs).flatten(1)\n    #     targets = targets.flatten(1)\n    #     numerator = 2 * (inputs * targets).sum(1)\n    #     denominator = inputs.sum(-1) + targets.sum(-1)\n    #     loss = 1 - (numerator + 1) / (denominator + 1)\n    #     return loss.sum() / num_gts\n\n    def _get_loss_aux(\n        self,\n        pred_bboxes,\n        pred_scores,\n        gt_bboxes,\n        gt_cls,\n        gt_groups,\n        match_indices=None,\n        postfix=\"\",\n        masks=None,\n        gt_mask=None,\n    ):\n        \"\"\"Get auxiliary losses.\"\"\"\n        # NOTE: loss class, bbox, giou, mask, dice\n        loss = torch.zeros(5 if masks is not None else 3, device=pred_bboxes.device)\n        if match_indices is None and self.use_uni_match:\n            match_indices = self.matcher(\n                pred_bboxes[self.uni_match_ind],\n                pred_scores[self.uni_match_ind],\n                gt_bboxes,\n                gt_cls,\n                gt_groups,\n                masks=masks[self.uni_match_ind] if masks is not None else None,\n                gt_mask=gt_mask,\n            )\n        for i, (aux_bboxes, aux_scores) in enumerate(zip(pred_bboxes, pred_scores)):\n            aux_masks = masks[i] if masks is not None else None\n            loss_ = self._get_loss(\n                aux_bboxes,\n                aux_scores,\n                gt_bboxes,\n                gt_cls,\n                gt_groups,\n                masks=aux_masks,\n                gt_mask=gt_mask,\n                postfix=postfix,\n                match_indices=match_indices,\n            )\n            loss[0] += loss_[f\"loss_class{postfix}\"]\n            loss[1] += loss_[f\"loss_bbox{postfix}\"]\n            loss[2] += loss_[f\"loss_giou{postfix}\"]\n            # if masks is not None and gt_mask is not None:\n            #     loss_ = self._get_loss_mask(aux_masks, gt_mask, match_indices, postfix)\n            #     loss[3] += loss_[f'loss_mask{postfix}']\n            #     loss[4] += loss_[f'loss_dice{postfix}']\n\n        loss = {\n            f\"loss_class_aux{postfix}\": loss[0],\n            f\"loss_bbox_aux{postfix}\": loss[1],\n            f\"loss_giou_aux{postfix}\": loss[2],\n        }\n        # if masks is not None and gt_mask is not None:\n        #     loss[f'loss_mask_aux{postfix}'] = loss[3]\n        #     loss[f'loss_dice_aux{postfix}'] = loss[4]\n        return loss\n\n    @staticmethod\n    def _get_index(match_indices):\n        \"\"\"Returns batch indices, source indices, and destination indices from provided match indices.\"\"\"\n        batch_idx = torch.cat([torch.full_like(src, i) for i, (src, _) in enumerate(match_indices)])\n        src_idx = torch.cat([src for (src, _) in match_indices])\n        dst_idx = torch.cat([dst for (_, dst) in match_indices])\n        return (batch_idx, src_idx), dst_idx\n\n    def _get_assigned_bboxes(self, pred_bboxes, gt_bboxes, match_indices):\n        \"\"\"Assigns predicted bounding boxes to ground truth bounding boxes based on the match indices.\"\"\"\n        pred_assigned = torch.cat(\n            [\n                t[I] if len(I) &gt; 0 else torch.zeros(0, t.shape[-1], device=self.device)\n                for t, (I, _) in zip(pred_bboxes, match_indices)\n            ]\n        )\n        gt_assigned = torch.cat(\n            [\n                t[J] if len(J) &gt; 0 else torch.zeros(0, t.shape[-1], device=self.device)\n                for t, (_, J) in zip(gt_bboxes, match_indices)\n            ]\n        )\n        return pred_assigned, gt_assigned\n\n    def _get_loss(\n        self,\n        pred_bboxes,\n        pred_scores,\n        gt_bboxes,\n        gt_cls,\n        gt_groups,\n        masks=None,\n        gt_mask=None,\n        postfix=\"\",\n        match_indices=None,\n    ):\n        \"\"\"Get losses.\"\"\"\n        if match_indices is None:\n            match_indices = self.matcher(\n                pred_bboxes, pred_scores, gt_bboxes, gt_cls, gt_groups, masks=masks, gt_mask=gt_mask\n            )\n\n        idx, gt_idx = self._get_index(match_indices)\n        pred_bboxes, gt_bboxes = pred_bboxes[idx], gt_bboxes[gt_idx]\n\n        bs, nq = pred_scores.shape[:2]\n        targets = torch.full((bs, nq), self.nc, device=pred_scores.device, dtype=gt_cls.dtype)\n        targets[idx] = gt_cls[gt_idx]\n\n        gt_scores = torch.zeros([bs, nq], device=pred_scores.device)\n        if len(gt_bboxes):\n            gt_scores[idx] = bbox_iou(pred_bboxes.detach(), gt_bboxes, xywh=True).squeeze(-1)\n\n        loss = {}\n        loss.update(self._get_loss_class(pred_scores, targets, gt_scores, len(gt_bboxes), postfix))\n        loss.update(self._get_loss_bbox(pred_bboxes, gt_bboxes, postfix))\n        # if masks is not None and gt_mask is not None:\n        #     loss.update(self._get_loss_mask(masks, gt_mask, match_indices, postfix))\n        return loss\n\n    def forward(self, pred_bboxes, pred_scores, batch, postfix=\"\", **kwargs):\n        \"\"\"\n        Args:\n            pred_bboxes (torch.Tensor): [l, b, query, 4]\n            pred_scores (torch.Tensor): [l, b, query, num_classes]\n            batch (dict): A dict includes:\n                gt_cls (torch.Tensor) with shape [num_gts, ],\n                gt_bboxes (torch.Tensor): [num_gts, 4],\n                gt_groups (List(int)): a list of batch size length includes the number of gts of each image.\n            postfix (str): postfix of loss name.\n        \"\"\"\n        self.device = pred_bboxes.device\n        match_indices = kwargs.get(\"match_indices\", None)\n        gt_cls, gt_bboxes, gt_groups = batch[\"cls\"], batch[\"bboxes\"], batch[\"gt_groups\"]\n\n        total_loss = self._get_loss(\n            pred_bboxes[-1], pred_scores[-1], gt_bboxes, gt_cls, gt_groups, postfix=postfix, match_indices=match_indices\n        )\n\n        if self.aux_loss:\n            total_loss.update(\n                self._get_loss_aux(\n                    pred_bboxes[:-1], pred_scores[:-1], gt_bboxes, gt_cls, gt_groups, match_indices, postfix\n                )\n            )\n\n        return total_loss\n</code></pre>"},{"location":"reference/models/utils/loss/#ultralytics.models.utils.loss.DETRLoss.__init__","title":"<code>__init__(nc=80, loss_gain=None, aux_loss=True, use_fl=True, use_vfl=False, use_uni_match=False, uni_match_ind=0)</code>","text":"<p>DETR loss function.</p> <p>Parameters:</p> Name Type Description Default <code>nc</code> <code>int</code> <p>The number of classes.</p> <code>80</code> <code>loss_gain</code> <code>dict</code> <p>The coefficient of loss.</p> <code>None</code> <code>aux_loss</code> <code>bool</code> <p>If 'aux_loss = True', loss at each decoder layer are to be used.</p> <code>True</code> <code>use_vfl</code> <code>bool</code> <p>Use VarifocalLoss or not.</p> <code>False</code> <code>use_uni_match</code> <code>bool</code> <p>Whether to use a fixed layer to assign labels for auxiliary branch.</p> <code>False</code> <code>uni_match_ind</code> <code>int</code> <p>The fixed indices of a layer.</p> <code>0</code> Source code in <code>ultralytics/models/utils/loss.py</code> <pre><code>def __init__(\n    self, nc=80, loss_gain=None, aux_loss=True, use_fl=True, use_vfl=False, use_uni_match=False, uni_match_ind=0\n):\n    \"\"\"\n    DETR loss function.\n\n    Args:\n        nc (int): The number of classes.\n        loss_gain (dict): The coefficient of loss.\n        aux_loss (bool): If 'aux_loss = True', loss at each decoder layer are to be used.\n        use_vfl (bool): Use VarifocalLoss or not.\n        use_uni_match (bool): Whether to use a fixed layer to assign labels for auxiliary branch.\n        uni_match_ind (int): The fixed indices of a layer.\n    \"\"\"\n    super().__init__()\n\n    if loss_gain is None:\n        loss_gain = {\"class\": 1, \"bbox\": 5, \"giou\": 2, \"no_object\": 0.1, \"mask\": 1, \"dice\": 1}\n    self.nc = nc\n    self.matcher = HungarianMatcher(cost_gain={\"class\": 2, \"bbox\": 5, \"giou\": 2})\n    self.loss_gain = loss_gain\n    self.aux_loss = aux_loss\n    self.fl = FocalLoss() if use_fl else None\n    self.vfl = VarifocalLoss() if use_vfl else None\n\n    self.use_uni_match = use_uni_match\n    self.uni_match_ind = uni_match_ind\n    self.device = None\n</code></pre>"},{"location":"reference/models/utils/loss/#ultralytics.models.utils.loss.DETRLoss.forward","title":"<code>forward(pred_bboxes, pred_scores, batch, postfix='', **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>pred_bboxes</code> <code>Tensor</code> <p>[l, b, query, 4]</p> required <code>pred_scores</code> <code>Tensor</code> <p>[l, b, query, num_classes]</p> required <code>batch</code> <code>dict</code> <p>A dict includes: gt_cls (torch.Tensor) with shape [num_gts, ], gt_bboxes (torch.Tensor): [num_gts, 4], gt_groups (List(int)): a list of batch size length includes the number of gts of each image.</p> required <code>postfix</code> <code>str</code> <p>postfix of loss name.</p> <code>''</code> Source code in <code>ultralytics/models/utils/loss.py</code> <pre><code>def forward(self, pred_bboxes, pred_scores, batch, postfix=\"\", **kwargs):\n    \"\"\"\n    Args:\n        pred_bboxes (torch.Tensor): [l, b, query, 4]\n        pred_scores (torch.Tensor): [l, b, query, num_classes]\n        batch (dict): A dict includes:\n            gt_cls (torch.Tensor) with shape [num_gts, ],\n            gt_bboxes (torch.Tensor): [num_gts, 4],\n            gt_groups (List(int)): a list of batch size length includes the number of gts of each image.\n        postfix (str): postfix of loss name.\n    \"\"\"\n    self.device = pred_bboxes.device\n    match_indices = kwargs.get(\"match_indices\", None)\n    gt_cls, gt_bboxes, gt_groups = batch[\"cls\"], batch[\"bboxes\"], batch[\"gt_groups\"]\n\n    total_loss = self._get_loss(\n        pred_bboxes[-1], pred_scores[-1], gt_bboxes, gt_cls, gt_groups, postfix=postfix, match_indices=match_indices\n    )\n\n    if self.aux_loss:\n        total_loss.update(\n            self._get_loss_aux(\n                pred_bboxes[:-1], pred_scores[:-1], gt_bboxes, gt_cls, gt_groups, match_indices, postfix\n            )\n        )\n\n    return total_loss\n</code></pre>"},{"location":"reference/models/utils/loss/#ultralytics.models.utils.loss.RTDETRDetectionLoss","title":"<code>ultralytics.models.utils.loss.RTDETRDetectionLoss</code>","text":"<p>             Bases: <code>DETRLoss</code></p> <p>Real-Time DeepTracker (RT-DETR) Detection Loss class that extends the DETRLoss.</p> <p>This class computes the detection loss for the RT-DETR model, which includes the standard detection loss as well as an additional denoising training loss when provided with denoising metadata.</p> Source code in <code>ultralytics/models/utils/loss.py</code> <pre><code>class RTDETRDetectionLoss(DETRLoss):\n    \"\"\"\n    Real-Time DeepTracker (RT-DETR) Detection Loss class that extends the DETRLoss.\n\n    This class computes the detection loss for the RT-DETR model, which includes the standard detection loss as well as\n    an additional denoising training loss when provided with denoising metadata.\n    \"\"\"\n\n    def forward(self, preds, batch, dn_bboxes=None, dn_scores=None, dn_meta=None):\n        \"\"\"\n        Forward pass to compute the detection loss.\n\n        Args:\n            preds (tuple): Predicted bounding boxes and scores.\n            batch (dict): Batch data containing ground truth information.\n            dn_bboxes (torch.Tensor, optional): Denoising bounding boxes. Default is None.\n            dn_scores (torch.Tensor, optional): Denoising scores. Default is None.\n            dn_meta (dict, optional): Metadata for denoising. Default is None.\n\n        Returns:\n            (dict): Dictionary containing the total loss and, if applicable, the denoising loss.\n        \"\"\"\n        pred_bboxes, pred_scores = preds\n        total_loss = super().forward(pred_bboxes, pred_scores, batch)\n\n        # Check for denoising metadata to compute denoising training loss\n        if dn_meta is not None:\n            dn_pos_idx, dn_num_group = dn_meta[\"dn_pos_idx\"], dn_meta[\"dn_num_group\"]\n            assert len(batch[\"gt_groups\"]) == len(dn_pos_idx)\n\n            # Get the match indices for denoising\n            match_indices = self.get_dn_match_indices(dn_pos_idx, dn_num_group, batch[\"gt_groups\"])\n\n            # Compute the denoising training loss\n            dn_loss = super().forward(dn_bboxes, dn_scores, batch, postfix=\"_dn\", match_indices=match_indices)\n            total_loss.update(dn_loss)\n        else:\n            # If no denoising metadata is provided, set denoising loss to zero\n            total_loss.update({f\"{k}_dn\": torch.tensor(0.0, device=self.device) for k in total_loss.keys()})\n\n        return total_loss\n\n    @staticmethod\n    def get_dn_match_indices(dn_pos_idx, dn_num_group, gt_groups):\n        \"\"\"\n        Get the match indices for denoising.\n\n        Args:\n            dn_pos_idx (List[torch.Tensor]): List of tensors containing positive indices for denoising.\n            dn_num_group (int): Number of denoising groups.\n            gt_groups (List[int]): List of integers representing the number of ground truths for each image.\n\n        Returns:\n            (List[tuple]): List of tuples containing matched indices for denoising.\n        \"\"\"\n        dn_match_indices = []\n        idx_groups = torch.as_tensor([0, *gt_groups[:-1]]).cumsum_(0)\n        for i, num_gt in enumerate(gt_groups):\n            if num_gt &gt; 0:\n                gt_idx = torch.arange(end=num_gt, dtype=torch.long) + idx_groups[i]\n                gt_idx = gt_idx.repeat(dn_num_group)\n                assert len(dn_pos_idx[i]) == len(gt_idx), \"Expected the same length, \"\n                f\"but got {len(dn_pos_idx[i])} and {len(gt_idx)} respectively.\"\n                dn_match_indices.append((dn_pos_idx[i], gt_idx))\n            else:\n                dn_match_indices.append((torch.zeros([0], dtype=torch.long), torch.zeros([0], dtype=torch.long)))\n        return dn_match_indices\n</code></pre>"},{"location":"reference/models/utils/loss/#ultralytics.models.utils.loss.RTDETRDetectionLoss.forward","title":"<code>forward(preds, batch, dn_bboxes=None, dn_scores=None, dn_meta=None)</code>","text":"<p>Forward pass to compute the detection loss.</p> <p>Parameters:</p> Name Type Description Default <code>preds</code> <code>tuple</code> <p>Predicted bounding boxes and scores.</p> required <code>batch</code> <code>dict</code> <p>Batch data containing ground truth information.</p> required <code>dn_bboxes</code> <code>Tensor</code> <p>Denoising bounding boxes. Default is None.</p> <code>None</code> <code>dn_scores</code> <code>Tensor</code> <p>Denoising scores. Default is None.</p> <code>None</code> <code>dn_meta</code> <code>dict</code> <p>Metadata for denoising. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing the total loss and, if applicable, the denoising loss.</p> Source code in <code>ultralytics/models/utils/loss.py</code> <pre><code>def forward(self, preds, batch, dn_bboxes=None, dn_scores=None, dn_meta=None):\n    \"\"\"\n    Forward pass to compute the detection loss.\n\n    Args:\n        preds (tuple): Predicted bounding boxes and scores.\n        batch (dict): Batch data containing ground truth information.\n        dn_bboxes (torch.Tensor, optional): Denoising bounding boxes. Default is None.\n        dn_scores (torch.Tensor, optional): Denoising scores. Default is None.\n        dn_meta (dict, optional): Metadata for denoising. Default is None.\n\n    Returns:\n        (dict): Dictionary containing the total loss and, if applicable, the denoising loss.\n    \"\"\"\n    pred_bboxes, pred_scores = preds\n    total_loss = super().forward(pred_bboxes, pred_scores, batch)\n\n    # Check for denoising metadata to compute denoising training loss\n    if dn_meta is not None:\n        dn_pos_idx, dn_num_group = dn_meta[\"dn_pos_idx\"], dn_meta[\"dn_num_group\"]\n        assert len(batch[\"gt_groups\"]) == len(dn_pos_idx)\n\n        # Get the match indices for denoising\n        match_indices = self.get_dn_match_indices(dn_pos_idx, dn_num_group, batch[\"gt_groups\"])\n\n        # Compute the denoising training loss\n        dn_loss = super().forward(dn_bboxes, dn_scores, batch, postfix=\"_dn\", match_indices=match_indices)\n        total_loss.update(dn_loss)\n    else:\n        # If no denoising metadata is provided, set denoising loss to zero\n        total_loss.update({f\"{k}_dn\": torch.tensor(0.0, device=self.device) for k in total_loss.keys()})\n\n    return total_loss\n</code></pre>"},{"location":"reference/models/utils/loss/#ultralytics.models.utils.loss.RTDETRDetectionLoss.get_dn_match_indices","title":"<code>get_dn_match_indices(dn_pos_idx, dn_num_group, gt_groups)</code>  <code>staticmethod</code>","text":"<p>Get the match indices for denoising.</p> <p>Parameters:</p> Name Type Description Default <code>dn_pos_idx</code> <code>List[Tensor]</code> <p>List of tensors containing positive indices for denoising.</p> required <code>dn_num_group</code> <code>int</code> <p>Number of denoising groups.</p> required <code>gt_groups</code> <code>List[int]</code> <p>List of integers representing the number of ground truths for each image.</p> required <p>Returns:</p> Type Description <code>List[tuple]</code> <p>List of tuples containing matched indices for denoising.</p> Source code in <code>ultralytics/models/utils/loss.py</code> <pre><code>@staticmethod\ndef get_dn_match_indices(dn_pos_idx, dn_num_group, gt_groups):\n    \"\"\"\n    Get the match indices for denoising.\n\n    Args:\n        dn_pos_idx (List[torch.Tensor]): List of tensors containing positive indices for denoising.\n        dn_num_group (int): Number of denoising groups.\n        gt_groups (List[int]): List of integers representing the number of ground truths for each image.\n\n    Returns:\n        (List[tuple]): List of tuples containing matched indices for denoising.\n    \"\"\"\n    dn_match_indices = []\n    idx_groups = torch.as_tensor([0, *gt_groups[:-1]]).cumsum_(0)\n    for i, num_gt in enumerate(gt_groups):\n        if num_gt &gt; 0:\n            gt_idx = torch.arange(end=num_gt, dtype=torch.long) + idx_groups[i]\n            gt_idx = gt_idx.repeat(dn_num_group)\n            assert len(dn_pos_idx[i]) == len(gt_idx), \"Expected the same length, \"\n            f\"but got {len(dn_pos_idx[i])} and {len(gt_idx)} respectively.\"\n            dn_match_indices.append((dn_pos_idx[i], gt_idx))\n        else:\n            dn_match_indices.append((torch.zeros([0], dtype=torch.long), torch.zeros([0], dtype=torch.long)))\n    return dn_match_indices\n</code></pre>"},{"location":"reference/models/utils/ops/","title":"Reference for <code>ultralytics/models/utils/ops.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/utils/ops.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p>"},{"location":"reference/models/utils/ops/#ultralytics.models.utils.ops.HungarianMatcher","title":"<code>ultralytics.models.utils.ops.HungarianMatcher</code>","text":"<p>             Bases: <code>Module</code></p> <p>A module implementing the HungarianMatcher, which is a differentiable module to solve the assignment problem in an end-to-end fashion.</p> <p>HungarianMatcher performs optimal assignment over the predicted and ground truth bounding boxes using a cost function that considers classification scores, bounding box coordinates, and optionally, mask predictions.</p> <p>Attributes:</p> Name Type Description <code>cost_gain</code> <code>dict</code> <p>Dictionary of cost coefficients: 'class', 'bbox', 'giou', 'mask', and 'dice'.</p> <code>use_fl</code> <code>bool</code> <p>Indicates whether to use Focal Loss for the classification cost calculation.</p> <code>with_mask</code> <code>bool</code> <p>Indicates whether the model makes mask predictions.</p> <code>num_sample_points</code> <code>int</code> <p>The number of sample points used in mask cost calculation.</p> <code>alpha</code> <code>float</code> <p>The alpha factor in Focal Loss calculation.</p> <code>gamma</code> <code>float</code> <p>The gamma factor in Focal Loss calculation.</p> <p>Methods:</p> Name Description <code>forward</code> <p>Computes the assignment between predictions and ground truths for a batch.</p> <code>_cost_mask</code> <p>Computes the mask cost and dice cost if masks are predicted.</p> Source code in <code>ultralytics/models/utils/ops.py</code> <pre><code>class HungarianMatcher(nn.Module):\n    \"\"\"\n    A module implementing the HungarianMatcher, which is a differentiable module to solve the assignment problem in an\n    end-to-end fashion.\n\n    HungarianMatcher performs optimal assignment over the predicted and ground truth bounding boxes using a cost\n    function that considers classification scores, bounding box coordinates, and optionally, mask predictions.\n\n    Attributes:\n        cost_gain (dict): Dictionary of cost coefficients: 'class', 'bbox', 'giou', 'mask', and 'dice'.\n        use_fl (bool): Indicates whether to use Focal Loss for the classification cost calculation.\n        with_mask (bool): Indicates whether the model makes mask predictions.\n        num_sample_points (int): The number of sample points used in mask cost calculation.\n        alpha (float): The alpha factor in Focal Loss calculation.\n        gamma (float): The gamma factor in Focal Loss calculation.\n\n    Methods:\n        forward(pred_bboxes, pred_scores, gt_bboxes, gt_cls, gt_groups, masks=None, gt_mask=None): Computes the\n            assignment between predictions and ground truths for a batch.\n        _cost_mask(bs, num_gts, masks=None, gt_mask=None): Computes the mask cost and dice cost if masks are predicted.\n    \"\"\"\n\n    def __init__(self, cost_gain=None, use_fl=True, with_mask=False, num_sample_points=12544, alpha=0.25, gamma=2.0):\n        \"\"\"Initializes HungarianMatcher with cost coefficients, Focal Loss, mask prediction, sample points, and alpha\n        gamma factors.\n        \"\"\"\n        super().__init__()\n        if cost_gain is None:\n            cost_gain = {\"class\": 1, \"bbox\": 5, \"giou\": 2, \"mask\": 1, \"dice\": 1}\n        self.cost_gain = cost_gain\n        self.use_fl = use_fl\n        self.with_mask = with_mask\n        self.num_sample_points = num_sample_points\n        self.alpha = alpha\n        self.gamma = gamma\n\n    def forward(self, pred_bboxes, pred_scores, gt_bboxes, gt_cls, gt_groups, masks=None, gt_mask=None):\n        \"\"\"\n        Forward pass for HungarianMatcher. This function computes costs based on prediction and ground truth\n        (classification cost, L1 cost between boxes and GIoU cost between boxes) and finds the optimal matching between\n        predictions and ground truth based on these costs.\n\n        Args:\n            pred_bboxes (Tensor): Predicted bounding boxes with shape [batch_size, num_queries, 4].\n            pred_scores (Tensor): Predicted scores with shape [batch_size, num_queries, num_classes].\n            gt_cls (torch.Tensor): Ground truth classes with shape [num_gts, ].\n            gt_bboxes (torch.Tensor): Ground truth bounding boxes with shape [num_gts, 4].\n            gt_groups (List[int]): List of length equal to batch size, containing the number of ground truths for\n                each image.\n            masks (Tensor, optional): Predicted masks with shape [batch_size, num_queries, height, width].\n                Defaults to None.\n            gt_mask (List[Tensor], optional): List of ground truth masks, each with shape [num_masks, Height, Width].\n                Defaults to None.\n\n        Returns:\n            (List[Tuple[Tensor, Tensor]]): A list of size batch_size, each element is a tuple (index_i, index_j), where:\n                - index_i is the tensor of indices of the selected predictions (in order)\n                - index_j is the tensor of indices of the corresponding selected ground truth targets (in order)\n                For each batch element, it holds:\n                    len(index_i) = len(index_j) = min(num_queries, num_target_boxes)\n        \"\"\"\n\n        bs, nq, nc = pred_scores.shape\n\n        if sum(gt_groups) == 0:\n            return [(torch.tensor([], dtype=torch.long), torch.tensor([], dtype=torch.long)) for _ in range(bs)]\n\n        # We flatten to compute the cost matrices in a batch\n        # [batch_size * num_queries, num_classes]\n        pred_scores = pred_scores.detach().view(-1, nc)\n        pred_scores = F.sigmoid(pred_scores) if self.use_fl else F.softmax(pred_scores, dim=-1)\n        # [batch_size * num_queries, 4]\n        pred_bboxes = pred_bboxes.detach().view(-1, 4)\n\n        # Compute the classification cost\n        pred_scores = pred_scores[:, gt_cls]\n        if self.use_fl:\n            neg_cost_class = (1 - self.alpha) * (pred_scores**self.gamma) * (-(1 - pred_scores + 1e-8).log())\n            pos_cost_class = self.alpha * ((1 - pred_scores) ** self.gamma) * (-(pred_scores + 1e-8).log())\n            cost_class = pos_cost_class - neg_cost_class\n        else:\n            cost_class = -pred_scores\n\n        # Compute the L1 cost between boxes\n        cost_bbox = (pred_bboxes.unsqueeze(1) - gt_bboxes.unsqueeze(0)).abs().sum(-1)  # (bs*num_queries, num_gt)\n\n        # Compute the GIoU cost between boxes, (bs*num_queries, num_gt)\n        cost_giou = 1.0 - bbox_iou(pred_bboxes.unsqueeze(1), gt_bboxes.unsqueeze(0), xywh=True, GIoU=True).squeeze(-1)\n\n        # Final cost matrix\n        C = (\n            self.cost_gain[\"class\"] * cost_class\n            + self.cost_gain[\"bbox\"] * cost_bbox\n            + self.cost_gain[\"giou\"] * cost_giou\n        )\n        # Compute the mask cost and dice cost\n        if self.with_mask:\n            C += self._cost_mask(bs, gt_groups, masks, gt_mask)\n\n        # Set invalid values (NaNs and infinities) to 0 (fixes ValueError: matrix contains invalid numeric entries)\n        C[C.isnan() | C.isinf()] = 0.0\n\n        C = C.view(bs, nq, -1).cpu()\n        indices = [linear_sum_assignment(c[i]) for i, c in enumerate(C.split(gt_groups, -1))]\n        gt_groups = torch.as_tensor([0, *gt_groups[:-1]]).cumsum_(0)  # (idx for queries, idx for gt)\n        return [\n            (torch.tensor(i, dtype=torch.long), torch.tensor(j, dtype=torch.long) + gt_groups[k])\n            for k, (i, j) in enumerate(indices)\n        ]\n</code></pre>"},{"location":"reference/models/utils/ops/#ultralytics.models.utils.ops.HungarianMatcher.__init__","title":"<code>__init__(cost_gain=None, use_fl=True, with_mask=False, num_sample_points=12544, alpha=0.25, gamma=2.0)</code>","text":"<p>Initializes HungarianMatcher with cost coefficients, Focal Loss, mask prediction, sample points, and alpha gamma factors.</p> Source code in <code>ultralytics/models/utils/ops.py</code> <pre><code>def __init__(self, cost_gain=None, use_fl=True, with_mask=False, num_sample_points=12544, alpha=0.25, gamma=2.0):\n    \"\"\"Initializes HungarianMatcher with cost coefficients, Focal Loss, mask prediction, sample points, and alpha\n    gamma factors.\n    \"\"\"\n    super().__init__()\n    if cost_gain is None:\n        cost_gain = {\"class\": 1, \"bbox\": 5, \"giou\": 2, \"mask\": 1, \"dice\": 1}\n    self.cost_gain = cost_gain\n    self.use_fl = use_fl\n    self.with_mask = with_mask\n    self.num_sample_points = num_sample_points\n    self.alpha = alpha\n    self.gamma = gamma\n</code></pre>"},{"location":"reference/models/utils/ops/#ultralytics.models.utils.ops.HungarianMatcher.forward","title":"<code>forward(pred_bboxes, pred_scores, gt_bboxes, gt_cls, gt_groups, masks=None, gt_mask=None)</code>","text":"<p>Forward pass for HungarianMatcher. This function computes costs based on prediction and ground truth (classification cost, L1 cost between boxes and GIoU cost between boxes) and finds the optimal matching between predictions and ground truth based on these costs.</p> <p>Parameters:</p> Name Type Description Default <code>pred_bboxes</code> <code>Tensor</code> <p>Predicted bounding boxes with shape [batch_size, num_queries, 4].</p> required <code>pred_scores</code> <code>Tensor</code> <p>Predicted scores with shape [batch_size, num_queries, num_classes].</p> required <code>gt_cls</code> <code>Tensor</code> <p>Ground truth classes with shape [num_gts, ].</p> required <code>gt_bboxes</code> <code>Tensor</code> <p>Ground truth bounding boxes with shape [num_gts, 4].</p> required <code>gt_groups</code> <code>List[int]</code> <p>List of length equal to batch size, containing the number of ground truths for each image.</p> required <code>masks</code> <code>Tensor</code> <p>Predicted masks with shape [batch_size, num_queries, height, width]. Defaults to None.</p> <code>None</code> <code>gt_mask</code> <code>List[Tensor]</code> <p>List of ground truth masks, each with shape [num_masks, Height, Width]. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Tuple[Tensor, Tensor]]</code> <p>A list of size batch_size, each element is a tuple (index_i, index_j), where: - index_i is the tensor of indices of the selected predictions (in order) - index_j is the tensor of indices of the corresponding selected ground truth targets (in order) For each batch element, it holds:     len(index_i) = len(index_j) = min(num_queries, num_target_boxes)</p> Source code in <code>ultralytics/models/utils/ops.py</code> <pre><code>def forward(self, pred_bboxes, pred_scores, gt_bboxes, gt_cls, gt_groups, masks=None, gt_mask=None):\n    \"\"\"\n    Forward pass for HungarianMatcher. This function computes costs based on prediction and ground truth\n    (classification cost, L1 cost between boxes and GIoU cost between boxes) and finds the optimal matching between\n    predictions and ground truth based on these costs.\n\n    Args:\n        pred_bboxes (Tensor): Predicted bounding boxes with shape [batch_size, num_queries, 4].\n        pred_scores (Tensor): Predicted scores with shape [batch_size, num_queries, num_classes].\n        gt_cls (torch.Tensor): Ground truth classes with shape [num_gts, ].\n        gt_bboxes (torch.Tensor): Ground truth bounding boxes with shape [num_gts, 4].\n        gt_groups (List[int]): List of length equal to batch size, containing the number of ground truths for\n            each image.\n        masks (Tensor, optional): Predicted masks with shape [batch_size, num_queries, height, width].\n            Defaults to None.\n        gt_mask (List[Tensor], optional): List of ground truth masks, each with shape [num_masks, Height, Width].\n            Defaults to None.\n\n    Returns:\n        (List[Tuple[Tensor, Tensor]]): A list of size batch_size, each element is a tuple (index_i, index_j), where:\n            - index_i is the tensor of indices of the selected predictions (in order)\n            - index_j is the tensor of indices of the corresponding selected ground truth targets (in order)\n            For each batch element, it holds:\n                len(index_i) = len(index_j) = min(num_queries, num_target_boxes)\n    \"\"\"\n\n    bs, nq, nc = pred_scores.shape\n\n    if sum(gt_groups) == 0:\n        return [(torch.tensor([], dtype=torch.long), torch.tensor([], dtype=torch.long)) for _ in range(bs)]\n\n    # We flatten to compute the cost matrices in a batch\n    # [batch_size * num_queries, num_classes]\n    pred_scores = pred_scores.detach().view(-1, nc)\n    pred_scores = F.sigmoid(pred_scores) if self.use_fl else F.softmax(pred_scores, dim=-1)\n    # [batch_size * num_queries, 4]\n    pred_bboxes = pred_bboxes.detach().view(-1, 4)\n\n    # Compute the classification cost\n    pred_scores = pred_scores[:, gt_cls]\n    if self.use_fl:\n        neg_cost_class = (1 - self.alpha) * (pred_scores**self.gamma) * (-(1 - pred_scores + 1e-8).log())\n        pos_cost_class = self.alpha * ((1 - pred_scores) ** self.gamma) * (-(pred_scores + 1e-8).log())\n        cost_class = pos_cost_class - neg_cost_class\n    else:\n        cost_class = -pred_scores\n\n    # Compute the L1 cost between boxes\n    cost_bbox = (pred_bboxes.unsqueeze(1) - gt_bboxes.unsqueeze(0)).abs().sum(-1)  # (bs*num_queries, num_gt)\n\n    # Compute the GIoU cost between boxes, (bs*num_queries, num_gt)\n    cost_giou = 1.0 - bbox_iou(pred_bboxes.unsqueeze(1), gt_bboxes.unsqueeze(0), xywh=True, GIoU=True).squeeze(-1)\n\n    # Final cost matrix\n    C = (\n        self.cost_gain[\"class\"] * cost_class\n        + self.cost_gain[\"bbox\"] * cost_bbox\n        + self.cost_gain[\"giou\"] * cost_giou\n    )\n    # Compute the mask cost and dice cost\n    if self.with_mask:\n        C += self._cost_mask(bs, gt_groups, masks, gt_mask)\n\n    # Set invalid values (NaNs and infinities) to 0 (fixes ValueError: matrix contains invalid numeric entries)\n    C[C.isnan() | C.isinf()] = 0.0\n\n    C = C.view(bs, nq, -1).cpu()\n    indices = [linear_sum_assignment(c[i]) for i, c in enumerate(C.split(gt_groups, -1))]\n    gt_groups = torch.as_tensor([0, *gt_groups[:-1]]).cumsum_(0)  # (idx for queries, idx for gt)\n    return [\n        (torch.tensor(i, dtype=torch.long), torch.tensor(j, dtype=torch.long) + gt_groups[k])\n        for k, (i, j) in enumerate(indices)\n    ]\n</code></pre>"},{"location":"reference/models/utils/ops/#ultralytics.models.utils.ops.get_cdn_group","title":"<code>ultralytics.models.utils.ops.get_cdn_group(batch, num_classes, num_queries, class_embed, num_dn=100, cls_noise_ratio=0.5, box_noise_scale=1.0, training=False)</code>","text":"<p>Get contrastive denoising training group. This function creates a contrastive denoising training group with positive and negative samples from the ground truths (gt). It applies noise to the class labels and bounding box coordinates, and returns the modified labels, bounding boxes, attention mask and meta information.</p> <p>Parameters:</p> Name Type Description Default <code>batch</code> <code>dict</code> <p>A dict that includes 'gt_cls' (torch.Tensor with shape [num_gts, ]), 'gt_bboxes' (torch.Tensor with shape [num_gts, 4]), 'gt_groups' (List(int)) which is a list of batch size length indicating the number of gts of each image.</p> required <code>num_classes</code> <code>int</code> <p>Number of classes.</p> required <code>num_queries</code> <code>int</code> <p>Number of queries.</p> required <code>class_embed</code> <code>Tensor</code> <p>Embedding weights to map class labels to embedding space.</p> required <code>num_dn</code> <code>int</code> <p>Number of denoising. Defaults to 100.</p> <code>100</code> <code>cls_noise_ratio</code> <code>float</code> <p>Noise ratio for class labels. Defaults to 0.5.</p> <code>0.5</code> <code>box_noise_scale</code> <code>float</code> <p>Noise scale for bounding box coordinates. Defaults to 1.0.</p> <code>1.0</code> <code>training</code> <code>bool</code> <p>If it's in training mode. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple[Optional[Tensor], Optional[Tensor], Optional[Tensor], Optional[Dict]]</code> <p>The modified class embeddings, bounding boxes, attention mask and meta information for denoising. If not in training mode or 'num_dn' is less than or equal to 0, the function returns None for all elements in the tuple.</p> Source code in <code>ultralytics/models/utils/ops.py</code> <pre><code>def get_cdn_group(\n    batch, num_classes, num_queries, class_embed, num_dn=100, cls_noise_ratio=0.5, box_noise_scale=1.0, training=False\n):\n    \"\"\"\n    Get contrastive denoising training group. This function creates a contrastive denoising training group with positive\n    and negative samples from the ground truths (gt). It applies noise to the class labels and bounding box coordinates,\n    and returns the modified labels, bounding boxes, attention mask and meta information.\n\n    Args:\n        batch (dict): A dict that includes 'gt_cls' (torch.Tensor with shape [num_gts, ]), 'gt_bboxes'\n            (torch.Tensor with shape [num_gts, 4]), 'gt_groups' (List(int)) which is a list of batch size length\n            indicating the number of gts of each image.\n        num_classes (int): Number of classes.\n        num_queries (int): Number of queries.\n        class_embed (torch.Tensor): Embedding weights to map class labels to embedding space.\n        num_dn (int, optional): Number of denoising. Defaults to 100.\n        cls_noise_ratio (float, optional): Noise ratio for class labels. Defaults to 0.5.\n        box_noise_scale (float, optional): Noise scale for bounding box coordinates. Defaults to 1.0.\n        training (bool, optional): If it's in training mode. Defaults to False.\n\n    Returns:\n        (Tuple[Optional[Tensor], Optional[Tensor], Optional[Tensor], Optional[Dict]]): The modified class embeddings,\n            bounding boxes, attention mask and meta information for denoising. If not in training mode or 'num_dn'\n            is less than or equal to 0, the function returns None for all elements in the tuple.\n    \"\"\"\n\n    if (not training) or num_dn &lt;= 0:\n        return None, None, None, None\n    gt_groups = batch[\"gt_groups\"]\n    total_num = sum(gt_groups)\n    max_nums = max(gt_groups)\n    if max_nums == 0:\n        return None, None, None, None\n\n    num_group = num_dn // max_nums\n    num_group = 1 if num_group == 0 else num_group\n    # Pad gt to max_num of a batch\n    bs = len(gt_groups)\n    gt_cls = batch[\"cls\"]  # (bs*num, )\n    gt_bbox = batch[\"bboxes\"]  # bs*num, 4\n    b_idx = batch[\"batch_idx\"]\n\n    # Each group has positive and negative queries.\n    dn_cls = gt_cls.repeat(2 * num_group)  # (2*num_group*bs*num, )\n    dn_bbox = gt_bbox.repeat(2 * num_group, 1)  # 2*num_group*bs*num, 4\n    dn_b_idx = b_idx.repeat(2 * num_group).view(-1)  # (2*num_group*bs*num, )\n\n    # Positive and negative mask\n    # (bs*num*num_group, ), the second total_num*num_group part as negative samples\n    neg_idx = torch.arange(total_num * num_group, dtype=torch.long, device=gt_bbox.device) + num_group * total_num\n\n    if cls_noise_ratio &gt; 0:\n        # Half of bbox prob\n        mask = torch.rand(dn_cls.shape) &lt; (cls_noise_ratio * 0.5)\n        idx = torch.nonzero(mask).squeeze(-1)\n        # Randomly put a new one here\n        new_label = torch.randint_like(idx, 0, num_classes, dtype=dn_cls.dtype, device=dn_cls.device)\n        dn_cls[idx] = new_label\n\n    if box_noise_scale &gt; 0:\n        known_bbox = xywh2xyxy(dn_bbox)\n\n        diff = (dn_bbox[..., 2:] * 0.5).repeat(1, 2) * box_noise_scale  # 2*num_group*bs*num, 4\n\n        rand_sign = torch.randint_like(dn_bbox, 0, 2) * 2.0 - 1.0\n        rand_part = torch.rand_like(dn_bbox)\n        rand_part[neg_idx] += 1.0\n        rand_part *= rand_sign\n        known_bbox += rand_part * diff\n        known_bbox.clip_(min=0.0, max=1.0)\n        dn_bbox = xyxy2xywh(known_bbox)\n        dn_bbox = torch.logit(dn_bbox, eps=1e-6)  # inverse sigmoid\n\n    num_dn = int(max_nums * 2 * num_group)  # total denoising queries\n    # class_embed = torch.cat([class_embed, torch.zeros([1, class_embed.shape[-1]], device=class_embed.device)])\n    dn_cls_embed = class_embed[dn_cls]  # bs*num * 2 * num_group, 256\n    padding_cls = torch.zeros(bs, num_dn, dn_cls_embed.shape[-1], device=gt_cls.device)\n    padding_bbox = torch.zeros(bs, num_dn, 4, device=gt_bbox.device)\n\n    map_indices = torch.cat([torch.tensor(range(num), dtype=torch.long) for num in gt_groups])\n    pos_idx = torch.stack([map_indices + max_nums * i for i in range(num_group)], dim=0)\n\n    map_indices = torch.cat([map_indices + max_nums * i for i in range(2 * num_group)])\n    padding_cls[(dn_b_idx, map_indices)] = dn_cls_embed\n    padding_bbox[(dn_b_idx, map_indices)] = dn_bbox\n\n    tgt_size = num_dn + num_queries\n    attn_mask = torch.zeros([tgt_size, tgt_size], dtype=torch.bool)\n    # Match query cannot see the reconstruct\n    attn_mask[num_dn:, :num_dn] = True\n    # Reconstruct cannot see each other\n    for i in range(num_group):\n        if i == 0:\n            attn_mask[max_nums * 2 * i : max_nums * 2 * (i + 1), max_nums * 2 * (i + 1) : num_dn] = True\n        if i == num_group - 1:\n            attn_mask[max_nums * 2 * i : max_nums * 2 * (i + 1), : max_nums * i * 2] = True\n        else:\n            attn_mask[max_nums * 2 * i : max_nums * 2 * (i + 1), max_nums * 2 * (i + 1) : num_dn] = True\n            attn_mask[max_nums * 2 * i : max_nums * 2 * (i + 1), : max_nums * 2 * i] = True\n    dn_meta = {\n        \"dn_pos_idx\": [p.reshape(-1) for p in pos_idx.cpu().split(list(gt_groups), dim=1)],\n        \"dn_num_group\": num_group,\n        \"dn_num_split\": [num_dn, num_queries],\n    }\n\n    return (\n        padding_cls.to(class_embed.device),\n        padding_bbox.to(class_embed.device),\n        attn_mask.to(class_embed.device),\n        dn_meta,\n    )\n</code></pre>"},{"location":"reference/models/yolo/model/","title":"Reference for <code>ultralytics/models/yolo/model.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/yolo/model.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/yolo/model/#ultralytics.models.yolo.model.YOLO","title":"<code>ultralytics.models.yolo.model.YOLO</code>","text":"<p>             Bases: <code>Model</code></p> <p>YOLO (You Only Look Once) object detection model.</p> Source code in <code>ultralytics/models/yolo/model.py</code> <pre><code>class YOLO(Model):\n    \"\"\"YOLO (You Only Look Once) object detection model.\"\"\"\n\n    @property\n    def task_map(self):\n        \"\"\"Map head to model, trainer, validator, and predictor classes.\"\"\"\n        return {\n            \"classify\": {\n                \"model\": ClassificationModel,\n                \"trainer\": yolo.classify.ClassificationTrainer,\n                \"validator\": yolo.classify.ClassificationValidator,\n                \"predictor\": yolo.classify.ClassificationPredictor,\n            },\n            \"detect\": {\n                \"model\": DetectionModel,\n                \"trainer\": yolo.detect.DetectionTrainer,\n                \"validator\": yolo.detect.DetectionValidator,\n                \"predictor\": yolo.detect.DetectionPredictor,\n            },\n            \"segment\": {\n                \"model\": SegmentationModel,\n                \"trainer\": yolo.segment.SegmentationTrainer,\n                \"validator\": yolo.segment.SegmentationValidator,\n                \"predictor\": yolo.segment.SegmentationPredictor,\n            },\n            \"pose\": {\n                \"model\": PoseModel,\n                \"trainer\": yolo.pose.PoseTrainer,\n                \"validator\": yolo.pose.PoseValidator,\n                \"predictor\": yolo.pose.PosePredictor,\n            },\n            \"obb\": {\n                \"model\": OBBModel,\n                \"trainer\": yolo.obb.OBBTrainer,\n                \"validator\": yolo.obb.OBBValidator,\n                \"predictor\": yolo.obb.OBBPredictor,\n            },\n        }\n</code></pre>"},{"location":"reference/models/yolo/model/#ultralytics.models.yolo.model.YOLO.task_map","title":"<code>task_map</code>  <code>property</code>","text":"<p>Map head to model, trainer, validator, and predictor classes.</p>"},{"location":"reference/models/yolo/classify/predict/","title":"Reference for <code>ultralytics/models/yolo/classify/predict.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/yolo/classify/predict.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/yolo/classify/predict/#ultralytics.models.yolo.classify.predict.ClassificationPredictor","title":"<code>ultralytics.models.yolo.classify.predict.ClassificationPredictor</code>","text":"<p>             Bases: <code>BasePredictor</code></p> <p>A class extending the BasePredictor class for prediction based on a classification model.</p> Notes <ul> <li>Torchvision classification models can also be passed to the 'model' argument, i.e. model='resnet18'.</li> </ul> Example <pre><code>from ultralytics.utils import ASSETS\nfrom ultralytics.models.yolo.classify import ClassificationPredictor\n\nargs = dict(model='yolov8n-cls.pt', source=ASSETS)\npredictor = ClassificationPredictor(overrides=args)\npredictor.predict_cli()\n</code></pre> Source code in <code>ultralytics/models/yolo/classify/predict.py</code> <pre><code>class ClassificationPredictor(BasePredictor):\n    \"\"\"\n    A class extending the BasePredictor class for prediction based on a classification model.\n\n    Notes:\n        - Torchvision classification models can also be passed to the 'model' argument, i.e. model='resnet18'.\n\n    Example:\n        ```python\n        from ultralytics.utils import ASSETS\n        from ultralytics.models.yolo.classify import ClassificationPredictor\n\n        args = dict(model='yolov8n-cls.pt', source=ASSETS)\n        predictor = ClassificationPredictor(overrides=args)\n        predictor.predict_cli()\n        ```\n    \"\"\"\n\n    def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n        \"\"\"Initializes ClassificationPredictor setting the task to 'classify'.\"\"\"\n        super().__init__(cfg, overrides, _callbacks)\n        self.args.task = \"classify\"\n        self._legacy_transform_name = \"ultralytics.yolo.data.augment.ToTensor\"\n\n    def preprocess(self, img):\n        \"\"\"Converts input image to model-compatible data type.\"\"\"\n        if not isinstance(img, torch.Tensor):\n            is_legacy_transform = any(\n                self._legacy_transform_name in str(transform) for transform in self.transforms.transforms\n            )\n            if is_legacy_transform:  # to handle legacy transforms\n                img = torch.stack([self.transforms(im) for im in img], dim=0)\n            else:\n                img = torch.stack(\n                    [self.transforms(Image.fromarray(cv2.cvtColor(im, cv2.COLOR_BGR2RGB))) for im in img], dim=0\n                )\n        img = (img if isinstance(img, torch.Tensor) else torch.from_numpy(img)).to(self.model.device)\n        return img.half() if self.model.fp16 else img.float()  # uint8 to fp16/32\n\n    def postprocess(self, preds, img, orig_imgs):\n        \"\"\"Post-processes predictions to return Results objects.\"\"\"\n        if not isinstance(orig_imgs, list):  # input images are a torch.Tensor, not a list\n            orig_imgs = ops.convert_torch2numpy_batch(orig_imgs)\n\n        results = []\n        for i, pred in enumerate(preds):\n            orig_img = orig_imgs[i]\n            img_path = self.batch[0][i]\n            results.append(Results(orig_img, path=img_path, names=self.model.names, probs=pred))\n        return results\n</code></pre>"},{"location":"reference/models/yolo/classify/predict/#ultralytics.models.yolo.classify.predict.ClassificationPredictor.__init__","title":"<code>__init__(cfg=DEFAULT_CFG, overrides=None, _callbacks=None)</code>","text":"<p>Initializes ClassificationPredictor setting the task to 'classify'.</p> Source code in <code>ultralytics/models/yolo/classify/predict.py</code> <pre><code>def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n    \"\"\"Initializes ClassificationPredictor setting the task to 'classify'.\"\"\"\n    super().__init__(cfg, overrides, _callbacks)\n    self.args.task = \"classify\"\n    self._legacy_transform_name = \"ultralytics.yolo.data.augment.ToTensor\"\n</code></pre>"},{"location":"reference/models/yolo/classify/predict/#ultralytics.models.yolo.classify.predict.ClassificationPredictor.postprocess","title":"<code>postprocess(preds, img, orig_imgs)</code>","text":"<p>Post-processes predictions to return Results objects.</p> Source code in <code>ultralytics/models/yolo/classify/predict.py</code> <pre><code>def postprocess(self, preds, img, orig_imgs):\n    \"\"\"Post-processes predictions to return Results objects.\"\"\"\n    if not isinstance(orig_imgs, list):  # input images are a torch.Tensor, not a list\n        orig_imgs = ops.convert_torch2numpy_batch(orig_imgs)\n\n    results = []\n    for i, pred in enumerate(preds):\n        orig_img = orig_imgs[i]\n        img_path = self.batch[0][i]\n        results.append(Results(orig_img, path=img_path, names=self.model.names, probs=pred))\n    return results\n</code></pre>"},{"location":"reference/models/yolo/classify/predict/#ultralytics.models.yolo.classify.predict.ClassificationPredictor.preprocess","title":"<code>preprocess(img)</code>","text":"<p>Converts input image to model-compatible data type.</p> Source code in <code>ultralytics/models/yolo/classify/predict.py</code> <pre><code>def preprocess(self, img):\n    \"\"\"Converts input image to model-compatible data type.\"\"\"\n    if not isinstance(img, torch.Tensor):\n        is_legacy_transform = any(\n            self._legacy_transform_name in str(transform) for transform in self.transforms.transforms\n        )\n        if is_legacy_transform:  # to handle legacy transforms\n            img = torch.stack([self.transforms(im) for im in img], dim=0)\n        else:\n            img = torch.stack(\n                [self.transforms(Image.fromarray(cv2.cvtColor(im, cv2.COLOR_BGR2RGB))) for im in img], dim=0\n            )\n    img = (img if isinstance(img, torch.Tensor) else torch.from_numpy(img)).to(self.model.device)\n    return img.half() if self.model.fp16 else img.float()  # uint8 to fp16/32\n</code></pre>"},{"location":"reference/models/yolo/classify/train/","title":"Reference for <code>ultralytics/models/yolo/classify/train.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/yolo/classify/train.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/yolo/classify/train/#ultralytics.models.yolo.classify.train.ClassificationTrainer","title":"<code>ultralytics.models.yolo.classify.train.ClassificationTrainer</code>","text":"<p>             Bases: <code>BaseTrainer</code></p> <p>A class extending the BaseTrainer class for training based on a classification model.</p> Notes <ul> <li>Torchvision classification models can also be passed to the 'model' argument, i.e. model='resnet18'.</li> </ul> Example <pre><code>from ultralytics.models.yolo.classify import ClassificationTrainer\n\nargs = dict(model='yolov8n-cls.pt', data='imagenet10', epochs=3)\ntrainer = ClassificationTrainer(overrides=args)\ntrainer.train()\n</code></pre> Source code in <code>ultralytics/models/yolo/classify/train.py</code> <pre><code>class ClassificationTrainer(BaseTrainer):\n    \"\"\"\n    A class extending the BaseTrainer class for training based on a classification model.\n\n    Notes:\n        - Torchvision classification models can also be passed to the 'model' argument, i.e. model='resnet18'.\n\n    Example:\n        ```python\n        from ultralytics.models.yolo.classify import ClassificationTrainer\n\n        args = dict(model='yolov8n-cls.pt', data='imagenet10', epochs=3)\n        trainer = ClassificationTrainer(overrides=args)\n        trainer.train()\n        ```\n    \"\"\"\n\n    def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n        \"\"\"Initialize a ClassificationTrainer object with optional configuration overrides and callbacks.\"\"\"\n        if overrides is None:\n            overrides = {}\n        overrides[\"task\"] = \"classify\"\n        if overrides.get(\"imgsz\") is None:\n            overrides[\"imgsz\"] = 224\n        super().__init__(cfg, overrides, _callbacks)\n\n    def set_model_attributes(self):\n        \"\"\"Set the YOLO model's class names from the loaded dataset.\"\"\"\n        self.model.names = self.data[\"names\"]\n\n    def get_model(self, cfg=None, weights=None, verbose=True):\n        \"\"\"Returns a modified PyTorch model configured for training YOLO.\"\"\"\n        model = ClassificationModel(cfg, nc=self.data[\"nc\"], verbose=verbose and RANK == -1)\n        if weights:\n            model.load(weights)\n\n        for m in model.modules():\n            if not self.args.pretrained and hasattr(m, \"reset_parameters\"):\n                m.reset_parameters()\n            if isinstance(m, torch.nn.Dropout) and self.args.dropout:\n                m.p = self.args.dropout  # set dropout\n        for p in model.parameters():\n            p.requires_grad = True  # for training\n        return model\n\n    def setup_model(self):\n        \"\"\"Load, create or download model for any task.\"\"\"\n        if isinstance(self.model, torch.nn.Module):  # if model is loaded beforehand. No setup needed\n            return\n\n        model, ckpt = str(self.model), None\n        # Load a YOLO model locally, from torchvision, or from Ultralytics assets\n        if model.endswith(\".pt\"):\n            self.model, ckpt = attempt_load_one_weight(model, device=\"cpu\")\n            for p in self.model.parameters():\n                p.requires_grad = True  # for training\n        elif model.split(\".\")[-1] in (\"yaml\", \"yml\"):\n            self.model = self.get_model(cfg=model)\n        elif model in torchvision.models.__dict__:\n            self.model = torchvision.models.__dict__[model](weights=\"IMAGENET1K_V1\" if self.args.pretrained else None)\n        else:\n            FileNotFoundError(f\"ERROR: model={model} not found locally or online. Please check model name.\")\n        ClassificationModel.reshape_outputs(self.model, self.data[\"nc\"])\n\n        return ckpt\n\n    def build_dataset(self, img_path, mode=\"train\", batch=None):\n        \"\"\"Creates a ClassificationDataset instance given an image path, and mode (train/test etc.).\"\"\"\n        return ClassificationDataset(root=img_path, args=self.args, augment=mode == \"train\", prefix=mode)\n\n    def get_dataloader(self, dataset_path, batch_size=16, rank=0, mode=\"train\"):\n        \"\"\"Returns PyTorch DataLoader with transforms to preprocess images for inference.\"\"\"\n        with torch_distributed_zero_first(rank):  # init dataset *.cache only once if DDP\n            dataset = self.build_dataset(dataset_path, mode)\n\n        loader = build_dataloader(dataset, batch_size, self.args.workers, rank=rank)\n        # Attach inference transforms\n        if mode != \"train\":\n            if is_parallel(self.model):\n                self.model.module.transforms = loader.dataset.torch_transforms\n            else:\n                self.model.transforms = loader.dataset.torch_transforms\n        return loader\n\n    def preprocess_batch(self, batch):\n        \"\"\"Preprocesses a batch of images and classes.\"\"\"\n        batch[\"img\"] = batch[\"img\"].to(self.device)\n        batch[\"cls\"] = batch[\"cls\"].to(self.device)\n        return batch\n\n    def progress_string(self):\n        \"\"\"Returns a formatted string showing training progress.\"\"\"\n        return (\"\\n\" + \"%11s\" * (4 + len(self.loss_names))) % (\n            \"Epoch\",\n            \"GPU_mem\",\n            *self.loss_names,\n            \"Instances\",\n            \"Size\",\n        )\n\n    def get_validator(self):\n        \"\"\"Returns an instance of ClassificationValidator for validation.\"\"\"\n        self.loss_names = [\"loss\"]\n        return yolo.classify.ClassificationValidator(self.test_loader, self.save_dir, _callbacks=self.callbacks)\n\n    def label_loss_items(self, loss_items=None, prefix=\"train\"):\n        \"\"\"\n        Returns a loss dict with labelled training loss items tensor.\n\n        Not needed for classification but necessary for segmentation &amp; detection\n        \"\"\"\n        keys = [f\"{prefix}/{x}\" for x in self.loss_names]\n        if loss_items is None:\n            return keys\n        loss_items = [round(float(loss_items), 5)]\n        return dict(zip(keys, loss_items))\n\n    def plot_metrics(self):\n        \"\"\"Plots metrics from a CSV file.\"\"\"\n        plot_results(file=self.csv, classify=True, on_plot=self.on_plot)  # save results.png\n\n    def final_eval(self):\n        \"\"\"Evaluate trained model and save validation results.\"\"\"\n        for f in self.last, self.best:\n            if f.exists():\n                strip_optimizer(f)  # strip optimizers\n                if f is self.best:\n                    LOGGER.info(f\"\\nValidating {f}...\")\n                    self.validator.args.data = self.args.data\n                    self.validator.args.plots = self.args.plots\n                    self.metrics = self.validator(model=f)\n                    self.metrics.pop(\"fitness\", None)\n                    self.run_callbacks(\"on_fit_epoch_end\")\n        LOGGER.info(f\"Results saved to {colorstr('bold', self.save_dir)}\")\n\n    def plot_training_samples(self, batch, ni):\n        \"\"\"Plots training samples with their annotations.\"\"\"\n        plot_images(\n            images=batch[\"img\"],\n            batch_idx=torch.arange(len(batch[\"img\"])),\n            cls=batch[\"cls\"].view(-1),  # warning: use .view(), not .squeeze() for Classify models\n            fname=self.save_dir / f\"train_batch{ni}.jpg\",\n            on_plot=self.on_plot,\n        )\n</code></pre>"},{"location":"reference/models/yolo/classify/train/#ultralytics.models.yolo.classify.train.ClassificationTrainer.__init__","title":"<code>__init__(cfg=DEFAULT_CFG, overrides=None, _callbacks=None)</code>","text":"<p>Initialize a ClassificationTrainer object with optional configuration overrides and callbacks.</p> Source code in <code>ultralytics/models/yolo/classify/train.py</code> <pre><code>def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n    \"\"\"Initialize a ClassificationTrainer object with optional configuration overrides and callbacks.\"\"\"\n    if overrides is None:\n        overrides = {}\n    overrides[\"task\"] = \"classify\"\n    if overrides.get(\"imgsz\") is None:\n        overrides[\"imgsz\"] = 224\n    super().__init__(cfg, overrides, _callbacks)\n</code></pre>"},{"location":"reference/models/yolo/classify/train/#ultralytics.models.yolo.classify.train.ClassificationTrainer.build_dataset","title":"<code>build_dataset(img_path, mode='train', batch=None)</code>","text":"<p>Creates a ClassificationDataset instance given an image path, and mode (train/test etc.).</p> Source code in <code>ultralytics/models/yolo/classify/train.py</code> <pre><code>def build_dataset(self, img_path, mode=\"train\", batch=None):\n    \"\"\"Creates a ClassificationDataset instance given an image path, and mode (train/test etc.).\"\"\"\n    return ClassificationDataset(root=img_path, args=self.args, augment=mode == \"train\", prefix=mode)\n</code></pre>"},{"location":"reference/models/yolo/classify/train/#ultralytics.models.yolo.classify.train.ClassificationTrainer.final_eval","title":"<code>final_eval()</code>","text":"<p>Evaluate trained model and save validation results.</p> Source code in <code>ultralytics/models/yolo/classify/train.py</code> <pre><code>def final_eval(self):\n    \"\"\"Evaluate trained model and save validation results.\"\"\"\n    for f in self.last, self.best:\n        if f.exists():\n            strip_optimizer(f)  # strip optimizers\n            if f is self.best:\n                LOGGER.info(f\"\\nValidating {f}...\")\n                self.validator.args.data = self.args.data\n                self.validator.args.plots = self.args.plots\n                self.metrics = self.validator(model=f)\n                self.metrics.pop(\"fitness\", None)\n                self.run_callbacks(\"on_fit_epoch_end\")\n    LOGGER.info(f\"Results saved to {colorstr('bold', self.save_dir)}\")\n</code></pre>"},{"location":"reference/models/yolo/classify/train/#ultralytics.models.yolo.classify.train.ClassificationTrainer.get_dataloader","title":"<code>get_dataloader(dataset_path, batch_size=16, rank=0, mode='train')</code>","text":"<p>Returns PyTorch DataLoader with transforms to preprocess images for inference.</p> Source code in <code>ultralytics/models/yolo/classify/train.py</code> <pre><code>def get_dataloader(self, dataset_path, batch_size=16, rank=0, mode=\"train\"):\n    \"\"\"Returns PyTorch DataLoader with transforms to preprocess images for inference.\"\"\"\n    with torch_distributed_zero_first(rank):  # init dataset *.cache only once if DDP\n        dataset = self.build_dataset(dataset_path, mode)\n\n    loader = build_dataloader(dataset, batch_size, self.args.workers, rank=rank)\n    # Attach inference transforms\n    if mode != \"train\":\n        if is_parallel(self.model):\n            self.model.module.transforms = loader.dataset.torch_transforms\n        else:\n            self.model.transforms = loader.dataset.torch_transforms\n    return loader\n</code></pre>"},{"location":"reference/models/yolo/classify/train/#ultralytics.models.yolo.classify.train.ClassificationTrainer.get_model","title":"<code>get_model(cfg=None, weights=None, verbose=True)</code>","text":"<p>Returns a modified PyTorch model configured for training YOLO.</p> Source code in <code>ultralytics/models/yolo/classify/train.py</code> <pre><code>def get_model(self, cfg=None, weights=None, verbose=True):\n    \"\"\"Returns a modified PyTorch model configured for training YOLO.\"\"\"\n    model = ClassificationModel(cfg, nc=self.data[\"nc\"], verbose=verbose and RANK == -1)\n    if weights:\n        model.load(weights)\n\n    for m in model.modules():\n        if not self.args.pretrained and hasattr(m, \"reset_parameters\"):\n            m.reset_parameters()\n        if isinstance(m, torch.nn.Dropout) and self.args.dropout:\n            m.p = self.args.dropout  # set dropout\n    for p in model.parameters():\n        p.requires_grad = True  # for training\n    return model\n</code></pre>"},{"location":"reference/models/yolo/classify/train/#ultralytics.models.yolo.classify.train.ClassificationTrainer.get_validator","title":"<code>get_validator()</code>","text":"<p>Returns an instance of ClassificationValidator for validation.</p> Source code in <code>ultralytics/models/yolo/classify/train.py</code> <pre><code>def get_validator(self):\n    \"\"\"Returns an instance of ClassificationValidator for validation.\"\"\"\n    self.loss_names = [\"loss\"]\n    return yolo.classify.ClassificationValidator(self.test_loader, self.save_dir, _callbacks=self.callbacks)\n</code></pre>"},{"location":"reference/models/yolo/classify/train/#ultralytics.models.yolo.classify.train.ClassificationTrainer.label_loss_items","title":"<code>label_loss_items(loss_items=None, prefix='train')</code>","text":"<p>Returns a loss dict with labelled training loss items tensor.</p> <p>Not needed for classification but necessary for segmentation &amp; detection</p> Source code in <code>ultralytics/models/yolo/classify/train.py</code> <pre><code>def label_loss_items(self, loss_items=None, prefix=\"train\"):\n    \"\"\"\n    Returns a loss dict with labelled training loss items tensor.\n\n    Not needed for classification but necessary for segmentation &amp; detection\n    \"\"\"\n    keys = [f\"{prefix}/{x}\" for x in self.loss_names]\n    if loss_items is None:\n        return keys\n    loss_items = [round(float(loss_items), 5)]\n    return dict(zip(keys, loss_items))\n</code></pre>"},{"location":"reference/models/yolo/classify/train/#ultralytics.models.yolo.classify.train.ClassificationTrainer.plot_metrics","title":"<code>plot_metrics()</code>","text":"<p>Plots metrics from a CSV file.</p> Source code in <code>ultralytics/models/yolo/classify/train.py</code> <pre><code>def plot_metrics(self):\n    \"\"\"Plots metrics from a CSV file.\"\"\"\n    plot_results(file=self.csv, classify=True, on_plot=self.on_plot)  # save results.png\n</code></pre>"},{"location":"reference/models/yolo/classify/train/#ultralytics.models.yolo.classify.train.ClassificationTrainer.plot_training_samples","title":"<code>plot_training_samples(batch, ni)</code>","text":"<p>Plots training samples with their annotations.</p> Source code in <code>ultralytics/models/yolo/classify/train.py</code> <pre><code>def plot_training_samples(self, batch, ni):\n    \"\"\"Plots training samples with their annotations.\"\"\"\n    plot_images(\n        images=batch[\"img\"],\n        batch_idx=torch.arange(len(batch[\"img\"])),\n        cls=batch[\"cls\"].view(-1),  # warning: use .view(), not .squeeze() for Classify models\n        fname=self.save_dir / f\"train_batch{ni}.jpg\",\n        on_plot=self.on_plot,\n    )\n</code></pre>"},{"location":"reference/models/yolo/classify/train/#ultralytics.models.yolo.classify.train.ClassificationTrainer.preprocess_batch","title":"<code>preprocess_batch(batch)</code>","text":"<p>Preprocesses a batch of images and classes.</p> Source code in <code>ultralytics/models/yolo/classify/train.py</code> <pre><code>def preprocess_batch(self, batch):\n    \"\"\"Preprocesses a batch of images and classes.\"\"\"\n    batch[\"img\"] = batch[\"img\"].to(self.device)\n    batch[\"cls\"] = batch[\"cls\"].to(self.device)\n    return batch\n</code></pre>"},{"location":"reference/models/yolo/classify/train/#ultralytics.models.yolo.classify.train.ClassificationTrainer.progress_string","title":"<code>progress_string()</code>","text":"<p>Returns a formatted string showing training progress.</p> Source code in <code>ultralytics/models/yolo/classify/train.py</code> <pre><code>def progress_string(self):\n    \"\"\"Returns a formatted string showing training progress.\"\"\"\n    return (\"\\n\" + \"%11s\" * (4 + len(self.loss_names))) % (\n        \"Epoch\",\n        \"GPU_mem\",\n        *self.loss_names,\n        \"Instances\",\n        \"Size\",\n    )\n</code></pre>"},{"location":"reference/models/yolo/classify/train/#ultralytics.models.yolo.classify.train.ClassificationTrainer.set_model_attributes","title":"<code>set_model_attributes()</code>","text":"<p>Set the YOLO model's class names from the loaded dataset.</p> Source code in <code>ultralytics/models/yolo/classify/train.py</code> <pre><code>def set_model_attributes(self):\n    \"\"\"Set the YOLO model's class names from the loaded dataset.\"\"\"\n    self.model.names = self.data[\"names\"]\n</code></pre>"},{"location":"reference/models/yolo/classify/train/#ultralytics.models.yolo.classify.train.ClassificationTrainer.setup_model","title":"<code>setup_model()</code>","text":"<p>Load, create or download model for any task.</p> Source code in <code>ultralytics/models/yolo/classify/train.py</code> <pre><code>def setup_model(self):\n    \"\"\"Load, create or download model for any task.\"\"\"\n    if isinstance(self.model, torch.nn.Module):  # if model is loaded beforehand. No setup needed\n        return\n\n    model, ckpt = str(self.model), None\n    # Load a YOLO model locally, from torchvision, or from Ultralytics assets\n    if model.endswith(\".pt\"):\n        self.model, ckpt = attempt_load_one_weight(model, device=\"cpu\")\n        for p in self.model.parameters():\n            p.requires_grad = True  # for training\n    elif model.split(\".\")[-1] in (\"yaml\", \"yml\"):\n        self.model = self.get_model(cfg=model)\n    elif model in torchvision.models.__dict__:\n        self.model = torchvision.models.__dict__[model](weights=\"IMAGENET1K_V1\" if self.args.pretrained else None)\n    else:\n        FileNotFoundError(f\"ERROR: model={model} not found locally or online. Please check model name.\")\n    ClassificationModel.reshape_outputs(self.model, self.data[\"nc\"])\n\n    return ckpt\n</code></pre>"},{"location":"reference/models/yolo/classify/val/","title":"Reference for <code>ultralytics/models/yolo/classify/val.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/yolo/classify/val.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/yolo/classify/val/#ultralytics.models.yolo.classify.val.ClassificationValidator","title":"<code>ultralytics.models.yolo.classify.val.ClassificationValidator</code>","text":"<p>             Bases: <code>BaseValidator</code></p> <p>A class extending the BaseValidator class for validation based on a classification model.</p> Notes <ul> <li>Torchvision classification models can also be passed to the 'model' argument, i.e. model='resnet18'.</li> </ul> Example <pre><code>from ultralytics.models.yolo.classify import ClassificationValidator\n\nargs = dict(model='yolov8n-cls.pt', data='imagenet10')\nvalidator = ClassificationValidator(args=args)\nvalidator()\n</code></pre> Source code in <code>ultralytics/models/yolo/classify/val.py</code> <pre><code>class ClassificationValidator(BaseValidator):\n    \"\"\"\n    A class extending the BaseValidator class for validation based on a classification model.\n\n    Notes:\n        - Torchvision classification models can also be passed to the 'model' argument, i.e. model='resnet18'.\n\n    Example:\n        ```python\n        from ultralytics.models.yolo.classify import ClassificationValidator\n\n        args = dict(model='yolov8n-cls.pt', data='imagenet10')\n        validator = ClassificationValidator(args=args)\n        validator()\n        ```\n    \"\"\"\n\n    def __init__(self, dataloader=None, save_dir=None, pbar=None, args=None, _callbacks=None):\n        \"\"\"Initializes ClassificationValidator instance with args, dataloader, save_dir, and progress bar.\"\"\"\n        super().__init__(dataloader, save_dir, pbar, args, _callbacks)\n        self.targets = None\n        self.pred = None\n        self.args.task = \"classify\"\n        self.metrics = ClassifyMetrics()\n\n    def get_desc(self):\n        \"\"\"Returns a formatted string summarizing classification metrics.\"\"\"\n        return (\"%22s\" + \"%11s\" * 2) % (\"classes\", \"top1_acc\", \"top5_acc\")\n\n    def init_metrics(self, model):\n        \"\"\"Initialize confusion matrix, class names, and top-1 and top-5 accuracy.\"\"\"\n        self.names = model.names\n        self.nc = len(model.names)\n        self.confusion_matrix = ConfusionMatrix(nc=self.nc, conf=self.args.conf, task=\"classify\")\n        self.pred = []\n        self.targets = []\n\n    def preprocess(self, batch):\n        \"\"\"Preprocesses input batch and returns it.\"\"\"\n        batch[\"img\"] = batch[\"img\"].to(self.device, non_blocking=True)\n        batch[\"img\"] = batch[\"img\"].half() if self.args.half else batch[\"img\"].float()\n        batch[\"cls\"] = batch[\"cls\"].to(self.device)\n        return batch\n\n    def update_metrics(self, preds, batch):\n        \"\"\"Updates running metrics with model predictions and batch targets.\"\"\"\n        n5 = min(len(self.names), 5)\n        self.pred.append(preds.argsort(1, descending=True)[:, :n5])\n        self.targets.append(batch[\"cls\"])\n\n    def finalize_metrics(self, *args, **kwargs):\n        \"\"\"Finalizes metrics of the model such as confusion_matrix and speed.\"\"\"\n        self.confusion_matrix.process_cls_preds(self.pred, self.targets)\n        if self.args.plots:\n            for normalize in True, False:\n                self.confusion_matrix.plot(\n                    save_dir=self.save_dir, names=self.names.values(), normalize=normalize, on_plot=self.on_plot\n                )\n        self.metrics.speed = self.speed\n        self.metrics.confusion_matrix = self.confusion_matrix\n        self.metrics.save_dir = self.save_dir\n\n    def get_stats(self):\n        \"\"\"Returns a dictionary of metrics obtained by processing targets and predictions.\"\"\"\n        self.metrics.process(self.targets, self.pred)\n        return self.metrics.results_dict\n\n    def build_dataset(self, img_path):\n        \"\"\"Creates and returns a ClassificationDataset instance using given image path and preprocessing parameters.\"\"\"\n        return ClassificationDataset(root=img_path, args=self.args, augment=False, prefix=self.args.split)\n\n    def get_dataloader(self, dataset_path, batch_size):\n        \"\"\"Builds and returns a data loader for classification tasks with given parameters.\"\"\"\n        dataset = self.build_dataset(dataset_path)\n        return build_dataloader(dataset, batch_size, self.args.workers, rank=-1)\n\n    def print_results(self):\n        \"\"\"Prints evaluation metrics for YOLO object detection model.\"\"\"\n        pf = \"%22s\" + \"%11.3g\" * len(self.metrics.keys)  # print format\n        LOGGER.info(pf % (\"all\", self.metrics.top1, self.metrics.top5))\n\n    def plot_val_samples(self, batch, ni):\n        \"\"\"Plot validation image samples.\"\"\"\n        plot_images(\n            images=batch[\"img\"],\n            batch_idx=torch.arange(len(batch[\"img\"])),\n            cls=batch[\"cls\"].view(-1),  # warning: use .view(), not .squeeze() for Classify models\n            fname=self.save_dir / f\"val_batch{ni}_labels.jpg\",\n            names=self.names,\n            on_plot=self.on_plot,\n        )\n\n    def plot_predictions(self, batch, preds, ni):\n        \"\"\"Plots predicted bounding boxes on input images and saves the result.\"\"\"\n        plot_images(\n            batch[\"img\"],\n            batch_idx=torch.arange(len(batch[\"img\"])),\n            cls=torch.argmax(preds, dim=1),\n            fname=self.save_dir / f\"val_batch{ni}_pred.jpg\",\n            names=self.names,\n            on_plot=self.on_plot,\n        )  # pred\n</code></pre>"},{"location":"reference/models/yolo/classify/val/#ultralytics.models.yolo.classify.val.ClassificationValidator.__init__","title":"<code>__init__(dataloader=None, save_dir=None, pbar=None, args=None, _callbacks=None)</code>","text":"<p>Initializes ClassificationValidator instance with args, dataloader, save_dir, and progress bar.</p> Source code in <code>ultralytics/models/yolo/classify/val.py</code> <pre><code>def __init__(self, dataloader=None, save_dir=None, pbar=None, args=None, _callbacks=None):\n    \"\"\"Initializes ClassificationValidator instance with args, dataloader, save_dir, and progress bar.\"\"\"\n    super().__init__(dataloader, save_dir, pbar, args, _callbacks)\n    self.targets = None\n    self.pred = None\n    self.args.task = \"classify\"\n    self.metrics = ClassifyMetrics()\n</code></pre>"},{"location":"reference/models/yolo/classify/val/#ultralytics.models.yolo.classify.val.ClassificationValidator.build_dataset","title":"<code>build_dataset(img_path)</code>","text":"<p>Creates and returns a ClassificationDataset instance using given image path and preprocessing parameters.</p> Source code in <code>ultralytics/models/yolo/classify/val.py</code> <pre><code>def build_dataset(self, img_path):\n    \"\"\"Creates and returns a ClassificationDataset instance using given image path and preprocessing parameters.\"\"\"\n    return ClassificationDataset(root=img_path, args=self.args, augment=False, prefix=self.args.split)\n</code></pre>"},{"location":"reference/models/yolo/classify/val/#ultralytics.models.yolo.classify.val.ClassificationValidator.finalize_metrics","title":"<code>finalize_metrics(*args, **kwargs)</code>","text":"<p>Finalizes metrics of the model such as confusion_matrix and speed.</p> Source code in <code>ultralytics/models/yolo/classify/val.py</code> <pre><code>def finalize_metrics(self, *args, **kwargs):\n    \"\"\"Finalizes metrics of the model such as confusion_matrix and speed.\"\"\"\n    self.confusion_matrix.process_cls_preds(self.pred, self.targets)\n    if self.args.plots:\n        for normalize in True, False:\n            self.confusion_matrix.plot(\n                save_dir=self.save_dir, names=self.names.values(), normalize=normalize, on_plot=self.on_plot\n            )\n    self.metrics.speed = self.speed\n    self.metrics.confusion_matrix = self.confusion_matrix\n    self.metrics.save_dir = self.save_dir\n</code></pre>"},{"location":"reference/models/yolo/classify/val/#ultralytics.models.yolo.classify.val.ClassificationValidator.get_dataloader","title":"<code>get_dataloader(dataset_path, batch_size)</code>","text":"<p>Builds and returns a data loader for classification tasks with given parameters.</p> Source code in <code>ultralytics/models/yolo/classify/val.py</code> <pre><code>def get_dataloader(self, dataset_path, batch_size):\n    \"\"\"Builds and returns a data loader for classification tasks with given parameters.\"\"\"\n    dataset = self.build_dataset(dataset_path)\n    return build_dataloader(dataset, batch_size, self.args.workers, rank=-1)\n</code></pre>"},{"location":"reference/models/yolo/classify/val/#ultralytics.models.yolo.classify.val.ClassificationValidator.get_desc","title":"<code>get_desc()</code>","text":"<p>Returns a formatted string summarizing classification metrics.</p> Source code in <code>ultralytics/models/yolo/classify/val.py</code> <pre><code>def get_desc(self):\n    \"\"\"Returns a formatted string summarizing classification metrics.\"\"\"\n    return (\"%22s\" + \"%11s\" * 2) % (\"classes\", \"top1_acc\", \"top5_acc\")\n</code></pre>"},{"location":"reference/models/yolo/classify/val/#ultralytics.models.yolo.classify.val.ClassificationValidator.get_stats","title":"<code>get_stats()</code>","text":"<p>Returns a dictionary of metrics obtained by processing targets and predictions.</p> Source code in <code>ultralytics/models/yolo/classify/val.py</code> <pre><code>def get_stats(self):\n    \"\"\"Returns a dictionary of metrics obtained by processing targets and predictions.\"\"\"\n    self.metrics.process(self.targets, self.pred)\n    return self.metrics.results_dict\n</code></pre>"},{"location":"reference/models/yolo/classify/val/#ultralytics.models.yolo.classify.val.ClassificationValidator.init_metrics","title":"<code>init_metrics(model)</code>","text":"<p>Initialize confusion matrix, class names, and top-1 and top-5 accuracy.</p> Source code in <code>ultralytics/models/yolo/classify/val.py</code> <pre><code>def init_metrics(self, model):\n    \"\"\"Initialize confusion matrix, class names, and top-1 and top-5 accuracy.\"\"\"\n    self.names = model.names\n    self.nc = len(model.names)\n    self.confusion_matrix = ConfusionMatrix(nc=self.nc, conf=self.args.conf, task=\"classify\")\n    self.pred = []\n    self.targets = []\n</code></pre>"},{"location":"reference/models/yolo/classify/val/#ultralytics.models.yolo.classify.val.ClassificationValidator.plot_predictions","title":"<code>plot_predictions(batch, preds, ni)</code>","text":"<p>Plots predicted bounding boxes on input images and saves the result.</p> Source code in <code>ultralytics/models/yolo/classify/val.py</code> <pre><code>def plot_predictions(self, batch, preds, ni):\n    \"\"\"Plots predicted bounding boxes on input images and saves the result.\"\"\"\n    plot_images(\n        batch[\"img\"],\n        batch_idx=torch.arange(len(batch[\"img\"])),\n        cls=torch.argmax(preds, dim=1),\n        fname=self.save_dir / f\"val_batch{ni}_pred.jpg\",\n        names=self.names,\n        on_plot=self.on_plot,\n    )  # pred\n</code></pre>"},{"location":"reference/models/yolo/classify/val/#ultralytics.models.yolo.classify.val.ClassificationValidator.plot_val_samples","title":"<code>plot_val_samples(batch, ni)</code>","text":"<p>Plot validation image samples.</p> Source code in <code>ultralytics/models/yolo/classify/val.py</code> <pre><code>def plot_val_samples(self, batch, ni):\n    \"\"\"Plot validation image samples.\"\"\"\n    plot_images(\n        images=batch[\"img\"],\n        batch_idx=torch.arange(len(batch[\"img\"])),\n        cls=batch[\"cls\"].view(-1),  # warning: use .view(), not .squeeze() for Classify models\n        fname=self.save_dir / f\"val_batch{ni}_labels.jpg\",\n        names=self.names,\n        on_plot=self.on_plot,\n    )\n</code></pre>"},{"location":"reference/models/yolo/classify/val/#ultralytics.models.yolo.classify.val.ClassificationValidator.preprocess","title":"<code>preprocess(batch)</code>","text":"<p>Preprocesses input batch and returns it.</p> Source code in <code>ultralytics/models/yolo/classify/val.py</code> <pre><code>def preprocess(self, batch):\n    \"\"\"Preprocesses input batch and returns it.\"\"\"\n    batch[\"img\"] = batch[\"img\"].to(self.device, non_blocking=True)\n    batch[\"img\"] = batch[\"img\"].half() if self.args.half else batch[\"img\"].float()\n    batch[\"cls\"] = batch[\"cls\"].to(self.device)\n    return batch\n</code></pre>"},{"location":"reference/models/yolo/classify/val/#ultralytics.models.yolo.classify.val.ClassificationValidator.print_results","title":"<code>print_results()</code>","text":"<p>Prints evaluation metrics for YOLO object detection model.</p> Source code in <code>ultralytics/models/yolo/classify/val.py</code> <pre><code>def print_results(self):\n    \"\"\"Prints evaluation metrics for YOLO object detection model.\"\"\"\n    pf = \"%22s\" + \"%11.3g\" * len(self.metrics.keys)  # print format\n    LOGGER.info(pf % (\"all\", self.metrics.top1, self.metrics.top5))\n</code></pre>"},{"location":"reference/models/yolo/classify/val/#ultralytics.models.yolo.classify.val.ClassificationValidator.update_metrics","title":"<code>update_metrics(preds, batch)</code>","text":"<p>Updates running metrics with model predictions and batch targets.</p> Source code in <code>ultralytics/models/yolo/classify/val.py</code> <pre><code>def update_metrics(self, preds, batch):\n    \"\"\"Updates running metrics with model predictions and batch targets.\"\"\"\n    n5 = min(len(self.names), 5)\n    self.pred.append(preds.argsort(1, descending=True)[:, :n5])\n    self.targets.append(batch[\"cls\"])\n</code></pre>"},{"location":"reference/models/yolo/detect/predict/","title":"Reference for <code>ultralytics/models/yolo/detect/predict.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/yolo/detect/predict.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/yolo/detect/predict/#ultralytics.models.yolo.detect.predict.DetectionPredictor","title":"<code>ultralytics.models.yolo.detect.predict.DetectionPredictor</code>","text":"<p>             Bases: <code>BasePredictor</code></p> <p>A class extending the BasePredictor class for prediction based on a detection model.</p> Example <pre><code>from ultralytics.utils import ASSETS\nfrom ultralytics.models.yolo.detect import DetectionPredictor\n\nargs = dict(model='yolov8n.pt', source=ASSETS)\npredictor = DetectionPredictor(overrides=args)\npredictor.predict_cli()\n</code></pre> Source code in <code>ultralytics/models/yolo/detect/predict.py</code> <pre><code>class DetectionPredictor(BasePredictor):\n    \"\"\"\n    A class extending the BasePredictor class for prediction based on a detection model.\n\n    Example:\n        ```python\n        from ultralytics.utils import ASSETS\n        from ultralytics.models.yolo.detect import DetectionPredictor\n\n        args = dict(model='yolov8n.pt', source=ASSETS)\n        predictor = DetectionPredictor(overrides=args)\n        predictor.predict_cli()\n        ```\n    \"\"\"\n\n    def postprocess(self, preds, img, orig_imgs):\n        \"\"\"Post-processes predictions and returns a list of Results objects.\"\"\"\n        preds = ops.non_max_suppression(\n            preds,\n            self.args.conf,\n            self.args.iou,\n            agnostic=self.args.agnostic_nms,\n            max_det=self.args.max_det,\n            classes=self.args.classes,\n        )\n\n        if not isinstance(orig_imgs, list):  # input images are a torch.Tensor, not a list\n            orig_imgs = ops.convert_torch2numpy_batch(orig_imgs)\n\n        results = []\n        for i, pred in enumerate(preds):\n            orig_img = orig_imgs[i]\n            pred[:, :4] = ops.scale_boxes(img.shape[2:], pred[:, :4], orig_img.shape)\n            img_path = self.batch[0][i]\n            results.append(Results(orig_img, path=img_path, names=self.model.names, boxes=pred))\n        return results\n</code></pre>"},{"location":"reference/models/yolo/detect/predict/#ultralytics.models.yolo.detect.predict.DetectionPredictor.postprocess","title":"<code>postprocess(preds, img, orig_imgs)</code>","text":"<p>Post-processes predictions and returns a list of Results objects.</p> Source code in <code>ultralytics/models/yolo/detect/predict.py</code> <pre><code>def postprocess(self, preds, img, orig_imgs):\n    \"\"\"Post-processes predictions and returns a list of Results objects.\"\"\"\n    preds = ops.non_max_suppression(\n        preds,\n        self.args.conf,\n        self.args.iou,\n        agnostic=self.args.agnostic_nms,\n        max_det=self.args.max_det,\n        classes=self.args.classes,\n    )\n\n    if not isinstance(orig_imgs, list):  # input images are a torch.Tensor, not a list\n        orig_imgs = ops.convert_torch2numpy_batch(orig_imgs)\n\n    results = []\n    for i, pred in enumerate(preds):\n        orig_img = orig_imgs[i]\n        pred[:, :4] = ops.scale_boxes(img.shape[2:], pred[:, :4], orig_img.shape)\n        img_path = self.batch[0][i]\n        results.append(Results(orig_img, path=img_path, names=self.model.names, boxes=pred))\n    return results\n</code></pre>"},{"location":"reference/models/yolo/detect/train/","title":"Reference for <code>ultralytics/models/yolo/detect/train.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/yolo/detect/train.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/yolo/detect/train/#ultralytics.models.yolo.detect.train.DetectionTrainer","title":"<code>ultralytics.models.yolo.detect.train.DetectionTrainer</code>","text":"<p>             Bases: <code>BaseTrainer</code></p> <p>A class extending the BaseTrainer class for training based on a detection model.</p> Example <pre><code>from ultralytics.models.yolo.detect import DetectionTrainer\n\nargs = dict(model='yolov8n.pt', data='coco8.yaml', epochs=3)\ntrainer = DetectionTrainer(overrides=args)\ntrainer.train()\n</code></pre> Source code in <code>ultralytics/models/yolo/detect/train.py</code> <pre><code>class DetectionTrainer(BaseTrainer):\n    \"\"\"\n    A class extending the BaseTrainer class for training based on a detection model.\n\n    Example:\n        ```python\n        from ultralytics.models.yolo.detect import DetectionTrainer\n\n        args = dict(model='yolov8n.pt', data='coco8.yaml', epochs=3)\n        trainer = DetectionTrainer(overrides=args)\n        trainer.train()\n        ```\n    \"\"\"\n\n    def build_dataset(self, img_path, mode=\"train\", batch=None):\n        \"\"\"\n        Build YOLO Dataset.\n\n        Args:\n            img_path (str): Path to the folder containing images.\n            mode (str): `train` mode or `val` mode, users are able to customize different augmentations for each mode.\n            batch (int, optional): Size of batches, this is for `rect`. Defaults to None.\n        \"\"\"\n        gs = max(int(de_parallel(self.model).stride.max() if self.model else 0), 32)\n        return build_yolo_dataset(self.args, img_path, batch, self.data, mode=mode, rect=mode == \"val\", stride=gs)\n\n    def get_dataloader(self, dataset_path, batch_size=16, rank=0, mode=\"train\"):\n        \"\"\"Construct and return dataloader.\"\"\"\n        assert mode in [\"train\", \"val\"]\n        with torch_distributed_zero_first(rank):  # init dataset *.cache only once if DDP\n            dataset = self.build_dataset(dataset_path, mode, batch_size)\n        shuffle = mode == \"train\"\n        if getattr(dataset, \"rect\", False) and shuffle:\n            LOGGER.warning(\"WARNING \u26a0\ufe0f 'rect=True' is incompatible with DataLoader shuffle, setting shuffle=False\")\n            shuffle = False\n        workers = self.args.workers if mode == \"train\" else self.args.workers * 2\n        return build_dataloader(dataset, batch_size, workers, shuffle, rank)  # return dataloader\n\n    def preprocess_batch(self, batch):\n        \"\"\"Preprocesses a batch of images by scaling and converting to float.\"\"\"\n        batch[\"img\"] = batch[\"img\"].to(self.device, non_blocking=True).float() / 255\n        if self.args.multi_scale:\n            imgs = batch[\"img\"]\n            sz = (\n                random.randrange(self.args.imgsz * 0.5, self.args.imgsz * 1.5 + self.stride)\n                // self.stride\n                * self.stride\n            )  # size\n            sf = sz / max(imgs.shape[2:])  # scale factor\n            if sf != 1:\n                ns = [\n                    math.ceil(x * sf / self.stride) * self.stride for x in imgs.shape[2:]\n                ]  # new shape (stretched to gs-multiple)\n                imgs = nn.functional.interpolate(imgs, size=ns, mode=\"bilinear\", align_corners=False)\n            batch[\"img\"] = imgs\n        return batch\n\n    def set_model_attributes(self):\n        \"\"\"Nl = de_parallel(self.model).model[-1].nl  # number of detection layers (to scale hyps).\"\"\"\n        # self.args.box *= 3 / nl  # scale to layers\n        # self.args.cls *= self.data[\"nc\"] / 80 * 3 / nl  # scale to classes and layers\n        # self.args.cls *= (self.args.imgsz / 640) ** 2 * 3 / nl  # scale to image size and layers\n        self.model.nc = self.data[\"nc\"]  # attach number of classes to model\n        self.model.names = self.data[\"names\"]  # attach class names to model\n        self.model.args = self.args  # attach hyperparameters to model\n        # TODO: self.model.class_weights = labels_to_class_weights(dataset.labels, nc).to(device) * nc\n\n    def get_model(self, cfg=None, weights=None, verbose=True):\n        \"\"\"Return a YOLO detection model.\"\"\"\n        model = DetectionModel(cfg, nc=self.data[\"nc\"], verbose=verbose and RANK == -1)\n        if weights:\n            model.load(weights)\n        return model\n\n    def get_validator(self):\n        \"\"\"Returns a DetectionValidator for YOLO model validation.\"\"\"\n        self.loss_names = \"box_loss\", \"cls_loss\", \"dfl_loss\"\n        return yolo.detect.DetectionValidator(\n            self.test_loader, save_dir=self.save_dir, args=copy(self.args), _callbacks=self.callbacks\n        )\n\n    def label_loss_items(self, loss_items=None, prefix=\"train\"):\n        \"\"\"\n        Returns a loss dict with labelled training loss items tensor.\n\n        Not needed for classification but necessary for segmentation &amp; detection\n        \"\"\"\n        keys = [f\"{prefix}/{x}\" for x in self.loss_names]\n        if loss_items is not None:\n            loss_items = [round(float(x), 5) for x in loss_items]  # convert tensors to 5 decimal place floats\n            return dict(zip(keys, loss_items))\n        else:\n            return keys\n\n    def progress_string(self):\n        \"\"\"Returns a formatted string of training progress with epoch, GPU memory, loss, instances and size.\"\"\"\n        return (\"\\n\" + \"%11s\" * (4 + len(self.loss_names))) % (\n            \"Epoch\",\n            \"GPU_mem\",\n            *self.loss_names,\n            \"Instances\",\n            \"Size\",\n        )\n\n    def plot_training_samples(self, batch, ni):\n        \"\"\"Plots training samples with their annotations.\"\"\"\n        plot_images(\n            images=batch[\"img\"],\n            batch_idx=batch[\"batch_idx\"],\n            cls=batch[\"cls\"].squeeze(-1),\n            bboxes=batch[\"bboxes\"],\n            paths=batch[\"im_file\"],\n            fname=self.save_dir / f\"train_batch{ni}.jpg\",\n            on_plot=self.on_plot,\n        )\n\n    def plot_metrics(self):\n        \"\"\"Plots metrics from a CSV file.\"\"\"\n        plot_results(file=self.csv, on_plot=self.on_plot)  # save results.png\n\n    def plot_training_labels(self):\n        \"\"\"Create a labeled training plot of the YOLO model.\"\"\"\n        boxes = np.concatenate([lb[\"bboxes\"] for lb in self.train_loader.dataset.labels], 0)\n        cls = np.concatenate([lb[\"cls\"] for lb in self.train_loader.dataset.labels], 0)\n        plot_labels(boxes, cls.squeeze(), names=self.data[\"names\"], save_dir=self.save_dir, on_plot=self.on_plot)\n</code></pre>"},{"location":"reference/models/yolo/detect/train/#ultralytics.models.yolo.detect.train.DetectionTrainer.build_dataset","title":"<code>build_dataset(img_path, mode='train', batch=None)</code>","text":"<p>Build YOLO Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>img_path</code> <code>str</code> <p>Path to the folder containing images.</p> required <code>mode</code> <code>str</code> <p><code>train</code> mode or <code>val</code> mode, users are able to customize different augmentations for each mode.</p> <code>'train'</code> <code>batch</code> <code>int</code> <p>Size of batches, this is for <code>rect</code>. Defaults to None.</p> <code>None</code> Source code in <code>ultralytics/models/yolo/detect/train.py</code> <pre><code>def build_dataset(self, img_path, mode=\"train\", batch=None):\n    \"\"\"\n    Build YOLO Dataset.\n\n    Args:\n        img_path (str): Path to the folder containing images.\n        mode (str): `train` mode or `val` mode, users are able to customize different augmentations for each mode.\n        batch (int, optional): Size of batches, this is for `rect`. Defaults to None.\n    \"\"\"\n    gs = max(int(de_parallel(self.model).stride.max() if self.model else 0), 32)\n    return build_yolo_dataset(self.args, img_path, batch, self.data, mode=mode, rect=mode == \"val\", stride=gs)\n</code></pre>"},{"location":"reference/models/yolo/detect/train/#ultralytics.models.yolo.detect.train.DetectionTrainer.get_dataloader","title":"<code>get_dataloader(dataset_path, batch_size=16, rank=0, mode='train')</code>","text":"<p>Construct and return dataloader.</p> Source code in <code>ultralytics/models/yolo/detect/train.py</code> <pre><code>def get_dataloader(self, dataset_path, batch_size=16, rank=0, mode=\"train\"):\n    \"\"\"Construct and return dataloader.\"\"\"\n    assert mode in [\"train\", \"val\"]\n    with torch_distributed_zero_first(rank):  # init dataset *.cache only once if DDP\n        dataset = self.build_dataset(dataset_path, mode, batch_size)\n    shuffle = mode == \"train\"\n    if getattr(dataset, \"rect\", False) and shuffle:\n        LOGGER.warning(\"WARNING \u26a0\ufe0f 'rect=True' is incompatible with DataLoader shuffle, setting shuffle=False\")\n        shuffle = False\n    workers = self.args.workers if mode == \"train\" else self.args.workers * 2\n    return build_dataloader(dataset, batch_size, workers, shuffle, rank)  # return dataloader\n</code></pre>"},{"location":"reference/models/yolo/detect/train/#ultralytics.models.yolo.detect.train.DetectionTrainer.get_model","title":"<code>get_model(cfg=None, weights=None, verbose=True)</code>","text":"<p>Return a YOLO detection model.</p> Source code in <code>ultralytics/models/yolo/detect/train.py</code> <pre><code>def get_model(self, cfg=None, weights=None, verbose=True):\n    \"\"\"Return a YOLO detection model.\"\"\"\n    model = DetectionModel(cfg, nc=self.data[\"nc\"], verbose=verbose and RANK == -1)\n    if weights:\n        model.load(weights)\n    return model\n</code></pre>"},{"location":"reference/models/yolo/detect/train/#ultralytics.models.yolo.detect.train.DetectionTrainer.get_validator","title":"<code>get_validator()</code>","text":"<p>Returns a DetectionValidator for YOLO model validation.</p> Source code in <code>ultralytics/models/yolo/detect/train.py</code> <pre><code>def get_validator(self):\n    \"\"\"Returns a DetectionValidator for YOLO model validation.\"\"\"\n    self.loss_names = \"box_loss\", \"cls_loss\", \"dfl_loss\"\n    return yolo.detect.DetectionValidator(\n        self.test_loader, save_dir=self.save_dir, args=copy(self.args), _callbacks=self.callbacks\n    )\n</code></pre>"},{"location":"reference/models/yolo/detect/train/#ultralytics.models.yolo.detect.train.DetectionTrainer.label_loss_items","title":"<code>label_loss_items(loss_items=None, prefix='train')</code>","text":"<p>Returns a loss dict with labelled training loss items tensor.</p> <p>Not needed for classification but necessary for segmentation &amp; detection</p> Source code in <code>ultralytics/models/yolo/detect/train.py</code> <pre><code>def label_loss_items(self, loss_items=None, prefix=\"train\"):\n    \"\"\"\n    Returns a loss dict with labelled training loss items tensor.\n\n    Not needed for classification but necessary for segmentation &amp; detection\n    \"\"\"\n    keys = [f\"{prefix}/{x}\" for x in self.loss_names]\n    if loss_items is not None:\n        loss_items = [round(float(x), 5) for x in loss_items]  # convert tensors to 5 decimal place floats\n        return dict(zip(keys, loss_items))\n    else:\n        return keys\n</code></pre>"},{"location":"reference/models/yolo/detect/train/#ultralytics.models.yolo.detect.train.DetectionTrainer.plot_metrics","title":"<code>plot_metrics()</code>","text":"<p>Plots metrics from a CSV file.</p> Source code in <code>ultralytics/models/yolo/detect/train.py</code> <pre><code>def plot_metrics(self):\n    \"\"\"Plots metrics from a CSV file.\"\"\"\n    plot_results(file=self.csv, on_plot=self.on_plot)  # save results.png\n</code></pre>"},{"location":"reference/models/yolo/detect/train/#ultralytics.models.yolo.detect.train.DetectionTrainer.plot_training_labels","title":"<code>plot_training_labels()</code>","text":"<p>Create a labeled training plot of the YOLO model.</p> Source code in <code>ultralytics/models/yolo/detect/train.py</code> <pre><code>def plot_training_labels(self):\n    \"\"\"Create a labeled training plot of the YOLO model.\"\"\"\n    boxes = np.concatenate([lb[\"bboxes\"] for lb in self.train_loader.dataset.labels], 0)\n    cls = np.concatenate([lb[\"cls\"] for lb in self.train_loader.dataset.labels], 0)\n    plot_labels(boxes, cls.squeeze(), names=self.data[\"names\"], save_dir=self.save_dir, on_plot=self.on_plot)\n</code></pre>"},{"location":"reference/models/yolo/detect/train/#ultralytics.models.yolo.detect.train.DetectionTrainer.plot_training_samples","title":"<code>plot_training_samples(batch, ni)</code>","text":"<p>Plots training samples with their annotations.</p> Source code in <code>ultralytics/models/yolo/detect/train.py</code> <pre><code>def plot_training_samples(self, batch, ni):\n    \"\"\"Plots training samples with their annotations.\"\"\"\n    plot_images(\n        images=batch[\"img\"],\n        batch_idx=batch[\"batch_idx\"],\n        cls=batch[\"cls\"].squeeze(-1),\n        bboxes=batch[\"bboxes\"],\n        paths=batch[\"im_file\"],\n        fname=self.save_dir / f\"train_batch{ni}.jpg\",\n        on_plot=self.on_plot,\n    )\n</code></pre>"},{"location":"reference/models/yolo/detect/train/#ultralytics.models.yolo.detect.train.DetectionTrainer.preprocess_batch","title":"<code>preprocess_batch(batch)</code>","text":"<p>Preprocesses a batch of images by scaling and converting to float.</p> Source code in <code>ultralytics/models/yolo/detect/train.py</code> <pre><code>def preprocess_batch(self, batch):\n    \"\"\"Preprocesses a batch of images by scaling and converting to float.\"\"\"\n    batch[\"img\"] = batch[\"img\"].to(self.device, non_blocking=True).float() / 255\n    if self.args.multi_scale:\n        imgs = batch[\"img\"]\n        sz = (\n            random.randrange(self.args.imgsz * 0.5, self.args.imgsz * 1.5 + self.stride)\n            // self.stride\n            * self.stride\n        )  # size\n        sf = sz / max(imgs.shape[2:])  # scale factor\n        if sf != 1:\n            ns = [\n                math.ceil(x * sf / self.stride) * self.stride for x in imgs.shape[2:]\n            ]  # new shape (stretched to gs-multiple)\n            imgs = nn.functional.interpolate(imgs, size=ns, mode=\"bilinear\", align_corners=False)\n        batch[\"img\"] = imgs\n    return batch\n</code></pre>"},{"location":"reference/models/yolo/detect/train/#ultralytics.models.yolo.detect.train.DetectionTrainer.progress_string","title":"<code>progress_string()</code>","text":"<p>Returns a formatted string of training progress with epoch, GPU memory, loss, instances and size.</p> Source code in <code>ultralytics/models/yolo/detect/train.py</code> <pre><code>def progress_string(self):\n    \"\"\"Returns a formatted string of training progress with epoch, GPU memory, loss, instances and size.\"\"\"\n    return (\"\\n\" + \"%11s\" * (4 + len(self.loss_names))) % (\n        \"Epoch\",\n        \"GPU_mem\",\n        *self.loss_names,\n        \"Instances\",\n        \"Size\",\n    )\n</code></pre>"},{"location":"reference/models/yolo/detect/train/#ultralytics.models.yolo.detect.train.DetectionTrainer.set_model_attributes","title":"<code>set_model_attributes()</code>","text":"<p>Nl = de_parallel(self.model).model[-1].nl  # number of detection layers (to scale hyps).</p> Source code in <code>ultralytics/models/yolo/detect/train.py</code> <pre><code>def set_model_attributes(self):\n    \"\"\"Nl = de_parallel(self.model).model[-1].nl  # number of detection layers (to scale hyps).\"\"\"\n    # self.args.box *= 3 / nl  # scale to layers\n    # self.args.cls *= self.data[\"nc\"] / 80 * 3 / nl  # scale to classes and layers\n    # self.args.cls *= (self.args.imgsz / 640) ** 2 * 3 / nl  # scale to image size and layers\n    self.model.nc = self.data[\"nc\"]  # attach number of classes to model\n    self.model.names = self.data[\"names\"]  # attach class names to model\n    self.model.args = self.args  # attach hyperparameters to model\n</code></pre>"},{"location":"reference/models/yolo/detect/val/","title":"Reference for <code>ultralytics/models/yolo/detect/val.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/yolo/detect/val.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/yolo/detect/val/#ultralytics.models.yolo.detect.val.DetectionValidator","title":"<code>ultralytics.models.yolo.detect.val.DetectionValidator</code>","text":"<p>             Bases: <code>BaseValidator</code></p> <p>A class extending the BaseValidator class for validation based on a detection model.</p> Example <pre><code>from ultralytics.models.yolo.detect import DetectionValidator\n\nargs = dict(model='yolov8n.pt', data='coco8.yaml')\nvalidator = DetectionValidator(args=args)\nvalidator()\n</code></pre> Source code in <code>ultralytics/models/yolo/detect/val.py</code> <pre><code>class DetectionValidator(BaseValidator):\n    \"\"\"\n    A class extending the BaseValidator class for validation based on a detection model.\n\n    Example:\n        ```python\n        from ultralytics.models.yolo.detect import DetectionValidator\n\n        args = dict(model='yolov8n.pt', data='coco8.yaml')\n        validator = DetectionValidator(args=args)\n        validator()\n        ```\n    \"\"\"\n\n    def __init__(self, dataloader=None, save_dir=None, pbar=None, args=None, _callbacks=None):\n        \"\"\"Initialize detection model with necessary variables and settings.\"\"\"\n        super().__init__(dataloader, save_dir, pbar, args, _callbacks)\n        self.nt_per_class = None\n        self.is_coco = False\n        self.class_map = None\n        self.args.task = \"detect\"\n        self.metrics = DetMetrics(save_dir=self.save_dir, on_plot=self.on_plot)\n        self.iouv = torch.linspace(0.5, 0.95, 10)  # iou vector for mAP@0.5:0.95\n        self.niou = self.iouv.numel()\n        self.lb = []  # for autolabelling\n\n    def preprocess(self, batch):\n        \"\"\"Preprocesses batch of images for YOLO training.\"\"\"\n        batch[\"img\"] = batch[\"img\"].to(self.device, non_blocking=True)\n        batch[\"img\"] = (batch[\"img\"].half() if self.args.half else batch[\"img\"].float()) / 255\n        for k in [\"batch_idx\", \"cls\", \"bboxes\"]:\n            batch[k] = batch[k].to(self.device)\n\n        if self.args.save_hybrid:\n            height, width = batch[\"img\"].shape[2:]\n            nb = len(batch[\"img\"])\n            bboxes = batch[\"bboxes\"] * torch.tensor((width, height, width, height), device=self.device)\n            self.lb = (\n                [\n                    torch.cat([batch[\"cls\"][batch[\"batch_idx\"] == i], bboxes[batch[\"batch_idx\"] == i]], dim=-1)\n                    for i in range(nb)\n                ]\n                if self.args.save_hybrid\n                else []\n            )  # for autolabelling\n\n        return batch\n\n    def init_metrics(self, model):\n        \"\"\"Initialize evaluation metrics for YOLO.\"\"\"\n        val = self.data.get(self.args.split, \"\")  # validation path\n        self.is_coco = isinstance(val, str) and \"coco\" in val and val.endswith(f\"{os.sep}val2017.txt\")  # is COCO\n        self.class_map = converter.coco80_to_coco91_class() if self.is_coco else list(range(1000))\n        self.args.save_json |= self.is_coco and not self.training  # run on final val if training COCO\n        self.names = model.names\n        self.nc = len(model.names)\n        self.metrics.names = self.names\n        self.metrics.plot = self.args.plots\n        self.confusion_matrix = ConfusionMatrix(nc=self.nc, conf=self.args.conf)\n        self.seen = 0\n        self.jdict = []\n        self.stats = dict(tp=[], conf=[], pred_cls=[], target_cls=[])\n\n    def get_desc(self):\n        \"\"\"Return a formatted string summarizing class metrics of YOLO model.\"\"\"\n        return (\"%22s\" + \"%11s\" * 6) % (\"Class\", \"Images\", \"Instances\", \"Box(P\", \"R\", \"mAP50\", \"mAP50-95)\")\n\n    def postprocess(self, preds):\n        \"\"\"Apply Non-maximum suppression to prediction outputs.\"\"\"\n        return ops.non_max_suppression(\n            preds,\n            self.args.conf,\n            self.args.iou,\n            labels=self.lb,\n            multi_label=True,\n            agnostic=self.args.single_cls,\n            max_det=self.args.max_det,\n        )\n\n    def _prepare_batch(self, si, batch):\n        \"\"\"Prepares a batch of images and annotations for validation.\"\"\"\n        idx = batch[\"batch_idx\"] == si\n        cls = batch[\"cls\"][idx].squeeze(-1)\n        bbox = batch[\"bboxes\"][idx]\n        ori_shape = batch[\"ori_shape\"][si]\n        imgsz = batch[\"img\"].shape[2:]\n        ratio_pad = batch[\"ratio_pad\"][si]\n        if len(cls):\n            bbox = ops.xywh2xyxy(bbox) * torch.tensor(imgsz, device=self.device)[[1, 0, 1, 0]]  # target boxes\n            ops.scale_boxes(imgsz, bbox, ori_shape, ratio_pad=ratio_pad)  # native-space labels\n        prepared_batch = dict(cls=cls, bbox=bbox, ori_shape=ori_shape, imgsz=imgsz, ratio_pad=ratio_pad)\n        return prepared_batch\n\n    def _prepare_pred(self, pred, pbatch):\n        \"\"\"Prepares a batch of images and annotations for validation.\"\"\"\n        predn = pred.clone()\n        ops.scale_boxes(\n            pbatch[\"imgsz\"], predn[:, :4], pbatch[\"ori_shape\"], ratio_pad=pbatch[\"ratio_pad\"]\n        )  # native-space pred\n        return predn\n\n    def update_metrics(self, preds, batch):\n        \"\"\"Metrics.\"\"\"\n        for si, pred in enumerate(preds):\n            self.seen += 1\n            npr = len(pred)\n            stat = dict(\n                conf=torch.zeros(0, device=self.device),\n                pred_cls=torch.zeros(0, device=self.device),\n                tp=torch.zeros(npr, self.niou, dtype=torch.bool, device=self.device),\n            )\n            pbatch = self._prepare_batch(si, batch)\n            cls, bbox = pbatch.pop(\"cls\"), pbatch.pop(\"bbox\")\n            nl = len(cls)\n            stat[\"target_cls\"] = cls\n            if npr == 0:\n                if nl:\n                    for k in self.stats.keys():\n                        self.stats[k].append(stat[k])\n                    # TODO: obb has not supported confusion_matrix yet.\n                    if self.args.plots and self.args.task != \"obb\":\n                        self.confusion_matrix.process_batch(detections=None, gt_bboxes=bbox, gt_cls=cls)\n                continue\n\n            # Predictions\n            if self.args.single_cls:\n                pred[:, 5] = 0\n            predn = self._prepare_pred(pred, pbatch)\n            stat[\"conf\"] = predn[:, 4]\n            stat[\"pred_cls\"] = predn[:, 5]\n\n            # Evaluate\n            if nl:\n                stat[\"tp\"] = self._process_batch(predn, bbox, cls)\n                # TODO: obb has not supported confusion_matrix yet.\n                if self.args.plots and self.args.task != \"obb\":\n                    self.confusion_matrix.process_batch(predn, bbox, cls)\n            for k in self.stats.keys():\n                self.stats[k].append(stat[k])\n\n            # Save\n            if self.args.save_json:\n                self.pred_to_json(predn, batch[\"im_file\"][si])\n            if self.args.save_txt:\n                file = self.save_dir / \"labels\" / f'{Path(batch[\"im_file\"][si]).stem}.txt'\n                self.save_one_txt(predn, self.args.save_conf, pbatch[\"ori_shape\"], file)\n\n    def finalize_metrics(self, *args, **kwargs):\n        \"\"\"Set final values for metrics speed and confusion matrix.\"\"\"\n        self.metrics.speed = self.speed\n        self.metrics.confusion_matrix = self.confusion_matrix\n\n    def get_stats(self):\n        \"\"\"Returns metrics statistics and results dictionary.\"\"\"\n        stats = {k: torch.cat(v, 0).cpu().numpy() for k, v in self.stats.items()}  # to numpy\n        if len(stats) and stats[\"tp\"].any():\n            self.metrics.process(**stats)\n        self.nt_per_class = np.bincount(\n            stats[\"target_cls\"].astype(int), minlength=self.nc\n        )  # number of targets per class\n        return self.metrics.results_dict\n\n    def print_results(self):\n        \"\"\"Prints training/validation set metrics per class.\"\"\"\n        pf = \"%22s\" + \"%11i\" * 2 + \"%11.3g\" * len(self.metrics.keys)  # print format\n        LOGGER.info(pf % (\"all\", self.seen, self.nt_per_class.sum(), *self.metrics.mean_results()))\n        if self.nt_per_class.sum() == 0:\n            LOGGER.warning(f\"WARNING \u26a0\ufe0f no labels found in {self.args.task} set, can not compute metrics without labels\")\n\n        # Print results per class\n        if self.args.verbose and not self.training and self.nc &gt; 1 and len(self.stats):\n            for i, c in enumerate(self.metrics.ap_class_index):\n                LOGGER.info(pf % (self.names[c], self.seen, self.nt_per_class[c], *self.metrics.class_result(i)))\n\n        if self.args.plots:\n            for normalize in True, False:\n                self.confusion_matrix.plot(\n                    save_dir=self.save_dir, names=self.names.values(), normalize=normalize, on_plot=self.on_plot\n                )\n\n    def _process_batch(self, detections, gt_bboxes, gt_cls):\n        \"\"\"\n        Return correct prediction matrix.\n\n        Args:\n            detections (torch.Tensor): Tensor of shape [N, 6] representing detections.\n                Each detection is of the format: x1, y1, x2, y2, conf, class.\n            labels (torch.Tensor): Tensor of shape [M, 5] representing labels.\n                Each label is of the format: class, x1, y1, x2, y2.\n\n        Returns:\n            (torch.Tensor): Correct prediction matrix of shape [N, 10] for 10 IoU levels.\n        \"\"\"\n        iou = box_iou(gt_bboxes, detections[:, :4])\n        return self.match_predictions(detections[:, 5], gt_cls, iou)\n\n    def build_dataset(self, img_path, mode=\"val\", batch=None):\n        \"\"\"\n        Build YOLO Dataset.\n\n        Args:\n            img_path (str): Path to the folder containing images.\n            mode (str): `train` mode or `val` mode, users are able to customize different augmentations for each mode.\n            batch (int, optional): Size of batches, this is for `rect`. Defaults to None.\n        \"\"\"\n        return build_yolo_dataset(self.args, img_path, batch, self.data, mode=mode, stride=self.stride)\n\n    def get_dataloader(self, dataset_path, batch_size):\n        \"\"\"Construct and return dataloader.\"\"\"\n        dataset = self.build_dataset(dataset_path, batch=batch_size, mode=\"val\")\n        return build_dataloader(dataset, batch_size, self.args.workers, shuffle=False, rank=-1)  # return dataloader\n\n    def plot_val_samples(self, batch, ni):\n        \"\"\"Plot validation image samples.\"\"\"\n        plot_images(\n            batch[\"img\"],\n            batch[\"batch_idx\"],\n            batch[\"cls\"].squeeze(-1),\n            batch[\"bboxes\"],\n            paths=batch[\"im_file\"],\n            fname=self.save_dir / f\"val_batch{ni}_labels.jpg\",\n            names=self.names,\n            on_plot=self.on_plot,\n        )\n\n    def plot_predictions(self, batch, preds, ni):\n        \"\"\"Plots predicted bounding boxes on input images and saves the result.\"\"\"\n        plot_images(\n            batch[\"img\"],\n            *output_to_target(preds, max_det=self.args.max_det),\n            paths=batch[\"im_file\"],\n            fname=self.save_dir / f\"val_batch{ni}_pred.jpg\",\n            names=self.names,\n            on_plot=self.on_plot,\n        )  # pred\n\n    def save_one_txt(self, predn, save_conf, shape, file):\n        \"\"\"Save YOLO detections to a txt file in normalized coordinates in a specific format.\"\"\"\n        gn = torch.tensor(shape)[[1, 0, 1, 0]]  # normalization gain whwh\n        for *xyxy, conf, cls in predn.tolist():\n            xywh = (ops.xyxy2xywh(torch.tensor(xyxy).view(1, 4)) / gn).view(-1).tolist()  # normalized xywh\n            line = (cls, *xywh, conf) if save_conf else (cls, *xywh)  # label format\n            with open(file, \"a\") as f:\n                f.write((\"%g \" * len(line)).rstrip() % line + \"\\n\")\n\n    def pred_to_json(self, predn, filename):\n        \"\"\"Serialize YOLO predictions to COCO json format.\"\"\"\n        stem = Path(filename).stem\n        image_id = int(stem) if stem.isnumeric() else stem\n        box = ops.xyxy2xywh(predn[:, :4])  # xywh\n        box[:, :2] -= box[:, 2:] / 2  # xy center to top-left corner\n        for p, b in zip(predn.tolist(), box.tolist()):\n            self.jdict.append(\n                {\n                    \"image_id\": image_id,\n                    \"category_id\": self.class_map[int(p[5])],\n                    \"bbox\": [round(x, 3) for x in b],\n                    \"score\": round(p[4], 5),\n                }\n            )\n\n    def eval_json(self, stats):\n        \"\"\"Evaluates YOLO output in JSON format and returns performance statistics.\"\"\"\n        if self.args.save_json and self.is_coco and len(self.jdict):\n            anno_json = self.data[\"path\"] / \"annotations/instances_val2017.json\"  # annotations\n            pred_json = self.save_dir / \"predictions.json\"  # predictions\n            LOGGER.info(f\"\\nEvaluating pycocotools mAP using {pred_json} and {anno_json}...\")\n            try:  # https://github.com/cocodataset/cocoapi/blob/master/PythonAPI/pycocoEvalDemo.ipynb\n                check_requirements(\"pycocotools&gt;=2.0.6\")\n                from pycocotools.coco import COCO  # noqa\n                from pycocotools.cocoeval import COCOeval  # noqa\n\n                for x in anno_json, pred_json:\n                    assert x.is_file(), f\"{x} file not found\"\n                anno = COCO(str(anno_json))  # init annotations api\n                pred = anno.loadRes(str(pred_json))  # init predictions api (must pass string, not Path)\n                eval = COCOeval(anno, pred, \"bbox\")\n                if self.is_coco:\n                    eval.params.imgIds = [int(Path(x).stem) for x in self.dataloader.dataset.im_files]  # images to eval\n                eval.evaluate()\n                eval.accumulate()\n                eval.summarize()\n                stats[self.metrics.keys[-1]], stats[self.metrics.keys[-2]] = eval.stats[:2]  # update mAP50-95 and mAP50\n            except Exception as e:\n                LOGGER.warning(f\"pycocotools unable to run: {e}\")\n        return stats\n</code></pre>"},{"location":"reference/models/yolo/detect/val/#ultralytics.models.yolo.detect.val.DetectionValidator.__init__","title":"<code>__init__(dataloader=None, save_dir=None, pbar=None, args=None, _callbacks=None)</code>","text":"<p>Initialize detection model with necessary variables and settings.</p> Source code in <code>ultralytics/models/yolo/detect/val.py</code> <pre><code>def __init__(self, dataloader=None, save_dir=None, pbar=None, args=None, _callbacks=None):\n    \"\"\"Initialize detection model with necessary variables and settings.\"\"\"\n    super().__init__(dataloader, save_dir, pbar, args, _callbacks)\n    self.nt_per_class = None\n    self.is_coco = False\n    self.class_map = None\n    self.args.task = \"detect\"\n    self.metrics = DetMetrics(save_dir=self.save_dir, on_plot=self.on_plot)\n    self.iouv = torch.linspace(0.5, 0.95, 10)  # iou vector for mAP@0.5:0.95\n    self.niou = self.iouv.numel()\n    self.lb = []  # for autolabelling\n</code></pre>"},{"location":"reference/models/yolo/detect/val/#ultralytics.models.yolo.detect.val.DetectionValidator.build_dataset","title":"<code>build_dataset(img_path, mode='val', batch=None)</code>","text":"<p>Build YOLO Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>img_path</code> <code>str</code> <p>Path to the folder containing images.</p> required <code>mode</code> <code>str</code> <p><code>train</code> mode or <code>val</code> mode, users are able to customize different augmentations for each mode.</p> <code>'val'</code> <code>batch</code> <code>int</code> <p>Size of batches, this is for <code>rect</code>. Defaults to None.</p> <code>None</code> Source code in <code>ultralytics/models/yolo/detect/val.py</code> <pre><code>def build_dataset(self, img_path, mode=\"val\", batch=None):\n    \"\"\"\n    Build YOLO Dataset.\n\n    Args:\n        img_path (str): Path to the folder containing images.\n        mode (str): `train` mode or `val` mode, users are able to customize different augmentations for each mode.\n        batch (int, optional): Size of batches, this is for `rect`. Defaults to None.\n    \"\"\"\n    return build_yolo_dataset(self.args, img_path, batch, self.data, mode=mode, stride=self.stride)\n</code></pre>"},{"location":"reference/models/yolo/detect/val/#ultralytics.models.yolo.detect.val.DetectionValidator.eval_json","title":"<code>eval_json(stats)</code>","text":"<p>Evaluates YOLO output in JSON format and returns performance statistics.</p> Source code in <code>ultralytics/models/yolo/detect/val.py</code> <pre><code>def eval_json(self, stats):\n    \"\"\"Evaluates YOLO output in JSON format and returns performance statistics.\"\"\"\n    if self.args.save_json and self.is_coco and len(self.jdict):\n        anno_json = self.data[\"path\"] / \"annotations/instances_val2017.json\"  # annotations\n        pred_json = self.save_dir / \"predictions.json\"  # predictions\n        LOGGER.info(f\"\\nEvaluating pycocotools mAP using {pred_json} and {anno_json}...\")\n        try:  # https://github.com/cocodataset/cocoapi/blob/master/PythonAPI/pycocoEvalDemo.ipynb\n            check_requirements(\"pycocotools&gt;=2.0.6\")\n            from pycocotools.coco import COCO  # noqa\n            from pycocotools.cocoeval import COCOeval  # noqa\n\n            for x in anno_json, pred_json:\n                assert x.is_file(), f\"{x} file not found\"\n            anno = COCO(str(anno_json))  # init annotations api\n            pred = anno.loadRes(str(pred_json))  # init predictions api (must pass string, not Path)\n            eval = COCOeval(anno, pred, \"bbox\")\n            if self.is_coco:\n                eval.params.imgIds = [int(Path(x).stem) for x in self.dataloader.dataset.im_files]  # images to eval\n            eval.evaluate()\n            eval.accumulate()\n            eval.summarize()\n            stats[self.metrics.keys[-1]], stats[self.metrics.keys[-2]] = eval.stats[:2]  # update mAP50-95 and mAP50\n        except Exception as e:\n            LOGGER.warning(f\"pycocotools unable to run: {e}\")\n    return stats\n</code></pre>"},{"location":"reference/models/yolo/detect/val/#ultralytics.models.yolo.detect.val.DetectionValidator.finalize_metrics","title":"<code>finalize_metrics(*args, **kwargs)</code>","text":"<p>Set final values for metrics speed and confusion matrix.</p> Source code in <code>ultralytics/models/yolo/detect/val.py</code> <pre><code>def finalize_metrics(self, *args, **kwargs):\n    \"\"\"Set final values for metrics speed and confusion matrix.\"\"\"\n    self.metrics.speed = self.speed\n    self.metrics.confusion_matrix = self.confusion_matrix\n</code></pre>"},{"location":"reference/models/yolo/detect/val/#ultralytics.models.yolo.detect.val.DetectionValidator.get_dataloader","title":"<code>get_dataloader(dataset_path, batch_size)</code>","text":"<p>Construct and return dataloader.</p> Source code in <code>ultralytics/models/yolo/detect/val.py</code> <pre><code>def get_dataloader(self, dataset_path, batch_size):\n    \"\"\"Construct and return dataloader.\"\"\"\n    dataset = self.build_dataset(dataset_path, batch=batch_size, mode=\"val\")\n    return build_dataloader(dataset, batch_size, self.args.workers, shuffle=False, rank=-1)  # return dataloader\n</code></pre>"},{"location":"reference/models/yolo/detect/val/#ultralytics.models.yolo.detect.val.DetectionValidator.get_desc","title":"<code>get_desc()</code>","text":"<p>Return a formatted string summarizing class metrics of YOLO model.</p> Source code in <code>ultralytics/models/yolo/detect/val.py</code> <pre><code>def get_desc(self):\n    \"\"\"Return a formatted string summarizing class metrics of YOLO model.\"\"\"\n    return (\"%22s\" + \"%11s\" * 6) % (\"Class\", \"Images\", \"Instances\", \"Box(P\", \"R\", \"mAP50\", \"mAP50-95)\")\n</code></pre>"},{"location":"reference/models/yolo/detect/val/#ultralytics.models.yolo.detect.val.DetectionValidator.get_stats","title":"<code>get_stats()</code>","text":"<p>Returns metrics statistics and results dictionary.</p> Source code in <code>ultralytics/models/yolo/detect/val.py</code> <pre><code>def get_stats(self):\n    \"\"\"Returns metrics statistics and results dictionary.\"\"\"\n    stats = {k: torch.cat(v, 0).cpu().numpy() for k, v in self.stats.items()}  # to numpy\n    if len(stats) and stats[\"tp\"].any():\n        self.metrics.process(**stats)\n    self.nt_per_class = np.bincount(\n        stats[\"target_cls\"].astype(int), minlength=self.nc\n    )  # number of targets per class\n    return self.metrics.results_dict\n</code></pre>"},{"location":"reference/models/yolo/detect/val/#ultralytics.models.yolo.detect.val.DetectionValidator.init_metrics","title":"<code>init_metrics(model)</code>","text":"<p>Initialize evaluation metrics for YOLO.</p> Source code in <code>ultralytics/models/yolo/detect/val.py</code> <pre><code>def init_metrics(self, model):\n    \"\"\"Initialize evaluation metrics for YOLO.\"\"\"\n    val = self.data.get(self.args.split, \"\")  # validation path\n    self.is_coco = isinstance(val, str) and \"coco\" in val and val.endswith(f\"{os.sep}val2017.txt\")  # is COCO\n    self.class_map = converter.coco80_to_coco91_class() if self.is_coco else list(range(1000))\n    self.args.save_json |= self.is_coco and not self.training  # run on final val if training COCO\n    self.names = model.names\n    self.nc = len(model.names)\n    self.metrics.names = self.names\n    self.metrics.plot = self.args.plots\n    self.confusion_matrix = ConfusionMatrix(nc=self.nc, conf=self.args.conf)\n    self.seen = 0\n    self.jdict = []\n    self.stats = dict(tp=[], conf=[], pred_cls=[], target_cls=[])\n</code></pre>"},{"location":"reference/models/yolo/detect/val/#ultralytics.models.yolo.detect.val.DetectionValidator.plot_predictions","title":"<code>plot_predictions(batch, preds, ni)</code>","text":"<p>Plots predicted bounding boxes on input images and saves the result.</p> Source code in <code>ultralytics/models/yolo/detect/val.py</code> <pre><code>def plot_predictions(self, batch, preds, ni):\n    \"\"\"Plots predicted bounding boxes on input images and saves the result.\"\"\"\n    plot_images(\n        batch[\"img\"],\n        *output_to_target(preds, max_det=self.args.max_det),\n        paths=batch[\"im_file\"],\n        fname=self.save_dir / f\"val_batch{ni}_pred.jpg\",\n        names=self.names,\n        on_plot=self.on_plot,\n    )  # pred\n</code></pre>"},{"location":"reference/models/yolo/detect/val/#ultralytics.models.yolo.detect.val.DetectionValidator.plot_val_samples","title":"<code>plot_val_samples(batch, ni)</code>","text":"<p>Plot validation image samples.</p> Source code in <code>ultralytics/models/yolo/detect/val.py</code> <pre><code>def plot_val_samples(self, batch, ni):\n    \"\"\"Plot validation image samples.\"\"\"\n    plot_images(\n        batch[\"img\"],\n        batch[\"batch_idx\"],\n        batch[\"cls\"].squeeze(-1),\n        batch[\"bboxes\"],\n        paths=batch[\"im_file\"],\n        fname=self.save_dir / f\"val_batch{ni}_labels.jpg\",\n        names=self.names,\n        on_plot=self.on_plot,\n    )\n</code></pre>"},{"location":"reference/models/yolo/detect/val/#ultralytics.models.yolo.detect.val.DetectionValidator.postprocess","title":"<code>postprocess(preds)</code>","text":"<p>Apply Non-maximum suppression to prediction outputs.</p> Source code in <code>ultralytics/models/yolo/detect/val.py</code> <pre><code>def postprocess(self, preds):\n    \"\"\"Apply Non-maximum suppression to prediction outputs.\"\"\"\n    return ops.non_max_suppression(\n        preds,\n        self.args.conf,\n        self.args.iou,\n        labels=self.lb,\n        multi_label=True,\n        agnostic=self.args.single_cls,\n        max_det=self.args.max_det,\n    )\n</code></pre>"},{"location":"reference/models/yolo/detect/val/#ultralytics.models.yolo.detect.val.DetectionValidator.pred_to_json","title":"<code>pred_to_json(predn, filename)</code>","text":"<p>Serialize YOLO predictions to COCO json format.</p> Source code in <code>ultralytics/models/yolo/detect/val.py</code> <pre><code>def pred_to_json(self, predn, filename):\n    \"\"\"Serialize YOLO predictions to COCO json format.\"\"\"\n    stem = Path(filename).stem\n    image_id = int(stem) if stem.isnumeric() else stem\n    box = ops.xyxy2xywh(predn[:, :4])  # xywh\n    box[:, :2] -= box[:, 2:] / 2  # xy center to top-left corner\n    for p, b in zip(predn.tolist(), box.tolist()):\n        self.jdict.append(\n            {\n                \"image_id\": image_id,\n                \"category_id\": self.class_map[int(p[5])],\n                \"bbox\": [round(x, 3) for x in b],\n                \"score\": round(p[4], 5),\n            }\n        )\n</code></pre>"},{"location":"reference/models/yolo/detect/val/#ultralytics.models.yolo.detect.val.DetectionValidator.preprocess","title":"<code>preprocess(batch)</code>","text":"<p>Preprocesses batch of images for YOLO training.</p> Source code in <code>ultralytics/models/yolo/detect/val.py</code> <pre><code>def preprocess(self, batch):\n    \"\"\"Preprocesses batch of images for YOLO training.\"\"\"\n    batch[\"img\"] = batch[\"img\"].to(self.device, non_blocking=True)\n    batch[\"img\"] = (batch[\"img\"].half() if self.args.half else batch[\"img\"].float()) / 255\n    for k in [\"batch_idx\", \"cls\", \"bboxes\"]:\n        batch[k] = batch[k].to(self.device)\n\n    if self.args.save_hybrid:\n        height, width = batch[\"img\"].shape[2:]\n        nb = len(batch[\"img\"])\n        bboxes = batch[\"bboxes\"] * torch.tensor((width, height, width, height), device=self.device)\n        self.lb = (\n            [\n                torch.cat([batch[\"cls\"][batch[\"batch_idx\"] == i], bboxes[batch[\"batch_idx\"] == i]], dim=-1)\n                for i in range(nb)\n            ]\n            if self.args.save_hybrid\n            else []\n        )  # for autolabelling\n\n    return batch\n</code></pre>"},{"location":"reference/models/yolo/detect/val/#ultralytics.models.yolo.detect.val.DetectionValidator.print_results","title":"<code>print_results()</code>","text":"<p>Prints training/validation set metrics per class.</p> Source code in <code>ultralytics/models/yolo/detect/val.py</code> <pre><code>def print_results(self):\n    \"\"\"Prints training/validation set metrics per class.\"\"\"\n    pf = \"%22s\" + \"%11i\" * 2 + \"%11.3g\" * len(self.metrics.keys)  # print format\n    LOGGER.info(pf % (\"all\", self.seen, self.nt_per_class.sum(), *self.metrics.mean_results()))\n    if self.nt_per_class.sum() == 0:\n        LOGGER.warning(f\"WARNING \u26a0\ufe0f no labels found in {self.args.task} set, can not compute metrics without labels\")\n\n    # Print results per class\n    if self.args.verbose and not self.training and self.nc &gt; 1 and len(self.stats):\n        for i, c in enumerate(self.metrics.ap_class_index):\n            LOGGER.info(pf % (self.names[c], self.seen, self.nt_per_class[c], *self.metrics.class_result(i)))\n\n    if self.args.plots:\n        for normalize in True, False:\n            self.confusion_matrix.plot(\n                save_dir=self.save_dir, names=self.names.values(), normalize=normalize, on_plot=self.on_plot\n            )\n</code></pre>"},{"location":"reference/models/yolo/detect/val/#ultralytics.models.yolo.detect.val.DetectionValidator.save_one_txt","title":"<code>save_one_txt(predn, save_conf, shape, file)</code>","text":"<p>Save YOLO detections to a txt file in normalized coordinates in a specific format.</p> Source code in <code>ultralytics/models/yolo/detect/val.py</code> <pre><code>def save_one_txt(self, predn, save_conf, shape, file):\n    \"\"\"Save YOLO detections to a txt file in normalized coordinates in a specific format.\"\"\"\n    gn = torch.tensor(shape)[[1, 0, 1, 0]]  # normalization gain whwh\n    for *xyxy, conf, cls in predn.tolist():\n        xywh = (ops.xyxy2xywh(torch.tensor(xyxy).view(1, 4)) / gn).view(-1).tolist()  # normalized xywh\n        line = (cls, *xywh, conf) if save_conf else (cls, *xywh)  # label format\n        with open(file, \"a\") as f:\n            f.write((\"%g \" * len(line)).rstrip() % line + \"\\n\")\n</code></pre>"},{"location":"reference/models/yolo/detect/val/#ultralytics.models.yolo.detect.val.DetectionValidator.update_metrics","title":"<code>update_metrics(preds, batch)</code>","text":"<p>Metrics.</p> Source code in <code>ultralytics/models/yolo/detect/val.py</code> <pre><code>def update_metrics(self, preds, batch):\n    \"\"\"Metrics.\"\"\"\n    for si, pred in enumerate(preds):\n        self.seen += 1\n        npr = len(pred)\n        stat = dict(\n            conf=torch.zeros(0, device=self.device),\n            pred_cls=torch.zeros(0, device=self.device),\n            tp=torch.zeros(npr, self.niou, dtype=torch.bool, device=self.device),\n        )\n        pbatch = self._prepare_batch(si, batch)\n        cls, bbox = pbatch.pop(\"cls\"), pbatch.pop(\"bbox\")\n        nl = len(cls)\n        stat[\"target_cls\"] = cls\n        if npr == 0:\n            if nl:\n                for k in self.stats.keys():\n                    self.stats[k].append(stat[k])\n                # TODO: obb has not supported confusion_matrix yet.\n                if self.args.plots and self.args.task != \"obb\":\n                    self.confusion_matrix.process_batch(detections=None, gt_bboxes=bbox, gt_cls=cls)\n            continue\n\n        # Predictions\n        if self.args.single_cls:\n            pred[:, 5] = 0\n        predn = self._prepare_pred(pred, pbatch)\n        stat[\"conf\"] = predn[:, 4]\n        stat[\"pred_cls\"] = predn[:, 5]\n\n        # Evaluate\n        if nl:\n            stat[\"tp\"] = self._process_batch(predn, bbox, cls)\n            # TODO: obb has not supported confusion_matrix yet.\n            if self.args.plots and self.args.task != \"obb\":\n                self.confusion_matrix.process_batch(predn, bbox, cls)\n        for k in self.stats.keys():\n            self.stats[k].append(stat[k])\n\n        # Save\n        if self.args.save_json:\n            self.pred_to_json(predn, batch[\"im_file\"][si])\n        if self.args.save_txt:\n            file = self.save_dir / \"labels\" / f'{Path(batch[\"im_file\"][si]).stem}.txt'\n            self.save_one_txt(predn, self.args.save_conf, pbatch[\"ori_shape\"], file)\n</code></pre>"},{"location":"reference/models/yolo/obb/predict/","title":"Reference for <code>ultralytics/models/yolo/obb/predict.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/yolo/obb/predict.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/yolo/obb/predict/#ultralytics.models.yolo.obb.predict.OBBPredictor","title":"<code>ultralytics.models.yolo.obb.predict.OBBPredictor</code>","text":"<p>             Bases: <code>DetectionPredictor</code></p> <p>A class extending the DetectionPredictor class for prediction based on an Oriented Bounding Box (OBB) model.</p> Example <pre><code>from ultralytics.utils import ASSETS\nfrom ultralytics.models.yolo.obb import OBBPredictor\n\nargs = dict(model='yolov8n-obb.pt', source=ASSETS)\npredictor = OBBPredictor(overrides=args)\npredictor.predict_cli()\n</code></pre> Source code in <code>ultralytics/models/yolo/obb/predict.py</code> <pre><code>class OBBPredictor(DetectionPredictor):\n    \"\"\"\n    A class extending the DetectionPredictor class for prediction based on an Oriented Bounding Box (OBB) model.\n\n    Example:\n        ```python\n        from ultralytics.utils import ASSETS\n        from ultralytics.models.yolo.obb import OBBPredictor\n\n        args = dict(model='yolov8n-obb.pt', source=ASSETS)\n        predictor = OBBPredictor(overrides=args)\n        predictor.predict_cli()\n        ```\n    \"\"\"\n\n    def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n        \"\"\"Initializes OBBPredictor with optional model and data configuration overrides.\"\"\"\n        super().__init__(cfg, overrides, _callbacks)\n        self.args.task = \"obb\"\n\n    def postprocess(self, preds, img, orig_imgs):\n        \"\"\"Post-processes predictions and returns a list of Results objects.\"\"\"\n        preds = ops.non_max_suppression(\n            preds,\n            self.args.conf,\n            self.args.iou,\n            agnostic=self.args.agnostic_nms,\n            max_det=self.args.max_det,\n            nc=len(self.model.names),\n            classes=self.args.classes,\n            rotated=True,\n        )\n\n        if not isinstance(orig_imgs, list):  # input images are a torch.Tensor, not a list\n            orig_imgs = ops.convert_torch2numpy_batch(orig_imgs)\n\n        results = []\n        for i, (pred, orig_img, img_path) in enumerate(zip(preds, orig_imgs, self.batch[0])):\n            pred[:, :4] = ops.scale_boxes(img.shape[2:], pred[:, :4], orig_img.shape, xywh=True)\n            # xywh, r, conf, cls\n            obb = torch.cat([pred[:, :4], pred[:, -1:], pred[:, 4:6]], dim=-1)\n            results.append(Results(orig_img, path=img_path, names=self.model.names, obb=obb))\n        return results\n</code></pre>"},{"location":"reference/models/yolo/obb/predict/#ultralytics.models.yolo.obb.predict.OBBPredictor.__init__","title":"<code>__init__(cfg=DEFAULT_CFG, overrides=None, _callbacks=None)</code>","text":"<p>Initializes OBBPredictor with optional model and data configuration overrides.</p> Source code in <code>ultralytics/models/yolo/obb/predict.py</code> <pre><code>def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n    \"\"\"Initializes OBBPredictor with optional model and data configuration overrides.\"\"\"\n    super().__init__(cfg, overrides, _callbacks)\n    self.args.task = \"obb\"\n</code></pre>"},{"location":"reference/models/yolo/obb/predict/#ultralytics.models.yolo.obb.predict.OBBPredictor.postprocess","title":"<code>postprocess(preds, img, orig_imgs)</code>","text":"<p>Post-processes predictions and returns a list of Results objects.</p> Source code in <code>ultralytics/models/yolo/obb/predict.py</code> <pre><code>def postprocess(self, preds, img, orig_imgs):\n    \"\"\"Post-processes predictions and returns a list of Results objects.\"\"\"\n    preds = ops.non_max_suppression(\n        preds,\n        self.args.conf,\n        self.args.iou,\n        agnostic=self.args.agnostic_nms,\n        max_det=self.args.max_det,\n        nc=len(self.model.names),\n        classes=self.args.classes,\n        rotated=True,\n    )\n\n    if not isinstance(orig_imgs, list):  # input images are a torch.Tensor, not a list\n        orig_imgs = ops.convert_torch2numpy_batch(orig_imgs)\n\n    results = []\n    for i, (pred, orig_img, img_path) in enumerate(zip(preds, orig_imgs, self.batch[0])):\n        pred[:, :4] = ops.scale_boxes(img.shape[2:], pred[:, :4], orig_img.shape, xywh=True)\n        # xywh, r, conf, cls\n        obb = torch.cat([pred[:, :4], pred[:, -1:], pred[:, 4:6]], dim=-1)\n        results.append(Results(orig_img, path=img_path, names=self.model.names, obb=obb))\n    return results\n</code></pre>"},{"location":"reference/models/yolo/obb/train/","title":"Reference for <code>ultralytics/models/yolo/obb/train.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/yolo/obb/train.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/yolo/obb/train/#ultralytics.models.yolo.obb.train.OBBTrainer","title":"<code>ultralytics.models.yolo.obb.train.OBBTrainer</code>","text":"<p>             Bases: <code>DetectionTrainer</code></p> <p>A class extending the DetectionTrainer class for training based on an Oriented Bounding Box (OBB) model.</p> Example <pre><code>from ultralytics.models.yolo.obb import OBBTrainer\n\nargs = dict(model='yolov8n-seg.pt', data='coco8-seg.yaml', epochs=3)\ntrainer = OBBTrainer(overrides=args)\ntrainer.train()\n</code></pre> Source code in <code>ultralytics/models/yolo/obb/train.py</code> <pre><code>class OBBTrainer(yolo.detect.DetectionTrainer):\n    \"\"\"\n    A class extending the DetectionTrainer class for training based on an Oriented Bounding Box (OBB) model.\n\n    Example:\n        ```python\n        from ultralytics.models.yolo.obb import OBBTrainer\n\n        args = dict(model='yolov8n-seg.pt', data='coco8-seg.yaml', epochs=3)\n        trainer = OBBTrainer(overrides=args)\n        trainer.train()\n        ```\n    \"\"\"\n\n    def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n        \"\"\"Initialize a OBBTrainer object with given arguments.\"\"\"\n        if overrides is None:\n            overrides = {}\n        overrides[\"task\"] = \"obb\"\n        super().__init__(cfg, overrides, _callbacks)\n\n    def get_model(self, cfg=None, weights=None, verbose=True):\n        \"\"\"Return OBBModel initialized with specified config and weights.\"\"\"\n        model = OBBModel(cfg, ch=3, nc=self.data[\"nc\"], verbose=verbose and RANK == -1)\n        if weights:\n            model.load(weights)\n\n        return model\n\n    def get_validator(self):\n        \"\"\"Return an instance of OBBValidator for validation of YOLO model.\"\"\"\n        self.loss_names = \"box_loss\", \"cls_loss\", \"dfl_loss\"\n        return yolo.obb.OBBValidator(self.test_loader, save_dir=self.save_dir, args=copy(self.args))\n</code></pre>"},{"location":"reference/models/yolo/obb/train/#ultralytics.models.yolo.obb.train.OBBTrainer.__init__","title":"<code>__init__(cfg=DEFAULT_CFG, overrides=None, _callbacks=None)</code>","text":"<p>Initialize a OBBTrainer object with given arguments.</p> Source code in <code>ultralytics/models/yolo/obb/train.py</code> <pre><code>def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n    \"\"\"Initialize a OBBTrainer object with given arguments.\"\"\"\n    if overrides is None:\n        overrides = {}\n    overrides[\"task\"] = \"obb\"\n    super().__init__(cfg, overrides, _callbacks)\n</code></pre>"},{"location":"reference/models/yolo/obb/train/#ultralytics.models.yolo.obb.train.OBBTrainer.get_model","title":"<code>get_model(cfg=None, weights=None, verbose=True)</code>","text":"<p>Return OBBModel initialized with specified config and weights.</p> Source code in <code>ultralytics/models/yolo/obb/train.py</code> <pre><code>def get_model(self, cfg=None, weights=None, verbose=True):\n    \"\"\"Return OBBModel initialized with specified config and weights.\"\"\"\n    model = OBBModel(cfg, ch=3, nc=self.data[\"nc\"], verbose=verbose and RANK == -1)\n    if weights:\n        model.load(weights)\n\n    return model\n</code></pre>"},{"location":"reference/models/yolo/obb/train/#ultralytics.models.yolo.obb.train.OBBTrainer.get_validator","title":"<code>get_validator()</code>","text":"<p>Return an instance of OBBValidator for validation of YOLO model.</p> Source code in <code>ultralytics/models/yolo/obb/train.py</code> <pre><code>def get_validator(self):\n    \"\"\"Return an instance of OBBValidator for validation of YOLO model.\"\"\"\n    self.loss_names = \"box_loss\", \"cls_loss\", \"dfl_loss\"\n    return yolo.obb.OBBValidator(self.test_loader, save_dir=self.save_dir, args=copy(self.args))\n</code></pre>"},{"location":"reference/models/yolo/obb/val/","title":"Reference for <code>ultralytics/models/yolo/obb/val.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/yolo/obb/val.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/yolo/obb/val/#ultralytics.models.yolo.obb.val.OBBValidator","title":"<code>ultralytics.models.yolo.obb.val.OBBValidator</code>","text":"<p>             Bases: <code>DetectionValidator</code></p> <p>A class extending the DetectionValidator class for validation based on an Oriented Bounding Box (OBB) model.</p> Example <pre><code>from ultralytics.models.yolo.obb import OBBValidator\n\nargs = dict(model='yolov8n-obb.pt', data='coco8-seg.yaml')\nvalidator = OBBValidator(args=args)\nvalidator(model=args['model'])\n</code></pre> Source code in <code>ultralytics/models/yolo/obb/val.py</code> <pre><code>class OBBValidator(DetectionValidator):\n    \"\"\"\n    A class extending the DetectionValidator class for validation based on an Oriented Bounding Box (OBB) model.\n\n    Example:\n        ```python\n        from ultralytics.models.yolo.obb import OBBValidator\n\n        args = dict(model='yolov8n-obb.pt', data='coco8-seg.yaml')\n        validator = OBBValidator(args=args)\n        validator(model=args['model'])\n        ```\n    \"\"\"\n\n    def __init__(self, dataloader=None, save_dir=None, pbar=None, args=None, _callbacks=None):\n        \"\"\"Initialize OBBValidator and set task to 'obb', metrics to OBBMetrics.\"\"\"\n        super().__init__(dataloader, save_dir, pbar, args, _callbacks)\n        self.args.task = \"obb\"\n        self.metrics = OBBMetrics(save_dir=self.save_dir, plot=True, on_plot=self.on_plot)\n\n    def init_metrics(self, model):\n        \"\"\"Initialize evaluation metrics for YOLO.\"\"\"\n        super().init_metrics(model)\n        val = self.data.get(self.args.split, \"\")  # validation path\n        self.is_dota = isinstance(val, str) and \"DOTA\" in val  # is COCO\n\n    def postprocess(self, preds):\n        \"\"\"Apply Non-maximum suppression to prediction outputs.\"\"\"\n        return ops.non_max_suppression(\n            preds,\n            self.args.conf,\n            self.args.iou,\n            labels=self.lb,\n            nc=self.nc,\n            multi_label=True,\n            agnostic=self.args.single_cls,\n            max_det=self.args.max_det,\n            rotated=True,\n        )\n\n    def _process_batch(self, detections, gt_bboxes, gt_cls):\n        \"\"\"\n        Return correct prediction matrix.\n\n        Args:\n            detections (torch.Tensor): Tensor of shape [N, 6] representing detections.\n                Each detection is of the format: x1, y1, x2, y2, conf, class.\n            labels (torch.Tensor): Tensor of shape [M, 5] representing labels.\n                Each label is of the format: class, x1, y1, x2, y2.\n\n        Returns:\n            (torch.Tensor): Correct prediction matrix of shape [N, 10] for 10 IoU levels.\n        \"\"\"\n        iou = batch_probiou(gt_bboxes, torch.cat([detections[:, :4], detections[:, -1:]], dim=-1))\n        return self.match_predictions(detections[:, 5], gt_cls, iou)\n\n    def _prepare_batch(self, si, batch):\n        \"\"\"Prepares and returns a batch for OBB validation.\"\"\"\n        idx = batch[\"batch_idx\"] == si\n        cls = batch[\"cls\"][idx].squeeze(-1)\n        bbox = batch[\"bboxes\"][idx]\n        ori_shape = batch[\"ori_shape\"][si]\n        imgsz = batch[\"img\"].shape[2:]\n        ratio_pad = batch[\"ratio_pad\"][si]\n        if len(cls):\n            bbox[..., :4].mul_(torch.tensor(imgsz, device=self.device)[[1, 0, 1, 0]])  # target boxes\n            ops.scale_boxes(imgsz, bbox, ori_shape, ratio_pad=ratio_pad, xywh=True)  # native-space labels\n        prepared_batch = dict(cls=cls, bbox=bbox, ori_shape=ori_shape, imgsz=imgsz, ratio_pad=ratio_pad)\n        return prepared_batch\n\n    def _prepare_pred(self, pred, pbatch):\n        \"\"\"Prepares and returns a batch for OBB validation with scaled and padded bounding boxes.\"\"\"\n        predn = pred.clone()\n        ops.scale_boxes(\n            pbatch[\"imgsz\"], predn[:, :4], pbatch[\"ori_shape\"], ratio_pad=pbatch[\"ratio_pad\"], xywh=True\n        )  # native-space pred\n        return predn\n\n    def plot_predictions(self, batch, preds, ni):\n        \"\"\"Plots predicted bounding boxes on input images and saves the result.\"\"\"\n        plot_images(\n            batch[\"img\"],\n            *output_to_rotated_target(preds, max_det=self.args.max_det),\n            paths=batch[\"im_file\"],\n            fname=self.save_dir / f\"val_batch{ni}_pred.jpg\",\n            names=self.names,\n            on_plot=self.on_plot,\n        )  # pred\n\n    def pred_to_json(self, predn, filename):\n        \"\"\"Serialize YOLO predictions to COCO json format.\"\"\"\n        stem = Path(filename).stem\n        image_id = int(stem) if stem.isnumeric() else stem\n        rbox = torch.cat([predn[:, :4], predn[:, -1:]], dim=-1)\n        poly = ops.xywhr2xyxyxyxy(rbox).view(-1, 8)\n        for i, (r, b) in enumerate(zip(rbox.tolist(), poly.tolist())):\n            self.jdict.append(\n                {\n                    \"image_id\": image_id,\n                    \"category_id\": self.class_map[int(predn[i, 5].item())],\n                    \"score\": round(predn[i, 4].item(), 5),\n                    \"rbox\": [round(x, 3) for x in r],\n                    \"poly\": [round(x, 3) for x in b],\n                }\n            )\n\n    def save_one_txt(self, predn, save_conf, shape, file):\n        \"\"\"Save YOLO detections to a txt file in normalized coordinates in a specific format.\"\"\"\n        gn = torch.tensor(shape)[[1, 0, 1, 0]]  # normalization gain whwh\n        for *xyxy, conf, cls, angle in predn.tolist():\n            xywha = torch.tensor([*xyxy, angle]).view(1, 5)\n            xywha[:, :4] /= gn\n            xyxyxyxy = ops.xywhr2xyxyxyxy(xywha).view(-1).tolist()  # normalized xywh\n            line = (cls, *xyxyxyxy, conf) if save_conf else (cls, *xyxyxyxy)  # label format\n            with open(file, \"a\") as f:\n                f.write((\"%g \" * len(line)).rstrip() % line + \"\\n\")\n\n    def eval_json(self, stats):\n        \"\"\"Evaluates YOLO output in JSON format and returns performance statistics.\"\"\"\n        if self.args.save_json and self.is_dota and len(self.jdict):\n            import json\n            import re\n            from collections import defaultdict\n\n            pred_json = self.save_dir / \"predictions.json\"  # predictions\n            pred_txt = self.save_dir / \"predictions_txt\"  # predictions\n            pred_txt.mkdir(parents=True, exist_ok=True)\n            data = json.load(open(pred_json))\n            # Save split results\n            LOGGER.info(f\"Saving predictions with DOTA format to {str(pred_txt)}...\")\n            for d in data:\n                image_id = d[\"image_id\"]\n                score = d[\"score\"]\n                classname = self.names[d[\"category_id\"]].replace(\" \", \"-\")\n\n                lines = \"{} {} {} {} {} {} {} {} {} {}\\n\".format(\n                    image_id,\n                    score,\n                    d[\"poly\"][0],\n                    d[\"poly\"][1],\n                    d[\"poly\"][2],\n                    d[\"poly\"][3],\n                    d[\"poly\"][4],\n                    d[\"poly\"][5],\n                    d[\"poly\"][6],\n                    d[\"poly\"][7],\n                )\n                with open(str(pred_txt / f\"Task1_{classname}\") + \".txt\", \"a\") as f:\n                    f.writelines(lines)\n            # Save merged results, this could result slightly lower map than using official merging script,\n            # because of the probiou calculation.\n            pred_merged_txt = self.save_dir / \"predictions_merged_txt\"  # predictions\n            pred_merged_txt.mkdir(parents=True, exist_ok=True)\n            merged_results = defaultdict(list)\n            LOGGER.info(f\"Saving merged predictions with DOTA format to {str(pred_merged_txt)}...\")\n            for d in data:\n                image_id = d[\"image_id\"].split(\"__\")[0]\n                pattern = re.compile(r\"\\d+___\\d+\")\n                x, y = (int(c) for c in re.findall(pattern, d[\"image_id\"])[0].split(\"___\"))\n                bbox, score, cls = d[\"rbox\"], d[\"score\"], d[\"category_id\"]\n                bbox[0] += x\n                bbox[1] += y\n                bbox.extend([score, cls])\n                merged_results[image_id].append(bbox)\n            for image_id, bbox in merged_results.items():\n                bbox = torch.tensor(bbox)\n                max_wh = torch.max(bbox[:, :2]).item() * 2\n                c = bbox[:, 6:7] * max_wh  # classes\n                scores = bbox[:, 5]  # scores\n                b = bbox[:, :5].clone()\n                b[:, :2] += c\n                # 0.3 could get results close to the ones from official merging script, even slightly better.\n                i = ops.nms_rotated(b, scores, 0.3)\n                bbox = bbox[i]\n\n                b = ops.xywhr2xyxyxyxy(bbox[:, :5]).view(-1, 8)\n                for x in torch.cat([b, bbox[:, 5:7]], dim=-1).tolist():\n                    classname = self.names[int(x[-1])].replace(\" \", \"-\")\n                    poly = [round(i, 3) for i in x[:-2]]\n                    score = round(x[-2], 3)\n\n                    lines = \"{} {} {} {} {} {} {} {} {} {}\\n\".format(\n                        image_id,\n                        score,\n                        poly[0],\n                        poly[1],\n                        poly[2],\n                        poly[3],\n                        poly[4],\n                        poly[5],\n                        poly[6],\n                        poly[7],\n                    )\n                    with open(str(pred_merged_txt / f\"Task1_{classname}\") + \".txt\", \"a\") as f:\n                        f.writelines(lines)\n\n        return stats\n</code></pre>"},{"location":"reference/models/yolo/obb/val/#ultralytics.models.yolo.obb.val.OBBValidator.__init__","title":"<code>__init__(dataloader=None, save_dir=None, pbar=None, args=None, _callbacks=None)</code>","text":"<p>Initialize OBBValidator and set task to 'obb', metrics to OBBMetrics.</p> Source code in <code>ultralytics/models/yolo/obb/val.py</code> <pre><code>def __init__(self, dataloader=None, save_dir=None, pbar=None, args=None, _callbacks=None):\n    \"\"\"Initialize OBBValidator and set task to 'obb', metrics to OBBMetrics.\"\"\"\n    super().__init__(dataloader, save_dir, pbar, args, _callbacks)\n    self.args.task = \"obb\"\n    self.metrics = OBBMetrics(save_dir=self.save_dir, plot=True, on_plot=self.on_plot)\n</code></pre>"},{"location":"reference/models/yolo/obb/val/#ultralytics.models.yolo.obb.val.OBBValidator.eval_json","title":"<code>eval_json(stats)</code>","text":"<p>Evaluates YOLO output in JSON format and returns performance statistics.</p> Source code in <code>ultralytics/models/yolo/obb/val.py</code> <pre><code>def eval_json(self, stats):\n    \"\"\"Evaluates YOLO output in JSON format and returns performance statistics.\"\"\"\n    if self.args.save_json and self.is_dota and len(self.jdict):\n        import json\n        import re\n        from collections import defaultdict\n\n        pred_json = self.save_dir / \"predictions.json\"  # predictions\n        pred_txt = self.save_dir / \"predictions_txt\"  # predictions\n        pred_txt.mkdir(parents=True, exist_ok=True)\n        data = json.load(open(pred_json))\n        # Save split results\n        LOGGER.info(f\"Saving predictions with DOTA format to {str(pred_txt)}...\")\n        for d in data:\n            image_id = d[\"image_id\"]\n            score = d[\"score\"]\n            classname = self.names[d[\"category_id\"]].replace(\" \", \"-\")\n\n            lines = \"{} {} {} {} {} {} {} {} {} {}\\n\".format(\n                image_id,\n                score,\n                d[\"poly\"][0],\n                d[\"poly\"][1],\n                d[\"poly\"][2],\n                d[\"poly\"][3],\n                d[\"poly\"][4],\n                d[\"poly\"][5],\n                d[\"poly\"][6],\n                d[\"poly\"][7],\n            )\n            with open(str(pred_txt / f\"Task1_{classname}\") + \".txt\", \"a\") as f:\n                f.writelines(lines)\n        # Save merged results, this could result slightly lower map than using official merging script,\n        # because of the probiou calculation.\n        pred_merged_txt = self.save_dir / \"predictions_merged_txt\"  # predictions\n        pred_merged_txt.mkdir(parents=True, exist_ok=True)\n        merged_results = defaultdict(list)\n        LOGGER.info(f\"Saving merged predictions with DOTA format to {str(pred_merged_txt)}...\")\n        for d in data:\n            image_id = d[\"image_id\"].split(\"__\")[0]\n            pattern = re.compile(r\"\\d+___\\d+\")\n            x, y = (int(c) for c in re.findall(pattern, d[\"image_id\"])[0].split(\"___\"))\n            bbox, score, cls = d[\"rbox\"], d[\"score\"], d[\"category_id\"]\n            bbox[0] += x\n            bbox[1] += y\n            bbox.extend([score, cls])\n            merged_results[image_id].append(bbox)\n        for image_id, bbox in merged_results.items():\n            bbox = torch.tensor(bbox)\n            max_wh = torch.max(bbox[:, :2]).item() * 2\n            c = bbox[:, 6:7] * max_wh  # classes\n            scores = bbox[:, 5]  # scores\n            b = bbox[:, :5].clone()\n            b[:, :2] += c\n            # 0.3 could get results close to the ones from official merging script, even slightly better.\n            i = ops.nms_rotated(b, scores, 0.3)\n            bbox = bbox[i]\n\n            b = ops.xywhr2xyxyxyxy(bbox[:, :5]).view(-1, 8)\n            for x in torch.cat([b, bbox[:, 5:7]], dim=-1).tolist():\n                classname = self.names[int(x[-1])].replace(\" \", \"-\")\n                poly = [round(i, 3) for i in x[:-2]]\n                score = round(x[-2], 3)\n\n                lines = \"{} {} {} {} {} {} {} {} {} {}\\n\".format(\n                    image_id,\n                    score,\n                    poly[0],\n                    poly[1],\n                    poly[2],\n                    poly[3],\n                    poly[4],\n                    poly[5],\n                    poly[6],\n                    poly[7],\n                )\n                with open(str(pred_merged_txt / f\"Task1_{classname}\") + \".txt\", \"a\") as f:\n                    f.writelines(lines)\n\n    return stats\n</code></pre>"},{"location":"reference/models/yolo/obb/val/#ultralytics.models.yolo.obb.val.OBBValidator.init_metrics","title":"<code>init_metrics(model)</code>","text":"<p>Initialize evaluation metrics for YOLO.</p> Source code in <code>ultralytics/models/yolo/obb/val.py</code> <pre><code>def init_metrics(self, model):\n    \"\"\"Initialize evaluation metrics for YOLO.\"\"\"\n    super().init_metrics(model)\n    val = self.data.get(self.args.split, \"\")  # validation path\n    self.is_dota = isinstance(val, str) and \"DOTA\" in val  # is COCO\n</code></pre>"},{"location":"reference/models/yolo/obb/val/#ultralytics.models.yolo.obb.val.OBBValidator.plot_predictions","title":"<code>plot_predictions(batch, preds, ni)</code>","text":"<p>Plots predicted bounding boxes on input images and saves the result.</p> Source code in <code>ultralytics/models/yolo/obb/val.py</code> <pre><code>def plot_predictions(self, batch, preds, ni):\n    \"\"\"Plots predicted bounding boxes on input images and saves the result.\"\"\"\n    plot_images(\n        batch[\"img\"],\n        *output_to_rotated_target(preds, max_det=self.args.max_det),\n        paths=batch[\"im_file\"],\n        fname=self.save_dir / f\"val_batch{ni}_pred.jpg\",\n        names=self.names,\n        on_plot=self.on_plot,\n    )  # pred\n</code></pre>"},{"location":"reference/models/yolo/obb/val/#ultralytics.models.yolo.obb.val.OBBValidator.postprocess","title":"<code>postprocess(preds)</code>","text":"<p>Apply Non-maximum suppression to prediction outputs.</p> Source code in <code>ultralytics/models/yolo/obb/val.py</code> <pre><code>def postprocess(self, preds):\n    \"\"\"Apply Non-maximum suppression to prediction outputs.\"\"\"\n    return ops.non_max_suppression(\n        preds,\n        self.args.conf,\n        self.args.iou,\n        labels=self.lb,\n        nc=self.nc,\n        multi_label=True,\n        agnostic=self.args.single_cls,\n        max_det=self.args.max_det,\n        rotated=True,\n    )\n</code></pre>"},{"location":"reference/models/yolo/obb/val/#ultralytics.models.yolo.obb.val.OBBValidator.pred_to_json","title":"<code>pred_to_json(predn, filename)</code>","text":"<p>Serialize YOLO predictions to COCO json format.</p> Source code in <code>ultralytics/models/yolo/obb/val.py</code> <pre><code>def pred_to_json(self, predn, filename):\n    \"\"\"Serialize YOLO predictions to COCO json format.\"\"\"\n    stem = Path(filename).stem\n    image_id = int(stem) if stem.isnumeric() else stem\n    rbox = torch.cat([predn[:, :4], predn[:, -1:]], dim=-1)\n    poly = ops.xywhr2xyxyxyxy(rbox).view(-1, 8)\n    for i, (r, b) in enumerate(zip(rbox.tolist(), poly.tolist())):\n        self.jdict.append(\n            {\n                \"image_id\": image_id,\n                \"category_id\": self.class_map[int(predn[i, 5].item())],\n                \"score\": round(predn[i, 4].item(), 5),\n                \"rbox\": [round(x, 3) for x in r],\n                \"poly\": [round(x, 3) for x in b],\n            }\n        )\n</code></pre>"},{"location":"reference/models/yolo/obb/val/#ultralytics.models.yolo.obb.val.OBBValidator.save_one_txt","title":"<code>save_one_txt(predn, save_conf, shape, file)</code>","text":"<p>Save YOLO detections to a txt file in normalized coordinates in a specific format.</p> Source code in <code>ultralytics/models/yolo/obb/val.py</code> <pre><code>def save_one_txt(self, predn, save_conf, shape, file):\n    \"\"\"Save YOLO detections to a txt file in normalized coordinates in a specific format.\"\"\"\n    gn = torch.tensor(shape)[[1, 0, 1, 0]]  # normalization gain whwh\n    for *xyxy, conf, cls, angle in predn.tolist():\n        xywha = torch.tensor([*xyxy, angle]).view(1, 5)\n        xywha[:, :4] /= gn\n        xyxyxyxy = ops.xywhr2xyxyxyxy(xywha).view(-1).tolist()  # normalized xywh\n        line = (cls, *xyxyxyxy, conf) if save_conf else (cls, *xyxyxyxy)  # label format\n        with open(file, \"a\") as f:\n            f.write((\"%g \" * len(line)).rstrip() % line + \"\\n\")\n</code></pre>"},{"location":"reference/models/yolo/pose/predict/","title":"Reference for <code>ultralytics/models/yolo/pose/predict.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/yolo/pose/predict.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/yolo/pose/predict/#ultralytics.models.yolo.pose.predict.PosePredictor","title":"<code>ultralytics.models.yolo.pose.predict.PosePredictor</code>","text":"<p>             Bases: <code>DetectionPredictor</code></p> <p>A class extending the DetectionPredictor class for prediction based on a pose model.</p> Example <pre><code>from ultralytics.utils import ASSETS\nfrom ultralytics.models.yolo.pose import PosePredictor\n\nargs = dict(model='yolov8n-pose.pt', source=ASSETS)\npredictor = PosePredictor(overrides=args)\npredictor.predict_cli()\n</code></pre> Source code in <code>ultralytics/models/yolo/pose/predict.py</code> <pre><code>class PosePredictor(DetectionPredictor):\n    \"\"\"\n    A class extending the DetectionPredictor class for prediction based on a pose model.\n\n    Example:\n        ```python\n        from ultralytics.utils import ASSETS\n        from ultralytics.models.yolo.pose import PosePredictor\n\n        args = dict(model='yolov8n-pose.pt', source=ASSETS)\n        predictor = PosePredictor(overrides=args)\n        predictor.predict_cli()\n        ```\n    \"\"\"\n\n    def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n        \"\"\"Initializes PosePredictor, sets task to 'pose' and logs a warning for using 'mps' as device.\"\"\"\n        super().__init__(cfg, overrides, _callbacks)\n        self.args.task = \"pose\"\n        if isinstance(self.args.device, str) and self.args.device.lower() == \"mps\":\n            LOGGER.warning(\n                \"WARNING \u26a0\ufe0f Apple MPS known Pose bug. Recommend 'device=cpu' for Pose models. \"\n                \"See https://github.com/ultralytics/ultralytics/issues/4031.\"\n            )\n\n    def postprocess(self, preds, img, orig_imgs):\n        \"\"\"Return detection results for a given input image or list of images.\"\"\"\n        preds = ops.non_max_suppression(\n            preds,\n            self.args.conf,\n            self.args.iou,\n            agnostic=self.args.agnostic_nms,\n            max_det=self.args.max_det,\n            classes=self.args.classes,\n            nc=len(self.model.names),\n        )\n\n        if not isinstance(orig_imgs, list):  # input images are a torch.Tensor, not a list\n            orig_imgs = ops.convert_torch2numpy_batch(orig_imgs)\n\n        results = []\n        for i, pred in enumerate(preds):\n            orig_img = orig_imgs[i]\n            pred[:, :4] = ops.scale_boxes(img.shape[2:], pred[:, :4], orig_img.shape).round()\n            pred_kpts = pred[:, 6:].view(len(pred), *self.model.kpt_shape) if len(pred) else pred[:, 6:]\n            pred_kpts = ops.scale_coords(img.shape[2:], pred_kpts, orig_img.shape)\n            img_path = self.batch[0][i]\n            results.append(\n                Results(orig_img, path=img_path, names=self.model.names, boxes=pred[:, :6], keypoints=pred_kpts)\n            )\n        return results\n</code></pre>"},{"location":"reference/models/yolo/pose/predict/#ultralytics.models.yolo.pose.predict.PosePredictor.__init__","title":"<code>__init__(cfg=DEFAULT_CFG, overrides=None, _callbacks=None)</code>","text":"<p>Initializes PosePredictor, sets task to 'pose' and logs a warning for using 'mps' as device.</p> Source code in <code>ultralytics/models/yolo/pose/predict.py</code> <pre><code>def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n    \"\"\"Initializes PosePredictor, sets task to 'pose' and logs a warning for using 'mps' as device.\"\"\"\n    super().__init__(cfg, overrides, _callbacks)\n    self.args.task = \"pose\"\n    if isinstance(self.args.device, str) and self.args.device.lower() == \"mps\":\n        LOGGER.warning(\n            \"WARNING \u26a0\ufe0f Apple MPS known Pose bug. Recommend 'device=cpu' for Pose models. \"\n            \"See https://github.com/ultralytics/ultralytics/issues/4031.\"\n        )\n</code></pre>"},{"location":"reference/models/yolo/pose/predict/#ultralytics.models.yolo.pose.predict.PosePredictor.postprocess","title":"<code>postprocess(preds, img, orig_imgs)</code>","text":"<p>Return detection results for a given input image or list of images.</p> Source code in <code>ultralytics/models/yolo/pose/predict.py</code> <pre><code>def postprocess(self, preds, img, orig_imgs):\n    \"\"\"Return detection results for a given input image or list of images.\"\"\"\n    preds = ops.non_max_suppression(\n        preds,\n        self.args.conf,\n        self.args.iou,\n        agnostic=self.args.agnostic_nms,\n        max_det=self.args.max_det,\n        classes=self.args.classes,\n        nc=len(self.model.names),\n    )\n\n    if not isinstance(orig_imgs, list):  # input images are a torch.Tensor, not a list\n        orig_imgs = ops.convert_torch2numpy_batch(orig_imgs)\n\n    results = []\n    for i, pred in enumerate(preds):\n        orig_img = orig_imgs[i]\n        pred[:, :4] = ops.scale_boxes(img.shape[2:], pred[:, :4], orig_img.shape).round()\n        pred_kpts = pred[:, 6:].view(len(pred), *self.model.kpt_shape) if len(pred) else pred[:, 6:]\n        pred_kpts = ops.scale_coords(img.shape[2:], pred_kpts, orig_img.shape)\n        img_path = self.batch[0][i]\n        results.append(\n            Results(orig_img, path=img_path, names=self.model.names, boxes=pred[:, :6], keypoints=pred_kpts)\n        )\n    return results\n</code></pre>"},{"location":"reference/models/yolo/pose/train/","title":"Reference for <code>ultralytics/models/yolo/pose/train.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/yolo/pose/train.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/yolo/pose/train/#ultralytics.models.yolo.pose.train.PoseTrainer","title":"<code>ultralytics.models.yolo.pose.train.PoseTrainer</code>","text":"<p>             Bases: <code>DetectionTrainer</code></p> <p>A class extending the DetectionTrainer class for training based on a pose model.</p> Example <pre><code>from ultralytics.models.yolo.pose import PoseTrainer\n\nargs = dict(model='yolov8n-pose.pt', data='coco8-pose.yaml', epochs=3)\ntrainer = PoseTrainer(overrides=args)\ntrainer.train()\n</code></pre> Source code in <code>ultralytics/models/yolo/pose/train.py</code> <pre><code>class PoseTrainer(yolo.detect.DetectionTrainer):\n    \"\"\"\n    A class extending the DetectionTrainer class for training based on a pose model.\n\n    Example:\n        ```python\n        from ultralytics.models.yolo.pose import PoseTrainer\n\n        args = dict(model='yolov8n-pose.pt', data='coco8-pose.yaml', epochs=3)\n        trainer = PoseTrainer(overrides=args)\n        trainer.train()\n        ```\n    \"\"\"\n\n    def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n        \"\"\"Initialize a PoseTrainer object with specified configurations and overrides.\"\"\"\n        if overrides is None:\n            overrides = {}\n        overrides[\"task\"] = \"pose\"\n        super().__init__(cfg, overrides, _callbacks)\n\n        if isinstance(self.args.device, str) and self.args.device.lower() == \"mps\":\n            LOGGER.warning(\n                \"WARNING \u26a0\ufe0f Apple MPS known Pose bug. Recommend 'device=cpu' for Pose models. \"\n                \"See https://github.com/ultralytics/ultralytics/issues/4031.\"\n            )\n\n    def get_model(self, cfg=None, weights=None, verbose=True):\n        \"\"\"Get pose estimation model with specified configuration and weights.\"\"\"\n        model = PoseModel(cfg, ch=3, nc=self.data[\"nc\"], data_kpt_shape=self.data[\"kpt_shape\"], verbose=verbose)\n        if weights:\n            model.load(weights)\n\n        return model\n\n    def set_model_attributes(self):\n        \"\"\"Sets keypoints shape attribute of PoseModel.\"\"\"\n        super().set_model_attributes()\n        self.model.kpt_shape = self.data[\"kpt_shape\"]\n\n    def get_validator(self):\n        \"\"\"Returns an instance of the PoseValidator class for validation.\"\"\"\n        self.loss_names = \"box_loss\", \"pose_loss\", \"kobj_loss\", \"cls_loss\", \"dfl_loss\"\n        return yolo.pose.PoseValidator(\n            self.test_loader, save_dir=self.save_dir, args=copy(self.args), _callbacks=self.callbacks\n        )\n\n    def plot_training_samples(self, batch, ni):\n        \"\"\"Plot a batch of training samples with annotated class labels, bounding boxes, and keypoints.\"\"\"\n        images = batch[\"img\"]\n        kpts = batch[\"keypoints\"]\n        cls = batch[\"cls\"].squeeze(-1)\n        bboxes = batch[\"bboxes\"]\n        paths = batch[\"im_file\"]\n        batch_idx = batch[\"batch_idx\"]\n        plot_images(\n            images,\n            batch_idx,\n            cls,\n            bboxes,\n            kpts=kpts,\n            paths=paths,\n            fname=self.save_dir / f\"train_batch{ni}.jpg\",\n            on_plot=self.on_plot,\n        )\n\n    def plot_metrics(self):\n        \"\"\"Plots training/val metrics.\"\"\"\n        plot_results(file=self.csv, pose=True, on_plot=self.on_plot)  # save results.png\n</code></pre>"},{"location":"reference/models/yolo/pose/train/#ultralytics.models.yolo.pose.train.PoseTrainer.__init__","title":"<code>__init__(cfg=DEFAULT_CFG, overrides=None, _callbacks=None)</code>","text":"<p>Initialize a PoseTrainer object with specified configurations and overrides.</p> Source code in <code>ultralytics/models/yolo/pose/train.py</code> <pre><code>def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n    \"\"\"Initialize a PoseTrainer object with specified configurations and overrides.\"\"\"\n    if overrides is None:\n        overrides = {}\n    overrides[\"task\"] = \"pose\"\n    super().__init__(cfg, overrides, _callbacks)\n\n    if isinstance(self.args.device, str) and self.args.device.lower() == \"mps\":\n        LOGGER.warning(\n            \"WARNING \u26a0\ufe0f Apple MPS known Pose bug. Recommend 'device=cpu' for Pose models. \"\n            \"See https://github.com/ultralytics/ultralytics/issues/4031.\"\n        )\n</code></pre>"},{"location":"reference/models/yolo/pose/train/#ultralytics.models.yolo.pose.train.PoseTrainer.get_model","title":"<code>get_model(cfg=None, weights=None, verbose=True)</code>","text":"<p>Get pose estimation model with specified configuration and weights.</p> Source code in <code>ultralytics/models/yolo/pose/train.py</code> <pre><code>def get_model(self, cfg=None, weights=None, verbose=True):\n    \"\"\"Get pose estimation model with specified configuration and weights.\"\"\"\n    model = PoseModel(cfg, ch=3, nc=self.data[\"nc\"], data_kpt_shape=self.data[\"kpt_shape\"], verbose=verbose)\n    if weights:\n        model.load(weights)\n\n    return model\n</code></pre>"},{"location":"reference/models/yolo/pose/train/#ultralytics.models.yolo.pose.train.PoseTrainer.get_validator","title":"<code>get_validator()</code>","text":"<p>Returns an instance of the PoseValidator class for validation.</p> Source code in <code>ultralytics/models/yolo/pose/train.py</code> <pre><code>def get_validator(self):\n    \"\"\"Returns an instance of the PoseValidator class for validation.\"\"\"\n    self.loss_names = \"box_loss\", \"pose_loss\", \"kobj_loss\", \"cls_loss\", \"dfl_loss\"\n    return yolo.pose.PoseValidator(\n        self.test_loader, save_dir=self.save_dir, args=copy(self.args), _callbacks=self.callbacks\n    )\n</code></pre>"},{"location":"reference/models/yolo/pose/train/#ultralytics.models.yolo.pose.train.PoseTrainer.plot_metrics","title":"<code>plot_metrics()</code>","text":"<p>Plots training/val metrics.</p> Source code in <code>ultralytics/models/yolo/pose/train.py</code> <pre><code>def plot_metrics(self):\n    \"\"\"Plots training/val metrics.\"\"\"\n    plot_results(file=self.csv, pose=True, on_plot=self.on_plot)  # save results.png\n</code></pre>"},{"location":"reference/models/yolo/pose/train/#ultralytics.models.yolo.pose.train.PoseTrainer.plot_training_samples","title":"<code>plot_training_samples(batch, ni)</code>","text":"<p>Plot a batch of training samples with annotated class labels, bounding boxes, and keypoints.</p> Source code in <code>ultralytics/models/yolo/pose/train.py</code> <pre><code>def plot_training_samples(self, batch, ni):\n    \"\"\"Plot a batch of training samples with annotated class labels, bounding boxes, and keypoints.\"\"\"\n    images = batch[\"img\"]\n    kpts = batch[\"keypoints\"]\n    cls = batch[\"cls\"].squeeze(-1)\n    bboxes = batch[\"bboxes\"]\n    paths = batch[\"im_file\"]\n    batch_idx = batch[\"batch_idx\"]\n    plot_images(\n        images,\n        batch_idx,\n        cls,\n        bboxes,\n        kpts=kpts,\n        paths=paths,\n        fname=self.save_dir / f\"train_batch{ni}.jpg\",\n        on_plot=self.on_plot,\n    )\n</code></pre>"},{"location":"reference/models/yolo/pose/train/#ultralytics.models.yolo.pose.train.PoseTrainer.set_model_attributes","title":"<code>set_model_attributes()</code>","text":"<p>Sets keypoints shape attribute of PoseModel.</p> Source code in <code>ultralytics/models/yolo/pose/train.py</code> <pre><code>def set_model_attributes(self):\n    \"\"\"Sets keypoints shape attribute of PoseModel.\"\"\"\n    super().set_model_attributes()\n    self.model.kpt_shape = self.data[\"kpt_shape\"]\n</code></pre>"},{"location":"reference/models/yolo/pose/val/","title":"Reference for <code>ultralytics/models/yolo/pose/val.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/yolo/pose/val.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/yolo/pose/val/#ultralytics.models.yolo.pose.val.PoseValidator","title":"<code>ultralytics.models.yolo.pose.val.PoseValidator</code>","text":"<p>             Bases: <code>DetectionValidator</code></p> <p>A class extending the DetectionValidator class for validation based on a pose model.</p> Example <pre><code>from ultralytics.models.yolo.pose import PoseValidator\n\nargs = dict(model='yolov8n-pose.pt', data='coco8-pose.yaml')\nvalidator = PoseValidator(args=args)\nvalidator()\n</code></pre> Source code in <code>ultralytics/models/yolo/pose/val.py</code> <pre><code>class PoseValidator(DetectionValidator):\n    \"\"\"\n    A class extending the DetectionValidator class for validation based on a pose model.\n\n    Example:\n        ```python\n        from ultralytics.models.yolo.pose import PoseValidator\n\n        args = dict(model='yolov8n-pose.pt', data='coco8-pose.yaml')\n        validator = PoseValidator(args=args)\n        validator()\n        ```\n    \"\"\"\n\n    def __init__(self, dataloader=None, save_dir=None, pbar=None, args=None, _callbacks=None):\n        \"\"\"Initialize a 'PoseValidator' object with custom parameters and assigned attributes.\"\"\"\n        super().__init__(dataloader, save_dir, pbar, args, _callbacks)\n        self.sigma = None\n        self.kpt_shape = None\n        self.args.task = \"pose\"\n        self.metrics = PoseMetrics(save_dir=self.save_dir, on_plot=self.on_plot)\n        if isinstance(self.args.device, str) and self.args.device.lower() == \"mps\":\n            LOGGER.warning(\n                \"WARNING \u26a0\ufe0f Apple MPS known Pose bug. Recommend 'device=cpu' for Pose models. \"\n                \"See https://github.com/ultralytics/ultralytics/issues/4031.\"\n            )\n\n    def preprocess(self, batch):\n        \"\"\"Preprocesses the batch by converting the 'keypoints' data into a float and moving it to the device.\"\"\"\n        batch = super().preprocess(batch)\n        batch[\"keypoints\"] = batch[\"keypoints\"].to(self.device).float()\n        return batch\n\n    def get_desc(self):\n        \"\"\"Returns description of evaluation metrics in string format.\"\"\"\n        return (\"%22s\" + \"%11s\" * 10) % (\n            \"Class\",\n            \"Images\",\n            \"Instances\",\n            \"Box(P\",\n            \"R\",\n            \"mAP50\",\n            \"mAP50-95)\",\n            \"Pose(P\",\n            \"R\",\n            \"mAP50\",\n            \"mAP50-95)\",\n        )\n\n    def postprocess(self, preds):\n        \"\"\"Apply non-maximum suppression and return detections with high confidence scores.\"\"\"\n        return ops.non_max_suppression(\n            preds,\n            self.args.conf,\n            self.args.iou,\n            labels=self.lb,\n            multi_label=True,\n            agnostic=self.args.single_cls,\n            max_det=self.args.max_det,\n            nc=self.nc,\n        )\n\n    def init_metrics(self, model):\n        \"\"\"Initiate pose estimation metrics for YOLO model.\"\"\"\n        super().init_metrics(model)\n        self.kpt_shape = self.data[\"kpt_shape\"]\n        is_pose = self.kpt_shape == [17, 3]\n        nkpt = self.kpt_shape[0]\n        self.sigma = OKS_SIGMA if is_pose else np.ones(nkpt) / nkpt\n        self.stats = dict(tp_p=[], tp=[], conf=[], pred_cls=[], target_cls=[])\n\n    def _prepare_batch(self, si, batch):\n        \"\"\"Prepares a batch for processing by converting keypoints to float and moving to device.\"\"\"\n        pbatch = super()._prepare_batch(si, batch)\n        kpts = batch[\"keypoints\"][batch[\"batch_idx\"] == si]\n        h, w = pbatch[\"imgsz\"]\n        kpts = kpts.clone()\n        kpts[..., 0] *= w\n        kpts[..., 1] *= h\n        kpts = ops.scale_coords(pbatch[\"imgsz\"], kpts, pbatch[\"ori_shape\"], ratio_pad=pbatch[\"ratio_pad\"])\n        pbatch[\"kpts\"] = kpts\n        return pbatch\n\n    def _prepare_pred(self, pred, pbatch):\n        \"\"\"Prepares and scales keypoints in a batch for pose processing.\"\"\"\n        predn = super()._prepare_pred(pred, pbatch)\n        nk = pbatch[\"kpts\"].shape[1]\n        pred_kpts = predn[:, 6:].view(len(predn), nk, -1)\n        ops.scale_coords(pbatch[\"imgsz\"], pred_kpts, pbatch[\"ori_shape\"], ratio_pad=pbatch[\"ratio_pad\"])\n        return predn, pred_kpts\n\n    def update_metrics(self, preds, batch):\n        \"\"\"Metrics.\"\"\"\n        for si, pred in enumerate(preds):\n            self.seen += 1\n            npr = len(pred)\n            stat = dict(\n                conf=torch.zeros(0, device=self.device),\n                pred_cls=torch.zeros(0, device=self.device),\n                tp=torch.zeros(npr, self.niou, dtype=torch.bool, device=self.device),\n                tp_p=torch.zeros(npr, self.niou, dtype=torch.bool, device=self.device),\n            )\n            pbatch = self._prepare_batch(si, batch)\n            cls, bbox = pbatch.pop(\"cls\"), pbatch.pop(\"bbox\")\n            nl = len(cls)\n            stat[\"target_cls\"] = cls\n            if npr == 0:\n                if nl:\n                    for k in self.stats.keys():\n                        self.stats[k].append(stat[k])\n                    if self.args.plots:\n                        self.confusion_matrix.process_batch(detections=None, gt_bboxes=bbox, gt_cls=cls)\n                continue\n\n            # Predictions\n            if self.args.single_cls:\n                pred[:, 5] = 0\n            predn, pred_kpts = self._prepare_pred(pred, pbatch)\n            stat[\"conf\"] = predn[:, 4]\n            stat[\"pred_cls\"] = predn[:, 5]\n\n            # Evaluate\n            if nl:\n                stat[\"tp\"] = self._process_batch(predn, bbox, cls)\n                stat[\"tp_p\"] = self._process_batch(predn, bbox, cls, pred_kpts, pbatch[\"kpts\"])\n                if self.args.plots:\n                    self.confusion_matrix.process_batch(predn, bbox, cls)\n\n            for k in self.stats.keys():\n                self.stats[k].append(stat[k])\n\n            # Save\n            if self.args.save_json:\n                self.pred_to_json(predn, batch[\"im_file\"][si])\n            # if self.args.save_txt:\n            #    save_one_txt(predn, save_conf, shape, file=save_dir / 'labels' / f'{path.stem}.txt')\n\n    def _process_batch(self, detections, gt_bboxes, gt_cls, pred_kpts=None, gt_kpts=None):\n        \"\"\"\n        Return correct prediction matrix.\n\n        Args:\n            detections (torch.Tensor): Tensor of shape [N, 6] representing detections.\n                Each detection is of the format: x1, y1, x2, y2, conf, class.\n            labels (torch.Tensor): Tensor of shape [M, 5] representing labels.\n                Each label is of the format: class, x1, y1, x2, y2.\n            pred_kpts (torch.Tensor, optional): Tensor of shape [N, 51] representing predicted keypoints.\n                51 corresponds to 17 keypoints each with 3 values.\n            gt_kpts (torch.Tensor, optional): Tensor of shape [N, 51] representing ground truth keypoints.\n\n        Returns:\n            torch.Tensor: Correct prediction matrix of shape [N, 10] for 10 IoU levels.\n        \"\"\"\n        if pred_kpts is not None and gt_kpts is not None:\n            # `0.53` is from https://github.com/jin-s13/xtcocoapi/blob/master/xtcocotools/cocoeval.py#L384\n            area = ops.xyxy2xywh(gt_bboxes)[:, 2:].prod(1) * 0.53\n            iou = kpt_iou(gt_kpts, pred_kpts, sigma=self.sigma, area=area)\n        else:  # boxes\n            iou = box_iou(gt_bboxes, detections[:, :4])\n\n        return self.match_predictions(detections[:, 5], gt_cls, iou)\n\n    def plot_val_samples(self, batch, ni):\n        \"\"\"Plots and saves validation set samples with predicted bounding boxes and keypoints.\"\"\"\n        plot_images(\n            batch[\"img\"],\n            batch[\"batch_idx\"],\n            batch[\"cls\"].squeeze(-1),\n            batch[\"bboxes\"],\n            kpts=batch[\"keypoints\"],\n            paths=batch[\"im_file\"],\n            fname=self.save_dir / f\"val_batch{ni}_labels.jpg\",\n            names=self.names,\n            on_plot=self.on_plot,\n        )\n\n    def plot_predictions(self, batch, preds, ni):\n        \"\"\"Plots predictions for YOLO model.\"\"\"\n        pred_kpts = torch.cat([p[:, 6:].view(-1, *self.kpt_shape) for p in preds], 0)\n        plot_images(\n            batch[\"img\"],\n            *output_to_target(preds, max_det=self.args.max_det),\n            kpts=pred_kpts,\n            paths=batch[\"im_file\"],\n            fname=self.save_dir / f\"val_batch{ni}_pred.jpg\",\n            names=self.names,\n            on_plot=self.on_plot,\n        )  # pred\n\n    def pred_to_json(self, predn, filename):\n        \"\"\"Converts YOLO predictions to COCO JSON format.\"\"\"\n        stem = Path(filename).stem\n        image_id = int(stem) if stem.isnumeric() else stem\n        box = ops.xyxy2xywh(predn[:, :4])  # xywh\n        box[:, :2] -= box[:, 2:] / 2  # xy center to top-left corner\n        for p, b in zip(predn.tolist(), box.tolist()):\n            self.jdict.append(\n                {\n                    \"image_id\": image_id,\n                    \"category_id\": self.class_map[int(p[5])],\n                    \"bbox\": [round(x, 3) for x in b],\n                    \"keypoints\": p[6:],\n                    \"score\": round(p[4], 5),\n                }\n            )\n\n    def eval_json(self, stats):\n        \"\"\"Evaluates object detection model using COCO JSON format.\"\"\"\n        if self.args.save_json and self.is_coco and len(self.jdict):\n            anno_json = self.data[\"path\"] / \"annotations/person_keypoints_val2017.json\"  # annotations\n            pred_json = self.save_dir / \"predictions.json\"  # predictions\n            LOGGER.info(f\"\\nEvaluating pycocotools mAP using {pred_json} and {anno_json}...\")\n            try:  # https://github.com/cocodataset/cocoapi/blob/master/PythonAPI/pycocoEvalDemo.ipynb\n                check_requirements(\"pycocotools&gt;=2.0.6\")\n                from pycocotools.coco import COCO  # noqa\n                from pycocotools.cocoeval import COCOeval  # noqa\n\n                for x in anno_json, pred_json:\n                    assert x.is_file(), f\"{x} file not found\"\n                anno = COCO(str(anno_json))  # init annotations api\n                pred = anno.loadRes(str(pred_json))  # init predictions api (must pass string, not Path)\n                for i, eval in enumerate([COCOeval(anno, pred, \"bbox\"), COCOeval(anno, pred, \"keypoints\")]):\n                    if self.is_coco:\n                        eval.params.imgIds = [int(Path(x).stem) for x in self.dataloader.dataset.im_files]  # im to eval\n                    eval.evaluate()\n                    eval.accumulate()\n                    eval.summarize()\n                    idx = i * 4 + 2\n                    stats[self.metrics.keys[idx + 1]], stats[self.metrics.keys[idx]] = eval.stats[\n                        :2\n                    ]  # update mAP50-95 and mAP50\n            except Exception as e:\n                LOGGER.warning(f\"pycocotools unable to run: {e}\")\n        return stats\n</code></pre>"},{"location":"reference/models/yolo/pose/val/#ultralytics.models.yolo.pose.val.PoseValidator.__init__","title":"<code>__init__(dataloader=None, save_dir=None, pbar=None, args=None, _callbacks=None)</code>","text":"<p>Initialize a 'PoseValidator' object with custom parameters and assigned attributes.</p> Source code in <code>ultralytics/models/yolo/pose/val.py</code> <pre><code>def __init__(self, dataloader=None, save_dir=None, pbar=None, args=None, _callbacks=None):\n    \"\"\"Initialize a 'PoseValidator' object with custom parameters and assigned attributes.\"\"\"\n    super().__init__(dataloader, save_dir, pbar, args, _callbacks)\n    self.sigma = None\n    self.kpt_shape = None\n    self.args.task = \"pose\"\n    self.metrics = PoseMetrics(save_dir=self.save_dir, on_plot=self.on_plot)\n    if isinstance(self.args.device, str) and self.args.device.lower() == \"mps\":\n        LOGGER.warning(\n            \"WARNING \u26a0\ufe0f Apple MPS known Pose bug. Recommend 'device=cpu' for Pose models. \"\n            \"See https://github.com/ultralytics/ultralytics/issues/4031.\"\n        )\n</code></pre>"},{"location":"reference/models/yolo/pose/val/#ultralytics.models.yolo.pose.val.PoseValidator.eval_json","title":"<code>eval_json(stats)</code>","text":"<p>Evaluates object detection model using COCO JSON format.</p> Source code in <code>ultralytics/models/yolo/pose/val.py</code> <pre><code>def eval_json(self, stats):\n    \"\"\"Evaluates object detection model using COCO JSON format.\"\"\"\n    if self.args.save_json and self.is_coco and len(self.jdict):\n        anno_json = self.data[\"path\"] / \"annotations/person_keypoints_val2017.json\"  # annotations\n        pred_json = self.save_dir / \"predictions.json\"  # predictions\n        LOGGER.info(f\"\\nEvaluating pycocotools mAP using {pred_json} and {anno_json}...\")\n        try:  # https://github.com/cocodataset/cocoapi/blob/master/PythonAPI/pycocoEvalDemo.ipynb\n            check_requirements(\"pycocotools&gt;=2.0.6\")\n            from pycocotools.coco import COCO  # noqa\n            from pycocotools.cocoeval import COCOeval  # noqa\n\n            for x in anno_json, pred_json:\n                assert x.is_file(), f\"{x} file not found\"\n            anno = COCO(str(anno_json))  # init annotations api\n            pred = anno.loadRes(str(pred_json))  # init predictions api (must pass string, not Path)\n            for i, eval in enumerate([COCOeval(anno, pred, \"bbox\"), COCOeval(anno, pred, \"keypoints\")]):\n                if self.is_coco:\n                    eval.params.imgIds = [int(Path(x).stem) for x in self.dataloader.dataset.im_files]  # im to eval\n                eval.evaluate()\n                eval.accumulate()\n                eval.summarize()\n                idx = i * 4 + 2\n                stats[self.metrics.keys[idx + 1]], stats[self.metrics.keys[idx]] = eval.stats[\n                    :2\n                ]  # update mAP50-95 and mAP50\n        except Exception as e:\n            LOGGER.warning(f\"pycocotools unable to run: {e}\")\n    return stats\n</code></pre>"},{"location":"reference/models/yolo/pose/val/#ultralytics.models.yolo.pose.val.PoseValidator.get_desc","title":"<code>get_desc()</code>","text":"<p>Returns description of evaluation metrics in string format.</p> Source code in <code>ultralytics/models/yolo/pose/val.py</code> <pre><code>def get_desc(self):\n    \"\"\"Returns description of evaluation metrics in string format.\"\"\"\n    return (\"%22s\" + \"%11s\" * 10) % (\n        \"Class\",\n        \"Images\",\n        \"Instances\",\n        \"Box(P\",\n        \"R\",\n        \"mAP50\",\n        \"mAP50-95)\",\n        \"Pose(P\",\n        \"R\",\n        \"mAP50\",\n        \"mAP50-95)\",\n    )\n</code></pre>"},{"location":"reference/models/yolo/pose/val/#ultralytics.models.yolo.pose.val.PoseValidator.init_metrics","title":"<code>init_metrics(model)</code>","text":"<p>Initiate pose estimation metrics for YOLO model.</p> Source code in <code>ultralytics/models/yolo/pose/val.py</code> <pre><code>def init_metrics(self, model):\n    \"\"\"Initiate pose estimation metrics for YOLO model.\"\"\"\n    super().init_metrics(model)\n    self.kpt_shape = self.data[\"kpt_shape\"]\n    is_pose = self.kpt_shape == [17, 3]\n    nkpt = self.kpt_shape[0]\n    self.sigma = OKS_SIGMA if is_pose else np.ones(nkpt) / nkpt\n    self.stats = dict(tp_p=[], tp=[], conf=[], pred_cls=[], target_cls=[])\n</code></pre>"},{"location":"reference/models/yolo/pose/val/#ultralytics.models.yolo.pose.val.PoseValidator.plot_predictions","title":"<code>plot_predictions(batch, preds, ni)</code>","text":"<p>Plots predictions for YOLO model.</p> Source code in <code>ultralytics/models/yolo/pose/val.py</code> <pre><code>def plot_predictions(self, batch, preds, ni):\n    \"\"\"Plots predictions for YOLO model.\"\"\"\n    pred_kpts = torch.cat([p[:, 6:].view(-1, *self.kpt_shape) for p in preds], 0)\n    plot_images(\n        batch[\"img\"],\n        *output_to_target(preds, max_det=self.args.max_det),\n        kpts=pred_kpts,\n        paths=batch[\"im_file\"],\n        fname=self.save_dir / f\"val_batch{ni}_pred.jpg\",\n        names=self.names,\n        on_plot=self.on_plot,\n    )  # pred\n</code></pre>"},{"location":"reference/models/yolo/pose/val/#ultralytics.models.yolo.pose.val.PoseValidator.plot_val_samples","title":"<code>plot_val_samples(batch, ni)</code>","text":"<p>Plots and saves validation set samples with predicted bounding boxes and keypoints.</p> Source code in <code>ultralytics/models/yolo/pose/val.py</code> <pre><code>def plot_val_samples(self, batch, ni):\n    \"\"\"Plots and saves validation set samples with predicted bounding boxes and keypoints.\"\"\"\n    plot_images(\n        batch[\"img\"],\n        batch[\"batch_idx\"],\n        batch[\"cls\"].squeeze(-1),\n        batch[\"bboxes\"],\n        kpts=batch[\"keypoints\"],\n        paths=batch[\"im_file\"],\n        fname=self.save_dir / f\"val_batch{ni}_labels.jpg\",\n        names=self.names,\n        on_plot=self.on_plot,\n    )\n</code></pre>"},{"location":"reference/models/yolo/pose/val/#ultralytics.models.yolo.pose.val.PoseValidator.postprocess","title":"<code>postprocess(preds)</code>","text":"<p>Apply non-maximum suppression and return detections with high confidence scores.</p> Source code in <code>ultralytics/models/yolo/pose/val.py</code> <pre><code>def postprocess(self, preds):\n    \"\"\"Apply non-maximum suppression and return detections with high confidence scores.\"\"\"\n    return ops.non_max_suppression(\n        preds,\n        self.args.conf,\n        self.args.iou,\n        labels=self.lb,\n        multi_label=True,\n        agnostic=self.args.single_cls,\n        max_det=self.args.max_det,\n        nc=self.nc,\n    )\n</code></pre>"},{"location":"reference/models/yolo/pose/val/#ultralytics.models.yolo.pose.val.PoseValidator.pred_to_json","title":"<code>pred_to_json(predn, filename)</code>","text":"<p>Converts YOLO predictions to COCO JSON format.</p> Source code in <code>ultralytics/models/yolo/pose/val.py</code> <pre><code>def pred_to_json(self, predn, filename):\n    \"\"\"Converts YOLO predictions to COCO JSON format.\"\"\"\n    stem = Path(filename).stem\n    image_id = int(stem) if stem.isnumeric() else stem\n    box = ops.xyxy2xywh(predn[:, :4])  # xywh\n    box[:, :2] -= box[:, 2:] / 2  # xy center to top-left corner\n    for p, b in zip(predn.tolist(), box.tolist()):\n        self.jdict.append(\n            {\n                \"image_id\": image_id,\n                \"category_id\": self.class_map[int(p[5])],\n                \"bbox\": [round(x, 3) for x in b],\n                \"keypoints\": p[6:],\n                \"score\": round(p[4], 5),\n            }\n        )\n</code></pre>"},{"location":"reference/models/yolo/pose/val/#ultralytics.models.yolo.pose.val.PoseValidator.preprocess","title":"<code>preprocess(batch)</code>","text":"<p>Preprocesses the batch by converting the 'keypoints' data into a float and moving it to the device.</p> Source code in <code>ultralytics/models/yolo/pose/val.py</code> <pre><code>def preprocess(self, batch):\n    \"\"\"Preprocesses the batch by converting the 'keypoints' data into a float and moving it to the device.\"\"\"\n    batch = super().preprocess(batch)\n    batch[\"keypoints\"] = batch[\"keypoints\"].to(self.device).float()\n    return batch\n</code></pre>"},{"location":"reference/models/yolo/pose/val/#ultralytics.models.yolo.pose.val.PoseValidator.update_metrics","title":"<code>update_metrics(preds, batch)</code>","text":"<p>Metrics.</p> Source code in <code>ultralytics/models/yolo/pose/val.py</code> <pre><code>def update_metrics(self, preds, batch):\n    \"\"\"Metrics.\"\"\"\n    for si, pred in enumerate(preds):\n        self.seen += 1\n        npr = len(pred)\n        stat = dict(\n            conf=torch.zeros(0, device=self.device),\n            pred_cls=torch.zeros(0, device=self.device),\n            tp=torch.zeros(npr, self.niou, dtype=torch.bool, device=self.device),\n            tp_p=torch.zeros(npr, self.niou, dtype=torch.bool, device=self.device),\n        )\n        pbatch = self._prepare_batch(si, batch)\n        cls, bbox = pbatch.pop(\"cls\"), pbatch.pop(\"bbox\")\n        nl = len(cls)\n        stat[\"target_cls\"] = cls\n        if npr == 0:\n            if nl:\n                for k in self.stats.keys():\n                    self.stats[k].append(stat[k])\n                if self.args.plots:\n                    self.confusion_matrix.process_batch(detections=None, gt_bboxes=bbox, gt_cls=cls)\n            continue\n\n        # Predictions\n        if self.args.single_cls:\n            pred[:, 5] = 0\n        predn, pred_kpts = self._prepare_pred(pred, pbatch)\n        stat[\"conf\"] = predn[:, 4]\n        stat[\"pred_cls\"] = predn[:, 5]\n\n        # Evaluate\n        if nl:\n            stat[\"tp\"] = self._process_batch(predn, bbox, cls)\n            stat[\"tp_p\"] = self._process_batch(predn, bbox, cls, pred_kpts, pbatch[\"kpts\"])\n            if self.args.plots:\n                self.confusion_matrix.process_batch(predn, bbox, cls)\n\n        for k in self.stats.keys():\n            self.stats[k].append(stat[k])\n\n        # Save\n        if self.args.save_json:\n            self.pred_to_json(predn, batch[\"im_file\"][si])\n</code></pre>"},{"location":"reference/models/yolo/segment/predict/","title":"Reference for <code>ultralytics/models/yolo/segment/predict.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/yolo/segment/predict.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/yolo/segment/predict/#ultralytics.models.yolo.segment.predict.SegmentationPredictor","title":"<code>ultralytics.models.yolo.segment.predict.SegmentationPredictor</code>","text":"<p>             Bases: <code>DetectionPredictor</code></p> <p>A class extending the DetectionPredictor class for prediction based on a segmentation model.</p> Example <pre><code>from ultralytics.utils import ASSETS\nfrom ultralytics.models.yolo.segment import SegmentationPredictor\n\nargs = dict(model='yolov8n-seg.pt', source=ASSETS)\npredictor = SegmentationPredictor(overrides=args)\npredictor.predict_cli()\n</code></pre> Source code in <code>ultralytics/models/yolo/segment/predict.py</code> <pre><code>class SegmentationPredictor(DetectionPredictor):\n    \"\"\"\n    A class extending the DetectionPredictor class for prediction based on a segmentation model.\n\n    Example:\n        ```python\n        from ultralytics.utils import ASSETS\n        from ultralytics.models.yolo.segment import SegmentationPredictor\n\n        args = dict(model='yolov8n-seg.pt', source=ASSETS)\n        predictor = SegmentationPredictor(overrides=args)\n        predictor.predict_cli()\n        ```\n    \"\"\"\n\n    def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n        \"\"\"Initializes the SegmentationPredictor with the provided configuration, overrides, and callbacks.\"\"\"\n        super().__init__(cfg, overrides, _callbacks)\n        self.args.task = \"segment\"\n\n    def postprocess(self, preds, img, orig_imgs):\n        \"\"\"Applies non-max suppression and processes detections for each image in an input batch.\"\"\"\n        p = ops.non_max_suppression(\n            preds[0],\n            self.args.conf,\n            self.args.iou,\n            agnostic=self.args.agnostic_nms,\n            max_det=self.args.max_det,\n            nc=len(self.model.names),\n            classes=self.args.classes,\n        )\n\n        if not isinstance(orig_imgs, list):  # input images are a torch.Tensor, not a list\n            orig_imgs = ops.convert_torch2numpy_batch(orig_imgs)\n\n        results = []\n        proto = preds[1][-1] if len(preds[1]) == 3 else preds[1]  # second output is len 3 if pt, but only 1 if exported\n        for i, pred in enumerate(p):\n            orig_img = orig_imgs[i]\n            img_path = self.batch[0][i]\n            if not len(pred):  # save empty boxes\n                masks = None\n            elif self.args.retina_masks:\n                pred[:, :4] = ops.scale_boxes(img.shape[2:], pred[:, :4], orig_img.shape)\n                masks = ops.process_mask_native(proto[i], pred[:, 6:], pred[:, :4], orig_img.shape[:2])  # HWC\n            else:\n                masks = ops.process_mask(proto[i], pred[:, 6:], pred[:, :4], img.shape[2:], upsample=True)  # HWC\n                pred[:, :4] = ops.scale_boxes(img.shape[2:], pred[:, :4], orig_img.shape)\n            results.append(Results(orig_img, path=img_path, names=self.model.names, boxes=pred[:, :6], masks=masks))\n        return results\n</code></pre>"},{"location":"reference/models/yolo/segment/predict/#ultralytics.models.yolo.segment.predict.SegmentationPredictor.__init__","title":"<code>__init__(cfg=DEFAULT_CFG, overrides=None, _callbacks=None)</code>","text":"<p>Initializes the SegmentationPredictor with the provided configuration, overrides, and callbacks.</p> Source code in <code>ultralytics/models/yolo/segment/predict.py</code> <pre><code>def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n    \"\"\"Initializes the SegmentationPredictor with the provided configuration, overrides, and callbacks.\"\"\"\n    super().__init__(cfg, overrides, _callbacks)\n    self.args.task = \"segment\"\n</code></pre>"},{"location":"reference/models/yolo/segment/predict/#ultralytics.models.yolo.segment.predict.SegmentationPredictor.postprocess","title":"<code>postprocess(preds, img, orig_imgs)</code>","text":"<p>Applies non-max suppression and processes detections for each image in an input batch.</p> Source code in <code>ultralytics/models/yolo/segment/predict.py</code> <pre><code>def postprocess(self, preds, img, orig_imgs):\n    \"\"\"Applies non-max suppression and processes detections for each image in an input batch.\"\"\"\n    p = ops.non_max_suppression(\n        preds[0],\n        self.args.conf,\n        self.args.iou,\n        agnostic=self.args.agnostic_nms,\n        max_det=self.args.max_det,\n        nc=len(self.model.names),\n        classes=self.args.classes,\n    )\n\n    if not isinstance(orig_imgs, list):  # input images are a torch.Tensor, not a list\n        orig_imgs = ops.convert_torch2numpy_batch(orig_imgs)\n\n    results = []\n    proto = preds[1][-1] if len(preds[1]) == 3 else preds[1]  # second output is len 3 if pt, but only 1 if exported\n    for i, pred in enumerate(p):\n        orig_img = orig_imgs[i]\n        img_path = self.batch[0][i]\n        if not len(pred):  # save empty boxes\n            masks = None\n        elif self.args.retina_masks:\n            pred[:, :4] = ops.scale_boxes(img.shape[2:], pred[:, :4], orig_img.shape)\n            masks = ops.process_mask_native(proto[i], pred[:, 6:], pred[:, :4], orig_img.shape[:2])  # HWC\n        else:\n            masks = ops.process_mask(proto[i], pred[:, 6:], pred[:, :4], img.shape[2:], upsample=True)  # HWC\n            pred[:, :4] = ops.scale_boxes(img.shape[2:], pred[:, :4], orig_img.shape)\n        results.append(Results(orig_img, path=img_path, names=self.model.names, boxes=pred[:, :6], masks=masks))\n    return results\n</code></pre>"},{"location":"reference/models/yolo/segment/train/","title":"Reference for <code>ultralytics/models/yolo/segment/train.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/yolo/segment/train.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/yolo/segment/train/#ultralytics.models.yolo.segment.train.SegmentationTrainer","title":"<code>ultralytics.models.yolo.segment.train.SegmentationTrainer</code>","text":"<p>             Bases: <code>DetectionTrainer</code></p> <p>A class extending the DetectionTrainer class for training based on a segmentation model.</p> Example <pre><code>from ultralytics.models.yolo.segment import SegmentationTrainer\n\nargs = dict(model='yolov8n-seg.pt', data='coco8-seg.yaml', epochs=3)\ntrainer = SegmentationTrainer(overrides=args)\ntrainer.train()\n</code></pre> Source code in <code>ultralytics/models/yolo/segment/train.py</code> <pre><code>class SegmentationTrainer(yolo.detect.DetectionTrainer):\n    \"\"\"\n    A class extending the DetectionTrainer class for training based on a segmentation model.\n\n    Example:\n        ```python\n        from ultralytics.models.yolo.segment import SegmentationTrainer\n\n        args = dict(model='yolov8n-seg.pt', data='coco8-seg.yaml', epochs=3)\n        trainer = SegmentationTrainer(overrides=args)\n        trainer.train()\n        ```\n    \"\"\"\n\n    def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n        \"\"\"Initialize a SegmentationTrainer object with given arguments.\"\"\"\n        if overrides is None:\n            overrides = {}\n        overrides[\"task\"] = \"segment\"\n        super().__init__(cfg, overrides, _callbacks)\n\n    def get_model(self, cfg=None, weights=None, verbose=True):\n        \"\"\"Return SegmentationModel initialized with specified config and weights.\"\"\"\n        model = SegmentationModel(cfg, ch=3, nc=self.data[\"nc\"], verbose=verbose and RANK == -1)\n        if weights:\n            model.load(weights)\n\n        return model\n\n    def get_validator(self):\n        \"\"\"Return an instance of SegmentationValidator for validation of YOLO model.\"\"\"\n        self.loss_names = \"box_loss\", \"seg_loss\", \"cls_loss\", \"dfl_loss\"\n        return yolo.segment.SegmentationValidator(\n            self.test_loader, save_dir=self.save_dir, args=copy(self.args), _callbacks=self.callbacks\n        )\n\n    def plot_training_samples(self, batch, ni):\n        \"\"\"Creates a plot of training sample images with labels and box coordinates.\"\"\"\n        plot_images(\n            batch[\"img\"],\n            batch[\"batch_idx\"],\n            batch[\"cls\"].squeeze(-1),\n            batch[\"bboxes\"],\n            masks=batch[\"masks\"],\n            paths=batch[\"im_file\"],\n            fname=self.save_dir / f\"train_batch{ni}.jpg\",\n            on_plot=self.on_plot,\n        )\n\n    def plot_metrics(self):\n        \"\"\"Plots training/val metrics.\"\"\"\n        plot_results(file=self.csv, segment=True, on_plot=self.on_plot)  # save results.png\n</code></pre>"},{"location":"reference/models/yolo/segment/train/#ultralytics.models.yolo.segment.train.SegmentationTrainer.__init__","title":"<code>__init__(cfg=DEFAULT_CFG, overrides=None, _callbacks=None)</code>","text":"<p>Initialize a SegmentationTrainer object with given arguments.</p> Source code in <code>ultralytics/models/yolo/segment/train.py</code> <pre><code>def __init__(self, cfg=DEFAULT_CFG, overrides=None, _callbacks=None):\n    \"\"\"Initialize a SegmentationTrainer object with given arguments.\"\"\"\n    if overrides is None:\n        overrides = {}\n    overrides[\"task\"] = \"segment\"\n    super().__init__(cfg, overrides, _callbacks)\n</code></pre>"},{"location":"reference/models/yolo/segment/train/#ultralytics.models.yolo.segment.train.SegmentationTrainer.get_model","title":"<code>get_model(cfg=None, weights=None, verbose=True)</code>","text":"<p>Return SegmentationModel initialized with specified config and weights.</p> Source code in <code>ultralytics/models/yolo/segment/train.py</code> <pre><code>def get_model(self, cfg=None, weights=None, verbose=True):\n    \"\"\"Return SegmentationModel initialized with specified config and weights.\"\"\"\n    model = SegmentationModel(cfg, ch=3, nc=self.data[\"nc\"], verbose=verbose and RANK == -1)\n    if weights:\n        model.load(weights)\n\n    return model\n</code></pre>"},{"location":"reference/models/yolo/segment/train/#ultralytics.models.yolo.segment.train.SegmentationTrainer.get_validator","title":"<code>get_validator()</code>","text":"<p>Return an instance of SegmentationValidator for validation of YOLO model.</p> Source code in <code>ultralytics/models/yolo/segment/train.py</code> <pre><code>def get_validator(self):\n    \"\"\"Return an instance of SegmentationValidator for validation of YOLO model.\"\"\"\n    self.loss_names = \"box_loss\", \"seg_loss\", \"cls_loss\", \"dfl_loss\"\n    return yolo.segment.SegmentationValidator(\n        self.test_loader, save_dir=self.save_dir, args=copy(self.args), _callbacks=self.callbacks\n    )\n</code></pre>"},{"location":"reference/models/yolo/segment/train/#ultralytics.models.yolo.segment.train.SegmentationTrainer.plot_metrics","title":"<code>plot_metrics()</code>","text":"<p>Plots training/val metrics.</p> Source code in <code>ultralytics/models/yolo/segment/train.py</code> <pre><code>def plot_metrics(self):\n    \"\"\"Plots training/val metrics.\"\"\"\n    plot_results(file=self.csv, segment=True, on_plot=self.on_plot)  # save results.png\n</code></pre>"},{"location":"reference/models/yolo/segment/train/#ultralytics.models.yolo.segment.train.SegmentationTrainer.plot_training_samples","title":"<code>plot_training_samples(batch, ni)</code>","text":"<p>Creates a plot of training sample images with labels and box coordinates.</p> Source code in <code>ultralytics/models/yolo/segment/train.py</code> <pre><code>def plot_training_samples(self, batch, ni):\n    \"\"\"Creates a plot of training sample images with labels and box coordinates.\"\"\"\n    plot_images(\n        batch[\"img\"],\n        batch[\"batch_idx\"],\n        batch[\"cls\"].squeeze(-1),\n        batch[\"bboxes\"],\n        masks=batch[\"masks\"],\n        paths=batch[\"im_file\"],\n        fname=self.save_dir / f\"train_batch{ni}.jpg\",\n        on_plot=self.on_plot,\n    )\n</code></pre>"},{"location":"reference/models/yolo/segment/val/","title":"Reference for <code>ultralytics/models/yolo/segment/val.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/models/yolo/segment/val.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/models/yolo/segment/val/#ultralytics.models.yolo.segment.val.SegmentationValidator","title":"<code>ultralytics.models.yolo.segment.val.SegmentationValidator</code>","text":"<p>             Bases: <code>DetectionValidator</code></p> <p>A class extending the DetectionValidator class for validation based on a segmentation model.</p> Example <pre><code>from ultralytics.models.yolo.segment import SegmentationValidator\n\nargs = dict(model='yolov8n-seg.pt', data='coco8-seg.yaml')\nvalidator = SegmentationValidator(args=args)\nvalidator()\n</code></pre> Source code in <code>ultralytics/models/yolo/segment/val.py</code> <pre><code>class SegmentationValidator(DetectionValidator):\n    \"\"\"\n    A class extending the DetectionValidator class for validation based on a segmentation model.\n\n    Example:\n        ```python\n        from ultralytics.models.yolo.segment import SegmentationValidator\n\n        args = dict(model='yolov8n-seg.pt', data='coco8-seg.yaml')\n        validator = SegmentationValidator(args=args)\n        validator()\n        ```\n    \"\"\"\n\n    def __init__(self, dataloader=None, save_dir=None, pbar=None, args=None, _callbacks=None):\n        \"\"\"Initialize SegmentationValidator and set task to 'segment', metrics to SegmentMetrics.\"\"\"\n        super().__init__(dataloader, save_dir, pbar, args, _callbacks)\n        self.plot_masks = None\n        self.process = None\n        self.args.task = \"segment\"\n        self.metrics = SegmentMetrics(save_dir=self.save_dir, on_plot=self.on_plot)\n\n    def preprocess(self, batch):\n        \"\"\"Preprocesses batch by converting masks to float and sending to device.\"\"\"\n        batch = super().preprocess(batch)\n        batch[\"masks\"] = batch[\"masks\"].to(self.device).float()\n        return batch\n\n    def init_metrics(self, model):\n        \"\"\"Initialize metrics and select mask processing function based on save_json flag.\"\"\"\n        super().init_metrics(model)\n        self.plot_masks = []\n        if self.args.save_json:\n            check_requirements(\"pycocotools&gt;=2.0.6\")\n            self.process = ops.process_mask_upsample  # more accurate\n        else:\n            self.process = ops.process_mask  # faster\n        self.stats = dict(tp_m=[], tp=[], conf=[], pred_cls=[], target_cls=[])\n\n    def get_desc(self):\n        \"\"\"Return a formatted description of evaluation metrics.\"\"\"\n        return (\"%22s\" + \"%11s\" * 10) % (\n            \"Class\",\n            \"Images\",\n            \"Instances\",\n            \"Box(P\",\n            \"R\",\n            \"mAP50\",\n            \"mAP50-95)\",\n            \"Mask(P\",\n            \"R\",\n            \"mAP50\",\n            \"mAP50-95)\",\n        )\n\n    def postprocess(self, preds):\n        \"\"\"Post-processes YOLO predictions and returns output detections with proto.\"\"\"\n        p = ops.non_max_suppression(\n            preds[0],\n            self.args.conf,\n            self.args.iou,\n            labels=self.lb,\n            multi_label=True,\n            agnostic=self.args.single_cls,\n            max_det=self.args.max_det,\n            nc=self.nc,\n        )\n        proto = preds[1][-1] if len(preds[1]) == 3 else preds[1]  # second output is len 3 if pt, but only 1 if exported\n        return p, proto\n\n    def _prepare_batch(self, si, batch):\n        \"\"\"Prepares a batch for training or inference by processing images and targets.\"\"\"\n        prepared_batch = super()._prepare_batch(si, batch)\n        midx = [si] if self.args.overlap_mask else batch[\"batch_idx\"] == si\n        prepared_batch[\"masks\"] = batch[\"masks\"][midx]\n        return prepared_batch\n\n    def _prepare_pred(self, pred, pbatch, proto):\n        \"\"\"Prepares a batch for training or inference by processing images and targets.\"\"\"\n        predn = super()._prepare_pred(pred, pbatch)\n        pred_masks = self.process(proto, pred[:, 6:], pred[:, :4], shape=pbatch[\"imgsz\"])\n        return predn, pred_masks\n\n    def update_metrics(self, preds, batch):\n        \"\"\"Metrics.\"\"\"\n        for si, (pred, proto) in enumerate(zip(preds[0], preds[1])):\n            self.seen += 1\n            npr = len(pred)\n            stat = dict(\n                conf=torch.zeros(0, device=self.device),\n                pred_cls=torch.zeros(0, device=self.device),\n                tp=torch.zeros(npr, self.niou, dtype=torch.bool, device=self.device),\n                tp_m=torch.zeros(npr, self.niou, dtype=torch.bool, device=self.device),\n            )\n            pbatch = self._prepare_batch(si, batch)\n            cls, bbox = pbatch.pop(\"cls\"), pbatch.pop(\"bbox\")\n            nl = len(cls)\n            stat[\"target_cls\"] = cls\n            if npr == 0:\n                if nl:\n                    for k in self.stats.keys():\n                        self.stats[k].append(stat[k])\n                    if self.args.plots:\n                        self.confusion_matrix.process_batch(detections=None, gt_bboxes=bbox, gt_cls=cls)\n                continue\n\n            # Masks\n            gt_masks = pbatch.pop(\"masks\")\n            # Predictions\n            if self.args.single_cls:\n                pred[:, 5] = 0\n            predn, pred_masks = self._prepare_pred(pred, pbatch, proto)\n            stat[\"conf\"] = predn[:, 4]\n            stat[\"pred_cls\"] = predn[:, 5]\n\n            # Evaluate\n            if nl:\n                stat[\"tp\"] = self._process_batch(predn, bbox, cls)\n                stat[\"tp_m\"] = self._process_batch(\n                    predn, bbox, cls, pred_masks, gt_masks, self.args.overlap_mask, masks=True\n                )\n                if self.args.plots:\n                    self.confusion_matrix.process_batch(predn, bbox, cls)\n\n            for k in self.stats.keys():\n                self.stats[k].append(stat[k])\n\n            pred_masks = torch.as_tensor(pred_masks, dtype=torch.uint8)\n            if self.args.plots and self.batch_i &lt; 3:\n                self.plot_masks.append(pred_masks[:15].cpu())  # filter top 15 to plot\n\n            # Save\n            if self.args.save_json:\n                pred_masks = ops.scale_image(\n                    pred_masks.permute(1, 2, 0).contiguous().cpu().numpy(),\n                    pbatch[\"ori_shape\"],\n                    ratio_pad=batch[\"ratio_pad\"][si],\n                )\n                self.pred_to_json(predn, batch[\"im_file\"][si], pred_masks)\n            # if self.args.save_txt:\n            #    save_one_txt(predn, save_conf, shape, file=save_dir / 'labels' / f'{path.stem}.txt')\n\n    def finalize_metrics(self, *args, **kwargs):\n        \"\"\"Sets speed and confusion matrix for evaluation metrics.\"\"\"\n        self.metrics.speed = self.speed\n        self.metrics.confusion_matrix = self.confusion_matrix\n\n    def _process_batch(self, detections, gt_bboxes, gt_cls, pred_masks=None, gt_masks=None, overlap=False, masks=False):\n        \"\"\"\n        Return correct prediction matrix.\n\n        Args:\n            detections (array[N, 6]), x1, y1, x2, y2, conf, class\n            labels (array[M, 5]), class, x1, y1, x2, y2\n\n        Returns:\n            correct (array[N, 10]), for 10 IoU levels\n        \"\"\"\n        if masks:\n            if overlap:\n                nl = len(gt_cls)\n                index = torch.arange(nl, device=gt_masks.device).view(nl, 1, 1) + 1\n                gt_masks = gt_masks.repeat(nl, 1, 1)  # shape(1,640,640) -&gt; (n,640,640)\n                gt_masks = torch.where(gt_masks == index, 1.0, 0.0)\n            if gt_masks.shape[1:] != pred_masks.shape[1:]:\n                gt_masks = F.interpolate(gt_masks[None], pred_masks.shape[1:], mode=\"bilinear\", align_corners=False)[0]\n                gt_masks = gt_masks.gt_(0.5)\n            iou = mask_iou(gt_masks.view(gt_masks.shape[0], -1), pred_masks.view(pred_masks.shape[0], -1))\n        else:  # boxes\n            iou = box_iou(gt_bboxes, detections[:, :4])\n\n        return self.match_predictions(detections[:, 5], gt_cls, iou)\n\n    def plot_val_samples(self, batch, ni):\n        \"\"\"Plots validation samples with bounding box labels.\"\"\"\n        plot_images(\n            batch[\"img\"],\n            batch[\"batch_idx\"],\n            batch[\"cls\"].squeeze(-1),\n            batch[\"bboxes\"],\n            masks=batch[\"masks\"],\n            paths=batch[\"im_file\"],\n            fname=self.save_dir / f\"val_batch{ni}_labels.jpg\",\n            names=self.names,\n            on_plot=self.on_plot,\n        )\n\n    def plot_predictions(self, batch, preds, ni):\n        \"\"\"Plots batch predictions with masks and bounding boxes.\"\"\"\n        plot_images(\n            batch[\"img\"],\n            *output_to_target(preds[0], max_det=15),  # not set to self.args.max_det due to slow plotting speed\n            torch.cat(self.plot_masks, dim=0) if len(self.plot_masks) else self.plot_masks,\n            paths=batch[\"im_file\"],\n            fname=self.save_dir / f\"val_batch{ni}_pred.jpg\",\n            names=self.names,\n            on_plot=self.on_plot,\n        )  # pred\n        self.plot_masks.clear()\n\n    def pred_to_json(self, predn, filename, pred_masks):\n        \"\"\"Save one JSON result.\"\"\"\n        # Example result = {\"image_id\": 42, \"category_id\": 18, \"bbox\": [258.15, 41.29, 348.26, 243.78], \"score\": 0.236}\n        from pycocotools.mask import encode  # noqa\n\n        def single_encode(x):\n            \"\"\"Encode predicted masks as RLE and append results to jdict.\"\"\"\n            rle = encode(np.asarray(x[:, :, None], order=\"F\", dtype=\"uint8\"))[0]\n            rle[\"counts\"] = rle[\"counts\"].decode(\"utf-8\")\n            return rle\n\n        stem = Path(filename).stem\n        image_id = int(stem) if stem.isnumeric() else stem\n        box = ops.xyxy2xywh(predn[:, :4])  # xywh\n        box[:, :2] -= box[:, 2:] / 2  # xy center to top-left corner\n        pred_masks = np.transpose(pred_masks, (2, 0, 1))\n        with ThreadPool(NUM_THREADS) as pool:\n            rles = pool.map(single_encode, pred_masks)\n        for i, (p, b) in enumerate(zip(predn.tolist(), box.tolist())):\n            self.jdict.append(\n                {\n                    \"image_id\": image_id,\n                    \"category_id\": self.class_map[int(p[5])],\n                    \"bbox\": [round(x, 3) for x in b],\n                    \"score\": round(p[4], 5),\n                    \"segmentation\": rles[i],\n                }\n            )\n\n    def eval_json(self, stats):\n        \"\"\"Return COCO-style object detection evaluation metrics.\"\"\"\n        if self.args.save_json and self.is_coco and len(self.jdict):\n            anno_json = self.data[\"path\"] / \"annotations/instances_val2017.json\"  # annotations\n            pred_json = self.save_dir / \"predictions.json\"  # predictions\n            LOGGER.info(f\"\\nEvaluating pycocotools mAP using {pred_json} and {anno_json}...\")\n            try:  # https://github.com/cocodataset/cocoapi/blob/master/PythonAPI/pycocoEvalDemo.ipynb\n                check_requirements(\"pycocotools&gt;=2.0.6\")\n                from pycocotools.coco import COCO  # noqa\n                from pycocotools.cocoeval import COCOeval  # noqa\n\n                for x in anno_json, pred_json:\n                    assert x.is_file(), f\"{x} file not found\"\n                anno = COCO(str(anno_json))  # init annotations api\n                pred = anno.loadRes(str(pred_json))  # init predictions api (must pass string, not Path)\n                for i, eval in enumerate([COCOeval(anno, pred, \"bbox\"), COCOeval(anno, pred, \"segm\")]):\n                    if self.is_coco:\n                        eval.params.imgIds = [int(Path(x).stem) for x in self.dataloader.dataset.im_files]  # im to eval\n                    eval.evaluate()\n                    eval.accumulate()\n                    eval.summarize()\n                    idx = i * 4 + 2\n                    stats[self.metrics.keys[idx + 1]], stats[self.metrics.keys[idx]] = eval.stats[\n                        :2\n                    ]  # update mAP50-95 and mAP50\n            except Exception as e:\n                LOGGER.warning(f\"pycocotools unable to run: {e}\")\n        return stats\n</code></pre>"},{"location":"reference/models/yolo/segment/val/#ultralytics.models.yolo.segment.val.SegmentationValidator.__init__","title":"<code>__init__(dataloader=None, save_dir=None, pbar=None, args=None, _callbacks=None)</code>","text":"<p>Initialize SegmentationValidator and set task to 'segment', metrics to SegmentMetrics.</p> Source code in <code>ultralytics/models/yolo/segment/val.py</code> <pre><code>def __init__(self, dataloader=None, save_dir=None, pbar=None, args=None, _callbacks=None):\n    \"\"\"Initialize SegmentationValidator and set task to 'segment', metrics to SegmentMetrics.\"\"\"\n    super().__init__(dataloader, save_dir, pbar, args, _callbacks)\n    self.plot_masks = None\n    self.process = None\n    self.args.task = \"segment\"\n    self.metrics = SegmentMetrics(save_dir=self.save_dir, on_plot=self.on_plot)\n</code></pre>"},{"location":"reference/models/yolo/segment/val/#ultralytics.models.yolo.segment.val.SegmentationValidator.eval_json","title":"<code>eval_json(stats)</code>","text":"<p>Return COCO-style object detection evaluation metrics.</p> Source code in <code>ultralytics/models/yolo/segment/val.py</code> <pre><code>def eval_json(self, stats):\n    \"\"\"Return COCO-style object detection evaluation metrics.\"\"\"\n    if self.args.save_json and self.is_coco and len(self.jdict):\n        anno_json = self.data[\"path\"] / \"annotations/instances_val2017.json\"  # annotations\n        pred_json = self.save_dir / \"predictions.json\"  # predictions\n        LOGGER.info(f\"\\nEvaluating pycocotools mAP using {pred_json} and {anno_json}...\")\n        try:  # https://github.com/cocodataset/cocoapi/blob/master/PythonAPI/pycocoEvalDemo.ipynb\n            check_requirements(\"pycocotools&gt;=2.0.6\")\n            from pycocotools.coco import COCO  # noqa\n            from pycocotools.cocoeval import COCOeval  # noqa\n\n            for x in anno_json, pred_json:\n                assert x.is_file(), f\"{x} file not found\"\n            anno = COCO(str(anno_json))  # init annotations api\n            pred = anno.loadRes(str(pred_json))  # init predictions api (must pass string, not Path)\n            for i, eval in enumerate([COCOeval(anno, pred, \"bbox\"), COCOeval(anno, pred, \"segm\")]):\n                if self.is_coco:\n                    eval.params.imgIds = [int(Path(x).stem) for x in self.dataloader.dataset.im_files]  # im to eval\n                eval.evaluate()\n                eval.accumulate()\n                eval.summarize()\n                idx = i * 4 + 2\n                stats[self.metrics.keys[idx + 1]], stats[self.metrics.keys[idx]] = eval.stats[\n                    :2\n                ]  # update mAP50-95 and mAP50\n        except Exception as e:\n            LOGGER.warning(f\"pycocotools unable to run: {e}\")\n    return stats\n</code></pre>"},{"location":"reference/models/yolo/segment/val/#ultralytics.models.yolo.segment.val.SegmentationValidator.finalize_metrics","title":"<code>finalize_metrics(*args, **kwargs)</code>","text":"<p>Sets speed and confusion matrix for evaluation metrics.</p> Source code in <code>ultralytics/models/yolo/segment/val.py</code> <pre><code>def finalize_metrics(self, *args, **kwargs):\n    \"\"\"Sets speed and confusion matrix for evaluation metrics.\"\"\"\n    self.metrics.speed = self.speed\n    self.metrics.confusion_matrix = self.confusion_matrix\n</code></pre>"},{"location":"reference/models/yolo/segment/val/#ultralytics.models.yolo.segment.val.SegmentationValidator.get_desc","title":"<code>get_desc()</code>","text":"<p>Return a formatted description of evaluation metrics.</p> Source code in <code>ultralytics/models/yolo/segment/val.py</code> <pre><code>def get_desc(self):\n    \"\"\"Return a formatted description of evaluation metrics.\"\"\"\n    return (\"%22s\" + \"%11s\" * 10) % (\n        \"Class\",\n        \"Images\",\n        \"Instances\",\n        \"Box(P\",\n        \"R\",\n        \"mAP50\",\n        \"mAP50-95)\",\n        \"Mask(P\",\n        \"R\",\n        \"mAP50\",\n        \"mAP50-95)\",\n    )\n</code></pre>"},{"location":"reference/models/yolo/segment/val/#ultralytics.models.yolo.segment.val.SegmentationValidator.init_metrics","title":"<code>init_metrics(model)</code>","text":"<p>Initialize metrics and select mask processing function based on save_json flag.</p> Source code in <code>ultralytics/models/yolo/segment/val.py</code> <pre><code>def init_metrics(self, model):\n    \"\"\"Initialize metrics and select mask processing function based on save_json flag.\"\"\"\n    super().init_metrics(model)\n    self.plot_masks = []\n    if self.args.save_json:\n        check_requirements(\"pycocotools&gt;=2.0.6\")\n        self.process = ops.process_mask_upsample  # more accurate\n    else:\n        self.process = ops.process_mask  # faster\n    self.stats = dict(tp_m=[], tp=[], conf=[], pred_cls=[], target_cls=[])\n</code></pre>"},{"location":"reference/models/yolo/segment/val/#ultralytics.models.yolo.segment.val.SegmentationValidator.plot_predictions","title":"<code>plot_predictions(batch, preds, ni)</code>","text":"<p>Plots batch predictions with masks and bounding boxes.</p> Source code in <code>ultralytics/models/yolo/segment/val.py</code> <pre><code>def plot_predictions(self, batch, preds, ni):\n    \"\"\"Plots batch predictions with masks and bounding boxes.\"\"\"\n    plot_images(\n        batch[\"img\"],\n        *output_to_target(preds[0], max_det=15),  # not set to self.args.max_det due to slow plotting speed\n        torch.cat(self.plot_masks, dim=0) if len(self.plot_masks) else self.plot_masks,\n        paths=batch[\"im_file\"],\n        fname=self.save_dir / f\"val_batch{ni}_pred.jpg\",\n        names=self.names,\n        on_plot=self.on_plot,\n    )  # pred\n    self.plot_masks.clear()\n</code></pre>"},{"location":"reference/models/yolo/segment/val/#ultralytics.models.yolo.segment.val.SegmentationValidator.plot_val_samples","title":"<code>plot_val_samples(batch, ni)</code>","text":"<p>Plots validation samples with bounding box labels.</p> Source code in <code>ultralytics/models/yolo/segment/val.py</code> <pre><code>def plot_val_samples(self, batch, ni):\n    \"\"\"Plots validation samples with bounding box labels.\"\"\"\n    plot_images(\n        batch[\"img\"],\n        batch[\"batch_idx\"],\n        batch[\"cls\"].squeeze(-1),\n        batch[\"bboxes\"],\n        masks=batch[\"masks\"],\n        paths=batch[\"im_file\"],\n        fname=self.save_dir / f\"val_batch{ni}_labels.jpg\",\n        names=self.names,\n        on_plot=self.on_plot,\n    )\n</code></pre>"},{"location":"reference/models/yolo/segment/val/#ultralytics.models.yolo.segment.val.SegmentationValidator.postprocess","title":"<code>postprocess(preds)</code>","text":"<p>Post-processes YOLO predictions and returns output detections with proto.</p> Source code in <code>ultralytics/models/yolo/segment/val.py</code> <pre><code>def postprocess(self, preds):\n    \"\"\"Post-processes YOLO predictions and returns output detections with proto.\"\"\"\n    p = ops.non_max_suppression(\n        preds[0],\n        self.args.conf,\n        self.args.iou,\n        labels=self.lb,\n        multi_label=True,\n        agnostic=self.args.single_cls,\n        max_det=self.args.max_det,\n        nc=self.nc,\n    )\n    proto = preds[1][-1] if len(preds[1]) == 3 else preds[1]  # second output is len 3 if pt, but only 1 if exported\n    return p, proto\n</code></pre>"},{"location":"reference/models/yolo/segment/val/#ultralytics.models.yolo.segment.val.SegmentationValidator.pred_to_json","title":"<code>pred_to_json(predn, filename, pred_masks)</code>","text":"<p>Save one JSON result.</p> Source code in <code>ultralytics/models/yolo/segment/val.py</code> <pre><code>def pred_to_json(self, predn, filename, pred_masks):\n    \"\"\"Save one JSON result.\"\"\"\n    # Example result = {\"image_id\": 42, \"category_id\": 18, \"bbox\": [258.15, 41.29, 348.26, 243.78], \"score\": 0.236}\n    from pycocotools.mask import encode  # noqa\n\n    def single_encode(x):\n        \"\"\"Encode predicted masks as RLE and append results to jdict.\"\"\"\n        rle = encode(np.asarray(x[:, :, None], order=\"F\", dtype=\"uint8\"))[0]\n        rle[\"counts\"] = rle[\"counts\"].decode(\"utf-8\")\n        return rle\n\n    stem = Path(filename).stem\n    image_id = int(stem) if stem.isnumeric() else stem\n    box = ops.xyxy2xywh(predn[:, :4])  # xywh\n    box[:, :2] -= box[:, 2:] / 2  # xy center to top-left corner\n    pred_masks = np.transpose(pred_masks, (2, 0, 1))\n    with ThreadPool(NUM_THREADS) as pool:\n        rles = pool.map(single_encode, pred_masks)\n    for i, (p, b) in enumerate(zip(predn.tolist(), box.tolist())):\n        self.jdict.append(\n            {\n                \"image_id\": image_id,\n                \"category_id\": self.class_map[int(p[5])],\n                \"bbox\": [round(x, 3) for x in b],\n                \"score\": round(p[4], 5),\n                \"segmentation\": rles[i],\n            }\n        )\n</code></pre>"},{"location":"reference/models/yolo/segment/val/#ultralytics.models.yolo.segment.val.SegmentationValidator.preprocess","title":"<code>preprocess(batch)</code>","text":"<p>Preprocesses batch by converting masks to float and sending to device.</p> Source code in <code>ultralytics/models/yolo/segment/val.py</code> <pre><code>def preprocess(self, batch):\n    \"\"\"Preprocesses batch by converting masks to float and sending to device.\"\"\"\n    batch = super().preprocess(batch)\n    batch[\"masks\"] = batch[\"masks\"].to(self.device).float()\n    return batch\n</code></pre>"},{"location":"reference/models/yolo/segment/val/#ultralytics.models.yolo.segment.val.SegmentationValidator.update_metrics","title":"<code>update_metrics(preds, batch)</code>","text":"<p>Metrics.</p> Source code in <code>ultralytics/models/yolo/segment/val.py</code> <pre><code>def update_metrics(self, preds, batch):\n    \"\"\"Metrics.\"\"\"\n    for si, (pred, proto) in enumerate(zip(preds[0], preds[1])):\n        self.seen += 1\n        npr = len(pred)\n        stat = dict(\n            conf=torch.zeros(0, device=self.device),\n            pred_cls=torch.zeros(0, device=self.device),\n            tp=torch.zeros(npr, self.niou, dtype=torch.bool, device=self.device),\n            tp_m=torch.zeros(npr, self.niou, dtype=torch.bool, device=self.device),\n        )\n        pbatch = self._prepare_batch(si, batch)\n        cls, bbox = pbatch.pop(\"cls\"), pbatch.pop(\"bbox\")\n        nl = len(cls)\n        stat[\"target_cls\"] = cls\n        if npr == 0:\n            if nl:\n                for k in self.stats.keys():\n                    self.stats[k].append(stat[k])\n                if self.args.plots:\n                    self.confusion_matrix.process_batch(detections=None, gt_bboxes=bbox, gt_cls=cls)\n            continue\n\n        # Masks\n        gt_masks = pbatch.pop(\"masks\")\n        # Predictions\n        if self.args.single_cls:\n            pred[:, 5] = 0\n        predn, pred_masks = self._prepare_pred(pred, pbatch, proto)\n        stat[\"conf\"] = predn[:, 4]\n        stat[\"pred_cls\"] = predn[:, 5]\n\n        # Evaluate\n        if nl:\n            stat[\"tp\"] = self._process_batch(predn, bbox, cls)\n            stat[\"tp_m\"] = self._process_batch(\n                predn, bbox, cls, pred_masks, gt_masks, self.args.overlap_mask, masks=True\n            )\n            if self.args.plots:\n                self.confusion_matrix.process_batch(predn, bbox, cls)\n\n        for k in self.stats.keys():\n            self.stats[k].append(stat[k])\n\n        pred_masks = torch.as_tensor(pred_masks, dtype=torch.uint8)\n        if self.args.plots and self.batch_i &lt; 3:\n            self.plot_masks.append(pred_masks[:15].cpu())  # filter top 15 to plot\n\n        # Save\n        if self.args.save_json:\n            pred_masks = ops.scale_image(\n                pred_masks.permute(1, 2, 0).contiguous().cpu().numpy(),\n                pbatch[\"ori_shape\"],\n                ratio_pad=batch[\"ratio_pad\"][si],\n            )\n            self.pred_to_json(predn, batch[\"im_file\"][si], pred_masks)\n</code></pre>"},{"location":"reference/nn/autobackend/","title":"Reference for <code>ultralytics/nn/autobackend.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/nn/autobackend.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/nn/autobackend/#ultralytics.nn.autobackend.AutoBackend","title":"<code>ultralytics.nn.autobackend.AutoBackend</code>","text":"<p>             Bases: <code>Module</code></p> <p>Handles dynamic backend selection for running inference using Ultralytics YOLO models.</p> <p>The AutoBackend class is designed to provide an abstraction layer for various inference engines. It supports a wide range of formats, each with specific naming conventions as outlined below:</p> <pre><code>Supported Formats and Naming Conventions:\n    | Format                | File Suffix      |\n    |-----------------------|------------------|\n    | PyTorch               | *.pt             |\n    | TorchScript           | *.torchscript    |\n    | ONNX Runtime          | *.onnx           |\n    | ONNX OpenCV DNN       | *.onnx (dnn=True)|\n    | OpenVINO              | *openvino_model/ |\n    | CoreML                | *.mlpackage      |\n    | TensorRT              | *.engine         |\n    | TensorFlow SavedModel | *_saved_model    |\n    | TensorFlow GraphDef   | *.pb             |\n    | TensorFlow Lite       | *.tflite         |\n    | TensorFlow Edge TPU   | *_edgetpu.tflite |\n    | PaddlePaddle          | *_paddle_model   |\n    | ncnn                  | *_ncnn_model     |\n</code></pre> <p>This class offers dynamic backend switching capabilities based on the input model format, making it easier to deploy models across various platforms.</p> Source code in <code>ultralytics/nn/autobackend.py</code> <pre><code>class AutoBackend(nn.Module):\n    \"\"\"\n    Handles dynamic backend selection for running inference using Ultralytics YOLO models.\n\n    The AutoBackend class is designed to provide an abstraction layer for various inference engines. It supports a wide\n    range of formats, each with specific naming conventions as outlined below:\n\n        Supported Formats and Naming Conventions:\n            | Format                | File Suffix      |\n            |-----------------------|------------------|\n            | PyTorch               | *.pt             |\n            | TorchScript           | *.torchscript    |\n            | ONNX Runtime          | *.onnx           |\n            | ONNX OpenCV DNN       | *.onnx (dnn=True)|\n            | OpenVINO              | *openvino_model/ |\n            | CoreML                | *.mlpackage      |\n            | TensorRT              | *.engine         |\n            | TensorFlow SavedModel | *_saved_model    |\n            | TensorFlow GraphDef   | *.pb             |\n            | TensorFlow Lite       | *.tflite         |\n            | TensorFlow Edge TPU   | *_edgetpu.tflite |\n            | PaddlePaddle          | *_paddle_model   |\n            | ncnn                  | *_ncnn_model     |\n\n    This class offers dynamic backend switching capabilities based on the input model format, making it easier to deploy\n    models across various platforms.\n    \"\"\"\n\n    @torch.no_grad()\n    def __init__(\n        self,\n        weights=\"yolov8n.pt\",\n        device=torch.device(\"cpu\"),\n        dnn=False,\n        data=None,\n        fp16=False,\n        fuse=True,\n        verbose=True,\n    ):\n        \"\"\"\n        Initialize the AutoBackend for inference.\n\n        Args:\n            weights (str): Path to the model weights file. Defaults to 'yolov8n.pt'.\n            device (torch.device): Device to run the model on. Defaults to CPU.\n            dnn (bool): Use OpenCV DNN module for ONNX inference. Defaults to False.\n            data (str | Path | optional): Path to the additional data.yaml file containing class names. Optional.\n            fp16 (bool): Enable half-precision inference. Supported only on specific backends. Defaults to False.\n            fuse (bool): Fuse Conv2D + BatchNorm layers for optimization. Defaults to True.\n            verbose (bool): Enable verbose logging. Defaults to True.\n        \"\"\"\n        super().__init__()\n        w = str(weights[0] if isinstance(weights, list) else weights)\n        nn_module = isinstance(weights, torch.nn.Module)\n        (\n            pt,\n            jit,\n            onnx,\n            xml,\n            engine,\n            coreml,\n            saved_model,\n            pb,\n            tflite,\n            edgetpu,\n            tfjs,\n            paddle,\n            ncnn,\n            triton,\n        ) = self._model_type(w)\n        fp16 &amp;= pt or jit or onnx or xml or engine or nn_module or triton  # FP16\n        nhwc = coreml or saved_model or pb or tflite or edgetpu  # BHWC formats (vs torch BCWH)\n        stride = 32  # default stride\n        model, metadata = None, None\n\n        # Set device\n        cuda = torch.cuda.is_available() and device.type != \"cpu\"  # use CUDA\n        if cuda and not any([nn_module, pt, jit, engine, onnx]):  # GPU dataloader formats\n            device = torch.device(\"cpu\")\n            cuda = False\n\n        # Download if not local\n        if not (pt or triton or nn_module):\n            w = attempt_download_asset(w)\n\n        # Load model\n        if nn_module:  # in-memory PyTorch model\n            model = weights.to(device)\n            model = model.fuse(verbose=verbose) if fuse else model\n            if hasattr(model, \"kpt_shape\"):\n                kpt_shape = model.kpt_shape  # pose-only\n            stride = max(int(model.stride.max()), 32)  # model stride\n            names = model.module.names if hasattr(model, \"module\") else model.names  # get class names\n            model.half() if fp16 else model.float()\n            self.model = model  # explicitly assign for to(), cpu(), cuda(), half()\n            pt = True\n        elif pt:  # PyTorch\n            from ultralytics.nn.tasks import attempt_load_weights\n\n            model = attempt_load_weights(\n                weights if isinstance(weights, list) else w, device=device, inplace=True, fuse=fuse\n            )\n            if hasattr(model, \"kpt_shape\"):\n                kpt_shape = model.kpt_shape  # pose-only\n            stride = max(int(model.stride.max()), 32)  # model stride\n            names = model.module.names if hasattr(model, \"module\") else model.names  # get class names\n            model.half() if fp16 else model.float()\n            self.model = model  # explicitly assign for to(), cpu(), cuda(), half()\n        elif jit:  # TorchScript\n            LOGGER.info(f\"Loading {w} for TorchScript inference...\")\n            extra_files = {\"config.txt\": \"\"}  # model metadata\n            model = torch.jit.load(w, _extra_files=extra_files, map_location=device)\n            model.half() if fp16 else model.float()\n            if extra_files[\"config.txt\"]:  # load metadata dict\n                metadata = json.loads(extra_files[\"config.txt\"], object_hook=lambda x: dict(x.items()))\n        elif dnn:  # ONNX OpenCV DNN\n            LOGGER.info(f\"Loading {w} for ONNX OpenCV DNN inference...\")\n            check_requirements(\"opencv-python&gt;=4.5.4\")\n            net = cv2.dnn.readNetFromONNX(w)\n        elif onnx:  # ONNX Runtime\n            LOGGER.info(f\"Loading {w} for ONNX Runtime inference...\")\n            check_requirements((\"onnx\", \"onnxruntime-gpu\" if cuda else \"onnxruntime\"))\n            import onnxruntime\n\n            providers = [\"CUDAExecutionProvider\", \"CPUExecutionProvider\"] if cuda else [\"CPUExecutionProvider\"]\n            session = onnxruntime.InferenceSession(w, providers=providers)\n            output_names = [x.name for x in session.get_outputs()]\n            metadata = session.get_modelmeta().custom_metadata_map  # metadata\n        elif xml:  # OpenVINO\n            LOGGER.info(f\"Loading {w} for OpenVINO inference...\")\n            check_requirements(\"openvino&gt;=2023.0\")  # requires openvino-dev: https://pypi.org/project/openvino-dev/\n            from openvino.runtime import Core, Layout, get_batch  # noqa\n\n            core = Core()\n            w = Path(w)\n            if not w.is_file():  # if not *.xml\n                w = next(w.glob(\"*.xml\"))  # get *.xml file from *_openvino_model dir\n            ov_model = core.read_model(model=str(w), weights=w.with_suffix(\".bin\"))\n            if ov_model.get_parameters()[0].get_layout().empty:\n                ov_model.get_parameters()[0].set_layout(Layout(\"NCHW\"))\n            batch_dim = get_batch(ov_model)\n            if batch_dim.is_static:\n                batch_size = batch_dim.get_length()\n            ov_compiled_model = core.compile_model(ov_model, device_name=\"AUTO\")  # AUTO selects best available device\n            metadata = w.parent / \"metadata.yaml\"\n        elif engine:  # TensorRT\n            LOGGER.info(f\"Loading {w} for TensorRT inference...\")\n            try:\n                import tensorrt as trt  # noqa https://developer.nvidia.com/nvidia-tensorrt-download\n            except ImportError:\n                if LINUX:\n                    check_requirements(\"nvidia-tensorrt\", cmds=\"-U --index-url https://pypi.ngc.nvidia.com\")\n                import tensorrt as trt  # noqa\n            check_version(trt.__version__, \"7.0.0\", hard=True)  # require tensorrt&gt;=7.0.0\n            if device.type == \"cpu\":\n                device = torch.device(\"cuda:0\")\n            Binding = namedtuple(\"Binding\", (\"name\", \"dtype\", \"shape\", \"data\", \"ptr\"))\n            logger = trt.Logger(trt.Logger.INFO)\n            # Read file\n            with open(w, \"rb\") as f, trt.Runtime(logger) as runtime:\n                meta_len = int.from_bytes(f.read(4), byteorder=\"little\")  # read metadata length\n                metadata = json.loads(f.read(meta_len).decode(\"utf-8\"))  # read metadata\n                model = runtime.deserialize_cuda_engine(f.read())  # read engine\n            context = model.create_execution_context()\n            bindings = OrderedDict()\n            output_names = []\n            fp16 = False  # default updated below\n            dynamic = False\n            for i in range(model.num_bindings):\n                name = model.get_binding_name(i)\n                dtype = trt.nptype(model.get_binding_dtype(i))\n                if model.binding_is_input(i):\n                    if -1 in tuple(model.get_binding_shape(i)):  # dynamic\n                        dynamic = True\n                        context.set_binding_shape(i, tuple(model.get_profile_shape(0, i)[2]))\n                    if dtype == np.float16:\n                        fp16 = True\n                else:  # output\n                    output_names.append(name)\n                shape = tuple(context.get_binding_shape(i))\n                im = torch.from_numpy(np.empty(shape, dtype=dtype)).to(device)\n                bindings[name] = Binding(name, dtype, shape, im, int(im.data_ptr()))\n            binding_addrs = OrderedDict((n, d.ptr) for n, d in bindings.items())\n            batch_size = bindings[\"images\"].shape[0]  # if dynamic, this is instead max batch size\n        elif coreml:  # CoreML\n            LOGGER.info(f\"Loading {w} for CoreML inference...\")\n            import coremltools as ct\n\n            model = ct.models.MLModel(w)\n            metadata = dict(model.user_defined_metadata)\n        elif saved_model:  # TF SavedModel\n            LOGGER.info(f\"Loading {w} for TensorFlow SavedModel inference...\")\n            import tensorflow as tf\n\n            keras = False  # assume TF1 saved_model\n            model = tf.keras.models.load_model(w) if keras else tf.saved_model.load(w)\n            metadata = Path(w) / \"metadata.yaml\"\n        elif pb:  # GraphDef https://www.tensorflow.org/guide/migrate#a_graphpb_or_graphpbtxt\n            LOGGER.info(f\"Loading {w} for TensorFlow GraphDef inference...\")\n            import tensorflow as tf\n\n            from ultralytics.engine.exporter import gd_outputs\n\n            def wrap_frozen_graph(gd, inputs, outputs):\n                \"\"\"Wrap frozen graphs for deployment.\"\"\"\n                x = tf.compat.v1.wrap_function(lambda: tf.compat.v1.import_graph_def(gd, name=\"\"), [])  # wrapped\n                ge = x.graph.as_graph_element\n                return x.prune(tf.nest.map_structure(ge, inputs), tf.nest.map_structure(ge, outputs))\n\n            gd = tf.Graph().as_graph_def()  # TF GraphDef\n            with open(w, \"rb\") as f:\n                gd.ParseFromString(f.read())\n            frozen_func = wrap_frozen_graph(gd, inputs=\"x:0\", outputs=gd_outputs(gd))\n        elif tflite or edgetpu:  # https://www.tensorflow.org/lite/guide/python#install_tensorflow_lite_for_python\n            try:  # https://coral.ai/docs/edgetpu/tflite-python/#update-existing-tf-lite-code-for-the-edge-tpu\n                from tflite_runtime.interpreter import Interpreter, load_delegate\n            except ImportError:\n                import tensorflow as tf\n\n                Interpreter, load_delegate = tf.lite.Interpreter, tf.lite.experimental.load_delegate\n            if edgetpu:  # TF Edge TPU https://coral.ai/software/#edgetpu-runtime\n                LOGGER.info(f\"Loading {w} for TensorFlow Lite Edge TPU inference...\")\n                delegate = {\"Linux\": \"libedgetpu.so.1\", \"Darwin\": \"libedgetpu.1.dylib\", \"Windows\": \"edgetpu.dll\"}[\n                    platform.system()\n                ]\n                interpreter = Interpreter(model_path=w, experimental_delegates=[load_delegate(delegate)])\n            else:  # TFLite\n                LOGGER.info(f\"Loading {w} for TensorFlow Lite inference...\")\n                interpreter = Interpreter(model_path=w)  # load TFLite model\n            interpreter.allocate_tensors()  # allocate\n            input_details = interpreter.get_input_details()  # inputs\n            output_details = interpreter.get_output_details()  # outputs\n            # Load metadata\n            with contextlib.suppress(zipfile.BadZipFile):\n                with zipfile.ZipFile(w, \"r\") as model:\n                    meta_file = model.namelist()[0]\n                    metadata = ast.literal_eval(model.read(meta_file).decode(\"utf-8\"))\n        elif tfjs:  # TF.js\n            raise NotImplementedError(\"YOLOv8 TF.js inference is not currently supported.\")\n        elif paddle:  # PaddlePaddle\n            LOGGER.info(f\"Loading {w} for PaddlePaddle inference...\")\n            check_requirements(\"paddlepaddle-gpu\" if cuda else \"paddlepaddle\")\n            import paddle.inference as pdi  # noqa\n\n            w = Path(w)\n            if not w.is_file():  # if not *.pdmodel\n                w = next(w.rglob(\"*.pdmodel\"))  # get *.pdmodel file from *_paddle_model dir\n            config = pdi.Config(str(w), str(w.with_suffix(\".pdiparams\")))\n            if cuda:\n                config.enable_use_gpu(memory_pool_init_size_mb=2048, device_id=0)\n            predictor = pdi.create_predictor(config)\n            input_handle = predictor.get_input_handle(predictor.get_input_names()[0])\n            output_names = predictor.get_output_names()\n            metadata = w.parents[1] / \"metadata.yaml\"\n        elif ncnn:  # ncnn\n            LOGGER.info(f\"Loading {w} for ncnn inference...\")\n            check_requirements(\"git+https://github.com/Tencent/ncnn.git\" if ARM64 else \"ncnn\")  # requires ncnn\n            import ncnn as pyncnn\n\n            net = pyncnn.Net()\n            net.opt.use_vulkan_compute = cuda\n            w = Path(w)\n            if not w.is_file():  # if not *.param\n                w = next(w.glob(\"*.param\"))  # get *.param file from *_ncnn_model dir\n            net.load_param(str(w))\n            net.load_model(str(w.with_suffix(\".bin\")))\n            metadata = w.parent / \"metadata.yaml\"\n        elif triton:  # NVIDIA Triton Inference Server\n            check_requirements(\"tritonclient[all]\")\n            from ultralytics.utils.triton import TritonRemoteModel\n\n            model = TritonRemoteModel(w)\n        else:\n            from ultralytics.engine.exporter import export_formats\n\n            raise TypeError(\n                f\"model='{w}' is not a supported model format. \"\n                \"See https://docs.ultralytics.com/modes/predict for help.\"\n                f\"\\n\\n{export_formats()}\"\n            )\n\n        # Load external metadata YAML\n        if isinstance(metadata, (str, Path)) and Path(metadata).exists():\n            metadata = yaml_load(metadata)\n        if metadata:\n            for k, v in metadata.items():\n                if k in (\"stride\", \"batch\"):\n                    metadata[k] = int(v)\n                elif k in (\"imgsz\", \"names\", \"kpt_shape\") and isinstance(v, str):\n                    metadata[k] = eval(v)\n            stride = metadata[\"stride\"]\n            task = metadata[\"task\"]\n            batch = metadata[\"batch\"]\n            imgsz = metadata[\"imgsz\"]\n            names = metadata[\"names\"]\n            kpt_shape = metadata.get(\"kpt_shape\")\n        elif not (pt or triton or nn_module):\n            LOGGER.warning(f\"WARNING \u26a0\ufe0f Metadata not found for 'model={weights}'\")\n\n        # Check names\n        if \"names\" not in locals():  # names missing\n            names = default_class_names(data)\n        names = check_class_names(names)\n\n        # Disable gradients\n        if pt:\n            for p in model.parameters():\n                p.requires_grad = False\n\n        self.__dict__.update(locals())  # assign all variables to self\n\n    def forward(self, im, augment=False, visualize=False, embed=None):\n        \"\"\"\n        Runs inference on the YOLOv8 MultiBackend model.\n\n        Args:\n            im (torch.Tensor): The image tensor to perform inference on.\n            augment (bool): whether to perform data augmentation during inference, defaults to False\n            visualize (bool): whether to visualize the output predictions, defaults to False\n            embed (list, optional): A list of feature vectors/embeddings to return.\n\n        Returns:\n            (tuple): Tuple containing the raw output tensor, and processed output for visualization (if visualize=True)\n        \"\"\"\n        b, ch, h, w = im.shape  # batch, channel, height, width\n        if self.fp16 and im.dtype != torch.float16:\n            im = im.half()  # to FP16\n        if self.nhwc:\n            im = im.permute(0, 2, 3, 1)  # torch BCHW to numpy BHWC shape(1,320,192,3)\n\n        if self.pt or self.nn_module:  # PyTorch\n            y = self.model(im, augment=augment, visualize=visualize, embed=embed)\n        elif self.jit:  # TorchScript\n            y = self.model(im)\n        elif self.dnn:  # ONNX OpenCV DNN\n            im = im.cpu().numpy()  # torch to numpy\n            self.net.setInput(im)\n            y = self.net.forward()\n        elif self.onnx:  # ONNX Runtime\n            im = im.cpu().numpy()  # torch to numpy\n            y = self.session.run(self.output_names, {self.session.get_inputs()[0].name: im})\n        elif self.xml:  # OpenVINO\n            im = im.cpu().numpy()  # FP32\n            y = list(self.ov_compiled_model(im).values())\n        elif self.engine:  # TensorRT\n            if self.dynamic and im.shape != self.bindings[\"images\"].shape:\n                i = self.model.get_binding_index(\"images\")\n                self.context.set_binding_shape(i, im.shape)  # reshape if dynamic\n                self.bindings[\"images\"] = self.bindings[\"images\"]._replace(shape=im.shape)\n                for name in self.output_names:\n                    i = self.model.get_binding_index(name)\n                    self.bindings[name].data.resize_(tuple(self.context.get_binding_shape(i)))\n            s = self.bindings[\"images\"].shape\n            assert im.shape == s, f\"input size {im.shape} {'&gt;' if self.dynamic else 'not equal to'} max model size {s}\"\n            self.binding_addrs[\"images\"] = int(im.data_ptr())\n            self.context.execute_v2(list(self.binding_addrs.values()))\n            y = [self.bindings[x].data for x in sorted(self.output_names)]\n        elif self.coreml:  # CoreML\n            im = im[0].cpu().numpy()\n            im_pil = Image.fromarray((im * 255).astype(\"uint8\"))\n            # im = im.resize((192, 320), Image.BILINEAR)\n            y = self.model.predict({\"image\": im_pil})  # coordinates are xywh normalized\n            if \"confidence\" in y:\n                raise TypeError(\n                    \"Ultralytics only supports inference of non-pipelined CoreML models exported with \"\n                    f\"'nms=False', but 'model={w}' has an NMS pipeline created by an 'nms=True' export.\"\n                )\n                # TODO: CoreML NMS inference handling\n                # from ultralytics.utils.ops import xywh2xyxy\n                # box = xywh2xyxy(y['coordinates'] * [[w, h, w, h]])  # xyxy pixels\n                # conf, cls = y['confidence'].max(1), y['confidence'].argmax(1).astype(np.float32)\n                # y = np.concatenate((box, conf.reshape(-1, 1), cls.reshape(-1, 1)), 1)\n            elif len(y) == 1:  # classification model\n                y = list(y.values())\n            elif len(y) == 2:  # segmentation model\n                y = list(reversed(y.values()))  # reversed for segmentation models (pred, proto)\n        elif self.paddle:  # PaddlePaddle\n            im = im.cpu().numpy().astype(np.float32)\n            self.input_handle.copy_from_cpu(im)\n            self.predictor.run()\n            y = [self.predictor.get_output_handle(x).copy_to_cpu() for x in self.output_names]\n        elif self.ncnn:  # ncnn\n            mat_in = self.pyncnn.Mat(im[0].cpu().numpy())\n            ex = self.net.create_extractor()\n            input_names, output_names = self.net.input_names(), self.net.output_names()\n            ex.input(input_names[0], mat_in)\n            y = []\n            for output_name in output_names:\n                mat_out = self.pyncnn.Mat()\n                ex.extract(output_name, mat_out)\n                y.append(np.array(mat_out)[None])\n        elif self.triton:  # NVIDIA Triton Inference Server\n            im = im.cpu().numpy()  # torch to numpy\n            y = self.model(im)\n        else:  # TensorFlow (SavedModel, GraphDef, Lite, Edge TPU)\n            im = im.cpu().numpy()\n            if self.saved_model:  # SavedModel\n                y = self.model(im, training=False) if self.keras else self.model(im)\n                if not isinstance(y, list):\n                    y = [y]\n            elif self.pb:  # GraphDef\n                y = self.frozen_func(x=self.tf.constant(im))\n                if len(y) == 2 and len(self.names) == 999:  # segments and names not defined\n                    ip, ib = (0, 1) if len(y[0].shape) == 4 else (1, 0)  # index of protos, boxes\n                    nc = y[ib].shape[1] - y[ip].shape[3] - 4  # y = (1, 160, 160, 32), (1, 116, 8400)\n                    self.names = {i: f\"class{i}\" for i in range(nc)}\n            else:  # Lite or Edge TPU\n                details = self.input_details[0]\n                integer = details[\"dtype\"] in (np.int8, np.int16)  # is TFLite quantized int8 or int16 model\n                if integer:\n                    scale, zero_point = details[\"quantization\"]\n                    im = (im / scale + zero_point).astype(details[\"dtype\"])  # de-scale\n                self.interpreter.set_tensor(details[\"index\"], im)\n                self.interpreter.invoke()\n                y = []\n                for output in self.output_details:\n                    x = self.interpreter.get_tensor(output[\"index\"])\n                    if integer:\n                        scale, zero_point = output[\"quantization\"]\n                        x = (x.astype(np.float32) - zero_point) * scale  # re-scale\n                    if x.ndim &gt; 2:  # if task is not classification\n                        # Denormalize xywh by image size. See https://github.com/ultralytics/ultralytics/pull/1695\n                        # xywh are normalized in TFLite/EdgeTPU to mitigate quantization error of integer models\n                        x[:, [0, 2]] *= w\n                        x[:, [1, 3]] *= h\n                    y.append(x)\n            # TF segment fixes: export is reversed vs ONNX export and protos are transposed\n            if len(y) == 2:  # segment with (det, proto) output order reversed\n                if len(y[1].shape) != 4:\n                    y = list(reversed(y))  # should be y = (1, 116, 8400), (1, 160, 160, 32)\n                y[1] = np.transpose(y[1], (0, 3, 1, 2))  # should be y = (1, 116, 8400), (1, 32, 160, 160)\n            y = [x if isinstance(x, np.ndarray) else x.numpy() for x in y]\n\n        # for x in y:\n        #     print(type(x), len(x)) if isinstance(x, (list, tuple)) else print(type(x), x.shape)  # debug shapes\n        if isinstance(y, (list, tuple)):\n            return self.from_numpy(y[0]) if len(y) == 1 else [self.from_numpy(x) for x in y]\n        else:\n            return self.from_numpy(y)\n\n    def from_numpy(self, x):\n        \"\"\"\n        Convert a numpy array to a tensor.\n\n        Args:\n            x (np.ndarray): The array to be converted.\n\n        Returns:\n            (torch.Tensor): The converted tensor\n        \"\"\"\n        return torch.tensor(x).to(self.device) if isinstance(x, np.ndarray) else x\n\n    def warmup(self, imgsz=(1, 3, 640, 640)):\n        \"\"\"\n        Warm up the model by running one forward pass with a dummy input.\n\n        Args:\n            imgsz (tuple): The shape of the dummy input tensor in the format (batch_size, channels, height, width)\n\n        Returns:\n            (None): This method runs the forward pass and don't return any value\n        \"\"\"\n        warmup_types = self.pt, self.jit, self.onnx, self.engine, self.saved_model, self.pb, self.triton, self.nn_module\n        if any(warmup_types) and (self.device.type != \"cpu\" or self.triton):\n            im = torch.empty(*imgsz, dtype=torch.half if self.fp16 else torch.float, device=self.device)  # input\n            for _ in range(2 if self.jit else 1):\n                self.forward(im)  # warmup\n\n    @staticmethod\n    def _model_type(p=\"path/to/model.pt\"):\n        \"\"\"\n        This function takes a path to a model file and returns the model type.\n\n        Args:\n            p: path to the model file. Defaults to path/to/model.pt\n        \"\"\"\n        # Return model type from model path, i.e. path='path/to/model.onnx' -&gt; type=onnx\n        # types = [pt, jit, onnx, xml, engine, coreml, saved_model, pb, tflite, edgetpu, tfjs, paddle]\n        from ultralytics.engine.exporter import export_formats\n\n        sf = list(export_formats().Suffix)  # export suffixes\n        if not is_url(p, check=False) and not isinstance(p, str):\n            check_suffix(p, sf)  # checks\n        name = Path(p).name\n        types = [s in name for s in sf]\n        types[5] |= name.endswith(\".mlmodel\")  # retain support for older Apple CoreML *.mlmodel formats\n        types[8] &amp;= not types[9]  # tflite &amp;= not edgetpu\n        if any(types):\n            triton = False\n        else:\n            from urllib.parse import urlsplit\n\n            url = urlsplit(p)\n            triton = url.netloc and url.path and url.scheme in {\"http\", \"grpc\"}\n\n        return types + [triton]\n</code></pre>"},{"location":"reference/nn/autobackend/#ultralytics.nn.autobackend.AutoBackend.__init__","title":"<code>__init__(weights='yolov8n.pt', device=torch.device('cpu'), dnn=False, data=None, fp16=False, fuse=True, verbose=True)</code>","text":"<p>Initialize the AutoBackend for inference.</p> <p>Parameters:</p> Name Type Description Default <code>weights</code> <code>str</code> <p>Path to the model weights file. Defaults to 'yolov8n.pt'.</p> <code>'yolov8n.pt'</code> <code>device</code> <code>device</code> <p>Device to run the model on. Defaults to CPU.</p> <code>device('cpu')</code> <code>dnn</code> <code>bool</code> <p>Use OpenCV DNN module for ONNX inference. Defaults to False.</p> <code>False</code> <code>data</code> <code>str | Path | optional</code> <p>Path to the additional data.yaml file containing class names. Optional.</p> <code>None</code> <code>fp16</code> <code>bool</code> <p>Enable half-precision inference. Supported only on specific backends. Defaults to False.</p> <code>False</code> <code>fuse</code> <code>bool</code> <p>Fuse Conv2D + BatchNorm layers for optimization. Defaults to True.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>Enable verbose logging. Defaults to True.</p> <code>True</code> Source code in <code>ultralytics/nn/autobackend.py</code> <pre><code>@torch.no_grad()\ndef __init__(\n    self,\n    weights=\"yolov8n.pt\",\n    device=torch.device(\"cpu\"),\n    dnn=False,\n    data=None,\n    fp16=False,\n    fuse=True,\n    verbose=True,\n):\n    \"\"\"\n    Initialize the AutoBackend for inference.\n\n    Args:\n        weights (str): Path to the model weights file. Defaults to 'yolov8n.pt'.\n        device (torch.device): Device to run the model on. Defaults to CPU.\n        dnn (bool): Use OpenCV DNN module for ONNX inference. Defaults to False.\n        data (str | Path | optional): Path to the additional data.yaml file containing class names. Optional.\n        fp16 (bool): Enable half-precision inference. Supported only on specific backends. Defaults to False.\n        fuse (bool): Fuse Conv2D + BatchNorm layers for optimization. Defaults to True.\n        verbose (bool): Enable verbose logging. Defaults to True.\n    \"\"\"\n    super().__init__()\n    w = str(weights[0] if isinstance(weights, list) else weights)\n    nn_module = isinstance(weights, torch.nn.Module)\n    (\n        pt,\n        jit,\n        onnx,\n        xml,\n        engine,\n        coreml,\n        saved_model,\n        pb,\n        tflite,\n        edgetpu,\n        tfjs,\n        paddle,\n        ncnn,\n        triton,\n    ) = self._model_type(w)\n    fp16 &amp;= pt or jit or onnx or xml or engine or nn_module or triton  # FP16\n    nhwc = coreml or saved_model or pb or tflite or edgetpu  # BHWC formats (vs torch BCWH)\n    stride = 32  # default stride\n    model, metadata = None, None\n\n    # Set device\n    cuda = torch.cuda.is_available() and device.type != \"cpu\"  # use CUDA\n    if cuda and not any([nn_module, pt, jit, engine, onnx]):  # GPU dataloader formats\n        device = torch.device(\"cpu\")\n        cuda = False\n\n    # Download if not local\n    if not (pt or triton or nn_module):\n        w = attempt_download_asset(w)\n\n    # Load model\n    if nn_module:  # in-memory PyTorch model\n        model = weights.to(device)\n        model = model.fuse(verbose=verbose) if fuse else model\n        if hasattr(model, \"kpt_shape\"):\n            kpt_shape = model.kpt_shape  # pose-only\n        stride = max(int(model.stride.max()), 32)  # model stride\n        names = model.module.names if hasattr(model, \"module\") else model.names  # get class names\n        model.half() if fp16 else model.float()\n        self.model = model  # explicitly assign for to(), cpu(), cuda(), half()\n        pt = True\n    elif pt:  # PyTorch\n        from ultralytics.nn.tasks import attempt_load_weights\n\n        model = attempt_load_weights(\n            weights if isinstance(weights, list) else w, device=device, inplace=True, fuse=fuse\n        )\n        if hasattr(model, \"kpt_shape\"):\n            kpt_shape = model.kpt_shape  # pose-only\n        stride = max(int(model.stride.max()), 32)  # model stride\n        names = model.module.names if hasattr(model, \"module\") else model.names  # get class names\n        model.half() if fp16 else model.float()\n        self.model = model  # explicitly assign for to(), cpu(), cuda(), half()\n    elif jit:  # TorchScript\n        LOGGER.info(f\"Loading {w} for TorchScript inference...\")\n        extra_files = {\"config.txt\": \"\"}  # model metadata\n        model = torch.jit.load(w, _extra_files=extra_files, map_location=device)\n        model.half() if fp16 else model.float()\n        if extra_files[\"config.txt\"]:  # load metadata dict\n            metadata = json.loads(extra_files[\"config.txt\"], object_hook=lambda x: dict(x.items()))\n    elif dnn:  # ONNX OpenCV DNN\n        LOGGER.info(f\"Loading {w} for ONNX OpenCV DNN inference...\")\n        check_requirements(\"opencv-python&gt;=4.5.4\")\n        net = cv2.dnn.readNetFromONNX(w)\n    elif onnx:  # ONNX Runtime\n        LOGGER.info(f\"Loading {w} for ONNX Runtime inference...\")\n        check_requirements((\"onnx\", \"onnxruntime-gpu\" if cuda else \"onnxruntime\"))\n        import onnxruntime\n\n        providers = [\"CUDAExecutionProvider\", \"CPUExecutionProvider\"] if cuda else [\"CPUExecutionProvider\"]\n        session = onnxruntime.InferenceSession(w, providers=providers)\n        output_names = [x.name for x in session.get_outputs()]\n        metadata = session.get_modelmeta().custom_metadata_map  # metadata\n    elif xml:  # OpenVINO\n        LOGGER.info(f\"Loading {w} for OpenVINO inference...\")\n        check_requirements(\"openvino&gt;=2023.0\")  # requires openvino-dev: https://pypi.org/project/openvino-dev/\n        from openvino.runtime import Core, Layout, get_batch  # noqa\n\n        core = Core()\n        w = Path(w)\n        if not w.is_file():  # if not *.xml\n            w = next(w.glob(\"*.xml\"))  # get *.xml file from *_openvino_model dir\n        ov_model = core.read_model(model=str(w), weights=w.with_suffix(\".bin\"))\n        if ov_model.get_parameters()[0].get_layout().empty:\n            ov_model.get_parameters()[0].set_layout(Layout(\"NCHW\"))\n        batch_dim = get_batch(ov_model)\n        if batch_dim.is_static:\n            batch_size = batch_dim.get_length()\n        ov_compiled_model = core.compile_model(ov_model, device_name=\"AUTO\")  # AUTO selects best available device\n        metadata = w.parent / \"metadata.yaml\"\n    elif engine:  # TensorRT\n        LOGGER.info(f\"Loading {w} for TensorRT inference...\")\n        try:\n            import tensorrt as trt  # noqa https://developer.nvidia.com/nvidia-tensorrt-download\n        except ImportError:\n            if LINUX:\n                check_requirements(\"nvidia-tensorrt\", cmds=\"-U --index-url https://pypi.ngc.nvidia.com\")\n            import tensorrt as trt  # noqa\n        check_version(trt.__version__, \"7.0.0\", hard=True)  # require tensorrt&gt;=7.0.0\n        if device.type == \"cpu\":\n            device = torch.device(\"cuda:0\")\n        Binding = namedtuple(\"Binding\", (\"name\", \"dtype\", \"shape\", \"data\", \"ptr\"))\n        logger = trt.Logger(trt.Logger.INFO)\n        # Read file\n        with open(w, \"rb\") as f, trt.Runtime(logger) as runtime:\n            meta_len = int.from_bytes(f.read(4), byteorder=\"little\")  # read metadata length\n            metadata = json.loads(f.read(meta_len).decode(\"utf-8\"))  # read metadata\n            model = runtime.deserialize_cuda_engine(f.read())  # read engine\n        context = model.create_execution_context()\n        bindings = OrderedDict()\n        output_names = []\n        fp16 = False  # default updated below\n        dynamic = False\n        for i in range(model.num_bindings):\n            name = model.get_binding_name(i)\n            dtype = trt.nptype(model.get_binding_dtype(i))\n            if model.binding_is_input(i):\n                if -1 in tuple(model.get_binding_shape(i)):  # dynamic\n                    dynamic = True\n                    context.set_binding_shape(i, tuple(model.get_profile_shape(0, i)[2]))\n                if dtype == np.float16:\n                    fp16 = True\n            else:  # output\n                output_names.append(name)\n            shape = tuple(context.get_binding_shape(i))\n            im = torch.from_numpy(np.empty(shape, dtype=dtype)).to(device)\n            bindings[name] = Binding(name, dtype, shape, im, int(im.data_ptr()))\n        binding_addrs = OrderedDict((n, d.ptr) for n, d in bindings.items())\n        batch_size = bindings[\"images\"].shape[0]  # if dynamic, this is instead max batch size\n    elif coreml:  # CoreML\n        LOGGER.info(f\"Loading {w} for CoreML inference...\")\n        import coremltools as ct\n\n        model = ct.models.MLModel(w)\n        metadata = dict(model.user_defined_metadata)\n    elif saved_model:  # TF SavedModel\n        LOGGER.info(f\"Loading {w} for TensorFlow SavedModel inference...\")\n        import tensorflow as tf\n\n        keras = False  # assume TF1 saved_model\n        model = tf.keras.models.load_model(w) if keras else tf.saved_model.load(w)\n        metadata = Path(w) / \"metadata.yaml\"\n    elif pb:  # GraphDef https://www.tensorflow.org/guide/migrate#a_graphpb_or_graphpbtxt\n        LOGGER.info(f\"Loading {w} for TensorFlow GraphDef inference...\")\n        import tensorflow as tf\n\n        from ultralytics.engine.exporter import gd_outputs\n\n        def wrap_frozen_graph(gd, inputs, outputs):\n            \"\"\"Wrap frozen graphs for deployment.\"\"\"\n            x = tf.compat.v1.wrap_function(lambda: tf.compat.v1.import_graph_def(gd, name=\"\"), [])  # wrapped\n            ge = x.graph.as_graph_element\n            return x.prune(tf.nest.map_structure(ge, inputs), tf.nest.map_structure(ge, outputs))\n\n        gd = tf.Graph().as_graph_def()  # TF GraphDef\n        with open(w, \"rb\") as f:\n            gd.ParseFromString(f.read())\n        frozen_func = wrap_frozen_graph(gd, inputs=\"x:0\", outputs=gd_outputs(gd))\n    elif tflite or edgetpu:  # https://www.tensorflow.org/lite/guide/python#install_tensorflow_lite_for_python\n        try:  # https://coral.ai/docs/edgetpu/tflite-python/#update-existing-tf-lite-code-for-the-edge-tpu\n            from tflite_runtime.interpreter import Interpreter, load_delegate\n        except ImportError:\n            import tensorflow as tf\n\n            Interpreter, load_delegate = tf.lite.Interpreter, tf.lite.experimental.load_delegate\n        if edgetpu:  # TF Edge TPU https://coral.ai/software/#edgetpu-runtime\n            LOGGER.info(f\"Loading {w} for TensorFlow Lite Edge TPU inference...\")\n            delegate = {\"Linux\": \"libedgetpu.so.1\", \"Darwin\": \"libedgetpu.1.dylib\", \"Windows\": \"edgetpu.dll\"}[\n                platform.system()\n            ]\n            interpreter = Interpreter(model_path=w, experimental_delegates=[load_delegate(delegate)])\n        else:  # TFLite\n            LOGGER.info(f\"Loading {w} for TensorFlow Lite inference...\")\n            interpreter = Interpreter(model_path=w)  # load TFLite model\n        interpreter.allocate_tensors()  # allocate\n        input_details = interpreter.get_input_details()  # inputs\n        output_details = interpreter.get_output_details()  # outputs\n        # Load metadata\n        with contextlib.suppress(zipfile.BadZipFile):\n            with zipfile.ZipFile(w, \"r\") as model:\n                meta_file = model.namelist()[0]\n                metadata = ast.literal_eval(model.read(meta_file).decode(\"utf-8\"))\n    elif tfjs:  # TF.js\n        raise NotImplementedError(\"YOLOv8 TF.js inference is not currently supported.\")\n    elif paddle:  # PaddlePaddle\n        LOGGER.info(f\"Loading {w} for PaddlePaddle inference...\")\n        check_requirements(\"paddlepaddle-gpu\" if cuda else \"paddlepaddle\")\n        import paddle.inference as pdi  # noqa\n\n        w = Path(w)\n        if not w.is_file():  # if not *.pdmodel\n            w = next(w.rglob(\"*.pdmodel\"))  # get *.pdmodel file from *_paddle_model dir\n        config = pdi.Config(str(w), str(w.with_suffix(\".pdiparams\")))\n        if cuda:\n            config.enable_use_gpu(memory_pool_init_size_mb=2048, device_id=0)\n        predictor = pdi.create_predictor(config)\n        input_handle = predictor.get_input_handle(predictor.get_input_names()[0])\n        output_names = predictor.get_output_names()\n        metadata = w.parents[1] / \"metadata.yaml\"\n    elif ncnn:  # ncnn\n        LOGGER.info(f\"Loading {w} for ncnn inference...\")\n        check_requirements(\"git+https://github.com/Tencent/ncnn.git\" if ARM64 else \"ncnn\")  # requires ncnn\n        import ncnn as pyncnn\n\n        net = pyncnn.Net()\n        net.opt.use_vulkan_compute = cuda\n        w = Path(w)\n        if not w.is_file():  # if not *.param\n            w = next(w.glob(\"*.param\"))  # get *.param file from *_ncnn_model dir\n        net.load_param(str(w))\n        net.load_model(str(w.with_suffix(\".bin\")))\n        metadata = w.parent / \"metadata.yaml\"\n    elif triton:  # NVIDIA Triton Inference Server\n        check_requirements(\"tritonclient[all]\")\n        from ultralytics.utils.triton import TritonRemoteModel\n\n        model = TritonRemoteModel(w)\n    else:\n        from ultralytics.engine.exporter import export_formats\n\n        raise TypeError(\n            f\"model='{w}' is not a supported model format. \"\n            \"See https://docs.ultralytics.com/modes/predict for help.\"\n            f\"\\n\\n{export_formats()}\"\n        )\n\n    # Load external metadata YAML\n    if isinstance(metadata, (str, Path)) and Path(metadata).exists():\n        metadata = yaml_load(metadata)\n    if metadata:\n        for k, v in metadata.items():\n            if k in (\"stride\", \"batch\"):\n                metadata[k] = int(v)\n            elif k in (\"imgsz\", \"names\", \"kpt_shape\") and isinstance(v, str):\n                metadata[k] = eval(v)\n        stride = metadata[\"stride\"]\n        task = metadata[\"task\"]\n        batch = metadata[\"batch\"]\n        imgsz = metadata[\"imgsz\"]\n        names = metadata[\"names\"]\n        kpt_shape = metadata.get(\"kpt_shape\")\n    elif not (pt or triton or nn_module):\n        LOGGER.warning(f\"WARNING \u26a0\ufe0f Metadata not found for 'model={weights}'\")\n\n    # Check names\n    if \"names\" not in locals():  # names missing\n        names = default_class_names(data)\n    names = check_class_names(names)\n\n    # Disable gradients\n    if pt:\n        for p in model.parameters():\n            p.requires_grad = False\n\n    self.__dict__.update(locals())  # assign all variables to self\n</code></pre>"},{"location":"reference/nn/autobackend/#ultralytics.nn.autobackend.AutoBackend.forward","title":"<code>forward(im, augment=False, visualize=False, embed=None)</code>","text":"<p>Runs inference on the YOLOv8 MultiBackend model.</p> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>Tensor</code> <p>The image tensor to perform inference on.</p> required <code>augment</code> <code>bool</code> <p>whether to perform data augmentation during inference, defaults to False</p> <code>False</code> <code>visualize</code> <code>bool</code> <p>whether to visualize the output predictions, defaults to False</p> <code>False</code> <code>embed</code> <code>list</code> <p>A list of feature vectors/embeddings to return.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple containing the raw output tensor, and processed output for visualization (if visualize=True)</p> Source code in <code>ultralytics/nn/autobackend.py</code> <pre><code>def forward(self, im, augment=False, visualize=False, embed=None):\n    \"\"\"\n    Runs inference on the YOLOv8 MultiBackend model.\n\n    Args:\n        im (torch.Tensor): The image tensor to perform inference on.\n        augment (bool): whether to perform data augmentation during inference, defaults to False\n        visualize (bool): whether to visualize the output predictions, defaults to False\n        embed (list, optional): A list of feature vectors/embeddings to return.\n\n    Returns:\n        (tuple): Tuple containing the raw output tensor, and processed output for visualization (if visualize=True)\n    \"\"\"\n    b, ch, h, w = im.shape  # batch, channel, height, width\n    if self.fp16 and im.dtype != torch.float16:\n        im = im.half()  # to FP16\n    if self.nhwc:\n        im = im.permute(0, 2, 3, 1)  # torch BCHW to numpy BHWC shape(1,320,192,3)\n\n    if self.pt or self.nn_module:  # PyTorch\n        y = self.model(im, augment=augment, visualize=visualize, embed=embed)\n    elif self.jit:  # TorchScript\n        y = self.model(im)\n    elif self.dnn:  # ONNX OpenCV DNN\n        im = im.cpu().numpy()  # torch to numpy\n        self.net.setInput(im)\n        y = self.net.forward()\n    elif self.onnx:  # ONNX Runtime\n        im = im.cpu().numpy()  # torch to numpy\n        y = self.session.run(self.output_names, {self.session.get_inputs()[0].name: im})\n    elif self.xml:  # OpenVINO\n        im = im.cpu().numpy()  # FP32\n        y = list(self.ov_compiled_model(im).values())\n    elif self.engine:  # TensorRT\n        if self.dynamic and im.shape != self.bindings[\"images\"].shape:\n            i = self.model.get_binding_index(\"images\")\n            self.context.set_binding_shape(i, im.shape)  # reshape if dynamic\n            self.bindings[\"images\"] = self.bindings[\"images\"]._replace(shape=im.shape)\n            for name in self.output_names:\n                i = self.model.get_binding_index(name)\n                self.bindings[name].data.resize_(tuple(self.context.get_binding_shape(i)))\n        s = self.bindings[\"images\"].shape\n        assert im.shape == s, f\"input size {im.shape} {'&gt;' if self.dynamic else 'not equal to'} max model size {s}\"\n        self.binding_addrs[\"images\"] = int(im.data_ptr())\n        self.context.execute_v2(list(self.binding_addrs.values()))\n        y = [self.bindings[x].data for x in sorted(self.output_names)]\n    elif self.coreml:  # CoreML\n        im = im[0].cpu().numpy()\n        im_pil = Image.fromarray((im * 255).astype(\"uint8\"))\n        # im = im.resize((192, 320), Image.BILINEAR)\n        y = self.model.predict({\"image\": im_pil})  # coordinates are xywh normalized\n        if \"confidence\" in y:\n            raise TypeError(\n                \"Ultralytics only supports inference of non-pipelined CoreML models exported with \"\n                f\"'nms=False', but 'model={w}' has an NMS pipeline created by an 'nms=True' export.\"\n            )\n            # TODO: CoreML NMS inference handling\n            # from ultralytics.utils.ops import xywh2xyxy\n            # box = xywh2xyxy(y['coordinates'] * [[w, h, w, h]])  # xyxy pixels\n            # conf, cls = y['confidence'].max(1), y['confidence'].argmax(1).astype(np.float32)\n            # y = np.concatenate((box, conf.reshape(-1, 1), cls.reshape(-1, 1)), 1)\n        elif len(y) == 1:  # classification model\n            y = list(y.values())\n        elif len(y) == 2:  # segmentation model\n            y = list(reversed(y.values()))  # reversed for segmentation models (pred, proto)\n    elif self.paddle:  # PaddlePaddle\n        im = im.cpu().numpy().astype(np.float32)\n        self.input_handle.copy_from_cpu(im)\n        self.predictor.run()\n        y = [self.predictor.get_output_handle(x).copy_to_cpu() for x in self.output_names]\n    elif self.ncnn:  # ncnn\n        mat_in = self.pyncnn.Mat(im[0].cpu().numpy())\n        ex = self.net.create_extractor()\n        input_names, output_names = self.net.input_names(), self.net.output_names()\n        ex.input(input_names[0], mat_in)\n        y = []\n        for output_name in output_names:\n            mat_out = self.pyncnn.Mat()\n            ex.extract(output_name, mat_out)\n            y.append(np.array(mat_out)[None])\n    elif self.triton:  # NVIDIA Triton Inference Server\n        im = im.cpu().numpy()  # torch to numpy\n        y = self.model(im)\n    else:  # TensorFlow (SavedModel, GraphDef, Lite, Edge TPU)\n        im = im.cpu().numpy()\n        if self.saved_model:  # SavedModel\n            y = self.model(im, training=False) if self.keras else self.model(im)\n            if not isinstance(y, list):\n                y = [y]\n        elif self.pb:  # GraphDef\n            y = self.frozen_func(x=self.tf.constant(im))\n            if len(y) == 2 and len(self.names) == 999:  # segments and names not defined\n                ip, ib = (0, 1) if len(y[0].shape) == 4 else (1, 0)  # index of protos, boxes\n                nc = y[ib].shape[1] - y[ip].shape[3] - 4  # y = (1, 160, 160, 32), (1, 116, 8400)\n                self.names = {i: f\"class{i}\" for i in range(nc)}\n        else:  # Lite or Edge TPU\n            details = self.input_details[0]\n            integer = details[\"dtype\"] in (np.int8, np.int16)  # is TFLite quantized int8 or int16 model\n            if integer:\n                scale, zero_point = details[\"quantization\"]\n                im = (im / scale + zero_point).astype(details[\"dtype\"])  # de-scale\n            self.interpreter.set_tensor(details[\"index\"], im)\n            self.interpreter.invoke()\n            y = []\n            for output in self.output_details:\n                x = self.interpreter.get_tensor(output[\"index\"])\n                if integer:\n                    scale, zero_point = output[\"quantization\"]\n                    x = (x.astype(np.float32) - zero_point) * scale  # re-scale\n                if x.ndim &gt; 2:  # if task is not classification\n                    # Denormalize xywh by image size. See https://github.com/ultralytics/ultralytics/pull/1695\n                    # xywh are normalized in TFLite/EdgeTPU to mitigate quantization error of integer models\n                    x[:, [0, 2]] *= w\n                    x[:, [1, 3]] *= h\n                y.append(x)\n        # TF segment fixes: export is reversed vs ONNX export and protos are transposed\n        if len(y) == 2:  # segment with (det, proto) output order reversed\n            if len(y[1].shape) != 4:\n                y = list(reversed(y))  # should be y = (1, 116, 8400), (1, 160, 160, 32)\n            y[1] = np.transpose(y[1], (0, 3, 1, 2))  # should be y = (1, 116, 8400), (1, 32, 160, 160)\n        y = [x if isinstance(x, np.ndarray) else x.numpy() for x in y]\n\n    # for x in y:\n    #     print(type(x), len(x)) if isinstance(x, (list, tuple)) else print(type(x), x.shape)  # debug shapes\n    if isinstance(y, (list, tuple)):\n        return self.from_numpy(y[0]) if len(y) == 1 else [self.from_numpy(x) for x in y]\n    else:\n        return self.from_numpy(y)\n</code></pre>"},{"location":"reference/nn/autobackend/#ultralytics.nn.autobackend.AutoBackend.from_numpy","title":"<code>from_numpy(x)</code>","text":"<p>Convert a numpy array to a tensor.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>The array to be converted.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The converted tensor</p> Source code in <code>ultralytics/nn/autobackend.py</code> <pre><code>def from_numpy(self, x):\n    \"\"\"\n    Convert a numpy array to a tensor.\n\n    Args:\n        x (np.ndarray): The array to be converted.\n\n    Returns:\n        (torch.Tensor): The converted tensor\n    \"\"\"\n    return torch.tensor(x).to(self.device) if isinstance(x, np.ndarray) else x\n</code></pre>"},{"location":"reference/nn/autobackend/#ultralytics.nn.autobackend.AutoBackend.warmup","title":"<code>warmup(imgsz=(1, 3, 640, 640))</code>","text":"<p>Warm up the model by running one forward pass with a dummy input.</p> <p>Parameters:</p> Name Type Description Default <code>imgsz</code> <code>tuple</code> <p>The shape of the dummy input tensor in the format (batch_size, channels, height, width)</p> <code>(1, 3, 640, 640)</code> <p>Returns:</p> Type Description <code>None</code> <p>This method runs the forward pass and don't return any value</p> Source code in <code>ultralytics/nn/autobackend.py</code> <pre><code>def warmup(self, imgsz=(1, 3, 640, 640)):\n    \"\"\"\n    Warm up the model by running one forward pass with a dummy input.\n\n    Args:\n        imgsz (tuple): The shape of the dummy input tensor in the format (batch_size, channels, height, width)\n\n    Returns:\n        (None): This method runs the forward pass and don't return any value\n    \"\"\"\n    warmup_types = self.pt, self.jit, self.onnx, self.engine, self.saved_model, self.pb, self.triton, self.nn_module\n    if any(warmup_types) and (self.device.type != \"cpu\" or self.triton):\n        im = torch.empty(*imgsz, dtype=torch.half if self.fp16 else torch.float, device=self.device)  # input\n        for _ in range(2 if self.jit else 1):\n            self.forward(im)  # warmup\n</code></pre>"},{"location":"reference/nn/autobackend/#ultralytics.nn.autobackend.check_class_names","title":"<code>ultralytics.nn.autobackend.check_class_names(names)</code>","text":"<p>Check class names.</p> <p>Map imagenet class codes to human-readable names if required. Convert lists to dicts.</p> Source code in <code>ultralytics/nn/autobackend.py</code> <pre><code>def check_class_names(names):\n    \"\"\"\n    Check class names.\n\n    Map imagenet class codes to human-readable names if required. Convert lists to dicts.\n    \"\"\"\n    if isinstance(names, list):  # names is a list\n        names = dict(enumerate(names))  # convert to dict\n    if isinstance(names, dict):\n        # Convert 1) string keys to int, i.e. '0' to 0, and non-string values to strings, i.e. True to 'True'\n        names = {int(k): str(v) for k, v in names.items()}\n        n = len(names)\n        if max(names.keys()) &gt;= n:\n            raise KeyError(\n                f\"{n}-class dataset requires class indices 0-{n - 1}, but you have invalid class indices \"\n                f\"{min(names.keys())}-{max(names.keys())} defined in your dataset YAML.\"\n            )\n        if isinstance(names[0], str) and names[0].startswith(\"n0\"):  # imagenet class codes, i.e. 'n01440764'\n            names_map = yaml_load(ROOT / \"cfg/datasets/ImageNet.yaml\")[\"map\"]  # human-readable names\n            names = {k: names_map[v] for k, v in names.items()}\n    return names\n</code></pre>"},{"location":"reference/nn/autobackend/#ultralytics.nn.autobackend.default_class_names","title":"<code>ultralytics.nn.autobackend.default_class_names(data=None)</code>","text":"<p>Applies default class names to an input YAML file or returns numerical class names.</p> Source code in <code>ultralytics/nn/autobackend.py</code> <pre><code>def default_class_names(data=None):\n    \"\"\"Applies default class names to an input YAML file or returns numerical class names.\"\"\"\n    if data:\n        with contextlib.suppress(Exception):\n            return yaml_load(check_yaml(data))[\"names\"]\n    return {i: f\"class{i}\" for i in range(999)}  # return default if above errors\n</code></pre>"},{"location":"reference/nn/tasks/","title":"Reference for <code>ultralytics/nn/tasks.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/nn/tasks.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.BaseModel","title":"<code>ultralytics.nn.tasks.BaseModel</code>","text":"<p>             Bases: <code>Module</code></p> <p>The BaseModel class serves as a base class for all the models in the Ultralytics YOLO family.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>class BaseModel(nn.Module):\n    \"\"\"The BaseModel class serves as a base class for all the models in the Ultralytics YOLO family.\"\"\"\n\n    def forward(self, x, *args, **kwargs):\n        \"\"\"\n        Forward pass of the model on a single scale. Wrapper for `_forward_once` method.\n\n        Args:\n            x (torch.Tensor | dict): The input image tensor or a dict including image tensor and gt labels.\n\n        Returns:\n            (torch.Tensor): The output of the network.\n        \"\"\"\n        if isinstance(x, dict):  # for cases of training and validating while training.\n            return self.loss(x, *args, **kwargs)\n        return self.predict(x, *args, **kwargs)\n\n    def predict(self, x, profile=False, visualize=False, augment=False, embed=None):\n        \"\"\"\n        Perform a forward pass through the network.\n\n        Args:\n            x (torch.Tensor): The input tensor to the model.\n            profile (bool):  Print the computation time of each layer if True, defaults to False.\n            visualize (bool): Save the feature maps of the model if True, defaults to False.\n            augment (bool): Augment image during prediction, defaults to False.\n            embed (list, optional): A list of feature vectors/embeddings to return.\n\n        Returns:\n            (torch.Tensor): The last output of the model.\n        \"\"\"\n        if augment:\n            return self._predict_augment(x)\n        return self._predict_once(x, profile, visualize, embed)\n\n    def _predict_once(self, x, profile=False, visualize=False, embed=None):\n        \"\"\"\n        Perform a forward pass through the network.\n\n        Args:\n            x (torch.Tensor): The input tensor to the model.\n            profile (bool):  Print the computation time of each layer if True, defaults to False.\n            visualize (bool): Save the feature maps of the model if True, defaults to False.\n            embed (list, optional): A list of feature vectors/embeddings to return.\n\n        Returns:\n            (torch.Tensor): The last output of the model.\n        \"\"\"\n        y, dt, embeddings = [], [], []  # outputs\n        for m in self.model:\n            if m.f != -1:  # if not from previous layer\n                x = y[m.f] if isinstance(m.f, int) else [x if j == -1 else y[j] for j in m.f]  # from earlier layers\n            if profile:\n                self._profile_one_layer(m, x, dt)\n            x = m(x)  # run\n            y.append(x if m.i in self.save else None)  # save output\n            if visualize:\n                feature_visualization(x, m.type, m.i, save_dir=visualize)\n            if embed and m.i in embed:\n                embeddings.append(nn.functional.adaptive_avg_pool2d(x, (1, 1)).squeeze(-1).squeeze(-1))  # flatten\n                if m.i == max(embed):\n                    return torch.unbind(torch.cat(embeddings, 1), dim=0)\n        return x\n\n    def _predict_augment(self, x):\n        \"\"\"Perform augmentations on input image x and return augmented inference.\"\"\"\n        LOGGER.warning(\n            f\"WARNING \u26a0\ufe0f {self.__class__.__name__} does not support augmented inference yet. \"\n            f\"Reverting to single-scale inference instead.\"\n        )\n        return self._predict_once(x)\n\n    def _profile_one_layer(self, m, x, dt):\n        \"\"\"\n        Profile the computation time and FLOPs of a single layer of the model on a given input. Appends the results to\n        the provided list.\n\n        Args:\n            m (nn.Module): The layer to be profiled.\n            x (torch.Tensor): The input data to the layer.\n            dt (list): A list to store the computation time of the layer.\n\n        Returns:\n            None\n        \"\"\"\n        c = m == self.model[-1] and isinstance(x, list)  # is final layer list, copy input as inplace fix\n        flops = thop.profile(m, inputs=[x.copy() if c else x], verbose=False)[0] / 1e9 * 2 if thop else 0  # FLOPs\n        t = time_sync()\n        for _ in range(10):\n            m(x.copy() if c else x)\n        dt.append((time_sync() - t) * 100)\n        if m == self.model[0]:\n            LOGGER.info(f\"{'time (ms)':&gt;10s} {'GFLOPs':&gt;10s} {'params':&gt;10s}  module\")\n        LOGGER.info(f\"{dt[-1]:10.2f} {flops:10.2f} {m.np:10.0f}  {m.type}\")\n        if c:\n            LOGGER.info(f\"{sum(dt):10.2f} {'-':&gt;10s} {'-':&gt;10s}  Total\")\n\n    def fuse(self, verbose=True):\n        \"\"\"\n        Fuse the `Conv2d()` and `BatchNorm2d()` layers of the model into a single layer, in order to improve the\n        computation efficiency.\n\n        Returns:\n            (nn.Module): The fused model is returned.\n        \"\"\"\n        if not self.is_fused():\n            for m in self.model.modules():\n                if isinstance(m, (Conv, Conv2, DWConv)) and hasattr(m, \"bn\"):\n                    if isinstance(m, Conv2):\n                        m.fuse_convs()\n                    m.conv = fuse_conv_and_bn(m.conv, m.bn)  # update conv\n                    delattr(m, \"bn\")  # remove batchnorm\n                    m.forward = m.forward_fuse  # update forward\n                if isinstance(m, ConvTranspose) and hasattr(m, \"bn\"):\n                    m.conv_transpose = fuse_deconv_and_bn(m.conv_transpose, m.bn)\n                    delattr(m, \"bn\")  # remove batchnorm\n                    m.forward = m.forward_fuse  # update forward\n                if isinstance(m, RepConv):\n                    m.fuse_convs()\n                    m.forward = m.forward_fuse  # update forward\n            self.info(verbose=verbose)\n\n        return self\n\n    def is_fused(self, thresh=10):\n        \"\"\"\n        Check if the model has less than a certain threshold of BatchNorm layers.\n\n        Args:\n            thresh (int, optional): The threshold number of BatchNorm layers. Default is 10.\n\n        Returns:\n            (bool): True if the number of BatchNorm layers in the model is less than the threshold, False otherwise.\n        \"\"\"\n        bn = tuple(v for k, v in nn.__dict__.items() if \"Norm\" in k)  # normalization layers, i.e. BatchNorm2d()\n        return sum(isinstance(v, bn) for v in self.modules()) &lt; thresh  # True if &lt; 'thresh' BatchNorm layers in model\n\n    def info(self, detailed=False, verbose=True, imgsz=640):\n        \"\"\"\n        Prints model information.\n\n        Args:\n            detailed (bool): if True, prints out detailed information about the model. Defaults to False\n            verbose (bool): if True, prints out the model information. Defaults to False\n            imgsz (int): the size of the image that the model will be trained on. Defaults to 640\n        \"\"\"\n        return model_info(self, detailed=detailed, verbose=verbose, imgsz=imgsz)\n\n    def _apply(self, fn):\n        \"\"\"\n        Applies a function to all the tensors in the model that are not parameters or registered buffers.\n\n        Args:\n            fn (function): the function to apply to the model\n\n        Returns:\n            (BaseModel): An updated BaseModel object.\n        \"\"\"\n        self = super()._apply(fn)\n        m = self.model[-1]  # Detect()\n        if isinstance(m, (Detect, Segment)):\n            m.stride = fn(m.stride)\n            m.anchors = fn(m.anchors)\n            m.strides = fn(m.strides)\n        return self\n\n    def load(self, weights, verbose=True):\n        \"\"\"\n        Load the weights into the model.\n\n        Args:\n            weights (dict | torch.nn.Module): The pre-trained weights to be loaded.\n            verbose (bool, optional): Whether to log the transfer progress. Defaults to True.\n        \"\"\"\n        model = weights[\"model\"] if isinstance(weights, dict) else weights  # torchvision models are not dicts\n        csd = model.float().state_dict()  # checkpoint state_dict as FP32\n        csd = intersect_dicts(csd, self.state_dict())  # intersect\n        self.load_state_dict(csd, strict=False)  # load\n        if verbose:\n            LOGGER.info(f\"Transferred {len(csd)}/{len(self.model.state_dict())} items from pretrained weights\")\n\n    def loss(self, batch, preds=None):\n        \"\"\"\n        Compute loss.\n\n        Args:\n            batch (dict): Batch to compute loss on\n            preds (torch.Tensor | List[torch.Tensor]): Predictions.\n        \"\"\"\n        if not hasattr(self, \"criterion\"):\n            self.criterion = self.init_criterion()\n\n        preds = self.forward(batch[\"img\"]) if preds is None else preds\n        return self.criterion(preds, batch)\n\n    def init_criterion(self):\n        \"\"\"Initialize the loss criterion for the BaseModel.\"\"\"\n        raise NotImplementedError(\"compute_loss() needs to be implemented by task heads\")\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.BaseModel.forward","title":"<code>forward(x, *args, **kwargs)</code>","text":"<p>Forward pass of the model on a single scale. Wrapper for <code>_forward_once</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor | dict</code> <p>The input image tensor or a dict including image tensor and gt labels.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The output of the network.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def forward(self, x, *args, **kwargs):\n    \"\"\"\n    Forward pass of the model on a single scale. Wrapper for `_forward_once` method.\n\n    Args:\n        x (torch.Tensor | dict): The input image tensor or a dict including image tensor and gt labels.\n\n    Returns:\n        (torch.Tensor): The output of the network.\n    \"\"\"\n    if isinstance(x, dict):  # for cases of training and validating while training.\n        return self.loss(x, *args, **kwargs)\n    return self.predict(x, *args, **kwargs)\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.BaseModel.fuse","title":"<code>fuse(verbose=True)</code>","text":"<p>Fuse the <code>Conv2d()</code> and <code>BatchNorm2d()</code> layers of the model into a single layer, in order to improve the computation efficiency.</p> <p>Returns:</p> Type Description <code>Module</code> <p>The fused model is returned.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def fuse(self, verbose=True):\n    \"\"\"\n    Fuse the `Conv2d()` and `BatchNorm2d()` layers of the model into a single layer, in order to improve the\n    computation efficiency.\n\n    Returns:\n        (nn.Module): The fused model is returned.\n    \"\"\"\n    if not self.is_fused():\n        for m in self.model.modules():\n            if isinstance(m, (Conv, Conv2, DWConv)) and hasattr(m, \"bn\"):\n                if isinstance(m, Conv2):\n                    m.fuse_convs()\n                m.conv = fuse_conv_and_bn(m.conv, m.bn)  # update conv\n                delattr(m, \"bn\")  # remove batchnorm\n                m.forward = m.forward_fuse  # update forward\n            if isinstance(m, ConvTranspose) and hasattr(m, \"bn\"):\n                m.conv_transpose = fuse_deconv_and_bn(m.conv_transpose, m.bn)\n                delattr(m, \"bn\")  # remove batchnorm\n                m.forward = m.forward_fuse  # update forward\n            if isinstance(m, RepConv):\n                m.fuse_convs()\n                m.forward = m.forward_fuse  # update forward\n        self.info(verbose=verbose)\n\n    return self\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.BaseModel.info","title":"<code>info(detailed=False, verbose=True, imgsz=640)</code>","text":"<p>Prints model information.</p> <p>Parameters:</p> Name Type Description Default <code>detailed</code> <code>bool</code> <p>if True, prints out detailed information about the model. Defaults to False</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>if True, prints out the model information. Defaults to False</p> <code>True</code> <code>imgsz</code> <code>int</code> <p>the size of the image that the model will be trained on. Defaults to 640</p> <code>640</code> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def info(self, detailed=False, verbose=True, imgsz=640):\n    \"\"\"\n    Prints model information.\n\n    Args:\n        detailed (bool): if True, prints out detailed information about the model. Defaults to False\n        verbose (bool): if True, prints out the model information. Defaults to False\n        imgsz (int): the size of the image that the model will be trained on. Defaults to 640\n    \"\"\"\n    return model_info(self, detailed=detailed, verbose=verbose, imgsz=imgsz)\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.BaseModel.init_criterion","title":"<code>init_criterion()</code>","text":"<p>Initialize the loss criterion for the BaseModel.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def init_criterion(self):\n    \"\"\"Initialize the loss criterion for the BaseModel.\"\"\"\n    raise NotImplementedError(\"compute_loss() needs to be implemented by task heads\")\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.BaseModel.is_fused","title":"<code>is_fused(thresh=10)</code>","text":"<p>Check if the model has less than a certain threshold of BatchNorm layers.</p> <p>Parameters:</p> Name Type Description Default <code>thresh</code> <code>int</code> <p>The threshold number of BatchNorm layers. Default is 10.</p> <code>10</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the number of BatchNorm layers in the model is less than the threshold, False otherwise.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def is_fused(self, thresh=10):\n    \"\"\"\n    Check if the model has less than a certain threshold of BatchNorm layers.\n\n    Args:\n        thresh (int, optional): The threshold number of BatchNorm layers. Default is 10.\n\n    Returns:\n        (bool): True if the number of BatchNorm layers in the model is less than the threshold, False otherwise.\n    \"\"\"\n    bn = tuple(v for k, v in nn.__dict__.items() if \"Norm\" in k)  # normalization layers, i.e. BatchNorm2d()\n    return sum(isinstance(v, bn) for v in self.modules()) &lt; thresh  # True if &lt; 'thresh' BatchNorm layers in model\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.BaseModel.load","title":"<code>load(weights, verbose=True)</code>","text":"<p>Load the weights into the model.</p> <p>Parameters:</p> Name Type Description Default <code>weights</code> <code>dict | Module</code> <p>The pre-trained weights to be loaded.</p> required <code>verbose</code> <code>bool</code> <p>Whether to log the transfer progress. Defaults to True.</p> <code>True</code> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def load(self, weights, verbose=True):\n    \"\"\"\n    Load the weights into the model.\n\n    Args:\n        weights (dict | torch.nn.Module): The pre-trained weights to be loaded.\n        verbose (bool, optional): Whether to log the transfer progress. Defaults to True.\n    \"\"\"\n    model = weights[\"model\"] if isinstance(weights, dict) else weights  # torchvision models are not dicts\n    csd = model.float().state_dict()  # checkpoint state_dict as FP32\n    csd = intersect_dicts(csd, self.state_dict())  # intersect\n    self.load_state_dict(csd, strict=False)  # load\n    if verbose:\n        LOGGER.info(f\"Transferred {len(csd)}/{len(self.model.state_dict())} items from pretrained weights\")\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.BaseModel.loss","title":"<code>loss(batch, preds=None)</code>","text":"<p>Compute loss.</p> <p>Parameters:</p> Name Type Description Default <code>batch</code> <code>dict</code> <p>Batch to compute loss on</p> required <code>preds</code> <code>Tensor | List[Tensor]</code> <p>Predictions.</p> <code>None</code> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def loss(self, batch, preds=None):\n    \"\"\"\n    Compute loss.\n\n    Args:\n        batch (dict): Batch to compute loss on\n        preds (torch.Tensor | List[torch.Tensor]): Predictions.\n    \"\"\"\n    if not hasattr(self, \"criterion\"):\n        self.criterion = self.init_criterion()\n\n    preds = self.forward(batch[\"img\"]) if preds is None else preds\n    return self.criterion(preds, batch)\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.BaseModel.predict","title":"<code>predict(x, profile=False, visualize=False, augment=False, embed=None)</code>","text":"<p>Perform a forward pass through the network.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>The input tensor to the model.</p> required <code>profile</code> <code>bool</code> <p>Print the computation time of each layer if True, defaults to False.</p> <code>False</code> <code>visualize</code> <code>bool</code> <p>Save the feature maps of the model if True, defaults to False.</p> <code>False</code> <code>augment</code> <code>bool</code> <p>Augment image during prediction, defaults to False.</p> <code>False</code> <code>embed</code> <code>list</code> <p>A list of feature vectors/embeddings to return.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>The last output of the model.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def predict(self, x, profile=False, visualize=False, augment=False, embed=None):\n    \"\"\"\n    Perform a forward pass through the network.\n\n    Args:\n        x (torch.Tensor): The input tensor to the model.\n        profile (bool):  Print the computation time of each layer if True, defaults to False.\n        visualize (bool): Save the feature maps of the model if True, defaults to False.\n        augment (bool): Augment image during prediction, defaults to False.\n        embed (list, optional): A list of feature vectors/embeddings to return.\n\n    Returns:\n        (torch.Tensor): The last output of the model.\n    \"\"\"\n    if augment:\n        return self._predict_augment(x)\n    return self._predict_once(x, profile, visualize, embed)\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.DetectionModel","title":"<code>ultralytics.nn.tasks.DetectionModel</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>YOLOv8 detection model.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>class DetectionModel(BaseModel):\n    \"\"\"YOLOv8 detection model.\"\"\"\n\n    def __init__(self, cfg=\"yolov8n.yaml\", ch=3, nc=None, verbose=True):  # model, input channels, number of classes\n        \"\"\"Initialize the YOLOv8 detection model with the given config and parameters.\"\"\"\n        super().__init__()\n        self.yaml = cfg if isinstance(cfg, dict) else yaml_model_load(cfg)  # cfg dict\n\n        # Define model\n        ch = self.yaml[\"ch\"] = self.yaml.get(\"ch\", ch)  # input channels\n        if nc and nc != self.yaml[\"nc\"]:\n            LOGGER.info(f\"Overriding model.yaml nc={self.yaml['nc']} with nc={nc}\")\n            self.yaml[\"nc\"] = nc  # override YAML value\n        self.model, self.save = parse_model(deepcopy(self.yaml), ch=ch, verbose=verbose)  # model, savelist\n        self.names = {i: f\"{i}\" for i in range(self.yaml[\"nc\"])}  # default names dict\n        self.inplace = self.yaml.get(\"inplace\", True)\n\n        # Build strides\n        m = self.model[-1]  # Detect()\n        if isinstance(m, (Detect, Segment, Pose, OBB)):\n            s = 256  # 2x min stride\n            m.inplace = self.inplace\n            forward = lambda x: self.forward(x)[0] if isinstance(m, (Segment, Pose, OBB)) else self.forward(x)\n            m.stride = torch.tensor([s / x.shape[-2] for x in forward(torch.zeros(1, ch, s, s))])  # forward\n            self.stride = m.stride\n            m.bias_init()  # only run once\n        else:\n            self.stride = torch.Tensor([32])  # default stride for i.e. RTDETR\n\n        # Init weights, biases\n        initialize_weights(self)\n        if verbose:\n            self.info()\n            LOGGER.info(\"\")\n\n    def _predict_augment(self, x):\n        \"\"\"Perform augmentations on input image x and return augmented inference and train outputs.\"\"\"\n        img_size = x.shape[-2:]  # height, width\n        s = [1, 0.83, 0.67]  # scales\n        f = [None, 3, None]  # flips (2-ud, 3-lr)\n        y = []  # outputs\n        for si, fi in zip(s, f):\n            xi = scale_img(x.flip(fi) if fi else x, si, gs=int(self.stride.max()))\n            yi = super().predict(xi)[0]  # forward\n            yi = self._descale_pred(yi, fi, si, img_size)\n            y.append(yi)\n        y = self._clip_augmented(y)  # clip augmented tails\n        return torch.cat(y, -1), None  # augmented inference, train\n\n    @staticmethod\n    def _descale_pred(p, flips, scale, img_size, dim=1):\n        \"\"\"De-scale predictions following augmented inference (inverse operation).\"\"\"\n        p[:, :4] /= scale  # de-scale\n        x, y, wh, cls = p.split((1, 1, 2, p.shape[dim] - 4), dim)\n        if flips == 2:\n            y = img_size[0] - y  # de-flip ud\n        elif flips == 3:\n            x = img_size[1] - x  # de-flip lr\n        return torch.cat((x, y, wh, cls), dim)\n\n    def _clip_augmented(self, y):\n        \"\"\"Clip YOLO augmented inference tails.\"\"\"\n        nl = self.model[-1].nl  # number of detection layers (P3-P5)\n        g = sum(4**x for x in range(nl))  # grid points\n        e = 1  # exclude layer count\n        i = (y[0].shape[-1] // g) * sum(4**x for x in range(e))  # indices\n        y[0] = y[0][..., :-i]  # large\n        i = (y[-1].shape[-1] // g) * sum(4 ** (nl - 1 - x) for x in range(e))  # indices\n        y[-1] = y[-1][..., i:]  # small\n        return y\n\n    def init_criterion(self):\n        \"\"\"Initialize the loss criterion for the DetectionModel.\"\"\"\n        return v8DetectionLoss(self)\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.DetectionModel.__init__","title":"<code>__init__(cfg='yolov8n.yaml', ch=3, nc=None, verbose=True)</code>","text":"<p>Initialize the YOLOv8 detection model with the given config and parameters.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def __init__(self, cfg=\"yolov8n.yaml\", ch=3, nc=None, verbose=True):  # model, input channels, number of classes\n    \"\"\"Initialize the YOLOv8 detection model with the given config and parameters.\"\"\"\n    super().__init__()\n    self.yaml = cfg if isinstance(cfg, dict) else yaml_model_load(cfg)  # cfg dict\n\n    # Define model\n    ch = self.yaml[\"ch\"] = self.yaml.get(\"ch\", ch)  # input channels\n    if nc and nc != self.yaml[\"nc\"]:\n        LOGGER.info(f\"Overriding model.yaml nc={self.yaml['nc']} with nc={nc}\")\n        self.yaml[\"nc\"] = nc  # override YAML value\n    self.model, self.save = parse_model(deepcopy(self.yaml), ch=ch, verbose=verbose)  # model, savelist\n    self.names = {i: f\"{i}\" for i in range(self.yaml[\"nc\"])}  # default names dict\n    self.inplace = self.yaml.get(\"inplace\", True)\n\n    # Build strides\n    m = self.model[-1]  # Detect()\n    if isinstance(m, (Detect, Segment, Pose, OBB)):\n        s = 256  # 2x min stride\n        m.inplace = self.inplace\n        forward = lambda x: self.forward(x)[0] if isinstance(m, (Segment, Pose, OBB)) else self.forward(x)\n        m.stride = torch.tensor([s / x.shape[-2] for x in forward(torch.zeros(1, ch, s, s))])  # forward\n        self.stride = m.stride\n        m.bias_init()  # only run once\n    else:\n        self.stride = torch.Tensor([32])  # default stride for i.e. RTDETR\n\n    # Init weights, biases\n    initialize_weights(self)\n    if verbose:\n        self.info()\n        LOGGER.info(\"\")\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.DetectionModel.init_criterion","title":"<code>init_criterion()</code>","text":"<p>Initialize the loss criterion for the DetectionModel.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def init_criterion(self):\n    \"\"\"Initialize the loss criterion for the DetectionModel.\"\"\"\n    return v8DetectionLoss(self)\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.OBBModel","title":"<code>ultralytics.nn.tasks.OBBModel</code>","text":"<p>             Bases: <code>DetectionModel</code></p> <p>\"YOLOv8 Oriented Bounding Box (OBB) model.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>class OBBModel(DetectionModel):\n    \"\"\"\"YOLOv8 Oriented Bounding Box (OBB) model.\"\"\"\n\n    def __init__(self, cfg=\"yolov8n-obb.yaml\", ch=3, nc=None, verbose=True):\n        \"\"\"Initialize YOLOv8 OBB model with given config and parameters.\"\"\"\n        super().__init__(cfg=cfg, ch=ch, nc=nc, verbose=verbose)\n\n    def init_criterion(self):\n        \"\"\"Initialize the loss criterion for the model.\"\"\"\n        return v8OBBLoss(self)\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.OBBModel.__init__","title":"<code>__init__(cfg='yolov8n-obb.yaml', ch=3, nc=None, verbose=True)</code>","text":"<p>Initialize YOLOv8 OBB model with given config and parameters.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def __init__(self, cfg=\"yolov8n-obb.yaml\", ch=3, nc=None, verbose=True):\n    \"\"\"Initialize YOLOv8 OBB model with given config and parameters.\"\"\"\n    super().__init__(cfg=cfg, ch=ch, nc=nc, verbose=verbose)\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.OBBModel.init_criterion","title":"<code>init_criterion()</code>","text":"<p>Initialize the loss criterion for the model.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def init_criterion(self):\n    \"\"\"Initialize the loss criterion for the model.\"\"\"\n    return v8OBBLoss(self)\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.SegmentationModel","title":"<code>ultralytics.nn.tasks.SegmentationModel</code>","text":"<p>             Bases: <code>DetectionModel</code></p> <p>YOLOv8 segmentation model.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>class SegmentationModel(DetectionModel):\n    \"\"\"YOLOv8 segmentation model.\"\"\"\n\n    def __init__(self, cfg=\"yolov8n-seg.yaml\", ch=3, nc=None, verbose=True):\n        \"\"\"Initialize YOLOv8 segmentation model with given config and parameters.\"\"\"\n        super().__init__(cfg=cfg, ch=ch, nc=nc, verbose=verbose)\n\n    def init_criterion(self):\n        \"\"\"Initialize the loss criterion for the SegmentationModel.\"\"\"\n        return v8SegmentationLoss(self)\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.SegmentationModel.__init__","title":"<code>__init__(cfg='yolov8n-seg.yaml', ch=3, nc=None, verbose=True)</code>","text":"<p>Initialize YOLOv8 segmentation model with given config and parameters.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def __init__(self, cfg=\"yolov8n-seg.yaml\", ch=3, nc=None, verbose=True):\n    \"\"\"Initialize YOLOv8 segmentation model with given config and parameters.\"\"\"\n    super().__init__(cfg=cfg, ch=ch, nc=nc, verbose=verbose)\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.SegmentationModel.init_criterion","title":"<code>init_criterion()</code>","text":"<p>Initialize the loss criterion for the SegmentationModel.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def init_criterion(self):\n    \"\"\"Initialize the loss criterion for the SegmentationModel.\"\"\"\n    return v8SegmentationLoss(self)\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.PoseModel","title":"<code>ultralytics.nn.tasks.PoseModel</code>","text":"<p>             Bases: <code>DetectionModel</code></p> <p>YOLOv8 pose model.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>class PoseModel(DetectionModel):\n    \"\"\"YOLOv8 pose model.\"\"\"\n\n    def __init__(self, cfg=\"yolov8n-pose.yaml\", ch=3, nc=None, data_kpt_shape=(None, None), verbose=True):\n        \"\"\"Initialize YOLOv8 Pose model.\"\"\"\n        if not isinstance(cfg, dict):\n            cfg = yaml_model_load(cfg)  # load model YAML\n        if any(data_kpt_shape) and list(data_kpt_shape) != list(cfg[\"kpt_shape\"]):\n            LOGGER.info(f\"Overriding model.yaml kpt_shape={cfg['kpt_shape']} with kpt_shape={data_kpt_shape}\")\n            cfg[\"kpt_shape\"] = data_kpt_shape\n        super().__init__(cfg=cfg, ch=ch, nc=nc, verbose=verbose)\n\n    def init_criterion(self):\n        \"\"\"Initialize the loss criterion for the PoseModel.\"\"\"\n        return v8PoseLoss(self)\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.PoseModel.__init__","title":"<code>__init__(cfg='yolov8n-pose.yaml', ch=3, nc=None, data_kpt_shape=(None, None), verbose=True)</code>","text":"<p>Initialize YOLOv8 Pose model.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def __init__(self, cfg=\"yolov8n-pose.yaml\", ch=3, nc=None, data_kpt_shape=(None, None), verbose=True):\n    \"\"\"Initialize YOLOv8 Pose model.\"\"\"\n    if not isinstance(cfg, dict):\n        cfg = yaml_model_load(cfg)  # load model YAML\n    if any(data_kpt_shape) and list(data_kpt_shape) != list(cfg[\"kpt_shape\"]):\n        LOGGER.info(f\"Overriding model.yaml kpt_shape={cfg['kpt_shape']} with kpt_shape={data_kpt_shape}\")\n        cfg[\"kpt_shape\"] = data_kpt_shape\n    super().__init__(cfg=cfg, ch=ch, nc=nc, verbose=verbose)\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.PoseModel.init_criterion","title":"<code>init_criterion()</code>","text":"<p>Initialize the loss criterion for the PoseModel.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def init_criterion(self):\n    \"\"\"Initialize the loss criterion for the PoseModel.\"\"\"\n    return v8PoseLoss(self)\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.ClassificationModel","title":"<code>ultralytics.nn.tasks.ClassificationModel</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>YOLOv8 classification model.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>class ClassificationModel(BaseModel):\n    \"\"\"YOLOv8 classification model.\"\"\"\n\n    def __init__(self, cfg=\"yolov8n-cls.yaml\", ch=3, nc=None, verbose=True):\n        \"\"\"Init ClassificationModel with YAML, channels, number of classes, verbose flag.\"\"\"\n        super().__init__()\n        self._from_yaml(cfg, ch, nc, verbose)\n\n    def _from_yaml(self, cfg, ch, nc, verbose):\n        \"\"\"Set YOLOv8 model configurations and define the model architecture.\"\"\"\n        self.yaml = cfg if isinstance(cfg, dict) else yaml_model_load(cfg)  # cfg dict\n\n        # Define model\n        ch = self.yaml[\"ch\"] = self.yaml.get(\"ch\", ch)  # input channels\n        if nc and nc != self.yaml[\"nc\"]:\n            LOGGER.info(f\"Overriding model.yaml nc={self.yaml['nc']} with nc={nc}\")\n            self.yaml[\"nc\"] = nc  # override YAML value\n        elif not nc and not self.yaml.get(\"nc\", None):\n            raise ValueError(\"nc not specified. Must specify nc in model.yaml or function arguments.\")\n        self.model, self.save = parse_model(deepcopy(self.yaml), ch=ch, verbose=verbose)  # model, savelist\n        self.stride = torch.Tensor([1])  # no stride constraints\n        self.names = {i: f\"{i}\" for i in range(self.yaml[\"nc\"])}  # default names dict\n        self.info()\n\n    @staticmethod\n    def reshape_outputs(model, nc):\n        \"\"\"Update a TorchVision classification model to class count 'n' if required.\"\"\"\n        name, m = list((model.model if hasattr(model, \"model\") else model).named_children())[-1]  # last module\n        if isinstance(m, Classify):  # YOLO Classify() head\n            if m.linear.out_features != nc:\n                m.linear = nn.Linear(m.linear.in_features, nc)\n        elif isinstance(m, nn.Linear):  # ResNet, EfficientNet\n            if m.out_features != nc:\n                setattr(model, name, nn.Linear(m.in_features, nc))\n        elif isinstance(m, nn.Sequential):\n            types = [type(x) for x in m]\n            if nn.Linear in types:\n                i = types.index(nn.Linear)  # nn.Linear index\n                if m[i].out_features != nc:\n                    m[i] = nn.Linear(m[i].in_features, nc)\n            elif nn.Conv2d in types:\n                i = types.index(nn.Conv2d)  # nn.Conv2d index\n                if m[i].out_channels != nc:\n                    m[i] = nn.Conv2d(m[i].in_channels, nc, m[i].kernel_size, m[i].stride, bias=m[i].bias is not None)\n\n    def init_criterion(self):\n        \"\"\"Initialize the loss criterion for the ClassificationModel.\"\"\"\n        return v8ClassificationLoss()\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.ClassificationModel.__init__","title":"<code>__init__(cfg='yolov8n-cls.yaml', ch=3, nc=None, verbose=True)</code>","text":"<p>Init ClassificationModel with YAML, channels, number of classes, verbose flag.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def __init__(self, cfg=\"yolov8n-cls.yaml\", ch=3, nc=None, verbose=True):\n    \"\"\"Init ClassificationModel with YAML, channels, number of classes, verbose flag.\"\"\"\n    super().__init__()\n    self._from_yaml(cfg, ch, nc, verbose)\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.ClassificationModel.init_criterion","title":"<code>init_criterion()</code>","text":"<p>Initialize the loss criterion for the ClassificationModel.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def init_criterion(self):\n    \"\"\"Initialize the loss criterion for the ClassificationModel.\"\"\"\n    return v8ClassificationLoss()\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.ClassificationModel.reshape_outputs","title":"<code>reshape_outputs(model, nc)</code>  <code>staticmethod</code>","text":"<p>Update a TorchVision classification model to class count 'n' if required.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>@staticmethod\ndef reshape_outputs(model, nc):\n    \"\"\"Update a TorchVision classification model to class count 'n' if required.\"\"\"\n    name, m = list((model.model if hasattr(model, \"model\") else model).named_children())[-1]  # last module\n    if isinstance(m, Classify):  # YOLO Classify() head\n        if m.linear.out_features != nc:\n            m.linear = nn.Linear(m.linear.in_features, nc)\n    elif isinstance(m, nn.Linear):  # ResNet, EfficientNet\n        if m.out_features != nc:\n            setattr(model, name, nn.Linear(m.in_features, nc))\n    elif isinstance(m, nn.Sequential):\n        types = [type(x) for x in m]\n        if nn.Linear in types:\n            i = types.index(nn.Linear)  # nn.Linear index\n            if m[i].out_features != nc:\n                m[i] = nn.Linear(m[i].in_features, nc)\n        elif nn.Conv2d in types:\n            i = types.index(nn.Conv2d)  # nn.Conv2d index\n            if m[i].out_channels != nc:\n                m[i] = nn.Conv2d(m[i].in_channels, nc, m[i].kernel_size, m[i].stride, bias=m[i].bias is not None)\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.RTDETRDetectionModel","title":"<code>ultralytics.nn.tasks.RTDETRDetectionModel</code>","text":"<p>             Bases: <code>DetectionModel</code></p> <p>RTDETR (Real-time DEtection and Tracking using Transformers) Detection Model class.</p> <p>This class is responsible for constructing the RTDETR architecture, defining loss functions, and facilitating both the training and inference processes. RTDETR is an object detection and tracking model that extends from the DetectionModel base class.</p> <p>Attributes:</p> Name Type Description <code>cfg</code> <code>str</code> <p>The configuration file path or preset string. Default is 'rtdetr-l.yaml'.</p> <code>ch</code> <code>int</code> <p>Number of input channels. Default is 3 (RGB).</p> <code>nc</code> <code>int</code> <p>Number of classes for object detection. Default is None.</p> <code>verbose</code> <code>bool</code> <p>Specifies if summary statistics are shown during initialization. Default is True.</p> <p>Methods:</p> Name Description <code>init_criterion</code> <p>Initializes the criterion used for loss calculation.</p> <code>loss</code> <p>Computes and returns the loss during training.</p> <code>predict</code> <p>Performs a forward pass through the network and returns the output.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>class RTDETRDetectionModel(DetectionModel):\n    \"\"\"\n    RTDETR (Real-time DEtection and Tracking using Transformers) Detection Model class.\n\n    This class is responsible for constructing the RTDETR architecture, defining loss functions, and facilitating both\n    the training and inference processes. RTDETR is an object detection and tracking model that extends from the\n    DetectionModel base class.\n\n    Attributes:\n        cfg (str): The configuration file path or preset string. Default is 'rtdetr-l.yaml'.\n        ch (int): Number of input channels. Default is 3 (RGB).\n        nc (int, optional): Number of classes for object detection. Default is None.\n        verbose (bool): Specifies if summary statistics are shown during initialization. Default is True.\n\n    Methods:\n        init_criterion: Initializes the criterion used for loss calculation.\n        loss: Computes and returns the loss during training.\n        predict: Performs a forward pass through the network and returns the output.\n    \"\"\"\n\n    def __init__(self, cfg=\"rtdetr-l.yaml\", ch=3, nc=None, verbose=True):\n        \"\"\"\n        Initialize the RTDETRDetectionModel.\n\n        Args:\n            cfg (str): Configuration file name or path.\n            ch (int): Number of input channels.\n            nc (int, optional): Number of classes. Defaults to None.\n            verbose (bool, optional): Print additional information during initialization. Defaults to True.\n        \"\"\"\n        super().__init__(cfg=cfg, ch=ch, nc=nc, verbose=verbose)\n\n    def init_criterion(self):\n        \"\"\"Initialize the loss criterion for the RTDETRDetectionModel.\"\"\"\n        from ultralytics.models.utils.loss import RTDETRDetectionLoss\n\n        return RTDETRDetectionLoss(nc=self.nc, use_vfl=True)\n\n    def loss(self, batch, preds=None):\n        \"\"\"\n        Compute the loss for the given batch of data.\n\n        Args:\n            batch (dict): Dictionary containing image and label data.\n            preds (torch.Tensor, optional): Precomputed model predictions. Defaults to None.\n\n        Returns:\n            (tuple): A tuple containing the total loss and main three losses in a tensor.\n        \"\"\"\n        if not hasattr(self, \"criterion\"):\n            self.criterion = self.init_criterion()\n\n        img = batch[\"img\"]\n        # NOTE: preprocess gt_bbox and gt_labels to list.\n        bs = len(img)\n        batch_idx = batch[\"batch_idx\"]\n        gt_groups = [(batch_idx == i).sum().item() for i in range(bs)]\n        targets = {\n            \"cls\": batch[\"cls\"].to(img.device, dtype=torch.long).view(-1),\n            \"bboxes\": batch[\"bboxes\"].to(device=img.device),\n            \"batch_idx\": batch_idx.to(img.device, dtype=torch.long).view(-1),\n            \"gt_groups\": gt_groups,\n        }\n\n        preds = self.predict(img, batch=targets) if preds is None else preds\n        dec_bboxes, dec_scores, enc_bboxes, enc_scores, dn_meta = preds if self.training else preds[1]\n        if dn_meta is None:\n            dn_bboxes, dn_scores = None, None\n        else:\n            dn_bboxes, dec_bboxes = torch.split(dec_bboxes, dn_meta[\"dn_num_split\"], dim=2)\n            dn_scores, dec_scores = torch.split(dec_scores, dn_meta[\"dn_num_split\"], dim=2)\n\n        dec_bboxes = torch.cat([enc_bboxes.unsqueeze(0), dec_bboxes])  # (7, bs, 300, 4)\n        dec_scores = torch.cat([enc_scores.unsqueeze(0), dec_scores])\n\n        loss = self.criterion(\n            (dec_bboxes, dec_scores), targets, dn_bboxes=dn_bboxes, dn_scores=dn_scores, dn_meta=dn_meta\n        )\n        # NOTE: There are like 12 losses in RTDETR, backward with all losses but only show the main three losses.\n        return sum(loss.values()), torch.as_tensor(\n            [loss[k].detach() for k in [\"loss_giou\", \"loss_class\", \"loss_bbox\"]], device=img.device\n        )\n\n    def predict(self, x, profile=False, visualize=False, batch=None, augment=False, embed=None):\n        \"\"\"\n        Perform a forward pass through the model.\n\n        Args:\n            x (torch.Tensor): The input tensor.\n            profile (bool, optional): If True, profile the computation time for each layer. Defaults to False.\n            visualize (bool, optional): If True, save feature maps for visualization. Defaults to False.\n            batch (dict, optional): Ground truth data for evaluation. Defaults to None.\n            augment (bool, optional): If True, perform data augmentation during inference. Defaults to False.\n            embed (list, optional): A list of feature vectors/embeddings to return.\n\n        Returns:\n            (torch.Tensor): Model's output tensor.\n        \"\"\"\n        y, dt, embeddings = [], [], []  # outputs\n        for m in self.model[:-1]:  # except the head part\n            if m.f != -1:  # if not from previous layer\n                x = y[m.f] if isinstance(m.f, int) else [x if j == -1 else y[j] for j in m.f]  # from earlier layers\n            if profile:\n                self._profile_one_layer(m, x, dt)\n            x = m(x)  # run\n            y.append(x if m.i in self.save else None)  # save output\n            if visualize:\n                feature_visualization(x, m.type, m.i, save_dir=visualize)\n            if embed and m.i in embed:\n                embeddings.append(nn.functional.adaptive_avg_pool2d(x, (1, 1)).squeeze(-1).squeeze(-1))  # flatten\n                if m.i == max(embed):\n                    return torch.unbind(torch.cat(embeddings, 1), dim=0)\n        head = self.model[-1]\n        x = head([y[j] for j in head.f], batch)  # head inference\n        return x\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.RTDETRDetectionModel.__init__","title":"<code>__init__(cfg='rtdetr-l.yaml', ch=3, nc=None, verbose=True)</code>","text":"<p>Initialize the RTDETRDetectionModel.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>str</code> <p>Configuration file name or path.</p> <code>'rtdetr-l.yaml'</code> <code>ch</code> <code>int</code> <p>Number of input channels.</p> <code>3</code> <code>nc</code> <code>int</code> <p>Number of classes. Defaults to None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Print additional information during initialization. Defaults to True.</p> <code>True</code> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def __init__(self, cfg=\"rtdetr-l.yaml\", ch=3, nc=None, verbose=True):\n    \"\"\"\n    Initialize the RTDETRDetectionModel.\n\n    Args:\n        cfg (str): Configuration file name or path.\n        ch (int): Number of input channels.\n        nc (int, optional): Number of classes. Defaults to None.\n        verbose (bool, optional): Print additional information during initialization. Defaults to True.\n    \"\"\"\n    super().__init__(cfg=cfg, ch=ch, nc=nc, verbose=verbose)\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.RTDETRDetectionModel.init_criterion","title":"<code>init_criterion()</code>","text":"<p>Initialize the loss criterion for the RTDETRDetectionModel.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def init_criterion(self):\n    \"\"\"Initialize the loss criterion for the RTDETRDetectionModel.\"\"\"\n    from ultralytics.models.utils.loss import RTDETRDetectionLoss\n\n    return RTDETRDetectionLoss(nc=self.nc, use_vfl=True)\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.RTDETRDetectionModel.loss","title":"<code>loss(batch, preds=None)</code>","text":"<p>Compute the loss for the given batch of data.</p> <p>Parameters:</p> Name Type Description Default <code>batch</code> <code>dict</code> <p>Dictionary containing image and label data.</p> required <code>preds</code> <code>Tensor</code> <p>Precomputed model predictions. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the total loss and main three losses in a tensor.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def loss(self, batch, preds=None):\n    \"\"\"\n    Compute the loss for the given batch of data.\n\n    Args:\n        batch (dict): Dictionary containing image and label data.\n        preds (torch.Tensor, optional): Precomputed model predictions. Defaults to None.\n\n    Returns:\n        (tuple): A tuple containing the total loss and main three losses in a tensor.\n    \"\"\"\n    if not hasattr(self, \"criterion\"):\n        self.criterion = self.init_criterion()\n\n    img = batch[\"img\"]\n    # NOTE: preprocess gt_bbox and gt_labels to list.\n    bs = len(img)\n    batch_idx = batch[\"batch_idx\"]\n    gt_groups = [(batch_idx == i).sum().item() for i in range(bs)]\n    targets = {\n        \"cls\": batch[\"cls\"].to(img.device, dtype=torch.long).view(-1),\n        \"bboxes\": batch[\"bboxes\"].to(device=img.device),\n        \"batch_idx\": batch_idx.to(img.device, dtype=torch.long).view(-1),\n        \"gt_groups\": gt_groups,\n    }\n\n    preds = self.predict(img, batch=targets) if preds is None else preds\n    dec_bboxes, dec_scores, enc_bboxes, enc_scores, dn_meta = preds if self.training else preds[1]\n    if dn_meta is None:\n        dn_bboxes, dn_scores = None, None\n    else:\n        dn_bboxes, dec_bboxes = torch.split(dec_bboxes, dn_meta[\"dn_num_split\"], dim=2)\n        dn_scores, dec_scores = torch.split(dec_scores, dn_meta[\"dn_num_split\"], dim=2)\n\n    dec_bboxes = torch.cat([enc_bboxes.unsqueeze(0), dec_bboxes])  # (7, bs, 300, 4)\n    dec_scores = torch.cat([enc_scores.unsqueeze(0), dec_scores])\n\n    loss = self.criterion(\n        (dec_bboxes, dec_scores), targets, dn_bboxes=dn_bboxes, dn_scores=dn_scores, dn_meta=dn_meta\n    )\n    # NOTE: There are like 12 losses in RTDETR, backward with all losses but only show the main three losses.\n    return sum(loss.values()), torch.as_tensor(\n        [loss[k].detach() for k in [\"loss_giou\", \"loss_class\", \"loss_bbox\"]], device=img.device\n    )\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.RTDETRDetectionModel.predict","title":"<code>predict(x, profile=False, visualize=False, batch=None, augment=False, embed=None)</code>","text":"<p>Perform a forward pass through the model.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>The input tensor.</p> required <code>profile</code> <code>bool</code> <p>If True, profile the computation time for each layer. Defaults to False.</p> <code>False</code> <code>visualize</code> <code>bool</code> <p>If True, save feature maps for visualization. Defaults to False.</p> <code>False</code> <code>batch</code> <code>dict</code> <p>Ground truth data for evaluation. Defaults to None.</p> <code>None</code> <code>augment</code> <code>bool</code> <p>If True, perform data augmentation during inference. Defaults to False.</p> <code>False</code> <code>embed</code> <code>list</code> <p>A list of feature vectors/embeddings to return.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>Model's output tensor.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def predict(self, x, profile=False, visualize=False, batch=None, augment=False, embed=None):\n    \"\"\"\n    Perform a forward pass through the model.\n\n    Args:\n        x (torch.Tensor): The input tensor.\n        profile (bool, optional): If True, profile the computation time for each layer. Defaults to False.\n        visualize (bool, optional): If True, save feature maps for visualization. Defaults to False.\n        batch (dict, optional): Ground truth data for evaluation. Defaults to None.\n        augment (bool, optional): If True, perform data augmentation during inference. Defaults to False.\n        embed (list, optional): A list of feature vectors/embeddings to return.\n\n    Returns:\n        (torch.Tensor): Model's output tensor.\n    \"\"\"\n    y, dt, embeddings = [], [], []  # outputs\n    for m in self.model[:-1]:  # except the head part\n        if m.f != -1:  # if not from previous layer\n            x = y[m.f] if isinstance(m.f, int) else [x if j == -1 else y[j] for j in m.f]  # from earlier layers\n        if profile:\n            self._profile_one_layer(m, x, dt)\n        x = m(x)  # run\n        y.append(x if m.i in self.save else None)  # save output\n        if visualize:\n            feature_visualization(x, m.type, m.i, save_dir=visualize)\n        if embed and m.i in embed:\n            embeddings.append(nn.functional.adaptive_avg_pool2d(x, (1, 1)).squeeze(-1).squeeze(-1))  # flatten\n            if m.i == max(embed):\n                return torch.unbind(torch.cat(embeddings, 1), dim=0)\n    head = self.model[-1]\n    x = head([y[j] for j in head.f], batch)  # head inference\n    return x\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.Ensemble","title":"<code>ultralytics.nn.tasks.Ensemble</code>","text":"<p>             Bases: <code>ModuleList</code></p> <p>Ensemble of models.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>class Ensemble(nn.ModuleList):\n    \"\"\"Ensemble of models.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize an ensemble of models.\"\"\"\n        super().__init__()\n\n    def forward(self, x, augment=False, profile=False, visualize=False):\n        \"\"\"Function generates the YOLO network's final layer.\"\"\"\n        y = [module(x, augment, profile, visualize)[0] for module in self]\n        # y = torch.stack(y).max(0)[0]  # max ensemble\n        # y = torch.stack(y).mean(0)  # mean ensemble\n        y = torch.cat(y, 2)  # nms ensemble, y shape(B, HW, C)\n        return y, None  # inference, train output\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.Ensemble.__init__","title":"<code>__init__()</code>","text":"<p>Initialize an ensemble of models.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize an ensemble of models.\"\"\"\n    super().__init__()\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.Ensemble.forward","title":"<code>forward(x, augment=False, profile=False, visualize=False)</code>","text":"<p>Function generates the YOLO network's final layer.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def forward(self, x, augment=False, profile=False, visualize=False):\n    \"\"\"Function generates the YOLO network's final layer.\"\"\"\n    y = [module(x, augment, profile, visualize)[0] for module in self]\n    # y = torch.stack(y).max(0)[0]  # max ensemble\n    # y = torch.stack(y).mean(0)  # mean ensemble\n    y = torch.cat(y, 2)  # nms ensemble, y shape(B, HW, C)\n    return y, None  # inference, train output\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.temporary_modules","title":"<code>ultralytics.nn.tasks.temporary_modules(modules=None)</code>","text":"<p>Context manager for temporarily adding or modifying modules in Python's module cache (<code>sys.modules</code>).</p> <p>This function can be used to change the module paths during runtime. It's useful when refactoring code, where you've moved a module from one location to another, but you still want to support the old import paths for backwards compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>modules</code> <code>dict</code> <p>A dictionary mapping old module paths to new module paths.</p> <code>None</code> Example <pre><code>with temporary_modules({'old.module.path': 'new.module.path'}):\n    import old.module.path  # this will now import new.module.path\n</code></pre> Note <p>The changes are only in effect inside the context manager and are undone once the context manager exits. Be aware that directly manipulating <code>sys.modules</code> can lead to unpredictable results, especially in larger applications or libraries. Use this function with caution.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>@contextlib.contextmanager\ndef temporary_modules(modules=None):\n    \"\"\"\n    Context manager for temporarily adding or modifying modules in Python's module cache (`sys.modules`).\n\n    This function can be used to change the module paths during runtime. It's useful when refactoring code,\n    where you've moved a module from one location to another, but you still want to support the old import\n    paths for backwards compatibility.\n\n    Args:\n        modules (dict, optional): A dictionary mapping old module paths to new module paths.\n\n    Example:\n        ```python\n        with temporary_modules({'old.module.path': 'new.module.path'}):\n            import old.module.path  # this will now import new.module.path\n        ```\n\n    Note:\n        The changes are only in effect inside the context manager and are undone once the context manager exits.\n        Be aware that directly manipulating `sys.modules` can lead to unpredictable results, especially in larger\n        applications or libraries. Use this function with caution.\n    \"\"\"\n    if not modules:\n        modules = {}\n\n    import importlib\n    import sys\n\n    try:\n        # Set modules in sys.modules under their old name\n        for old, new in modules.items():\n            sys.modules[old] = importlib.import_module(new)\n\n        yield\n    finally:\n        # Remove the temporary module paths\n        for old in modules:\n            if old in sys.modules:\n                del sys.modules[old]\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.torch_safe_load","title":"<code>ultralytics.nn.tasks.torch_safe_load(weight)</code>","text":"<p>This function attempts to load a PyTorch model with the torch.load() function. If a ModuleNotFoundError is raised, it catches the error, logs a warning message, and attempts to install the missing module via the check_requirements() function. After installation, the function again attempts to load the model using torch.load().</p> <p>Parameters:</p> Name Type Description Default <code>weight</code> <code>str</code> <p>The file path of the PyTorch model.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The loaded PyTorch model.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def torch_safe_load(weight):\n    \"\"\"\n    This function attempts to load a PyTorch model with the torch.load() function. If a ModuleNotFoundError is raised,\n    it catches the error, logs a warning message, and attempts to install the missing module via the\n    check_requirements() function. After installation, the function again attempts to load the model using torch.load().\n\n    Args:\n        weight (str): The file path of the PyTorch model.\n\n    Returns:\n        (dict): The loaded PyTorch model.\n    \"\"\"\n    from ultralytics.utils.downloads import attempt_download_asset\n\n    check_suffix(file=weight, suffix=\".pt\")\n    file = attempt_download_asset(weight)  # search online if missing locally\n    try:\n        with temporary_modules(\n            {\n                \"ultralytics.yolo.utils\": \"ultralytics.utils\",\n                \"ultralytics.yolo.v8\": \"ultralytics.models.yolo\",\n                \"ultralytics.yolo.data\": \"ultralytics.data\",\n            }\n        ):  # for legacy 8.0 Classify and Pose models\n            return torch.load(file, map_location=\"cpu\"), file  # load\n\n    except ModuleNotFoundError as e:  # e.name is missing module name\n        if e.name == \"models\":\n            raise TypeError(\n                emojis(\n                    f\"ERROR \u274c\ufe0f {weight} appears to be an Ultralytics YOLOv5 model originally trained \"\n                    f\"with https://github.com/ultralytics/yolov5.\\nThis model is NOT forwards compatible with \"\n                    f\"YOLOv8 at https://github.com/ultralytics/ultralytics.\"\n                    f\"\\nRecommend fixes are to train a new model using the latest 'ultralytics' package or to \"\n                    f\"run a command with an official YOLOv8 model, i.e. 'yolo predict model=yolov8n.pt'\"\n                )\n            ) from e\n        LOGGER.warning(\n            f\"WARNING \u26a0\ufe0f {weight} appears to require '{e.name}', which is not in ultralytics requirements.\"\n            f\"\\nAutoInstall will run now for '{e.name}' but this feature will be removed in the future.\"\n            f\"\\nRecommend fixes are to train a new model using the latest 'ultralytics' package or to \"\n            f\"run a command with an official YOLOv8 model, i.e. 'yolo predict model=yolov8n.pt'\"\n        )\n        check_requirements(e.name)  # install missing module\n\n        return torch.load(file, map_location=\"cpu\"), file  # load\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.attempt_load_weights","title":"<code>ultralytics.nn.tasks.attempt_load_weights(weights, device=None, inplace=True, fuse=False)</code>","text":"<p>Loads an ensemble of models weights=[a,b,c] or a single model weights=[a] or weights=a.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def attempt_load_weights(weights, device=None, inplace=True, fuse=False):\n    \"\"\"Loads an ensemble of models weights=[a,b,c] or a single model weights=[a] or weights=a.\"\"\"\n\n    ensemble = Ensemble()\n    for w in weights if isinstance(weights, list) else [weights]:\n        ckpt, w = torch_safe_load(w)  # load ckpt\n        args = {**DEFAULT_CFG_DICT, **ckpt[\"train_args\"]} if \"train_args\" in ckpt else None  # combined args\n        model = (ckpt.get(\"ema\") or ckpt[\"model\"]).to(device).float()  # FP32 model\n\n        # Model compatibility updates\n        model.args = args  # attach args to model\n        model.pt_path = w  # attach *.pt file path to model\n        model.task = guess_model_task(model)\n        if not hasattr(model, \"stride\"):\n            model.stride = torch.tensor([32.0])\n\n        # Append\n        ensemble.append(model.fuse().eval() if fuse and hasattr(model, \"fuse\") else model.eval())  # model in eval mode\n\n    # Module updates\n    for m in ensemble.modules():\n        t = type(m)\n        if t in (nn.Hardswish, nn.LeakyReLU, nn.ReLU, nn.ReLU6, nn.SiLU, Detect, Segment, Pose, OBB):\n            m.inplace = inplace\n        elif t is nn.Upsample and not hasattr(m, \"recompute_scale_factor\"):\n            m.recompute_scale_factor = None  # torch 1.11.0 compatibility\n\n    # Return model\n    if len(ensemble) == 1:\n        return ensemble[-1]\n\n    # Return ensemble\n    LOGGER.info(f\"Ensemble created with {weights}\\n\")\n    for k in \"names\", \"nc\", \"yaml\":\n        setattr(ensemble, k, getattr(ensemble[0], k))\n    ensemble.stride = ensemble[torch.argmax(torch.tensor([m.stride.max() for m in ensemble])).int()].stride\n    assert all(ensemble[0].nc == m.nc for m in ensemble), f\"Models differ in class counts {[m.nc for m in ensemble]}\"\n    return ensemble\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.attempt_load_one_weight","title":"<code>ultralytics.nn.tasks.attempt_load_one_weight(weight, device=None, inplace=True, fuse=False)</code>","text":"<p>Loads a single model weights.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def attempt_load_one_weight(weight, device=None, inplace=True, fuse=False):\n    \"\"\"Loads a single model weights.\"\"\"\n    ckpt, weight = torch_safe_load(weight)  # load ckpt\n    args = {**DEFAULT_CFG_DICT, **(ckpt.get(\"train_args\", {}))}  # combine model and default args, preferring model args\n    model = (ckpt.get(\"ema\") or ckpt[\"model\"]).to(device).float()  # FP32 model\n\n    # Model compatibility updates\n    model.args = {k: v for k, v in args.items() if k in DEFAULT_CFG_KEYS}  # attach args to model\n    model.pt_path = weight  # attach *.pt file path to model\n    model.task = guess_model_task(model)\n    if not hasattr(model, \"stride\"):\n        model.stride = torch.tensor([32.0])\n\n    model = model.fuse().eval() if fuse and hasattr(model, \"fuse\") else model.eval()  # model in eval mode\n\n    # Module updates\n    for m in model.modules():\n        t = type(m)\n        if t in (nn.Hardswish, nn.LeakyReLU, nn.ReLU, nn.ReLU6, nn.SiLU, Detect, Segment, Pose, OBB):\n            m.inplace = inplace\n        elif t is nn.Upsample and not hasattr(m, \"recompute_scale_factor\"):\n            m.recompute_scale_factor = None  # torch 1.11.0 compatibility\n\n    # Return model and ckpt\n    return model, ckpt\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.parse_model","title":"<code>ultralytics.nn.tasks.parse_model(d, ch, verbose=True)</code>","text":"<p>Parse a YOLO model.yaml dictionary into a PyTorch model.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def parse_model(d, ch, verbose=True):  # model_dict, input_channels(3)\n    \"\"\"Parse a YOLO model.yaml dictionary into a PyTorch model.\"\"\"\n    import ast\n\n    # Args\n    max_channels = float(\"inf\")\n    nc, act, scales = (d.get(x) for x in (\"nc\", \"activation\", \"scales\"))\n    depth, width, kpt_shape = (d.get(x, 1.0) for x in (\"depth_multiple\", \"width_multiple\", \"kpt_shape\"))\n    if scales:\n        scale = d.get(\"scale\")\n        if not scale:\n            scale = tuple(scales.keys())[0]\n            LOGGER.warning(f\"WARNING \u26a0\ufe0f no model scale passed. Assuming scale='{scale}'.\")\n        depth, width, max_channels = scales[scale]\n\n    if act:\n        Conv.default_act = eval(act)  # redefine default activation, i.e. Conv.default_act = nn.SiLU()\n        if verbose:\n            LOGGER.info(f\"{colorstr('activation:')} {act}\")  # print\n\n    if verbose:\n        LOGGER.info(f\"\\n{'':&gt;3}{'from':&gt;20}{'n':&gt;3}{'params':&gt;10}  {'module':&lt;45}{'arguments':&lt;30}\")\n    ch = [ch]\n    layers, save, c2 = [], [], ch[-1]  # layers, savelist, ch out\n    for i, (f, n, m, args) in enumerate(d[\"backbone\"] + d[\"head\"]):  # from, number, module, args\n        m = getattr(torch.nn, m[3:]) if \"nn.\" in m else globals()[m]  # get module\n        for j, a in enumerate(args):\n            if isinstance(a, str):\n                with contextlib.suppress(ValueError):\n                    args[j] = locals()[a] if a in locals() else ast.literal_eval(a)\n\n        n = n_ = max(round(n * depth), 1) if n &gt; 1 else n  # depth gain\n        if m in (\n            Classify,\n            Conv,\n            ConvTranspose,\n            GhostConv,\n            Bottleneck,\n            GhostBottleneck,\n            SPP,\n            SPPF,\n            DWConv,\n            Focus,\n            BottleneckCSP,\n            C1,\n            C2,\n            C2f,\n            C3,\n            C3TR,\n            C3Ghost,\n            nn.ConvTranspose2d,\n            DWConvTranspose2d,\n            C3x,\n            RepC3,\n        ):\n            c1, c2 = ch[f], args[0]\n            if c2 != nc:  # if c2 not equal to number of classes (i.e. for Classify() output)\n                c2 = make_divisible(min(c2, max_channels) * width, 8)\n\n            args = [c1, c2, *args[1:]]\n            if m in (BottleneckCSP, C1, C2, C2f, C3, C3TR, C3Ghost, C3x, RepC3):\n                args.insert(2, n)  # number of repeats\n                n = 1\n        elif m is AIFI:\n            args = [ch[f], *args]\n        elif m in (HGStem, HGBlock):\n            c1, cm, c2 = ch[f], args[0], args[1]\n            args = [c1, cm, c2, *args[2:]]\n            if m is HGBlock:\n                args.insert(4, n)  # number of repeats\n                n = 1\n        elif m is ResNetLayer:\n            c2 = args[1] if args[3] else args[1] * 4\n        elif m is nn.BatchNorm2d:\n            args = [ch[f]]\n        elif m is Concat:\n            c2 = sum(ch[x] for x in f)\n        elif m in (Detect, Segment, Pose, OBB):\n            args.append([ch[x] for x in f])\n            if m is Segment:\n                args[2] = make_divisible(min(args[2], max_channels) * width, 8)\n        elif m is RTDETRDecoder:  # special case, channels arg must be passed in index 1\n            args.insert(1, [ch[x] for x in f])\n        else:\n            c2 = ch[f]\n\n        m_ = nn.Sequential(*(m(*args) for _ in range(n))) if n &gt; 1 else m(*args)  # module\n        t = str(m)[8:-2].replace(\"__main__.\", \"\")  # module type\n        m.np = sum(x.numel() for x in m_.parameters())  # number params\n        m_.i, m_.f, m_.type = i, f, t  # attach index, 'from' index, type\n        if verbose:\n            LOGGER.info(f\"{i:&gt;3}{str(f):&gt;20}{n_:&gt;3}{m.np:10.0f}  {t:&lt;45}{str(args):&lt;30}\")  # print\n        save.extend(x % i for x in ([f] if isinstance(f, int) else f) if x != -1)  # append to savelist\n        layers.append(m_)\n        if i == 0:\n            ch = []\n        ch.append(c2)\n    return nn.Sequential(*layers), sorted(save)\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.yaml_model_load","title":"<code>ultralytics.nn.tasks.yaml_model_load(path)</code>","text":"<p>Load a YOLOv8 model from a YAML file.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def yaml_model_load(path):\n    \"\"\"Load a YOLOv8 model from a YAML file.\"\"\"\n    import re\n\n    path = Path(path)\n    if path.stem in (f\"yolov{d}{x}6\" for x in \"nsmlx\" for d in (5, 8)):\n        new_stem = re.sub(r\"(\\d+)([nslmx])6(.+)?$\", r\"\\1\\2-p6\\3\", path.stem)\n        LOGGER.warning(f\"WARNING \u26a0\ufe0f Ultralytics YOLO P6 models now use -p6 suffix. Renaming {path.stem} to {new_stem}.\")\n        path = path.with_name(new_stem + path.suffix)\n\n    unified_path = re.sub(r\"(\\d+)([nslmx])(.+)?$\", r\"\\1\\3\", str(path))  # i.e. yolov8x.yaml -&gt; yolov8.yaml\n    yaml_file = check_yaml(unified_path, hard=False) or check_yaml(path)\n    d = yaml_load(yaml_file)  # model dict\n    d[\"scale\"] = guess_model_scale(path)\n    d[\"yaml_file\"] = str(path)\n    return d\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.guess_model_scale","title":"<code>ultralytics.nn.tasks.guess_model_scale(model_path)</code>","text":"<p>Takes a path to a YOLO model's YAML file as input and extracts the size character of the model's scale. The function uses regular expression matching to find the pattern of the model scale in the YAML file name, which is denoted by n, s, m, l, or x. The function returns the size character of the model scale as a string.</p> <p>Parameters:</p> Name Type Description Default <code>model_path</code> <code>str | Path</code> <p>The path to the YOLO model's YAML file.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The size character of the model's scale, which can be n, s, m, l, or x.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def guess_model_scale(model_path):\n    \"\"\"\n    Takes a path to a YOLO model's YAML file as input and extracts the size character of the model's scale. The function\n    uses regular expression matching to find the pattern of the model scale in the YAML file name, which is denoted by\n    n, s, m, l, or x. The function returns the size character of the model scale as a string.\n\n    Args:\n        model_path (str | Path): The path to the YOLO model's YAML file.\n\n    Returns:\n        (str): The size character of the model's scale, which can be n, s, m, l, or x.\n    \"\"\"\n    with contextlib.suppress(AttributeError):\n        import re\n\n        return re.search(r\"yolov\\d+([nslmx])\", Path(model_path).stem).group(1)  # n, s, m, l, or x\n    return \"\"\n</code></pre>"},{"location":"reference/nn/tasks/#ultralytics.nn.tasks.guess_model_task","title":"<code>ultralytics.nn.tasks.guess_model_task(model)</code>","text":"<p>Guess the task of a PyTorch model from its architecture or configuration.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Module | dict</code> <p>PyTorch model or model configuration in YAML format.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Task of the model ('detect', 'segment', 'classify', 'pose').</p> <p>Raises:</p> Type Description <code>SyntaxError</code> <p>If the task of the model could not be determined.</p> Source code in <code>ultralytics/nn/tasks.py</code> <pre><code>def guess_model_task(model):\n    \"\"\"\n    Guess the task of a PyTorch model from its architecture or configuration.\n\n    Args:\n        model (nn.Module | dict): PyTorch model or model configuration in YAML format.\n\n    Returns:\n        (str): Task of the model ('detect', 'segment', 'classify', 'pose').\n\n    Raises:\n        SyntaxError: If the task of the model could not be determined.\n    \"\"\"\n\n    def cfg2task(cfg):\n        \"\"\"Guess from YAML dictionary.\"\"\"\n        m = cfg[\"head\"][-1][-2].lower()  # output module name\n        if m in (\"classify\", \"classifier\", \"cls\", \"fc\"):\n            return \"classify\"\n        if m == \"detect\":\n            return \"detect\"\n        if m == \"segment\":\n            return \"segment\"\n        if m == \"pose\":\n            return \"pose\"\n        if m == \"obb\":\n            return \"obb\"\n\n    # Guess from model cfg\n    if isinstance(model, dict):\n        with contextlib.suppress(Exception):\n            return cfg2task(model)\n\n    # Guess from PyTorch model\n    if isinstance(model, nn.Module):  # PyTorch model\n        for x in \"model.args\", \"model.model.args\", \"model.model.model.args\":\n            with contextlib.suppress(Exception):\n                return eval(x)[\"task\"]\n        for x in \"model.yaml\", \"model.model.yaml\", \"model.model.model.yaml\":\n            with contextlib.suppress(Exception):\n                return cfg2task(eval(x))\n\n        for m in model.modules():\n            if isinstance(m, Detect):\n                return \"detect\"\n            elif isinstance(m, Segment):\n                return \"segment\"\n            elif isinstance(m, Classify):\n                return \"classify\"\n            elif isinstance(m, Pose):\n                return \"pose\"\n            elif isinstance(m, OBB):\n                return \"obb\"\n\n    # Guess from model filename\n    if isinstance(model, (str, Path)):\n        model = Path(model)\n        if \"-seg\" in model.stem or \"segment\" in model.parts:\n            return \"segment\"\n        elif \"-cls\" in model.stem or \"classify\" in model.parts:\n            return \"classify\"\n        elif \"-pose\" in model.stem or \"pose\" in model.parts:\n            return \"pose\"\n        elif \"-obb\" in model.stem or \"obb\" in model.parts:\n            return \"obb\"\n        elif \"detect\" in model.parts:\n            return \"detect\"\n\n    # Unable to determine task from model\n    LOGGER.warning(\n        \"WARNING \u26a0\ufe0f Unable to automatically guess model task, assuming 'task=detect'. \"\n        \"Explicitly define task for your model, i.e. 'task=detect', 'segment', 'classify','pose' or 'obb'.\"\n    )\n    return \"detect\"  # assume detect\n</code></pre>"},{"location":"reference/nn/modules/block/","title":"Reference for <code>ultralytics/nn/modules/block.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/nn/modules/block.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.DFL","title":"<code>ultralytics.nn.modules.block.DFL</code>","text":"<p>             Bases: <code>Module</code></p> <p>Integral module of Distribution Focal Loss (DFL).</p> <p>Proposed in Generalized Focal Loss https://ieeexplore.ieee.org/document/9792391</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>class DFL(nn.Module):\n    \"\"\"\n    Integral module of Distribution Focal Loss (DFL).\n\n    Proposed in Generalized Focal Loss https://ieeexplore.ieee.org/document/9792391\n    \"\"\"\n\n    def __init__(self, c1=16):\n        \"\"\"Initialize a convolutional layer with a given number of input channels.\"\"\"\n        super().__init__()\n        self.conv = nn.Conv2d(c1, 1, 1, bias=False).requires_grad_(False)\n        x = torch.arange(c1, dtype=torch.float)\n        self.conv.weight.data[:] = nn.Parameter(x.view(1, c1, 1, 1))\n        self.c1 = c1\n\n    def forward(self, x):\n        \"\"\"Applies a transformer layer on input tensor 'x' and returns a tensor.\"\"\"\n        b, c, a = x.shape  # batch, channels, anchors\n        return self.conv(x.view(b, 4, self.c1, a).transpose(2, 1).softmax(1)).view(b, 4, a)\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.DFL.__init__","title":"<code>__init__(c1=16)</code>","text":"<p>Initialize a convolutional layer with a given number of input channels.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def __init__(self, c1=16):\n    \"\"\"Initialize a convolutional layer with a given number of input channels.\"\"\"\n    super().__init__()\n    self.conv = nn.Conv2d(c1, 1, 1, bias=False).requires_grad_(False)\n    x = torch.arange(c1, dtype=torch.float)\n    self.conv.weight.data[:] = nn.Parameter(x.view(1, c1, 1, 1))\n    self.c1 = c1\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.DFL.forward","title":"<code>forward(x)</code>","text":"<p>Applies a transformer layer on input tensor 'x' and returns a tensor.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def forward(self, x):\n    \"\"\"Applies a transformer layer on input tensor 'x' and returns a tensor.\"\"\"\n    b, c, a = x.shape  # batch, channels, anchors\n    return self.conv(x.view(b, 4, self.c1, a).transpose(2, 1).softmax(1)).view(b, 4, a)\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.Proto","title":"<code>ultralytics.nn.modules.block.Proto</code>","text":"<p>             Bases: <code>Module</code></p> <p>YOLOv8 mask Proto module for segmentation models.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>class Proto(nn.Module):\n    \"\"\"YOLOv8 mask Proto module for segmentation models.\"\"\"\n\n    def __init__(self, c1, c_=256, c2=32):\n        \"\"\"\n        Initializes the YOLOv8 mask Proto module with specified number of protos and masks.\n\n        Input arguments are ch_in, number of protos, number of masks.\n        \"\"\"\n        super().__init__()\n        self.cv1 = Conv(c1, c_, k=3)\n        self.upsample = nn.ConvTranspose2d(c_, c_, 2, 2, 0, bias=True)  # nn.Upsample(scale_factor=2, mode='nearest')\n        self.cv2 = Conv(c_, c_, k=3)\n        self.cv3 = Conv(c_, c2)\n\n    def forward(self, x):\n        \"\"\"Performs a forward pass through layers using an upsampled input image.\"\"\"\n        return self.cv3(self.cv2(self.upsample(self.cv1(x))))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.Proto.__init__","title":"<code>__init__(c1, c_=256, c2=32)</code>","text":"<p>Initializes the YOLOv8 mask Proto module with specified number of protos and masks.</p> <p>Input arguments are ch_in, number of protos, number of masks.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def __init__(self, c1, c_=256, c2=32):\n    \"\"\"\n    Initializes the YOLOv8 mask Proto module with specified number of protos and masks.\n\n    Input arguments are ch_in, number of protos, number of masks.\n    \"\"\"\n    super().__init__()\n    self.cv1 = Conv(c1, c_, k=3)\n    self.upsample = nn.ConvTranspose2d(c_, c_, 2, 2, 0, bias=True)  # nn.Upsample(scale_factor=2, mode='nearest')\n    self.cv2 = Conv(c_, c_, k=3)\n    self.cv3 = Conv(c_, c2)\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.Proto.forward","title":"<code>forward(x)</code>","text":"<p>Performs a forward pass through layers using an upsampled input image.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def forward(self, x):\n    \"\"\"Performs a forward pass through layers using an upsampled input image.\"\"\"\n    return self.cv3(self.cv2(self.upsample(self.cv1(x))))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.HGStem","title":"<code>ultralytics.nn.modules.block.HGStem</code>","text":"<p>             Bases: <code>Module</code></p> <p>StemBlock of PPHGNetV2 with 5 convolutions and one maxpool2d.</p> <p>https://github.com/PaddlePaddle/PaddleDetection/blob/develop/ppdet/modeling/backbones/hgnet_v2.py</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>class HGStem(nn.Module):\n    \"\"\"\n    StemBlock of PPHGNetV2 with 5 convolutions and one maxpool2d.\n\n    https://github.com/PaddlePaddle/PaddleDetection/blob/develop/ppdet/modeling/backbones/hgnet_v2.py\n    \"\"\"\n\n    def __init__(self, c1, cm, c2):\n        \"\"\"Initialize the SPP layer with input/output channels and specified kernel sizes for max pooling.\"\"\"\n        super().__init__()\n        self.stem1 = Conv(c1, cm, 3, 2, act=nn.ReLU())\n        self.stem2a = Conv(cm, cm // 2, 2, 1, 0, act=nn.ReLU())\n        self.stem2b = Conv(cm // 2, cm, 2, 1, 0, act=nn.ReLU())\n        self.stem3 = Conv(cm * 2, cm, 3, 2, act=nn.ReLU())\n        self.stem4 = Conv(cm, c2, 1, 1, act=nn.ReLU())\n        self.pool = nn.MaxPool2d(kernel_size=2, stride=1, padding=0, ceil_mode=True)\n\n    def forward(self, x):\n        \"\"\"Forward pass of a PPHGNetV2 backbone layer.\"\"\"\n        x = self.stem1(x)\n        x = F.pad(x, [0, 1, 0, 1])\n        x2 = self.stem2a(x)\n        x2 = F.pad(x2, [0, 1, 0, 1])\n        x2 = self.stem2b(x2)\n        x1 = self.pool(x)\n        x = torch.cat([x1, x2], dim=1)\n        x = self.stem3(x)\n        x = self.stem4(x)\n        return x\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.HGStem.__init__","title":"<code>__init__(c1, cm, c2)</code>","text":"<p>Initialize the SPP layer with input/output channels and specified kernel sizes for max pooling.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def __init__(self, c1, cm, c2):\n    \"\"\"Initialize the SPP layer with input/output channels and specified kernel sizes for max pooling.\"\"\"\n    super().__init__()\n    self.stem1 = Conv(c1, cm, 3, 2, act=nn.ReLU())\n    self.stem2a = Conv(cm, cm // 2, 2, 1, 0, act=nn.ReLU())\n    self.stem2b = Conv(cm // 2, cm, 2, 1, 0, act=nn.ReLU())\n    self.stem3 = Conv(cm * 2, cm, 3, 2, act=nn.ReLU())\n    self.stem4 = Conv(cm, c2, 1, 1, act=nn.ReLU())\n    self.pool = nn.MaxPool2d(kernel_size=2, stride=1, padding=0, ceil_mode=True)\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.HGStem.forward","title":"<code>forward(x)</code>","text":"<p>Forward pass of a PPHGNetV2 backbone layer.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def forward(self, x):\n    \"\"\"Forward pass of a PPHGNetV2 backbone layer.\"\"\"\n    x = self.stem1(x)\n    x = F.pad(x, [0, 1, 0, 1])\n    x2 = self.stem2a(x)\n    x2 = F.pad(x2, [0, 1, 0, 1])\n    x2 = self.stem2b(x2)\n    x1 = self.pool(x)\n    x = torch.cat([x1, x2], dim=1)\n    x = self.stem3(x)\n    x = self.stem4(x)\n    return x\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.HGBlock","title":"<code>ultralytics.nn.modules.block.HGBlock</code>","text":"<p>             Bases: <code>Module</code></p> <p>HG_Block of PPHGNetV2 with 2 convolutions and LightConv.</p> <p>https://github.com/PaddlePaddle/PaddleDetection/blob/develop/ppdet/modeling/backbones/hgnet_v2.py</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>class HGBlock(nn.Module):\n    \"\"\"\n    HG_Block of PPHGNetV2 with 2 convolutions and LightConv.\n\n    https://github.com/PaddlePaddle/PaddleDetection/blob/develop/ppdet/modeling/backbones/hgnet_v2.py\n    \"\"\"\n\n    def __init__(self, c1, cm, c2, k=3, n=6, lightconv=False, shortcut=False, act=nn.ReLU()):\n        \"\"\"Initializes a CSP Bottleneck with 1 convolution using specified input and output channels.\"\"\"\n        super().__init__()\n        block = LightConv if lightconv else Conv\n        self.m = nn.ModuleList(block(c1 if i == 0 else cm, cm, k=k, act=act) for i in range(n))\n        self.sc = Conv(c1 + n * cm, c2 // 2, 1, 1, act=act)  # squeeze conv\n        self.ec = Conv(c2 // 2, c2, 1, 1, act=act)  # excitation conv\n        self.add = shortcut and c1 == c2\n\n    def forward(self, x):\n        \"\"\"Forward pass of a PPHGNetV2 backbone layer.\"\"\"\n        y = [x]\n        y.extend(m(y[-1]) for m in self.m)\n        y = self.ec(self.sc(torch.cat(y, 1)))\n        return y + x if self.add else y\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.HGBlock.__init__","title":"<code>__init__(c1, cm, c2, k=3, n=6, lightconv=False, shortcut=False, act=nn.ReLU())</code>","text":"<p>Initializes a CSP Bottleneck with 1 convolution using specified input and output channels.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def __init__(self, c1, cm, c2, k=3, n=6, lightconv=False, shortcut=False, act=nn.ReLU()):\n    \"\"\"Initializes a CSP Bottleneck with 1 convolution using specified input and output channels.\"\"\"\n    super().__init__()\n    block = LightConv if lightconv else Conv\n    self.m = nn.ModuleList(block(c1 if i == 0 else cm, cm, k=k, act=act) for i in range(n))\n    self.sc = Conv(c1 + n * cm, c2 // 2, 1, 1, act=act)  # squeeze conv\n    self.ec = Conv(c2 // 2, c2, 1, 1, act=act)  # excitation conv\n    self.add = shortcut and c1 == c2\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.HGBlock.forward","title":"<code>forward(x)</code>","text":"<p>Forward pass of a PPHGNetV2 backbone layer.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def forward(self, x):\n    \"\"\"Forward pass of a PPHGNetV2 backbone layer.\"\"\"\n    y = [x]\n    y.extend(m(y[-1]) for m in self.m)\n    y = self.ec(self.sc(torch.cat(y, 1)))\n    return y + x if self.add else y\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.SPP","title":"<code>ultralytics.nn.modules.block.SPP</code>","text":"<p>             Bases: <code>Module</code></p> <p>Spatial Pyramid Pooling (SPP) layer https://arxiv.org/abs/1406.4729.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>class SPP(nn.Module):\n    \"\"\"Spatial Pyramid Pooling (SPP) layer https://arxiv.org/abs/1406.4729.\"\"\"\n\n    def __init__(self, c1, c2, k=(5, 9, 13)):\n        \"\"\"Initialize the SPP layer with input/output channels and pooling kernel sizes.\"\"\"\n        super().__init__()\n        c_ = c1 // 2  # hidden channels\n        self.cv1 = Conv(c1, c_, 1, 1)\n        self.cv2 = Conv(c_ * (len(k) + 1), c2, 1, 1)\n        self.m = nn.ModuleList([nn.MaxPool2d(kernel_size=x, stride=1, padding=x // 2) for x in k])\n\n    def forward(self, x):\n        \"\"\"Forward pass of the SPP layer, performing spatial pyramid pooling.\"\"\"\n        x = self.cv1(x)\n        return self.cv2(torch.cat([x] + [m(x) for m in self.m], 1))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.SPP.__init__","title":"<code>__init__(c1, c2, k=(5, 9, 13))</code>","text":"<p>Initialize the SPP layer with input/output channels and pooling kernel sizes.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def __init__(self, c1, c2, k=(5, 9, 13)):\n    \"\"\"Initialize the SPP layer with input/output channels and pooling kernel sizes.\"\"\"\n    super().__init__()\n    c_ = c1 // 2  # hidden channels\n    self.cv1 = Conv(c1, c_, 1, 1)\n    self.cv2 = Conv(c_ * (len(k) + 1), c2, 1, 1)\n    self.m = nn.ModuleList([nn.MaxPool2d(kernel_size=x, stride=1, padding=x // 2) for x in k])\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.SPP.forward","title":"<code>forward(x)</code>","text":"<p>Forward pass of the SPP layer, performing spatial pyramid pooling.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def forward(self, x):\n    \"\"\"Forward pass of the SPP layer, performing spatial pyramid pooling.\"\"\"\n    x = self.cv1(x)\n    return self.cv2(torch.cat([x] + [m(x) for m in self.m], 1))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.SPPF","title":"<code>ultralytics.nn.modules.block.SPPF</code>","text":"<p>             Bases: <code>Module</code></p> <p>Spatial Pyramid Pooling - Fast (SPPF) layer for YOLOv5 by Glenn Jocher.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>class SPPF(nn.Module):\n    \"\"\"Spatial Pyramid Pooling - Fast (SPPF) layer for YOLOv5 by Glenn Jocher.\"\"\"\n\n    def __init__(self, c1, c2, k=5):\n        \"\"\"\n        Initializes the SPPF layer with given input/output channels and kernel size.\n\n        This module is equivalent to SPP(k=(5, 9, 13)).\n        \"\"\"\n        super().__init__()\n        c_ = c1 // 2  # hidden channels\n        self.cv1 = Conv(c1, c_, 1, 1)\n        self.cv2 = Conv(c_ * 4, c2, 1, 1)\n        self.m = nn.MaxPool2d(kernel_size=k, stride=1, padding=k // 2)\n\n    def forward(self, x):\n        \"\"\"Forward pass through Ghost Convolution block.\"\"\"\n        x = self.cv1(x)\n        y1 = self.m(x)\n        y2 = self.m(y1)\n        return self.cv2(torch.cat((x, y1, y2, self.m(y2)), 1))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.SPPF.__init__","title":"<code>__init__(c1, c2, k=5)</code>","text":"<p>Initializes the SPPF layer with given input/output channels and kernel size.</p> <p>This module is equivalent to SPP(k=(5, 9, 13)).</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def __init__(self, c1, c2, k=5):\n    \"\"\"\n    Initializes the SPPF layer with given input/output channels and kernel size.\n\n    This module is equivalent to SPP(k=(5, 9, 13)).\n    \"\"\"\n    super().__init__()\n    c_ = c1 // 2  # hidden channels\n    self.cv1 = Conv(c1, c_, 1, 1)\n    self.cv2 = Conv(c_ * 4, c2, 1, 1)\n    self.m = nn.MaxPool2d(kernel_size=k, stride=1, padding=k // 2)\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.SPPF.forward","title":"<code>forward(x)</code>","text":"<p>Forward pass through Ghost Convolution block.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def forward(self, x):\n    \"\"\"Forward pass through Ghost Convolution block.\"\"\"\n    x = self.cv1(x)\n    y1 = self.m(x)\n    y2 = self.m(y1)\n    return self.cv2(torch.cat((x, y1, y2, self.m(y2)), 1))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.C1","title":"<code>ultralytics.nn.modules.block.C1</code>","text":"<p>             Bases: <code>Module</code></p> <p>CSP Bottleneck with 1 convolution.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>class C1(nn.Module):\n    \"\"\"CSP Bottleneck with 1 convolution.\"\"\"\n\n    def __init__(self, c1, c2, n=1):\n        \"\"\"Initializes the CSP Bottleneck with configurations for 1 convolution with arguments ch_in, ch_out, number.\"\"\"\n        super().__init__()\n        self.cv1 = Conv(c1, c2, 1, 1)\n        self.m = nn.Sequential(*(Conv(c2, c2, 3) for _ in range(n)))\n\n    def forward(self, x):\n        \"\"\"Applies cross-convolutions to input in the C3 module.\"\"\"\n        y = self.cv1(x)\n        return self.m(y) + y\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.C1.__init__","title":"<code>__init__(c1, c2, n=1)</code>","text":"<p>Initializes the CSP Bottleneck with configurations for 1 convolution with arguments ch_in, ch_out, number.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def __init__(self, c1, c2, n=1):\n    \"\"\"Initializes the CSP Bottleneck with configurations for 1 convolution with arguments ch_in, ch_out, number.\"\"\"\n    super().__init__()\n    self.cv1 = Conv(c1, c2, 1, 1)\n    self.m = nn.Sequential(*(Conv(c2, c2, 3) for _ in range(n)))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.C1.forward","title":"<code>forward(x)</code>","text":"<p>Applies cross-convolutions to input in the C3 module.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def forward(self, x):\n    \"\"\"Applies cross-convolutions to input in the C3 module.\"\"\"\n    y = self.cv1(x)\n    return self.m(y) + y\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.C2","title":"<code>ultralytics.nn.modules.block.C2</code>","text":"<p>             Bases: <code>Module</code></p> <p>CSP Bottleneck with 2 convolutions.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>class C2(nn.Module):\n    \"\"\"CSP Bottleneck with 2 convolutions.\"\"\"\n\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        \"\"\"Initializes the CSP Bottleneck with 2 convolutions module with arguments ch_in, ch_out, number, shortcut,\n        groups, expansion.\n        \"\"\"\n        super().__init__()\n        self.c = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, 2 * self.c, 1, 1)\n        self.cv2 = Conv(2 * self.c, c2, 1)  # optional act=FReLU(c2)\n        # self.attention = ChannelAttention(2 * self.c)  # or SpatialAttention()\n        self.m = nn.Sequential(*(Bottleneck(self.c, self.c, shortcut, g, k=((3, 3), (3, 3)), e=1.0) for _ in range(n)))\n\n    def forward(self, x):\n        \"\"\"Forward pass through the CSP bottleneck with 2 convolutions.\"\"\"\n        a, b = self.cv1(x).chunk(2, 1)\n        return self.cv2(torch.cat((self.m(a), b), 1))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.C2.__init__","title":"<code>__init__(c1, c2, n=1, shortcut=True, g=1, e=0.5)</code>","text":"<p>Initializes the CSP Bottleneck with 2 convolutions module with arguments ch_in, ch_out, number, shortcut, groups, expansion.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n    \"\"\"Initializes the CSP Bottleneck with 2 convolutions module with arguments ch_in, ch_out, number, shortcut,\n    groups, expansion.\n    \"\"\"\n    super().__init__()\n    self.c = int(c2 * e)  # hidden channels\n    self.cv1 = Conv(c1, 2 * self.c, 1, 1)\n    self.cv2 = Conv(2 * self.c, c2, 1)  # optional act=FReLU(c2)\n    # self.attention = ChannelAttention(2 * self.c)  # or SpatialAttention()\n    self.m = nn.Sequential(*(Bottleneck(self.c, self.c, shortcut, g, k=((3, 3), (3, 3)), e=1.0) for _ in range(n)))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.C2.forward","title":"<code>forward(x)</code>","text":"<p>Forward pass through the CSP bottleneck with 2 convolutions.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def forward(self, x):\n    \"\"\"Forward pass through the CSP bottleneck with 2 convolutions.\"\"\"\n    a, b = self.cv1(x).chunk(2, 1)\n    return self.cv2(torch.cat((self.m(a), b), 1))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.C2f","title":"<code>ultralytics.nn.modules.block.C2f</code>","text":"<p>             Bases: <code>Module</code></p> <p>Faster Implementation of CSP Bottleneck with 2 convolutions.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>class C2f(nn.Module):\n    \"\"\"Faster Implementation of CSP Bottleneck with 2 convolutions.\"\"\"\n\n    def __init__(self, c1, c2, n=1, shortcut=False, g=1, e=0.5):\n        \"\"\"Initialize CSP bottleneck layer with two convolutions with arguments ch_in, ch_out, number, shortcut, groups,\n        expansion.\n        \"\"\"\n        super().__init__()\n        self.c = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, 2 * self.c, 1, 1)\n        self.cv2 = Conv((2 + n) * self.c, c2, 1)  # optional act=FReLU(c2)\n        self.m = nn.ModuleList(Bottleneck(self.c, self.c, shortcut, g, k=((3, 3), (3, 3)), e=1.0) for _ in range(n))\n\n    def forward(self, x):\n        \"\"\"Forward pass through C2f layer.\"\"\"\n        y = list(self.cv1(x).chunk(2, 1))\n        y.extend(m(y[-1]) for m in self.m)\n        return self.cv2(torch.cat(y, 1))\n\n    def forward_split(self, x):\n        \"\"\"Forward pass using split() instead of chunk().\"\"\"\n        y = list(self.cv1(x).split((self.c, self.c), 1))\n        y.extend(m(y[-1]) for m in self.m)\n        return self.cv2(torch.cat(y, 1))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.C2f.__init__","title":"<code>__init__(c1, c2, n=1, shortcut=False, g=1, e=0.5)</code>","text":"<p>Initialize CSP bottleneck layer with two convolutions with arguments ch_in, ch_out, number, shortcut, groups, expansion.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def __init__(self, c1, c2, n=1, shortcut=False, g=1, e=0.5):\n    \"\"\"Initialize CSP bottleneck layer with two convolutions with arguments ch_in, ch_out, number, shortcut, groups,\n    expansion.\n    \"\"\"\n    super().__init__()\n    self.c = int(c2 * e)  # hidden channels\n    self.cv1 = Conv(c1, 2 * self.c, 1, 1)\n    self.cv2 = Conv((2 + n) * self.c, c2, 1)  # optional act=FReLU(c2)\n    self.m = nn.ModuleList(Bottleneck(self.c, self.c, shortcut, g, k=((3, 3), (3, 3)), e=1.0) for _ in range(n))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.C2f.forward","title":"<code>forward(x)</code>","text":"<p>Forward pass through C2f layer.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def forward(self, x):\n    \"\"\"Forward pass through C2f layer.\"\"\"\n    y = list(self.cv1(x).chunk(2, 1))\n    y.extend(m(y[-1]) for m in self.m)\n    return self.cv2(torch.cat(y, 1))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.C2f.forward_split","title":"<code>forward_split(x)</code>","text":"<p>Forward pass using split() instead of chunk().</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def forward_split(self, x):\n    \"\"\"Forward pass using split() instead of chunk().\"\"\"\n    y = list(self.cv1(x).split((self.c, self.c), 1))\n    y.extend(m(y[-1]) for m in self.m)\n    return self.cv2(torch.cat(y, 1))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.C3","title":"<code>ultralytics.nn.modules.block.C3</code>","text":"<p>             Bases: <code>Module</code></p> <p>CSP Bottleneck with 3 convolutions.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>class C3(nn.Module):\n    \"\"\"CSP Bottleneck with 3 convolutions.\"\"\"\n\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        \"\"\"Initialize the CSP Bottleneck with given channels, number, shortcut, groups, and expansion values.\"\"\"\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, c_, 1, 1)\n        self.cv2 = Conv(c1, c_, 1, 1)\n        self.cv3 = Conv(2 * c_, c2, 1)  # optional act=FReLU(c2)\n        self.m = nn.Sequential(*(Bottleneck(c_, c_, shortcut, g, k=((1, 1), (3, 3)), e=1.0) for _ in range(n)))\n\n    def forward(self, x):\n        \"\"\"Forward pass through the CSP bottleneck with 2 convolutions.\"\"\"\n        return self.cv3(torch.cat((self.m(self.cv1(x)), self.cv2(x)), 1))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.C3.__init__","title":"<code>__init__(c1, c2, n=1, shortcut=True, g=1, e=0.5)</code>","text":"<p>Initialize the CSP Bottleneck with given channels, number, shortcut, groups, and expansion values.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n    \"\"\"Initialize the CSP Bottleneck with given channels, number, shortcut, groups, and expansion values.\"\"\"\n    super().__init__()\n    c_ = int(c2 * e)  # hidden channels\n    self.cv1 = Conv(c1, c_, 1, 1)\n    self.cv2 = Conv(c1, c_, 1, 1)\n    self.cv3 = Conv(2 * c_, c2, 1)  # optional act=FReLU(c2)\n    self.m = nn.Sequential(*(Bottleneck(c_, c_, shortcut, g, k=((1, 1), (3, 3)), e=1.0) for _ in range(n)))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.C3.forward","title":"<code>forward(x)</code>","text":"<p>Forward pass through the CSP bottleneck with 2 convolutions.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def forward(self, x):\n    \"\"\"Forward pass through the CSP bottleneck with 2 convolutions.\"\"\"\n    return self.cv3(torch.cat((self.m(self.cv1(x)), self.cv2(x)), 1))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.C3x","title":"<code>ultralytics.nn.modules.block.C3x</code>","text":"<p>             Bases: <code>C3</code></p> <p>C3 module with cross-convolutions.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>class C3x(C3):\n    \"\"\"C3 module with cross-convolutions.\"\"\"\n\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        \"\"\"Initialize C3TR instance and set default parameters.\"\"\"\n        super().__init__(c1, c2, n, shortcut, g, e)\n        self.c_ = int(c2 * e)\n        self.m = nn.Sequential(*(Bottleneck(self.c_, self.c_, shortcut, g, k=((1, 3), (3, 1)), e=1) for _ in range(n)))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.C3x.__init__","title":"<code>__init__(c1, c2, n=1, shortcut=True, g=1, e=0.5)</code>","text":"<p>Initialize C3TR instance and set default parameters.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n    \"\"\"Initialize C3TR instance and set default parameters.\"\"\"\n    super().__init__(c1, c2, n, shortcut, g, e)\n    self.c_ = int(c2 * e)\n    self.m = nn.Sequential(*(Bottleneck(self.c_, self.c_, shortcut, g, k=((1, 3), (3, 1)), e=1) for _ in range(n)))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.RepC3","title":"<code>ultralytics.nn.modules.block.RepC3</code>","text":"<p>             Bases: <code>Module</code></p> <p>Rep C3.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>class RepC3(nn.Module):\n    \"\"\"Rep C3.\"\"\"\n\n    def __init__(self, c1, c2, n=3, e=1.0):\n        \"\"\"Initialize CSP Bottleneck with a single convolution using input channels, output channels, and number.\"\"\"\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, c2, 1, 1)\n        self.cv2 = Conv(c1, c2, 1, 1)\n        self.m = nn.Sequential(*[RepConv(c_, c_) for _ in range(n)])\n        self.cv3 = Conv(c_, c2, 1, 1) if c_ != c2 else nn.Identity()\n\n    def forward(self, x):\n        \"\"\"Forward pass of RT-DETR neck layer.\"\"\"\n        return self.cv3(self.m(self.cv1(x)) + self.cv2(x))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.RepC3.__init__","title":"<code>__init__(c1, c2, n=3, e=1.0)</code>","text":"<p>Initialize CSP Bottleneck with a single convolution using input channels, output channels, and number.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def __init__(self, c1, c2, n=3, e=1.0):\n    \"\"\"Initialize CSP Bottleneck with a single convolution using input channels, output channels, and number.\"\"\"\n    super().__init__()\n    c_ = int(c2 * e)  # hidden channels\n    self.cv1 = Conv(c1, c2, 1, 1)\n    self.cv2 = Conv(c1, c2, 1, 1)\n    self.m = nn.Sequential(*[RepConv(c_, c_) for _ in range(n)])\n    self.cv3 = Conv(c_, c2, 1, 1) if c_ != c2 else nn.Identity()\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.RepC3.forward","title":"<code>forward(x)</code>","text":"<p>Forward pass of RT-DETR neck layer.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def forward(self, x):\n    \"\"\"Forward pass of RT-DETR neck layer.\"\"\"\n    return self.cv3(self.m(self.cv1(x)) + self.cv2(x))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.C3TR","title":"<code>ultralytics.nn.modules.block.C3TR</code>","text":"<p>             Bases: <code>C3</code></p> <p>C3 module with TransformerBlock().</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>class C3TR(C3):\n    \"\"\"C3 module with TransformerBlock().\"\"\"\n\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        \"\"\"Initialize C3Ghost module with GhostBottleneck().\"\"\"\n        super().__init__(c1, c2, n, shortcut, g, e)\n        c_ = int(c2 * e)\n        self.m = TransformerBlock(c_, c_, 4, n)\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.C3TR.__init__","title":"<code>__init__(c1, c2, n=1, shortcut=True, g=1, e=0.5)</code>","text":"<p>Initialize C3Ghost module with GhostBottleneck().</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n    \"\"\"Initialize C3Ghost module with GhostBottleneck().\"\"\"\n    super().__init__(c1, c2, n, shortcut, g, e)\n    c_ = int(c2 * e)\n    self.m = TransformerBlock(c_, c_, 4, n)\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.C3Ghost","title":"<code>ultralytics.nn.modules.block.C3Ghost</code>","text":"<p>             Bases: <code>C3</code></p> <p>C3 module with GhostBottleneck().</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>class C3Ghost(C3):\n    \"\"\"C3 module with GhostBottleneck().\"\"\"\n\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        \"\"\"Initialize 'SPP' module with various pooling sizes for spatial pyramid pooling.\"\"\"\n        super().__init__(c1, c2, n, shortcut, g, e)\n        c_ = int(c2 * e)  # hidden channels\n        self.m = nn.Sequential(*(GhostBottleneck(c_, c_) for _ in range(n)))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.C3Ghost.__init__","title":"<code>__init__(c1, c2, n=1, shortcut=True, g=1, e=0.5)</code>","text":"<p>Initialize 'SPP' module with various pooling sizes for spatial pyramid pooling.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n    \"\"\"Initialize 'SPP' module with various pooling sizes for spatial pyramid pooling.\"\"\"\n    super().__init__(c1, c2, n, shortcut, g, e)\n    c_ = int(c2 * e)  # hidden channels\n    self.m = nn.Sequential(*(GhostBottleneck(c_, c_) for _ in range(n)))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.GhostBottleneck","title":"<code>ultralytics.nn.modules.block.GhostBottleneck</code>","text":"<p>             Bases: <code>Module</code></p> <p>Ghost Bottleneck https://github.com/huawei-noah/ghostnet.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>class GhostBottleneck(nn.Module):\n    \"\"\"Ghost Bottleneck https://github.com/huawei-noah/ghostnet.\"\"\"\n\n    def __init__(self, c1, c2, k=3, s=1):\n        \"\"\"Initializes GhostBottleneck module with arguments ch_in, ch_out, kernel, stride.\"\"\"\n        super().__init__()\n        c_ = c2 // 2\n        self.conv = nn.Sequential(\n            GhostConv(c1, c_, 1, 1),  # pw\n            DWConv(c_, c_, k, s, act=False) if s == 2 else nn.Identity(),  # dw\n            GhostConv(c_, c2, 1, 1, act=False),  # pw-linear\n        )\n        self.shortcut = (\n            nn.Sequential(DWConv(c1, c1, k, s, act=False), Conv(c1, c2, 1, 1, act=False)) if s == 2 else nn.Identity()\n        )\n\n    def forward(self, x):\n        \"\"\"Applies skip connection and concatenation to input tensor.\"\"\"\n        return self.conv(x) + self.shortcut(x)\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.GhostBottleneck.__init__","title":"<code>__init__(c1, c2, k=3, s=1)</code>","text":"<p>Initializes GhostBottleneck module with arguments ch_in, ch_out, kernel, stride.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def __init__(self, c1, c2, k=3, s=1):\n    \"\"\"Initializes GhostBottleneck module with arguments ch_in, ch_out, kernel, stride.\"\"\"\n    super().__init__()\n    c_ = c2 // 2\n    self.conv = nn.Sequential(\n        GhostConv(c1, c_, 1, 1),  # pw\n        DWConv(c_, c_, k, s, act=False) if s == 2 else nn.Identity(),  # dw\n        GhostConv(c_, c2, 1, 1, act=False),  # pw-linear\n    )\n    self.shortcut = (\n        nn.Sequential(DWConv(c1, c1, k, s, act=False), Conv(c1, c2, 1, 1, act=False)) if s == 2 else nn.Identity()\n    )\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.GhostBottleneck.forward","title":"<code>forward(x)</code>","text":"<p>Applies skip connection and concatenation to input tensor.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def forward(self, x):\n    \"\"\"Applies skip connection and concatenation to input tensor.\"\"\"\n    return self.conv(x) + self.shortcut(x)\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.Bottleneck","title":"<code>ultralytics.nn.modules.block.Bottleneck</code>","text":"<p>             Bases: <code>Module</code></p> <p>Standard bottleneck.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>class Bottleneck(nn.Module):\n    \"\"\"Standard bottleneck.\"\"\"\n\n    def __init__(self, c1, c2, shortcut=True, g=1, k=(3, 3), e=0.5):\n        \"\"\"Initializes a bottleneck module with given input/output channels, shortcut option, group, kernels, and\n        expansion.\n        \"\"\"\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, c_, k[0], 1)\n        self.cv2 = Conv(c_, c2, k[1], 1, g=g)\n        self.add = shortcut and c1 == c2\n\n    def forward(self, x):\n        \"\"\"'forward()' applies the YOLO FPN to input data.\"\"\"\n        return x + self.cv2(self.cv1(x)) if self.add else self.cv2(self.cv1(x))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.Bottleneck.__init__","title":"<code>__init__(c1, c2, shortcut=True, g=1, k=(3, 3), e=0.5)</code>","text":"<p>Initializes a bottleneck module with given input/output channels, shortcut option, group, kernels, and expansion.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def __init__(self, c1, c2, shortcut=True, g=1, k=(3, 3), e=0.5):\n    \"\"\"Initializes a bottleneck module with given input/output channels, shortcut option, group, kernels, and\n    expansion.\n    \"\"\"\n    super().__init__()\n    c_ = int(c2 * e)  # hidden channels\n    self.cv1 = Conv(c1, c_, k[0], 1)\n    self.cv2 = Conv(c_, c2, k[1], 1, g=g)\n    self.add = shortcut and c1 == c2\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.Bottleneck.forward","title":"<code>forward(x)</code>","text":"<p>'forward()' applies the YOLO FPN to input data.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def forward(self, x):\n    \"\"\"'forward()' applies the YOLO FPN to input data.\"\"\"\n    return x + self.cv2(self.cv1(x)) if self.add else self.cv2(self.cv1(x))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.BottleneckCSP","title":"<code>ultralytics.nn.modules.block.BottleneckCSP</code>","text":"<p>             Bases: <code>Module</code></p> <p>CSP Bottleneck https://github.com/WongKinYiu/CrossStagePartialNetworks.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>class BottleneckCSP(nn.Module):\n    \"\"\"CSP Bottleneck https://github.com/WongKinYiu/CrossStagePartialNetworks.\"\"\"\n\n    def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n        \"\"\"Initializes the CSP Bottleneck given arguments for ch_in, ch_out, number, shortcut, groups, expansion.\"\"\"\n        super().__init__()\n        c_ = int(c2 * e)  # hidden channels\n        self.cv1 = Conv(c1, c_, 1, 1)\n        self.cv2 = nn.Conv2d(c1, c_, 1, 1, bias=False)\n        self.cv3 = nn.Conv2d(c_, c_, 1, 1, bias=False)\n        self.cv4 = Conv(2 * c_, c2, 1, 1)\n        self.bn = nn.BatchNorm2d(2 * c_)  # applied to cat(cv2, cv3)\n        self.act = nn.SiLU()\n        self.m = nn.Sequential(*(Bottleneck(c_, c_, shortcut, g, e=1.0) for _ in range(n)))\n\n    def forward(self, x):\n        \"\"\"Applies a CSP bottleneck with 3 convolutions.\"\"\"\n        y1 = self.cv3(self.m(self.cv1(x)))\n        y2 = self.cv2(x)\n        return self.cv4(self.act(self.bn(torch.cat((y1, y2), 1))))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.BottleneckCSP.__init__","title":"<code>__init__(c1, c2, n=1, shortcut=True, g=1, e=0.5)</code>","text":"<p>Initializes the CSP Bottleneck given arguments for ch_in, ch_out, number, shortcut, groups, expansion.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):\n    \"\"\"Initializes the CSP Bottleneck given arguments for ch_in, ch_out, number, shortcut, groups, expansion.\"\"\"\n    super().__init__()\n    c_ = int(c2 * e)  # hidden channels\n    self.cv1 = Conv(c1, c_, 1, 1)\n    self.cv2 = nn.Conv2d(c1, c_, 1, 1, bias=False)\n    self.cv3 = nn.Conv2d(c_, c_, 1, 1, bias=False)\n    self.cv4 = Conv(2 * c_, c2, 1, 1)\n    self.bn = nn.BatchNorm2d(2 * c_)  # applied to cat(cv2, cv3)\n    self.act = nn.SiLU()\n    self.m = nn.Sequential(*(Bottleneck(c_, c_, shortcut, g, e=1.0) for _ in range(n)))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.BottleneckCSP.forward","title":"<code>forward(x)</code>","text":"<p>Applies a CSP bottleneck with 3 convolutions.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def forward(self, x):\n    \"\"\"Applies a CSP bottleneck with 3 convolutions.\"\"\"\n    y1 = self.cv3(self.m(self.cv1(x)))\n    y2 = self.cv2(x)\n    return self.cv4(self.act(self.bn(torch.cat((y1, y2), 1))))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.ResNetBlock","title":"<code>ultralytics.nn.modules.block.ResNetBlock</code>","text":"<p>             Bases: <code>Module</code></p> <p>ResNet block with standard convolution layers.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>class ResNetBlock(nn.Module):\n    \"\"\"ResNet block with standard convolution layers.\"\"\"\n\n    def __init__(self, c1, c2, s=1, e=4):\n        \"\"\"Initialize convolution with given parameters.\"\"\"\n        super().__init__()\n        c3 = e * c2\n        self.cv1 = Conv(c1, c2, k=1, s=1, act=True)\n        self.cv2 = Conv(c2, c2, k=3, s=s, p=1, act=True)\n        self.cv3 = Conv(c2, c3, k=1, act=False)\n        self.shortcut = nn.Sequential(Conv(c1, c3, k=1, s=s, act=False)) if s != 1 or c1 != c3 else nn.Identity()\n\n    def forward(self, x):\n        \"\"\"Forward pass through the ResNet block.\"\"\"\n        return F.relu(self.cv3(self.cv2(self.cv1(x))) + self.shortcut(x))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.ResNetBlock.__init__","title":"<code>__init__(c1, c2, s=1, e=4)</code>","text":"<p>Initialize convolution with given parameters.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def __init__(self, c1, c2, s=1, e=4):\n    \"\"\"Initialize convolution with given parameters.\"\"\"\n    super().__init__()\n    c3 = e * c2\n    self.cv1 = Conv(c1, c2, k=1, s=1, act=True)\n    self.cv2 = Conv(c2, c2, k=3, s=s, p=1, act=True)\n    self.cv3 = Conv(c2, c3, k=1, act=False)\n    self.shortcut = nn.Sequential(Conv(c1, c3, k=1, s=s, act=False)) if s != 1 or c1 != c3 else nn.Identity()\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.ResNetBlock.forward","title":"<code>forward(x)</code>","text":"<p>Forward pass through the ResNet block.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def forward(self, x):\n    \"\"\"Forward pass through the ResNet block.\"\"\"\n    return F.relu(self.cv3(self.cv2(self.cv1(x))) + self.shortcut(x))\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.ResNetLayer","title":"<code>ultralytics.nn.modules.block.ResNetLayer</code>","text":"<p>             Bases: <code>Module</code></p> <p>ResNet layer with multiple ResNet blocks.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>class ResNetLayer(nn.Module):\n    \"\"\"ResNet layer with multiple ResNet blocks.\"\"\"\n\n    def __init__(self, c1, c2, s=1, is_first=False, n=1, e=4):\n        \"\"\"Initializes the ResNetLayer given arguments.\"\"\"\n        super().__init__()\n        self.is_first = is_first\n\n        if self.is_first:\n            self.layer = nn.Sequential(\n                Conv(c1, c2, k=7, s=2, p=3, act=True), nn.MaxPool2d(kernel_size=3, stride=2, padding=1)\n            )\n        else:\n            blocks = [ResNetBlock(c1, c2, s, e=e)]\n            blocks.extend([ResNetBlock(e * c2, c2, 1, e=e) for _ in range(n - 1)])\n            self.layer = nn.Sequential(*blocks)\n\n    def forward(self, x):\n        \"\"\"Forward pass through the ResNet layer.\"\"\"\n        return self.layer(x)\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.ResNetLayer.__init__","title":"<code>__init__(c1, c2, s=1, is_first=False, n=1, e=4)</code>","text":"<p>Initializes the ResNetLayer given arguments.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def __init__(self, c1, c2, s=1, is_first=False, n=1, e=4):\n    \"\"\"Initializes the ResNetLayer given arguments.\"\"\"\n    super().__init__()\n    self.is_first = is_first\n\n    if self.is_first:\n        self.layer = nn.Sequential(\n            Conv(c1, c2, k=7, s=2, p=3, act=True), nn.MaxPool2d(kernel_size=3, stride=2, padding=1)\n        )\n    else:\n        blocks = [ResNetBlock(c1, c2, s, e=e)]\n        blocks.extend([ResNetBlock(e * c2, c2, 1, e=e) for _ in range(n - 1)])\n        self.layer = nn.Sequential(*blocks)\n</code></pre>"},{"location":"reference/nn/modules/block/#ultralytics.nn.modules.block.ResNetLayer.forward","title":"<code>forward(x)</code>","text":"<p>Forward pass through the ResNet layer.</p> Source code in <code>ultralytics/nn/modules/block.py</code> <pre><code>def forward(self, x):\n    \"\"\"Forward pass through the ResNet layer.\"\"\"\n    return self.layer(x)\n</code></pre>"},{"location":"reference/nn/modules/conv/","title":"Reference for <code>ultralytics/nn/modules/conv.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/nn/modules/conv.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.Conv","title":"<code>ultralytics.nn.modules.conv.Conv</code>","text":"<p>             Bases: <code>Module</code></p> <p>Standard convolution with args(ch_in, ch_out, kernel, stride, padding, groups, dilation, activation).</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>class Conv(nn.Module):\n    \"\"\"Standard convolution with args(ch_in, ch_out, kernel, stride, padding, groups, dilation, activation).\"\"\"\n\n    default_act = nn.SiLU()  # default activation\n\n    def __init__(self, c1, c2, k=1, s=1, p=None, g=1, d=1, act=True):\n        \"\"\"Initialize Conv layer with given arguments including activation.\"\"\"\n        super().__init__()\n        self.conv = nn.Conv2d(c1, c2, k, s, autopad(k, p, d), groups=g, dilation=d, bias=False)\n        self.bn = nn.BatchNorm2d(c2)\n        self.act = self.default_act if act is True else act if isinstance(act, nn.Module) else nn.Identity()\n\n    def forward(self, x):\n        \"\"\"Apply convolution, batch normalization and activation to input tensor.\"\"\"\n        return self.act(self.bn(self.conv(x)))\n\n    def forward_fuse(self, x):\n        \"\"\"Perform transposed convolution of 2D data.\"\"\"\n        return self.act(self.conv(x))\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.Conv.__init__","title":"<code>__init__(c1, c2, k=1, s=1, p=None, g=1, d=1, act=True)</code>","text":"<p>Initialize Conv layer with given arguments including activation.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def __init__(self, c1, c2, k=1, s=1, p=None, g=1, d=1, act=True):\n    \"\"\"Initialize Conv layer with given arguments including activation.\"\"\"\n    super().__init__()\n    self.conv = nn.Conv2d(c1, c2, k, s, autopad(k, p, d), groups=g, dilation=d, bias=False)\n    self.bn = nn.BatchNorm2d(c2)\n    self.act = self.default_act if act is True else act if isinstance(act, nn.Module) else nn.Identity()\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.Conv.forward","title":"<code>forward(x)</code>","text":"<p>Apply convolution, batch normalization and activation to input tensor.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def forward(self, x):\n    \"\"\"Apply convolution, batch normalization and activation to input tensor.\"\"\"\n    return self.act(self.bn(self.conv(x)))\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.Conv.forward_fuse","title":"<code>forward_fuse(x)</code>","text":"<p>Perform transposed convolution of 2D data.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def forward_fuse(self, x):\n    \"\"\"Perform transposed convolution of 2D data.\"\"\"\n    return self.act(self.conv(x))\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.Conv2","title":"<code>ultralytics.nn.modules.conv.Conv2</code>","text":"<p>             Bases: <code>Conv</code></p> <p>Simplified RepConv module with Conv fusing.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>class Conv2(Conv):\n    \"\"\"Simplified RepConv module with Conv fusing.\"\"\"\n\n    def __init__(self, c1, c2, k=3, s=1, p=None, g=1, d=1, act=True):\n        \"\"\"Initialize Conv layer with given arguments including activation.\"\"\"\n        super().__init__(c1, c2, k, s, p, g=g, d=d, act=act)\n        self.cv2 = nn.Conv2d(c1, c2, 1, s, autopad(1, p, d), groups=g, dilation=d, bias=False)  # add 1x1 conv\n\n    def forward(self, x):\n        \"\"\"Apply convolution, batch normalization and activation to input tensor.\"\"\"\n        return self.act(self.bn(self.conv(x) + self.cv2(x)))\n\n    def forward_fuse(self, x):\n        \"\"\"Apply fused convolution, batch normalization and activation to input tensor.\"\"\"\n        return self.act(self.bn(self.conv(x)))\n\n    def fuse_convs(self):\n        \"\"\"Fuse parallel convolutions.\"\"\"\n        w = torch.zeros_like(self.conv.weight.data)\n        i = [x // 2 for x in w.shape[2:]]\n        w[:, :, i[0] : i[0] + 1, i[1] : i[1] + 1] = self.cv2.weight.data.clone()\n        self.conv.weight.data += w\n        self.__delattr__(\"cv2\")\n        self.forward = self.forward_fuse\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.Conv2.__init__","title":"<code>__init__(c1, c2, k=3, s=1, p=None, g=1, d=1, act=True)</code>","text":"<p>Initialize Conv layer with given arguments including activation.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def __init__(self, c1, c2, k=3, s=1, p=None, g=1, d=1, act=True):\n    \"\"\"Initialize Conv layer with given arguments including activation.\"\"\"\n    super().__init__(c1, c2, k, s, p, g=g, d=d, act=act)\n    self.cv2 = nn.Conv2d(c1, c2, 1, s, autopad(1, p, d), groups=g, dilation=d, bias=False)  # add 1x1 conv\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.Conv2.forward","title":"<code>forward(x)</code>","text":"<p>Apply convolution, batch normalization and activation to input tensor.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def forward(self, x):\n    \"\"\"Apply convolution, batch normalization and activation to input tensor.\"\"\"\n    return self.act(self.bn(self.conv(x) + self.cv2(x)))\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.Conv2.forward_fuse","title":"<code>forward_fuse(x)</code>","text":"<p>Apply fused convolution, batch normalization and activation to input tensor.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def forward_fuse(self, x):\n    \"\"\"Apply fused convolution, batch normalization and activation to input tensor.\"\"\"\n    return self.act(self.bn(self.conv(x)))\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.Conv2.fuse_convs","title":"<code>fuse_convs()</code>","text":"<p>Fuse parallel convolutions.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def fuse_convs(self):\n    \"\"\"Fuse parallel convolutions.\"\"\"\n    w = torch.zeros_like(self.conv.weight.data)\n    i = [x // 2 for x in w.shape[2:]]\n    w[:, :, i[0] : i[0] + 1, i[1] : i[1] + 1] = self.cv2.weight.data.clone()\n    self.conv.weight.data += w\n    self.__delattr__(\"cv2\")\n    self.forward = self.forward_fuse\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.LightConv","title":"<code>ultralytics.nn.modules.conv.LightConv</code>","text":"<p>             Bases: <code>Module</code></p> <p>Light convolution with args(ch_in, ch_out, kernel).</p> <p>https://github.com/PaddlePaddle/PaddleDetection/blob/develop/ppdet/modeling/backbones/hgnet_v2.py</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>class LightConv(nn.Module):\n    \"\"\"\n    Light convolution with args(ch_in, ch_out, kernel).\n\n    https://github.com/PaddlePaddle/PaddleDetection/blob/develop/ppdet/modeling/backbones/hgnet_v2.py\n    \"\"\"\n\n    def __init__(self, c1, c2, k=1, act=nn.ReLU()):\n        \"\"\"Initialize Conv layer with given arguments including activation.\"\"\"\n        super().__init__()\n        self.conv1 = Conv(c1, c2, 1, act=False)\n        self.conv2 = DWConv(c2, c2, k, act=act)\n\n    def forward(self, x):\n        \"\"\"Apply 2 convolutions to input tensor.\"\"\"\n        return self.conv2(self.conv1(x))\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.LightConv.__init__","title":"<code>__init__(c1, c2, k=1, act=nn.ReLU())</code>","text":"<p>Initialize Conv layer with given arguments including activation.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def __init__(self, c1, c2, k=1, act=nn.ReLU()):\n    \"\"\"Initialize Conv layer with given arguments including activation.\"\"\"\n    super().__init__()\n    self.conv1 = Conv(c1, c2, 1, act=False)\n    self.conv2 = DWConv(c2, c2, k, act=act)\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.LightConv.forward","title":"<code>forward(x)</code>","text":"<p>Apply 2 convolutions to input tensor.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def forward(self, x):\n    \"\"\"Apply 2 convolutions to input tensor.\"\"\"\n    return self.conv2(self.conv1(x))\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.DWConv","title":"<code>ultralytics.nn.modules.conv.DWConv</code>","text":"<p>             Bases: <code>Conv</code></p> <p>Depth-wise convolution.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>class DWConv(Conv):\n    \"\"\"Depth-wise convolution.\"\"\"\n\n    def __init__(self, c1, c2, k=1, s=1, d=1, act=True):  # ch_in, ch_out, kernel, stride, dilation, activation\n        \"\"\"Initialize Depth-wise convolution with given parameters.\"\"\"\n        super().__init__(c1, c2, k, s, g=math.gcd(c1, c2), d=d, act=act)\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.DWConv.__init__","title":"<code>__init__(c1, c2, k=1, s=1, d=1, act=True)</code>","text":"<p>Initialize Depth-wise convolution with given parameters.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def __init__(self, c1, c2, k=1, s=1, d=1, act=True):  # ch_in, ch_out, kernel, stride, dilation, activation\n    \"\"\"Initialize Depth-wise convolution with given parameters.\"\"\"\n    super().__init__(c1, c2, k, s, g=math.gcd(c1, c2), d=d, act=act)\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.DWConvTranspose2d","title":"<code>ultralytics.nn.modules.conv.DWConvTranspose2d</code>","text":"<p>             Bases: <code>ConvTranspose2d</code></p> <p>Depth-wise transpose convolution.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>class DWConvTranspose2d(nn.ConvTranspose2d):\n    \"\"\"Depth-wise transpose convolution.\"\"\"\n\n    def __init__(self, c1, c2, k=1, s=1, p1=0, p2=0):  # ch_in, ch_out, kernel, stride, padding, padding_out\n        \"\"\"Initialize DWConvTranspose2d class with given parameters.\"\"\"\n        super().__init__(c1, c2, k, s, p1, p2, groups=math.gcd(c1, c2))\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.DWConvTranspose2d.__init__","title":"<code>__init__(c1, c2, k=1, s=1, p1=0, p2=0)</code>","text":"<p>Initialize DWConvTranspose2d class with given parameters.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def __init__(self, c1, c2, k=1, s=1, p1=0, p2=0):  # ch_in, ch_out, kernel, stride, padding, padding_out\n    \"\"\"Initialize DWConvTranspose2d class with given parameters.\"\"\"\n    super().__init__(c1, c2, k, s, p1, p2, groups=math.gcd(c1, c2))\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.ConvTranspose","title":"<code>ultralytics.nn.modules.conv.ConvTranspose</code>","text":"<p>             Bases: <code>Module</code></p> <p>Convolution transpose 2d layer.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>class ConvTranspose(nn.Module):\n    \"\"\"Convolution transpose 2d layer.\"\"\"\n\n    default_act = nn.SiLU()  # default activation\n\n    def __init__(self, c1, c2, k=2, s=2, p=0, bn=True, act=True):\n        \"\"\"Initialize ConvTranspose2d layer with batch normalization and activation function.\"\"\"\n        super().__init__()\n        self.conv_transpose = nn.ConvTranspose2d(c1, c2, k, s, p, bias=not bn)\n        self.bn = nn.BatchNorm2d(c2) if bn else nn.Identity()\n        self.act = self.default_act if act is True else act if isinstance(act, nn.Module) else nn.Identity()\n\n    def forward(self, x):\n        \"\"\"Applies transposed convolutions, batch normalization and activation to input.\"\"\"\n        return self.act(self.bn(self.conv_transpose(x)))\n\n    def forward_fuse(self, x):\n        \"\"\"Applies activation and convolution transpose operation to input.\"\"\"\n        return self.act(self.conv_transpose(x))\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.ConvTranspose.__init__","title":"<code>__init__(c1, c2, k=2, s=2, p=0, bn=True, act=True)</code>","text":"<p>Initialize ConvTranspose2d layer with batch normalization and activation function.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def __init__(self, c1, c2, k=2, s=2, p=0, bn=True, act=True):\n    \"\"\"Initialize ConvTranspose2d layer with batch normalization and activation function.\"\"\"\n    super().__init__()\n    self.conv_transpose = nn.ConvTranspose2d(c1, c2, k, s, p, bias=not bn)\n    self.bn = nn.BatchNorm2d(c2) if bn else nn.Identity()\n    self.act = self.default_act if act is True else act if isinstance(act, nn.Module) else nn.Identity()\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.ConvTranspose.forward","title":"<code>forward(x)</code>","text":"<p>Applies transposed convolutions, batch normalization and activation to input.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def forward(self, x):\n    \"\"\"Applies transposed convolutions, batch normalization and activation to input.\"\"\"\n    return self.act(self.bn(self.conv_transpose(x)))\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.ConvTranspose.forward_fuse","title":"<code>forward_fuse(x)</code>","text":"<p>Applies activation and convolution transpose operation to input.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def forward_fuse(self, x):\n    \"\"\"Applies activation and convolution transpose operation to input.\"\"\"\n    return self.act(self.conv_transpose(x))\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.Focus","title":"<code>ultralytics.nn.modules.conv.Focus</code>","text":"<p>             Bases: <code>Module</code></p> <p>Focus wh information into c-space.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>class Focus(nn.Module):\n    \"\"\"Focus wh information into c-space.\"\"\"\n\n    def __init__(self, c1, c2, k=1, s=1, p=None, g=1, act=True):\n        \"\"\"Initializes Focus object with user defined channel, convolution, padding, group and activation values.\"\"\"\n        super().__init__()\n        self.conv = Conv(c1 * 4, c2, k, s, p, g, act=act)\n        # self.contract = Contract(gain=2)\n\n    def forward(self, x):\n        \"\"\"\n        Applies convolution to concatenated tensor and returns the output.\n\n        Input shape is (b,c,w,h) and output shape is (b,4c,w/2,h/2).\n        \"\"\"\n        return self.conv(torch.cat((x[..., ::2, ::2], x[..., 1::2, ::2], x[..., ::2, 1::2], x[..., 1::2, 1::2]), 1))\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.Focus.__init__","title":"<code>__init__(c1, c2, k=1, s=1, p=None, g=1, act=True)</code>","text":"<p>Initializes Focus object with user defined channel, convolution, padding, group and activation values.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def __init__(self, c1, c2, k=1, s=1, p=None, g=1, act=True):\n    \"\"\"Initializes Focus object with user defined channel, convolution, padding, group and activation values.\"\"\"\n    super().__init__()\n    self.conv = Conv(c1 * 4, c2, k, s, p, g, act=act)\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.Focus.forward","title":"<code>forward(x)</code>","text":"<p>Applies convolution to concatenated tensor and returns the output.</p> <p>Input shape is (b,c,w,h) and output shape is (b,4c,w/2,h/2).</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def forward(self, x):\n    \"\"\"\n    Applies convolution to concatenated tensor and returns the output.\n\n    Input shape is (b,c,w,h) and output shape is (b,4c,w/2,h/2).\n    \"\"\"\n    return self.conv(torch.cat((x[..., ::2, ::2], x[..., 1::2, ::2], x[..., ::2, 1::2], x[..., 1::2, 1::2]), 1))\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.GhostConv","title":"<code>ultralytics.nn.modules.conv.GhostConv</code>","text":"<p>             Bases: <code>Module</code></p> <p>Ghost Convolution https://github.com/huawei-noah/ghostnet.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>class GhostConv(nn.Module):\n    \"\"\"Ghost Convolution https://github.com/huawei-noah/ghostnet.\"\"\"\n\n    def __init__(self, c1, c2, k=1, s=1, g=1, act=True):\n        \"\"\"Initializes the GhostConv object with input channels, output channels, kernel size, stride, groups and\n        activation.\n        \"\"\"\n        super().__init__()\n        c_ = c2 // 2  # hidden channels\n        self.cv1 = Conv(c1, c_, k, s, None, g, act=act)\n        self.cv2 = Conv(c_, c_, 5, 1, None, c_, act=act)\n\n    def forward(self, x):\n        \"\"\"Forward propagation through a Ghost Bottleneck layer with skip connection.\"\"\"\n        y = self.cv1(x)\n        return torch.cat((y, self.cv2(y)), 1)\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.GhostConv.__init__","title":"<code>__init__(c1, c2, k=1, s=1, g=1, act=True)</code>","text":"<p>Initializes the GhostConv object with input channels, output channels, kernel size, stride, groups and activation.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def __init__(self, c1, c2, k=1, s=1, g=1, act=True):\n    \"\"\"Initializes the GhostConv object with input channels, output channels, kernel size, stride, groups and\n    activation.\n    \"\"\"\n    super().__init__()\n    c_ = c2 // 2  # hidden channels\n    self.cv1 = Conv(c1, c_, k, s, None, g, act=act)\n    self.cv2 = Conv(c_, c_, 5, 1, None, c_, act=act)\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.GhostConv.forward","title":"<code>forward(x)</code>","text":"<p>Forward propagation through a Ghost Bottleneck layer with skip connection.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def forward(self, x):\n    \"\"\"Forward propagation through a Ghost Bottleneck layer with skip connection.\"\"\"\n    y = self.cv1(x)\n    return torch.cat((y, self.cv2(y)), 1)\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.RepConv","title":"<code>ultralytics.nn.modules.conv.RepConv</code>","text":"<p>             Bases: <code>Module</code></p> <p>RepConv is a basic rep-style block, including training and deploy status.</p> <p>This module is used in RT-DETR. Based on https://github.com/DingXiaoH/RepVGG/blob/main/repvgg.py</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>class RepConv(nn.Module):\n    \"\"\"\n    RepConv is a basic rep-style block, including training and deploy status.\n\n    This module is used in RT-DETR.\n    Based on https://github.com/DingXiaoH/RepVGG/blob/main/repvgg.py\n    \"\"\"\n\n    default_act = nn.SiLU()  # default activation\n\n    def __init__(self, c1, c2, k=3, s=1, p=1, g=1, d=1, act=True, bn=False, deploy=False):\n        \"\"\"Initializes Light Convolution layer with inputs, outputs &amp; optional activation function.\"\"\"\n        super().__init__()\n        assert k == 3 and p == 1\n        self.g = g\n        self.c1 = c1\n        self.c2 = c2\n        self.act = self.default_act if act is True else act if isinstance(act, nn.Module) else nn.Identity()\n\n        self.bn = nn.BatchNorm2d(num_features=c1) if bn and c2 == c1 and s == 1 else None\n        self.conv1 = Conv(c1, c2, k, s, p=p, g=g, act=False)\n        self.conv2 = Conv(c1, c2, 1, s, p=(p - k // 2), g=g, act=False)\n\n    def forward_fuse(self, x):\n        \"\"\"Forward process.\"\"\"\n        return self.act(self.conv(x))\n\n    def forward(self, x):\n        \"\"\"Forward process.\"\"\"\n        id_out = 0 if self.bn is None else self.bn(x)\n        return self.act(self.conv1(x) + self.conv2(x) + id_out)\n\n    def get_equivalent_kernel_bias(self):\n        \"\"\"Returns equivalent kernel and bias by adding 3x3 kernel, 1x1 kernel and identity kernel with their biases.\"\"\"\n        kernel3x3, bias3x3 = self._fuse_bn_tensor(self.conv1)\n        kernel1x1, bias1x1 = self._fuse_bn_tensor(self.conv2)\n        kernelid, biasid = self._fuse_bn_tensor(self.bn)\n        return kernel3x3 + self._pad_1x1_to_3x3_tensor(kernel1x1) + kernelid, bias3x3 + bias1x1 + biasid\n\n    def _pad_1x1_to_3x3_tensor(self, kernel1x1):\n        \"\"\"Pads a 1x1 tensor to a 3x3 tensor.\"\"\"\n        if kernel1x1 is None:\n            return 0\n        else:\n            return torch.nn.functional.pad(kernel1x1, [1, 1, 1, 1])\n\n    def _fuse_bn_tensor(self, branch):\n        \"\"\"Generates appropriate kernels and biases for convolution by fusing branches of the neural network.\"\"\"\n        if branch is None:\n            return 0, 0\n        if isinstance(branch, Conv):\n            kernel = branch.conv.weight\n            running_mean = branch.bn.running_mean\n            running_var = branch.bn.running_var\n            gamma = branch.bn.weight\n            beta = branch.bn.bias\n            eps = branch.bn.eps\n        elif isinstance(branch, nn.BatchNorm2d):\n            if not hasattr(self, \"id_tensor\"):\n                input_dim = self.c1 // self.g\n                kernel_value = np.zeros((self.c1, input_dim, 3, 3), dtype=np.float32)\n                for i in range(self.c1):\n                    kernel_value[i, i % input_dim, 1, 1] = 1\n                self.id_tensor = torch.from_numpy(kernel_value).to(branch.weight.device)\n            kernel = self.id_tensor\n            running_mean = branch.running_mean\n            running_var = branch.running_var\n            gamma = branch.weight\n            beta = branch.bias\n            eps = branch.eps\n        std = (running_var + eps).sqrt()\n        t = (gamma / std).reshape(-1, 1, 1, 1)\n        return kernel * t, beta - running_mean * gamma / std\n\n    def fuse_convs(self):\n        \"\"\"Combines two convolution layers into a single layer and removes unused attributes from the class.\"\"\"\n        if hasattr(self, \"conv\"):\n            return\n        kernel, bias = self.get_equivalent_kernel_bias()\n        self.conv = nn.Conv2d(\n            in_channels=self.conv1.conv.in_channels,\n            out_channels=self.conv1.conv.out_channels,\n            kernel_size=self.conv1.conv.kernel_size,\n            stride=self.conv1.conv.stride,\n            padding=self.conv1.conv.padding,\n            dilation=self.conv1.conv.dilation,\n            groups=self.conv1.conv.groups,\n            bias=True,\n        ).requires_grad_(False)\n        self.conv.weight.data = kernel\n        self.conv.bias.data = bias\n        for para in self.parameters():\n            para.detach_()\n        self.__delattr__(\"conv1\")\n        self.__delattr__(\"conv2\")\n        if hasattr(self, \"nm\"):\n            self.__delattr__(\"nm\")\n        if hasattr(self, \"bn\"):\n            self.__delattr__(\"bn\")\n        if hasattr(self, \"id_tensor\"):\n            self.__delattr__(\"id_tensor\")\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.RepConv.__init__","title":"<code>__init__(c1, c2, k=3, s=1, p=1, g=1, d=1, act=True, bn=False, deploy=False)</code>","text":"<p>Initializes Light Convolution layer with inputs, outputs &amp; optional activation function.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def __init__(self, c1, c2, k=3, s=1, p=1, g=1, d=1, act=True, bn=False, deploy=False):\n    \"\"\"Initializes Light Convolution layer with inputs, outputs &amp; optional activation function.\"\"\"\n    super().__init__()\n    assert k == 3 and p == 1\n    self.g = g\n    self.c1 = c1\n    self.c2 = c2\n    self.act = self.default_act if act is True else act if isinstance(act, nn.Module) else nn.Identity()\n\n    self.bn = nn.BatchNorm2d(num_features=c1) if bn and c2 == c1 and s == 1 else None\n    self.conv1 = Conv(c1, c2, k, s, p=p, g=g, act=False)\n    self.conv2 = Conv(c1, c2, 1, s, p=(p - k // 2), g=g, act=False)\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.RepConv.forward","title":"<code>forward(x)</code>","text":"<p>Forward process.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def forward(self, x):\n    \"\"\"Forward process.\"\"\"\n    id_out = 0 if self.bn is None else self.bn(x)\n    return self.act(self.conv1(x) + self.conv2(x) + id_out)\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.RepConv.forward_fuse","title":"<code>forward_fuse(x)</code>","text":"<p>Forward process.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def forward_fuse(self, x):\n    \"\"\"Forward process.\"\"\"\n    return self.act(self.conv(x))\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.RepConv.fuse_convs","title":"<code>fuse_convs()</code>","text":"<p>Combines two convolution layers into a single layer and removes unused attributes from the class.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def fuse_convs(self):\n    \"\"\"Combines two convolution layers into a single layer and removes unused attributes from the class.\"\"\"\n    if hasattr(self, \"conv\"):\n        return\n    kernel, bias = self.get_equivalent_kernel_bias()\n    self.conv = nn.Conv2d(\n        in_channels=self.conv1.conv.in_channels,\n        out_channels=self.conv1.conv.out_channels,\n        kernel_size=self.conv1.conv.kernel_size,\n        stride=self.conv1.conv.stride,\n        padding=self.conv1.conv.padding,\n        dilation=self.conv1.conv.dilation,\n        groups=self.conv1.conv.groups,\n        bias=True,\n    ).requires_grad_(False)\n    self.conv.weight.data = kernel\n    self.conv.bias.data = bias\n    for para in self.parameters():\n        para.detach_()\n    self.__delattr__(\"conv1\")\n    self.__delattr__(\"conv2\")\n    if hasattr(self, \"nm\"):\n        self.__delattr__(\"nm\")\n    if hasattr(self, \"bn\"):\n        self.__delattr__(\"bn\")\n    if hasattr(self, \"id_tensor\"):\n        self.__delattr__(\"id_tensor\")\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.RepConv.get_equivalent_kernel_bias","title":"<code>get_equivalent_kernel_bias()</code>","text":"<p>Returns equivalent kernel and bias by adding 3x3 kernel, 1x1 kernel and identity kernel with their biases.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def get_equivalent_kernel_bias(self):\n    \"\"\"Returns equivalent kernel and bias by adding 3x3 kernel, 1x1 kernel and identity kernel with their biases.\"\"\"\n    kernel3x3, bias3x3 = self._fuse_bn_tensor(self.conv1)\n    kernel1x1, bias1x1 = self._fuse_bn_tensor(self.conv2)\n    kernelid, biasid = self._fuse_bn_tensor(self.bn)\n    return kernel3x3 + self._pad_1x1_to_3x3_tensor(kernel1x1) + kernelid, bias3x3 + bias1x1 + biasid\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.ChannelAttention","title":"<code>ultralytics.nn.modules.conv.ChannelAttention</code>","text":"<p>             Bases: <code>Module</code></p> <p>Channel-attention module https://github.com/open-mmlab/mmdetection/tree/v3.0.0rc1/configs/rtmdet.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>class ChannelAttention(nn.Module):\n    \"\"\"Channel-attention module https://github.com/open-mmlab/mmdetection/tree/v3.0.0rc1/configs/rtmdet.\"\"\"\n\n    def __init__(self, channels: int) -&gt; None:\n        \"\"\"Initializes the class and sets the basic configurations and instance variables required.\"\"\"\n        super().__init__()\n        self.pool = nn.AdaptiveAvgPool2d(1)\n        self.fc = nn.Conv2d(channels, channels, 1, 1, 0, bias=True)\n        self.act = nn.Sigmoid()\n\n    def forward(self, x: torch.Tensor) -&gt; torch.Tensor:\n        \"\"\"Applies forward pass using activation on convolutions of the input, optionally using batch normalization.\"\"\"\n        return x * self.act(self.fc(self.pool(x)))\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.ChannelAttention.__init__","title":"<code>__init__(channels)</code>","text":"<p>Initializes the class and sets the basic configurations and instance variables required.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def __init__(self, channels: int) -&gt; None:\n    \"\"\"Initializes the class and sets the basic configurations and instance variables required.\"\"\"\n    super().__init__()\n    self.pool = nn.AdaptiveAvgPool2d(1)\n    self.fc = nn.Conv2d(channels, channels, 1, 1, 0, bias=True)\n    self.act = nn.Sigmoid()\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.ChannelAttention.forward","title":"<code>forward(x)</code>","text":"<p>Applies forward pass using activation on convolutions of the input, optionally using batch normalization.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def forward(self, x: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"Applies forward pass using activation on convolutions of the input, optionally using batch normalization.\"\"\"\n    return x * self.act(self.fc(self.pool(x)))\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.SpatialAttention","title":"<code>ultralytics.nn.modules.conv.SpatialAttention</code>","text":"<p>             Bases: <code>Module</code></p> <p>Spatial-attention module.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>class SpatialAttention(nn.Module):\n    \"\"\"Spatial-attention module.\"\"\"\n\n    def __init__(self, kernel_size=7):\n        \"\"\"Initialize Spatial-attention module with kernel size argument.\"\"\"\n        super().__init__()\n        assert kernel_size in (3, 7), \"kernel size must be 3 or 7\"\n        padding = 3 if kernel_size == 7 else 1\n        self.cv1 = nn.Conv2d(2, 1, kernel_size, padding=padding, bias=False)\n        self.act = nn.Sigmoid()\n\n    def forward(self, x):\n        \"\"\"Apply channel and spatial attention on input for feature recalibration.\"\"\"\n        return x * self.act(self.cv1(torch.cat([torch.mean(x, 1, keepdim=True), torch.max(x, 1, keepdim=True)[0]], 1)))\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.SpatialAttention.__init__","title":"<code>__init__(kernel_size=7)</code>","text":"<p>Initialize Spatial-attention module with kernel size argument.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def __init__(self, kernel_size=7):\n    \"\"\"Initialize Spatial-attention module with kernel size argument.\"\"\"\n    super().__init__()\n    assert kernel_size in (3, 7), \"kernel size must be 3 or 7\"\n    padding = 3 if kernel_size == 7 else 1\n    self.cv1 = nn.Conv2d(2, 1, kernel_size, padding=padding, bias=False)\n    self.act = nn.Sigmoid()\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.SpatialAttention.forward","title":"<code>forward(x)</code>","text":"<p>Apply channel and spatial attention on input for feature recalibration.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def forward(self, x):\n    \"\"\"Apply channel and spatial attention on input for feature recalibration.\"\"\"\n    return x * self.act(self.cv1(torch.cat([torch.mean(x, 1, keepdim=True), torch.max(x, 1, keepdim=True)[0]], 1)))\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.CBAM","title":"<code>ultralytics.nn.modules.conv.CBAM</code>","text":"<p>             Bases: <code>Module</code></p> <p>Convolutional Block Attention Module.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>class CBAM(nn.Module):\n    \"\"\"Convolutional Block Attention Module.\"\"\"\n\n    def __init__(self, c1, kernel_size=7):\n        \"\"\"Initialize CBAM with given input channel (c1) and kernel size.\"\"\"\n        super().__init__()\n        self.channel_attention = ChannelAttention(c1)\n        self.spatial_attention = SpatialAttention(kernel_size)\n\n    def forward(self, x):\n        \"\"\"Applies the forward pass through C1 module.\"\"\"\n        return self.spatial_attention(self.channel_attention(x))\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.CBAM.__init__","title":"<code>__init__(c1, kernel_size=7)</code>","text":"<p>Initialize CBAM with given input channel (c1) and kernel size.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def __init__(self, c1, kernel_size=7):\n    \"\"\"Initialize CBAM with given input channel (c1) and kernel size.\"\"\"\n    super().__init__()\n    self.channel_attention = ChannelAttention(c1)\n    self.spatial_attention = SpatialAttention(kernel_size)\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.CBAM.forward","title":"<code>forward(x)</code>","text":"<p>Applies the forward pass through C1 module.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def forward(self, x):\n    \"\"\"Applies the forward pass through C1 module.\"\"\"\n    return self.spatial_attention(self.channel_attention(x))\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.Concat","title":"<code>ultralytics.nn.modules.conv.Concat</code>","text":"<p>             Bases: <code>Module</code></p> <p>Concatenate a list of tensors along dimension.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>class Concat(nn.Module):\n    \"\"\"Concatenate a list of tensors along dimension.\"\"\"\n\n    def __init__(self, dimension=1):\n        \"\"\"Concatenates a list of tensors along a specified dimension.\"\"\"\n        super().__init__()\n        self.d = dimension\n\n    def forward(self, x):\n        \"\"\"Forward pass for the YOLOv8 mask Proto module.\"\"\"\n        return torch.cat(x, self.d)\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.Concat.__init__","title":"<code>__init__(dimension=1)</code>","text":"<p>Concatenates a list of tensors along a specified dimension.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def __init__(self, dimension=1):\n    \"\"\"Concatenates a list of tensors along a specified dimension.\"\"\"\n    super().__init__()\n    self.d = dimension\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.Concat.forward","title":"<code>forward(x)</code>","text":"<p>Forward pass for the YOLOv8 mask Proto module.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def forward(self, x):\n    \"\"\"Forward pass for the YOLOv8 mask Proto module.\"\"\"\n    return torch.cat(x, self.d)\n</code></pre>"},{"location":"reference/nn/modules/conv/#ultralytics.nn.modules.conv.autopad","title":"<code>ultralytics.nn.modules.conv.autopad(k, p=None, d=1)</code>","text":"<p>Pad to 'same' shape outputs.</p> Source code in <code>ultralytics/nn/modules/conv.py</code> <pre><code>def autopad(k, p=None, d=1):  # kernel, padding, dilation\n    \"\"\"Pad to 'same' shape outputs.\"\"\"\n    if d &gt; 1:\n        k = d * (k - 1) + 1 if isinstance(k, int) else [d * (x - 1) + 1 for x in k]  # actual kernel-size\n    if p is None:\n        p = k // 2 if isinstance(k, int) else [x // 2 for x in k]  # auto-pad\n    return p\n</code></pre>"},{"location":"reference/nn/modules/head/","title":"Reference for <code>ultralytics/nn/modules/head.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/nn/modules/head.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/nn/modules/head/#ultralytics.nn.modules.head.Detect","title":"<code>ultralytics.nn.modules.head.Detect</code>","text":"<p>             Bases: <code>Module</code></p> <p>YOLOv8 Detect head for detection models.</p> Source code in <code>ultralytics/nn/modules/head.py</code> <pre><code>class Detect(nn.Module):\n    \"\"\"YOLOv8 Detect head for detection models.\"\"\"\n\n    dynamic = False  # force grid reconstruction\n    export = False  # export mode\n    shape = None\n    anchors = torch.empty(0)  # init\n    strides = torch.empty(0)  # init\n\n    def __init__(self, nc=80, ch=()):\n        \"\"\"Initializes the YOLOv8 detection layer with specified number of classes and channels.\"\"\"\n        super().__init__()\n        self.nc = nc  # number of classes\n        self.nl = len(ch)  # number of detection layers\n        self.reg_max = 16  # DFL channels (ch[0] // 16 to scale 4/8/12/16/20 for n/s/m/l/x)\n        self.no = nc + self.reg_max * 4  # number of outputs per anchor\n        self.stride = torch.zeros(self.nl)  # strides computed during build\n        c2, c3 = max((16, ch[0] // 4, self.reg_max * 4)), max(ch[0], min(self.nc, 100))  # channels\n        self.cv2 = nn.ModuleList(\n            nn.Sequential(Conv(x, c2, 3), Conv(c2, c2, 3), nn.Conv2d(c2, 4 * self.reg_max, 1)) for x in ch\n        )\n        self.cv3 = nn.ModuleList(nn.Sequential(Conv(x, c3, 3), Conv(c3, c3, 3), nn.Conv2d(c3, self.nc, 1)) for x in ch)\n        self.dfl = DFL(self.reg_max) if self.reg_max &gt; 1 else nn.Identity()\n\n    def forward(self, x):\n        \"\"\"Concatenates and returns predicted bounding boxes and class probabilities.\"\"\"\n        for i in range(self.nl):\n            x[i] = torch.cat((self.cv2[i](x[i]), self.cv3[i](x[i])), 1)\n        if self.training:  # Training path\n            return x\n\n        # Inference path\n        shape = x[0].shape  # BCHW\n        x_cat = torch.cat([xi.view(shape[0], self.no, -1) for xi in x], 2)\n        if self.dynamic or self.shape != shape:\n            self.anchors, self.strides = (x.transpose(0, 1) for x in make_anchors(x, self.stride, 0.5))\n            self.shape = shape\n\n        if self.export and self.format in (\"saved_model\", \"pb\", \"tflite\", \"edgetpu\", \"tfjs\"):  # avoid TF FlexSplitV ops\n            box = x_cat[:, : self.reg_max * 4]\n            cls = x_cat[:, self.reg_max * 4 :]\n        else:\n            box, cls = x_cat.split((self.reg_max * 4, self.nc), 1)\n        dbox = self.decode_bboxes(box)\n\n        if self.export and self.format in (\"tflite\", \"edgetpu\"):\n            # Precompute normalization factor to increase numerical stability\n            # See https://github.com/ultralytics/ultralytics/issues/7371\n            img_h = shape[2]\n            img_w = shape[3]\n            img_size = torch.tensor([img_w, img_h, img_w, img_h], device=box.device).reshape(1, 4, 1)\n            norm = self.strides / (self.stride[0] * img_size)\n            dbox = dist2bbox(self.dfl(box) * norm, self.anchors.unsqueeze(0) * norm[:, :2], xywh=True, dim=1)\n\n        y = torch.cat((dbox, cls.sigmoid()), 1)\n        return y if self.export else (y, x)\n\n    def bias_init(self):\n        \"\"\"Initialize Detect() biases, WARNING: requires stride availability.\"\"\"\n        m = self  # self.model[-1]  # Detect() module\n        # cf = torch.bincount(torch.tensor(np.concatenate(dataset.labels, 0)[:, 0]).long(), minlength=nc) + 1\n        # ncf = math.log(0.6 / (m.nc - 0.999999)) if cf is None else torch.log(cf / cf.sum())  # nominal class frequency\n        for a, b, s in zip(m.cv2, m.cv3, m.stride):  # from\n            a[-1].bias.data[:] = 1.0  # box\n            b[-1].bias.data[: m.nc] = math.log(5 / m.nc / (640 / s) ** 2)  # cls (.01 objects, 80 classes, 640 img)\n\n    def decode_bboxes(self, bboxes):\n        \"\"\"Decode bounding boxes.\"\"\"\n        return dist2bbox(self.dfl(bboxes), self.anchors.unsqueeze(0), xywh=True, dim=1) * self.strides\n</code></pre>"},{"location":"reference/nn/modules/head/#ultralytics.nn.modules.head.Detect.__init__","title":"<code>__init__(nc=80, ch=())</code>","text":"<p>Initializes the YOLOv8 detection layer with specified number of classes and channels.</p> Source code in <code>ultralytics/nn/modules/head.py</code> <pre><code>def __init__(self, nc=80, ch=()):\n    \"\"\"Initializes the YOLOv8 detection layer with specified number of classes and channels.\"\"\"\n    super().__init__()\n    self.nc = nc  # number of classes\n    self.nl = len(ch)  # number of detection layers\n    self.reg_max = 16  # DFL channels (ch[0] // 16 to scale 4/8/12/16/20 for n/s/m/l/x)\n    self.no = nc + self.reg_max * 4  # number of outputs per anchor\n    self.stride = torch.zeros(self.nl)  # strides computed during build\n    c2, c3 = max((16, ch[0] // 4, self.reg_max * 4)), max(ch[0], min(self.nc, 100))  # channels\n    self.cv2 = nn.ModuleList(\n        nn.Sequential(Conv(x, c2, 3), Conv(c2, c2, 3), nn.Conv2d(c2, 4 * self.reg_max, 1)) for x in ch\n    )\n    self.cv3 = nn.ModuleList(nn.Sequential(Conv(x, c3, 3), Conv(c3, c3, 3), nn.Conv2d(c3, self.nc, 1)) for x in ch)\n    self.dfl = DFL(self.reg_max) if self.reg_max &gt; 1 else nn.Identity()\n</code></pre>"},{"location":"reference/nn/modules/head/#ultralytics.nn.modules.head.Detect.bias_init","title":"<code>bias_init()</code>","text":"<p>Initialize Detect() biases, WARNING: requires stride availability.</p> Source code in <code>ultralytics/nn/modules/head.py</code> <pre><code>def bias_init(self):\n    \"\"\"Initialize Detect() biases, WARNING: requires stride availability.\"\"\"\n    m = self  # self.model[-1]  # Detect() module\n    # cf = torch.bincount(torch.tensor(np.concatenate(dataset.labels, 0)[:, 0]).long(), minlength=nc) + 1\n    # ncf = math.log(0.6 / (m.nc - 0.999999)) if cf is None else torch.log(cf / cf.sum())  # nominal class frequency\n    for a, b, s in zip(m.cv2, m.cv3, m.stride):  # from\n        a[-1].bias.data[:] = 1.0  # box\n        b[-1].bias.data[: m.nc] = math.log(5 / m.nc / (640 / s) ** 2)  # cls (.01 objects, 80 classes, 640 img)\n</code></pre>"},{"location":"reference/nn/modules/head/#ultralytics.nn.modules.head.Detect.decode_bboxes","title":"<code>decode_bboxes(bboxes)</code>","text":"<p>Decode bounding boxes.</p> Source code in <code>ultralytics/nn/modules/head.py</code> <pre><code>def decode_bboxes(self, bboxes):\n    \"\"\"Decode bounding boxes.\"\"\"\n    return dist2bbox(self.dfl(bboxes), self.anchors.unsqueeze(0), xywh=True, dim=1) * self.strides\n</code></pre>"},{"location":"reference/nn/modules/head/#ultralytics.nn.modules.head.Detect.forward","title":"<code>forward(x)</code>","text":"<p>Concatenates and returns predicted bounding boxes and class probabilities.</p> Source code in <code>ultralytics/nn/modules/head.py</code> <pre><code>def forward(self, x):\n    \"\"\"Concatenates and returns predicted bounding boxes and class probabilities.\"\"\"\n    for i in range(self.nl):\n        x[i] = torch.cat((self.cv2[i](x[i]), self.cv3[i](x[i])), 1)\n    if self.training:  # Training path\n        return x\n\n    # Inference path\n    shape = x[0].shape  # BCHW\n    x_cat = torch.cat([xi.view(shape[0], self.no, -1) for xi in x], 2)\n    if self.dynamic or self.shape != shape:\n        self.anchors, self.strides = (x.transpose(0, 1) for x in make_anchors(x, self.stride, 0.5))\n        self.shape = shape\n\n    if self.export and self.format in (\"saved_model\", \"pb\", \"tflite\", \"edgetpu\", \"tfjs\"):  # avoid TF FlexSplitV ops\n        box = x_cat[:, : self.reg_max * 4]\n        cls = x_cat[:, self.reg_max * 4 :]\n    else:\n        box, cls = x_cat.split((self.reg_max * 4, self.nc), 1)\n    dbox = self.decode_bboxes(box)\n\n    if self.export and self.format in (\"tflite\", \"edgetpu\"):\n        # Precompute normalization factor to increase numerical stability\n        # See https://github.com/ultralytics/ultralytics/issues/7371\n        img_h = shape[2]\n        img_w = shape[3]\n        img_size = torch.tensor([img_w, img_h, img_w, img_h], device=box.device).reshape(1, 4, 1)\n        norm = self.strides / (self.stride[0] * img_size)\n        dbox = dist2bbox(self.dfl(box) * norm, self.anchors.unsqueeze(0) * norm[:, :2], xywh=True, dim=1)\n\n    y = torch.cat((dbox, cls.sigmoid()), 1)\n    return y if self.export else (y, x)\n</code></pre>"},{"location":"reference/nn/modules/head/#ultralytics.nn.modules.head.Segment","title":"<code>ultralytics.nn.modules.head.Segment</code>","text":"<p>             Bases: <code>Detect</code></p> <p>YOLOv8 Segment head for segmentation models.</p> Source code in <code>ultralytics/nn/modules/head.py</code> <pre><code>class Segment(Detect):\n    \"\"\"YOLOv8 Segment head for segmentation models.\"\"\"\n\n    def __init__(self, nc=80, nm=32, npr=256, ch=()):\n        \"\"\"Initialize the YOLO model attributes such as the number of masks, prototypes, and the convolution layers.\"\"\"\n        super().__init__(nc, ch)\n        self.nm = nm  # number of masks\n        self.npr = npr  # number of protos\n        self.proto = Proto(ch[0], self.npr, self.nm)  # protos\n        self.detect = Detect.forward\n\n        c4 = max(ch[0] // 4, self.nm)\n        self.cv4 = nn.ModuleList(nn.Sequential(Conv(x, c4, 3), Conv(c4, c4, 3), nn.Conv2d(c4, self.nm, 1)) for x in ch)\n\n    def forward(self, x):\n        \"\"\"Return model outputs and mask coefficients if training, otherwise return outputs and mask coefficients.\"\"\"\n        p = self.proto(x[0])  # mask protos\n        bs = p.shape[0]  # batch size\n\n        mc = torch.cat([self.cv4[i](x[i]).view(bs, self.nm, -1) for i in range(self.nl)], 2)  # mask coefficients\n        x = self.detect(self, x)\n        if self.training:\n            return x, mc, p\n        return (torch.cat([x, mc], 1), p) if self.export else (torch.cat([x[0], mc], 1), (x[1], mc, p))\n</code></pre>"},{"location":"reference/nn/modules/head/#ultralytics.nn.modules.head.Segment.__init__","title":"<code>__init__(nc=80, nm=32, npr=256, ch=())</code>","text":"<p>Initialize the YOLO model attributes such as the number of masks, prototypes, and the convolution layers.</p> Source code in <code>ultralytics/nn/modules/head.py</code> <pre><code>def __init__(self, nc=80, nm=32, npr=256, ch=()):\n    \"\"\"Initialize the YOLO model attributes such as the number of masks, prototypes, and the convolution layers.\"\"\"\n    super().__init__(nc, ch)\n    self.nm = nm  # number of masks\n    self.npr = npr  # number of protos\n    self.proto = Proto(ch[0], self.npr, self.nm)  # protos\n    self.detect = Detect.forward\n\n    c4 = max(ch[0] // 4, self.nm)\n    self.cv4 = nn.ModuleList(nn.Sequential(Conv(x, c4, 3), Conv(c4, c4, 3), nn.Conv2d(c4, self.nm, 1)) for x in ch)\n</code></pre>"},{"location":"reference/nn/modules/head/#ultralytics.nn.modules.head.Segment.forward","title":"<code>forward(x)</code>","text":"<p>Return model outputs and mask coefficients if training, otherwise return outputs and mask coefficients.</p> Source code in <code>ultralytics/nn/modules/head.py</code> <pre><code>def forward(self, x):\n    \"\"\"Return model outputs and mask coefficients if training, otherwise return outputs and mask coefficients.\"\"\"\n    p = self.proto(x[0])  # mask protos\n    bs = p.shape[0]  # batch size\n\n    mc = torch.cat([self.cv4[i](x[i]).view(bs, self.nm, -1) for i in range(self.nl)], 2)  # mask coefficients\n    x = self.detect(self, x)\n    if self.training:\n        return x, mc, p\n    return (torch.cat([x, mc], 1), p) if self.export else (torch.cat([x[0], mc], 1), (x[1], mc, p))\n</code></pre>"},{"location":"reference/nn/modules/head/#ultralytics.nn.modules.head.OBB","title":"<code>ultralytics.nn.modules.head.OBB</code>","text":"<p>             Bases: <code>Detect</code></p> <p>YOLOv8 OBB detection head for detection with rotation models.</p> Source code in <code>ultralytics/nn/modules/head.py</code> <pre><code>class OBB(Detect):\n    \"\"\"YOLOv8 OBB detection head for detection with rotation models.\"\"\"\n\n    def __init__(self, nc=80, ne=1, ch=()):\n        \"\"\"Initialize OBB with number of classes `nc` and layer channels `ch`.\"\"\"\n        super().__init__(nc, ch)\n        self.ne = ne  # number of extra parameters\n        self.detect = Detect.forward\n\n        c4 = max(ch[0] // 4, self.ne)\n        self.cv4 = nn.ModuleList(nn.Sequential(Conv(x, c4, 3), Conv(c4, c4, 3), nn.Conv2d(c4, self.ne, 1)) for x in ch)\n\n    def forward(self, x):\n        \"\"\"Concatenates and returns predicted bounding boxes and class probabilities.\"\"\"\n        bs = x[0].shape[0]  # batch size\n        angle = torch.cat([self.cv4[i](x[i]).view(bs, self.ne, -1) for i in range(self.nl)], 2)  # OBB theta logits\n        # NOTE: set `angle` as an attribute so that `decode_bboxes` could use it.\n        angle = (angle.sigmoid() - 0.25) * math.pi  # [-pi/4, 3pi/4]\n        # angle = angle.sigmoid() * math.pi / 2  # [0, pi/2]\n        if not self.training:\n            self.angle = angle\n        x = self.detect(self, x)\n        if self.training:\n            return x, angle\n        return torch.cat([x, angle], 1) if self.export else (torch.cat([x[0], angle], 1), (x[1], angle))\n\n    def decode_bboxes(self, bboxes):\n        \"\"\"Decode rotated bounding boxes.\"\"\"\n        return dist2rbox(self.dfl(bboxes), self.angle, self.anchors.unsqueeze(0), dim=1) * self.strides\n</code></pre>"},{"location":"reference/nn/modules/head/#ultralytics.nn.modules.head.OBB.__init__","title":"<code>__init__(nc=80, ne=1, ch=())</code>","text":"<p>Initialize OBB with number of classes <code>nc</code> and layer channels <code>ch</code>.</p> Source code in <code>ultralytics/nn/modules/head.py</code> <pre><code>def __init__(self, nc=80, ne=1, ch=()):\n    \"\"\"Initialize OBB with number of classes `nc` and layer channels `ch`.\"\"\"\n    super().__init__(nc, ch)\n    self.ne = ne  # number of extra parameters\n    self.detect = Detect.forward\n\n    c4 = max(ch[0] // 4, self.ne)\n    self.cv4 = nn.ModuleList(nn.Sequential(Conv(x, c4, 3), Conv(c4, c4, 3), nn.Conv2d(c4, self.ne, 1)) for x in ch)\n</code></pre>"},{"location":"reference/nn/modules/head/#ultralytics.nn.modules.head.OBB.decode_bboxes","title":"<code>decode_bboxes(bboxes)</code>","text":"<p>Decode rotated bounding boxes.</p> Source code in <code>ultralytics/nn/modules/head.py</code> <pre><code>def decode_bboxes(self, bboxes):\n    \"\"\"Decode rotated bounding boxes.\"\"\"\n    return dist2rbox(self.dfl(bboxes), self.angle, self.anchors.unsqueeze(0), dim=1) * self.strides\n</code></pre>"},{"location":"reference/nn/modules/head/#ultralytics.nn.modules.head.OBB.forward","title":"<code>forward(x)</code>","text":"<p>Concatenates and returns predicted bounding boxes and class probabilities.</p> Source code in <code>ultralytics/nn/modules/head.py</code> <pre><code>def forward(self, x):\n    \"\"\"Concatenates and returns predicted bounding boxes and class probabilities.\"\"\"\n    bs = x[0].shape[0]  # batch size\n    angle = torch.cat([self.cv4[i](x[i]).view(bs, self.ne, -1) for i in range(self.nl)], 2)  # OBB theta logits\n    # NOTE: set `angle` as an attribute so that `decode_bboxes` could use it.\n    angle = (angle.sigmoid() - 0.25) * math.pi  # [-pi/4, 3pi/4]\n    # angle = angle.sigmoid() * math.pi / 2  # [0, pi/2]\n    if not self.training:\n        self.angle = angle\n    x = self.detect(self, x)\n    if self.training:\n        return x, angle\n    return torch.cat([x, angle], 1) if self.export else (torch.cat([x[0], angle], 1), (x[1], angle))\n</code></pre>"},{"location":"reference/nn/modules/head/#ultralytics.nn.modules.head.Pose","title":"<code>ultralytics.nn.modules.head.Pose</code>","text":"<p>             Bases: <code>Detect</code></p> <p>YOLOv8 Pose head for keypoints models.</p> Source code in <code>ultralytics/nn/modules/head.py</code> <pre><code>class Pose(Detect):\n    \"\"\"YOLOv8 Pose head for keypoints models.\"\"\"\n\n    def __init__(self, nc=80, kpt_shape=(17, 3), ch=()):\n        \"\"\"Initialize YOLO network with default parameters and Convolutional Layers.\"\"\"\n        super().__init__(nc, ch)\n        self.kpt_shape = kpt_shape  # number of keypoints, number of dims (2 for x,y or 3 for x,y,visible)\n        self.nk = kpt_shape[0] * kpt_shape[1]  # number of keypoints total\n        self.detect = Detect.forward\n\n        c4 = max(ch[0] // 4, self.nk)\n        self.cv4 = nn.ModuleList(nn.Sequential(Conv(x, c4, 3), Conv(c4, c4, 3), nn.Conv2d(c4, self.nk, 1)) for x in ch)\n\n    def forward(self, x):\n        \"\"\"Perform forward pass through YOLO model and return predictions.\"\"\"\n        bs = x[0].shape[0]  # batch size\n        kpt = torch.cat([self.cv4[i](x[i]).view(bs, self.nk, -1) for i in range(self.nl)], -1)  # (bs, 17*3, h*w)\n        x = self.detect(self, x)\n        if self.training:\n            return x, kpt\n        pred_kpt = self.kpts_decode(bs, kpt)\n        return torch.cat([x, pred_kpt], 1) if self.export else (torch.cat([x[0], pred_kpt], 1), (x[1], kpt))\n\n    def kpts_decode(self, bs, kpts):\n        \"\"\"Decodes keypoints.\"\"\"\n        ndim = self.kpt_shape[1]\n        if self.export:  # required for TFLite export to avoid 'PLACEHOLDER_FOR_GREATER_OP_CODES' bug\n            y = kpts.view(bs, *self.kpt_shape, -1)\n            a = (y[:, :, :2] * 2.0 + (self.anchors - 0.5)) * self.strides\n            if ndim == 3:\n                a = torch.cat((a, y[:, :, 2:3].sigmoid()), 2)\n            return a.view(bs, self.nk, -1)\n        else:\n            y = kpts.clone()\n            if ndim == 3:\n                y[:, 2::3] = y[:, 2::3].sigmoid()  # sigmoid (WARNING: inplace .sigmoid_() Apple MPS bug)\n            y[:, 0::ndim] = (y[:, 0::ndim] * 2.0 + (self.anchors[0] - 0.5)) * self.strides\n            y[:, 1::ndim] = (y[:, 1::ndim] * 2.0 + (self.anchors[1] - 0.5)) * self.strides\n            return y\n</code></pre>"},{"location":"reference/nn/modules/head/#ultralytics.nn.modules.head.Pose.__init__","title":"<code>__init__(nc=80, kpt_shape=(17, 3), ch=())</code>","text":"<p>Initialize YOLO network with default parameters and Convolutional Layers.</p> Source code in <code>ultralytics/nn/modules/head.py</code> <pre><code>def __init__(self, nc=80, kpt_shape=(17, 3), ch=()):\n    \"\"\"Initialize YOLO network with default parameters and Convolutional Layers.\"\"\"\n    super().__init__(nc, ch)\n    self.kpt_shape = kpt_shape  # number of keypoints, number of dims (2 for x,y or 3 for x,y,visible)\n    self.nk = kpt_shape[0] * kpt_shape[1]  # number of keypoints total\n    self.detect = Detect.forward\n\n    c4 = max(ch[0] // 4, self.nk)\n    self.cv4 = nn.ModuleList(nn.Sequential(Conv(x, c4, 3), Conv(c4, c4, 3), nn.Conv2d(c4, self.nk, 1)) for x in ch)\n</code></pre>"},{"location":"reference/nn/modules/head/#ultralytics.nn.modules.head.Pose.forward","title":"<code>forward(x)</code>","text":"<p>Perform forward pass through YOLO model and return predictions.</p> Source code in <code>ultralytics/nn/modules/head.py</code> <pre><code>def forward(self, x):\n    \"\"\"Perform forward pass through YOLO model and return predictions.\"\"\"\n    bs = x[0].shape[0]  # batch size\n    kpt = torch.cat([self.cv4[i](x[i]).view(bs, self.nk, -1) for i in range(self.nl)], -1)  # (bs, 17*3, h*w)\n    x = self.detect(self, x)\n    if self.training:\n        return x, kpt\n    pred_kpt = self.kpts_decode(bs, kpt)\n    return torch.cat([x, pred_kpt], 1) if self.export else (torch.cat([x[0], pred_kpt], 1), (x[1], kpt))\n</code></pre>"},{"location":"reference/nn/modules/head/#ultralytics.nn.modules.head.Pose.kpts_decode","title":"<code>kpts_decode(bs, kpts)</code>","text":"<p>Decodes keypoints.</p> Source code in <code>ultralytics/nn/modules/head.py</code> <pre><code>def kpts_decode(self, bs, kpts):\n    \"\"\"Decodes keypoints.\"\"\"\n    ndim = self.kpt_shape[1]\n    if self.export:  # required for TFLite export to avoid 'PLACEHOLDER_FOR_GREATER_OP_CODES' bug\n        y = kpts.view(bs, *self.kpt_shape, -1)\n        a = (y[:, :, :2] * 2.0 + (self.anchors - 0.5)) * self.strides\n        if ndim == 3:\n            a = torch.cat((a, y[:, :, 2:3].sigmoid()), 2)\n        return a.view(bs, self.nk, -1)\n    else:\n        y = kpts.clone()\n        if ndim == 3:\n            y[:, 2::3] = y[:, 2::3].sigmoid()  # sigmoid (WARNING: inplace .sigmoid_() Apple MPS bug)\n        y[:, 0::ndim] = (y[:, 0::ndim] * 2.0 + (self.anchors[0] - 0.5)) * self.strides\n        y[:, 1::ndim] = (y[:, 1::ndim] * 2.0 + (self.anchors[1] - 0.5)) * self.strides\n        return y\n</code></pre>"},{"location":"reference/nn/modules/head/#ultralytics.nn.modules.head.Classify","title":"<code>ultralytics.nn.modules.head.Classify</code>","text":"<p>             Bases: <code>Module</code></p> <p>YOLOv8 classification head, i.e. x(b,c1,20,20) to x(b,c2).</p> Source code in <code>ultralytics/nn/modules/head.py</code> <pre><code>class Classify(nn.Module):\n    \"\"\"YOLOv8 classification head, i.e. x(b,c1,20,20) to x(b,c2).\"\"\"\n\n    def __init__(self, c1, c2, k=1, s=1, p=None, g=1):\n        \"\"\"Initializes YOLOv8 classification head with specified input and output channels, kernel size, stride,\n        padding, and groups.\n        \"\"\"\n        super().__init__()\n        c_ = 1280  # efficientnet_b0 size\n        self.conv = Conv(c1, c_, k, s, p, g)\n        self.pool = nn.AdaptiveAvgPool2d(1)  # to x(b,c_,1,1)\n        self.drop = nn.Dropout(p=0.0, inplace=True)\n        self.linear = nn.Linear(c_, c2)  # to x(b,c2)\n\n    def forward(self, x):\n        \"\"\"Performs a forward pass of the YOLO model on input image data.\"\"\"\n        if isinstance(x, list):\n            x = torch.cat(x, 1)\n        x = self.linear(self.drop(self.pool(self.conv(x)).flatten(1)))\n        return x if self.training else x.softmax(1)\n</code></pre>"},{"location":"reference/nn/modules/head/#ultralytics.nn.modules.head.Classify.__init__","title":"<code>__init__(c1, c2, k=1, s=1, p=None, g=1)</code>","text":"<p>Initializes YOLOv8 classification head with specified input and output channels, kernel size, stride, padding, and groups.</p> Source code in <code>ultralytics/nn/modules/head.py</code> <pre><code>def __init__(self, c1, c2, k=1, s=1, p=None, g=1):\n    \"\"\"Initializes YOLOv8 classification head with specified input and output channels, kernel size, stride,\n    padding, and groups.\n    \"\"\"\n    super().__init__()\n    c_ = 1280  # efficientnet_b0 size\n    self.conv = Conv(c1, c_, k, s, p, g)\n    self.pool = nn.AdaptiveAvgPool2d(1)  # to x(b,c_,1,1)\n    self.drop = nn.Dropout(p=0.0, inplace=True)\n    self.linear = nn.Linear(c_, c2)  # to x(b,c2)\n</code></pre>"},{"location":"reference/nn/modules/head/#ultralytics.nn.modules.head.Classify.forward","title":"<code>forward(x)</code>","text":"<p>Performs a forward pass of the YOLO model on input image data.</p> Source code in <code>ultralytics/nn/modules/head.py</code> <pre><code>def forward(self, x):\n    \"\"\"Performs a forward pass of the YOLO model on input image data.\"\"\"\n    if isinstance(x, list):\n        x = torch.cat(x, 1)\n    x = self.linear(self.drop(self.pool(self.conv(x)).flatten(1)))\n    return x if self.training else x.softmax(1)\n</code></pre>"},{"location":"reference/nn/modules/head/#ultralytics.nn.modules.head.RTDETRDecoder","title":"<code>ultralytics.nn.modules.head.RTDETRDecoder</code>","text":"<p>             Bases: <code>Module</code></p> <p>Real-Time Deformable Transformer Decoder (RTDETRDecoder) module for object detection.</p> <p>This decoder module utilizes Transformer architecture along with deformable convolutions to predict bounding boxes and class labels for objects in an image. It integrates features from multiple layers and runs through a series of Transformer decoder layers to output the final predictions.</p> Source code in <code>ultralytics/nn/modules/head.py</code> <pre><code>class RTDETRDecoder(nn.Module):\n    \"\"\"\n    Real-Time Deformable Transformer Decoder (RTDETRDecoder) module for object detection.\n\n    This decoder module utilizes Transformer architecture along with deformable convolutions to predict bounding boxes\n    and class labels for objects in an image. It integrates features from multiple layers and runs through a series of\n    Transformer decoder layers to output the final predictions.\n    \"\"\"\n\n    export = False  # export mode\n\n    def __init__(\n        self,\n        nc=80,\n        ch=(512, 1024, 2048),\n        hd=256,  # hidden dim\n        nq=300,  # num queries\n        ndp=4,  # num decoder points\n        nh=8,  # num head\n        ndl=6,  # num decoder layers\n        d_ffn=1024,  # dim of feedforward\n        dropout=0.0,\n        act=nn.ReLU(),\n        eval_idx=-1,\n        # Training args\n        nd=100,  # num denoising\n        label_noise_ratio=0.5,\n        box_noise_scale=1.0,\n        learnt_init_query=False,\n    ):\n        \"\"\"\n        Initializes the RTDETRDecoder module with the given parameters.\n\n        Args:\n            nc (int): Number of classes. Default is 80.\n            ch (tuple): Channels in the backbone feature maps. Default is (512, 1024, 2048).\n            hd (int): Dimension of hidden layers. Default is 256.\n            nq (int): Number of query points. Default is 300.\n            ndp (int): Number of decoder points. Default is 4.\n            nh (int): Number of heads in multi-head attention. Default is 8.\n            ndl (int): Number of decoder layers. Default is 6.\n            d_ffn (int): Dimension of the feed-forward networks. Default is 1024.\n            dropout (float): Dropout rate. Default is 0.\n            act (nn.Module): Activation function. Default is nn.ReLU.\n            eval_idx (int): Evaluation index. Default is -1.\n            nd (int): Number of denoising. Default is 100.\n            label_noise_ratio (float): Label noise ratio. Default is 0.5.\n            box_noise_scale (float): Box noise scale. Default is 1.0.\n            learnt_init_query (bool): Whether to learn initial query embeddings. Default is False.\n        \"\"\"\n        super().__init__()\n        self.hidden_dim = hd\n        self.nhead = nh\n        self.nl = len(ch)  # num level\n        self.nc = nc\n        self.num_queries = nq\n        self.num_decoder_layers = ndl\n\n        # Backbone feature projection\n        self.input_proj = nn.ModuleList(nn.Sequential(nn.Conv2d(x, hd, 1, bias=False), nn.BatchNorm2d(hd)) for x in ch)\n        # NOTE: simplified version but it's not consistent with .pt weights.\n        # self.input_proj = nn.ModuleList(Conv(x, hd, act=False) for x in ch)\n\n        # Transformer module\n        decoder_layer = DeformableTransformerDecoderLayer(hd, nh, d_ffn, dropout, act, self.nl, ndp)\n        self.decoder = DeformableTransformerDecoder(hd, decoder_layer, ndl, eval_idx)\n\n        # Denoising part\n        self.denoising_class_embed = nn.Embedding(nc, hd)\n        self.num_denoising = nd\n        self.label_noise_ratio = label_noise_ratio\n        self.box_noise_scale = box_noise_scale\n\n        # Decoder embedding\n        self.learnt_init_query = learnt_init_query\n        if learnt_init_query:\n            self.tgt_embed = nn.Embedding(nq, hd)\n        self.query_pos_head = MLP(4, 2 * hd, hd, num_layers=2)\n\n        # Encoder head\n        self.enc_output = nn.Sequential(nn.Linear(hd, hd), nn.LayerNorm(hd))\n        self.enc_score_head = nn.Linear(hd, nc)\n        self.enc_bbox_head = MLP(hd, hd, 4, num_layers=3)\n\n        # Decoder head\n        self.dec_score_head = nn.ModuleList([nn.Linear(hd, nc) for _ in range(ndl)])\n        self.dec_bbox_head = nn.ModuleList([MLP(hd, hd, 4, num_layers=3) for _ in range(ndl)])\n\n        self._reset_parameters()\n\n    def forward(self, x, batch=None):\n        \"\"\"Runs the forward pass of the module, returning bounding box and classification scores for the input.\"\"\"\n        from ultralytics.models.utils.ops import get_cdn_group\n\n        # Input projection and embedding\n        feats, shapes = self._get_encoder_input(x)\n\n        # Prepare denoising training\n        dn_embed, dn_bbox, attn_mask, dn_meta = get_cdn_group(\n            batch,\n            self.nc,\n            self.num_queries,\n            self.denoising_class_embed.weight,\n            self.num_denoising,\n            self.label_noise_ratio,\n            self.box_noise_scale,\n            self.training,\n        )\n\n        embed, refer_bbox, enc_bboxes, enc_scores = self._get_decoder_input(feats, shapes, dn_embed, dn_bbox)\n\n        # Decoder\n        dec_bboxes, dec_scores = self.decoder(\n            embed,\n            refer_bbox,\n            feats,\n            shapes,\n            self.dec_bbox_head,\n            self.dec_score_head,\n            self.query_pos_head,\n            attn_mask=attn_mask,\n        )\n        x = dec_bboxes, dec_scores, enc_bboxes, enc_scores, dn_meta\n        if self.training:\n            return x\n        # (bs, 300, 4+nc)\n        y = torch.cat((dec_bboxes.squeeze(0), dec_scores.squeeze(0).sigmoid()), -1)\n        return y if self.export else (y, x)\n\n    def _generate_anchors(self, shapes, grid_size=0.05, dtype=torch.float32, device=\"cpu\", eps=1e-2):\n        \"\"\"Generates anchor bounding boxes for given shapes with specific grid size and validates them.\"\"\"\n        anchors = []\n        for i, (h, w) in enumerate(shapes):\n            sy = torch.arange(end=h, dtype=dtype, device=device)\n            sx = torch.arange(end=w, dtype=dtype, device=device)\n            grid_y, grid_x = torch.meshgrid(sy, sx, indexing=\"ij\") if TORCH_1_10 else torch.meshgrid(sy, sx)\n            grid_xy = torch.stack([grid_x, grid_y], -1)  # (h, w, 2)\n\n            valid_WH = torch.tensor([w, h], dtype=dtype, device=device)\n            grid_xy = (grid_xy.unsqueeze(0) + 0.5) / valid_WH  # (1, h, w, 2)\n            wh = torch.ones_like(grid_xy, dtype=dtype, device=device) * grid_size * (2.0**i)\n            anchors.append(torch.cat([grid_xy, wh], -1).view(-1, h * w, 4))  # (1, h*w, 4)\n\n        anchors = torch.cat(anchors, 1)  # (1, h*w*nl, 4)\n        valid_mask = ((anchors &gt; eps) * (anchors &lt; 1 - eps)).all(-1, keepdim=True)  # 1, h*w*nl, 1\n        anchors = torch.log(anchors / (1 - anchors))\n        anchors = anchors.masked_fill(~valid_mask, float(\"inf\"))\n        return anchors, valid_mask\n\n    def _get_encoder_input(self, x):\n        \"\"\"Processes and returns encoder inputs by getting projection features from input and concatenating them.\"\"\"\n        # Get projection features\n        x = [self.input_proj[i](feat) for i, feat in enumerate(x)]\n        # Get encoder inputs\n        feats = []\n        shapes = []\n        for feat in x:\n            h, w = feat.shape[2:]\n            # [b, c, h, w] -&gt; [b, h*w, c]\n            feats.append(feat.flatten(2).permute(0, 2, 1))\n            # [nl, 2]\n            shapes.append([h, w])\n\n        # [b, h*w, c]\n        feats = torch.cat(feats, 1)\n        return feats, shapes\n\n    def _get_decoder_input(self, feats, shapes, dn_embed=None, dn_bbox=None):\n        \"\"\"Generates and prepares the input required for the decoder from the provided features and shapes.\"\"\"\n        bs = len(feats)\n        # Prepare input for decoder\n        anchors, valid_mask = self._generate_anchors(shapes, dtype=feats.dtype, device=feats.device)\n        features = self.enc_output(valid_mask * feats)  # bs, h*w, 256\n\n        enc_outputs_scores = self.enc_score_head(features)  # (bs, h*w, nc)\n\n        # Query selection\n        # (bs, num_queries)\n        topk_ind = torch.topk(enc_outputs_scores.max(-1).values, self.num_queries, dim=1).indices.view(-1)\n        # (bs, num_queries)\n        batch_ind = torch.arange(end=bs, dtype=topk_ind.dtype).unsqueeze(-1).repeat(1, self.num_queries).view(-1)\n\n        # (bs, num_queries, 256)\n        top_k_features = features[batch_ind, topk_ind].view(bs, self.num_queries, -1)\n        # (bs, num_queries, 4)\n        top_k_anchors = anchors[:, topk_ind].view(bs, self.num_queries, -1)\n\n        # Dynamic anchors + static content\n        refer_bbox = self.enc_bbox_head(top_k_features) + top_k_anchors\n\n        enc_bboxes = refer_bbox.sigmoid()\n        if dn_bbox is not None:\n            refer_bbox = torch.cat([dn_bbox, refer_bbox], 1)\n        enc_scores = enc_outputs_scores[batch_ind, topk_ind].view(bs, self.num_queries, -1)\n\n        embeddings = self.tgt_embed.weight.unsqueeze(0).repeat(bs, 1, 1) if self.learnt_init_query else top_k_features\n        if self.training:\n            refer_bbox = refer_bbox.detach()\n            if not self.learnt_init_query:\n                embeddings = embeddings.detach()\n        if dn_embed is not None:\n            embeddings = torch.cat([dn_embed, embeddings], 1)\n\n        return embeddings, refer_bbox, enc_bboxes, enc_scores\n\n    # TODO\n    def _reset_parameters(self):\n        \"\"\"Initializes or resets the parameters of the model's various components with predefined weights and biases.\"\"\"\n        # Class and bbox head init\n        bias_cls = bias_init_with_prob(0.01) / 80 * self.nc\n        # NOTE: the weight initialization in `linear_init_` would cause NaN when training with custom datasets.\n        # linear_init_(self.enc_score_head)\n        constant_(self.enc_score_head.bias, bias_cls)\n        constant_(self.enc_bbox_head.layers[-1].weight, 0.0)\n        constant_(self.enc_bbox_head.layers[-1].bias, 0.0)\n        for cls_, reg_ in zip(self.dec_score_head, self.dec_bbox_head):\n            # linear_init_(cls_)\n            constant_(cls_.bias, bias_cls)\n            constant_(reg_.layers[-1].weight, 0.0)\n            constant_(reg_.layers[-1].bias, 0.0)\n\n        linear_init_(self.enc_output[0])\n        xavier_uniform_(self.enc_output[0].weight)\n        if self.learnt_init_query:\n            xavier_uniform_(self.tgt_embed.weight)\n        xavier_uniform_(self.query_pos_head.layers[0].weight)\n        xavier_uniform_(self.query_pos_head.layers[1].weight)\n        for layer in self.input_proj:\n            xavier_uniform_(layer[0].weight)\n</code></pre>"},{"location":"reference/nn/modules/head/#ultralytics.nn.modules.head.RTDETRDecoder.__init__","title":"<code>__init__(nc=80, ch=(512, 1024, 2048), hd=256, nq=300, ndp=4, nh=8, ndl=6, d_ffn=1024, dropout=0.0, act=nn.ReLU(), eval_idx=-1, nd=100, label_noise_ratio=0.5, box_noise_scale=1.0, learnt_init_query=False)</code>","text":"<p>Initializes the RTDETRDecoder module with the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>nc</code> <code>int</code> <p>Number of classes. Default is 80.</p> <code>80</code> <code>ch</code> <code>tuple</code> <p>Channels in the backbone feature maps. Default is (512, 1024, 2048).</p> <code>(512, 1024, 2048)</code> <code>hd</code> <code>int</code> <p>Dimension of hidden layers. Default is 256.</p> <code>256</code> <code>nq</code> <code>int</code> <p>Number of query points. Default is 300.</p> <code>300</code> <code>ndp</code> <code>int</code> <p>Number of decoder points. Default is 4.</p> <code>4</code> <code>nh</code> <code>int</code> <p>Number of heads in multi-head attention. Default is 8.</p> <code>8</code> <code>ndl</code> <code>int</code> <p>Number of decoder layers. Default is 6.</p> <code>6</code> <code>d_ffn</code> <code>int</code> <p>Dimension of the feed-forward networks. Default is 1024.</p> <code>1024</code> <code>dropout</code> <code>float</code> <p>Dropout rate. Default is 0.</p> <code>0.0</code> <code>act</code> <code>Module</code> <p>Activation function. Default is nn.ReLU.</p> <code>ReLU()</code> <code>eval_idx</code> <code>int</code> <p>Evaluation index. Default is -1.</p> <code>-1</code> <code>nd</code> <code>int</code> <p>Number of denoising. Default is 100.</p> <code>100</code> <code>label_noise_ratio</code> <code>float</code> <p>Label noise ratio. Default is 0.5.</p> <code>0.5</code> <code>box_noise_scale</code> <code>float</code> <p>Box noise scale. Default is 1.0.</p> <code>1.0</code> <code>learnt_init_query</code> <code>bool</code> <p>Whether to learn initial query embeddings. Default is False.</p> <code>False</code> Source code in <code>ultralytics/nn/modules/head.py</code> <pre><code>def __init__(\n    self,\n    nc=80,\n    ch=(512, 1024, 2048),\n    hd=256,  # hidden dim\n    nq=300,  # num queries\n    ndp=4,  # num decoder points\n    nh=8,  # num head\n    ndl=6,  # num decoder layers\n    d_ffn=1024,  # dim of feedforward\n    dropout=0.0,\n    act=nn.ReLU(),\n    eval_idx=-1,\n    # Training args\n    nd=100,  # num denoising\n    label_noise_ratio=0.5,\n    box_noise_scale=1.0,\n    learnt_init_query=False,\n):\n    \"\"\"\n    Initializes the RTDETRDecoder module with the given parameters.\n\n    Args:\n        nc (int): Number of classes. Default is 80.\n        ch (tuple): Channels in the backbone feature maps. Default is (512, 1024, 2048).\n        hd (int): Dimension of hidden layers. Default is 256.\n        nq (int): Number of query points. Default is 300.\n        ndp (int): Number of decoder points. Default is 4.\n        nh (int): Number of heads in multi-head attention. Default is 8.\n        ndl (int): Number of decoder layers. Default is 6.\n        d_ffn (int): Dimension of the feed-forward networks. Default is 1024.\n        dropout (float): Dropout rate. Default is 0.\n        act (nn.Module): Activation function. Default is nn.ReLU.\n        eval_idx (int): Evaluation index. Default is -1.\n        nd (int): Number of denoising. Default is 100.\n        label_noise_ratio (float): Label noise ratio. Default is 0.5.\n        box_noise_scale (float): Box noise scale. Default is 1.0.\n        learnt_init_query (bool): Whether to learn initial query embeddings. Default is False.\n    \"\"\"\n    super().__init__()\n    self.hidden_dim = hd\n    self.nhead = nh\n    self.nl = len(ch)  # num level\n    self.nc = nc\n    self.num_queries = nq\n    self.num_decoder_layers = ndl\n\n    # Backbone feature projection\n    self.input_proj = nn.ModuleList(nn.Sequential(nn.Conv2d(x, hd, 1, bias=False), nn.BatchNorm2d(hd)) for x in ch)\n    # NOTE: simplified version but it's not consistent with .pt weights.\n    # self.input_proj = nn.ModuleList(Conv(x, hd, act=False) for x in ch)\n\n    # Transformer module\n    decoder_layer = DeformableTransformerDecoderLayer(hd, nh, d_ffn, dropout, act, self.nl, ndp)\n    self.decoder = DeformableTransformerDecoder(hd, decoder_layer, ndl, eval_idx)\n\n    # Denoising part\n    self.denoising_class_embed = nn.Embedding(nc, hd)\n    self.num_denoising = nd\n    self.label_noise_ratio = label_noise_ratio\n    self.box_noise_scale = box_noise_scale\n\n    # Decoder embedding\n    self.learnt_init_query = learnt_init_query\n    if learnt_init_query:\n        self.tgt_embed = nn.Embedding(nq, hd)\n    self.query_pos_head = MLP(4, 2 * hd, hd, num_layers=2)\n\n    # Encoder head\n    self.enc_output = nn.Sequential(nn.Linear(hd, hd), nn.LayerNorm(hd))\n    self.enc_score_head = nn.Linear(hd, nc)\n    self.enc_bbox_head = MLP(hd, hd, 4, num_layers=3)\n\n    # Decoder head\n    self.dec_score_head = nn.ModuleList([nn.Linear(hd, nc) for _ in range(ndl)])\n    self.dec_bbox_head = nn.ModuleList([MLP(hd, hd, 4, num_layers=3) for _ in range(ndl)])\n\n    self._reset_parameters()\n</code></pre>"},{"location":"reference/nn/modules/head/#ultralytics.nn.modules.head.RTDETRDecoder.forward","title":"<code>forward(x, batch=None)</code>","text":"<p>Runs the forward pass of the module, returning bounding box and classification scores for the input.</p> Source code in <code>ultralytics/nn/modules/head.py</code> <pre><code>def forward(self, x, batch=None):\n    \"\"\"Runs the forward pass of the module, returning bounding box and classification scores for the input.\"\"\"\n    from ultralytics.models.utils.ops import get_cdn_group\n\n    # Input projection and embedding\n    feats, shapes = self._get_encoder_input(x)\n\n    # Prepare denoising training\n    dn_embed, dn_bbox, attn_mask, dn_meta = get_cdn_group(\n        batch,\n        self.nc,\n        self.num_queries,\n        self.denoising_class_embed.weight,\n        self.num_denoising,\n        self.label_noise_ratio,\n        self.box_noise_scale,\n        self.training,\n    )\n\n    embed, refer_bbox, enc_bboxes, enc_scores = self._get_decoder_input(feats, shapes, dn_embed, dn_bbox)\n\n    # Decoder\n    dec_bboxes, dec_scores = self.decoder(\n        embed,\n        refer_bbox,\n        feats,\n        shapes,\n        self.dec_bbox_head,\n        self.dec_score_head,\n        self.query_pos_head,\n        attn_mask=attn_mask,\n    )\n    x = dec_bboxes, dec_scores, enc_bboxes, enc_scores, dn_meta\n    if self.training:\n        return x\n    # (bs, 300, 4+nc)\n    y = torch.cat((dec_bboxes.squeeze(0), dec_scores.squeeze(0).sigmoid()), -1)\n    return y if self.export else (y, x)\n</code></pre>"},{"location":"reference/nn/modules/transformer/","title":"Reference for <code>ultralytics/nn/modules/transformer.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/nn/modules/transformer.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.TransformerEncoderLayer","title":"<code>ultralytics.nn.modules.transformer.TransformerEncoderLayer</code>","text":"<p>             Bases: <code>Module</code></p> <p>Defines a single layer of the transformer encoder.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>class TransformerEncoderLayer(nn.Module):\n    \"\"\"Defines a single layer of the transformer encoder.\"\"\"\n\n    def __init__(self, c1, cm=2048, num_heads=8, dropout=0.0, act=nn.GELU(), normalize_before=False):\n        \"\"\"Initialize the TransformerEncoderLayer with specified parameters.\"\"\"\n        super().__init__()\n        from ...utils.torch_utils import TORCH_1_9\n\n        if not TORCH_1_9:\n            raise ModuleNotFoundError(\n                \"TransformerEncoderLayer() requires torch&gt;=1.9 to use nn.MultiheadAttention(batch_first=True).\"\n            )\n        self.ma = nn.MultiheadAttention(c1, num_heads, dropout=dropout, batch_first=True)\n        # Implementation of Feedforward model\n        self.fc1 = nn.Linear(c1, cm)\n        self.fc2 = nn.Linear(cm, c1)\n\n        self.norm1 = nn.LayerNorm(c1)\n        self.norm2 = nn.LayerNorm(c1)\n        self.dropout = nn.Dropout(dropout)\n        self.dropout1 = nn.Dropout(dropout)\n        self.dropout2 = nn.Dropout(dropout)\n\n        self.act = act\n        self.normalize_before = normalize_before\n\n    @staticmethod\n    def with_pos_embed(tensor, pos=None):\n        \"\"\"Add position embeddings to the tensor if provided.\"\"\"\n        return tensor if pos is None else tensor + pos\n\n    def forward_post(self, src, src_mask=None, src_key_padding_mask=None, pos=None):\n        \"\"\"Performs forward pass with post-normalization.\"\"\"\n        q = k = self.with_pos_embed(src, pos)\n        src2 = self.ma(q, k, value=src, attn_mask=src_mask, key_padding_mask=src_key_padding_mask)[0]\n        src = src + self.dropout1(src2)\n        src = self.norm1(src)\n        src2 = self.fc2(self.dropout(self.act(self.fc1(src))))\n        src = src + self.dropout2(src2)\n        return self.norm2(src)\n\n    def forward_pre(self, src, src_mask=None, src_key_padding_mask=None, pos=None):\n        \"\"\"Performs forward pass with pre-normalization.\"\"\"\n        src2 = self.norm1(src)\n        q = k = self.with_pos_embed(src2, pos)\n        src2 = self.ma(q, k, value=src2, attn_mask=src_mask, key_padding_mask=src_key_padding_mask)[0]\n        src = src + self.dropout1(src2)\n        src2 = self.norm2(src)\n        src2 = self.fc2(self.dropout(self.act(self.fc1(src2))))\n        return src + self.dropout2(src2)\n\n    def forward(self, src, src_mask=None, src_key_padding_mask=None, pos=None):\n        \"\"\"Forward propagates the input through the encoder module.\"\"\"\n        if self.normalize_before:\n            return self.forward_pre(src, src_mask, src_key_padding_mask, pos)\n        return self.forward_post(src, src_mask, src_key_padding_mask, pos)\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.TransformerEncoderLayer.__init__","title":"<code>__init__(c1, cm=2048, num_heads=8, dropout=0.0, act=nn.GELU(), normalize_before=False)</code>","text":"<p>Initialize the TransformerEncoderLayer with specified parameters.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>def __init__(self, c1, cm=2048, num_heads=8, dropout=0.0, act=nn.GELU(), normalize_before=False):\n    \"\"\"Initialize the TransformerEncoderLayer with specified parameters.\"\"\"\n    super().__init__()\n    from ...utils.torch_utils import TORCH_1_9\n\n    if not TORCH_1_9:\n        raise ModuleNotFoundError(\n            \"TransformerEncoderLayer() requires torch&gt;=1.9 to use nn.MultiheadAttention(batch_first=True).\"\n        )\n    self.ma = nn.MultiheadAttention(c1, num_heads, dropout=dropout, batch_first=True)\n    # Implementation of Feedforward model\n    self.fc1 = nn.Linear(c1, cm)\n    self.fc2 = nn.Linear(cm, c1)\n\n    self.norm1 = nn.LayerNorm(c1)\n    self.norm2 = nn.LayerNorm(c1)\n    self.dropout = nn.Dropout(dropout)\n    self.dropout1 = nn.Dropout(dropout)\n    self.dropout2 = nn.Dropout(dropout)\n\n    self.act = act\n    self.normalize_before = normalize_before\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.TransformerEncoderLayer.forward","title":"<code>forward(src, src_mask=None, src_key_padding_mask=None, pos=None)</code>","text":"<p>Forward propagates the input through the encoder module.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>def forward(self, src, src_mask=None, src_key_padding_mask=None, pos=None):\n    \"\"\"Forward propagates the input through the encoder module.\"\"\"\n    if self.normalize_before:\n        return self.forward_pre(src, src_mask, src_key_padding_mask, pos)\n    return self.forward_post(src, src_mask, src_key_padding_mask, pos)\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.TransformerEncoderLayer.forward_post","title":"<code>forward_post(src, src_mask=None, src_key_padding_mask=None, pos=None)</code>","text":"<p>Performs forward pass with post-normalization.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>def forward_post(self, src, src_mask=None, src_key_padding_mask=None, pos=None):\n    \"\"\"Performs forward pass with post-normalization.\"\"\"\n    q = k = self.with_pos_embed(src, pos)\n    src2 = self.ma(q, k, value=src, attn_mask=src_mask, key_padding_mask=src_key_padding_mask)[0]\n    src = src + self.dropout1(src2)\n    src = self.norm1(src)\n    src2 = self.fc2(self.dropout(self.act(self.fc1(src))))\n    src = src + self.dropout2(src2)\n    return self.norm2(src)\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.TransformerEncoderLayer.forward_pre","title":"<code>forward_pre(src, src_mask=None, src_key_padding_mask=None, pos=None)</code>","text":"<p>Performs forward pass with pre-normalization.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>def forward_pre(self, src, src_mask=None, src_key_padding_mask=None, pos=None):\n    \"\"\"Performs forward pass with pre-normalization.\"\"\"\n    src2 = self.norm1(src)\n    q = k = self.with_pos_embed(src2, pos)\n    src2 = self.ma(q, k, value=src2, attn_mask=src_mask, key_padding_mask=src_key_padding_mask)[0]\n    src = src + self.dropout1(src2)\n    src2 = self.norm2(src)\n    src2 = self.fc2(self.dropout(self.act(self.fc1(src2))))\n    return src + self.dropout2(src2)\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.TransformerEncoderLayer.with_pos_embed","title":"<code>with_pos_embed(tensor, pos=None)</code>  <code>staticmethod</code>","text":"<p>Add position embeddings to the tensor if provided.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>@staticmethod\ndef with_pos_embed(tensor, pos=None):\n    \"\"\"Add position embeddings to the tensor if provided.\"\"\"\n    return tensor if pos is None else tensor + pos\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.AIFI","title":"<code>ultralytics.nn.modules.transformer.AIFI</code>","text":"<p>             Bases: <code>TransformerEncoderLayer</code></p> <p>Defines the AIFI transformer layer.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>class AIFI(TransformerEncoderLayer):\n    \"\"\"Defines the AIFI transformer layer.\"\"\"\n\n    def __init__(self, c1, cm=2048, num_heads=8, dropout=0, act=nn.GELU(), normalize_before=False):\n        \"\"\"Initialize the AIFI instance with specified parameters.\"\"\"\n        super().__init__(c1, cm, num_heads, dropout, act, normalize_before)\n\n    def forward(self, x):\n        \"\"\"Forward pass for the AIFI transformer layer.\"\"\"\n        c, h, w = x.shape[1:]\n        pos_embed = self.build_2d_sincos_position_embedding(w, h, c)\n        # Flatten [B, C, H, W] to [B, HxW, C]\n        x = super().forward(x.flatten(2).permute(0, 2, 1), pos=pos_embed.to(device=x.device, dtype=x.dtype))\n        return x.permute(0, 2, 1).view([-1, c, h, w]).contiguous()\n\n    @staticmethod\n    def build_2d_sincos_position_embedding(w, h, embed_dim=256, temperature=10000.0):\n        \"\"\"Builds 2D sine-cosine position embedding.\"\"\"\n        grid_w = torch.arange(int(w), dtype=torch.float32)\n        grid_h = torch.arange(int(h), dtype=torch.float32)\n        grid_w, grid_h = torch.meshgrid(grid_w, grid_h, indexing=\"ij\")\n        assert embed_dim % 4 == 0, \"Embed dimension must be divisible by 4 for 2D sin-cos position embedding\"\n        pos_dim = embed_dim // 4\n        omega = torch.arange(pos_dim, dtype=torch.float32) / pos_dim\n        omega = 1.0 / (temperature**omega)\n\n        out_w = grid_w.flatten()[..., None] @ omega[None]\n        out_h = grid_h.flatten()[..., None] @ omega[None]\n\n        return torch.cat([torch.sin(out_w), torch.cos(out_w), torch.sin(out_h), torch.cos(out_h)], 1)[None]\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.AIFI.__init__","title":"<code>__init__(c1, cm=2048, num_heads=8, dropout=0, act=nn.GELU(), normalize_before=False)</code>","text":"<p>Initialize the AIFI instance with specified parameters.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>def __init__(self, c1, cm=2048, num_heads=8, dropout=0, act=nn.GELU(), normalize_before=False):\n    \"\"\"Initialize the AIFI instance with specified parameters.\"\"\"\n    super().__init__(c1, cm, num_heads, dropout, act, normalize_before)\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.AIFI.build_2d_sincos_position_embedding","title":"<code>build_2d_sincos_position_embedding(w, h, embed_dim=256, temperature=10000.0)</code>  <code>staticmethod</code>","text":"<p>Builds 2D sine-cosine position embedding.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>@staticmethod\ndef build_2d_sincos_position_embedding(w, h, embed_dim=256, temperature=10000.0):\n    \"\"\"Builds 2D sine-cosine position embedding.\"\"\"\n    grid_w = torch.arange(int(w), dtype=torch.float32)\n    grid_h = torch.arange(int(h), dtype=torch.float32)\n    grid_w, grid_h = torch.meshgrid(grid_w, grid_h, indexing=\"ij\")\n    assert embed_dim % 4 == 0, \"Embed dimension must be divisible by 4 for 2D sin-cos position embedding\"\n    pos_dim = embed_dim // 4\n    omega = torch.arange(pos_dim, dtype=torch.float32) / pos_dim\n    omega = 1.0 / (temperature**omega)\n\n    out_w = grid_w.flatten()[..., None] @ omega[None]\n    out_h = grid_h.flatten()[..., None] @ omega[None]\n\n    return torch.cat([torch.sin(out_w), torch.cos(out_w), torch.sin(out_h), torch.cos(out_h)], 1)[None]\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.AIFI.forward","title":"<code>forward(x)</code>","text":"<p>Forward pass for the AIFI transformer layer.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>def forward(self, x):\n    \"\"\"Forward pass for the AIFI transformer layer.\"\"\"\n    c, h, w = x.shape[1:]\n    pos_embed = self.build_2d_sincos_position_embedding(w, h, c)\n    # Flatten [B, C, H, W] to [B, HxW, C]\n    x = super().forward(x.flatten(2).permute(0, 2, 1), pos=pos_embed.to(device=x.device, dtype=x.dtype))\n    return x.permute(0, 2, 1).view([-1, c, h, w]).contiguous()\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.TransformerLayer","title":"<code>ultralytics.nn.modules.transformer.TransformerLayer</code>","text":"<p>             Bases: <code>Module</code></p> <p>Transformer layer https://arxiv.org/abs/2010.11929 (LayerNorm layers removed for better performance).</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>class TransformerLayer(nn.Module):\n    \"\"\"Transformer layer https://arxiv.org/abs/2010.11929 (LayerNorm layers removed for better performance).\"\"\"\n\n    def __init__(self, c, num_heads):\n        \"\"\"Initializes a self-attention mechanism using linear transformations and multi-head attention.\"\"\"\n        super().__init__()\n        self.q = nn.Linear(c, c, bias=False)\n        self.k = nn.Linear(c, c, bias=False)\n        self.v = nn.Linear(c, c, bias=False)\n        self.ma = nn.MultiheadAttention(embed_dim=c, num_heads=num_heads)\n        self.fc1 = nn.Linear(c, c, bias=False)\n        self.fc2 = nn.Linear(c, c, bias=False)\n\n    def forward(self, x):\n        \"\"\"Apply a transformer block to the input x and return the output.\"\"\"\n        x = self.ma(self.q(x), self.k(x), self.v(x))[0] + x\n        return self.fc2(self.fc1(x)) + x\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.TransformerLayer.__init__","title":"<code>__init__(c, num_heads)</code>","text":"<p>Initializes a self-attention mechanism using linear transformations and multi-head attention.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>def __init__(self, c, num_heads):\n    \"\"\"Initializes a self-attention mechanism using linear transformations and multi-head attention.\"\"\"\n    super().__init__()\n    self.q = nn.Linear(c, c, bias=False)\n    self.k = nn.Linear(c, c, bias=False)\n    self.v = nn.Linear(c, c, bias=False)\n    self.ma = nn.MultiheadAttention(embed_dim=c, num_heads=num_heads)\n    self.fc1 = nn.Linear(c, c, bias=False)\n    self.fc2 = nn.Linear(c, c, bias=False)\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.TransformerLayer.forward","title":"<code>forward(x)</code>","text":"<p>Apply a transformer block to the input x and return the output.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>def forward(self, x):\n    \"\"\"Apply a transformer block to the input x and return the output.\"\"\"\n    x = self.ma(self.q(x), self.k(x), self.v(x))[0] + x\n    return self.fc2(self.fc1(x)) + x\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.TransformerBlock","title":"<code>ultralytics.nn.modules.transformer.TransformerBlock</code>","text":"<p>             Bases: <code>Module</code></p> <p>Vision Transformer https://arxiv.org/abs/2010.11929.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>class TransformerBlock(nn.Module):\n    \"\"\"Vision Transformer https://arxiv.org/abs/2010.11929.\"\"\"\n\n    def __init__(self, c1, c2, num_heads, num_layers):\n        \"\"\"Initialize a Transformer module with position embedding and specified number of heads and layers.\"\"\"\n        super().__init__()\n        self.conv = None\n        if c1 != c2:\n            self.conv = Conv(c1, c2)\n        self.linear = nn.Linear(c2, c2)  # learnable position embedding\n        self.tr = nn.Sequential(*(TransformerLayer(c2, num_heads) for _ in range(num_layers)))\n        self.c2 = c2\n\n    def forward(self, x):\n        \"\"\"Forward propagates the input through the bottleneck module.\"\"\"\n        if self.conv is not None:\n            x = self.conv(x)\n        b, _, w, h = x.shape\n        p = x.flatten(2).permute(2, 0, 1)\n        return self.tr(p + self.linear(p)).permute(1, 2, 0).reshape(b, self.c2, w, h)\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.TransformerBlock.__init__","title":"<code>__init__(c1, c2, num_heads, num_layers)</code>","text":"<p>Initialize a Transformer module with position embedding and specified number of heads and layers.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>def __init__(self, c1, c2, num_heads, num_layers):\n    \"\"\"Initialize a Transformer module with position embedding and specified number of heads and layers.\"\"\"\n    super().__init__()\n    self.conv = None\n    if c1 != c2:\n        self.conv = Conv(c1, c2)\n    self.linear = nn.Linear(c2, c2)  # learnable position embedding\n    self.tr = nn.Sequential(*(TransformerLayer(c2, num_heads) for _ in range(num_layers)))\n    self.c2 = c2\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.TransformerBlock.forward","title":"<code>forward(x)</code>","text":"<p>Forward propagates the input through the bottleneck module.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>def forward(self, x):\n    \"\"\"Forward propagates the input through the bottleneck module.\"\"\"\n    if self.conv is not None:\n        x = self.conv(x)\n    b, _, w, h = x.shape\n    p = x.flatten(2).permute(2, 0, 1)\n    return self.tr(p + self.linear(p)).permute(1, 2, 0).reshape(b, self.c2, w, h)\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.MLPBlock","title":"<code>ultralytics.nn.modules.transformer.MLPBlock</code>","text":"<p>             Bases: <code>Module</code></p> <p>Implements a single block of a multi-layer perceptron.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>class MLPBlock(nn.Module):\n    \"\"\"Implements a single block of a multi-layer perceptron.\"\"\"\n\n    def __init__(self, embedding_dim, mlp_dim, act=nn.GELU):\n        \"\"\"Initialize the MLPBlock with specified embedding dimension, MLP dimension, and activation function.\"\"\"\n        super().__init__()\n        self.lin1 = nn.Linear(embedding_dim, mlp_dim)\n        self.lin2 = nn.Linear(mlp_dim, embedding_dim)\n        self.act = act()\n\n    def forward(self, x: torch.Tensor) -&gt; torch.Tensor:\n        \"\"\"Forward pass for the MLPBlock.\"\"\"\n        return self.lin2(self.act(self.lin1(x)))\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.MLPBlock.__init__","title":"<code>__init__(embedding_dim, mlp_dim, act=nn.GELU)</code>","text":"<p>Initialize the MLPBlock with specified embedding dimension, MLP dimension, and activation function.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>def __init__(self, embedding_dim, mlp_dim, act=nn.GELU):\n    \"\"\"Initialize the MLPBlock with specified embedding dimension, MLP dimension, and activation function.\"\"\"\n    super().__init__()\n    self.lin1 = nn.Linear(embedding_dim, mlp_dim)\n    self.lin2 = nn.Linear(mlp_dim, embedding_dim)\n    self.act = act()\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.MLPBlock.forward","title":"<code>forward(x)</code>","text":"<p>Forward pass for the MLPBlock.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>def forward(self, x: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"Forward pass for the MLPBlock.\"\"\"\n    return self.lin2(self.act(self.lin1(x)))\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.MLP","title":"<code>ultralytics.nn.modules.transformer.MLP</code>","text":"<p>             Bases: <code>Module</code></p> <p>Implements a simple multi-layer perceptron (also called FFN).</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>class MLP(nn.Module):\n    \"\"\"Implements a simple multi-layer perceptron (also called FFN).\"\"\"\n\n    def __init__(self, input_dim, hidden_dim, output_dim, num_layers):\n        \"\"\"Initialize the MLP with specified input, hidden, output dimensions and number of layers.\"\"\"\n        super().__init__()\n        self.num_layers = num_layers\n        h = [hidden_dim] * (num_layers - 1)\n        self.layers = nn.ModuleList(nn.Linear(n, k) for n, k in zip([input_dim] + h, h + [output_dim]))\n\n    def forward(self, x):\n        \"\"\"Forward pass for the entire MLP.\"\"\"\n        for i, layer in enumerate(self.layers):\n            x = F.relu(layer(x)) if i &lt; self.num_layers - 1 else layer(x)\n        return x\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.MLP.__init__","title":"<code>__init__(input_dim, hidden_dim, output_dim, num_layers)</code>","text":"<p>Initialize the MLP with specified input, hidden, output dimensions and number of layers.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>def __init__(self, input_dim, hidden_dim, output_dim, num_layers):\n    \"\"\"Initialize the MLP with specified input, hidden, output dimensions and number of layers.\"\"\"\n    super().__init__()\n    self.num_layers = num_layers\n    h = [hidden_dim] * (num_layers - 1)\n    self.layers = nn.ModuleList(nn.Linear(n, k) for n, k in zip([input_dim] + h, h + [output_dim]))\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.MLP.forward","title":"<code>forward(x)</code>","text":"<p>Forward pass for the entire MLP.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>def forward(self, x):\n    \"\"\"Forward pass for the entire MLP.\"\"\"\n    for i, layer in enumerate(self.layers):\n        x = F.relu(layer(x)) if i &lt; self.num_layers - 1 else layer(x)\n    return x\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.LayerNorm2d","title":"<code>ultralytics.nn.modules.transformer.LayerNorm2d</code>","text":"<p>             Bases: <code>Module</code></p> <p>2D Layer Normalization module inspired by Detectron2 and ConvNeXt implementations.</p> <p>Original implementations in https://github.com/facebookresearch/detectron2/blob/main/detectron2/layers/batch_norm.py and https://github.com/facebookresearch/ConvNeXt/blob/main/models/convnext.py.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>class LayerNorm2d(nn.Module):\n    \"\"\"\n    2D Layer Normalization module inspired by Detectron2 and ConvNeXt implementations.\n\n    Original implementations in\n    https://github.com/facebookresearch/detectron2/blob/main/detectron2/layers/batch_norm.py\n    and\n    https://github.com/facebookresearch/ConvNeXt/blob/main/models/convnext.py.\n    \"\"\"\n\n    def __init__(self, num_channels, eps=1e-6):\n        \"\"\"Initialize LayerNorm2d with the given parameters.\"\"\"\n        super().__init__()\n        self.weight = nn.Parameter(torch.ones(num_channels))\n        self.bias = nn.Parameter(torch.zeros(num_channels))\n        self.eps = eps\n\n    def forward(self, x):\n        \"\"\"Perform forward pass for 2D layer normalization.\"\"\"\n        u = x.mean(1, keepdim=True)\n        s = (x - u).pow(2).mean(1, keepdim=True)\n        x = (x - u) / torch.sqrt(s + self.eps)\n        return self.weight[:, None, None] * x + self.bias[:, None, None]\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.LayerNorm2d.__init__","title":"<code>__init__(num_channels, eps=1e-06)</code>","text":"<p>Initialize LayerNorm2d with the given parameters.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>def __init__(self, num_channels, eps=1e-6):\n    \"\"\"Initialize LayerNorm2d with the given parameters.\"\"\"\n    super().__init__()\n    self.weight = nn.Parameter(torch.ones(num_channels))\n    self.bias = nn.Parameter(torch.zeros(num_channels))\n    self.eps = eps\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.LayerNorm2d.forward","title":"<code>forward(x)</code>","text":"<p>Perform forward pass for 2D layer normalization.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>def forward(self, x):\n    \"\"\"Perform forward pass for 2D layer normalization.\"\"\"\n    u = x.mean(1, keepdim=True)\n    s = (x - u).pow(2).mean(1, keepdim=True)\n    x = (x - u) / torch.sqrt(s + self.eps)\n    return self.weight[:, None, None] * x + self.bias[:, None, None]\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.MSDeformAttn","title":"<code>ultralytics.nn.modules.transformer.MSDeformAttn</code>","text":"<p>             Bases: <code>Module</code></p> <p>Multi-Scale Deformable Attention Module based on Deformable-DETR and PaddleDetection implementations.</p> <p>https://github.com/fundamentalvision/Deformable-DETR/blob/main/models/ops/modules/ms_deform_attn.py</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>class MSDeformAttn(nn.Module):\n    \"\"\"\n    Multi-Scale Deformable Attention Module based on Deformable-DETR and PaddleDetection implementations.\n\n    https://github.com/fundamentalvision/Deformable-DETR/blob/main/models/ops/modules/ms_deform_attn.py\n    \"\"\"\n\n    def __init__(self, d_model=256, n_levels=4, n_heads=8, n_points=4):\n        \"\"\"Initialize MSDeformAttn with the given parameters.\"\"\"\n        super().__init__()\n        if d_model % n_heads != 0:\n            raise ValueError(f\"d_model must be divisible by n_heads, but got {d_model} and {n_heads}\")\n        _d_per_head = d_model // n_heads\n        # Better to set _d_per_head to a power of 2 which is more efficient in a CUDA implementation\n        assert _d_per_head * n_heads == d_model, \"`d_model` must be divisible by `n_heads`\"\n\n        self.im2col_step = 64\n\n        self.d_model = d_model\n        self.n_levels = n_levels\n        self.n_heads = n_heads\n        self.n_points = n_points\n\n        self.sampling_offsets = nn.Linear(d_model, n_heads * n_levels * n_points * 2)\n        self.attention_weights = nn.Linear(d_model, n_heads * n_levels * n_points)\n        self.value_proj = nn.Linear(d_model, d_model)\n        self.output_proj = nn.Linear(d_model, d_model)\n\n        self._reset_parameters()\n\n    def _reset_parameters(self):\n        \"\"\"Reset module parameters.\"\"\"\n        constant_(self.sampling_offsets.weight.data, 0.0)\n        thetas = torch.arange(self.n_heads, dtype=torch.float32) * (2.0 * math.pi / self.n_heads)\n        grid_init = torch.stack([thetas.cos(), thetas.sin()], -1)\n        grid_init = (\n            (grid_init / grid_init.abs().max(-1, keepdim=True)[0])\n            .view(self.n_heads, 1, 1, 2)\n            .repeat(1, self.n_levels, self.n_points, 1)\n        )\n        for i in range(self.n_points):\n            grid_init[:, :, i, :] *= i + 1\n        with torch.no_grad():\n            self.sampling_offsets.bias = nn.Parameter(grid_init.view(-1))\n        constant_(self.attention_weights.weight.data, 0.0)\n        constant_(self.attention_weights.bias.data, 0.0)\n        xavier_uniform_(self.value_proj.weight.data)\n        constant_(self.value_proj.bias.data, 0.0)\n        xavier_uniform_(self.output_proj.weight.data)\n        constant_(self.output_proj.bias.data, 0.0)\n\n    def forward(self, query, refer_bbox, value, value_shapes, value_mask=None):\n        \"\"\"\n        Perform forward pass for multiscale deformable attention.\n\n        https://github.com/PaddlePaddle/PaddleDetection/blob/develop/ppdet/modeling/transformers/deformable_transformer.py\n\n        Args:\n            query (torch.Tensor): [bs, query_length, C]\n            refer_bbox (torch.Tensor): [bs, query_length, n_levels, 2], range in [0, 1], top-left (0,0),\n                bottom-right (1, 1), including padding area\n            value (torch.Tensor): [bs, value_length, C]\n            value_shapes (List): [n_levels, 2], [(H_0, W_0), (H_1, W_1), ..., (H_{L-1}, W_{L-1})]\n            value_mask (Tensor): [bs, value_length], True for non-padding elements, False for padding elements\n\n        Returns:\n            output (Tensor): [bs, Length_{query}, C]\n        \"\"\"\n        bs, len_q = query.shape[:2]\n        len_v = value.shape[1]\n        assert sum(s[0] * s[1] for s in value_shapes) == len_v\n\n        value = self.value_proj(value)\n        if value_mask is not None:\n            value = value.masked_fill(value_mask[..., None], float(0))\n        value = value.view(bs, len_v, self.n_heads, self.d_model // self.n_heads)\n        sampling_offsets = self.sampling_offsets(query).view(bs, len_q, self.n_heads, self.n_levels, self.n_points, 2)\n        attention_weights = self.attention_weights(query).view(bs, len_q, self.n_heads, self.n_levels * self.n_points)\n        attention_weights = F.softmax(attention_weights, -1).view(bs, len_q, self.n_heads, self.n_levels, self.n_points)\n        # N, Len_q, n_heads, n_levels, n_points, 2\n        num_points = refer_bbox.shape[-1]\n        if num_points == 2:\n            offset_normalizer = torch.as_tensor(value_shapes, dtype=query.dtype, device=query.device).flip(-1)\n            add = sampling_offsets / offset_normalizer[None, None, None, :, None, :]\n            sampling_locations = refer_bbox[:, :, None, :, None, :] + add\n        elif num_points == 4:\n            add = sampling_offsets / self.n_points * refer_bbox[:, :, None, :, None, 2:] * 0.5\n            sampling_locations = refer_bbox[:, :, None, :, None, :2] + add\n        else:\n            raise ValueError(f\"Last dim of reference_points must be 2 or 4, but got {num_points}.\")\n        output = multi_scale_deformable_attn_pytorch(value, value_shapes, sampling_locations, attention_weights)\n        return self.output_proj(output)\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.MSDeformAttn.__init__","title":"<code>__init__(d_model=256, n_levels=4, n_heads=8, n_points=4)</code>","text":"<p>Initialize MSDeformAttn with the given parameters.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>def __init__(self, d_model=256, n_levels=4, n_heads=8, n_points=4):\n    \"\"\"Initialize MSDeformAttn with the given parameters.\"\"\"\n    super().__init__()\n    if d_model % n_heads != 0:\n        raise ValueError(f\"d_model must be divisible by n_heads, but got {d_model} and {n_heads}\")\n    _d_per_head = d_model // n_heads\n    # Better to set _d_per_head to a power of 2 which is more efficient in a CUDA implementation\n    assert _d_per_head * n_heads == d_model, \"`d_model` must be divisible by `n_heads`\"\n\n    self.im2col_step = 64\n\n    self.d_model = d_model\n    self.n_levels = n_levels\n    self.n_heads = n_heads\n    self.n_points = n_points\n\n    self.sampling_offsets = nn.Linear(d_model, n_heads * n_levels * n_points * 2)\n    self.attention_weights = nn.Linear(d_model, n_heads * n_levels * n_points)\n    self.value_proj = nn.Linear(d_model, d_model)\n    self.output_proj = nn.Linear(d_model, d_model)\n\n    self._reset_parameters()\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.MSDeformAttn.forward","title":"<code>forward(query, refer_bbox, value, value_shapes, value_mask=None)</code>","text":"<p>Perform forward pass for multiscale deformable attention.</p> <p>https://github.com/PaddlePaddle/PaddleDetection/blob/develop/ppdet/modeling/transformers/deformable_transformer.py</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Tensor</code> <p>[bs, query_length, C]</p> required <code>refer_bbox</code> <code>Tensor</code> <p>[bs, query_length, n_levels, 2], range in [0, 1], top-left (0,0), bottom-right (1, 1), including padding area</p> required <code>value</code> <code>Tensor</code> <p>[bs, value_length, C]</p> required <code>value_shapes</code> <code>List</code> <p>[n_levels, 2], [(H_0, W_0), (H_1, W_1), ..., (H_{L-1}, W_{L-1})]</p> required <code>value_mask</code> <code>Tensor</code> <p>[bs, value_length], True for non-padding elements, False for padding elements</p> <code>None</code> <p>Returns:</p> Name Type Description <code>output</code> <code>Tensor</code> <p>[bs, Length_{query}, C]</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>def forward(self, query, refer_bbox, value, value_shapes, value_mask=None):\n    \"\"\"\n    Perform forward pass for multiscale deformable attention.\n\n    https://github.com/PaddlePaddle/PaddleDetection/blob/develop/ppdet/modeling/transformers/deformable_transformer.py\n\n    Args:\n        query (torch.Tensor): [bs, query_length, C]\n        refer_bbox (torch.Tensor): [bs, query_length, n_levels, 2], range in [0, 1], top-left (0,0),\n            bottom-right (1, 1), including padding area\n        value (torch.Tensor): [bs, value_length, C]\n        value_shapes (List): [n_levels, 2], [(H_0, W_0), (H_1, W_1), ..., (H_{L-1}, W_{L-1})]\n        value_mask (Tensor): [bs, value_length], True for non-padding elements, False for padding elements\n\n    Returns:\n        output (Tensor): [bs, Length_{query}, C]\n    \"\"\"\n    bs, len_q = query.shape[:2]\n    len_v = value.shape[1]\n    assert sum(s[0] * s[1] for s in value_shapes) == len_v\n\n    value = self.value_proj(value)\n    if value_mask is not None:\n        value = value.masked_fill(value_mask[..., None], float(0))\n    value = value.view(bs, len_v, self.n_heads, self.d_model // self.n_heads)\n    sampling_offsets = self.sampling_offsets(query).view(bs, len_q, self.n_heads, self.n_levels, self.n_points, 2)\n    attention_weights = self.attention_weights(query).view(bs, len_q, self.n_heads, self.n_levels * self.n_points)\n    attention_weights = F.softmax(attention_weights, -1).view(bs, len_q, self.n_heads, self.n_levels, self.n_points)\n    # N, Len_q, n_heads, n_levels, n_points, 2\n    num_points = refer_bbox.shape[-1]\n    if num_points == 2:\n        offset_normalizer = torch.as_tensor(value_shapes, dtype=query.dtype, device=query.device).flip(-1)\n        add = sampling_offsets / offset_normalizer[None, None, None, :, None, :]\n        sampling_locations = refer_bbox[:, :, None, :, None, :] + add\n    elif num_points == 4:\n        add = sampling_offsets / self.n_points * refer_bbox[:, :, None, :, None, 2:] * 0.5\n        sampling_locations = refer_bbox[:, :, None, :, None, :2] + add\n    else:\n        raise ValueError(f\"Last dim of reference_points must be 2 or 4, but got {num_points}.\")\n    output = multi_scale_deformable_attn_pytorch(value, value_shapes, sampling_locations, attention_weights)\n    return self.output_proj(output)\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.DeformableTransformerDecoderLayer","title":"<code>ultralytics.nn.modules.transformer.DeformableTransformerDecoderLayer</code>","text":"<p>             Bases: <code>Module</code></p> <p>Deformable Transformer Decoder Layer inspired by PaddleDetection and Deformable-DETR implementations.</p> <p>https://github.com/PaddlePaddle/PaddleDetection/blob/develop/ppdet/modeling/transformers/deformable_transformer.py https://github.com/fundamentalvision/Deformable-DETR/blob/main/models/deformable_transformer.py</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>class DeformableTransformerDecoderLayer(nn.Module):\n    \"\"\"\n    Deformable Transformer Decoder Layer inspired by PaddleDetection and Deformable-DETR implementations.\n\n    https://github.com/PaddlePaddle/PaddleDetection/blob/develop/ppdet/modeling/transformers/deformable_transformer.py\n    https://github.com/fundamentalvision/Deformable-DETR/blob/main/models/deformable_transformer.py\n    \"\"\"\n\n    def __init__(self, d_model=256, n_heads=8, d_ffn=1024, dropout=0.0, act=nn.ReLU(), n_levels=4, n_points=4):\n        \"\"\"Initialize the DeformableTransformerDecoderLayer with the given parameters.\"\"\"\n        super().__init__()\n\n        # Self attention\n        self.self_attn = nn.MultiheadAttention(d_model, n_heads, dropout=dropout)\n        self.dropout1 = nn.Dropout(dropout)\n        self.norm1 = nn.LayerNorm(d_model)\n\n        # Cross attention\n        self.cross_attn = MSDeformAttn(d_model, n_levels, n_heads, n_points)\n        self.dropout2 = nn.Dropout(dropout)\n        self.norm2 = nn.LayerNorm(d_model)\n\n        # FFN\n        self.linear1 = nn.Linear(d_model, d_ffn)\n        self.act = act\n        self.dropout3 = nn.Dropout(dropout)\n        self.linear2 = nn.Linear(d_ffn, d_model)\n        self.dropout4 = nn.Dropout(dropout)\n        self.norm3 = nn.LayerNorm(d_model)\n\n    @staticmethod\n    def with_pos_embed(tensor, pos):\n        \"\"\"Add positional embeddings to the input tensor, if provided.\"\"\"\n        return tensor if pos is None else tensor + pos\n\n    def forward_ffn(self, tgt):\n        \"\"\"Perform forward pass through the Feed-Forward Network part of the layer.\"\"\"\n        tgt2 = self.linear2(self.dropout3(self.act(self.linear1(tgt))))\n        tgt = tgt + self.dropout4(tgt2)\n        return self.norm3(tgt)\n\n    def forward(self, embed, refer_bbox, feats, shapes, padding_mask=None, attn_mask=None, query_pos=None):\n        \"\"\"Perform the forward pass through the entire decoder layer.\"\"\"\n\n        # Self attention\n        q = k = self.with_pos_embed(embed, query_pos)\n        tgt = self.self_attn(q.transpose(0, 1), k.transpose(0, 1), embed.transpose(0, 1), attn_mask=attn_mask)[\n            0\n        ].transpose(0, 1)\n        embed = embed + self.dropout1(tgt)\n        embed = self.norm1(embed)\n\n        # Cross attention\n        tgt = self.cross_attn(\n            self.with_pos_embed(embed, query_pos), refer_bbox.unsqueeze(2), feats, shapes, padding_mask\n        )\n        embed = embed + self.dropout2(tgt)\n        embed = self.norm2(embed)\n\n        # FFN\n        return self.forward_ffn(embed)\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.DeformableTransformerDecoderLayer.__init__","title":"<code>__init__(d_model=256, n_heads=8, d_ffn=1024, dropout=0.0, act=nn.ReLU(), n_levels=4, n_points=4)</code>","text":"<p>Initialize the DeformableTransformerDecoderLayer with the given parameters.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>def __init__(self, d_model=256, n_heads=8, d_ffn=1024, dropout=0.0, act=nn.ReLU(), n_levels=4, n_points=4):\n    \"\"\"Initialize the DeformableTransformerDecoderLayer with the given parameters.\"\"\"\n    super().__init__()\n\n    # Self attention\n    self.self_attn = nn.MultiheadAttention(d_model, n_heads, dropout=dropout)\n    self.dropout1 = nn.Dropout(dropout)\n    self.norm1 = nn.LayerNorm(d_model)\n\n    # Cross attention\n    self.cross_attn = MSDeformAttn(d_model, n_levels, n_heads, n_points)\n    self.dropout2 = nn.Dropout(dropout)\n    self.norm2 = nn.LayerNorm(d_model)\n\n    # FFN\n    self.linear1 = nn.Linear(d_model, d_ffn)\n    self.act = act\n    self.dropout3 = nn.Dropout(dropout)\n    self.linear2 = nn.Linear(d_ffn, d_model)\n    self.dropout4 = nn.Dropout(dropout)\n    self.norm3 = nn.LayerNorm(d_model)\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.DeformableTransformerDecoderLayer.forward","title":"<code>forward(embed, refer_bbox, feats, shapes, padding_mask=None, attn_mask=None, query_pos=None)</code>","text":"<p>Perform the forward pass through the entire decoder layer.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>def forward(self, embed, refer_bbox, feats, shapes, padding_mask=None, attn_mask=None, query_pos=None):\n    \"\"\"Perform the forward pass through the entire decoder layer.\"\"\"\n\n    # Self attention\n    q = k = self.with_pos_embed(embed, query_pos)\n    tgt = self.self_attn(q.transpose(0, 1), k.transpose(0, 1), embed.transpose(0, 1), attn_mask=attn_mask)[\n        0\n    ].transpose(0, 1)\n    embed = embed + self.dropout1(tgt)\n    embed = self.norm1(embed)\n\n    # Cross attention\n    tgt = self.cross_attn(\n        self.with_pos_embed(embed, query_pos), refer_bbox.unsqueeze(2), feats, shapes, padding_mask\n    )\n    embed = embed + self.dropout2(tgt)\n    embed = self.norm2(embed)\n\n    # FFN\n    return self.forward_ffn(embed)\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.DeformableTransformerDecoderLayer.forward_ffn","title":"<code>forward_ffn(tgt)</code>","text":"<p>Perform forward pass through the Feed-Forward Network part of the layer.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>def forward_ffn(self, tgt):\n    \"\"\"Perform forward pass through the Feed-Forward Network part of the layer.\"\"\"\n    tgt2 = self.linear2(self.dropout3(self.act(self.linear1(tgt))))\n    tgt = tgt + self.dropout4(tgt2)\n    return self.norm3(tgt)\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.DeformableTransformerDecoderLayer.with_pos_embed","title":"<code>with_pos_embed(tensor, pos)</code>  <code>staticmethod</code>","text":"<p>Add positional embeddings to the input tensor, if provided.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>@staticmethod\ndef with_pos_embed(tensor, pos):\n    \"\"\"Add positional embeddings to the input tensor, if provided.\"\"\"\n    return tensor if pos is None else tensor + pos\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.DeformableTransformerDecoder","title":"<code>ultralytics.nn.modules.transformer.DeformableTransformerDecoder</code>","text":"<p>             Bases: <code>Module</code></p> <p>Implementation of Deformable Transformer Decoder based on PaddleDetection.</p> <p>https://github.com/PaddlePaddle/PaddleDetection/blob/develop/ppdet/modeling/transformers/deformable_transformer.py</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>class DeformableTransformerDecoder(nn.Module):\n    \"\"\"\n    Implementation of Deformable Transformer Decoder based on PaddleDetection.\n\n    https://github.com/PaddlePaddle/PaddleDetection/blob/develop/ppdet/modeling/transformers/deformable_transformer.py\n    \"\"\"\n\n    def __init__(self, hidden_dim, decoder_layer, num_layers, eval_idx=-1):\n        \"\"\"Initialize the DeformableTransformerDecoder with the given parameters.\"\"\"\n        super().__init__()\n        self.layers = _get_clones(decoder_layer, num_layers)\n        self.num_layers = num_layers\n        self.hidden_dim = hidden_dim\n        self.eval_idx = eval_idx if eval_idx &gt;= 0 else num_layers + eval_idx\n\n    def forward(\n        self,\n        embed,  # decoder embeddings\n        refer_bbox,  # anchor\n        feats,  # image features\n        shapes,  # feature shapes\n        bbox_head,\n        score_head,\n        pos_mlp,\n        attn_mask=None,\n        padding_mask=None,\n    ):\n        \"\"\"Perform the forward pass through the entire decoder.\"\"\"\n        output = embed\n        dec_bboxes = []\n        dec_cls = []\n        last_refined_bbox = None\n        refer_bbox = refer_bbox.sigmoid()\n        for i, layer in enumerate(self.layers):\n            output = layer(output, refer_bbox, feats, shapes, padding_mask, attn_mask, pos_mlp(refer_bbox))\n\n            bbox = bbox_head[i](output)\n            refined_bbox = torch.sigmoid(bbox + inverse_sigmoid(refer_bbox))\n\n            if self.training:\n                dec_cls.append(score_head[i](output))\n                if i == 0:\n                    dec_bboxes.append(refined_bbox)\n                else:\n                    dec_bboxes.append(torch.sigmoid(bbox + inverse_sigmoid(last_refined_bbox)))\n            elif i == self.eval_idx:\n                dec_cls.append(score_head[i](output))\n                dec_bboxes.append(refined_bbox)\n                break\n\n            last_refined_bbox = refined_bbox\n            refer_bbox = refined_bbox.detach() if self.training else refined_bbox\n\n        return torch.stack(dec_bboxes), torch.stack(dec_cls)\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.DeformableTransformerDecoder.__init__","title":"<code>__init__(hidden_dim, decoder_layer, num_layers, eval_idx=-1)</code>","text":"<p>Initialize the DeformableTransformerDecoder with the given parameters.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>def __init__(self, hidden_dim, decoder_layer, num_layers, eval_idx=-1):\n    \"\"\"Initialize the DeformableTransformerDecoder with the given parameters.\"\"\"\n    super().__init__()\n    self.layers = _get_clones(decoder_layer, num_layers)\n    self.num_layers = num_layers\n    self.hidden_dim = hidden_dim\n    self.eval_idx = eval_idx if eval_idx &gt;= 0 else num_layers + eval_idx\n</code></pre>"},{"location":"reference/nn/modules/transformer/#ultralytics.nn.modules.transformer.DeformableTransformerDecoder.forward","title":"<code>forward(embed, refer_bbox, feats, shapes, bbox_head, score_head, pos_mlp, attn_mask=None, padding_mask=None)</code>","text":"<p>Perform the forward pass through the entire decoder.</p> Source code in <code>ultralytics/nn/modules/transformer.py</code> <pre><code>def forward(\n    self,\n    embed,  # decoder embeddings\n    refer_bbox,  # anchor\n    feats,  # image features\n    shapes,  # feature shapes\n    bbox_head,\n    score_head,\n    pos_mlp,\n    attn_mask=None,\n    padding_mask=None,\n):\n    \"\"\"Perform the forward pass through the entire decoder.\"\"\"\n    output = embed\n    dec_bboxes = []\n    dec_cls = []\n    last_refined_bbox = None\n    refer_bbox = refer_bbox.sigmoid()\n    for i, layer in enumerate(self.layers):\n        output = layer(output, refer_bbox, feats, shapes, padding_mask, attn_mask, pos_mlp(refer_bbox))\n\n        bbox = bbox_head[i](output)\n        refined_bbox = torch.sigmoid(bbox + inverse_sigmoid(refer_bbox))\n\n        if self.training:\n            dec_cls.append(score_head[i](output))\n            if i == 0:\n                dec_bboxes.append(refined_bbox)\n            else:\n                dec_bboxes.append(torch.sigmoid(bbox + inverse_sigmoid(last_refined_bbox)))\n        elif i == self.eval_idx:\n            dec_cls.append(score_head[i](output))\n            dec_bboxes.append(refined_bbox)\n            break\n\n        last_refined_bbox = refined_bbox\n        refer_bbox = refined_bbox.detach() if self.training else refined_bbox\n\n    return torch.stack(dec_bboxes), torch.stack(dec_cls)\n</code></pre>"},{"location":"reference/nn/modules/utils/","title":"Reference for <code>ultralytics/nn/modules/utils.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/nn/modules/utils.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/nn/modules/utils/#ultralytics.nn.modules.utils._get_clones","title":"<code>ultralytics.nn.modules.utils._get_clones(module, n)</code>","text":"<p>Create a list of cloned modules from the given module.</p> Source code in <code>ultralytics/nn/modules/utils.py</code> <pre><code>def _get_clones(module, n):\n    \"\"\"Create a list of cloned modules from the given module.\"\"\"\n    return nn.ModuleList([copy.deepcopy(module) for _ in range(n)])\n</code></pre>"},{"location":"reference/nn/modules/utils/#ultralytics.nn.modules.utils.bias_init_with_prob","title":"<code>ultralytics.nn.modules.utils.bias_init_with_prob(prior_prob=0.01)</code>","text":"<p>Initialize conv/fc bias value according to a given probability value.</p> Source code in <code>ultralytics/nn/modules/utils.py</code> <pre><code>def bias_init_with_prob(prior_prob=0.01):\n    \"\"\"Initialize conv/fc bias value according to a given probability value.\"\"\"\n    return float(-np.log((1 - prior_prob) / prior_prob))  # return bias_init\n</code></pre>"},{"location":"reference/nn/modules/utils/#ultralytics.nn.modules.utils.linear_init_","title":"<code>ultralytics.nn.modules.utils.linear_init_(module)</code>","text":"<p>Initialize the weights and biases of a linear module.</p> Source code in <code>ultralytics/nn/modules/utils.py</code> <pre><code>def linear_init_(module):\n    \"\"\"Initialize the weights and biases of a linear module.\"\"\"\n    bound = 1 / math.sqrt(module.weight.shape[0])\n    uniform_(module.weight, -bound, bound)\n    if hasattr(module, \"bias\") and module.bias is not None:\n        uniform_(module.bias, -bound, bound)\n</code></pre>"},{"location":"reference/nn/modules/utils/#ultralytics.nn.modules.utils.inverse_sigmoid","title":"<code>ultralytics.nn.modules.utils.inverse_sigmoid(x, eps=1e-05)</code>","text":"<p>Calculate the inverse sigmoid function for a tensor.</p> Source code in <code>ultralytics/nn/modules/utils.py</code> <pre><code>def inverse_sigmoid(x, eps=1e-5):\n    \"\"\"Calculate the inverse sigmoid function for a tensor.\"\"\"\n    x = x.clamp(min=0, max=1)\n    x1 = x.clamp(min=eps)\n    x2 = (1 - x).clamp(min=eps)\n    return torch.log(x1 / x2)\n</code></pre>"},{"location":"reference/nn/modules/utils/#ultralytics.nn.modules.utils.multi_scale_deformable_attn_pytorch","title":"<code>ultralytics.nn.modules.utils.multi_scale_deformable_attn_pytorch(value, value_spatial_shapes, sampling_locations, attention_weights)</code>","text":"<p>Multi-scale deformable attention.</p> <p>https://github.com/IDEA-Research/detrex/blob/main/detrex/layers/multi_scale_deform_attn.py</p> Source code in <code>ultralytics/nn/modules/utils.py</code> <pre><code>def multi_scale_deformable_attn_pytorch(\n    value: torch.Tensor,\n    value_spatial_shapes: torch.Tensor,\n    sampling_locations: torch.Tensor,\n    attention_weights: torch.Tensor,\n) -&gt; torch.Tensor:\n    \"\"\"\n    Multi-scale deformable attention.\n\n    https://github.com/IDEA-Research/detrex/blob/main/detrex/layers/multi_scale_deform_attn.py\n    \"\"\"\n\n    bs, _, num_heads, embed_dims = value.shape\n    _, num_queries, num_heads, num_levels, num_points, _ = sampling_locations.shape\n    value_list = value.split([H_ * W_ for H_, W_ in value_spatial_shapes], dim=1)\n    sampling_grids = 2 * sampling_locations - 1\n    sampling_value_list = []\n    for level, (H_, W_) in enumerate(value_spatial_shapes):\n        # bs, H_*W_, num_heads, embed_dims -&gt;\n        # bs, H_*W_, num_heads*embed_dims -&gt;\n        # bs, num_heads*embed_dims, H_*W_ -&gt;\n        # bs*num_heads, embed_dims, H_, W_\n        value_l_ = value_list[level].flatten(2).transpose(1, 2).reshape(bs * num_heads, embed_dims, H_, W_)\n        # bs, num_queries, num_heads, num_points, 2 -&gt;\n        # bs, num_heads, num_queries, num_points, 2 -&gt;\n        # bs*num_heads, num_queries, num_points, 2\n        sampling_grid_l_ = sampling_grids[:, :, :, level].transpose(1, 2).flatten(0, 1)\n        # bs*num_heads, embed_dims, num_queries, num_points\n        sampling_value_l_ = F.grid_sample(\n            value_l_, sampling_grid_l_, mode=\"bilinear\", padding_mode=\"zeros\", align_corners=False\n        )\n        sampling_value_list.append(sampling_value_l_)\n    # (bs, num_queries, num_heads, num_levels, num_points) -&gt;\n    # (bs, num_heads, num_queries, num_levels, num_points) -&gt;\n    # (bs, num_heads, 1, num_queries, num_levels*num_points)\n    attention_weights = attention_weights.transpose(1, 2).reshape(\n        bs * num_heads, 1, num_queries, num_levels * num_points\n    )\n    output = (\n        (torch.stack(sampling_value_list, dim=-2).flatten(-2) * attention_weights)\n        .sum(-1)\n        .view(bs, num_heads * embed_dims, num_queries)\n    )\n    return output.transpose(1, 2).contiguous()\n</code></pre>"},{"location":"reference/solutions/ai_gym/","title":"Reference for <code>ultralytics/solutions/ai_gym.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/solutions/ai_gym.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/solutions/ai_gym/#ultralytics.solutions.ai_gym.AIGym","title":"<code>ultralytics.solutions.ai_gym.AIGym</code>","text":"<p>A class to manage the gym steps of people in a real-time video stream based on their poses.</p> Source code in <code>ultralytics/solutions/ai_gym.py</code> <pre><code>class AIGym:\n    \"\"\"A class to manage the gym steps of people in a real-time video stream based on their poses.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initializes the AIGym with default values for Visual and Image parameters.\"\"\"\n\n        # Image and line thickness\n        self.im0 = None\n        self.tf = None\n\n        # Keypoints and count information\n        self.keypoints = None\n        self.poseup_angle = None\n        self.posedown_angle = None\n        self.threshold = 0.001\n\n        # Store stage, count and angle information\n        self.angle = None\n        self.count = None\n        self.stage = None\n        self.pose_type = \"pushup\"\n        self.kpts_to_check = None\n\n        # Visual Information\n        self.view_img = False\n        self.annotator = None\n\n        # Check if environment support imshow\n        self.env_check = check_imshow(warn=True)\n\n    def set_args(\n        self,\n        kpts_to_check,\n        line_thickness=2,\n        view_img=False,\n        pose_up_angle=145.0,\n        pose_down_angle=90.0,\n        pose_type=\"pullup\",\n    ):\n        \"\"\"\n        Configures the AIGym line_thickness, save image and view image parameters\n        Args:\n            kpts_to_check (list): 3 keypoints for counting\n            line_thickness (int): Line thickness for bounding boxes.\n            view_img (bool): display the im0\n            pose_up_angle (float): Angle to set pose position up\n            pose_down_angle (float): Angle to set pose position down\n            pose_type: \"pushup\", \"pullup\" or \"abworkout\"\n        \"\"\"\n        self.kpts_to_check = kpts_to_check\n        self.tf = line_thickness\n        self.view_img = view_img\n        self.poseup_angle = pose_up_angle\n        self.posedown_angle = pose_down_angle\n        self.pose_type = pose_type\n\n    def start_counting(self, im0, results, frame_count):\n        \"\"\"\n        Function used to count the gym steps\n        Args:\n            im0 (ndarray): Current frame from the video stream.\n            results: Pose estimation data\n            frame_count: store current frame count\n        \"\"\"\n        self.im0 = im0\n        if frame_count == 1:\n            self.count = [0] * len(results[0])\n            self.angle = [0] * len(results[0])\n            self.stage = [\"-\" for _ in results[0]]\n        self.keypoints = results[0].keypoints.data\n        self.annotator = Annotator(im0, line_width=2)\n\n        for ind, k in enumerate(reversed(self.keypoints)):\n            if self.pose_type == \"pushup\" or self.pose_type == \"pullup\":\n                self.angle[ind] = self.annotator.estimate_pose_angle(\n                    k[int(self.kpts_to_check[0])].cpu(),\n                    k[int(self.kpts_to_check[1])].cpu(),\n                    k[int(self.kpts_to_check[2])].cpu(),\n                )\n                self.im0 = self.annotator.draw_specific_points(k, self.kpts_to_check, shape=(640, 640), radius=10)\n\n            if self.pose_type == \"abworkout\":\n                self.angle[ind] = self.annotator.estimate_pose_angle(\n                    k[int(self.kpts_to_check[0])].cpu(),\n                    k[int(self.kpts_to_check[1])].cpu(),\n                    k[int(self.kpts_to_check[2])].cpu(),\n                )\n                self.im0 = self.annotator.draw_specific_points(k, self.kpts_to_check, shape=(640, 640), radius=10)\n                if self.angle[ind] &gt; self.poseup_angle:\n                    self.stage[ind] = \"down\"\n                if self.angle[ind] &lt; self.posedown_angle and self.stage[ind] == \"down\":\n                    self.stage[ind] = \"up\"\n                    self.count[ind] += 1\n                self.annotator.plot_angle_and_count_and_stage(\n                    angle_text=self.angle[ind],\n                    count_text=self.count[ind],\n                    stage_text=self.stage[ind],\n                    center_kpt=k[int(self.kpts_to_check[1])],\n                    line_thickness=self.tf,\n                )\n\n            if self.pose_type == \"pushup\":\n                if self.angle[ind] &gt; self.poseup_angle:\n                    self.stage[ind] = \"up\"\n                if self.angle[ind] &lt; self.posedown_angle and self.stage[ind] == \"up\":\n                    self.stage[ind] = \"down\"\n                    self.count[ind] += 1\n                self.annotator.plot_angle_and_count_and_stage(\n                    angle_text=self.angle[ind],\n                    count_text=self.count[ind],\n                    stage_text=self.stage[ind],\n                    center_kpt=k[int(self.kpts_to_check[1])],\n                    line_thickness=self.tf,\n                )\n            if self.pose_type == \"pullup\":\n                if self.angle[ind] &gt; self.poseup_angle:\n                    self.stage[ind] = \"down\"\n                if self.angle[ind] &lt; self.posedown_angle and self.stage[ind] == \"down\":\n                    self.stage[ind] = \"up\"\n                    self.count[ind] += 1\n                self.annotator.plot_angle_and_count_and_stage(\n                    angle_text=self.angle[ind],\n                    count_text=self.count[ind],\n                    stage_text=self.stage[ind],\n                    center_kpt=k[int(self.kpts_to_check[1])],\n                    line_thickness=self.tf,\n                )\n\n            self.annotator.kpts(k, shape=(640, 640), radius=1, kpt_line=True)\n\n        if self.env_check and self.view_img:\n            cv2.imshow(\"Ultralytics YOLOv8 AI GYM\", self.im0)\n            if cv2.waitKey(1) &amp; 0xFF == ord(\"q\"):\n                return\n\n        return self.im0\n</code></pre>"},{"location":"reference/solutions/ai_gym/#ultralytics.solutions.ai_gym.AIGym.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the AIGym with default values for Visual and Image parameters.</p> Source code in <code>ultralytics/solutions/ai_gym.py</code> <pre><code>def __init__(self):\n    \"\"\"Initializes the AIGym with default values for Visual and Image parameters.\"\"\"\n\n    # Image and line thickness\n    self.im0 = None\n    self.tf = None\n\n    # Keypoints and count information\n    self.keypoints = None\n    self.poseup_angle = None\n    self.posedown_angle = None\n    self.threshold = 0.001\n\n    # Store stage, count and angle information\n    self.angle = None\n    self.count = None\n    self.stage = None\n    self.pose_type = \"pushup\"\n    self.kpts_to_check = None\n\n    # Visual Information\n    self.view_img = False\n    self.annotator = None\n\n    # Check if environment support imshow\n    self.env_check = check_imshow(warn=True)\n</code></pre>"},{"location":"reference/solutions/ai_gym/#ultralytics.solutions.ai_gym.AIGym.set_args","title":"<code>set_args(kpts_to_check, line_thickness=2, view_img=False, pose_up_angle=145.0, pose_down_angle=90.0, pose_type='pullup')</code>","text":"<p>Configures the AIGym line_thickness, save image and view image parameters Args:     kpts_to_check (list): 3 keypoints for counting     line_thickness (int): Line thickness for bounding boxes.     view_img (bool): display the im0     pose_up_angle (float): Angle to set pose position up     pose_down_angle (float): Angle to set pose position down     pose_type: \"pushup\", \"pullup\" or \"abworkout\"</p> Source code in <code>ultralytics/solutions/ai_gym.py</code> <pre><code>def set_args(\n    self,\n    kpts_to_check,\n    line_thickness=2,\n    view_img=False,\n    pose_up_angle=145.0,\n    pose_down_angle=90.0,\n    pose_type=\"pullup\",\n):\n    \"\"\"\n    Configures the AIGym line_thickness, save image and view image parameters\n    Args:\n        kpts_to_check (list): 3 keypoints for counting\n        line_thickness (int): Line thickness for bounding boxes.\n        view_img (bool): display the im0\n        pose_up_angle (float): Angle to set pose position up\n        pose_down_angle (float): Angle to set pose position down\n        pose_type: \"pushup\", \"pullup\" or \"abworkout\"\n    \"\"\"\n    self.kpts_to_check = kpts_to_check\n    self.tf = line_thickness\n    self.view_img = view_img\n    self.poseup_angle = pose_up_angle\n    self.posedown_angle = pose_down_angle\n    self.pose_type = pose_type\n</code></pre>"},{"location":"reference/solutions/ai_gym/#ultralytics.solutions.ai_gym.AIGym.start_counting","title":"<code>start_counting(im0, results, frame_count)</code>","text":"<p>Function used to count the gym steps Args:     im0 (ndarray): Current frame from the video stream.     results: Pose estimation data     frame_count: store current frame count</p> Source code in <code>ultralytics/solutions/ai_gym.py</code> <pre><code>def start_counting(self, im0, results, frame_count):\n    \"\"\"\n    Function used to count the gym steps\n    Args:\n        im0 (ndarray): Current frame from the video stream.\n        results: Pose estimation data\n        frame_count: store current frame count\n    \"\"\"\n    self.im0 = im0\n    if frame_count == 1:\n        self.count = [0] * len(results[0])\n        self.angle = [0] * len(results[0])\n        self.stage = [\"-\" for _ in results[0]]\n    self.keypoints = results[0].keypoints.data\n    self.annotator = Annotator(im0, line_width=2)\n\n    for ind, k in enumerate(reversed(self.keypoints)):\n        if self.pose_type == \"pushup\" or self.pose_type == \"pullup\":\n            self.angle[ind] = self.annotator.estimate_pose_angle(\n                k[int(self.kpts_to_check[0])].cpu(),\n                k[int(self.kpts_to_check[1])].cpu(),\n                k[int(self.kpts_to_check[2])].cpu(),\n            )\n            self.im0 = self.annotator.draw_specific_points(k, self.kpts_to_check, shape=(640, 640), radius=10)\n\n        if self.pose_type == \"abworkout\":\n            self.angle[ind] = self.annotator.estimate_pose_angle(\n                k[int(self.kpts_to_check[0])].cpu(),\n                k[int(self.kpts_to_check[1])].cpu(),\n                k[int(self.kpts_to_check[2])].cpu(),\n            )\n            self.im0 = self.annotator.draw_specific_points(k, self.kpts_to_check, shape=(640, 640), radius=10)\n            if self.angle[ind] &gt; self.poseup_angle:\n                self.stage[ind] = \"down\"\n            if self.angle[ind] &lt; self.posedown_angle and self.stage[ind] == \"down\":\n                self.stage[ind] = \"up\"\n                self.count[ind] += 1\n            self.annotator.plot_angle_and_count_and_stage(\n                angle_text=self.angle[ind],\n                count_text=self.count[ind],\n                stage_text=self.stage[ind],\n                center_kpt=k[int(self.kpts_to_check[1])],\n                line_thickness=self.tf,\n            )\n\n        if self.pose_type == \"pushup\":\n            if self.angle[ind] &gt; self.poseup_angle:\n                self.stage[ind] = \"up\"\n            if self.angle[ind] &lt; self.posedown_angle and self.stage[ind] == \"up\":\n                self.stage[ind] = \"down\"\n                self.count[ind] += 1\n            self.annotator.plot_angle_and_count_and_stage(\n                angle_text=self.angle[ind],\n                count_text=self.count[ind],\n                stage_text=self.stage[ind],\n                center_kpt=k[int(self.kpts_to_check[1])],\n                line_thickness=self.tf,\n            )\n        if self.pose_type == \"pullup\":\n            if self.angle[ind] &gt; self.poseup_angle:\n                self.stage[ind] = \"down\"\n            if self.angle[ind] &lt; self.posedown_angle and self.stage[ind] == \"down\":\n                self.stage[ind] = \"up\"\n                self.count[ind] += 1\n            self.annotator.plot_angle_and_count_and_stage(\n                angle_text=self.angle[ind],\n                count_text=self.count[ind],\n                stage_text=self.stage[ind],\n                center_kpt=k[int(self.kpts_to_check[1])],\n                line_thickness=self.tf,\n            )\n\n        self.annotator.kpts(k, shape=(640, 640), radius=1, kpt_line=True)\n\n    if self.env_check and self.view_img:\n        cv2.imshow(\"Ultralytics YOLOv8 AI GYM\", self.im0)\n        if cv2.waitKey(1) &amp; 0xFF == ord(\"q\"):\n            return\n\n    return self.im0\n</code></pre>"},{"location":"reference/solutions/distance_calculation/","title":"Reference for <code>ultralytics/solutions/distance_calculation.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/solutions/distance_calculation.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/solutions/distance_calculation/#ultralytics.solutions.distance_calculation.DistanceCalculation","title":"<code>ultralytics.solutions.distance_calculation.DistanceCalculation</code>","text":"<p>A class to calculate distance between two objects in real-time video stream based on their tracks.</p> Source code in <code>ultralytics/solutions/distance_calculation.py</code> <pre><code>class DistanceCalculation:\n    \"\"\"A class to calculate distance between two objects in real-time video stream based on their tracks.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initializes the distance calculation class with default values for Visual, Image, track and distance\n        parameters.\n        \"\"\"\n\n        # Visual &amp; im0 information\n        self.im0 = None\n        self.annotator = None\n        self.view_img = False\n        self.line_color = (255, 255, 0)\n        self.centroid_color = (255, 0, 255)\n\n        # Predict/track information\n        self.clss = None\n        self.names = None\n        self.boxes = None\n        self.line_thickness = 2\n        self.trk_ids = None\n\n        # Distance calculation information\n        self.centroids = []\n        self.pixel_per_meter = 10\n\n        # Mouse event\n        self.left_mouse_count = 0\n        self.selected_boxes = {}\n\n        # Check if environment support imshow\n        self.env_check = check_imshow(warn=True)\n\n    def set_args(\n        self,\n        names,\n        pixels_per_meter=10,\n        view_img=False,\n        line_thickness=2,\n        line_color=(255, 255, 0),\n        centroid_color=(255, 0, 255),\n    ):\n        \"\"\"\n        Configures the distance calculation and display parameters.\n\n        Args:\n            names (dict): object detection classes names\n            pixels_per_meter (int): Number of pixels in meter\n            view_img (bool): Flag indicating frame display\n            line_thickness (int): Line thickness for bounding boxes.\n            line_color (RGB): color of centroids line\n            centroid_color (RGB): colors of bbox centroids\n        \"\"\"\n        self.names = names\n        self.pixel_per_meter = pixels_per_meter\n        self.view_img = view_img\n        self.line_thickness = line_thickness\n        self.line_color = line_color\n        self.centroid_color = centroid_color\n\n    def mouse_event_for_distance(self, event, x, y, flags, param):\n        \"\"\"\n        This function is designed to move region with mouse events in a real-time video stream.\n\n        Args:\n            event (int): The type of mouse event (e.g., cv2.EVENT_MOUSEMOVE, cv2.EVENT_LBUTTONDOWN, etc.).\n            x (int): The x-coordinate of the mouse pointer.\n            y (int): The y-coordinate of the mouse pointer.\n            flags (int): Any flags associated with the event (e.g., cv2.EVENT_FLAG_CTRLKEY,\n                cv2.EVENT_FLAG_SHIFTKEY, etc.).\n            param (dict): Additional parameters you may want to pass to the function.\n        \"\"\"\n        global selected_boxes\n        global left_mouse_count\n        if event == cv2.EVENT_LBUTTONDOWN:\n            self.left_mouse_count += 1\n            if self.left_mouse_count &lt;= 2:\n                for box, track_id in zip(self.boxes, self.trk_ids):\n                    if box[0] &lt; x &lt; box[2] and box[1] &lt; y &lt; box[3]:\n                        if track_id not in self.selected_boxes:\n                            self.selected_boxes[track_id] = []\n                            self.selected_boxes[track_id] = box\n\n        if event == cv2.EVENT_RBUTTONDOWN:\n            self.selected_boxes = {}\n            self.left_mouse_count = 0\n\n    def extract_tracks(self, tracks):\n        \"\"\"\n        Extracts results from the provided data.\n\n        Args:\n            tracks (list): List of tracks obtained from the object tracking process.\n        \"\"\"\n        self.boxes = tracks[0].boxes.xyxy.cpu()\n        self.clss = tracks[0].boxes.cls.cpu().tolist()\n        self.trk_ids = tracks[0].boxes.id.int().cpu().tolist()\n\n    def calculate_centroid(self, box):\n        \"\"\"\n        Calculate the centroid of bounding box\n        Args:\n            box (list): Bounding box data\n        \"\"\"\n        return int((box[0] + box[2]) // 2), int((box[1] + box[3]) // 2)\n\n    def calculate_distance(self, centroid1, centroid2):\n        \"\"\"\n        Calculate distance between two centroids\n        Args:\n            centroid1 (point): First bounding box data\n            centroid2 (point): Second bounding box data\n        \"\"\"\n        pixel_distance = math.sqrt((centroid1[0] - centroid2[0]) ** 2 + (centroid1[1] - centroid2[1]) ** 2)\n        return pixel_distance / self.pixel_per_meter\n\n    def plot_distance_and_line(self, distance):\n        \"\"\"\n        Plot the distance and line on frame\n        Args:\n            distance (float): Distance between two centroids\n        \"\"\"\n        cv2.rectangle(self.im0, (15, 25), (280, 70), (255, 255, 255), -1)\n        cv2.putText(\n            self.im0, f\"Distance : {distance:.2f}m\", (20, 55), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 0), 2, cv2.LINE_AA\n        )\n        cv2.line(self.im0, self.centroids[0], self.centroids[1], self.line_color, 3)\n        cv2.circle(self.im0, self.centroids[0], 6, self.centroid_color, -1)\n        cv2.circle(self.im0, self.centroids[1], 6, self.centroid_color, -1)\n\n    def start_process(self, im0, tracks):\n        \"\"\"\n        Calculate distance between two bounding boxes based on tracking data\n        Args:\n            im0 (nd array): Image\n            tracks (list): List of tracks obtained from the object tracking process.\n        \"\"\"\n        self.im0 = im0\n        if tracks[0].boxes.id is None:\n            if self.view_img:\n                self.display_frames()\n                return\n            else:\n                return\n\n        self.extract_tracks(tracks)\n\n        self.annotator = Annotator(self.im0, line_width=2)\n\n        for box, cls, track_id in zip(self.boxes, self.clss, self.trk_ids):\n            self.annotator.box_label(box, color=colors(int(cls), True), label=self.names[int(cls)])\n\n            if len(self.selected_boxes) == 2:\n                for trk_id, _ in self.selected_boxes.items():\n                    if trk_id == track_id:\n                        self.selected_boxes[track_id] = box\n\n        if len(self.selected_boxes) == 2:\n            for trk_id, box in self.selected_boxes.items():\n                centroid = self.calculate_centroid(self.selected_boxes[trk_id])\n                self.centroids.append(centroid)\n\n            distance = self.calculate_distance(self.centroids[0], self.centroids[1])\n            self.plot_distance_and_line(distance)\n\n        self.centroids = []\n\n        if self.view_img and self.env_check:\n            self.display_frames()\n\n        return im0\n\n    def display_frames(self):\n        \"\"\"Display frame.\"\"\"\n        cv2.namedWindow(\"Ultralytics Distance Estimation\")\n        cv2.setMouseCallback(\"Ultralytics Distance Estimation\", self.mouse_event_for_distance)\n        cv2.imshow(\"Ultralytics Distance Estimation\", self.im0)\n\n        if cv2.waitKey(1) &amp; 0xFF == ord(\"q\"):\n            return\n</code></pre>"},{"location":"reference/solutions/distance_calculation/#ultralytics.solutions.distance_calculation.DistanceCalculation.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the distance calculation class with default values for Visual, Image, track and distance parameters.</p> Source code in <code>ultralytics/solutions/distance_calculation.py</code> <pre><code>def __init__(self):\n    \"\"\"Initializes the distance calculation class with default values for Visual, Image, track and distance\n    parameters.\n    \"\"\"\n\n    # Visual &amp; im0 information\n    self.im0 = None\n    self.annotator = None\n    self.view_img = False\n    self.line_color = (255, 255, 0)\n    self.centroid_color = (255, 0, 255)\n\n    # Predict/track information\n    self.clss = None\n    self.names = None\n    self.boxes = None\n    self.line_thickness = 2\n    self.trk_ids = None\n\n    # Distance calculation information\n    self.centroids = []\n    self.pixel_per_meter = 10\n\n    # Mouse event\n    self.left_mouse_count = 0\n    self.selected_boxes = {}\n\n    # Check if environment support imshow\n    self.env_check = check_imshow(warn=True)\n</code></pre>"},{"location":"reference/solutions/distance_calculation/#ultralytics.solutions.distance_calculation.DistanceCalculation.calculate_centroid","title":"<code>calculate_centroid(box)</code>","text":"<p>Calculate the centroid of bounding box Args:     box (list): Bounding box data</p> Source code in <code>ultralytics/solutions/distance_calculation.py</code> <pre><code>def calculate_centroid(self, box):\n    \"\"\"\n    Calculate the centroid of bounding box\n    Args:\n        box (list): Bounding box data\n    \"\"\"\n    return int((box[0] + box[2]) // 2), int((box[1] + box[3]) // 2)\n</code></pre>"},{"location":"reference/solutions/distance_calculation/#ultralytics.solutions.distance_calculation.DistanceCalculation.calculate_distance","title":"<code>calculate_distance(centroid1, centroid2)</code>","text":"<p>Calculate distance between two centroids Args:     centroid1 (point): First bounding box data     centroid2 (point): Second bounding box data</p> Source code in <code>ultralytics/solutions/distance_calculation.py</code> <pre><code>def calculate_distance(self, centroid1, centroid2):\n    \"\"\"\n    Calculate distance between two centroids\n    Args:\n        centroid1 (point): First bounding box data\n        centroid2 (point): Second bounding box data\n    \"\"\"\n    pixel_distance = math.sqrt((centroid1[0] - centroid2[0]) ** 2 + (centroid1[1] - centroid2[1]) ** 2)\n    return pixel_distance / self.pixel_per_meter\n</code></pre>"},{"location":"reference/solutions/distance_calculation/#ultralytics.solutions.distance_calculation.DistanceCalculation.display_frames","title":"<code>display_frames()</code>","text":"<p>Display frame.</p> Source code in <code>ultralytics/solutions/distance_calculation.py</code> <pre><code>def display_frames(self):\n    \"\"\"Display frame.\"\"\"\n    cv2.namedWindow(\"Ultralytics Distance Estimation\")\n    cv2.setMouseCallback(\"Ultralytics Distance Estimation\", self.mouse_event_for_distance)\n    cv2.imshow(\"Ultralytics Distance Estimation\", self.im0)\n\n    if cv2.waitKey(1) &amp; 0xFF == ord(\"q\"):\n        return\n</code></pre>"},{"location":"reference/solutions/distance_calculation/#ultralytics.solutions.distance_calculation.DistanceCalculation.extract_tracks","title":"<code>extract_tracks(tracks)</code>","text":"<p>Extracts results from the provided data.</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>list</code> <p>List of tracks obtained from the object tracking process.</p> required Source code in <code>ultralytics/solutions/distance_calculation.py</code> <pre><code>def extract_tracks(self, tracks):\n    \"\"\"\n    Extracts results from the provided data.\n\n    Args:\n        tracks (list): List of tracks obtained from the object tracking process.\n    \"\"\"\n    self.boxes = tracks[0].boxes.xyxy.cpu()\n    self.clss = tracks[0].boxes.cls.cpu().tolist()\n    self.trk_ids = tracks[0].boxes.id.int().cpu().tolist()\n</code></pre>"},{"location":"reference/solutions/distance_calculation/#ultralytics.solutions.distance_calculation.DistanceCalculation.mouse_event_for_distance","title":"<code>mouse_event_for_distance(event, x, y, flags, param)</code>","text":"<p>This function is designed to move region with mouse events in a real-time video stream.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>int</code> <p>The type of mouse event (e.g., cv2.EVENT_MOUSEMOVE, cv2.EVENT_LBUTTONDOWN, etc.).</p> required <code>x</code> <code>int</code> <p>The x-coordinate of the mouse pointer.</p> required <code>y</code> <code>int</code> <p>The y-coordinate of the mouse pointer.</p> required <code>flags</code> <code>int</code> <p>Any flags associated with the event (e.g., cv2.EVENT_FLAG_CTRLKEY, cv2.EVENT_FLAG_SHIFTKEY, etc.).</p> required <code>param</code> <code>dict</code> <p>Additional parameters you may want to pass to the function.</p> required Source code in <code>ultralytics/solutions/distance_calculation.py</code> <pre><code>def mouse_event_for_distance(self, event, x, y, flags, param):\n    \"\"\"\n    This function is designed to move region with mouse events in a real-time video stream.\n\n    Args:\n        event (int): The type of mouse event (e.g., cv2.EVENT_MOUSEMOVE, cv2.EVENT_LBUTTONDOWN, etc.).\n        x (int): The x-coordinate of the mouse pointer.\n        y (int): The y-coordinate of the mouse pointer.\n        flags (int): Any flags associated with the event (e.g., cv2.EVENT_FLAG_CTRLKEY,\n            cv2.EVENT_FLAG_SHIFTKEY, etc.).\n        param (dict): Additional parameters you may want to pass to the function.\n    \"\"\"\n    global selected_boxes\n    global left_mouse_count\n    if event == cv2.EVENT_LBUTTONDOWN:\n        self.left_mouse_count += 1\n        if self.left_mouse_count &lt;= 2:\n            for box, track_id in zip(self.boxes, self.trk_ids):\n                if box[0] &lt; x &lt; box[2] and box[1] &lt; y &lt; box[3]:\n                    if track_id not in self.selected_boxes:\n                        self.selected_boxes[track_id] = []\n                        self.selected_boxes[track_id] = box\n\n    if event == cv2.EVENT_RBUTTONDOWN:\n        self.selected_boxes = {}\n        self.left_mouse_count = 0\n</code></pre>"},{"location":"reference/solutions/distance_calculation/#ultralytics.solutions.distance_calculation.DistanceCalculation.plot_distance_and_line","title":"<code>plot_distance_and_line(distance)</code>","text":"<p>Plot the distance and line on frame Args:     distance (float): Distance between two centroids</p> Source code in <code>ultralytics/solutions/distance_calculation.py</code> <pre><code>def plot_distance_and_line(self, distance):\n    \"\"\"\n    Plot the distance and line on frame\n    Args:\n        distance (float): Distance between two centroids\n    \"\"\"\n    cv2.rectangle(self.im0, (15, 25), (280, 70), (255, 255, 255), -1)\n    cv2.putText(\n        self.im0, f\"Distance : {distance:.2f}m\", (20, 55), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 0), 2, cv2.LINE_AA\n    )\n    cv2.line(self.im0, self.centroids[0], self.centroids[1], self.line_color, 3)\n    cv2.circle(self.im0, self.centroids[0], 6, self.centroid_color, -1)\n    cv2.circle(self.im0, self.centroids[1], 6, self.centroid_color, -1)\n</code></pre>"},{"location":"reference/solutions/distance_calculation/#ultralytics.solutions.distance_calculation.DistanceCalculation.set_args","title":"<code>set_args(names, pixels_per_meter=10, view_img=False, line_thickness=2, line_color=(255, 255, 0), centroid_color=(255, 0, 255))</code>","text":"<p>Configures the distance calculation and display parameters.</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>dict</code> <p>object detection classes names</p> required <code>pixels_per_meter</code> <code>int</code> <p>Number of pixels in meter</p> <code>10</code> <code>view_img</code> <code>bool</code> <p>Flag indicating frame display</p> <code>False</code> <code>line_thickness</code> <code>int</code> <p>Line thickness for bounding boxes.</p> <code>2</code> <code>line_color</code> <code>RGB</code> <p>color of centroids line</p> <code>(255, 255, 0)</code> <code>centroid_color</code> <code>RGB</code> <p>colors of bbox centroids</p> <code>(255, 0, 255)</code> Source code in <code>ultralytics/solutions/distance_calculation.py</code> <pre><code>def set_args(\n    self,\n    names,\n    pixels_per_meter=10,\n    view_img=False,\n    line_thickness=2,\n    line_color=(255, 255, 0),\n    centroid_color=(255, 0, 255),\n):\n    \"\"\"\n    Configures the distance calculation and display parameters.\n\n    Args:\n        names (dict): object detection classes names\n        pixels_per_meter (int): Number of pixels in meter\n        view_img (bool): Flag indicating frame display\n        line_thickness (int): Line thickness for bounding boxes.\n        line_color (RGB): color of centroids line\n        centroid_color (RGB): colors of bbox centroids\n    \"\"\"\n    self.names = names\n    self.pixel_per_meter = pixels_per_meter\n    self.view_img = view_img\n    self.line_thickness = line_thickness\n    self.line_color = line_color\n    self.centroid_color = centroid_color\n</code></pre>"},{"location":"reference/solutions/distance_calculation/#ultralytics.solutions.distance_calculation.DistanceCalculation.start_process","title":"<code>start_process(im0, tracks)</code>","text":"<p>Calculate distance between two bounding boxes based on tracking data Args:     im0 (nd array): Image     tracks (list): List of tracks obtained from the object tracking process.</p> Source code in <code>ultralytics/solutions/distance_calculation.py</code> <pre><code>def start_process(self, im0, tracks):\n    \"\"\"\n    Calculate distance between two bounding boxes based on tracking data\n    Args:\n        im0 (nd array): Image\n        tracks (list): List of tracks obtained from the object tracking process.\n    \"\"\"\n    self.im0 = im0\n    if tracks[0].boxes.id is None:\n        if self.view_img:\n            self.display_frames()\n            return\n        else:\n            return\n\n    self.extract_tracks(tracks)\n\n    self.annotator = Annotator(self.im0, line_width=2)\n\n    for box, cls, track_id in zip(self.boxes, self.clss, self.trk_ids):\n        self.annotator.box_label(box, color=colors(int(cls), True), label=self.names[int(cls)])\n\n        if len(self.selected_boxes) == 2:\n            for trk_id, _ in self.selected_boxes.items():\n                if trk_id == track_id:\n                    self.selected_boxes[track_id] = box\n\n    if len(self.selected_boxes) == 2:\n        for trk_id, box in self.selected_boxes.items():\n            centroid = self.calculate_centroid(self.selected_boxes[trk_id])\n            self.centroids.append(centroid)\n\n        distance = self.calculate_distance(self.centroids[0], self.centroids[1])\n        self.plot_distance_and_line(distance)\n\n    self.centroids = []\n\n    if self.view_img and self.env_check:\n        self.display_frames()\n\n    return im0\n</code></pre>"},{"location":"reference/solutions/heatmap/","title":"Reference for <code>ultralytics/solutions/heatmap.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/solutions/heatmap.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/solutions/heatmap/#ultralytics.solutions.heatmap.Heatmap","title":"<code>ultralytics.solutions.heatmap.Heatmap</code>","text":"<p>A class to draw heatmaps in real-time video stream based on their tracks.</p> Source code in <code>ultralytics/solutions/heatmap.py</code> <pre><code>class Heatmap:\n    \"\"\"A class to draw heatmaps in real-time video stream based on their tracks.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initializes the heatmap class with default values for Visual, Image, track, count and heatmap parameters.\"\"\"\n\n        # Visual information\n        self.annotator = None\n        self.view_img = False\n        self.shape = \"circle\"\n\n        # Image information\n        self.imw = None\n        self.imh = None\n        self.im0 = None\n        self.view_in_counts = True\n        self.view_out_counts = True\n\n        # Heatmap colormap and heatmap np array\n        self.colormap = None\n        self.heatmap = None\n        self.heatmap_alpha = 0.5\n\n        # Predict/track information\n        self.boxes = None\n        self.track_ids = None\n        self.clss = None\n        self.track_history = defaultdict(list)\n\n        # Region &amp; Line Information\n        self.count_reg_pts = None\n        self.counting_region = None\n        self.line_dist_thresh = 15\n        self.region_thickness = 5\n        self.region_color = (255, 0, 255)\n\n        # Object Counting Information\n        self.in_counts = 0\n        self.out_counts = 0\n        self.counting_list = []\n        self.count_txt_thickness = 0\n        self.count_txt_color = (0, 0, 0)\n        self.count_color = (255, 255, 255)\n\n        # Decay factor\n        self.decay_factor = 0.99\n\n        # Check if environment support imshow\n        self.env_check = check_imshow(warn=True)\n\n    def set_args(\n        self,\n        imw,\n        imh,\n        colormap=cv2.COLORMAP_JET,\n        heatmap_alpha=0.5,\n        view_img=False,\n        view_in_counts=True,\n        view_out_counts=True,\n        count_reg_pts=None,\n        count_txt_thickness=2,\n        count_txt_color=(0, 0, 0),\n        count_color=(255, 255, 255),\n        count_reg_color=(255, 0, 255),\n        region_thickness=5,\n        line_dist_thresh=15,\n        decay_factor=0.99,\n        shape=\"circle\",\n    ):\n        \"\"\"\n        Configures the heatmap colormap, width, height and display parameters.\n\n        Args:\n            colormap (cv2.COLORMAP): The colormap to be set.\n            imw (int): The width of the frame.\n            imh (int): The height of the frame.\n            heatmap_alpha (float): alpha value for heatmap display\n            view_img (bool): Flag indicating frame display\n            view_in_counts (bool): Flag to control whether to display the incounts on video stream.\n            view_out_counts (bool): Flag to control whether to display the outcounts on video stream.\n            count_reg_pts (list): Object counting region points\n            count_txt_thickness (int): Text thickness for object counting display\n            count_txt_color (RGB color): count text color value\n            count_color (RGB color): count text background color value\n            count_reg_color (RGB color): Color of object counting region\n            region_thickness (int): Object counting Region thickness\n            line_dist_thresh (int): Euclidean Distance threshold for line counter\n            decay_factor (float): value for removing heatmap area after object passed\n            shape (str): Heatmap shape, rect or circle shape supported\n        \"\"\"\n        self.imw = imw\n        self.imh = imh\n        self.heatmap_alpha = heatmap_alpha\n        self.view_img = view_img\n        self.view_in_counts = view_in_counts\n        self.view_out_counts = view_out_counts\n        self.colormap = colormap\n\n        # Region and line selection\n        if count_reg_pts is not None:\n            if len(count_reg_pts) == 2:\n                print(\"Line Counter Initiated.\")\n                self.count_reg_pts = count_reg_pts\n                self.counting_region = LineString(count_reg_pts)\n\n            elif len(count_reg_pts) == 4:\n                print(\"Region Counter Initiated.\")\n                self.count_reg_pts = count_reg_pts\n                self.counting_region = Polygon(self.count_reg_pts)\n\n            else:\n                print(\"Region or line points Invalid, 2 or 4 points supported\")\n                print(\"Using Line Counter Now\")\n                self.counting_region = Polygon([(20, 400), (1260, 400)])  # dummy points\n\n        # Heatmap new frame\n        self.heatmap = np.zeros((int(self.imh), int(self.imw)), dtype=np.float32)\n\n        self.count_txt_thickness = count_txt_thickness\n        self.count_txt_color = count_txt_color\n        self.count_color = count_color\n        self.region_color = count_reg_color\n        self.region_thickness = region_thickness\n        self.decay_factor = decay_factor\n        self.line_dist_thresh = line_dist_thresh\n        self.shape = shape\n\n        # shape of heatmap, if not selected\n        if self.shape not in [\"circle\", \"rect\"]:\n            print(\"Unknown shape value provided, 'circle' &amp; 'rect' supported\")\n            print(\"Using Circular shape now\")\n            self.shape = \"circle\"\n\n    def extract_results(self, tracks):\n        \"\"\"\n        Extracts results from the provided data.\n\n        Args:\n            tracks (list): List of tracks obtained from the object tracking process.\n        \"\"\"\n        self.boxes = tracks[0].boxes.xyxy.cpu()\n        self.clss = tracks[0].boxes.cls.cpu().tolist()\n        self.track_ids = tracks[0].boxes.id.int().cpu().tolist()\n\n    def generate_heatmap(self, im0, tracks):\n        \"\"\"\n        Generate heatmap based on tracking data.\n\n        Args:\n            im0 (nd array): Image\n            tracks (list): List of tracks obtained from the object tracking process.\n        \"\"\"\n        self.im0 = im0\n        if tracks[0].boxes.id is None:\n            if self.view_img and self.env_check:\n                self.display_frames()\n                return\n            else:\n                return\n\n        self.heatmap *= self.decay_factor  # decay factor\n        self.extract_results(tracks)\n        self.annotator = Annotator(self.im0, self.count_txt_thickness, None)\n\n        if self.count_reg_pts is not None:\n            # Draw counting region\n            if self.view_in_counts or self.view_out_counts:\n                self.annotator.draw_region(\n                    reg_pts=self.count_reg_pts, color=self.region_color, thickness=self.region_thickness\n                )\n\n            for box, cls, track_id in zip(self.boxes, self.clss, self.track_ids):\n                if self.shape == \"circle\":\n                    center = (int((box[0] + box[2]) // 2), int((box[1] + box[3]) // 2))\n                    radius = min(int(box[2]) - int(box[0]), int(box[3]) - int(box[1])) // 2\n\n                    y, x = np.ogrid[0 : self.heatmap.shape[0], 0 : self.heatmap.shape[1]]\n                    mask = (x - center[0]) ** 2 + (y - center[1]) ** 2 &lt;= radius**2\n\n                    self.heatmap[int(box[1]) : int(box[3]), int(box[0]) : int(box[2])] += (\n                        2 * mask[int(box[1]) : int(box[3]), int(box[0]) : int(box[2])]\n                    )\n\n                else:\n                    self.heatmap[int(box[1]) : int(box[3]), int(box[0]) : int(box[2])] += 2\n\n                # Store tracking hist\n                track_line = self.track_history[track_id]\n                track_line.append((float((box[0] + box[2]) / 2), float((box[1] + box[3]) / 2)))\n                if len(track_line) &gt; 30:\n                    track_line.pop(0)\n\n                # Count objects\n                if len(self.count_reg_pts) == 4:\n                    if self.counting_region.contains(Point(track_line[-1])):\n                        if track_id not in self.counting_list:\n                            self.counting_list.append(track_id)\n                            if box[0] &lt; self.counting_region.centroid.x:\n                                self.out_counts += 1\n                            else:\n                                self.in_counts += 1\n\n                elif len(self.count_reg_pts) == 2:\n                    distance = Point(track_line[-1]).distance(self.counting_region)\n                    if distance &lt; self.line_dist_thresh:\n                        if track_id not in self.counting_list:\n                            self.counting_list.append(track_id)\n                            if box[0] &lt; self.counting_region.centroid.x:\n                                self.out_counts += 1\n                            else:\n                                self.in_counts += 1\n        else:\n            for box, cls in zip(self.boxes, self.clss):\n                if self.shape == \"circle\":\n                    center = (int((box[0] + box[2]) // 2), int((box[1] + box[3]) // 2))\n                    radius = min(int(box[2]) - int(box[0]), int(box[3]) - int(box[1])) // 2\n\n                    y, x = np.ogrid[0 : self.heatmap.shape[0], 0 : self.heatmap.shape[1]]\n                    mask = (x - center[0]) ** 2 + (y - center[1]) ** 2 &lt;= radius**2\n\n                    self.heatmap[int(box[1]) : int(box[3]), int(box[0]) : int(box[2])] += (\n                        2 * mask[int(box[1]) : int(box[3]), int(box[0]) : int(box[2])]\n                    )\n\n                else:\n                    self.heatmap[int(box[1]) : int(box[3]), int(box[0]) : int(box[2])] += 2\n\n        # Normalize, apply colormap to heatmap and combine with original image\n        heatmap_normalized = cv2.normalize(self.heatmap, None, 0, 255, cv2.NORM_MINMAX)\n        heatmap_colored = cv2.applyColorMap(heatmap_normalized.astype(np.uint8), self.colormap)\n\n        incount_label = \"In Count : \" + f\"{self.in_counts}\"\n        outcount_label = \"OutCount : \" + f\"{self.out_counts}\"\n\n        # Display counts based on user choice\n        counts_label = None\n        if not self.view_in_counts and not self.view_out_counts:\n            counts_label = None\n        elif not self.view_in_counts:\n            counts_label = outcount_label\n        elif not self.view_out_counts:\n            counts_label = incount_label\n        else:\n            counts_label = incount_label + \" \" + outcount_label\n\n        if self.count_reg_pts is not None and counts_label is not None:\n            self.annotator.count_labels(\n                counts=counts_label,\n                count_txt_size=self.count_txt_thickness,\n                txt_color=self.count_txt_color,\n                color=self.count_color,\n            )\n\n        self.im0 = cv2.addWeighted(self.im0, 1 - self.heatmap_alpha, heatmap_colored, self.heatmap_alpha, 0)\n\n        if self.env_check and self.view_img:\n            self.display_frames()\n\n        return self.im0\n\n    def display_frames(self):\n        \"\"\"Display frame.\"\"\"\n        cv2.imshow(\"Ultralytics Heatmap\", self.im0)\n\n        if cv2.waitKey(1) &amp; 0xFF == ord(\"q\"):\n            return\n</code></pre>"},{"location":"reference/solutions/heatmap/#ultralytics.solutions.heatmap.Heatmap.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the heatmap class with default values for Visual, Image, track, count and heatmap parameters.</p> Source code in <code>ultralytics/solutions/heatmap.py</code> <pre><code>def __init__(self):\n    \"\"\"Initializes the heatmap class with default values for Visual, Image, track, count and heatmap parameters.\"\"\"\n\n    # Visual information\n    self.annotator = None\n    self.view_img = False\n    self.shape = \"circle\"\n\n    # Image information\n    self.imw = None\n    self.imh = None\n    self.im0 = None\n    self.view_in_counts = True\n    self.view_out_counts = True\n\n    # Heatmap colormap and heatmap np array\n    self.colormap = None\n    self.heatmap = None\n    self.heatmap_alpha = 0.5\n\n    # Predict/track information\n    self.boxes = None\n    self.track_ids = None\n    self.clss = None\n    self.track_history = defaultdict(list)\n\n    # Region &amp; Line Information\n    self.count_reg_pts = None\n    self.counting_region = None\n    self.line_dist_thresh = 15\n    self.region_thickness = 5\n    self.region_color = (255, 0, 255)\n\n    # Object Counting Information\n    self.in_counts = 0\n    self.out_counts = 0\n    self.counting_list = []\n    self.count_txt_thickness = 0\n    self.count_txt_color = (0, 0, 0)\n    self.count_color = (255, 255, 255)\n\n    # Decay factor\n    self.decay_factor = 0.99\n\n    # Check if environment support imshow\n    self.env_check = check_imshow(warn=True)\n</code></pre>"},{"location":"reference/solutions/heatmap/#ultralytics.solutions.heatmap.Heatmap.display_frames","title":"<code>display_frames()</code>","text":"<p>Display frame.</p> Source code in <code>ultralytics/solutions/heatmap.py</code> <pre><code>def display_frames(self):\n    \"\"\"Display frame.\"\"\"\n    cv2.imshow(\"Ultralytics Heatmap\", self.im0)\n\n    if cv2.waitKey(1) &amp; 0xFF == ord(\"q\"):\n        return\n</code></pre>"},{"location":"reference/solutions/heatmap/#ultralytics.solutions.heatmap.Heatmap.extract_results","title":"<code>extract_results(tracks)</code>","text":"<p>Extracts results from the provided data.</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>list</code> <p>List of tracks obtained from the object tracking process.</p> required Source code in <code>ultralytics/solutions/heatmap.py</code> <pre><code>def extract_results(self, tracks):\n    \"\"\"\n    Extracts results from the provided data.\n\n    Args:\n        tracks (list): List of tracks obtained from the object tracking process.\n    \"\"\"\n    self.boxes = tracks[0].boxes.xyxy.cpu()\n    self.clss = tracks[0].boxes.cls.cpu().tolist()\n    self.track_ids = tracks[0].boxes.id.int().cpu().tolist()\n</code></pre>"},{"location":"reference/solutions/heatmap/#ultralytics.solutions.heatmap.Heatmap.generate_heatmap","title":"<code>generate_heatmap(im0, tracks)</code>","text":"<p>Generate heatmap based on tracking data.</p> <p>Parameters:</p> Name Type Description Default <code>im0</code> <code>nd array</code> <p>Image</p> required <code>tracks</code> <code>list</code> <p>List of tracks obtained from the object tracking process.</p> required Source code in <code>ultralytics/solutions/heatmap.py</code> <pre><code>def generate_heatmap(self, im0, tracks):\n    \"\"\"\n    Generate heatmap based on tracking data.\n\n    Args:\n        im0 (nd array): Image\n        tracks (list): List of tracks obtained from the object tracking process.\n    \"\"\"\n    self.im0 = im0\n    if tracks[0].boxes.id is None:\n        if self.view_img and self.env_check:\n            self.display_frames()\n            return\n        else:\n            return\n\n    self.heatmap *= self.decay_factor  # decay factor\n    self.extract_results(tracks)\n    self.annotator = Annotator(self.im0, self.count_txt_thickness, None)\n\n    if self.count_reg_pts is not None:\n        # Draw counting region\n        if self.view_in_counts or self.view_out_counts:\n            self.annotator.draw_region(\n                reg_pts=self.count_reg_pts, color=self.region_color, thickness=self.region_thickness\n            )\n\n        for box, cls, track_id in zip(self.boxes, self.clss, self.track_ids):\n            if self.shape == \"circle\":\n                center = (int((box[0] + box[2]) // 2), int((box[1] + box[3]) // 2))\n                radius = min(int(box[2]) - int(box[0]), int(box[3]) - int(box[1])) // 2\n\n                y, x = np.ogrid[0 : self.heatmap.shape[0], 0 : self.heatmap.shape[1]]\n                mask = (x - center[0]) ** 2 + (y - center[1]) ** 2 &lt;= radius**2\n\n                self.heatmap[int(box[1]) : int(box[3]), int(box[0]) : int(box[2])] += (\n                    2 * mask[int(box[1]) : int(box[3]), int(box[0]) : int(box[2])]\n                )\n\n            else:\n                self.heatmap[int(box[1]) : int(box[3]), int(box[0]) : int(box[2])] += 2\n\n            # Store tracking hist\n            track_line = self.track_history[track_id]\n            track_line.append((float((box[0] + box[2]) / 2), float((box[1] + box[3]) / 2)))\n            if len(track_line) &gt; 30:\n                track_line.pop(0)\n\n            # Count objects\n            if len(self.count_reg_pts) == 4:\n                if self.counting_region.contains(Point(track_line[-1])):\n                    if track_id not in self.counting_list:\n                        self.counting_list.append(track_id)\n                        if box[0] &lt; self.counting_region.centroid.x:\n                            self.out_counts += 1\n                        else:\n                            self.in_counts += 1\n\n            elif len(self.count_reg_pts) == 2:\n                distance = Point(track_line[-1]).distance(self.counting_region)\n                if distance &lt; self.line_dist_thresh:\n                    if track_id not in self.counting_list:\n                        self.counting_list.append(track_id)\n                        if box[0] &lt; self.counting_region.centroid.x:\n                            self.out_counts += 1\n                        else:\n                            self.in_counts += 1\n    else:\n        for box, cls in zip(self.boxes, self.clss):\n            if self.shape == \"circle\":\n                center = (int((box[0] + box[2]) // 2), int((box[1] + box[3]) // 2))\n                radius = min(int(box[2]) - int(box[0]), int(box[3]) - int(box[1])) // 2\n\n                y, x = np.ogrid[0 : self.heatmap.shape[0], 0 : self.heatmap.shape[1]]\n                mask = (x - center[0]) ** 2 + (y - center[1]) ** 2 &lt;= radius**2\n\n                self.heatmap[int(box[1]) : int(box[3]), int(box[0]) : int(box[2])] += (\n                    2 * mask[int(box[1]) : int(box[3]), int(box[0]) : int(box[2])]\n                )\n\n            else:\n                self.heatmap[int(box[1]) : int(box[3]), int(box[0]) : int(box[2])] += 2\n\n    # Normalize, apply colormap to heatmap and combine with original image\n    heatmap_normalized = cv2.normalize(self.heatmap, None, 0, 255, cv2.NORM_MINMAX)\n    heatmap_colored = cv2.applyColorMap(heatmap_normalized.astype(np.uint8), self.colormap)\n\n    incount_label = \"In Count : \" + f\"{self.in_counts}\"\n    outcount_label = \"OutCount : \" + f\"{self.out_counts}\"\n\n    # Display counts based on user choice\n    counts_label = None\n    if not self.view_in_counts and not self.view_out_counts:\n        counts_label = None\n    elif not self.view_in_counts:\n        counts_label = outcount_label\n    elif not self.view_out_counts:\n        counts_label = incount_label\n    else:\n        counts_label = incount_label + \" \" + outcount_label\n\n    if self.count_reg_pts is not None and counts_label is not None:\n        self.annotator.count_labels(\n            counts=counts_label,\n            count_txt_size=self.count_txt_thickness,\n            txt_color=self.count_txt_color,\n            color=self.count_color,\n        )\n\n    self.im0 = cv2.addWeighted(self.im0, 1 - self.heatmap_alpha, heatmap_colored, self.heatmap_alpha, 0)\n\n    if self.env_check and self.view_img:\n        self.display_frames()\n\n    return self.im0\n</code></pre>"},{"location":"reference/solutions/heatmap/#ultralytics.solutions.heatmap.Heatmap.set_args","title":"<code>set_args(imw, imh, colormap=cv2.COLORMAP_JET, heatmap_alpha=0.5, view_img=False, view_in_counts=True, view_out_counts=True, count_reg_pts=None, count_txt_thickness=2, count_txt_color=(0, 0, 0), count_color=(255, 255, 255), count_reg_color=(255, 0, 255), region_thickness=5, line_dist_thresh=15, decay_factor=0.99, shape='circle')</code>","text":"<p>Configures the heatmap colormap, width, height and display parameters.</p> <p>Parameters:</p> Name Type Description Default <code>colormap</code> <code>COLORMAP</code> <p>The colormap to be set.</p> <code>COLORMAP_JET</code> <code>imw</code> <code>int</code> <p>The width of the frame.</p> required <code>imh</code> <code>int</code> <p>The height of the frame.</p> required <code>heatmap_alpha</code> <code>float</code> <p>alpha value for heatmap display</p> <code>0.5</code> <code>view_img</code> <code>bool</code> <p>Flag indicating frame display</p> <code>False</code> <code>view_in_counts</code> <code>bool</code> <p>Flag to control whether to display the incounts on video stream.</p> <code>True</code> <code>view_out_counts</code> <code>bool</code> <p>Flag to control whether to display the outcounts on video stream.</p> <code>True</code> <code>count_reg_pts</code> <code>list</code> <p>Object counting region points</p> <code>None</code> <code>count_txt_thickness</code> <code>int</code> <p>Text thickness for object counting display</p> <code>2</code> <code>count_txt_color</code> <code>RGB color</code> <p>count text color value</p> <code>(0, 0, 0)</code> <code>count_color</code> <code>RGB color</code> <p>count text background color value</p> <code>(255, 255, 255)</code> <code>count_reg_color</code> <code>RGB color</code> <p>Color of object counting region</p> <code>(255, 0, 255)</code> <code>region_thickness</code> <code>int</code> <p>Object counting Region thickness</p> <code>5</code> <code>line_dist_thresh</code> <code>int</code> <p>Euclidean Distance threshold for line counter</p> <code>15</code> <code>decay_factor</code> <code>float</code> <p>value for removing heatmap area after object passed</p> <code>0.99</code> <code>shape</code> <code>str</code> <p>Heatmap shape, rect or circle shape supported</p> <code>'circle'</code> Source code in <code>ultralytics/solutions/heatmap.py</code> <pre><code>def set_args(\n    self,\n    imw,\n    imh,\n    colormap=cv2.COLORMAP_JET,\n    heatmap_alpha=0.5,\n    view_img=False,\n    view_in_counts=True,\n    view_out_counts=True,\n    count_reg_pts=None,\n    count_txt_thickness=2,\n    count_txt_color=(0, 0, 0),\n    count_color=(255, 255, 255),\n    count_reg_color=(255, 0, 255),\n    region_thickness=5,\n    line_dist_thresh=15,\n    decay_factor=0.99,\n    shape=\"circle\",\n):\n    \"\"\"\n    Configures the heatmap colormap, width, height and display parameters.\n\n    Args:\n        colormap (cv2.COLORMAP): The colormap to be set.\n        imw (int): The width of the frame.\n        imh (int): The height of the frame.\n        heatmap_alpha (float): alpha value for heatmap display\n        view_img (bool): Flag indicating frame display\n        view_in_counts (bool): Flag to control whether to display the incounts on video stream.\n        view_out_counts (bool): Flag to control whether to display the outcounts on video stream.\n        count_reg_pts (list): Object counting region points\n        count_txt_thickness (int): Text thickness for object counting display\n        count_txt_color (RGB color): count text color value\n        count_color (RGB color): count text background color value\n        count_reg_color (RGB color): Color of object counting region\n        region_thickness (int): Object counting Region thickness\n        line_dist_thresh (int): Euclidean Distance threshold for line counter\n        decay_factor (float): value for removing heatmap area after object passed\n        shape (str): Heatmap shape, rect or circle shape supported\n    \"\"\"\n    self.imw = imw\n    self.imh = imh\n    self.heatmap_alpha = heatmap_alpha\n    self.view_img = view_img\n    self.view_in_counts = view_in_counts\n    self.view_out_counts = view_out_counts\n    self.colormap = colormap\n\n    # Region and line selection\n    if count_reg_pts is not None:\n        if len(count_reg_pts) == 2:\n            print(\"Line Counter Initiated.\")\n            self.count_reg_pts = count_reg_pts\n            self.counting_region = LineString(count_reg_pts)\n\n        elif len(count_reg_pts) == 4:\n            print(\"Region Counter Initiated.\")\n            self.count_reg_pts = count_reg_pts\n            self.counting_region = Polygon(self.count_reg_pts)\n\n        else:\n            print(\"Region or line points Invalid, 2 or 4 points supported\")\n            print(\"Using Line Counter Now\")\n            self.counting_region = Polygon([(20, 400), (1260, 400)])  # dummy points\n\n    # Heatmap new frame\n    self.heatmap = np.zeros((int(self.imh), int(self.imw)), dtype=np.float32)\n\n    self.count_txt_thickness = count_txt_thickness\n    self.count_txt_color = count_txt_color\n    self.count_color = count_color\n    self.region_color = count_reg_color\n    self.region_thickness = region_thickness\n    self.decay_factor = decay_factor\n    self.line_dist_thresh = line_dist_thresh\n    self.shape = shape\n\n    # shape of heatmap, if not selected\n    if self.shape not in [\"circle\", \"rect\"]:\n        print(\"Unknown shape value provided, 'circle' &amp; 'rect' supported\")\n        print(\"Using Circular shape now\")\n        self.shape = \"circle\"\n</code></pre>"},{"location":"reference/solutions/object_counter/","title":"Reference for <code>ultralytics/solutions/object_counter.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/solutions/object_counter.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/solutions/object_counter/#ultralytics.solutions.object_counter.ObjectCounter","title":"<code>ultralytics.solutions.object_counter.ObjectCounter</code>","text":"<p>A class to manage the counting of objects in a real-time video stream based on their tracks.</p> Source code in <code>ultralytics/solutions/object_counter.py</code> <pre><code>class ObjectCounter:\n    \"\"\"A class to manage the counting of objects in a real-time video stream based on their tracks.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initializes the Counter with default values for various tracking and counting parameters.\"\"\"\n\n        # Mouse events\n        self.is_drawing = False\n        self.selected_point = None\n\n        # Region &amp; Line Information\n        self.reg_pts = [(20, 400), (1260, 400)]\n        self.line_dist_thresh = 15\n        self.counting_region = None\n        self.region_color = (255, 0, 255)\n        self.region_thickness = 5\n\n        # Image and annotation Information\n        self.im0 = None\n        self.tf = None\n        self.view_img = False\n        self.view_in_counts = True\n        self.view_out_counts = True\n\n        self.names = None  # Classes names\n        self.annotator = None  # Annotator\n\n        # Object counting Information\n        self.in_counts = 0\n        self.out_counts = 0\n        self.counting_list = []\n        self.count_txt_thickness = 0\n        self.count_txt_color = (0, 0, 0)\n        self.count_color = (255, 255, 255)\n\n        # Tracks info\n        self.track_history = defaultdict(list)\n        self.track_thickness = 2\n        self.draw_tracks = False\n        self.track_color = (0, 255, 0)\n\n        # Check if environment support imshow\n        self.env_check = check_imshow(warn=True)\n\n    def set_args(\n        self,\n        classes_names,\n        reg_pts,\n        count_reg_color=(255, 0, 255),\n        line_thickness=2,\n        track_thickness=2,\n        view_img=False,\n        view_in_counts=True,\n        view_out_counts=True,\n        draw_tracks=False,\n        count_txt_thickness=2,\n        count_txt_color=(0, 0, 0),\n        count_color=(255, 255, 255),\n        track_color=(0, 255, 0),\n        region_thickness=5,\n        line_dist_thresh=15,\n    ):\n        \"\"\"\n        Configures the Counter's image, bounding box line thickness, and counting region points.\n\n        Args:\n            line_thickness (int): Line thickness for bounding boxes.\n            view_img (bool): Flag to control whether to display the video stream.\n            view_in_counts (bool): Flag to control whether to display the incounts on video stream.\n            view_out_counts (bool): Flag to control whether to display the outcounts on video stream.\n            reg_pts (list): Initial list of points defining the counting region.\n            classes_names (dict): Classes names\n            track_thickness (int): Track thickness\n            draw_tracks (Bool): draw tracks\n            count_txt_thickness (int): Text thickness for object counting display\n            count_txt_color (RGB color): count text color value\n            count_color (RGB color): count text background color value\n            count_reg_color (RGB color): Color of object counting region\n            track_color (RGB color): color for tracks\n            region_thickness (int): Object counting Region thickness\n            line_dist_thresh (int): Euclidean Distance threshold for line counter\n        \"\"\"\n        self.tf = line_thickness\n        self.view_img = view_img\n        self.view_in_counts = view_in_counts\n        self.view_out_counts = view_out_counts\n        self.track_thickness = track_thickness\n        self.draw_tracks = draw_tracks\n\n        # Region and line selection\n        if len(reg_pts) == 2:\n            print(\"Line Counter Initiated.\")\n            self.reg_pts = reg_pts\n            self.counting_region = LineString(self.reg_pts)\n        elif len(reg_pts) == 4:\n            print(\"Region Counter Initiated.\")\n            self.reg_pts = reg_pts\n            self.counting_region = Polygon(self.reg_pts)\n        else:\n            print(\"Invalid Region points provided, region_points can be 2 or 4\")\n            print(\"Using Line Counter Now\")\n            self.counting_region = LineString(self.reg_pts)\n\n        self.names = classes_names\n        self.track_color = track_color\n        self.count_txt_thickness = count_txt_thickness\n        self.count_txt_color = count_txt_color\n        self.count_color = count_color\n        self.region_color = count_reg_color\n        self.region_thickness = region_thickness\n        self.line_dist_thresh = line_dist_thresh\n\n    def mouse_event_for_region(self, event, x, y, flags, params):\n        \"\"\"\n        This function is designed to move region with mouse events in a real-time video stream.\n\n        Args:\n            event (int): The type of mouse event (e.g., cv2.EVENT_MOUSEMOVE, cv2.EVENT_LBUTTONDOWN, etc.).\n            x (int): The x-coordinate of the mouse pointer.\n            y (int): The y-coordinate of the mouse pointer.\n            flags (int): Any flags associated with the event (e.g., cv2.EVENT_FLAG_CTRLKEY,\n                cv2.EVENT_FLAG_SHIFTKEY, etc.).\n            params (dict): Additional parameters you may want to pass to the function.\n        \"\"\"\n        # global is_drawing, selected_point\n        if event == cv2.EVENT_LBUTTONDOWN:\n            for i, point in enumerate(self.reg_pts):\n                if isinstance(point, (tuple, list)) and len(point) &gt;= 2:\n                    if abs(x - point[0]) &lt; 10 and abs(y - point[1]) &lt; 10:\n                        self.selected_point = i\n                        self.is_drawing = True\n                        break\n\n        elif event == cv2.EVENT_MOUSEMOVE:\n            if self.is_drawing and self.selected_point is not None:\n                self.reg_pts[self.selected_point] = (x, y)\n                self.counting_region = Polygon(self.reg_pts)\n\n        elif event == cv2.EVENT_LBUTTONUP:\n            self.is_drawing = False\n            self.selected_point = None\n\n    def extract_and_process_tracks(self, tracks):\n        \"\"\"Extracts and processes tracks for object counting in a video stream.\"\"\"\n        boxes = tracks[0].boxes.xyxy.cpu()\n        clss = tracks[0].boxes.cls.cpu().tolist()\n        track_ids = tracks[0].boxes.id.int().cpu().tolist()\n\n        # Annotator Init and region drawing\n        self.annotator = Annotator(self.im0, self.tf, self.names)\n        self.annotator.draw_region(reg_pts=self.reg_pts, color=self.region_color, thickness=self.region_thickness)\n\n        # Extract tracks\n        for box, track_id, cls in zip(boxes, track_ids, clss):\n            self.annotator.box_label(\n                box, label=str(track_id) + \":\" + self.names[cls], color=colors(int(cls), True)\n            )  # Draw bounding box\n\n            # Draw Tracks\n            track_line = self.track_history[track_id]\n            track_line.append((float((box[0] + box[2]) / 2), float((box[1] + box[3]) / 2)))\n            if len(track_line) &gt; 30:\n                track_line.pop(0)\n\n            # Draw track trails\n            if self.draw_tracks:\n                self.annotator.draw_centroid_and_tracks(\n                    track_line, color=self.track_color, track_thickness=self.track_thickness\n                )\n\n            # Count objects\n            if len(self.reg_pts) == 4:\n                if self.counting_region.contains(Point(track_line[-1])):\n                    if track_id not in self.counting_list:\n                        self.counting_list.append(track_id)\n                        if box[0] &lt; self.counting_region.centroid.x:\n                            self.out_counts += 1\n                        else:\n                            self.in_counts += 1\n\n            elif len(self.reg_pts) == 2:\n                distance = Point(track_line[-1]).distance(self.counting_region)\n                if distance &lt; self.line_dist_thresh:\n                    if track_id not in self.counting_list:\n                        self.counting_list.append(track_id)\n                        if box[0] &lt; self.counting_region.centroid.x:\n                            self.out_counts += 1\n                        else:\n                            self.in_counts += 1\n\n        incount_label = \"In Count : \" + f\"{self.in_counts}\"\n        outcount_label = \"OutCount : \" + f\"{self.out_counts}\"\n\n        # Display counts based on user choice\n        counts_label = None\n        if not self.view_in_counts and not self.view_out_counts:\n            counts_label = None\n        elif not self.view_in_counts:\n            counts_label = outcount_label\n        elif not self.view_out_counts:\n            counts_label = incount_label\n        else:\n            counts_label = incount_label + \" \" + outcount_label\n\n        if counts_label is not None:\n            self.annotator.count_labels(\n                counts=counts_label,\n                count_txt_size=self.count_txt_thickness,\n                txt_color=self.count_txt_color,\n                color=self.count_color,\n            )\n\n    def display_frames(self):\n        \"\"\"Display frame.\"\"\"\n        if self.env_check:\n            cv2.namedWindow(\"Ultralytics YOLOv8 Object Counter\")\n            if len(self.reg_pts) == 4:  # only add mouse event If user drawn region\n                cv2.setMouseCallback(\n                    \"Ultralytics YOLOv8 Object Counter\", self.mouse_event_for_region, {\"region_points\": self.reg_pts}\n                )\n            cv2.imshow(\"Ultralytics YOLOv8 Object Counter\", self.im0)\n            # Break Window\n            if cv2.waitKey(1) &amp; 0xFF == ord(\"q\"):\n                return\n\n    def start_counting(self, im0, tracks):\n        \"\"\"\n        Main function to start the object counting process.\n\n        Args:\n            im0 (ndarray): Current frame from the video stream.\n            tracks (list): List of tracks obtained from the object tracking process.\n        \"\"\"\n        self.im0 = im0  # store image\n\n        if tracks[0].boxes.id is None:\n            if self.view_img:\n                self.display_frames()\n                return\n            else:\n                return\n        self.extract_and_process_tracks(tracks)\n\n        if self.view_img:\n            self.display_frames()\n        return self.im0\n</code></pre>"},{"location":"reference/solutions/object_counter/#ultralytics.solutions.object_counter.ObjectCounter.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the Counter with default values for various tracking and counting parameters.</p> Source code in <code>ultralytics/solutions/object_counter.py</code> <pre><code>def __init__(self):\n    \"\"\"Initializes the Counter with default values for various tracking and counting parameters.\"\"\"\n\n    # Mouse events\n    self.is_drawing = False\n    self.selected_point = None\n\n    # Region &amp; Line Information\n    self.reg_pts = [(20, 400), (1260, 400)]\n    self.line_dist_thresh = 15\n    self.counting_region = None\n    self.region_color = (255, 0, 255)\n    self.region_thickness = 5\n\n    # Image and annotation Information\n    self.im0 = None\n    self.tf = None\n    self.view_img = False\n    self.view_in_counts = True\n    self.view_out_counts = True\n\n    self.names = None  # Classes names\n    self.annotator = None  # Annotator\n\n    # Object counting Information\n    self.in_counts = 0\n    self.out_counts = 0\n    self.counting_list = []\n    self.count_txt_thickness = 0\n    self.count_txt_color = (0, 0, 0)\n    self.count_color = (255, 255, 255)\n\n    # Tracks info\n    self.track_history = defaultdict(list)\n    self.track_thickness = 2\n    self.draw_tracks = False\n    self.track_color = (0, 255, 0)\n\n    # Check if environment support imshow\n    self.env_check = check_imshow(warn=True)\n</code></pre>"},{"location":"reference/solutions/object_counter/#ultralytics.solutions.object_counter.ObjectCounter.display_frames","title":"<code>display_frames()</code>","text":"<p>Display frame.</p> Source code in <code>ultralytics/solutions/object_counter.py</code> <pre><code>def display_frames(self):\n    \"\"\"Display frame.\"\"\"\n    if self.env_check:\n        cv2.namedWindow(\"Ultralytics YOLOv8 Object Counter\")\n        if len(self.reg_pts) == 4:  # only add mouse event If user drawn region\n            cv2.setMouseCallback(\n                \"Ultralytics YOLOv8 Object Counter\", self.mouse_event_for_region, {\"region_points\": self.reg_pts}\n            )\n        cv2.imshow(\"Ultralytics YOLOv8 Object Counter\", self.im0)\n        # Break Window\n        if cv2.waitKey(1) &amp; 0xFF == ord(\"q\"):\n            return\n</code></pre>"},{"location":"reference/solutions/object_counter/#ultralytics.solutions.object_counter.ObjectCounter.extract_and_process_tracks","title":"<code>extract_and_process_tracks(tracks)</code>","text":"<p>Extracts and processes tracks for object counting in a video stream.</p> Source code in <code>ultralytics/solutions/object_counter.py</code> <pre><code>def extract_and_process_tracks(self, tracks):\n    \"\"\"Extracts and processes tracks for object counting in a video stream.\"\"\"\n    boxes = tracks[0].boxes.xyxy.cpu()\n    clss = tracks[0].boxes.cls.cpu().tolist()\n    track_ids = tracks[0].boxes.id.int().cpu().tolist()\n\n    # Annotator Init and region drawing\n    self.annotator = Annotator(self.im0, self.tf, self.names)\n    self.annotator.draw_region(reg_pts=self.reg_pts, color=self.region_color, thickness=self.region_thickness)\n\n    # Extract tracks\n    for box, track_id, cls in zip(boxes, track_ids, clss):\n        self.annotator.box_label(\n            box, label=str(track_id) + \":\" + self.names[cls], color=colors(int(cls), True)\n        )  # Draw bounding box\n\n        # Draw Tracks\n        track_line = self.track_history[track_id]\n        track_line.append((float((box[0] + box[2]) / 2), float((box[1] + box[3]) / 2)))\n        if len(track_line) &gt; 30:\n            track_line.pop(0)\n\n        # Draw track trails\n        if self.draw_tracks:\n            self.annotator.draw_centroid_and_tracks(\n                track_line, color=self.track_color, track_thickness=self.track_thickness\n            )\n\n        # Count objects\n        if len(self.reg_pts) == 4:\n            if self.counting_region.contains(Point(track_line[-1])):\n                if track_id not in self.counting_list:\n                    self.counting_list.append(track_id)\n                    if box[0] &lt; self.counting_region.centroid.x:\n                        self.out_counts += 1\n                    else:\n                        self.in_counts += 1\n\n        elif len(self.reg_pts) == 2:\n            distance = Point(track_line[-1]).distance(self.counting_region)\n            if distance &lt; self.line_dist_thresh:\n                if track_id not in self.counting_list:\n                    self.counting_list.append(track_id)\n                    if box[0] &lt; self.counting_region.centroid.x:\n                        self.out_counts += 1\n                    else:\n                        self.in_counts += 1\n\n    incount_label = \"In Count : \" + f\"{self.in_counts}\"\n    outcount_label = \"OutCount : \" + f\"{self.out_counts}\"\n\n    # Display counts based on user choice\n    counts_label = None\n    if not self.view_in_counts and not self.view_out_counts:\n        counts_label = None\n    elif not self.view_in_counts:\n        counts_label = outcount_label\n    elif not self.view_out_counts:\n        counts_label = incount_label\n    else:\n        counts_label = incount_label + \" \" + outcount_label\n\n    if counts_label is not None:\n        self.annotator.count_labels(\n            counts=counts_label,\n            count_txt_size=self.count_txt_thickness,\n            txt_color=self.count_txt_color,\n            color=self.count_color,\n        )\n</code></pre>"},{"location":"reference/solutions/object_counter/#ultralytics.solutions.object_counter.ObjectCounter.mouse_event_for_region","title":"<code>mouse_event_for_region(event, x, y, flags, params)</code>","text":"<p>This function is designed to move region with mouse events in a real-time video stream.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>int</code> <p>The type of mouse event (e.g., cv2.EVENT_MOUSEMOVE, cv2.EVENT_LBUTTONDOWN, etc.).</p> required <code>x</code> <code>int</code> <p>The x-coordinate of the mouse pointer.</p> required <code>y</code> <code>int</code> <p>The y-coordinate of the mouse pointer.</p> required <code>flags</code> <code>int</code> <p>Any flags associated with the event (e.g., cv2.EVENT_FLAG_CTRLKEY, cv2.EVENT_FLAG_SHIFTKEY, etc.).</p> required <code>params</code> <code>dict</code> <p>Additional parameters you may want to pass to the function.</p> required Source code in <code>ultralytics/solutions/object_counter.py</code> <pre><code>def mouse_event_for_region(self, event, x, y, flags, params):\n    \"\"\"\n    This function is designed to move region with mouse events in a real-time video stream.\n\n    Args:\n        event (int): The type of mouse event (e.g., cv2.EVENT_MOUSEMOVE, cv2.EVENT_LBUTTONDOWN, etc.).\n        x (int): The x-coordinate of the mouse pointer.\n        y (int): The y-coordinate of the mouse pointer.\n        flags (int): Any flags associated with the event (e.g., cv2.EVENT_FLAG_CTRLKEY,\n            cv2.EVENT_FLAG_SHIFTKEY, etc.).\n        params (dict): Additional parameters you may want to pass to the function.\n    \"\"\"\n    # global is_drawing, selected_point\n    if event == cv2.EVENT_LBUTTONDOWN:\n        for i, point in enumerate(self.reg_pts):\n            if isinstance(point, (tuple, list)) and len(point) &gt;= 2:\n                if abs(x - point[0]) &lt; 10 and abs(y - point[1]) &lt; 10:\n                    self.selected_point = i\n                    self.is_drawing = True\n                    break\n\n    elif event == cv2.EVENT_MOUSEMOVE:\n        if self.is_drawing and self.selected_point is not None:\n            self.reg_pts[self.selected_point] = (x, y)\n            self.counting_region = Polygon(self.reg_pts)\n\n    elif event == cv2.EVENT_LBUTTONUP:\n        self.is_drawing = False\n        self.selected_point = None\n</code></pre>"},{"location":"reference/solutions/object_counter/#ultralytics.solutions.object_counter.ObjectCounter.set_args","title":"<code>set_args(classes_names, reg_pts, count_reg_color=(255, 0, 255), line_thickness=2, track_thickness=2, view_img=False, view_in_counts=True, view_out_counts=True, draw_tracks=False, count_txt_thickness=2, count_txt_color=(0, 0, 0), count_color=(255, 255, 255), track_color=(0, 255, 0), region_thickness=5, line_dist_thresh=15)</code>","text":"<p>Configures the Counter's image, bounding box line thickness, and counting region points.</p> <p>Parameters:</p> Name Type Description Default <code>line_thickness</code> <code>int</code> <p>Line thickness for bounding boxes.</p> <code>2</code> <code>view_img</code> <code>bool</code> <p>Flag to control whether to display the video stream.</p> <code>False</code> <code>view_in_counts</code> <code>bool</code> <p>Flag to control whether to display the incounts on video stream.</p> <code>True</code> <code>view_out_counts</code> <code>bool</code> <p>Flag to control whether to display the outcounts on video stream.</p> <code>True</code> <code>reg_pts</code> <code>list</code> <p>Initial list of points defining the counting region.</p> required <code>classes_names</code> <code>dict</code> <p>Classes names</p> required <code>track_thickness</code> <code>int</code> <p>Track thickness</p> <code>2</code> <code>draw_tracks</code> <code>Bool</code> <p>draw tracks</p> <code>False</code> <code>count_txt_thickness</code> <code>int</code> <p>Text thickness for object counting display</p> <code>2</code> <code>count_txt_color</code> <code>RGB color</code> <p>count text color value</p> <code>(0, 0, 0)</code> <code>count_color</code> <code>RGB color</code> <p>count text background color value</p> <code>(255, 255, 255)</code> <code>count_reg_color</code> <code>RGB color</code> <p>Color of object counting region</p> <code>(255, 0, 255)</code> <code>track_color</code> <code>RGB color</code> <p>color for tracks</p> <code>(0, 255, 0)</code> <code>region_thickness</code> <code>int</code> <p>Object counting Region thickness</p> <code>5</code> <code>line_dist_thresh</code> <code>int</code> <p>Euclidean Distance threshold for line counter</p> <code>15</code> Source code in <code>ultralytics/solutions/object_counter.py</code> <pre><code>def set_args(\n    self,\n    classes_names,\n    reg_pts,\n    count_reg_color=(255, 0, 255),\n    line_thickness=2,\n    track_thickness=2,\n    view_img=False,\n    view_in_counts=True,\n    view_out_counts=True,\n    draw_tracks=False,\n    count_txt_thickness=2,\n    count_txt_color=(0, 0, 0),\n    count_color=(255, 255, 255),\n    track_color=(0, 255, 0),\n    region_thickness=5,\n    line_dist_thresh=15,\n):\n    \"\"\"\n    Configures the Counter's image, bounding box line thickness, and counting region points.\n\n    Args:\n        line_thickness (int): Line thickness for bounding boxes.\n        view_img (bool): Flag to control whether to display the video stream.\n        view_in_counts (bool): Flag to control whether to display the incounts on video stream.\n        view_out_counts (bool): Flag to control whether to display the outcounts on video stream.\n        reg_pts (list): Initial list of points defining the counting region.\n        classes_names (dict): Classes names\n        track_thickness (int): Track thickness\n        draw_tracks (Bool): draw tracks\n        count_txt_thickness (int): Text thickness for object counting display\n        count_txt_color (RGB color): count text color value\n        count_color (RGB color): count text background color value\n        count_reg_color (RGB color): Color of object counting region\n        track_color (RGB color): color for tracks\n        region_thickness (int): Object counting Region thickness\n        line_dist_thresh (int): Euclidean Distance threshold for line counter\n    \"\"\"\n    self.tf = line_thickness\n    self.view_img = view_img\n    self.view_in_counts = view_in_counts\n    self.view_out_counts = view_out_counts\n    self.track_thickness = track_thickness\n    self.draw_tracks = draw_tracks\n\n    # Region and line selection\n    if len(reg_pts) == 2:\n        print(\"Line Counter Initiated.\")\n        self.reg_pts = reg_pts\n        self.counting_region = LineString(self.reg_pts)\n    elif len(reg_pts) == 4:\n        print(\"Region Counter Initiated.\")\n        self.reg_pts = reg_pts\n        self.counting_region = Polygon(self.reg_pts)\n    else:\n        print(\"Invalid Region points provided, region_points can be 2 or 4\")\n        print(\"Using Line Counter Now\")\n        self.counting_region = LineString(self.reg_pts)\n\n    self.names = classes_names\n    self.track_color = track_color\n    self.count_txt_thickness = count_txt_thickness\n    self.count_txt_color = count_txt_color\n    self.count_color = count_color\n    self.region_color = count_reg_color\n    self.region_thickness = region_thickness\n    self.line_dist_thresh = line_dist_thresh\n</code></pre>"},{"location":"reference/solutions/object_counter/#ultralytics.solutions.object_counter.ObjectCounter.start_counting","title":"<code>start_counting(im0, tracks)</code>","text":"<p>Main function to start the object counting process.</p> <p>Parameters:</p> Name Type Description Default <code>im0</code> <code>ndarray</code> <p>Current frame from the video stream.</p> required <code>tracks</code> <code>list</code> <p>List of tracks obtained from the object tracking process.</p> required Source code in <code>ultralytics/solutions/object_counter.py</code> <pre><code>def start_counting(self, im0, tracks):\n    \"\"\"\n    Main function to start the object counting process.\n\n    Args:\n        im0 (ndarray): Current frame from the video stream.\n        tracks (list): List of tracks obtained from the object tracking process.\n    \"\"\"\n    self.im0 = im0  # store image\n\n    if tracks[0].boxes.id is None:\n        if self.view_img:\n            self.display_frames()\n            return\n        else:\n            return\n    self.extract_and_process_tracks(tracks)\n\n    if self.view_img:\n        self.display_frames()\n    return self.im0\n</code></pre>"},{"location":"reference/solutions/speed_estimation/","title":"Reference for <code>ultralytics/solutions/speed_estimation.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/solutions/speed_estimation.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/solutions/speed_estimation/#ultralytics.solutions.speed_estimation.SpeedEstimator","title":"<code>ultralytics.solutions.speed_estimation.SpeedEstimator</code>","text":"<p>A class to estimation speed of objects in real-time video stream based on their tracks.</p> Source code in <code>ultralytics/solutions/speed_estimation.py</code> <pre><code>class SpeedEstimator:\n    \"\"\"A class to estimation speed of objects in real-time video stream based on their tracks.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initializes the speed-estimator class with default values for Visual, Image, track and speed parameters.\"\"\"\n\n        # Visual &amp; im0 information\n        self.im0 = None\n        self.annotator = None\n        self.view_img = False\n\n        # Region information\n        self.reg_pts = [(20, 400), (1260, 400)]\n        self.region_thickness = 3\n\n        # Predict/track information\n        self.clss = None\n        self.names = None\n        self.boxes = None\n        self.trk_ids = None\n        self.trk_pts = None\n        self.line_thickness = 2\n        self.trk_history = defaultdict(list)\n\n        # Speed estimator information\n        self.current_time = 0\n        self.dist_data = {}\n        self.trk_idslist = []\n        self.spdl_dist_thresh = 10\n        self.trk_previous_times = {}\n        self.trk_previous_points = {}\n\n        # Check if environment support imshow\n        self.env_check = check_imshow(warn=True)\n\n    def set_args(\n        self,\n        reg_pts,\n        names,\n        view_img=False,\n        line_thickness=2,\n        region_thickness=5,\n        spdl_dist_thresh=10,\n    ):\n        \"\"\"\n        Configures the speed estimation and display parameters.\n\n        Args:\n            reg_pts (list): Initial list of points defining the speed calculation region.\n            names (dict): object detection classes names\n            view_img (bool): Flag indicating frame display\n            line_thickness (int): Line thickness for bounding boxes.\n            region_thickness (int): Speed estimation region thickness\n            spdl_dist_thresh (int): Euclidean distance threshold for speed line\n        \"\"\"\n        if reg_pts is None:\n            print(\"Region points not provided, using default values\")\n        else:\n            self.reg_pts = reg_pts\n        self.names = names\n        self.view_img = view_img\n        self.line_thickness = line_thickness\n        self.region_thickness = region_thickness\n        self.spdl_dist_thresh = spdl_dist_thresh\n\n    def extract_tracks(self, tracks):\n        \"\"\"\n        Extracts results from the provided data.\n\n        Args:\n            tracks (list): List of tracks obtained from the object tracking process.\n        \"\"\"\n        self.boxes = tracks[0].boxes.xyxy.cpu()\n        self.clss = tracks[0].boxes.cls.cpu().tolist()\n        self.trk_ids = tracks[0].boxes.id.int().cpu().tolist()\n\n    def store_track_info(self, track_id, box):\n        \"\"\"\n        Store track data.\n\n        Args:\n            track_id (int): object track id.\n            box (list): object bounding box data\n        \"\"\"\n        track = self.trk_history[track_id]\n        bbox_center = (float((box[0] + box[2]) / 2), float((box[1] + box[3]) / 2))\n        track.append(bbox_center)\n\n        if len(track) &gt; 30:\n            track.pop(0)\n\n        self.trk_pts = np.hstack(track).astype(np.int32).reshape((-1, 1, 2))\n        return track\n\n    def plot_box_and_track(self, track_id, box, cls, track):\n        \"\"\"\n        Plot track and bounding box.\n\n        Args:\n            track_id (int): object track id.\n            box (list): object bounding box data\n            cls (str): object class name\n            track (list): tracking history for tracks path drawing\n        \"\"\"\n        speed_label = (\n            str(int(self.dist_data[track_id])) + \"km/ph\" if track_id in self.dist_data else self.names[int(cls)]\n        )\n        bbox_color = colors(int(track_id)) if track_id in self.dist_data else (255, 0, 255)\n\n        self.annotator.box_label(box, speed_label, bbox_color)\n\n        cv2.polylines(self.im0, [self.trk_pts], isClosed=False, color=(0, 255, 0), thickness=1)\n        cv2.circle(self.im0, (int(track[-1][0]), int(track[-1][1])), 5, bbox_color, -1)\n\n    def calculate_speed(self, trk_id, track):\n        \"\"\"\n        Calculation of object speed\n        Args:\n            trk_id (int): object track id.\n            track (list): tracking history for tracks path drawing\n        \"\"\"\n\n        if self.reg_pts[0][0] &lt; track[-1][0] &lt; self.reg_pts[1][0]:\n            if self.reg_pts[1][1] - self.spdl_dist_thresh &lt; track[-1][1] &lt; self.reg_pts[1][1] + self.spdl_dist_thresh:\n                direction = \"known\"\n\n            elif self.reg_pts[0][1] - self.spdl_dist_thresh &lt; track[-1][1] &lt; self.reg_pts[0][1] + self.spdl_dist_thresh:\n                direction = \"known\"\n\n            else:\n                direction = \"unknown\"\n\n            if self.trk_previous_times[trk_id] != 0 and direction != \"unknown\":\n                if trk_id not in self.trk_idslist:\n                    self.trk_idslist.append(trk_id)\n\n                    time_difference = time() - self.trk_previous_times[trk_id]\n                    if time_difference &gt; 0:\n                        dist_difference = np.abs(track[-1][1] - self.trk_previous_points[trk_id][1])\n                        speed = dist_difference / time_difference\n                        self.dist_data[trk_id] = speed\n\n            self.trk_previous_times[trk_id] = time()\n            self.trk_previous_points[trk_id] = track[-1]\n\n    def estimate_speed(self, im0, tracks):\n        \"\"\"\n        Calculate object based on tracking data\n        Args:\n            im0 (nd array): Image\n            tracks (list): List of tracks obtained from the object tracking process.\n        \"\"\"\n        self.im0 = im0\n        if tracks[0].boxes.id is None:\n            if self.view_img and self.env_check:\n                self.display_frames()\n                return\n            else:\n                return\n\n        self.extract_tracks(tracks)\n\n        self.annotator = Annotator(self.im0, line_width=2)\n        self.annotator.draw_region(reg_pts=self.reg_pts, color=(255, 0, 0), thickness=self.region_thickness)\n\n        for box, trk_id, cls in zip(self.boxes, self.trk_ids, self.clss):\n            track = self.store_track_info(trk_id, box)\n\n            if trk_id not in self.trk_previous_times:\n                self.trk_previous_times[trk_id] = 0\n\n            self.plot_box_and_track(trk_id, box, cls, track)\n            self.calculate_speed(trk_id, track)\n\n        if self.view_img and self.env_check:\n            self.display_frames()\n\n        return im0\n\n    def display_frames(self):\n        \"\"\"Display frame.\"\"\"\n        cv2.imshow(\"Ultralytics Speed Estimation\", self.im0)\n        if cv2.waitKey(1) &amp; 0xFF == ord(\"q\"):\n            return\n</code></pre>"},{"location":"reference/solutions/speed_estimation/#ultralytics.solutions.speed_estimation.SpeedEstimator.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the speed-estimator class with default values for Visual, Image, track and speed parameters.</p> Source code in <code>ultralytics/solutions/speed_estimation.py</code> <pre><code>def __init__(self):\n    \"\"\"Initializes the speed-estimator class with default values for Visual, Image, track and speed parameters.\"\"\"\n\n    # Visual &amp; im0 information\n    self.im0 = None\n    self.annotator = None\n    self.view_img = False\n\n    # Region information\n    self.reg_pts = [(20, 400), (1260, 400)]\n    self.region_thickness = 3\n\n    # Predict/track information\n    self.clss = None\n    self.names = None\n    self.boxes = None\n    self.trk_ids = None\n    self.trk_pts = None\n    self.line_thickness = 2\n    self.trk_history = defaultdict(list)\n\n    # Speed estimator information\n    self.current_time = 0\n    self.dist_data = {}\n    self.trk_idslist = []\n    self.spdl_dist_thresh = 10\n    self.trk_previous_times = {}\n    self.trk_previous_points = {}\n\n    # Check if environment support imshow\n    self.env_check = check_imshow(warn=True)\n</code></pre>"},{"location":"reference/solutions/speed_estimation/#ultralytics.solutions.speed_estimation.SpeedEstimator.calculate_speed","title":"<code>calculate_speed(trk_id, track)</code>","text":"<p>Calculation of object speed Args:     trk_id (int): object track id.     track (list): tracking history for tracks path drawing</p> Source code in <code>ultralytics/solutions/speed_estimation.py</code> <pre><code>def calculate_speed(self, trk_id, track):\n    \"\"\"\n    Calculation of object speed\n    Args:\n        trk_id (int): object track id.\n        track (list): tracking history for tracks path drawing\n    \"\"\"\n\n    if self.reg_pts[0][0] &lt; track[-1][0] &lt; self.reg_pts[1][0]:\n        if self.reg_pts[1][1] - self.spdl_dist_thresh &lt; track[-1][1] &lt; self.reg_pts[1][1] + self.spdl_dist_thresh:\n            direction = \"known\"\n\n        elif self.reg_pts[0][1] - self.spdl_dist_thresh &lt; track[-1][1] &lt; self.reg_pts[0][1] + self.spdl_dist_thresh:\n            direction = \"known\"\n\n        else:\n            direction = \"unknown\"\n\n        if self.trk_previous_times[trk_id] != 0 and direction != \"unknown\":\n            if trk_id not in self.trk_idslist:\n                self.trk_idslist.append(trk_id)\n\n                time_difference = time() - self.trk_previous_times[trk_id]\n                if time_difference &gt; 0:\n                    dist_difference = np.abs(track[-1][1] - self.trk_previous_points[trk_id][1])\n                    speed = dist_difference / time_difference\n                    self.dist_data[trk_id] = speed\n\n        self.trk_previous_times[trk_id] = time()\n        self.trk_previous_points[trk_id] = track[-1]\n</code></pre>"},{"location":"reference/solutions/speed_estimation/#ultralytics.solutions.speed_estimation.SpeedEstimator.display_frames","title":"<code>display_frames()</code>","text":"<p>Display frame.</p> Source code in <code>ultralytics/solutions/speed_estimation.py</code> <pre><code>def display_frames(self):\n    \"\"\"Display frame.\"\"\"\n    cv2.imshow(\"Ultralytics Speed Estimation\", self.im0)\n    if cv2.waitKey(1) &amp; 0xFF == ord(\"q\"):\n        return\n</code></pre>"},{"location":"reference/solutions/speed_estimation/#ultralytics.solutions.speed_estimation.SpeedEstimator.estimate_speed","title":"<code>estimate_speed(im0, tracks)</code>","text":"<p>Calculate object based on tracking data Args:     im0 (nd array): Image     tracks (list): List of tracks obtained from the object tracking process.</p> Source code in <code>ultralytics/solutions/speed_estimation.py</code> <pre><code>def estimate_speed(self, im0, tracks):\n    \"\"\"\n    Calculate object based on tracking data\n    Args:\n        im0 (nd array): Image\n        tracks (list): List of tracks obtained from the object tracking process.\n    \"\"\"\n    self.im0 = im0\n    if tracks[0].boxes.id is None:\n        if self.view_img and self.env_check:\n            self.display_frames()\n            return\n        else:\n            return\n\n    self.extract_tracks(tracks)\n\n    self.annotator = Annotator(self.im0, line_width=2)\n    self.annotator.draw_region(reg_pts=self.reg_pts, color=(255, 0, 0), thickness=self.region_thickness)\n\n    for box, trk_id, cls in zip(self.boxes, self.trk_ids, self.clss):\n        track = self.store_track_info(trk_id, box)\n\n        if trk_id not in self.trk_previous_times:\n            self.trk_previous_times[trk_id] = 0\n\n        self.plot_box_and_track(trk_id, box, cls, track)\n        self.calculate_speed(trk_id, track)\n\n    if self.view_img and self.env_check:\n        self.display_frames()\n\n    return im0\n</code></pre>"},{"location":"reference/solutions/speed_estimation/#ultralytics.solutions.speed_estimation.SpeedEstimator.extract_tracks","title":"<code>extract_tracks(tracks)</code>","text":"<p>Extracts results from the provided data.</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>list</code> <p>List of tracks obtained from the object tracking process.</p> required Source code in <code>ultralytics/solutions/speed_estimation.py</code> <pre><code>def extract_tracks(self, tracks):\n    \"\"\"\n    Extracts results from the provided data.\n\n    Args:\n        tracks (list): List of tracks obtained from the object tracking process.\n    \"\"\"\n    self.boxes = tracks[0].boxes.xyxy.cpu()\n    self.clss = tracks[0].boxes.cls.cpu().tolist()\n    self.trk_ids = tracks[0].boxes.id.int().cpu().tolist()\n</code></pre>"},{"location":"reference/solutions/speed_estimation/#ultralytics.solutions.speed_estimation.SpeedEstimator.plot_box_and_track","title":"<code>plot_box_and_track(track_id, box, cls, track)</code>","text":"<p>Plot track and bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>track_id</code> <code>int</code> <p>object track id.</p> required <code>box</code> <code>list</code> <p>object bounding box data</p> required <code>cls</code> <code>str</code> <p>object class name</p> required <code>track</code> <code>list</code> <p>tracking history for tracks path drawing</p> required Source code in <code>ultralytics/solutions/speed_estimation.py</code> <pre><code>def plot_box_and_track(self, track_id, box, cls, track):\n    \"\"\"\n    Plot track and bounding box.\n\n    Args:\n        track_id (int): object track id.\n        box (list): object bounding box data\n        cls (str): object class name\n        track (list): tracking history for tracks path drawing\n    \"\"\"\n    speed_label = (\n        str(int(self.dist_data[track_id])) + \"km/ph\" if track_id in self.dist_data else self.names[int(cls)]\n    )\n    bbox_color = colors(int(track_id)) if track_id in self.dist_data else (255, 0, 255)\n\n    self.annotator.box_label(box, speed_label, bbox_color)\n\n    cv2.polylines(self.im0, [self.trk_pts], isClosed=False, color=(0, 255, 0), thickness=1)\n    cv2.circle(self.im0, (int(track[-1][0]), int(track[-1][1])), 5, bbox_color, -1)\n</code></pre>"},{"location":"reference/solutions/speed_estimation/#ultralytics.solutions.speed_estimation.SpeedEstimator.set_args","title":"<code>set_args(reg_pts, names, view_img=False, line_thickness=2, region_thickness=5, spdl_dist_thresh=10)</code>","text":"<p>Configures the speed estimation and display parameters.</p> <p>Parameters:</p> Name Type Description Default <code>reg_pts</code> <code>list</code> <p>Initial list of points defining the speed calculation region.</p> required <code>names</code> <code>dict</code> <p>object detection classes names</p> required <code>view_img</code> <code>bool</code> <p>Flag indicating frame display</p> <code>False</code> <code>line_thickness</code> <code>int</code> <p>Line thickness for bounding boxes.</p> <code>2</code> <code>region_thickness</code> <code>int</code> <p>Speed estimation region thickness</p> <code>5</code> <code>spdl_dist_thresh</code> <code>int</code> <p>Euclidean distance threshold for speed line</p> <code>10</code> Source code in <code>ultralytics/solutions/speed_estimation.py</code> <pre><code>def set_args(\n    self,\n    reg_pts,\n    names,\n    view_img=False,\n    line_thickness=2,\n    region_thickness=5,\n    spdl_dist_thresh=10,\n):\n    \"\"\"\n    Configures the speed estimation and display parameters.\n\n    Args:\n        reg_pts (list): Initial list of points defining the speed calculation region.\n        names (dict): object detection classes names\n        view_img (bool): Flag indicating frame display\n        line_thickness (int): Line thickness for bounding boxes.\n        region_thickness (int): Speed estimation region thickness\n        spdl_dist_thresh (int): Euclidean distance threshold for speed line\n    \"\"\"\n    if reg_pts is None:\n        print(\"Region points not provided, using default values\")\n    else:\n        self.reg_pts = reg_pts\n    self.names = names\n    self.view_img = view_img\n    self.line_thickness = line_thickness\n    self.region_thickness = region_thickness\n    self.spdl_dist_thresh = spdl_dist_thresh\n</code></pre>"},{"location":"reference/solutions/speed_estimation/#ultralytics.solutions.speed_estimation.SpeedEstimator.store_track_info","title":"<code>store_track_info(track_id, box)</code>","text":"<p>Store track data.</p> <p>Parameters:</p> Name Type Description Default <code>track_id</code> <code>int</code> <p>object track id.</p> required <code>box</code> <code>list</code> <p>object bounding box data</p> required Source code in <code>ultralytics/solutions/speed_estimation.py</code> <pre><code>def store_track_info(self, track_id, box):\n    \"\"\"\n    Store track data.\n\n    Args:\n        track_id (int): object track id.\n        box (list): object bounding box data\n    \"\"\"\n    track = self.trk_history[track_id]\n    bbox_center = (float((box[0] + box[2]) / 2), float((box[1] + box[3]) / 2))\n    track.append(bbox_center)\n\n    if len(track) &gt; 30:\n        track.pop(0)\n\n    self.trk_pts = np.hstack(track).astype(np.int32).reshape((-1, 1, 2))\n    return track\n</code></pre>"},{"location":"reference/trackers/basetrack/","title":"Reference for <code>ultralytics/trackers/basetrack.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/trackers/basetrack.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p>"},{"location":"reference/trackers/basetrack/#ultralytics.trackers.basetrack.TrackState","title":"<code>ultralytics.trackers.basetrack.TrackState</code>","text":"<p>Enumeration class representing the possible states of an object being tracked.</p> <p>Attributes:</p> Name Type Description <code>New</code> <code>int</code> <p>State when the object is newly detected.</p> <code>Tracked</code> <code>int</code> <p>State when the object is successfully tracked in subsequent frames.</p> <code>Lost</code> <code>int</code> <p>State when the object is no longer tracked.</p> <code>Removed</code> <code>int</code> <p>State when the object is removed from tracking.</p> Source code in <code>ultralytics/trackers/basetrack.py</code> <pre><code>class TrackState:\n    \"\"\"\n    Enumeration class representing the possible states of an object being tracked.\n\n    Attributes:\n        New (int): State when the object is newly detected.\n        Tracked (int): State when the object is successfully tracked in subsequent frames.\n        Lost (int): State when the object is no longer tracked.\n        Removed (int): State when the object is removed from tracking.\n    \"\"\"\n\n    New = 0\n    Tracked = 1\n    Lost = 2\n    Removed = 3\n</code></pre>"},{"location":"reference/trackers/basetrack/#ultralytics.trackers.basetrack.BaseTrack","title":"<code>ultralytics.trackers.basetrack.BaseTrack</code>","text":"<p>Base class for object tracking, providing foundational attributes and methods.</p> <p>Attributes:</p> Name Type Description <code>_count</code> <code>int</code> <p>Class-level counter for unique track IDs.</p> <code>track_id</code> <code>int</code> <p>Unique identifier for the track.</p> <code>is_activated</code> <code>bool</code> <p>Flag indicating whether the track is currently active.</p> <code>state</code> <code>TrackState</code> <p>Current state of the track.</p> <code>history</code> <code>OrderedDict</code> <p>Ordered history of the track's states.</p> <code>features</code> <code>list</code> <p>List of features extracted from the object for tracking.</p> <code>curr_feature</code> <code>any</code> <p>The current feature of the object being tracked.</p> <code>score</code> <code>float</code> <p>The confidence score of the tracking.</p> <code>start_frame</code> <code>int</code> <p>The frame number where tracking started.</p> <code>frame_id</code> <code>int</code> <p>The most recent frame ID processed by the track.</p> <code>time_since_update</code> <code>int</code> <p>Frames passed since the last update.</p> <code>location</code> <code>tuple</code> <p>The location of the object in the context of multi-camera tracking.</p> <p>Methods:</p> Name Description <code>end_frame</code> <p>Returns the ID of the last frame where the object was tracked.</p> <code>next_id</code> <p>Increments and returns the next global track ID.</p> <code>activate</code> <p>Abstract method to activate the track.</p> <code>predict</code> <p>Abstract method to predict the next state of the track.</p> <code>update</code> <p>Abstract method to update the track with new data.</p> <code>mark_lost</code> <p>Marks the track as lost.</p> <code>mark_removed</code> <p>Marks the track as removed.</p> <code>reset_id</code> <p>Resets the global track ID counter.</p> Source code in <code>ultralytics/trackers/basetrack.py</code> <pre><code>class BaseTrack:\n    \"\"\"\n    Base class for object tracking, providing foundational attributes and methods.\n\n    Attributes:\n        _count (int): Class-level counter for unique track IDs.\n        track_id (int): Unique identifier for the track.\n        is_activated (bool): Flag indicating whether the track is currently active.\n        state (TrackState): Current state of the track.\n        history (OrderedDict): Ordered history of the track's states.\n        features (list): List of features extracted from the object for tracking.\n        curr_feature (any): The current feature of the object being tracked.\n        score (float): The confidence score of the tracking.\n        start_frame (int): The frame number where tracking started.\n        frame_id (int): The most recent frame ID processed by the track.\n        time_since_update (int): Frames passed since the last update.\n        location (tuple): The location of the object in the context of multi-camera tracking.\n\n    Methods:\n        end_frame: Returns the ID of the last frame where the object was tracked.\n        next_id: Increments and returns the next global track ID.\n        activate: Abstract method to activate the track.\n        predict: Abstract method to predict the next state of the track.\n        update: Abstract method to update the track with new data.\n        mark_lost: Marks the track as lost.\n        mark_removed: Marks the track as removed.\n        reset_id: Resets the global track ID counter.\n    \"\"\"\n\n    _count = 0\n\n    def __init__(self):\n        \"\"\"Initializes a new track with unique ID and foundational tracking attributes.\"\"\"\n        self.track_id = 0\n        self.is_activated = False\n        self.state = TrackState.New\n        self.history = OrderedDict()\n        self.features = []\n        self.curr_feature = None\n        self.score = 0\n        self.start_frame = 0\n        self.frame_id = 0\n        self.time_since_update = 0\n        self.location = (np.inf, np.inf)\n\n    @property\n    def end_frame(self):\n        \"\"\"Return the last frame ID of the track.\"\"\"\n        return self.frame_id\n\n    @staticmethod\n    def next_id():\n        \"\"\"Increment and return the global track ID counter.\"\"\"\n        BaseTrack._count += 1\n        return BaseTrack._count\n\n    def activate(self, *args):\n        \"\"\"Abstract method to activate the track with provided arguments.\"\"\"\n        raise NotImplementedError\n\n    def predict(self):\n        \"\"\"Abstract method to predict the next state of the track.\"\"\"\n        raise NotImplementedError\n\n    def update(self, *args, **kwargs):\n        \"\"\"Abstract method to update the track with new observations.\"\"\"\n        raise NotImplementedError\n\n    def mark_lost(self):\n        \"\"\"Mark the track as lost.\"\"\"\n        self.state = TrackState.Lost\n\n    def mark_removed(self):\n        \"\"\"Mark the track as removed.\"\"\"\n        self.state = TrackState.Removed\n\n    @staticmethod\n    def reset_id():\n        \"\"\"Reset the global track ID counter.\"\"\"\n        BaseTrack._count = 0\n</code></pre>"},{"location":"reference/trackers/basetrack/#ultralytics.trackers.basetrack.BaseTrack.end_frame","title":"<code>end_frame</code>  <code>property</code>","text":"<p>Return the last frame ID of the track.</p>"},{"location":"reference/trackers/basetrack/#ultralytics.trackers.basetrack.BaseTrack.__init__","title":"<code>__init__()</code>","text":"<p>Initializes a new track with unique ID and foundational tracking attributes.</p> Source code in <code>ultralytics/trackers/basetrack.py</code> <pre><code>def __init__(self):\n    \"\"\"Initializes a new track with unique ID and foundational tracking attributes.\"\"\"\n    self.track_id = 0\n    self.is_activated = False\n    self.state = TrackState.New\n    self.history = OrderedDict()\n    self.features = []\n    self.curr_feature = None\n    self.score = 0\n    self.start_frame = 0\n    self.frame_id = 0\n    self.time_since_update = 0\n    self.location = (np.inf, np.inf)\n</code></pre>"},{"location":"reference/trackers/basetrack/#ultralytics.trackers.basetrack.BaseTrack.activate","title":"<code>activate(*args)</code>","text":"<p>Abstract method to activate the track with provided arguments.</p> Source code in <code>ultralytics/trackers/basetrack.py</code> <pre><code>def activate(self, *args):\n    \"\"\"Abstract method to activate the track with provided arguments.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/trackers/basetrack/#ultralytics.trackers.basetrack.BaseTrack.mark_lost","title":"<code>mark_lost()</code>","text":"<p>Mark the track as lost.</p> Source code in <code>ultralytics/trackers/basetrack.py</code> <pre><code>def mark_lost(self):\n    \"\"\"Mark the track as lost.\"\"\"\n    self.state = TrackState.Lost\n</code></pre>"},{"location":"reference/trackers/basetrack/#ultralytics.trackers.basetrack.BaseTrack.mark_removed","title":"<code>mark_removed()</code>","text":"<p>Mark the track as removed.</p> Source code in <code>ultralytics/trackers/basetrack.py</code> <pre><code>def mark_removed(self):\n    \"\"\"Mark the track as removed.\"\"\"\n    self.state = TrackState.Removed\n</code></pre>"},{"location":"reference/trackers/basetrack/#ultralytics.trackers.basetrack.BaseTrack.next_id","title":"<code>next_id()</code>  <code>staticmethod</code>","text":"<p>Increment and return the global track ID counter.</p> Source code in <code>ultralytics/trackers/basetrack.py</code> <pre><code>@staticmethod\ndef next_id():\n    \"\"\"Increment and return the global track ID counter.\"\"\"\n    BaseTrack._count += 1\n    return BaseTrack._count\n</code></pre>"},{"location":"reference/trackers/basetrack/#ultralytics.trackers.basetrack.BaseTrack.predict","title":"<code>predict()</code>","text":"<p>Abstract method to predict the next state of the track.</p> Source code in <code>ultralytics/trackers/basetrack.py</code> <pre><code>def predict(self):\n    \"\"\"Abstract method to predict the next state of the track.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/trackers/basetrack/#ultralytics.trackers.basetrack.BaseTrack.reset_id","title":"<code>reset_id()</code>  <code>staticmethod</code>","text":"<p>Reset the global track ID counter.</p> Source code in <code>ultralytics/trackers/basetrack.py</code> <pre><code>@staticmethod\ndef reset_id():\n    \"\"\"Reset the global track ID counter.\"\"\"\n    BaseTrack._count = 0\n</code></pre>"},{"location":"reference/trackers/basetrack/#ultralytics.trackers.basetrack.BaseTrack.update","title":"<code>update(*args, **kwargs)</code>","text":"<p>Abstract method to update the track with new observations.</p> Source code in <code>ultralytics/trackers/basetrack.py</code> <pre><code>def update(self, *args, **kwargs):\n    \"\"\"Abstract method to update the track with new observations.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/trackers/bot_sort/","title":"Reference for <code>ultralytics/trackers/bot_sort.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/trackers/bot_sort.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p>"},{"location":"reference/trackers/bot_sort/#ultralytics.trackers.bot_sort.BOTrack","title":"<code>ultralytics.trackers.bot_sort.BOTrack</code>","text":"<p>             Bases: <code>STrack</code></p> <p>An extended version of the STrack class for YOLOv8, adding object tracking features.</p> <p>Attributes:</p> Name Type Description <code>shared_kalman</code> <code>KalmanFilterXYWH</code> <p>A shared Kalman filter for all instances of BOTrack.</p> <code>smooth_feat</code> <code>ndarray</code> <p>Smoothed feature vector.</p> <code>curr_feat</code> <code>ndarray</code> <p>Current feature vector.</p> <code>features</code> <code>deque</code> <p>A deque to store feature vectors with a maximum length defined by <code>feat_history</code>.</p> <code>alpha</code> <code>float</code> <p>Smoothing factor for the exponential moving average of features.</p> <code>mean</code> <code>ndarray</code> <p>The mean state of the Kalman filter.</p> <code>covariance</code> <code>ndarray</code> <p>The covariance matrix of the Kalman filter.</p> <p>Methods:</p> Name Description <code>update_features</code> <p>Update features vector and smooth it using exponential moving average.</p> <code>predict</code> <p>Predicts the mean and covariance using Kalman filter.</p> <code>re_activate</code> <p>Reactivates a track with updated features and optionally new ID.</p> <code>update</code> <p>Update the YOLOv8 instance with new track and frame ID.</p> <code>tlwh</code> <p>Property that gets the current position in tlwh format <code>(top left x, top left y, width, height)</code>.</p> <code>multi_predict</code> <p>Predicts the mean and covariance of multiple object tracks using shared Kalman filter.</p> <code>convert_coords</code> <p>Converts tlwh bounding box coordinates to xywh format.</p> <code>tlwh_to_xywh</code> <p>Convert bounding box to xywh format <code>(center x, center y, width, height)</code>.</p> Usage <p>bo_track = BOTrack(tlwh, score, cls, feat) bo_track.predict() bo_track.update(new_track, frame_id)</p> Source code in <code>ultralytics/trackers/bot_sort.py</code> <pre><code>class BOTrack(STrack):\n    \"\"\"\n    An extended version of the STrack class for YOLOv8, adding object tracking features.\n\n    Attributes:\n        shared_kalman (KalmanFilterXYWH): A shared Kalman filter for all instances of BOTrack.\n        smooth_feat (np.ndarray): Smoothed feature vector.\n        curr_feat (np.ndarray): Current feature vector.\n        features (deque): A deque to store feature vectors with a maximum length defined by `feat_history`.\n        alpha (float): Smoothing factor for the exponential moving average of features.\n        mean (np.ndarray): The mean state of the Kalman filter.\n        covariance (np.ndarray): The covariance matrix of the Kalman filter.\n\n    Methods:\n        update_features(feat): Update features vector and smooth it using exponential moving average.\n        predict(): Predicts the mean and covariance using Kalman filter.\n        re_activate(new_track, frame_id, new_id): Reactivates a track with updated features and optionally new ID.\n        update(new_track, frame_id): Update the YOLOv8 instance with new track and frame ID.\n        tlwh: Property that gets the current position in tlwh format `(top left x, top left y, width, height)`.\n        multi_predict(stracks): Predicts the mean and covariance of multiple object tracks using shared Kalman filter.\n        convert_coords(tlwh): Converts tlwh bounding box coordinates to xywh format.\n        tlwh_to_xywh(tlwh): Convert bounding box to xywh format `(center x, center y, width, height)`.\n\n    Usage:\n        bo_track = BOTrack(tlwh, score, cls, feat)\n        bo_track.predict()\n        bo_track.update(new_track, frame_id)\n    \"\"\"\n\n    shared_kalman = KalmanFilterXYWH()\n\n    def __init__(self, tlwh, score, cls, feat=None, feat_history=50):\n        \"\"\"Initialize YOLOv8 object with temporal parameters, such as feature history, alpha and current features.\"\"\"\n        super().__init__(tlwh, score, cls)\n\n        self.smooth_feat = None\n        self.curr_feat = None\n        if feat is not None:\n            self.update_features(feat)\n        self.features = deque([], maxlen=feat_history)\n        self.alpha = 0.9\n\n    def update_features(self, feat):\n        \"\"\"Update features vector and smooth it using exponential moving average.\"\"\"\n        feat /= np.linalg.norm(feat)\n        self.curr_feat = feat\n        if self.smooth_feat is None:\n            self.smooth_feat = feat\n        else:\n            self.smooth_feat = self.alpha * self.smooth_feat + (1 - self.alpha) * feat\n        self.features.append(feat)\n        self.smooth_feat /= np.linalg.norm(self.smooth_feat)\n\n    def predict(self):\n        \"\"\"Predicts the mean and covariance using Kalman filter.\"\"\"\n        mean_state = self.mean.copy()\n        if self.state != TrackState.Tracked:\n            mean_state[6] = 0\n            mean_state[7] = 0\n\n        self.mean, self.covariance = self.kalman_filter.predict(mean_state, self.covariance)\n\n    def re_activate(self, new_track, frame_id, new_id=False):\n        \"\"\"Reactivates a track with updated features and optionally assigns a new ID.\"\"\"\n        if new_track.curr_feat is not None:\n            self.update_features(new_track.curr_feat)\n        super().re_activate(new_track, frame_id, new_id)\n\n    def update(self, new_track, frame_id):\n        \"\"\"Update the YOLOv8 instance with new track and frame ID.\"\"\"\n        if new_track.curr_feat is not None:\n            self.update_features(new_track.curr_feat)\n        super().update(new_track, frame_id)\n\n    @property\n    def tlwh(self):\n        \"\"\"Get current position in bounding box format `(top left x, top left y, width, height)`.\"\"\"\n        if self.mean is None:\n            return self._tlwh.copy()\n        ret = self.mean[:4].copy()\n        ret[:2] -= ret[2:] / 2\n        return ret\n\n    @staticmethod\n    def multi_predict(stracks):\n        \"\"\"Predicts the mean and covariance of multiple object tracks using shared Kalman filter.\"\"\"\n        if len(stracks) &lt;= 0:\n            return\n        multi_mean = np.asarray([st.mean.copy() for st in stracks])\n        multi_covariance = np.asarray([st.covariance for st in stracks])\n        for i, st in enumerate(stracks):\n            if st.state != TrackState.Tracked:\n                multi_mean[i][6] = 0\n                multi_mean[i][7] = 0\n        multi_mean, multi_covariance = BOTrack.shared_kalman.multi_predict(multi_mean, multi_covariance)\n        for i, (mean, cov) in enumerate(zip(multi_mean, multi_covariance)):\n            stracks[i].mean = mean\n            stracks[i].covariance = cov\n\n    def convert_coords(self, tlwh):\n        \"\"\"Converts Top-Left-Width-Height bounding box coordinates to X-Y-Width-Height format.\"\"\"\n        return self.tlwh_to_xywh(tlwh)\n\n    @staticmethod\n    def tlwh_to_xywh(tlwh):\n        \"\"\"Convert bounding box to format `(center x, center y, width, height)`.\"\"\"\n        ret = np.asarray(tlwh).copy()\n        ret[:2] += ret[2:] / 2\n        return ret\n</code></pre>"},{"location":"reference/trackers/bot_sort/#ultralytics.trackers.bot_sort.BOTrack.tlwh","title":"<code>tlwh</code>  <code>property</code>","text":"<p>Get current position in bounding box format <code>(top left x, top left y, width, height)</code>.</p>"},{"location":"reference/trackers/bot_sort/#ultralytics.trackers.bot_sort.BOTrack.__init__","title":"<code>__init__(tlwh, score, cls, feat=None, feat_history=50)</code>","text":"<p>Initialize YOLOv8 object with temporal parameters, such as feature history, alpha and current features.</p> Source code in <code>ultralytics/trackers/bot_sort.py</code> <pre><code>def __init__(self, tlwh, score, cls, feat=None, feat_history=50):\n    \"\"\"Initialize YOLOv8 object with temporal parameters, such as feature history, alpha and current features.\"\"\"\n    super().__init__(tlwh, score, cls)\n\n    self.smooth_feat = None\n    self.curr_feat = None\n    if feat is not None:\n        self.update_features(feat)\n    self.features = deque([], maxlen=feat_history)\n    self.alpha = 0.9\n</code></pre>"},{"location":"reference/trackers/bot_sort/#ultralytics.trackers.bot_sort.BOTrack.convert_coords","title":"<code>convert_coords(tlwh)</code>","text":"<p>Converts Top-Left-Width-Height bounding box coordinates to X-Y-Width-Height format.</p> Source code in <code>ultralytics/trackers/bot_sort.py</code> <pre><code>def convert_coords(self, tlwh):\n    \"\"\"Converts Top-Left-Width-Height bounding box coordinates to X-Y-Width-Height format.\"\"\"\n    return self.tlwh_to_xywh(tlwh)\n</code></pre>"},{"location":"reference/trackers/bot_sort/#ultralytics.trackers.bot_sort.BOTrack.multi_predict","title":"<code>multi_predict(stracks)</code>  <code>staticmethod</code>","text":"<p>Predicts the mean and covariance of multiple object tracks using shared Kalman filter.</p> Source code in <code>ultralytics/trackers/bot_sort.py</code> <pre><code>@staticmethod\ndef multi_predict(stracks):\n    \"\"\"Predicts the mean and covariance of multiple object tracks using shared Kalman filter.\"\"\"\n    if len(stracks) &lt;= 0:\n        return\n    multi_mean = np.asarray([st.mean.copy() for st in stracks])\n    multi_covariance = np.asarray([st.covariance for st in stracks])\n    for i, st in enumerate(stracks):\n        if st.state != TrackState.Tracked:\n            multi_mean[i][6] = 0\n            multi_mean[i][7] = 0\n    multi_mean, multi_covariance = BOTrack.shared_kalman.multi_predict(multi_mean, multi_covariance)\n    for i, (mean, cov) in enumerate(zip(multi_mean, multi_covariance)):\n        stracks[i].mean = mean\n        stracks[i].covariance = cov\n</code></pre>"},{"location":"reference/trackers/bot_sort/#ultralytics.trackers.bot_sort.BOTrack.predict","title":"<code>predict()</code>","text":"<p>Predicts the mean and covariance using Kalman filter.</p> Source code in <code>ultralytics/trackers/bot_sort.py</code> <pre><code>def predict(self):\n    \"\"\"Predicts the mean and covariance using Kalman filter.\"\"\"\n    mean_state = self.mean.copy()\n    if self.state != TrackState.Tracked:\n        mean_state[6] = 0\n        mean_state[7] = 0\n\n    self.mean, self.covariance = self.kalman_filter.predict(mean_state, self.covariance)\n</code></pre>"},{"location":"reference/trackers/bot_sort/#ultralytics.trackers.bot_sort.BOTrack.re_activate","title":"<code>re_activate(new_track, frame_id, new_id=False)</code>","text":"<p>Reactivates a track with updated features and optionally assigns a new ID.</p> Source code in <code>ultralytics/trackers/bot_sort.py</code> <pre><code>def re_activate(self, new_track, frame_id, new_id=False):\n    \"\"\"Reactivates a track with updated features and optionally assigns a new ID.\"\"\"\n    if new_track.curr_feat is not None:\n        self.update_features(new_track.curr_feat)\n    super().re_activate(new_track, frame_id, new_id)\n</code></pre>"},{"location":"reference/trackers/bot_sort/#ultralytics.trackers.bot_sort.BOTrack.tlwh_to_xywh","title":"<code>tlwh_to_xywh(tlwh)</code>  <code>staticmethod</code>","text":"<p>Convert bounding box to format <code>(center x, center y, width, height)</code>.</p> Source code in <code>ultralytics/trackers/bot_sort.py</code> <pre><code>@staticmethod\ndef tlwh_to_xywh(tlwh):\n    \"\"\"Convert bounding box to format `(center x, center y, width, height)`.\"\"\"\n    ret = np.asarray(tlwh).copy()\n    ret[:2] += ret[2:] / 2\n    return ret\n</code></pre>"},{"location":"reference/trackers/bot_sort/#ultralytics.trackers.bot_sort.BOTrack.update","title":"<code>update(new_track, frame_id)</code>","text":"<p>Update the YOLOv8 instance with new track and frame ID.</p> Source code in <code>ultralytics/trackers/bot_sort.py</code> <pre><code>def update(self, new_track, frame_id):\n    \"\"\"Update the YOLOv8 instance with new track and frame ID.\"\"\"\n    if new_track.curr_feat is not None:\n        self.update_features(new_track.curr_feat)\n    super().update(new_track, frame_id)\n</code></pre>"},{"location":"reference/trackers/bot_sort/#ultralytics.trackers.bot_sort.BOTrack.update_features","title":"<code>update_features(feat)</code>","text":"<p>Update features vector and smooth it using exponential moving average.</p> Source code in <code>ultralytics/trackers/bot_sort.py</code> <pre><code>def update_features(self, feat):\n    \"\"\"Update features vector and smooth it using exponential moving average.\"\"\"\n    feat /= np.linalg.norm(feat)\n    self.curr_feat = feat\n    if self.smooth_feat is None:\n        self.smooth_feat = feat\n    else:\n        self.smooth_feat = self.alpha * self.smooth_feat + (1 - self.alpha) * feat\n    self.features.append(feat)\n    self.smooth_feat /= np.linalg.norm(self.smooth_feat)\n</code></pre>"},{"location":"reference/trackers/bot_sort/#ultralytics.trackers.bot_sort.BOTSORT","title":"<code>ultralytics.trackers.bot_sort.BOTSORT</code>","text":"<p>             Bases: <code>BYTETracker</code></p> <p>An extended version of the BYTETracker class for YOLOv8, designed for object tracking with ReID and GMC algorithm.</p> <p>Attributes:</p> Name Type Description <code>proximity_thresh</code> <code>float</code> <p>Threshold for spatial proximity (IoU) between tracks and detections.</p> <code>appearance_thresh</code> <code>float</code> <p>Threshold for appearance similarity (ReID embeddings) between tracks and detections.</p> <code>encoder</code> <code>object</code> <p>Object to handle ReID embeddings, set to None if ReID is not enabled.</p> <code>gmc</code> <code>GMC</code> <p>An instance of the GMC algorithm for data association.</p> <code>args</code> <code>object</code> <p>Parsed command-line arguments containing tracking parameters.</p> <p>Methods:</p> Name Description <code>get_kalmanfilter</code> <p>Returns an instance of KalmanFilterXYWH for object tracking.</p> <code>init_track</code> <p>Initialize track with detections, scores, and classes.</p> <code>get_dists</code> <p>Get distances between tracks and detections using IoU and (optionally) ReID.</p> <code>multi_predict</code> <p>Predict and track multiple objects with YOLOv8 model.</p> Usage <p>bot_sort = BOTSORT(args, frame_rate) bot_sort.init_track(dets, scores, cls, img) bot_sort.multi_predict(tracks)</p> Note <p>The class is designed to work with the YOLOv8 object detection model and supports ReID only if enabled via args.</p> Source code in <code>ultralytics/trackers/bot_sort.py</code> <pre><code>class BOTSORT(BYTETracker):\n    \"\"\"\n    An extended version of the BYTETracker class for YOLOv8, designed for object tracking with ReID and GMC algorithm.\n\n    Attributes:\n        proximity_thresh (float): Threshold for spatial proximity (IoU) between tracks and detections.\n        appearance_thresh (float): Threshold for appearance similarity (ReID embeddings) between tracks and detections.\n        encoder (object): Object to handle ReID embeddings, set to None if ReID is not enabled.\n        gmc (GMC): An instance of the GMC algorithm for data association.\n        args (object): Parsed command-line arguments containing tracking parameters.\n\n    Methods:\n        get_kalmanfilter(): Returns an instance of KalmanFilterXYWH for object tracking.\n        init_track(dets, scores, cls, img): Initialize track with detections, scores, and classes.\n        get_dists(tracks, detections): Get distances between tracks and detections using IoU and (optionally) ReID.\n        multi_predict(tracks): Predict and track multiple objects with YOLOv8 model.\n\n    Usage:\n        bot_sort = BOTSORT(args, frame_rate)\n        bot_sort.init_track(dets, scores, cls, img)\n        bot_sort.multi_predict(tracks)\n\n    Note:\n        The class is designed to work with the YOLOv8 object detection model and supports ReID only if enabled via args.\n    \"\"\"\n\n    def __init__(self, args, frame_rate=30):\n        \"\"\"Initialize YOLOv8 object with ReID module and GMC algorithm.\"\"\"\n        super().__init__(args, frame_rate)\n        # ReID module\n        self.proximity_thresh = args.proximity_thresh\n        self.appearance_thresh = args.appearance_thresh\n\n        if args.with_reid:\n            # Haven't supported BoT-SORT(reid) yet\n            self.encoder = None\n        self.gmc = GMC(method=args.gmc_method)\n\n    def get_kalmanfilter(self):\n        \"\"\"Returns an instance of KalmanFilterXYWH for object tracking.\"\"\"\n        return KalmanFilterXYWH()\n\n    def init_track(self, dets, scores, cls, img=None):\n        \"\"\"Initialize track with detections, scores, and classes.\"\"\"\n        if len(dets) == 0:\n            return []\n        if self.args.with_reid and self.encoder is not None:\n            features_keep = self.encoder.inference(img, dets)\n            return [BOTrack(xyxy, s, c, f) for (xyxy, s, c, f) in zip(dets, scores, cls, features_keep)]  # detections\n        else:\n            return [BOTrack(xyxy, s, c) for (xyxy, s, c) in zip(dets, scores, cls)]  # detections\n\n    def get_dists(self, tracks, detections):\n        \"\"\"Get distances between tracks and detections using IoU and (optionally) ReID embeddings.\"\"\"\n        dists = matching.iou_distance(tracks, detections)\n        dists_mask = dists &gt; self.proximity_thresh\n\n        # TODO: mot20\n        # if not self.args.mot20:\n        dists = matching.fuse_score(dists, detections)\n\n        if self.args.with_reid and self.encoder is not None:\n            emb_dists = matching.embedding_distance(tracks, detections) / 2.0\n            emb_dists[emb_dists &gt; self.appearance_thresh] = 1.0\n            emb_dists[dists_mask] = 1.0\n            dists = np.minimum(dists, emb_dists)\n        return dists\n\n    def multi_predict(self, tracks):\n        \"\"\"Predict and track multiple objects with YOLOv8 model.\"\"\"\n        BOTrack.multi_predict(tracks)\n\n    def reset(self):\n        \"\"\"Reset tracker.\"\"\"\n        super().reset()\n        self.gmc.reset_params()\n</code></pre>"},{"location":"reference/trackers/bot_sort/#ultralytics.trackers.bot_sort.BOTSORT.__init__","title":"<code>__init__(args, frame_rate=30)</code>","text":"<p>Initialize YOLOv8 object with ReID module and GMC algorithm.</p> Source code in <code>ultralytics/trackers/bot_sort.py</code> <pre><code>def __init__(self, args, frame_rate=30):\n    \"\"\"Initialize YOLOv8 object with ReID module and GMC algorithm.\"\"\"\n    super().__init__(args, frame_rate)\n    # ReID module\n    self.proximity_thresh = args.proximity_thresh\n    self.appearance_thresh = args.appearance_thresh\n\n    if args.with_reid:\n        # Haven't supported BoT-SORT(reid) yet\n        self.encoder = None\n    self.gmc = GMC(method=args.gmc_method)\n</code></pre>"},{"location":"reference/trackers/bot_sort/#ultralytics.trackers.bot_sort.BOTSORT.get_dists","title":"<code>get_dists(tracks, detections)</code>","text":"<p>Get distances between tracks and detections using IoU and (optionally) ReID embeddings.</p> Source code in <code>ultralytics/trackers/bot_sort.py</code> <pre><code>def get_dists(self, tracks, detections):\n    \"\"\"Get distances between tracks and detections using IoU and (optionally) ReID embeddings.\"\"\"\n    dists = matching.iou_distance(tracks, detections)\n    dists_mask = dists &gt; self.proximity_thresh\n\n    # TODO: mot20\n    # if not self.args.mot20:\n    dists = matching.fuse_score(dists, detections)\n\n    if self.args.with_reid and self.encoder is not None:\n        emb_dists = matching.embedding_distance(tracks, detections) / 2.0\n        emb_dists[emb_dists &gt; self.appearance_thresh] = 1.0\n        emb_dists[dists_mask] = 1.0\n        dists = np.minimum(dists, emb_dists)\n    return dists\n</code></pre>"},{"location":"reference/trackers/bot_sort/#ultralytics.trackers.bot_sort.BOTSORT.get_kalmanfilter","title":"<code>get_kalmanfilter()</code>","text":"<p>Returns an instance of KalmanFilterXYWH for object tracking.</p> Source code in <code>ultralytics/trackers/bot_sort.py</code> <pre><code>def get_kalmanfilter(self):\n    \"\"\"Returns an instance of KalmanFilterXYWH for object tracking.\"\"\"\n    return KalmanFilterXYWH()\n</code></pre>"},{"location":"reference/trackers/bot_sort/#ultralytics.trackers.bot_sort.BOTSORT.init_track","title":"<code>init_track(dets, scores, cls, img=None)</code>","text":"<p>Initialize track with detections, scores, and classes.</p> Source code in <code>ultralytics/trackers/bot_sort.py</code> <pre><code>def init_track(self, dets, scores, cls, img=None):\n    \"\"\"Initialize track with detections, scores, and classes.\"\"\"\n    if len(dets) == 0:\n        return []\n    if self.args.with_reid and self.encoder is not None:\n        features_keep = self.encoder.inference(img, dets)\n        return [BOTrack(xyxy, s, c, f) for (xyxy, s, c, f) in zip(dets, scores, cls, features_keep)]  # detections\n    else:\n        return [BOTrack(xyxy, s, c) for (xyxy, s, c) in zip(dets, scores, cls)]  # detections\n</code></pre>"},{"location":"reference/trackers/bot_sort/#ultralytics.trackers.bot_sort.BOTSORT.multi_predict","title":"<code>multi_predict(tracks)</code>","text":"<p>Predict and track multiple objects with YOLOv8 model.</p> Source code in <code>ultralytics/trackers/bot_sort.py</code> <pre><code>def multi_predict(self, tracks):\n    \"\"\"Predict and track multiple objects with YOLOv8 model.\"\"\"\n    BOTrack.multi_predict(tracks)\n</code></pre>"},{"location":"reference/trackers/bot_sort/#ultralytics.trackers.bot_sort.BOTSORT.reset","title":"<code>reset()</code>","text":"<p>Reset tracker.</p> Source code in <code>ultralytics/trackers/bot_sort.py</code> <pre><code>def reset(self):\n    \"\"\"Reset tracker.\"\"\"\n    super().reset()\n    self.gmc.reset_params()\n</code></pre>"},{"location":"reference/trackers/byte_tracker/","title":"Reference for <code>ultralytics/trackers/byte_tracker.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/trackers/byte_tracker.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p>"},{"location":"reference/trackers/byte_tracker/#ultralytics.trackers.byte_tracker.STrack","title":"<code>ultralytics.trackers.byte_tracker.STrack</code>","text":"<p>             Bases: <code>BaseTrack</code></p> <p>Single object tracking representation that uses Kalman filtering for state estimation.</p> <p>This class is responsible for storing all the information regarding individual tracklets and performs state updates and predictions based on Kalman filter.</p> <p>Attributes:</p> Name Type Description <code>shared_kalman</code> <code>KalmanFilterXYAH</code> <p>Shared Kalman filter that is used across all STrack instances for prediction.</p> <code>_tlwh</code> <code>ndarray</code> <p>Private attribute to store top-left corner coordinates and width and height of bounding box.</p> <code>kalman_filter</code> <code>KalmanFilterXYAH</code> <p>Instance of Kalman filter used for this particular object track.</p> <code>mean</code> <code>ndarray</code> <p>Mean state estimate vector.</p> <code>covariance</code> <code>ndarray</code> <p>Covariance of state estimate.</p> <code>is_activated</code> <code>bool</code> <p>Boolean flag indicating if the track has been activated.</p> <code>score</code> <code>float</code> <p>Confidence score of the track.</p> <code>tracklet_len</code> <code>int</code> <p>Length of the tracklet.</p> <code>cls</code> <code>any</code> <p>Class label for the object.</p> <code>idx</code> <code>int</code> <p>Index or identifier for the object.</p> <code>frame_id</code> <code>int</code> <p>Current frame ID.</p> <code>start_frame</code> <code>int</code> <p>Frame where the object was first detected.</p> <p>Methods:</p> Name Description <code>predict</code> <p>Predict the next state of the object using Kalman filter.</p> <code>multi_predict</code> <p>Predict the next states for multiple tracks.</p> <code>multi_gmc</code> <p>Update multiple track states using a homography matrix.</p> <code>activate</code> <p>Activate a new tracklet.</p> <code>re_activate</code> <p>Reactivate a previously lost tracklet.</p> <code>update</code> <p>Update the state of a matched track.</p> <code>convert_coords</code> <p>Convert bounding box to x-y-angle-height format.</p> <code>tlwh_to_xyah</code> <p>Convert tlwh bounding box to xyah format.</p> <code>tlbr_to_tlwh</code> <p>Convert tlbr bounding box to tlwh format.</p> <code>tlwh_to_tlbr</code> <p>Convert tlwh bounding box to tlbr format.</p> Source code in <code>ultralytics/trackers/byte_tracker.py</code> <pre><code>class STrack(BaseTrack):\n    \"\"\"\n    Single object tracking representation that uses Kalman filtering for state estimation.\n\n    This class is responsible for storing all the information regarding individual tracklets and performs state updates\n    and predictions based on Kalman filter.\n\n    Attributes:\n        shared_kalman (KalmanFilterXYAH): Shared Kalman filter that is used across all STrack instances for prediction.\n        _tlwh (np.ndarray): Private attribute to store top-left corner coordinates and width and height of bounding box.\n        kalman_filter (KalmanFilterXYAH): Instance of Kalman filter used for this particular object track.\n        mean (np.ndarray): Mean state estimate vector.\n        covariance (np.ndarray): Covariance of state estimate.\n        is_activated (bool): Boolean flag indicating if the track has been activated.\n        score (float): Confidence score of the track.\n        tracklet_len (int): Length of the tracklet.\n        cls (any): Class label for the object.\n        idx (int): Index or identifier for the object.\n        frame_id (int): Current frame ID.\n        start_frame (int): Frame where the object was first detected.\n\n    Methods:\n        predict(): Predict the next state of the object using Kalman filter.\n        multi_predict(stracks): Predict the next states for multiple tracks.\n        multi_gmc(stracks, H): Update multiple track states using a homography matrix.\n        activate(kalman_filter, frame_id): Activate a new tracklet.\n        re_activate(new_track, frame_id, new_id): Reactivate a previously lost tracklet.\n        update(new_track, frame_id): Update the state of a matched track.\n        convert_coords(tlwh): Convert bounding box to x-y-angle-height format.\n        tlwh_to_xyah(tlwh): Convert tlwh bounding box to xyah format.\n        tlbr_to_tlwh(tlbr): Convert tlbr bounding box to tlwh format.\n        tlwh_to_tlbr(tlwh): Convert tlwh bounding box to tlbr format.\n    \"\"\"\n\n    shared_kalman = KalmanFilterXYAH()\n\n    def __init__(self, tlwh, score, cls):\n        \"\"\"Initialize new STrack instance.\"\"\"\n        super().__init__()\n        self._tlwh = np.asarray(self.tlbr_to_tlwh(tlwh[:-1]), dtype=np.float32)\n        self.kalman_filter = None\n        self.mean, self.covariance = None, None\n        self.is_activated = False\n\n        self.score = score\n        self.tracklet_len = 0\n        self.cls = cls\n        self.idx = tlwh[-1]\n\n    def predict(self):\n        \"\"\"Predicts mean and covariance using Kalman filter.\"\"\"\n        mean_state = self.mean.copy()\n        if self.state != TrackState.Tracked:\n            mean_state[7] = 0\n        self.mean, self.covariance = self.kalman_filter.predict(mean_state, self.covariance)\n\n    @staticmethod\n    def multi_predict(stracks):\n        \"\"\"Perform multi-object predictive tracking using Kalman filter for given stracks.\"\"\"\n        if len(stracks) &lt;= 0:\n            return\n        multi_mean = np.asarray([st.mean.copy() for st in stracks])\n        multi_covariance = np.asarray([st.covariance for st in stracks])\n        for i, st in enumerate(stracks):\n            if st.state != TrackState.Tracked:\n                multi_mean[i][7] = 0\n        multi_mean, multi_covariance = STrack.shared_kalman.multi_predict(multi_mean, multi_covariance)\n        for i, (mean, cov) in enumerate(zip(multi_mean, multi_covariance)):\n            stracks[i].mean = mean\n            stracks[i].covariance = cov\n\n    @staticmethod\n    def multi_gmc(stracks, H=np.eye(2, 3)):\n        \"\"\"Update state tracks positions and covariances using a homography matrix.\"\"\"\n        if len(stracks) &gt; 0:\n            multi_mean = np.asarray([st.mean.copy() for st in stracks])\n            multi_covariance = np.asarray([st.covariance for st in stracks])\n\n            R = H[:2, :2]\n            R8x8 = np.kron(np.eye(4, dtype=float), R)\n            t = H[:2, 2]\n\n            for i, (mean, cov) in enumerate(zip(multi_mean, multi_covariance)):\n                mean = R8x8.dot(mean)\n                mean[:2] += t\n                cov = R8x8.dot(cov).dot(R8x8.transpose())\n\n                stracks[i].mean = mean\n                stracks[i].covariance = cov\n\n    def activate(self, kalman_filter, frame_id):\n        \"\"\"Start a new tracklet.\"\"\"\n        self.kalman_filter = kalman_filter\n        self.track_id = self.next_id()\n        self.mean, self.covariance = self.kalman_filter.initiate(self.convert_coords(self._tlwh))\n\n        self.tracklet_len = 0\n        self.state = TrackState.Tracked\n        if frame_id == 1:\n            self.is_activated = True\n        self.frame_id = frame_id\n        self.start_frame = frame_id\n\n    def re_activate(self, new_track, frame_id, new_id=False):\n        \"\"\"Reactivates a previously lost track with a new detection.\"\"\"\n        self.mean, self.covariance = self.kalman_filter.update(\n            self.mean, self.covariance, self.convert_coords(new_track.tlwh)\n        )\n        self.tracklet_len = 0\n        self.state = TrackState.Tracked\n        self.is_activated = True\n        self.frame_id = frame_id\n        if new_id:\n            self.track_id = self.next_id()\n        self.score = new_track.score\n        self.cls = new_track.cls\n        self.idx = new_track.idx\n\n    def update(self, new_track, frame_id):\n        \"\"\"\n        Update the state of a matched track.\n\n        Args:\n            new_track (STrack): The new track containing updated information.\n            frame_id (int): The ID of the current frame.\n        \"\"\"\n        self.frame_id = frame_id\n        self.tracklet_len += 1\n\n        new_tlwh = new_track.tlwh\n        self.mean, self.covariance = self.kalman_filter.update(\n            self.mean, self.covariance, self.convert_coords(new_tlwh)\n        )\n        self.state = TrackState.Tracked\n        self.is_activated = True\n\n        self.score = new_track.score\n        self.cls = new_track.cls\n        self.idx = new_track.idx\n\n    def convert_coords(self, tlwh):\n        \"\"\"Convert a bounding box's top-left-width-height format to its x-y-angle-height equivalent.\"\"\"\n        return self.tlwh_to_xyah(tlwh)\n\n    @property\n    def tlwh(self):\n        \"\"\"Get current position in bounding box format (top left x, top left y, width, height).\"\"\"\n        if self.mean is None:\n            return self._tlwh.copy()\n        ret = self.mean[:4].copy()\n        ret[2] *= ret[3]\n        ret[:2] -= ret[2:] / 2\n        return ret\n\n    @property\n    def tlbr(self):\n        \"\"\"Convert bounding box to format (min x, min y, max x, max y), i.e., (top left, bottom right).\"\"\"\n        ret = self.tlwh.copy()\n        ret[2:] += ret[:2]\n        return ret\n\n    @staticmethod\n    def tlwh_to_xyah(tlwh):\n        \"\"\"Convert bounding box to format (center x, center y, aspect ratio, height), where the aspect ratio is width /\n        height.\n        \"\"\"\n        ret = np.asarray(tlwh).copy()\n        ret[:2] += ret[2:] / 2\n        ret[2] /= ret[3]\n        return ret\n\n    @staticmethod\n    def tlbr_to_tlwh(tlbr):\n        \"\"\"Converts top-left bottom-right format to top-left width height format.\"\"\"\n        ret = np.asarray(tlbr).copy()\n        ret[2:] -= ret[:2]\n        return ret\n\n    @staticmethod\n    def tlwh_to_tlbr(tlwh):\n        \"\"\"Converts tlwh bounding box format to tlbr format.\"\"\"\n        ret = np.asarray(tlwh).copy()\n        ret[2:] += ret[:2]\n        return ret\n\n    def __repr__(self):\n        \"\"\"Return a string representation of the BYTETracker object with start and end frames and track ID.\"\"\"\n        return f\"OT_{self.track_id}_({self.start_frame}-{self.end_frame})\"\n</code></pre>"},{"location":"reference/trackers/byte_tracker/#ultralytics.trackers.byte_tracker.STrack.tlbr","title":"<code>tlbr</code>  <code>property</code>","text":"<p>Convert bounding box to format (min x, min y, max x, max y), i.e., (top left, bottom right).</p>"},{"location":"reference/trackers/byte_tracker/#ultralytics.trackers.byte_tracker.STrack.tlwh","title":"<code>tlwh</code>  <code>property</code>","text":"<p>Get current position in bounding box format (top left x, top left y, width, height).</p>"},{"location":"reference/trackers/byte_tracker/#ultralytics.trackers.byte_tracker.STrack.__init__","title":"<code>__init__(tlwh, score, cls)</code>","text":"<p>Initialize new STrack instance.</p> Source code in <code>ultralytics/trackers/byte_tracker.py</code> <pre><code>def __init__(self, tlwh, score, cls):\n    \"\"\"Initialize new STrack instance.\"\"\"\n    super().__init__()\n    self._tlwh = np.asarray(self.tlbr_to_tlwh(tlwh[:-1]), dtype=np.float32)\n    self.kalman_filter = None\n    self.mean, self.covariance = None, None\n    self.is_activated = False\n\n    self.score = score\n    self.tracklet_len = 0\n    self.cls = cls\n    self.idx = tlwh[-1]\n</code></pre>"},{"location":"reference/trackers/byte_tracker/#ultralytics.trackers.byte_tracker.STrack.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the BYTETracker object with start and end frames and track ID.</p> Source code in <code>ultralytics/trackers/byte_tracker.py</code> <pre><code>def __repr__(self):\n    \"\"\"Return a string representation of the BYTETracker object with start and end frames and track ID.\"\"\"\n    return f\"OT_{self.track_id}_({self.start_frame}-{self.end_frame})\"\n</code></pre>"},{"location":"reference/trackers/byte_tracker/#ultralytics.trackers.byte_tracker.STrack.activate","title":"<code>activate(kalman_filter, frame_id)</code>","text":"<p>Start a new tracklet.</p> Source code in <code>ultralytics/trackers/byte_tracker.py</code> <pre><code>def activate(self, kalman_filter, frame_id):\n    \"\"\"Start a new tracklet.\"\"\"\n    self.kalman_filter = kalman_filter\n    self.track_id = self.next_id()\n    self.mean, self.covariance = self.kalman_filter.initiate(self.convert_coords(self._tlwh))\n\n    self.tracklet_len = 0\n    self.state = TrackState.Tracked\n    if frame_id == 1:\n        self.is_activated = True\n    self.frame_id = frame_id\n    self.start_frame = frame_id\n</code></pre>"},{"location":"reference/trackers/byte_tracker/#ultralytics.trackers.byte_tracker.STrack.convert_coords","title":"<code>convert_coords(tlwh)</code>","text":"<p>Convert a bounding box's top-left-width-height format to its x-y-angle-height equivalent.</p> Source code in <code>ultralytics/trackers/byte_tracker.py</code> <pre><code>def convert_coords(self, tlwh):\n    \"\"\"Convert a bounding box's top-left-width-height format to its x-y-angle-height equivalent.\"\"\"\n    return self.tlwh_to_xyah(tlwh)\n</code></pre>"},{"location":"reference/trackers/byte_tracker/#ultralytics.trackers.byte_tracker.STrack.multi_gmc","title":"<code>multi_gmc(stracks, H=np.eye(2, 3))</code>  <code>staticmethod</code>","text":"<p>Update state tracks positions and covariances using a homography matrix.</p> Source code in <code>ultralytics/trackers/byte_tracker.py</code> <pre><code>@staticmethod\ndef multi_gmc(stracks, H=np.eye(2, 3)):\n    \"\"\"Update state tracks positions and covariances using a homography matrix.\"\"\"\n    if len(stracks) &gt; 0:\n        multi_mean = np.asarray([st.mean.copy() for st in stracks])\n        multi_covariance = np.asarray([st.covariance for st in stracks])\n\n        R = H[:2, :2]\n        R8x8 = np.kron(np.eye(4, dtype=float), R)\n        t = H[:2, 2]\n\n        for i, (mean, cov) in enumerate(zip(multi_mean, multi_covariance)):\n            mean = R8x8.dot(mean)\n            mean[:2] += t\n            cov = R8x8.dot(cov).dot(R8x8.transpose())\n\n            stracks[i].mean = mean\n            stracks[i].covariance = cov\n</code></pre>"},{"location":"reference/trackers/byte_tracker/#ultralytics.trackers.byte_tracker.STrack.multi_predict","title":"<code>multi_predict(stracks)</code>  <code>staticmethod</code>","text":"<p>Perform multi-object predictive tracking using Kalman filter for given stracks.</p> Source code in <code>ultralytics/trackers/byte_tracker.py</code> <pre><code>@staticmethod\ndef multi_predict(stracks):\n    \"\"\"Perform multi-object predictive tracking using Kalman filter for given stracks.\"\"\"\n    if len(stracks) &lt;= 0:\n        return\n    multi_mean = np.asarray([st.mean.copy() for st in stracks])\n    multi_covariance = np.asarray([st.covariance for st in stracks])\n    for i, st in enumerate(stracks):\n        if st.state != TrackState.Tracked:\n            multi_mean[i][7] = 0\n    multi_mean, multi_covariance = STrack.shared_kalman.multi_predict(multi_mean, multi_covariance)\n    for i, (mean, cov) in enumerate(zip(multi_mean, multi_covariance)):\n        stracks[i].mean = mean\n        stracks[i].covariance = cov\n</code></pre>"},{"location":"reference/trackers/byte_tracker/#ultralytics.trackers.byte_tracker.STrack.predict","title":"<code>predict()</code>","text":"<p>Predicts mean and covariance using Kalman filter.</p> Source code in <code>ultralytics/trackers/byte_tracker.py</code> <pre><code>def predict(self):\n    \"\"\"Predicts mean and covariance using Kalman filter.\"\"\"\n    mean_state = self.mean.copy()\n    if self.state != TrackState.Tracked:\n        mean_state[7] = 0\n    self.mean, self.covariance = self.kalman_filter.predict(mean_state, self.covariance)\n</code></pre>"},{"location":"reference/trackers/byte_tracker/#ultralytics.trackers.byte_tracker.STrack.re_activate","title":"<code>re_activate(new_track, frame_id, new_id=False)</code>","text":"<p>Reactivates a previously lost track with a new detection.</p> Source code in <code>ultralytics/trackers/byte_tracker.py</code> <pre><code>def re_activate(self, new_track, frame_id, new_id=False):\n    \"\"\"Reactivates a previously lost track with a new detection.\"\"\"\n    self.mean, self.covariance = self.kalman_filter.update(\n        self.mean, self.covariance, self.convert_coords(new_track.tlwh)\n    )\n    self.tracklet_len = 0\n    self.state = TrackState.Tracked\n    self.is_activated = True\n    self.frame_id = frame_id\n    if new_id:\n        self.track_id = self.next_id()\n    self.score = new_track.score\n    self.cls = new_track.cls\n    self.idx = new_track.idx\n</code></pre>"},{"location":"reference/trackers/byte_tracker/#ultralytics.trackers.byte_tracker.STrack.tlbr_to_tlwh","title":"<code>tlbr_to_tlwh(tlbr)</code>  <code>staticmethod</code>","text":"<p>Converts top-left bottom-right format to top-left width height format.</p> Source code in <code>ultralytics/trackers/byte_tracker.py</code> <pre><code>@staticmethod\ndef tlbr_to_tlwh(tlbr):\n    \"\"\"Converts top-left bottom-right format to top-left width height format.\"\"\"\n    ret = np.asarray(tlbr).copy()\n    ret[2:] -= ret[:2]\n    return ret\n</code></pre>"},{"location":"reference/trackers/byte_tracker/#ultralytics.trackers.byte_tracker.STrack.tlwh_to_tlbr","title":"<code>tlwh_to_tlbr(tlwh)</code>  <code>staticmethod</code>","text":"<p>Converts tlwh bounding box format to tlbr format.</p> Source code in <code>ultralytics/trackers/byte_tracker.py</code> <pre><code>@staticmethod\ndef tlwh_to_tlbr(tlwh):\n    \"\"\"Converts tlwh bounding box format to tlbr format.\"\"\"\n    ret = np.asarray(tlwh).copy()\n    ret[2:] += ret[:2]\n    return ret\n</code></pre>"},{"location":"reference/trackers/byte_tracker/#ultralytics.trackers.byte_tracker.STrack.tlwh_to_xyah","title":"<code>tlwh_to_xyah(tlwh)</code>  <code>staticmethod</code>","text":"<p>Convert bounding box to format (center x, center y, aspect ratio, height), where the aspect ratio is width / height.</p> Source code in <code>ultralytics/trackers/byte_tracker.py</code> <pre><code>@staticmethod\ndef tlwh_to_xyah(tlwh):\n    \"\"\"Convert bounding box to format (center x, center y, aspect ratio, height), where the aspect ratio is width /\n    height.\n    \"\"\"\n    ret = np.asarray(tlwh).copy()\n    ret[:2] += ret[2:] / 2\n    ret[2] /= ret[3]\n    return ret\n</code></pre>"},{"location":"reference/trackers/byte_tracker/#ultralytics.trackers.byte_tracker.STrack.update","title":"<code>update(new_track, frame_id)</code>","text":"<p>Update the state of a matched track.</p> <p>Parameters:</p> Name Type Description Default <code>new_track</code> <code>STrack</code> <p>The new track containing updated information.</p> required <code>frame_id</code> <code>int</code> <p>The ID of the current frame.</p> required Source code in <code>ultralytics/trackers/byte_tracker.py</code> <pre><code>def update(self, new_track, frame_id):\n    \"\"\"\n    Update the state of a matched track.\n\n    Args:\n        new_track (STrack): The new track containing updated information.\n        frame_id (int): The ID of the current frame.\n    \"\"\"\n    self.frame_id = frame_id\n    self.tracklet_len += 1\n\n    new_tlwh = new_track.tlwh\n    self.mean, self.covariance = self.kalman_filter.update(\n        self.mean, self.covariance, self.convert_coords(new_tlwh)\n    )\n    self.state = TrackState.Tracked\n    self.is_activated = True\n\n    self.score = new_track.score\n    self.cls = new_track.cls\n    self.idx = new_track.idx\n</code></pre>"},{"location":"reference/trackers/byte_tracker/#ultralytics.trackers.byte_tracker.BYTETracker","title":"<code>ultralytics.trackers.byte_tracker.BYTETracker</code>","text":"<p>BYTETracker: A tracking algorithm built on top of YOLOv8 for object detection and tracking.</p> <p>The class is responsible for initializing, updating, and managing the tracks for detected objects in a video sequence. It maintains the state of tracked, lost, and removed tracks over frames, utilizes Kalman filtering for predicting the new object locations, and performs data association.</p> <p>Attributes:</p> Name Type Description <code>tracked_stracks</code> <code>list[STrack]</code> <p>List of successfully activated tracks.</p> <code>lost_stracks</code> <code>list[STrack]</code> <p>List of lost tracks.</p> <code>removed_stracks</code> <code>list[STrack]</code> <p>List of removed tracks.</p> <code>frame_id</code> <code>int</code> <p>The current frame ID.</p> <code>args</code> <code>namespace</code> <p>Command-line arguments.</p> <code>max_time_lost</code> <code>int</code> <p>The maximum frames for a track to be considered as 'lost'.</p> <code>kalman_filter</code> <code>object</code> <p>Kalman Filter object.</p> <p>Methods:</p> Name Description <code>update</code> <p>Updates object tracker with new detections.</p> <code>get_kalmanfilter</code> <p>Returns a Kalman filter object for tracking bounding boxes.</p> <code>init_track</code> <p>Initialize object tracking with detections.</p> <code>get_dists</code> <p>Calculates the distance between tracks and detections.</p> <code>multi_predict</code> <p>Predicts the location of tracks.</p> <code>reset_id</code> <p>Resets the ID counter of STrack.</p> <code>joint_stracks</code> <p>Combines two lists of stracks.</p> <code>sub_stracks</code> <p>Filters out the stracks present in the second list from the first list.</p> <code>remove_duplicate_stracks</code> <p>Removes duplicate stracks based on IOU.</p> Source code in <code>ultralytics/trackers/byte_tracker.py</code> <pre><code>class BYTETracker:\n    \"\"\"\n    BYTETracker: A tracking algorithm built on top of YOLOv8 for object detection and tracking.\n\n    The class is responsible for initializing, updating, and managing the tracks for detected objects in a video\n    sequence. It maintains the state of tracked, lost, and removed tracks over frames, utilizes Kalman filtering for\n    predicting the new object locations, and performs data association.\n\n    Attributes:\n        tracked_stracks (list[STrack]): List of successfully activated tracks.\n        lost_stracks (list[STrack]): List of lost tracks.\n        removed_stracks (list[STrack]): List of removed tracks.\n        frame_id (int): The current frame ID.\n        args (namespace): Command-line arguments.\n        max_time_lost (int): The maximum frames for a track to be considered as 'lost'.\n        kalman_filter (object): Kalman Filter object.\n\n    Methods:\n        update(results, img=None): Updates object tracker with new detections.\n        get_kalmanfilter(): Returns a Kalman filter object for tracking bounding boxes.\n        init_track(dets, scores, cls, img=None): Initialize object tracking with detections.\n        get_dists(tracks, detections): Calculates the distance between tracks and detections.\n        multi_predict(tracks): Predicts the location of tracks.\n        reset_id(): Resets the ID counter of STrack.\n        joint_stracks(tlista, tlistb): Combines two lists of stracks.\n        sub_stracks(tlista, tlistb): Filters out the stracks present in the second list from the first list.\n        remove_duplicate_stracks(stracksa, stracksb): Removes duplicate stracks based on IOU.\n    \"\"\"\n\n    def __init__(self, args, frame_rate=30):\n        \"\"\"Initialize a YOLOv8 object to track objects with given arguments and frame rate.\"\"\"\n        self.tracked_stracks = []  # type: list[STrack]\n        self.lost_stracks = []  # type: list[STrack]\n        self.removed_stracks = []  # type: list[STrack]\n\n        self.frame_id = 0\n        self.args = args\n        self.max_time_lost = int(frame_rate / 30.0 * args.track_buffer)\n        self.kalman_filter = self.get_kalmanfilter()\n        self.reset_id()\n\n    def update(self, results, img=None):\n        \"\"\"Updates object tracker with new detections and returns tracked object bounding boxes.\"\"\"\n        self.frame_id += 1\n        activated_stracks = []\n        refind_stracks = []\n        lost_stracks = []\n        removed_stracks = []\n\n        scores = results.conf\n        bboxes = results.xyxy\n        # Add index\n        bboxes = np.concatenate([bboxes, np.arange(len(bboxes)).reshape(-1, 1)], axis=-1)\n        cls = results.cls\n\n        remain_inds = scores &gt; self.args.track_high_thresh\n        inds_low = scores &gt; self.args.track_low_thresh\n        inds_high = scores &lt; self.args.track_high_thresh\n\n        inds_second = np.logical_and(inds_low, inds_high)\n        dets_second = bboxes[inds_second]\n        dets = bboxes[remain_inds]\n        scores_keep = scores[remain_inds]\n        scores_second = scores[inds_second]\n        cls_keep = cls[remain_inds]\n        cls_second = cls[inds_second]\n\n        detections = self.init_track(dets, scores_keep, cls_keep, img)\n        # Add newly detected tracklets to tracked_stracks\n        unconfirmed = []\n        tracked_stracks = []  # type: list[STrack]\n        for track in self.tracked_stracks:\n            if not track.is_activated:\n                unconfirmed.append(track)\n            else:\n                tracked_stracks.append(track)\n        # Step 2: First association, with high score detection boxes\n        strack_pool = self.joint_stracks(tracked_stracks, self.lost_stracks)\n        # Predict the current location with KF\n        self.multi_predict(strack_pool)\n        if hasattr(self, \"gmc\") and img is not None:\n            warp = self.gmc.apply(img, dets)\n            STrack.multi_gmc(strack_pool, warp)\n            STrack.multi_gmc(unconfirmed, warp)\n\n        dists = self.get_dists(strack_pool, detections)\n        matches, u_track, u_detection = matching.linear_assignment(dists, thresh=self.args.match_thresh)\n\n        for itracked, idet in matches:\n            track = strack_pool[itracked]\n            det = detections[idet]\n            if track.state == TrackState.Tracked:\n                track.update(det, self.frame_id)\n                activated_stracks.append(track)\n            else:\n                track.re_activate(det, self.frame_id, new_id=False)\n                refind_stracks.append(track)\n        # Step 3: Second association, with low score detection boxes association the untrack to the low score detections\n        detections_second = self.init_track(dets_second, scores_second, cls_second, img)\n        r_tracked_stracks = [strack_pool[i] for i in u_track if strack_pool[i].state == TrackState.Tracked]\n        # TODO\n        dists = matching.iou_distance(r_tracked_stracks, detections_second)\n        matches, u_track, u_detection_second = matching.linear_assignment(dists, thresh=0.5)\n        for itracked, idet in matches:\n            track = r_tracked_stracks[itracked]\n            det = detections_second[idet]\n            if track.state == TrackState.Tracked:\n                track.update(det, self.frame_id)\n                activated_stracks.append(track)\n            else:\n                track.re_activate(det, self.frame_id, new_id=False)\n                refind_stracks.append(track)\n\n        for it in u_track:\n            track = r_tracked_stracks[it]\n            if track.state != TrackState.Lost:\n                track.mark_lost()\n                lost_stracks.append(track)\n        # Deal with unconfirmed tracks, usually tracks with only one beginning frame\n        detections = [detections[i] for i in u_detection]\n        dists = self.get_dists(unconfirmed, detections)\n        matches, u_unconfirmed, u_detection = matching.linear_assignment(dists, thresh=0.7)\n        for itracked, idet in matches:\n            unconfirmed[itracked].update(detections[idet], self.frame_id)\n            activated_stracks.append(unconfirmed[itracked])\n        for it in u_unconfirmed:\n            track = unconfirmed[it]\n            track.mark_removed()\n            removed_stracks.append(track)\n        # Step 4: Init new stracks\n        for inew in u_detection:\n            track = detections[inew]\n            if track.score &lt; self.args.new_track_thresh:\n                continue\n            track.activate(self.kalman_filter, self.frame_id)\n            activated_stracks.append(track)\n        # Step 5: Update state\n        for track in self.lost_stracks:\n            if self.frame_id - track.end_frame &gt; self.max_time_lost:\n                track.mark_removed()\n                removed_stracks.append(track)\n\n        self.tracked_stracks = [t for t in self.tracked_stracks if t.state == TrackState.Tracked]\n        self.tracked_stracks = self.joint_stracks(self.tracked_stracks, activated_stracks)\n        self.tracked_stracks = self.joint_stracks(self.tracked_stracks, refind_stracks)\n        self.lost_stracks = self.sub_stracks(self.lost_stracks, self.tracked_stracks)\n        self.lost_stracks.extend(lost_stracks)\n        self.lost_stracks = self.sub_stracks(self.lost_stracks, self.removed_stracks)\n        self.tracked_stracks, self.lost_stracks = self.remove_duplicate_stracks(self.tracked_stracks, self.lost_stracks)\n        self.removed_stracks.extend(removed_stracks)\n        if len(self.removed_stracks) &gt; 1000:\n            self.removed_stracks = self.removed_stracks[-999:]  # clip remove stracks to 1000 maximum\n        return np.asarray(\n            [x.tlbr.tolist() + [x.track_id, x.score, x.cls, x.idx] for x in self.tracked_stracks if x.is_activated],\n            dtype=np.float32,\n        )\n\n    def get_kalmanfilter(self):\n        \"\"\"Returns a Kalman filter object for tracking bounding boxes.\"\"\"\n        return KalmanFilterXYAH()\n\n    def init_track(self, dets, scores, cls, img=None):\n        \"\"\"Initialize object tracking with detections and scores using STrack algorithm.\"\"\"\n        return [STrack(xyxy, s, c) for (xyxy, s, c) in zip(dets, scores, cls)] if len(dets) else []  # detections\n\n    def get_dists(self, tracks, detections):\n        \"\"\"Calculates the distance between tracks and detections using IOU and fuses scores.\"\"\"\n        dists = matching.iou_distance(tracks, detections)\n        # TODO: mot20\n        # if not self.args.mot20:\n        dists = matching.fuse_score(dists, detections)\n        return dists\n\n    def multi_predict(self, tracks):\n        \"\"\"Returns the predicted tracks using the YOLOv8 network.\"\"\"\n        STrack.multi_predict(tracks)\n\n    @staticmethod\n    def reset_id():\n        \"\"\"Resets the ID counter of STrack.\"\"\"\n        STrack.reset_id()\n\n    def reset(self):\n        \"\"\"Reset tracker.\"\"\"\n        self.tracked_stracks = []  # type: list[STrack]\n        self.lost_stracks = []  # type: list[STrack]\n        self.removed_stracks = []  # type: list[STrack]\n        self.frame_id = 0\n        self.kalman_filter = self.get_kalmanfilter()\n        self.reset_id()\n\n    @staticmethod\n    def joint_stracks(tlista, tlistb):\n        \"\"\"Combine two lists of stracks into a single one.\"\"\"\n        exists = {}\n        res = []\n        for t in tlista:\n            exists[t.track_id] = 1\n            res.append(t)\n        for t in tlistb:\n            tid = t.track_id\n            if not exists.get(tid, 0):\n                exists[tid] = 1\n                res.append(t)\n        return res\n\n    @staticmethod\n    def sub_stracks(tlista, tlistb):\n        \"\"\"DEPRECATED CODE in https://github.com/ultralytics/ultralytics/pull/1890/\n        stracks = {t.track_id: t for t in tlista}\n        for t in tlistb:\n            tid = t.track_id\n            if stracks.get(tid, 0):\n                del stracks[tid]\n        return list(stracks.values())\n        \"\"\"\n        track_ids_b = {t.track_id for t in tlistb}\n        return [t for t in tlista if t.track_id not in track_ids_b]\n\n    @staticmethod\n    def remove_duplicate_stracks(stracksa, stracksb):\n        \"\"\"Remove duplicate stracks with non-maximum IOU distance.\"\"\"\n        pdist = matching.iou_distance(stracksa, stracksb)\n        pairs = np.where(pdist &lt; 0.15)\n        dupa, dupb = [], []\n        for p, q in zip(*pairs):\n            timep = stracksa[p].frame_id - stracksa[p].start_frame\n            timeq = stracksb[q].frame_id - stracksb[q].start_frame\n            if timep &gt; timeq:\n                dupb.append(q)\n            else:\n                dupa.append(p)\n        resa = [t for i, t in enumerate(stracksa) if i not in dupa]\n        resb = [t for i, t in enumerate(stracksb) if i not in dupb]\n        return resa, resb\n</code></pre>"},{"location":"reference/trackers/byte_tracker/#ultralytics.trackers.byte_tracker.BYTETracker.__init__","title":"<code>__init__(args, frame_rate=30)</code>","text":"<p>Initialize a YOLOv8 object to track objects with given arguments and frame rate.</p> Source code in <code>ultralytics/trackers/byte_tracker.py</code> <pre><code>def __init__(self, args, frame_rate=30):\n    \"\"\"Initialize a YOLOv8 object to track objects with given arguments and frame rate.\"\"\"\n    self.tracked_stracks = []  # type: list[STrack]\n    self.lost_stracks = []  # type: list[STrack]\n    self.removed_stracks = []  # type: list[STrack]\n\n    self.frame_id = 0\n    self.args = args\n    self.max_time_lost = int(frame_rate / 30.0 * args.track_buffer)\n    self.kalman_filter = self.get_kalmanfilter()\n    self.reset_id()\n</code></pre>"},{"location":"reference/trackers/byte_tracker/#ultralytics.trackers.byte_tracker.BYTETracker.get_dists","title":"<code>get_dists(tracks, detections)</code>","text":"<p>Calculates the distance between tracks and detections using IOU and fuses scores.</p> Source code in <code>ultralytics/trackers/byte_tracker.py</code> <pre><code>def get_dists(self, tracks, detections):\n    \"\"\"Calculates the distance between tracks and detections using IOU and fuses scores.\"\"\"\n    dists = matching.iou_distance(tracks, detections)\n    # TODO: mot20\n    # if not self.args.mot20:\n    dists = matching.fuse_score(dists, detections)\n    return dists\n</code></pre>"},{"location":"reference/trackers/byte_tracker/#ultralytics.trackers.byte_tracker.BYTETracker.get_kalmanfilter","title":"<code>get_kalmanfilter()</code>","text":"<p>Returns a Kalman filter object for tracking bounding boxes.</p> Source code in <code>ultralytics/trackers/byte_tracker.py</code> <pre><code>def get_kalmanfilter(self):\n    \"\"\"Returns a Kalman filter object for tracking bounding boxes.\"\"\"\n    return KalmanFilterXYAH()\n</code></pre>"},{"location":"reference/trackers/byte_tracker/#ultralytics.trackers.byte_tracker.BYTETracker.init_track","title":"<code>init_track(dets, scores, cls, img=None)</code>","text":"<p>Initialize object tracking with detections and scores using STrack algorithm.</p> Source code in <code>ultralytics/trackers/byte_tracker.py</code> <pre><code>def init_track(self, dets, scores, cls, img=None):\n    \"\"\"Initialize object tracking with detections and scores using STrack algorithm.\"\"\"\n    return [STrack(xyxy, s, c) for (xyxy, s, c) in zip(dets, scores, cls)] if len(dets) else []  # detections\n</code></pre>"},{"location":"reference/trackers/byte_tracker/#ultralytics.trackers.byte_tracker.BYTETracker.joint_stracks","title":"<code>joint_stracks(tlista, tlistb)</code>  <code>staticmethod</code>","text":"<p>Combine two lists of stracks into a single one.</p> Source code in <code>ultralytics/trackers/byte_tracker.py</code> <pre><code>@staticmethod\ndef joint_stracks(tlista, tlistb):\n    \"\"\"Combine two lists of stracks into a single one.\"\"\"\n    exists = {}\n    res = []\n    for t in tlista:\n        exists[t.track_id] = 1\n        res.append(t)\n    for t in tlistb:\n        tid = t.track_id\n        if not exists.get(tid, 0):\n            exists[tid] = 1\n            res.append(t)\n    return res\n</code></pre>"},{"location":"reference/trackers/byte_tracker/#ultralytics.trackers.byte_tracker.BYTETracker.multi_predict","title":"<code>multi_predict(tracks)</code>","text":"<p>Returns the predicted tracks using the YOLOv8 network.</p> Source code in <code>ultralytics/trackers/byte_tracker.py</code> <pre><code>def multi_predict(self, tracks):\n    \"\"\"Returns the predicted tracks using the YOLOv8 network.\"\"\"\n    STrack.multi_predict(tracks)\n</code></pre>"},{"location":"reference/trackers/byte_tracker/#ultralytics.trackers.byte_tracker.BYTETracker.remove_duplicate_stracks","title":"<code>remove_duplicate_stracks(stracksa, stracksb)</code>  <code>staticmethod</code>","text":"<p>Remove duplicate stracks with non-maximum IOU distance.</p> Source code in <code>ultralytics/trackers/byte_tracker.py</code> <pre><code>@staticmethod\ndef remove_duplicate_stracks(stracksa, stracksb):\n    \"\"\"Remove duplicate stracks with non-maximum IOU distance.\"\"\"\n    pdist = matching.iou_distance(stracksa, stracksb)\n    pairs = np.where(pdist &lt; 0.15)\n    dupa, dupb = [], []\n    for p, q in zip(*pairs):\n        timep = stracksa[p].frame_id - stracksa[p].start_frame\n        timeq = stracksb[q].frame_id - stracksb[q].start_frame\n        if timep &gt; timeq:\n            dupb.append(q)\n        else:\n            dupa.append(p)\n    resa = [t for i, t in enumerate(stracksa) if i not in dupa]\n    resb = [t for i, t in enumerate(stracksb) if i not in dupb]\n    return resa, resb\n</code></pre>"},{"location":"reference/trackers/byte_tracker/#ultralytics.trackers.byte_tracker.BYTETracker.reset","title":"<code>reset()</code>","text":"<p>Reset tracker.</p> Source code in <code>ultralytics/trackers/byte_tracker.py</code> <pre><code>def reset(self):\n    \"\"\"Reset tracker.\"\"\"\n    self.tracked_stracks = []  # type: list[STrack]\n    self.lost_stracks = []  # type: list[STrack]\n    self.removed_stracks = []  # type: list[STrack]\n    self.frame_id = 0\n    self.kalman_filter = self.get_kalmanfilter()\n    self.reset_id()\n</code></pre>"},{"location":"reference/trackers/byte_tracker/#ultralytics.trackers.byte_tracker.BYTETracker.reset_id","title":"<code>reset_id()</code>  <code>staticmethod</code>","text":"<p>Resets the ID counter of STrack.</p> Source code in <code>ultralytics/trackers/byte_tracker.py</code> <pre><code>@staticmethod\ndef reset_id():\n    \"\"\"Resets the ID counter of STrack.\"\"\"\n    STrack.reset_id()\n</code></pre>"},{"location":"reference/trackers/byte_tracker/#ultralytics.trackers.byte_tracker.BYTETracker.sub_stracks","title":"<code>sub_stracks(tlista, tlistb)</code>  <code>staticmethod</code>","text":"<p>DEPRECATED CODE in https://github.com/ultralytics/ultralytics/pull/1890/ stracks = {t.track_id: t for t in tlista} for t in tlistb:     tid = t.track_id     if stracks.get(tid, 0):         del stracks[tid] return list(stracks.values())</p> Source code in <code>ultralytics/trackers/byte_tracker.py</code> <pre><code>@staticmethod\ndef sub_stracks(tlista, tlistb):\n    \"\"\"DEPRECATED CODE in https://github.com/ultralytics/ultralytics/pull/1890/\n    stracks = {t.track_id: t for t in tlista}\n    for t in tlistb:\n        tid = t.track_id\n        if stracks.get(tid, 0):\n            del stracks[tid]\n    return list(stracks.values())\n    \"\"\"\n    track_ids_b = {t.track_id for t in tlistb}\n    return [t for t in tlista if t.track_id not in track_ids_b]\n</code></pre>"},{"location":"reference/trackers/byte_tracker/#ultralytics.trackers.byte_tracker.BYTETracker.update","title":"<code>update(results, img=None)</code>","text":"<p>Updates object tracker with new detections and returns tracked object bounding boxes.</p> Source code in <code>ultralytics/trackers/byte_tracker.py</code> <pre><code>def update(self, results, img=None):\n    \"\"\"Updates object tracker with new detections and returns tracked object bounding boxes.\"\"\"\n    self.frame_id += 1\n    activated_stracks = []\n    refind_stracks = []\n    lost_stracks = []\n    removed_stracks = []\n\n    scores = results.conf\n    bboxes = results.xyxy\n    # Add index\n    bboxes = np.concatenate([bboxes, np.arange(len(bboxes)).reshape(-1, 1)], axis=-1)\n    cls = results.cls\n\n    remain_inds = scores &gt; self.args.track_high_thresh\n    inds_low = scores &gt; self.args.track_low_thresh\n    inds_high = scores &lt; self.args.track_high_thresh\n\n    inds_second = np.logical_and(inds_low, inds_high)\n    dets_second = bboxes[inds_second]\n    dets = bboxes[remain_inds]\n    scores_keep = scores[remain_inds]\n    scores_second = scores[inds_second]\n    cls_keep = cls[remain_inds]\n    cls_second = cls[inds_second]\n\n    detections = self.init_track(dets, scores_keep, cls_keep, img)\n    # Add newly detected tracklets to tracked_stracks\n    unconfirmed = []\n    tracked_stracks = []  # type: list[STrack]\n    for track in self.tracked_stracks:\n        if not track.is_activated:\n            unconfirmed.append(track)\n        else:\n            tracked_stracks.append(track)\n    # Step 2: First association, with high score detection boxes\n    strack_pool = self.joint_stracks(tracked_stracks, self.lost_stracks)\n    # Predict the current location with KF\n    self.multi_predict(strack_pool)\n    if hasattr(self, \"gmc\") and img is not None:\n        warp = self.gmc.apply(img, dets)\n        STrack.multi_gmc(strack_pool, warp)\n        STrack.multi_gmc(unconfirmed, warp)\n\n    dists = self.get_dists(strack_pool, detections)\n    matches, u_track, u_detection = matching.linear_assignment(dists, thresh=self.args.match_thresh)\n\n    for itracked, idet in matches:\n        track = strack_pool[itracked]\n        det = detections[idet]\n        if track.state == TrackState.Tracked:\n            track.update(det, self.frame_id)\n            activated_stracks.append(track)\n        else:\n            track.re_activate(det, self.frame_id, new_id=False)\n            refind_stracks.append(track)\n    # Step 3: Second association, with low score detection boxes association the untrack to the low score detections\n    detections_second = self.init_track(dets_second, scores_second, cls_second, img)\n    r_tracked_stracks = [strack_pool[i] for i in u_track if strack_pool[i].state == TrackState.Tracked]\n    # TODO\n    dists = matching.iou_distance(r_tracked_stracks, detections_second)\n    matches, u_track, u_detection_second = matching.linear_assignment(dists, thresh=0.5)\n    for itracked, idet in matches:\n        track = r_tracked_stracks[itracked]\n        det = detections_second[idet]\n        if track.state == TrackState.Tracked:\n            track.update(det, self.frame_id)\n            activated_stracks.append(track)\n        else:\n            track.re_activate(det, self.frame_id, new_id=False)\n            refind_stracks.append(track)\n\n    for it in u_track:\n        track = r_tracked_stracks[it]\n        if track.state != TrackState.Lost:\n            track.mark_lost()\n            lost_stracks.append(track)\n    # Deal with unconfirmed tracks, usually tracks with only one beginning frame\n    detections = [detections[i] for i in u_detection]\n    dists = self.get_dists(unconfirmed, detections)\n    matches, u_unconfirmed, u_detection = matching.linear_assignment(dists, thresh=0.7)\n    for itracked, idet in matches:\n        unconfirmed[itracked].update(detections[idet], self.frame_id)\n        activated_stracks.append(unconfirmed[itracked])\n    for it in u_unconfirmed:\n        track = unconfirmed[it]\n        track.mark_removed()\n        removed_stracks.append(track)\n    # Step 4: Init new stracks\n    for inew in u_detection:\n        track = detections[inew]\n        if track.score &lt; self.args.new_track_thresh:\n            continue\n        track.activate(self.kalman_filter, self.frame_id)\n        activated_stracks.append(track)\n    # Step 5: Update state\n    for track in self.lost_stracks:\n        if self.frame_id - track.end_frame &gt; self.max_time_lost:\n            track.mark_removed()\n            removed_stracks.append(track)\n\n    self.tracked_stracks = [t for t in self.tracked_stracks if t.state == TrackState.Tracked]\n    self.tracked_stracks = self.joint_stracks(self.tracked_stracks, activated_stracks)\n    self.tracked_stracks = self.joint_stracks(self.tracked_stracks, refind_stracks)\n    self.lost_stracks = self.sub_stracks(self.lost_stracks, self.tracked_stracks)\n    self.lost_stracks.extend(lost_stracks)\n    self.lost_stracks = self.sub_stracks(self.lost_stracks, self.removed_stracks)\n    self.tracked_stracks, self.lost_stracks = self.remove_duplicate_stracks(self.tracked_stracks, self.lost_stracks)\n    self.removed_stracks.extend(removed_stracks)\n    if len(self.removed_stracks) &gt; 1000:\n        self.removed_stracks = self.removed_stracks[-999:]  # clip remove stracks to 1000 maximum\n    return np.asarray(\n        [x.tlbr.tolist() + [x.track_id, x.score, x.cls, x.idx] for x in self.tracked_stracks if x.is_activated],\n        dtype=np.float32,\n    )\n</code></pre>"},{"location":"reference/trackers/track/","title":"Reference for <code>ultralytics/trackers/track.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/trackers/track.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/trackers/track/#ultralytics.trackers.track.on_predict_start","title":"<code>ultralytics.trackers.track.on_predict_start(predictor, persist=False)</code>","text":"<p>Initialize trackers for object tracking during prediction.</p> <p>Parameters:</p> Name Type Description Default <code>predictor</code> <code>object</code> <p>The predictor object to initialize trackers for.</p> required <code>persist</code> <code>bool</code> <p>Whether to persist the trackers if they already exist. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the tracker_type is not 'bytetrack' or 'botsort'.</p> Source code in <code>ultralytics/trackers/track.py</code> <pre><code>def on_predict_start(predictor: object, persist: bool = False) -&gt; None:\n    \"\"\"\n    Initialize trackers for object tracking during prediction.\n\n    Args:\n        predictor (object): The predictor object to initialize trackers for.\n        persist (bool, optional): Whether to persist the trackers if they already exist. Defaults to False.\n\n    Raises:\n        AssertionError: If the tracker_type is not 'bytetrack' or 'botsort'.\n    \"\"\"\n    if predictor.args.task == \"obb\":\n        raise NotImplementedError(\"ERROR \u274c OBB task does not support track mode!\")\n    if hasattr(predictor, \"trackers\") and persist:\n        return\n\n    tracker = check_yaml(predictor.args.tracker)\n    cfg = IterableSimpleNamespace(**yaml_load(tracker))\n\n    if cfg.tracker_type not in [\"bytetrack\", \"botsort\"]:\n        raise AssertionError(f\"Only 'bytetrack' and 'botsort' are supported for now, but got '{cfg.tracker_type}'\")\n\n    trackers = []\n    for _ in range(predictor.dataset.bs):\n        tracker = TRACKER_MAP[cfg.tracker_type](args=cfg, frame_rate=30)\n        trackers.append(tracker)\n    predictor.trackers = trackers\n</code></pre>"},{"location":"reference/trackers/track/#ultralytics.trackers.track.on_predict_postprocess_end","title":"<code>ultralytics.trackers.track.on_predict_postprocess_end(predictor, persist=False)</code>","text":"<p>Postprocess detected boxes and update with object tracking.</p> <p>Parameters:</p> Name Type Description Default <code>predictor</code> <code>object</code> <p>The predictor object containing the predictions.</p> required <code>persist</code> <code>bool</code> <p>Whether to persist the trackers if they already exist. Defaults to False.</p> <code>False</code> Source code in <code>ultralytics/trackers/track.py</code> <pre><code>def on_predict_postprocess_end(predictor: object, persist: bool = False) -&gt; None:\n    \"\"\"\n    Postprocess detected boxes and update with object tracking.\n\n    Args:\n        predictor (object): The predictor object containing the predictions.\n        persist (bool, optional): Whether to persist the trackers if they already exist. Defaults to False.\n    \"\"\"\n    bs = predictor.dataset.bs\n    path, im0s = predictor.batch[:2]\n\n    for i in range(bs):\n        if not persist and predictor.vid_path[i] != str(predictor.save_dir / Path(path[i]).name):  # new video\n            predictor.trackers[i].reset()\n\n        det = predictor.results[i].boxes.cpu().numpy()\n        if len(det) == 0:\n            continue\n        tracks = predictor.trackers[i].update(det, im0s[i])\n        if len(tracks) == 0:\n            continue\n        idx = tracks[:, -1].astype(int)\n        predictor.results[i] = predictor.results[i][idx]\n        predictor.results[i].update(boxes=torch.as_tensor(tracks[:, :-1]))\n</code></pre>"},{"location":"reference/trackers/track/#ultralytics.trackers.track.register_tracker","title":"<code>ultralytics.trackers.track.register_tracker(model, persist)</code>","text":"<p>Register tracking callbacks to the model for object tracking during prediction.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The model object to register tracking callbacks for.</p> required <code>persist</code> <code>bool</code> <p>Whether to persist the trackers if they already exist.</p> required Source code in <code>ultralytics/trackers/track.py</code> <pre><code>def register_tracker(model: object, persist: bool) -&gt; None:\n    \"\"\"\n    Register tracking callbacks to the model for object tracking during prediction.\n\n    Args:\n        model (object): The model object to register tracking callbacks for.\n        persist (bool): Whether to persist the trackers if they already exist.\n    \"\"\"\n    model.add_callback(\"on_predict_start\", partial(on_predict_start, persist=persist))\n    model.add_callback(\"on_predict_postprocess_end\", partial(on_predict_postprocess_end, persist=persist))\n</code></pre>"},{"location":"reference/trackers/utils/gmc/","title":"Reference for <code>ultralytics/trackers/utils/gmc.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/trackers/utils/gmc.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/trackers/utils/gmc/#ultralytics.trackers.utils.gmc.GMC","title":"<code>ultralytics.trackers.utils.gmc.GMC</code>","text":"<p>Generalized Motion Compensation (GMC) class for tracking and object detection in video frames.</p> <p>This class provides methods for tracking and detecting objects based on several tracking algorithms including ORB, SIFT, ECC, and Sparse Optical Flow. It also supports downscaling of frames for computational efficiency.</p> <p>Attributes:</p> Name Type Description <code>method</code> <code>str</code> <p>The method used for tracking. Options include 'orb', 'sift', 'ecc', 'sparseOptFlow', 'none'.</p> <code>downscale</code> <code>int</code> <p>Factor by which to downscale the frames for processing.</p> <code>prevFrame</code> <code>array</code> <p>Stores the previous frame for tracking.</p> <code>prevKeyPoints</code> <code>list</code> <p>Stores the keypoints from the previous frame.</p> <code>prevDescriptors</code> <code>array</code> <p>Stores the descriptors from the previous frame.</p> <code>initializedFirstFrame</code> <code>bool</code> <p>Flag to indicate if the first frame has been processed.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes a GMC object with the specified method                                                   and downscale factor.</p> <code>apply</code> <p>Applies the chosen method to a raw frame and optionally uses                                      provided detections.</p> <code>applyEcc</code> <p>Applies the ECC algorithm to a raw frame.</p> <code>applyFeatures</code> <p>Applies feature-based methods like ORB or SIFT to a raw frame.</p> <code>applySparseOptFlow</code> <p>Applies the Sparse Optical Flow method to a raw frame.</p> Source code in <code>ultralytics/trackers/utils/gmc.py</code> <pre><code>class GMC:\n    \"\"\"\n    Generalized Motion Compensation (GMC) class for tracking and object detection in video frames.\n\n    This class provides methods for tracking and detecting objects based on several tracking algorithms including ORB,\n    SIFT, ECC, and Sparse Optical Flow. It also supports downscaling of frames for computational efficiency.\n\n    Attributes:\n        method (str): The method used for tracking. Options include 'orb', 'sift', 'ecc', 'sparseOptFlow', 'none'.\n        downscale (int): Factor by which to downscale the frames for processing.\n        prevFrame (np.array): Stores the previous frame for tracking.\n        prevKeyPoints (list): Stores the keypoints from the previous frame.\n        prevDescriptors (np.array): Stores the descriptors from the previous frame.\n        initializedFirstFrame (bool): Flag to indicate if the first frame has been processed.\n\n    Methods:\n        __init__(self, method='sparseOptFlow', downscale=2): Initializes a GMC object with the specified method\n                                                              and downscale factor.\n        apply(self, raw_frame, detections=None): Applies the chosen method to a raw frame and optionally uses\n                                                 provided detections.\n        applyEcc(self, raw_frame, detections=None): Applies the ECC algorithm to a raw frame.\n        applyFeatures(self, raw_frame, detections=None): Applies feature-based methods like ORB or SIFT to a raw frame.\n        applySparseOptFlow(self, raw_frame, detections=None): Applies the Sparse Optical Flow method to a raw frame.\n    \"\"\"\n\n    def __init__(self, method: str = \"sparseOptFlow\", downscale: int = 2) -&gt; None:\n        \"\"\"\n        Initialize a video tracker with specified parameters.\n\n        Args:\n            method (str): The method used for tracking. Options include 'orb', 'sift', 'ecc', 'sparseOptFlow', 'none'.\n            downscale (int): Downscale factor for processing frames.\n        \"\"\"\n        super().__init__()\n\n        self.method = method\n        self.downscale = max(1, int(downscale))\n\n        if self.method == \"orb\":\n            self.detector = cv2.FastFeatureDetector_create(20)\n            self.extractor = cv2.ORB_create()\n            self.matcher = cv2.BFMatcher(cv2.NORM_HAMMING)\n\n        elif self.method == \"sift\":\n            self.detector = cv2.SIFT_create(nOctaveLayers=3, contrastThreshold=0.02, edgeThreshold=20)\n            self.extractor = cv2.SIFT_create(nOctaveLayers=3, contrastThreshold=0.02, edgeThreshold=20)\n            self.matcher = cv2.BFMatcher(cv2.NORM_L2)\n\n        elif self.method == \"ecc\":\n            number_of_iterations = 5000\n            termination_eps = 1e-6\n            self.warp_mode = cv2.MOTION_EUCLIDEAN\n            self.criteria = (cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, number_of_iterations, termination_eps)\n\n        elif self.method == \"sparseOptFlow\":\n            self.feature_params = dict(\n                maxCorners=1000, qualityLevel=0.01, minDistance=1, blockSize=3, useHarrisDetector=False, k=0.04\n            )\n\n        elif self.method in [\"none\", \"None\", None]:\n            self.method = None\n        else:\n            raise ValueError(f\"Error: Unknown GMC method:{method}\")\n\n        self.prevFrame = None\n        self.prevKeyPoints = None\n        self.prevDescriptors = None\n        self.initializedFirstFrame = False\n\n    def apply(self, raw_frame: np.array, detections: list = None) -&gt; np.array:\n        \"\"\"\n        Apply object detection on a raw frame using specified method.\n\n        Args:\n            raw_frame (np.array): The raw frame to be processed.\n            detections (list): List of detections to be used in the processing.\n\n        Returns:\n            (np.array): Processed frame.\n\n        Examples:\n            &gt;&gt;&gt; gmc = GMC()\n            &gt;&gt;&gt; gmc.apply(np.array([[1, 2, 3], [4, 5, 6]]))\n            array([[1, 2, 3],\n                   [4, 5, 6]])\n        \"\"\"\n        if self.method in [\"orb\", \"sift\"]:\n            return self.applyFeatures(raw_frame, detections)\n        elif self.method == \"ecc\":\n            return self.applyEcc(raw_frame, detections)\n        elif self.method == \"sparseOptFlow\":\n            return self.applySparseOptFlow(raw_frame, detections)\n        else:\n            return np.eye(2, 3)\n\n    def applyEcc(self, raw_frame: np.array, detections: list = None) -&gt; np.array:\n        \"\"\"\n        Apply ECC algorithm to a raw frame.\n\n        Args:\n            raw_frame (np.array): The raw frame to be processed.\n            detections (list): List of detections to be used in the processing.\n\n        Returns:\n            (np.array): Processed frame.\n\n        Examples:\n            &gt;&gt;&gt; gmc = GMC()\n            &gt;&gt;&gt; gmc.applyEcc(np.array([[1, 2, 3], [4, 5, 6]]))\n            array([[1, 2, 3],\n                   [4, 5, 6]])\n        \"\"\"\n        height, width, _ = raw_frame.shape\n        frame = cv2.cvtColor(raw_frame, cv2.COLOR_BGR2GRAY)\n        H = np.eye(2, 3, dtype=np.float32)\n\n        # Downscale image\n        if self.downscale &gt; 1.0:\n            frame = cv2.GaussianBlur(frame, (3, 3), 1.5)\n            frame = cv2.resize(frame, (width // self.downscale, height // self.downscale))\n            width = width // self.downscale\n            height = height // self.downscale\n\n        # Handle first frame\n        if not self.initializedFirstFrame:\n            # Initialize data\n            self.prevFrame = frame.copy()\n\n            # Initialization done\n            self.initializedFirstFrame = True\n\n            return H\n\n        # Run the ECC algorithm. The results are stored in warp_matrix.\n        # (cc, H) = cv2.findTransformECC(self.prevFrame, frame, H, self.warp_mode, self.criteria)\n        try:\n            (cc, H) = cv2.findTransformECC(self.prevFrame, frame, H, self.warp_mode, self.criteria, None, 1)\n        except Exception as e:\n            LOGGER.warning(f\"WARNING: find transform failed. Set warp as identity {e}\")\n\n        return H\n\n    def applyFeatures(self, raw_frame: np.array, detections: list = None) -&gt; np.array:\n        \"\"\"\n        Apply feature-based methods like ORB or SIFT to a raw frame.\n\n        Args:\n            raw_frame (np.array): The raw frame to be processed.\n            detections (list): List of detections to be used in the processing.\n\n        Returns:\n            (np.array): Processed frame.\n\n        Examples:\n            &gt;&gt;&gt; gmc = GMC()\n            &gt;&gt;&gt; gmc.applyFeatures(np.array([[1, 2, 3], [4, 5, 6]]))\n            array([[1, 2, 3],\n                   [4, 5, 6]])\n        \"\"\"\n        height, width, _ = raw_frame.shape\n        frame = cv2.cvtColor(raw_frame, cv2.COLOR_BGR2GRAY)\n        H = np.eye(2, 3)\n\n        # Downscale image\n        if self.downscale &gt; 1.0:\n            frame = cv2.resize(frame, (width // self.downscale, height // self.downscale))\n            width = width // self.downscale\n            height = height // self.downscale\n\n        # Find the keypoints\n        mask = np.zeros_like(frame)\n        mask[int(0.02 * height) : int(0.98 * height), int(0.02 * width) : int(0.98 * width)] = 255\n        if detections is not None:\n            for det in detections:\n                tlbr = (det[:4] / self.downscale).astype(np.int_)\n                mask[tlbr[1] : tlbr[3], tlbr[0] : tlbr[2]] = 0\n\n        keypoints = self.detector.detect(frame, mask)\n\n        # Compute the descriptors\n        keypoints, descriptors = self.extractor.compute(frame, keypoints)\n\n        # Handle first frame\n        if not self.initializedFirstFrame:\n            # Initialize data\n            self.prevFrame = frame.copy()\n            self.prevKeyPoints = copy.copy(keypoints)\n            self.prevDescriptors = copy.copy(descriptors)\n\n            # Initialization done\n            self.initializedFirstFrame = True\n\n            return H\n\n        # Match descriptors\n        knnMatches = self.matcher.knnMatch(self.prevDescriptors, descriptors, 2)\n\n        # Filter matches based on smallest spatial distance\n        matches = []\n        spatialDistances = []\n\n        maxSpatialDistance = 0.25 * np.array([width, height])\n\n        # Handle empty matches case\n        if len(knnMatches) == 0:\n            # Store to next iteration\n            self.prevFrame = frame.copy()\n            self.prevKeyPoints = copy.copy(keypoints)\n            self.prevDescriptors = copy.copy(descriptors)\n\n            return H\n\n        for m, n in knnMatches:\n            if m.distance &lt; 0.9 * n.distance:\n                prevKeyPointLocation = self.prevKeyPoints[m.queryIdx].pt\n                currKeyPointLocation = keypoints[m.trainIdx].pt\n\n                spatialDistance = (\n                    prevKeyPointLocation[0] - currKeyPointLocation[0],\n                    prevKeyPointLocation[1] - currKeyPointLocation[1],\n                )\n\n                if (np.abs(spatialDistance[0]) &lt; maxSpatialDistance[0]) and (\n                    np.abs(spatialDistance[1]) &lt; maxSpatialDistance[1]\n                ):\n                    spatialDistances.append(spatialDistance)\n                    matches.append(m)\n\n        meanSpatialDistances = np.mean(spatialDistances, 0)\n        stdSpatialDistances = np.std(spatialDistances, 0)\n\n        inliers = (spatialDistances - meanSpatialDistances) &lt; 2.5 * stdSpatialDistances\n\n        goodMatches = []\n        prevPoints = []\n        currPoints = []\n        for i in range(len(matches)):\n            if inliers[i, 0] and inliers[i, 1]:\n                goodMatches.append(matches[i])\n                prevPoints.append(self.prevKeyPoints[matches[i].queryIdx].pt)\n                currPoints.append(keypoints[matches[i].trainIdx].pt)\n\n        prevPoints = np.array(prevPoints)\n        currPoints = np.array(currPoints)\n\n        # Draw the keypoint matches on the output image\n        # if False:\n        #     import matplotlib.pyplot as plt\n        #     matches_img = np.hstack((self.prevFrame, frame))\n        #     matches_img = cv2.cvtColor(matches_img, cv2.COLOR_GRAY2BGR)\n        #     W = np.size(self.prevFrame, 1)\n        #     for m in goodMatches:\n        #         prev_pt = np.array(self.prevKeyPoints[m.queryIdx].pt, dtype=np.int_)\n        #         curr_pt = np.array(keypoints[m.trainIdx].pt, dtype=np.int_)\n        #         curr_pt[0] += W\n        #         color = np.random.randint(0, 255, 3)\n        #         color = (int(color[0]), int(color[1]), int(color[2]))\n        #\n        #         matches_img = cv2.line(matches_img, prev_pt, curr_pt, tuple(color), 1, cv2.LINE_AA)\n        #         matches_img = cv2.circle(matches_img, prev_pt, 2, tuple(color), -1)\n        #         matches_img = cv2.circle(matches_img, curr_pt, 2, tuple(color), -1)\n        #\n        #     plt.figure()\n        #     plt.imshow(matches_img)\n        #     plt.show()\n\n        # Find rigid matrix\n        if (np.size(prevPoints, 0) &gt; 4) and (np.size(prevPoints, 0) == np.size(prevPoints, 0)):\n            H, inliers = cv2.estimateAffinePartial2D(prevPoints, currPoints, cv2.RANSAC)\n\n            # Handle downscale\n            if self.downscale &gt; 1.0:\n                H[0, 2] *= self.downscale\n                H[1, 2] *= self.downscale\n        else:\n            LOGGER.warning(\"WARNING: not enough matching points\")\n\n        # Store to next iteration\n        self.prevFrame = frame.copy()\n        self.prevKeyPoints = copy.copy(keypoints)\n        self.prevDescriptors = copy.copy(descriptors)\n\n        return H\n\n    def applySparseOptFlow(self, raw_frame: np.array, detections: list = None) -&gt; np.array:\n        \"\"\"\n        Apply Sparse Optical Flow method to a raw frame.\n\n        Args:\n            raw_frame (np.array): The raw frame to be processed.\n            detections (list): List of detections to be used in the processing.\n\n        Returns:\n            (np.array): Processed frame.\n\n        Examples:\n            &gt;&gt;&gt; gmc = GMC()\n            &gt;&gt;&gt; gmc.applySparseOptFlow(np.array([[1, 2, 3], [4, 5, 6]]))\n            array([[1, 2, 3],\n                   [4, 5, 6]])\n        \"\"\"\n        height, width, _ = raw_frame.shape\n        frame = cv2.cvtColor(raw_frame, cv2.COLOR_BGR2GRAY)\n        H = np.eye(2, 3)\n\n        # Downscale image\n        if self.downscale &gt; 1.0:\n            frame = cv2.resize(frame, (width // self.downscale, height // self.downscale))\n\n        # Find the keypoints\n        keypoints = cv2.goodFeaturesToTrack(frame, mask=None, **self.feature_params)\n\n        # Handle first frame\n        if not self.initializedFirstFrame:\n            self.prevFrame = frame.copy()\n            self.prevKeyPoints = copy.copy(keypoints)\n            self.initializedFirstFrame = True\n            return H\n\n        # Find correspondences\n        matchedKeypoints, status, err = cv2.calcOpticalFlowPyrLK(self.prevFrame, frame, self.prevKeyPoints, None)\n\n        # Leave good correspondences only\n        prevPoints = []\n        currPoints = []\n\n        for i in range(len(status)):\n            if status[i]:\n                prevPoints.append(self.prevKeyPoints[i])\n                currPoints.append(matchedKeypoints[i])\n\n        prevPoints = np.array(prevPoints)\n        currPoints = np.array(currPoints)\n\n        # Find rigid matrix\n        if np.size(prevPoints, 0) &gt; 4 and np.size(prevPoints, 0) == np.size(prevPoints, 0):\n            H, inliers = cv2.estimateAffinePartial2D(prevPoints, currPoints, cv2.RANSAC)\n\n            if self.downscale &gt; 1.0:\n                H[0, 2] *= self.downscale\n                H[1, 2] *= self.downscale\n        else:\n            LOGGER.warning(\"WARNING: not enough matching points\")\n\n        self.prevFrame = frame.copy()\n        self.prevKeyPoints = copy.copy(keypoints)\n\n        return H\n\n    def reset_params(self) -&gt; None:\n        \"\"\"Reset parameters.\"\"\"\n        self.prevFrame = None\n        self.prevKeyPoints = None\n        self.prevDescriptors = None\n        self.initializedFirstFrame = False\n</code></pre>"},{"location":"reference/trackers/utils/gmc/#ultralytics.trackers.utils.gmc.GMC.__init__","title":"<code>__init__(method='sparseOptFlow', downscale=2)</code>","text":"<p>Initialize a video tracker with specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The method used for tracking. Options include 'orb', 'sift', 'ecc', 'sparseOptFlow', 'none'.</p> <code>'sparseOptFlow'</code> <code>downscale</code> <code>int</code> <p>Downscale factor for processing frames.</p> <code>2</code> Source code in <code>ultralytics/trackers/utils/gmc.py</code> <pre><code>def __init__(self, method: str = \"sparseOptFlow\", downscale: int = 2) -&gt; None:\n    \"\"\"\n    Initialize a video tracker with specified parameters.\n\n    Args:\n        method (str): The method used for tracking. Options include 'orb', 'sift', 'ecc', 'sparseOptFlow', 'none'.\n        downscale (int): Downscale factor for processing frames.\n    \"\"\"\n    super().__init__()\n\n    self.method = method\n    self.downscale = max(1, int(downscale))\n\n    if self.method == \"orb\":\n        self.detector = cv2.FastFeatureDetector_create(20)\n        self.extractor = cv2.ORB_create()\n        self.matcher = cv2.BFMatcher(cv2.NORM_HAMMING)\n\n    elif self.method == \"sift\":\n        self.detector = cv2.SIFT_create(nOctaveLayers=3, contrastThreshold=0.02, edgeThreshold=20)\n        self.extractor = cv2.SIFT_create(nOctaveLayers=3, contrastThreshold=0.02, edgeThreshold=20)\n        self.matcher = cv2.BFMatcher(cv2.NORM_L2)\n\n    elif self.method == \"ecc\":\n        number_of_iterations = 5000\n        termination_eps = 1e-6\n        self.warp_mode = cv2.MOTION_EUCLIDEAN\n        self.criteria = (cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, number_of_iterations, termination_eps)\n\n    elif self.method == \"sparseOptFlow\":\n        self.feature_params = dict(\n            maxCorners=1000, qualityLevel=0.01, minDistance=1, blockSize=3, useHarrisDetector=False, k=0.04\n        )\n\n    elif self.method in [\"none\", \"None\", None]:\n        self.method = None\n    else:\n        raise ValueError(f\"Error: Unknown GMC method:{method}\")\n\n    self.prevFrame = None\n    self.prevKeyPoints = None\n    self.prevDescriptors = None\n    self.initializedFirstFrame = False\n</code></pre>"},{"location":"reference/trackers/utils/gmc/#ultralytics.trackers.utils.gmc.GMC.apply","title":"<code>apply(raw_frame, detections=None)</code>","text":"<p>Apply object detection on a raw frame using specified method.</p> <p>Parameters:</p> Name Type Description Default <code>raw_frame</code> <code>array</code> <p>The raw frame to be processed.</p> required <code>detections</code> <code>list</code> <p>List of detections to be used in the processing.</p> <code>None</code> <p>Returns:</p> Type Description <code>array</code> <p>Processed frame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gmc = GMC()\n&gt;&gt;&gt; gmc.apply(np.array([[1, 2, 3], [4, 5, 6]]))\narray([[1, 2, 3],\n       [4, 5, 6]])\n</code></pre> Source code in <code>ultralytics/trackers/utils/gmc.py</code> <pre><code>def apply(self, raw_frame: np.array, detections: list = None) -&gt; np.array:\n    \"\"\"\n    Apply object detection on a raw frame using specified method.\n\n    Args:\n        raw_frame (np.array): The raw frame to be processed.\n        detections (list): List of detections to be used in the processing.\n\n    Returns:\n        (np.array): Processed frame.\n\n    Examples:\n        &gt;&gt;&gt; gmc = GMC()\n        &gt;&gt;&gt; gmc.apply(np.array([[1, 2, 3], [4, 5, 6]]))\n        array([[1, 2, 3],\n               [4, 5, 6]])\n    \"\"\"\n    if self.method in [\"orb\", \"sift\"]:\n        return self.applyFeatures(raw_frame, detections)\n    elif self.method == \"ecc\":\n        return self.applyEcc(raw_frame, detections)\n    elif self.method == \"sparseOptFlow\":\n        return self.applySparseOptFlow(raw_frame, detections)\n    else:\n        return np.eye(2, 3)\n</code></pre>"},{"location":"reference/trackers/utils/gmc/#ultralytics.trackers.utils.gmc.GMC.applyEcc","title":"<code>applyEcc(raw_frame, detections=None)</code>","text":"<p>Apply ECC algorithm to a raw frame.</p> <p>Parameters:</p> Name Type Description Default <code>raw_frame</code> <code>array</code> <p>The raw frame to be processed.</p> required <code>detections</code> <code>list</code> <p>List of detections to be used in the processing.</p> <code>None</code> <p>Returns:</p> Type Description <code>array</code> <p>Processed frame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gmc = GMC()\n&gt;&gt;&gt; gmc.applyEcc(np.array([[1, 2, 3], [4, 5, 6]]))\narray([[1, 2, 3],\n       [4, 5, 6]])\n</code></pre> Source code in <code>ultralytics/trackers/utils/gmc.py</code> <pre><code>def applyEcc(self, raw_frame: np.array, detections: list = None) -&gt; np.array:\n    \"\"\"\n    Apply ECC algorithm to a raw frame.\n\n    Args:\n        raw_frame (np.array): The raw frame to be processed.\n        detections (list): List of detections to be used in the processing.\n\n    Returns:\n        (np.array): Processed frame.\n\n    Examples:\n        &gt;&gt;&gt; gmc = GMC()\n        &gt;&gt;&gt; gmc.applyEcc(np.array([[1, 2, 3], [4, 5, 6]]))\n        array([[1, 2, 3],\n               [4, 5, 6]])\n    \"\"\"\n    height, width, _ = raw_frame.shape\n    frame = cv2.cvtColor(raw_frame, cv2.COLOR_BGR2GRAY)\n    H = np.eye(2, 3, dtype=np.float32)\n\n    # Downscale image\n    if self.downscale &gt; 1.0:\n        frame = cv2.GaussianBlur(frame, (3, 3), 1.5)\n        frame = cv2.resize(frame, (width // self.downscale, height // self.downscale))\n        width = width // self.downscale\n        height = height // self.downscale\n\n    # Handle first frame\n    if not self.initializedFirstFrame:\n        # Initialize data\n        self.prevFrame = frame.copy()\n\n        # Initialization done\n        self.initializedFirstFrame = True\n\n        return H\n\n    # Run the ECC algorithm. The results are stored in warp_matrix.\n    # (cc, H) = cv2.findTransformECC(self.prevFrame, frame, H, self.warp_mode, self.criteria)\n    try:\n        (cc, H) = cv2.findTransformECC(self.prevFrame, frame, H, self.warp_mode, self.criteria, None, 1)\n    except Exception as e:\n        LOGGER.warning(f\"WARNING: find transform failed. Set warp as identity {e}\")\n\n    return H\n</code></pre>"},{"location":"reference/trackers/utils/gmc/#ultralytics.trackers.utils.gmc.GMC.applyFeatures","title":"<code>applyFeatures(raw_frame, detections=None)</code>","text":"<p>Apply feature-based methods like ORB or SIFT to a raw frame.</p> <p>Parameters:</p> Name Type Description Default <code>raw_frame</code> <code>array</code> <p>The raw frame to be processed.</p> required <code>detections</code> <code>list</code> <p>List of detections to be used in the processing.</p> <code>None</code> <p>Returns:</p> Type Description <code>array</code> <p>Processed frame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gmc = GMC()\n&gt;&gt;&gt; gmc.applyFeatures(np.array([[1, 2, 3], [4, 5, 6]]))\narray([[1, 2, 3],\n       [4, 5, 6]])\n</code></pre> Source code in <code>ultralytics/trackers/utils/gmc.py</code> <pre><code>def applyFeatures(self, raw_frame: np.array, detections: list = None) -&gt; np.array:\n    \"\"\"\n    Apply feature-based methods like ORB or SIFT to a raw frame.\n\n    Args:\n        raw_frame (np.array): The raw frame to be processed.\n        detections (list): List of detections to be used in the processing.\n\n    Returns:\n        (np.array): Processed frame.\n\n    Examples:\n        &gt;&gt;&gt; gmc = GMC()\n        &gt;&gt;&gt; gmc.applyFeatures(np.array([[1, 2, 3], [4, 5, 6]]))\n        array([[1, 2, 3],\n               [4, 5, 6]])\n    \"\"\"\n    height, width, _ = raw_frame.shape\n    frame = cv2.cvtColor(raw_frame, cv2.COLOR_BGR2GRAY)\n    H = np.eye(2, 3)\n\n    # Downscale image\n    if self.downscale &gt; 1.0:\n        frame = cv2.resize(frame, (width // self.downscale, height // self.downscale))\n        width = width // self.downscale\n        height = height // self.downscale\n\n    # Find the keypoints\n    mask = np.zeros_like(frame)\n    mask[int(0.02 * height) : int(0.98 * height), int(0.02 * width) : int(0.98 * width)] = 255\n    if detections is not None:\n        for det in detections:\n            tlbr = (det[:4] / self.downscale).astype(np.int_)\n            mask[tlbr[1] : tlbr[3], tlbr[0] : tlbr[2]] = 0\n\n    keypoints = self.detector.detect(frame, mask)\n\n    # Compute the descriptors\n    keypoints, descriptors = self.extractor.compute(frame, keypoints)\n\n    # Handle first frame\n    if not self.initializedFirstFrame:\n        # Initialize data\n        self.prevFrame = frame.copy()\n        self.prevKeyPoints = copy.copy(keypoints)\n        self.prevDescriptors = copy.copy(descriptors)\n\n        # Initialization done\n        self.initializedFirstFrame = True\n\n        return H\n\n    # Match descriptors\n    knnMatches = self.matcher.knnMatch(self.prevDescriptors, descriptors, 2)\n\n    # Filter matches based on smallest spatial distance\n    matches = []\n    spatialDistances = []\n\n    maxSpatialDistance = 0.25 * np.array([width, height])\n\n    # Handle empty matches case\n    if len(knnMatches) == 0:\n        # Store to next iteration\n        self.prevFrame = frame.copy()\n        self.prevKeyPoints = copy.copy(keypoints)\n        self.prevDescriptors = copy.copy(descriptors)\n\n        return H\n\n    for m, n in knnMatches:\n        if m.distance &lt; 0.9 * n.distance:\n            prevKeyPointLocation = self.prevKeyPoints[m.queryIdx].pt\n            currKeyPointLocation = keypoints[m.trainIdx].pt\n\n            spatialDistance = (\n                prevKeyPointLocation[0] - currKeyPointLocation[0],\n                prevKeyPointLocation[1] - currKeyPointLocation[1],\n            )\n\n            if (np.abs(spatialDistance[0]) &lt; maxSpatialDistance[0]) and (\n                np.abs(spatialDistance[1]) &lt; maxSpatialDistance[1]\n            ):\n                spatialDistances.append(spatialDistance)\n                matches.append(m)\n\n    meanSpatialDistances = np.mean(spatialDistances, 0)\n    stdSpatialDistances = np.std(spatialDistances, 0)\n\n    inliers = (spatialDistances - meanSpatialDistances) &lt; 2.5 * stdSpatialDistances\n\n    goodMatches = []\n    prevPoints = []\n    currPoints = []\n    for i in range(len(matches)):\n        if inliers[i, 0] and inliers[i, 1]:\n            goodMatches.append(matches[i])\n            prevPoints.append(self.prevKeyPoints[matches[i].queryIdx].pt)\n            currPoints.append(keypoints[matches[i].trainIdx].pt)\n\n    prevPoints = np.array(prevPoints)\n    currPoints = np.array(currPoints)\n\n    # Draw the keypoint matches on the output image\n    # if False:\n    #     import matplotlib.pyplot as plt\n    #     matches_img = np.hstack((self.prevFrame, frame))\n    #     matches_img = cv2.cvtColor(matches_img, cv2.COLOR_GRAY2BGR)\n    #     W = np.size(self.prevFrame, 1)\n    #     for m in goodMatches:\n    #         prev_pt = np.array(self.prevKeyPoints[m.queryIdx].pt, dtype=np.int_)\n    #         curr_pt = np.array(keypoints[m.trainIdx].pt, dtype=np.int_)\n    #         curr_pt[0] += W\n    #         color = np.random.randint(0, 255, 3)\n    #         color = (int(color[0]), int(color[1]), int(color[2]))\n    #\n    #         matches_img = cv2.line(matches_img, prev_pt, curr_pt, tuple(color), 1, cv2.LINE_AA)\n    #         matches_img = cv2.circle(matches_img, prev_pt, 2, tuple(color), -1)\n    #         matches_img = cv2.circle(matches_img, curr_pt, 2, tuple(color), -1)\n    #\n    #     plt.figure()\n    #     plt.imshow(matches_img)\n    #     plt.show()\n\n    # Find rigid matrix\n    if (np.size(prevPoints, 0) &gt; 4) and (np.size(prevPoints, 0) == np.size(prevPoints, 0)):\n        H, inliers = cv2.estimateAffinePartial2D(prevPoints, currPoints, cv2.RANSAC)\n\n        # Handle downscale\n        if self.downscale &gt; 1.0:\n            H[0, 2] *= self.downscale\n            H[1, 2] *= self.downscale\n    else:\n        LOGGER.warning(\"WARNING: not enough matching points\")\n\n    # Store to next iteration\n    self.prevFrame = frame.copy()\n    self.prevKeyPoints = copy.copy(keypoints)\n    self.prevDescriptors = copy.copy(descriptors)\n\n    return H\n</code></pre>"},{"location":"reference/trackers/utils/gmc/#ultralytics.trackers.utils.gmc.GMC.applySparseOptFlow","title":"<code>applySparseOptFlow(raw_frame, detections=None)</code>","text":"<p>Apply Sparse Optical Flow method to a raw frame.</p> <p>Parameters:</p> Name Type Description Default <code>raw_frame</code> <code>array</code> <p>The raw frame to be processed.</p> required <code>detections</code> <code>list</code> <p>List of detections to be used in the processing.</p> <code>None</code> <p>Returns:</p> Type Description <code>array</code> <p>Processed frame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gmc = GMC()\n&gt;&gt;&gt; gmc.applySparseOptFlow(np.array([[1, 2, 3], [4, 5, 6]]))\narray([[1, 2, 3],\n       [4, 5, 6]])\n</code></pre> Source code in <code>ultralytics/trackers/utils/gmc.py</code> <pre><code>def applySparseOptFlow(self, raw_frame: np.array, detections: list = None) -&gt; np.array:\n    \"\"\"\n    Apply Sparse Optical Flow method to a raw frame.\n\n    Args:\n        raw_frame (np.array): The raw frame to be processed.\n        detections (list): List of detections to be used in the processing.\n\n    Returns:\n        (np.array): Processed frame.\n\n    Examples:\n        &gt;&gt;&gt; gmc = GMC()\n        &gt;&gt;&gt; gmc.applySparseOptFlow(np.array([[1, 2, 3], [4, 5, 6]]))\n        array([[1, 2, 3],\n               [4, 5, 6]])\n    \"\"\"\n    height, width, _ = raw_frame.shape\n    frame = cv2.cvtColor(raw_frame, cv2.COLOR_BGR2GRAY)\n    H = np.eye(2, 3)\n\n    # Downscale image\n    if self.downscale &gt; 1.0:\n        frame = cv2.resize(frame, (width // self.downscale, height // self.downscale))\n\n    # Find the keypoints\n    keypoints = cv2.goodFeaturesToTrack(frame, mask=None, **self.feature_params)\n\n    # Handle first frame\n    if not self.initializedFirstFrame:\n        self.prevFrame = frame.copy()\n        self.prevKeyPoints = copy.copy(keypoints)\n        self.initializedFirstFrame = True\n        return H\n\n    # Find correspondences\n    matchedKeypoints, status, err = cv2.calcOpticalFlowPyrLK(self.prevFrame, frame, self.prevKeyPoints, None)\n\n    # Leave good correspondences only\n    prevPoints = []\n    currPoints = []\n\n    for i in range(len(status)):\n        if status[i]:\n            prevPoints.append(self.prevKeyPoints[i])\n            currPoints.append(matchedKeypoints[i])\n\n    prevPoints = np.array(prevPoints)\n    currPoints = np.array(currPoints)\n\n    # Find rigid matrix\n    if np.size(prevPoints, 0) &gt; 4 and np.size(prevPoints, 0) == np.size(prevPoints, 0):\n        H, inliers = cv2.estimateAffinePartial2D(prevPoints, currPoints, cv2.RANSAC)\n\n        if self.downscale &gt; 1.0:\n            H[0, 2] *= self.downscale\n            H[1, 2] *= self.downscale\n    else:\n        LOGGER.warning(\"WARNING: not enough matching points\")\n\n    self.prevFrame = frame.copy()\n    self.prevKeyPoints = copy.copy(keypoints)\n\n    return H\n</code></pre>"},{"location":"reference/trackers/utils/gmc/#ultralytics.trackers.utils.gmc.GMC.reset_params","title":"<code>reset_params()</code>","text":"<p>Reset parameters.</p> Source code in <code>ultralytics/trackers/utils/gmc.py</code> <pre><code>def reset_params(self) -&gt; None:\n    \"\"\"Reset parameters.\"\"\"\n    self.prevFrame = None\n    self.prevKeyPoints = None\n    self.prevDescriptors = None\n    self.initializedFirstFrame = False\n</code></pre>"},{"location":"reference/trackers/utils/kalman_filter/","title":"Reference for <code>ultralytics/trackers/utils/kalman_filter.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/trackers/utils/kalman_filter.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p>"},{"location":"reference/trackers/utils/kalman_filter/#ultralytics.trackers.utils.kalman_filter.KalmanFilterXYAH","title":"<code>ultralytics.trackers.utils.kalman_filter.KalmanFilterXYAH</code>","text":"<p>For bytetrack. A simple Kalman filter for tracking bounding boxes in image space.</p> <p>The 8-dimensional state space (x, y, a, h, vx, vy, va, vh) contains the bounding box center position (x, y), aspect ratio a, height h, and their respective velocities.</p> <p>Object motion follows a constant velocity model. The bounding box location (x, y, a, h) is taken as direct observation of the state space (linear observation model).</p> Source code in <code>ultralytics/trackers/utils/kalman_filter.py</code> <pre><code>class KalmanFilterXYAH:\n    \"\"\"\n    For bytetrack. A simple Kalman filter for tracking bounding boxes in image space.\n\n    The 8-dimensional state space (x, y, a, h, vx, vy, va, vh) contains the bounding box center position (x, y), aspect\n    ratio a, height h, and their respective velocities.\n\n    Object motion follows a constant velocity model. The bounding box location (x, y, a, h) is taken as direct\n    observation of the state space (linear observation model).\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize Kalman filter model matrices with motion and observation uncertainty weights.\"\"\"\n        ndim, dt = 4, 1.0\n\n        # Create Kalman filter model matrices\n        self._motion_mat = np.eye(2 * ndim, 2 * ndim)\n        for i in range(ndim):\n            self._motion_mat[i, ndim + i] = dt\n        self._update_mat = np.eye(ndim, 2 * ndim)\n\n        # Motion and observation uncertainty are chosen relative to the current state estimate. These weights control\n        # the amount of uncertainty in the model.\n        self._std_weight_position = 1.0 / 20\n        self._std_weight_velocity = 1.0 / 160\n\n    def initiate(self, measurement: np.ndarray) -&gt; tuple:\n        \"\"\"\n        Create track from unassociated measurement.\n\n        Args:\n            measurement (ndarray): Bounding box coordinates (x, y, a, h) with center position (x, y), aspect ratio a,\n                and height h.\n\n        Returns:\n            (tuple[ndarray, ndarray]): Returns the mean vector (8 dimensional) and covariance matrix (8x8 dimensional) of\n                the new track. Unobserved velocities are initialized to 0 mean.\n        \"\"\"\n        mean_pos = measurement\n        mean_vel = np.zeros_like(mean_pos)\n        mean = np.r_[mean_pos, mean_vel]\n\n        std = [\n            2 * self._std_weight_position * measurement[3],\n            2 * self._std_weight_position * measurement[3],\n            1e-2,\n            2 * self._std_weight_position * measurement[3],\n            10 * self._std_weight_velocity * measurement[3],\n            10 * self._std_weight_velocity * measurement[3],\n            1e-5,\n            10 * self._std_weight_velocity * measurement[3],\n        ]\n        covariance = np.diag(np.square(std))\n        return mean, covariance\n\n    def predict(self, mean: np.ndarray, covariance: np.ndarray) -&gt; tuple:\n        \"\"\"\n        Run Kalman filter prediction step.\n\n        Args:\n            mean (ndarray): The 8 dimensional mean vector of the object state at the previous time step.\n            covariance (ndarray): The 8x8 dimensional covariance matrix of the object state at the previous time step.\n\n        Returns:\n            (tuple[ndarray, ndarray]): Returns the mean vector and covariance matrix of the predicted state. Unobserved\n                velocities are initialized to 0 mean.\n        \"\"\"\n        std_pos = [\n            self._std_weight_position * mean[3],\n            self._std_weight_position * mean[3],\n            1e-2,\n            self._std_weight_position * mean[3],\n        ]\n        std_vel = [\n            self._std_weight_velocity * mean[3],\n            self._std_weight_velocity * mean[3],\n            1e-5,\n            self._std_weight_velocity * mean[3],\n        ]\n        motion_cov = np.diag(np.square(np.r_[std_pos, std_vel]))\n\n        mean = np.dot(mean, self._motion_mat.T)\n        covariance = np.linalg.multi_dot((self._motion_mat, covariance, self._motion_mat.T)) + motion_cov\n\n        return mean, covariance\n\n    def project(self, mean: np.ndarray, covariance: np.ndarray) -&gt; tuple:\n        \"\"\"\n        Project state distribution to measurement space.\n\n        Args:\n            mean (ndarray): The state's mean vector (8 dimensional array).\n            covariance (ndarray): The state's covariance matrix (8x8 dimensional).\n\n        Returns:\n            (tuple[ndarray, ndarray]): Returns the projected mean and covariance matrix of the given state estimate.\n        \"\"\"\n        std = [\n            self._std_weight_position * mean[3],\n            self._std_weight_position * mean[3],\n            1e-1,\n            self._std_weight_position * mean[3],\n        ]\n        innovation_cov = np.diag(np.square(std))\n\n        mean = np.dot(self._update_mat, mean)\n        covariance = np.linalg.multi_dot((self._update_mat, covariance, self._update_mat.T))\n        return mean, covariance + innovation_cov\n\n    def multi_predict(self, mean: np.ndarray, covariance: np.ndarray) -&gt; tuple:\n        \"\"\"\n        Run Kalman filter prediction step (Vectorized version).\n\n        Args:\n            mean (ndarray): The Nx8 dimensional mean matrix of the object states at the previous time step.\n            covariance (ndarray): The Nx8x8 covariance matrix of the object states at the previous time step.\n\n        Returns:\n            (tuple[ndarray, ndarray]): Returns the mean vector and covariance matrix of the predicted state. Unobserved\n                velocities are initialized to 0 mean.\n        \"\"\"\n        std_pos = [\n            self._std_weight_position * mean[:, 3],\n            self._std_weight_position * mean[:, 3],\n            1e-2 * np.ones_like(mean[:, 3]),\n            self._std_weight_position * mean[:, 3],\n        ]\n        std_vel = [\n            self._std_weight_velocity * mean[:, 3],\n            self._std_weight_velocity * mean[:, 3],\n            1e-5 * np.ones_like(mean[:, 3]),\n            self._std_weight_velocity * mean[:, 3],\n        ]\n        sqr = np.square(np.r_[std_pos, std_vel]).T\n\n        motion_cov = [np.diag(sqr[i]) for i in range(len(mean))]\n        motion_cov = np.asarray(motion_cov)\n\n        mean = np.dot(mean, self._motion_mat.T)\n        left = np.dot(self._motion_mat, covariance).transpose((1, 0, 2))\n        covariance = np.dot(left, self._motion_mat.T) + motion_cov\n\n        return mean, covariance\n\n    def update(self, mean: np.ndarray, covariance: np.ndarray, measurement: np.ndarray) -&gt; tuple:\n        \"\"\"\n        Run Kalman filter correction step.\n\n        Args:\n            mean (ndarray): The predicted state's mean vector (8 dimensional).\n            covariance (ndarray): The state's covariance matrix (8x8 dimensional).\n            measurement (ndarray): The 4 dimensional measurement vector (x, y, a, h), where (x, y) is the center\n                position, a the aspect ratio, and h the height of the bounding box.\n\n        Returns:\n            (tuple[ndarray, ndarray]): Returns the measurement-corrected state distribution.\n        \"\"\"\n        projected_mean, projected_cov = self.project(mean, covariance)\n\n        chol_factor, lower = scipy.linalg.cho_factor(projected_cov, lower=True, check_finite=False)\n        kalman_gain = scipy.linalg.cho_solve(\n            (chol_factor, lower), np.dot(covariance, self._update_mat.T).T, check_finite=False\n        ).T\n        innovation = measurement - projected_mean\n\n        new_mean = mean + np.dot(innovation, kalman_gain.T)\n        new_covariance = covariance - np.linalg.multi_dot((kalman_gain, projected_cov, kalman_gain.T))\n        return new_mean, new_covariance\n\n    def gating_distance(\n        self,\n        mean: np.ndarray,\n        covariance: np.ndarray,\n        measurements: np.ndarray,\n        only_position: bool = False,\n        metric: str = \"maha\",\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Compute gating distance between state distribution and measurements. A suitable distance threshold can be\n        obtained from `chi2inv95`. If `only_position` is False, the chi-square distribution has 4 degrees of freedom,\n        otherwise 2.\n\n        Args:\n            mean (ndarray): Mean vector over the state distribution (8 dimensional).\n            covariance (ndarray): Covariance of the state distribution (8x8 dimensional).\n            measurements (ndarray): An Nx4 matrix of N measurements, each in format (x, y, a, h) where (x, y)\n                is the bounding box center position, a the aspect ratio, and h the height.\n            only_position (bool, optional): If True, distance computation is done with respect to the bounding box\n                center position only. Defaults to False.\n            metric (str, optional): The metric to use for calculating the distance. Options are 'gaussian' for the\n                squared Euclidean distance and 'maha' for the squared Mahalanobis distance. Defaults to 'maha'.\n\n        Returns:\n            (np.ndarray): Returns an array of length N, where the i-th element contains the squared distance between\n                (mean, covariance) and `measurements[i]`.\n        \"\"\"\n        mean, covariance = self.project(mean, covariance)\n        if only_position:\n            mean, covariance = mean[:2], covariance[:2, :2]\n            measurements = measurements[:, :2]\n\n        d = measurements - mean\n        if metric == \"gaussian\":\n            return np.sum(d * d, axis=1)\n        elif metric == \"maha\":\n            cholesky_factor = np.linalg.cholesky(covariance)\n            z = scipy.linalg.solve_triangular(cholesky_factor, d.T, lower=True, check_finite=False, overwrite_b=True)\n            return np.sum(z * z, axis=0)  # square maha\n        else:\n            raise ValueError(\"Invalid distance metric\")\n</code></pre>"},{"location":"reference/trackers/utils/kalman_filter/#ultralytics.trackers.utils.kalman_filter.KalmanFilterXYAH.__init__","title":"<code>__init__()</code>","text":"<p>Initialize Kalman filter model matrices with motion and observation uncertainty weights.</p> Source code in <code>ultralytics/trackers/utils/kalman_filter.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize Kalman filter model matrices with motion and observation uncertainty weights.\"\"\"\n    ndim, dt = 4, 1.0\n\n    # Create Kalman filter model matrices\n    self._motion_mat = np.eye(2 * ndim, 2 * ndim)\n    for i in range(ndim):\n        self._motion_mat[i, ndim + i] = dt\n    self._update_mat = np.eye(ndim, 2 * ndim)\n\n    # Motion and observation uncertainty are chosen relative to the current state estimate. These weights control\n    # the amount of uncertainty in the model.\n    self._std_weight_position = 1.0 / 20\n    self._std_weight_velocity = 1.0 / 160\n</code></pre>"},{"location":"reference/trackers/utils/kalman_filter/#ultralytics.trackers.utils.kalman_filter.KalmanFilterXYAH.gating_distance","title":"<code>gating_distance(mean, covariance, measurements, only_position=False, metric='maha')</code>","text":"<p>Compute gating distance between state distribution and measurements. A suitable distance threshold can be obtained from <code>chi2inv95</code>. If <code>only_position</code> is False, the chi-square distribution has 4 degrees of freedom, otherwise 2.</p> <p>Parameters:</p> Name Type Description Default <code>mean</code> <code>ndarray</code> <p>Mean vector over the state distribution (8 dimensional).</p> required <code>covariance</code> <code>ndarray</code> <p>Covariance of the state distribution (8x8 dimensional).</p> required <code>measurements</code> <code>ndarray</code> <p>An Nx4 matrix of N measurements, each in format (x, y, a, h) where (x, y) is the bounding box center position, a the aspect ratio, and h the height.</p> required <code>only_position</code> <code>bool</code> <p>If True, distance computation is done with respect to the bounding box center position only. Defaults to False.</p> <code>False</code> <code>metric</code> <code>str</code> <p>The metric to use for calculating the distance. Options are 'gaussian' for the squared Euclidean distance and 'maha' for the squared Mahalanobis distance. Defaults to 'maha'.</p> <code>'maha'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Returns an array of length N, where the i-th element contains the squared distance between (mean, covariance) and <code>measurements[i]</code>.</p> Source code in <code>ultralytics/trackers/utils/kalman_filter.py</code> <pre><code>def gating_distance(\n    self,\n    mean: np.ndarray,\n    covariance: np.ndarray,\n    measurements: np.ndarray,\n    only_position: bool = False,\n    metric: str = \"maha\",\n) -&gt; np.ndarray:\n    \"\"\"\n    Compute gating distance between state distribution and measurements. A suitable distance threshold can be\n    obtained from `chi2inv95`. If `only_position` is False, the chi-square distribution has 4 degrees of freedom,\n    otherwise 2.\n\n    Args:\n        mean (ndarray): Mean vector over the state distribution (8 dimensional).\n        covariance (ndarray): Covariance of the state distribution (8x8 dimensional).\n        measurements (ndarray): An Nx4 matrix of N measurements, each in format (x, y, a, h) where (x, y)\n            is the bounding box center position, a the aspect ratio, and h the height.\n        only_position (bool, optional): If True, distance computation is done with respect to the bounding box\n            center position only. Defaults to False.\n        metric (str, optional): The metric to use for calculating the distance. Options are 'gaussian' for the\n            squared Euclidean distance and 'maha' for the squared Mahalanobis distance. Defaults to 'maha'.\n\n    Returns:\n        (np.ndarray): Returns an array of length N, where the i-th element contains the squared distance between\n            (mean, covariance) and `measurements[i]`.\n    \"\"\"\n    mean, covariance = self.project(mean, covariance)\n    if only_position:\n        mean, covariance = mean[:2], covariance[:2, :2]\n        measurements = measurements[:, :2]\n\n    d = measurements - mean\n    if metric == \"gaussian\":\n        return np.sum(d * d, axis=1)\n    elif metric == \"maha\":\n        cholesky_factor = np.linalg.cholesky(covariance)\n        z = scipy.linalg.solve_triangular(cholesky_factor, d.T, lower=True, check_finite=False, overwrite_b=True)\n        return np.sum(z * z, axis=0)  # square maha\n    else:\n        raise ValueError(\"Invalid distance metric\")\n</code></pre>"},{"location":"reference/trackers/utils/kalman_filter/#ultralytics.trackers.utils.kalman_filter.KalmanFilterXYAH.initiate","title":"<code>initiate(measurement)</code>","text":"<p>Create track from unassociated measurement.</p> <p>Parameters:</p> Name Type Description Default <code>measurement</code> <code>ndarray</code> <p>Bounding box coordinates (x, y, a, h) with center position (x, y), aspect ratio a, and height h.</p> required <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray]</code> <p>Returns the mean vector (8 dimensional) and covariance matrix (8x8 dimensional) of the new track. Unobserved velocities are initialized to 0 mean.</p> Source code in <code>ultralytics/trackers/utils/kalman_filter.py</code> <pre><code>def initiate(self, measurement: np.ndarray) -&gt; tuple:\n    \"\"\"\n    Create track from unassociated measurement.\n\n    Args:\n        measurement (ndarray): Bounding box coordinates (x, y, a, h) with center position (x, y), aspect ratio a,\n            and height h.\n\n    Returns:\n        (tuple[ndarray, ndarray]): Returns the mean vector (8 dimensional) and covariance matrix (8x8 dimensional) of\n            the new track. Unobserved velocities are initialized to 0 mean.\n    \"\"\"\n    mean_pos = measurement\n    mean_vel = np.zeros_like(mean_pos)\n    mean = np.r_[mean_pos, mean_vel]\n\n    std = [\n        2 * self._std_weight_position * measurement[3],\n        2 * self._std_weight_position * measurement[3],\n        1e-2,\n        2 * self._std_weight_position * measurement[3],\n        10 * self._std_weight_velocity * measurement[3],\n        10 * self._std_weight_velocity * measurement[3],\n        1e-5,\n        10 * self._std_weight_velocity * measurement[3],\n    ]\n    covariance = np.diag(np.square(std))\n    return mean, covariance\n</code></pre>"},{"location":"reference/trackers/utils/kalman_filter/#ultralytics.trackers.utils.kalman_filter.KalmanFilterXYAH.multi_predict","title":"<code>multi_predict(mean, covariance)</code>","text":"<p>Run Kalman filter prediction step (Vectorized version).</p> <p>Parameters:</p> Name Type Description Default <code>mean</code> <code>ndarray</code> <p>The Nx8 dimensional mean matrix of the object states at the previous time step.</p> required <code>covariance</code> <code>ndarray</code> <p>The Nx8x8 covariance matrix of the object states at the previous time step.</p> required <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray]</code> <p>Returns the mean vector and covariance matrix of the predicted state. Unobserved velocities are initialized to 0 mean.</p> Source code in <code>ultralytics/trackers/utils/kalman_filter.py</code> <pre><code>def multi_predict(self, mean: np.ndarray, covariance: np.ndarray) -&gt; tuple:\n    \"\"\"\n    Run Kalman filter prediction step (Vectorized version).\n\n    Args:\n        mean (ndarray): The Nx8 dimensional mean matrix of the object states at the previous time step.\n        covariance (ndarray): The Nx8x8 covariance matrix of the object states at the previous time step.\n\n    Returns:\n        (tuple[ndarray, ndarray]): Returns the mean vector and covariance matrix of the predicted state. Unobserved\n            velocities are initialized to 0 mean.\n    \"\"\"\n    std_pos = [\n        self._std_weight_position * mean[:, 3],\n        self._std_weight_position * mean[:, 3],\n        1e-2 * np.ones_like(mean[:, 3]),\n        self._std_weight_position * mean[:, 3],\n    ]\n    std_vel = [\n        self._std_weight_velocity * mean[:, 3],\n        self._std_weight_velocity * mean[:, 3],\n        1e-5 * np.ones_like(mean[:, 3]),\n        self._std_weight_velocity * mean[:, 3],\n    ]\n    sqr = np.square(np.r_[std_pos, std_vel]).T\n\n    motion_cov = [np.diag(sqr[i]) for i in range(len(mean))]\n    motion_cov = np.asarray(motion_cov)\n\n    mean = np.dot(mean, self._motion_mat.T)\n    left = np.dot(self._motion_mat, covariance).transpose((1, 0, 2))\n    covariance = np.dot(left, self._motion_mat.T) + motion_cov\n\n    return mean, covariance\n</code></pre>"},{"location":"reference/trackers/utils/kalman_filter/#ultralytics.trackers.utils.kalman_filter.KalmanFilterXYAH.predict","title":"<code>predict(mean, covariance)</code>","text":"<p>Run Kalman filter prediction step.</p> <p>Parameters:</p> Name Type Description Default <code>mean</code> <code>ndarray</code> <p>The 8 dimensional mean vector of the object state at the previous time step.</p> required <code>covariance</code> <code>ndarray</code> <p>The 8x8 dimensional covariance matrix of the object state at the previous time step.</p> required <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray]</code> <p>Returns the mean vector and covariance matrix of the predicted state. Unobserved velocities are initialized to 0 mean.</p> Source code in <code>ultralytics/trackers/utils/kalman_filter.py</code> <pre><code>def predict(self, mean: np.ndarray, covariance: np.ndarray) -&gt; tuple:\n    \"\"\"\n    Run Kalman filter prediction step.\n\n    Args:\n        mean (ndarray): The 8 dimensional mean vector of the object state at the previous time step.\n        covariance (ndarray): The 8x8 dimensional covariance matrix of the object state at the previous time step.\n\n    Returns:\n        (tuple[ndarray, ndarray]): Returns the mean vector and covariance matrix of the predicted state. Unobserved\n            velocities are initialized to 0 mean.\n    \"\"\"\n    std_pos = [\n        self._std_weight_position * mean[3],\n        self._std_weight_position * mean[3],\n        1e-2,\n        self._std_weight_position * mean[3],\n    ]\n    std_vel = [\n        self._std_weight_velocity * mean[3],\n        self._std_weight_velocity * mean[3],\n        1e-5,\n        self._std_weight_velocity * mean[3],\n    ]\n    motion_cov = np.diag(np.square(np.r_[std_pos, std_vel]))\n\n    mean = np.dot(mean, self._motion_mat.T)\n    covariance = np.linalg.multi_dot((self._motion_mat, covariance, self._motion_mat.T)) + motion_cov\n\n    return mean, covariance\n</code></pre>"},{"location":"reference/trackers/utils/kalman_filter/#ultralytics.trackers.utils.kalman_filter.KalmanFilterXYAH.project","title":"<code>project(mean, covariance)</code>","text":"<p>Project state distribution to measurement space.</p> <p>Parameters:</p> Name Type Description Default <code>mean</code> <code>ndarray</code> <p>The state's mean vector (8 dimensional array).</p> required <code>covariance</code> <code>ndarray</code> <p>The state's covariance matrix (8x8 dimensional).</p> required <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray]</code> <p>Returns the projected mean and covariance matrix of the given state estimate.</p> Source code in <code>ultralytics/trackers/utils/kalman_filter.py</code> <pre><code>def project(self, mean: np.ndarray, covariance: np.ndarray) -&gt; tuple:\n    \"\"\"\n    Project state distribution to measurement space.\n\n    Args:\n        mean (ndarray): The state's mean vector (8 dimensional array).\n        covariance (ndarray): The state's covariance matrix (8x8 dimensional).\n\n    Returns:\n        (tuple[ndarray, ndarray]): Returns the projected mean and covariance matrix of the given state estimate.\n    \"\"\"\n    std = [\n        self._std_weight_position * mean[3],\n        self._std_weight_position * mean[3],\n        1e-1,\n        self._std_weight_position * mean[3],\n    ]\n    innovation_cov = np.diag(np.square(std))\n\n    mean = np.dot(self._update_mat, mean)\n    covariance = np.linalg.multi_dot((self._update_mat, covariance, self._update_mat.T))\n    return mean, covariance + innovation_cov\n</code></pre>"},{"location":"reference/trackers/utils/kalman_filter/#ultralytics.trackers.utils.kalman_filter.KalmanFilterXYAH.update","title":"<code>update(mean, covariance, measurement)</code>","text":"<p>Run Kalman filter correction step.</p> <p>Parameters:</p> Name Type Description Default <code>mean</code> <code>ndarray</code> <p>The predicted state's mean vector (8 dimensional).</p> required <code>covariance</code> <code>ndarray</code> <p>The state's covariance matrix (8x8 dimensional).</p> required <code>measurement</code> <code>ndarray</code> <p>The 4 dimensional measurement vector (x, y, a, h), where (x, y) is the center position, a the aspect ratio, and h the height of the bounding box.</p> required <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray]</code> <p>Returns the measurement-corrected state distribution.</p> Source code in <code>ultralytics/trackers/utils/kalman_filter.py</code> <pre><code>def update(self, mean: np.ndarray, covariance: np.ndarray, measurement: np.ndarray) -&gt; tuple:\n    \"\"\"\n    Run Kalman filter correction step.\n\n    Args:\n        mean (ndarray): The predicted state's mean vector (8 dimensional).\n        covariance (ndarray): The state's covariance matrix (8x8 dimensional).\n        measurement (ndarray): The 4 dimensional measurement vector (x, y, a, h), where (x, y) is the center\n            position, a the aspect ratio, and h the height of the bounding box.\n\n    Returns:\n        (tuple[ndarray, ndarray]): Returns the measurement-corrected state distribution.\n    \"\"\"\n    projected_mean, projected_cov = self.project(mean, covariance)\n\n    chol_factor, lower = scipy.linalg.cho_factor(projected_cov, lower=True, check_finite=False)\n    kalman_gain = scipy.linalg.cho_solve(\n        (chol_factor, lower), np.dot(covariance, self._update_mat.T).T, check_finite=False\n    ).T\n    innovation = measurement - projected_mean\n\n    new_mean = mean + np.dot(innovation, kalman_gain.T)\n    new_covariance = covariance - np.linalg.multi_dot((kalman_gain, projected_cov, kalman_gain.T))\n    return new_mean, new_covariance\n</code></pre>"},{"location":"reference/trackers/utils/kalman_filter/#ultralytics.trackers.utils.kalman_filter.KalmanFilterXYWH","title":"<code>ultralytics.trackers.utils.kalman_filter.KalmanFilterXYWH</code>","text":"<p>             Bases: <code>KalmanFilterXYAH</code></p> <p>For BoT-SORT. A simple Kalman filter for tracking bounding boxes in image space.</p> <p>The 8-dimensional state space (x, y, w, h, vx, vy, vw, vh) contains the bounding box center position (x, y), width w, height h, and their respective velocities.</p> <p>Object motion follows a constant velocity model. The bounding box location (x, y, w, h) is taken as direct observation of the state space (linear observation model).</p> Source code in <code>ultralytics/trackers/utils/kalman_filter.py</code> <pre><code>class KalmanFilterXYWH(KalmanFilterXYAH):\n    \"\"\"\n    For BoT-SORT. A simple Kalman filter for tracking bounding boxes in image space.\n\n    The 8-dimensional state space (x, y, w, h, vx, vy, vw, vh) contains the bounding box center position (x, y), width\n    w, height h, and their respective velocities.\n\n    Object motion follows a constant velocity model. The bounding box location (x, y, w, h) is taken as direct\n    observation of the state space (linear observation model).\n    \"\"\"\n\n    def initiate(self, measurement: np.ndarray) -&gt; tuple:\n        \"\"\"\n        Create track from unassociated measurement.\n\n        Args:\n            measurement (ndarray): Bounding box coordinates (x, y, w, h) with center position (x, y), width, and height.\n\n        Returns:\n            (tuple[ndarray, ndarray]): Returns the mean vector (8 dimensional) and covariance matrix (8x8 dimensional) of\n                the new track. Unobserved velocities are initialized to 0 mean.\n        \"\"\"\n        mean_pos = measurement\n        mean_vel = np.zeros_like(mean_pos)\n        mean = np.r_[mean_pos, mean_vel]\n\n        std = [\n            2 * self._std_weight_position * measurement[2],\n            2 * self._std_weight_position * measurement[3],\n            2 * self._std_weight_position * measurement[2],\n            2 * self._std_weight_position * measurement[3],\n            10 * self._std_weight_velocity * measurement[2],\n            10 * self._std_weight_velocity * measurement[3],\n            10 * self._std_weight_velocity * measurement[2],\n            10 * self._std_weight_velocity * measurement[3],\n        ]\n        covariance = np.diag(np.square(std))\n        return mean, covariance\n\n    def predict(self, mean, covariance) -&gt; tuple:\n        \"\"\"\n        Run Kalman filter prediction step.\n\n        Args:\n            mean (ndarray): The 8 dimensional mean vector of the object state at the previous time step.\n            covariance (ndarray): The 8x8 dimensional covariance matrix of the object state at the previous time step.\n\n        Returns:\n            (tuple[ndarray, ndarray]): Returns the mean vector and covariance matrix of the predicted state. Unobserved\n                velocities are initialized to 0 mean.\n        \"\"\"\n        std_pos = [\n            self._std_weight_position * mean[2],\n            self._std_weight_position * mean[3],\n            self._std_weight_position * mean[2],\n            self._std_weight_position * mean[3],\n        ]\n        std_vel = [\n            self._std_weight_velocity * mean[2],\n            self._std_weight_velocity * mean[3],\n            self._std_weight_velocity * mean[2],\n            self._std_weight_velocity * mean[3],\n        ]\n        motion_cov = np.diag(np.square(np.r_[std_pos, std_vel]))\n\n        mean = np.dot(mean, self._motion_mat.T)\n        covariance = np.linalg.multi_dot((self._motion_mat, covariance, self._motion_mat.T)) + motion_cov\n\n        return mean, covariance\n\n    def project(self, mean, covariance) -&gt; tuple:\n        \"\"\"\n        Project state distribution to measurement space.\n\n        Args:\n            mean (ndarray): The state's mean vector (8 dimensional array).\n            covariance (ndarray): The state's covariance matrix (8x8 dimensional).\n\n        Returns:\n            (tuple[ndarray, ndarray]): Returns the projected mean and covariance matrix of the given state estimate.\n        \"\"\"\n        std = [\n            self._std_weight_position * mean[2],\n            self._std_weight_position * mean[3],\n            self._std_weight_position * mean[2],\n            self._std_weight_position * mean[3],\n        ]\n        innovation_cov = np.diag(np.square(std))\n\n        mean = np.dot(self._update_mat, mean)\n        covariance = np.linalg.multi_dot((self._update_mat, covariance, self._update_mat.T))\n        return mean, covariance + innovation_cov\n\n    def multi_predict(self, mean, covariance) -&gt; tuple:\n        \"\"\"\n        Run Kalman filter prediction step (Vectorized version).\n\n        Args:\n            mean (ndarray): The Nx8 dimensional mean matrix of the object states at the previous time step.\n            covariance (ndarray): The Nx8x8 covariance matrix of the object states at the previous time step.\n\n        Returns:\n            (tuple[ndarray, ndarray]): Returns the mean vector and covariance matrix of the predicted state. Unobserved\n                velocities are initialized to 0 mean.\n        \"\"\"\n        std_pos = [\n            self._std_weight_position * mean[:, 2],\n            self._std_weight_position * mean[:, 3],\n            self._std_weight_position * mean[:, 2],\n            self._std_weight_position * mean[:, 3],\n        ]\n        std_vel = [\n            self._std_weight_velocity * mean[:, 2],\n            self._std_weight_velocity * mean[:, 3],\n            self._std_weight_velocity * mean[:, 2],\n            self._std_weight_velocity * mean[:, 3],\n        ]\n        sqr = np.square(np.r_[std_pos, std_vel]).T\n\n        motion_cov = [np.diag(sqr[i]) for i in range(len(mean))]\n        motion_cov = np.asarray(motion_cov)\n\n        mean = np.dot(mean, self._motion_mat.T)\n        left = np.dot(self._motion_mat, covariance).transpose((1, 0, 2))\n        covariance = np.dot(left, self._motion_mat.T) + motion_cov\n\n        return mean, covariance\n\n    def update(self, mean, covariance, measurement) -&gt; tuple:\n        \"\"\"\n        Run Kalman filter correction step.\n\n        Args:\n            mean (ndarray): The predicted state's mean vector (8 dimensional).\n            covariance (ndarray): The state's covariance matrix (8x8 dimensional).\n            measurement (ndarray): The 4 dimensional measurement vector (x, y, w, h), where (x, y) is the center\n                position, w the width, and h the height of the bounding box.\n\n        Returns:\n            (tuple[ndarray, ndarray]): Returns the measurement-corrected state distribution.\n        \"\"\"\n        return super().update(mean, covariance, measurement)\n</code></pre>"},{"location":"reference/trackers/utils/kalman_filter/#ultralytics.trackers.utils.kalman_filter.KalmanFilterXYWH.initiate","title":"<code>initiate(measurement)</code>","text":"<p>Create track from unassociated measurement.</p> <p>Parameters:</p> Name Type Description Default <code>measurement</code> <code>ndarray</code> <p>Bounding box coordinates (x, y, w, h) with center position (x, y), width, and height.</p> required <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray]</code> <p>Returns the mean vector (8 dimensional) and covariance matrix (8x8 dimensional) of the new track. Unobserved velocities are initialized to 0 mean.</p> Source code in <code>ultralytics/trackers/utils/kalman_filter.py</code> <pre><code>def initiate(self, measurement: np.ndarray) -&gt; tuple:\n    \"\"\"\n    Create track from unassociated measurement.\n\n    Args:\n        measurement (ndarray): Bounding box coordinates (x, y, w, h) with center position (x, y), width, and height.\n\n    Returns:\n        (tuple[ndarray, ndarray]): Returns the mean vector (8 dimensional) and covariance matrix (8x8 dimensional) of\n            the new track. Unobserved velocities are initialized to 0 mean.\n    \"\"\"\n    mean_pos = measurement\n    mean_vel = np.zeros_like(mean_pos)\n    mean = np.r_[mean_pos, mean_vel]\n\n    std = [\n        2 * self._std_weight_position * measurement[2],\n        2 * self._std_weight_position * measurement[3],\n        2 * self._std_weight_position * measurement[2],\n        2 * self._std_weight_position * measurement[3],\n        10 * self._std_weight_velocity * measurement[2],\n        10 * self._std_weight_velocity * measurement[3],\n        10 * self._std_weight_velocity * measurement[2],\n        10 * self._std_weight_velocity * measurement[3],\n    ]\n    covariance = np.diag(np.square(std))\n    return mean, covariance\n</code></pre>"},{"location":"reference/trackers/utils/kalman_filter/#ultralytics.trackers.utils.kalman_filter.KalmanFilterXYWH.multi_predict","title":"<code>multi_predict(mean, covariance)</code>","text":"<p>Run Kalman filter prediction step (Vectorized version).</p> <p>Parameters:</p> Name Type Description Default <code>mean</code> <code>ndarray</code> <p>The Nx8 dimensional mean matrix of the object states at the previous time step.</p> required <code>covariance</code> <code>ndarray</code> <p>The Nx8x8 covariance matrix of the object states at the previous time step.</p> required <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray]</code> <p>Returns the mean vector and covariance matrix of the predicted state. Unobserved velocities are initialized to 0 mean.</p> Source code in <code>ultralytics/trackers/utils/kalman_filter.py</code> <pre><code>def multi_predict(self, mean, covariance) -&gt; tuple:\n    \"\"\"\n    Run Kalman filter prediction step (Vectorized version).\n\n    Args:\n        mean (ndarray): The Nx8 dimensional mean matrix of the object states at the previous time step.\n        covariance (ndarray): The Nx8x8 covariance matrix of the object states at the previous time step.\n\n    Returns:\n        (tuple[ndarray, ndarray]): Returns the mean vector and covariance matrix of the predicted state. Unobserved\n            velocities are initialized to 0 mean.\n    \"\"\"\n    std_pos = [\n        self._std_weight_position * mean[:, 2],\n        self._std_weight_position * mean[:, 3],\n        self._std_weight_position * mean[:, 2],\n        self._std_weight_position * mean[:, 3],\n    ]\n    std_vel = [\n        self._std_weight_velocity * mean[:, 2],\n        self._std_weight_velocity * mean[:, 3],\n        self._std_weight_velocity * mean[:, 2],\n        self._std_weight_velocity * mean[:, 3],\n    ]\n    sqr = np.square(np.r_[std_pos, std_vel]).T\n\n    motion_cov = [np.diag(sqr[i]) for i in range(len(mean))]\n    motion_cov = np.asarray(motion_cov)\n\n    mean = np.dot(mean, self._motion_mat.T)\n    left = np.dot(self._motion_mat, covariance).transpose((1, 0, 2))\n    covariance = np.dot(left, self._motion_mat.T) + motion_cov\n\n    return mean, covariance\n</code></pre>"},{"location":"reference/trackers/utils/kalman_filter/#ultralytics.trackers.utils.kalman_filter.KalmanFilterXYWH.predict","title":"<code>predict(mean, covariance)</code>","text":"<p>Run Kalman filter prediction step.</p> <p>Parameters:</p> Name Type Description Default <code>mean</code> <code>ndarray</code> <p>The 8 dimensional mean vector of the object state at the previous time step.</p> required <code>covariance</code> <code>ndarray</code> <p>The 8x8 dimensional covariance matrix of the object state at the previous time step.</p> required <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray]</code> <p>Returns the mean vector and covariance matrix of the predicted state. Unobserved velocities are initialized to 0 mean.</p> Source code in <code>ultralytics/trackers/utils/kalman_filter.py</code> <pre><code>def predict(self, mean, covariance) -&gt; tuple:\n    \"\"\"\n    Run Kalman filter prediction step.\n\n    Args:\n        mean (ndarray): The 8 dimensional mean vector of the object state at the previous time step.\n        covariance (ndarray): The 8x8 dimensional covariance matrix of the object state at the previous time step.\n\n    Returns:\n        (tuple[ndarray, ndarray]): Returns the mean vector and covariance matrix of the predicted state. Unobserved\n            velocities are initialized to 0 mean.\n    \"\"\"\n    std_pos = [\n        self._std_weight_position * mean[2],\n        self._std_weight_position * mean[3],\n        self._std_weight_position * mean[2],\n        self._std_weight_position * mean[3],\n    ]\n    std_vel = [\n        self._std_weight_velocity * mean[2],\n        self._std_weight_velocity * mean[3],\n        self._std_weight_velocity * mean[2],\n        self._std_weight_velocity * mean[3],\n    ]\n    motion_cov = np.diag(np.square(np.r_[std_pos, std_vel]))\n\n    mean = np.dot(mean, self._motion_mat.T)\n    covariance = np.linalg.multi_dot((self._motion_mat, covariance, self._motion_mat.T)) + motion_cov\n\n    return mean, covariance\n</code></pre>"},{"location":"reference/trackers/utils/kalman_filter/#ultralytics.trackers.utils.kalman_filter.KalmanFilterXYWH.project","title":"<code>project(mean, covariance)</code>","text":"<p>Project state distribution to measurement space.</p> <p>Parameters:</p> Name Type Description Default <code>mean</code> <code>ndarray</code> <p>The state's mean vector (8 dimensional array).</p> required <code>covariance</code> <code>ndarray</code> <p>The state's covariance matrix (8x8 dimensional).</p> required <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray]</code> <p>Returns the projected mean and covariance matrix of the given state estimate.</p> Source code in <code>ultralytics/trackers/utils/kalman_filter.py</code> <pre><code>def project(self, mean, covariance) -&gt; tuple:\n    \"\"\"\n    Project state distribution to measurement space.\n\n    Args:\n        mean (ndarray): The state's mean vector (8 dimensional array).\n        covariance (ndarray): The state's covariance matrix (8x8 dimensional).\n\n    Returns:\n        (tuple[ndarray, ndarray]): Returns the projected mean and covariance matrix of the given state estimate.\n    \"\"\"\n    std = [\n        self._std_weight_position * mean[2],\n        self._std_weight_position * mean[3],\n        self._std_weight_position * mean[2],\n        self._std_weight_position * mean[3],\n    ]\n    innovation_cov = np.diag(np.square(std))\n\n    mean = np.dot(self._update_mat, mean)\n    covariance = np.linalg.multi_dot((self._update_mat, covariance, self._update_mat.T))\n    return mean, covariance + innovation_cov\n</code></pre>"},{"location":"reference/trackers/utils/kalman_filter/#ultralytics.trackers.utils.kalman_filter.KalmanFilterXYWH.update","title":"<code>update(mean, covariance, measurement)</code>","text":"<p>Run Kalman filter correction step.</p> <p>Parameters:</p> Name Type Description Default <code>mean</code> <code>ndarray</code> <p>The predicted state's mean vector (8 dimensional).</p> required <code>covariance</code> <code>ndarray</code> <p>The state's covariance matrix (8x8 dimensional).</p> required <code>measurement</code> <code>ndarray</code> <p>The 4 dimensional measurement vector (x, y, w, h), where (x, y) is the center position, w the width, and h the height of the bounding box.</p> required <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray]</code> <p>Returns the measurement-corrected state distribution.</p> Source code in <code>ultralytics/trackers/utils/kalman_filter.py</code> <pre><code>def update(self, mean, covariance, measurement) -&gt; tuple:\n    \"\"\"\n    Run Kalman filter correction step.\n\n    Args:\n        mean (ndarray): The predicted state's mean vector (8 dimensional).\n        covariance (ndarray): The state's covariance matrix (8x8 dimensional).\n        measurement (ndarray): The 4 dimensional measurement vector (x, y, w, h), where (x, y) is the center\n            position, w the width, and h the height of the bounding box.\n\n    Returns:\n        (tuple[ndarray, ndarray]): Returns the measurement-corrected state distribution.\n    \"\"\"\n    return super().update(mean, covariance, measurement)\n</code></pre>"},{"location":"reference/trackers/utils/matching/","title":"Reference for <code>ultralytics/trackers/utils/matching.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/trackers/utils/matching.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/trackers/utils/matching/#ultralytics.trackers.utils.matching.linear_assignment","title":"<code>ultralytics.trackers.utils.matching.linear_assignment(cost_matrix, thresh, use_lap=True)</code>","text":"<p>Perform linear assignment using scipy or lap.lapjv.</p> <p>Parameters:</p> Name Type Description Default <code>cost_matrix</code> <code>ndarray</code> <p>The matrix containing cost values for assignments.</p> required <code>thresh</code> <code>float</code> <p>Threshold for considering an assignment valid.</p> required <code>use_lap</code> <code>bool</code> <p>Whether to use lap.lapjv. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple with: - matched indices - unmatched indices from 'a' - unmatched indices from 'b'</p> Source code in <code>ultralytics/trackers/utils/matching.py</code> <pre><code>def linear_assignment(cost_matrix: np.ndarray, thresh: float, use_lap: bool = True) -&gt; tuple:\n    \"\"\"\n    Perform linear assignment using scipy or lap.lapjv.\n\n    Args:\n        cost_matrix (np.ndarray): The matrix containing cost values for assignments.\n        thresh (float): Threshold for considering an assignment valid.\n        use_lap (bool, optional): Whether to use lap.lapjv. Defaults to True.\n\n    Returns:\n        Tuple with:\n            - matched indices\n            - unmatched indices from 'a'\n            - unmatched indices from 'b'\n    \"\"\"\n\n    if cost_matrix.size == 0:\n        return np.empty((0, 2), dtype=int), tuple(range(cost_matrix.shape[0])), tuple(range(cost_matrix.shape[1]))\n\n    if use_lap:\n        # Use lap.lapjv\n        # https://github.com/gatagat/lap\n        _, x, y = lap.lapjv(cost_matrix, extend_cost=True, cost_limit=thresh)\n        matches = [[ix, mx] for ix, mx in enumerate(x) if mx &gt;= 0]\n        unmatched_a = np.where(x &lt; 0)[0]\n        unmatched_b = np.where(y &lt; 0)[0]\n    else:\n        # Use scipy.optimize.linear_sum_assignment\n        # https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.linear_sum_assignment.html\n        x, y = scipy.optimize.linear_sum_assignment(cost_matrix)  # row x, col y\n        matches = np.asarray([[x[i], y[i]] for i in range(len(x)) if cost_matrix[x[i], y[i]] &lt;= thresh])\n        if len(matches) == 0:\n            unmatched_a = list(np.arange(cost_matrix.shape[0]))\n            unmatched_b = list(np.arange(cost_matrix.shape[1]))\n        else:\n            unmatched_a = list(set(np.arange(cost_matrix.shape[0])) - set(matches[:, 0]))\n            unmatched_b = list(set(np.arange(cost_matrix.shape[1])) - set(matches[:, 1]))\n\n    return matches, unmatched_a, unmatched_b\n</code></pre>"},{"location":"reference/trackers/utils/matching/#ultralytics.trackers.utils.matching.iou_distance","title":"<code>ultralytics.trackers.utils.matching.iou_distance(atracks, btracks)</code>","text":"<p>Compute cost based on Intersection over Union (IoU) between tracks.</p> <p>Parameters:</p> Name Type Description Default <code>atracks</code> <code>list[STrack] | list[ndarray]</code> <p>List of tracks 'a' or bounding boxes.</p> required <code>btracks</code> <code>list[STrack] | list[ndarray]</code> <p>List of tracks 'b' or bounding boxes.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Cost matrix computed based on IoU.</p> Source code in <code>ultralytics/trackers/utils/matching.py</code> <pre><code>def iou_distance(atracks: list, btracks: list) -&gt; np.ndarray:\n    \"\"\"\n    Compute cost based on Intersection over Union (IoU) between tracks.\n\n    Args:\n        atracks (list[STrack] | list[np.ndarray]): List of tracks 'a' or bounding boxes.\n        btracks (list[STrack] | list[np.ndarray]): List of tracks 'b' or bounding boxes.\n\n    Returns:\n        (np.ndarray): Cost matrix computed based on IoU.\n    \"\"\"\n\n    if (len(atracks) &gt; 0 and isinstance(atracks[0], np.ndarray)) or (\n        len(btracks) &gt; 0 and isinstance(btracks[0], np.ndarray)\n    ):\n        atlbrs = atracks\n        btlbrs = btracks\n    else:\n        atlbrs = [track.tlbr for track in atracks]\n        btlbrs = [track.tlbr for track in btracks]\n\n    ious = np.zeros((len(atlbrs), len(btlbrs)), dtype=np.float32)\n    if len(atlbrs) and len(btlbrs):\n        ious = bbox_ioa(\n            np.ascontiguousarray(atlbrs, dtype=np.float32), np.ascontiguousarray(btlbrs, dtype=np.float32), iou=True\n        )\n    return 1 - ious  # cost matrix\n</code></pre>"},{"location":"reference/trackers/utils/matching/#ultralytics.trackers.utils.matching.embedding_distance","title":"<code>ultralytics.trackers.utils.matching.embedding_distance(tracks, detections, metric='cosine')</code>","text":"<p>Compute distance between tracks and detections based on embeddings.</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>list[STrack]</code> <p>List of tracks.</p> required <code>detections</code> <code>list[BaseTrack]</code> <p>List of detections.</p> required <code>metric</code> <code>str</code> <p>Metric for distance computation. Defaults to 'cosine'.</p> <code>'cosine'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Cost matrix computed based on embeddings.</p> Source code in <code>ultralytics/trackers/utils/matching.py</code> <pre><code>def embedding_distance(tracks: list, detections: list, metric: str = \"cosine\") -&gt; np.ndarray:\n    \"\"\"\n    Compute distance between tracks and detections based on embeddings.\n\n    Args:\n        tracks (list[STrack]): List of tracks.\n        detections (list[BaseTrack]): List of detections.\n        metric (str, optional): Metric for distance computation. Defaults to 'cosine'.\n\n    Returns:\n        (np.ndarray): Cost matrix computed based on embeddings.\n    \"\"\"\n\n    cost_matrix = np.zeros((len(tracks), len(detections)), dtype=np.float32)\n    if cost_matrix.size == 0:\n        return cost_matrix\n    det_features = np.asarray([track.curr_feat for track in detections], dtype=np.float32)\n    # for i, track in enumerate(tracks):\n    # cost_matrix[i, :] = np.maximum(0.0, cdist(track.smooth_feat.reshape(1,-1), det_features, metric))\n    track_features = np.asarray([track.smooth_feat for track in tracks], dtype=np.float32)\n    cost_matrix = np.maximum(0.0, cdist(track_features, det_features, metric))  # Normalized features\n    return cost_matrix\n</code></pre>"},{"location":"reference/trackers/utils/matching/#ultralytics.trackers.utils.matching.fuse_score","title":"<code>ultralytics.trackers.utils.matching.fuse_score(cost_matrix, detections)</code>","text":"<p>Fuses cost matrix with detection scores to produce a single similarity matrix.</p> <p>Parameters:</p> Name Type Description Default <code>cost_matrix</code> <code>ndarray</code> <p>The matrix containing cost values for assignments.</p> required <code>detections</code> <code>list[BaseTrack]</code> <p>List of detections with scores.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Fused similarity matrix.</p> Source code in <code>ultralytics/trackers/utils/matching.py</code> <pre><code>def fuse_score(cost_matrix: np.ndarray, detections: list) -&gt; np.ndarray:\n    \"\"\"\n    Fuses cost matrix with detection scores to produce a single similarity matrix.\n\n    Args:\n        cost_matrix (np.ndarray): The matrix containing cost values for assignments.\n        detections (list[BaseTrack]): List of detections with scores.\n\n    Returns:\n        (np.ndarray): Fused similarity matrix.\n    \"\"\"\n\n    if cost_matrix.size == 0:\n        return cost_matrix\n    iou_sim = 1 - cost_matrix\n    det_scores = np.array([det.score for det in detections])\n    det_scores = np.expand_dims(det_scores, axis=0).repeat(cost_matrix.shape[0], axis=0)\n    fuse_sim = iou_sim * det_scores\n    return 1 - fuse_sim  # fuse_cost\n</code></pre>"},{"location":"reference/utils/__init__/","title":"Reference for <code>ultralytics/utils/__init__.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/init.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/__init__/#ultralytics.utils.TQDM","title":"<code>ultralytics.utils.TQDM</code>","text":"<p>             Bases: <code>tqdm</code></p> <p>Custom Ultralytics tqdm class with different default arguments.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>list</code> <p>Positional arguments passed to original tqdm.</p> <code>()</code> <code>**kwargs</code> <code>dict</code> <p>Keyword arguments, with custom defaults applied.</p> <code>{}</code> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>class TQDM(tqdm_original):\n    \"\"\"\n    Custom Ultralytics tqdm class with different default arguments.\n\n    Args:\n        *args (list): Positional arguments passed to original tqdm.\n        **kwargs (dict): Keyword arguments, with custom defaults applied.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Initialize custom Ultralytics tqdm class with different default arguments.\"\"\"\n        # Set new default values (these can still be overridden when calling TQDM)\n        kwargs[\"disable\"] = not VERBOSE or kwargs.get(\"disable\", False)  # logical 'and' with default value if passed\n        kwargs.setdefault(\"bar_format\", TQDM_BAR_FORMAT)  # override default value if passed\n        super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.TQDM.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize custom Ultralytics tqdm class with different default arguments.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"Initialize custom Ultralytics tqdm class with different default arguments.\"\"\"\n    # Set new default values (these can still be overridden when calling TQDM)\n    kwargs[\"disable\"] = not VERBOSE or kwargs.get(\"disable\", False)  # logical 'and' with default value if passed\n    kwargs.setdefault(\"bar_format\", TQDM_BAR_FORMAT)  # override default value if passed\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.SimpleClass","title":"<code>ultralytics.utils.SimpleClass</code>","text":"<p>Ultralytics SimpleClass is a base class providing helpful string representation, error reporting, and attribute access methods for easier debugging and usage.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>class SimpleClass:\n    \"\"\"Ultralytics SimpleClass is a base class providing helpful string representation, error reporting, and attribute\n    access methods for easier debugging and usage.\n    \"\"\"\n\n    def __str__(self):\n        \"\"\"Return a human-readable string representation of the object.\"\"\"\n        attr = []\n        for a in dir(self):\n            v = getattr(self, a)\n            if not callable(v) and not a.startswith(\"_\"):\n                if isinstance(v, SimpleClass):\n                    # Display only the module and class name for subclasses\n                    s = f\"{a}: {v.__module__}.{v.__class__.__name__} object\"\n                else:\n                    s = f\"{a}: {repr(v)}\"\n                attr.append(s)\n        return f\"{self.__module__}.{self.__class__.__name__} object with attributes:\\n\\n\" + \"\\n\".join(attr)\n\n    def __repr__(self):\n        \"\"\"Return a machine-readable string representation of the object.\"\"\"\n        return self.__str__()\n\n    def __getattr__(self, attr):\n        \"\"\"Custom attribute access error message with helpful information.\"\"\"\n        name = self.__class__.__name__\n        raise AttributeError(f\"'{name}' object has no attribute '{attr}'. See valid attributes below.\\n{self.__doc__}\")\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.SimpleClass.__getattr__","title":"<code>__getattr__(attr)</code>","text":"<p>Custom attribute access error message with helpful information.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def __getattr__(self, attr):\n    \"\"\"Custom attribute access error message with helpful information.\"\"\"\n    name = self.__class__.__name__\n    raise AttributeError(f\"'{name}' object has no attribute '{attr}'. See valid attributes below.\\n{self.__doc__}\")\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.SimpleClass.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a machine-readable string representation of the object.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def __repr__(self):\n    \"\"\"Return a machine-readable string representation of the object.\"\"\"\n    return self.__str__()\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.SimpleClass.__str__","title":"<code>__str__()</code>","text":"<p>Return a human-readable string representation of the object.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def __str__(self):\n    \"\"\"Return a human-readable string representation of the object.\"\"\"\n    attr = []\n    for a in dir(self):\n        v = getattr(self, a)\n        if not callable(v) and not a.startswith(\"_\"):\n            if isinstance(v, SimpleClass):\n                # Display only the module and class name for subclasses\n                s = f\"{a}: {v.__module__}.{v.__class__.__name__} object\"\n            else:\n                s = f\"{a}: {repr(v)}\"\n            attr.append(s)\n    return f\"{self.__module__}.{self.__class__.__name__} object with attributes:\\n\\n\" + \"\\n\".join(attr)\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.IterableSimpleNamespace","title":"<code>ultralytics.utils.IterableSimpleNamespace</code>","text":"<p>             Bases: <code>SimpleNamespace</code></p> <p>Ultralytics IterableSimpleNamespace is an extension class of SimpleNamespace that adds iterable functionality and enables usage with dict() and for loops.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>class IterableSimpleNamespace(SimpleNamespace):\n    \"\"\"Ultralytics IterableSimpleNamespace is an extension class of SimpleNamespace that adds iterable functionality and\n    enables usage with dict() and for loops.\n    \"\"\"\n\n    def __iter__(self):\n        \"\"\"Return an iterator of key-value pairs from the namespace's attributes.\"\"\"\n        return iter(vars(self).items())\n\n    def __str__(self):\n        \"\"\"Return a human-readable string representation of the object.\"\"\"\n        return \"\\n\".join(f\"{k}={v}\" for k, v in vars(self).items())\n\n    def __getattr__(self, attr):\n        \"\"\"Custom attribute access error message with helpful information.\"\"\"\n        name = self.__class__.__name__\n        raise AttributeError(\n            f\"\"\"\n            '{name}' object has no attribute '{attr}'. This may be caused by a modified or out of date ultralytics\n            'default.yaml' file.\\nPlease update your code with 'pip install -U ultralytics' and if necessary replace\n            {DEFAULT_CFG_PATH} with the latest version from\n            https://github.com/ultralytics/ultralytics/blob/main/ultralytics/cfg/default.yaml\n            \"\"\"\n        )\n\n    def get(self, key, default=None):\n        \"\"\"Return the value of the specified key if it exists; otherwise, return the default value.\"\"\"\n        return getattr(self, key, default)\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.IterableSimpleNamespace.__getattr__","title":"<code>__getattr__(attr)</code>","text":"<p>Custom attribute access error message with helpful information.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def __getattr__(self, attr):\n    \"\"\"Custom attribute access error message with helpful information.\"\"\"\n    name = self.__class__.__name__\n    raise AttributeError(\n        f\"\"\"\n        '{name}' object has no attribute '{attr}'. This may be caused by a modified or out of date ultralytics\n        'default.yaml' file.\\nPlease update your code with 'pip install -U ultralytics' and if necessary replace\n        {DEFAULT_CFG_PATH} with the latest version from\n        https://github.com/ultralytics/ultralytics/blob/main/ultralytics/cfg/default.yaml\n        \"\"\"\n    )\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.IterableSimpleNamespace.__iter__","title":"<code>__iter__()</code>","text":"<p>Return an iterator of key-value pairs from the namespace's attributes.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def __iter__(self):\n    \"\"\"Return an iterator of key-value pairs from the namespace's attributes.\"\"\"\n    return iter(vars(self).items())\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.IterableSimpleNamespace.__str__","title":"<code>__str__()</code>","text":"<p>Return a human-readable string representation of the object.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def __str__(self):\n    \"\"\"Return a human-readable string representation of the object.\"\"\"\n    return \"\\n\".join(f\"{k}={v}\" for k, v in vars(self).items())\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.IterableSimpleNamespace.get","title":"<code>get(key, default=None)</code>","text":"<p>Return the value of the specified key if it exists; otherwise, return the default value.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def get(self, key, default=None):\n    \"\"\"Return the value of the specified key if it exists; otherwise, return the default value.\"\"\"\n    return getattr(self, key, default)\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.ThreadingLocked","title":"<code>ultralytics.utils.ThreadingLocked</code>","text":"<p>A decorator class for ensuring thread-safe execution of a function or method. This class can be used as a decorator to make sure that if the decorated function is called from multiple threads, only one thread at a time will be able to execute the function.</p> <p>Attributes:</p> Name Type Description <code>lock</code> <code>Lock</code> <p>A lock object used to manage access to the decorated function.</p> Example <pre><code>from ultralytics.utils import ThreadingLocked\n\n@ThreadingLocked()\ndef my_function():\n    # Your code here\n    pass\n</code></pre> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>class ThreadingLocked:\n    \"\"\"\n    A decorator class for ensuring thread-safe execution of a function or method. This class can be used as a decorator\n    to make sure that if the decorated function is called from multiple threads, only one thread at a time will be able\n    to execute the function.\n\n    Attributes:\n        lock (threading.Lock): A lock object used to manage access to the decorated function.\n\n    Example:\n        ```python\n        from ultralytics.utils import ThreadingLocked\n\n        @ThreadingLocked()\n        def my_function():\n            # Your code here\n            pass\n        ```\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initializes the decorator class for thread-safe execution of a function or method.\"\"\"\n        self.lock = threading.Lock()\n\n    def __call__(self, f):\n        \"\"\"Run thread-safe execution of function or method.\"\"\"\n        from functools import wraps\n\n        @wraps(f)\n        def decorated(*args, **kwargs):\n            \"\"\"Applies thread-safety to the decorated function or method.\"\"\"\n            with self.lock:\n                return f(*args, **kwargs)\n\n        return decorated\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.ThreadingLocked.__call__","title":"<code>__call__(f)</code>","text":"<p>Run thread-safe execution of function or method.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def __call__(self, f):\n    \"\"\"Run thread-safe execution of function or method.\"\"\"\n    from functools import wraps\n\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        \"\"\"Applies thread-safety to the decorated function or method.\"\"\"\n        with self.lock:\n            return f(*args, **kwargs)\n\n    return decorated\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.ThreadingLocked.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the decorator class for thread-safe execution of a function or method.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def __init__(self):\n    \"\"\"Initializes the decorator class for thread-safe execution of a function or method.\"\"\"\n    self.lock = threading.Lock()\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.TryExcept","title":"<code>ultralytics.utils.TryExcept</code>","text":"<p>             Bases: <code>ContextDecorator</code></p> <p>YOLOv8 TryExcept class.</p> <p>Use as @TryExcept() decorator or 'with TryExcept():' context manager.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>class TryExcept(contextlib.ContextDecorator):\n    \"\"\"\n    YOLOv8 TryExcept class.\n\n    Use as @TryExcept() decorator or 'with TryExcept():' context manager.\n    \"\"\"\n\n    def __init__(self, msg=\"\", verbose=True):\n        \"\"\"Initialize TryExcept class with optional message and verbosity settings.\"\"\"\n        self.msg = msg\n        self.verbose = verbose\n\n    def __enter__(self):\n        \"\"\"Executes when entering TryExcept context, initializes instance.\"\"\"\n        pass\n\n    def __exit__(self, exc_type, value, traceback):\n        \"\"\"Defines behavior when exiting a 'with' block, prints error message if necessary.\"\"\"\n        if self.verbose and value:\n            print(emojis(f\"{self.msg}{': ' if self.msg else ''}{value}\"))\n        return True\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.TryExcept.__enter__","title":"<code>__enter__()</code>","text":"<p>Executes when entering TryExcept context, initializes instance.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def __enter__(self):\n    \"\"\"Executes when entering TryExcept context, initializes instance.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.TryExcept.__exit__","title":"<code>__exit__(exc_type, value, traceback)</code>","text":"<p>Defines behavior when exiting a 'with' block, prints error message if necessary.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def __exit__(self, exc_type, value, traceback):\n    \"\"\"Defines behavior when exiting a 'with' block, prints error message if necessary.\"\"\"\n    if self.verbose and value:\n        print(emojis(f\"{self.msg}{': ' if self.msg else ''}{value}\"))\n    return True\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.TryExcept.__init__","title":"<code>__init__(msg='', verbose=True)</code>","text":"<p>Initialize TryExcept class with optional message and verbosity settings.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def __init__(self, msg=\"\", verbose=True):\n    \"\"\"Initialize TryExcept class with optional message and verbosity settings.\"\"\"\n    self.msg = msg\n    self.verbose = verbose\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.SettingsManager","title":"<code>ultralytics.utils.SettingsManager</code>","text":"<p>             Bases: <code>dict</code></p> <p>Manages Ultralytics settings stored in a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path</code> <p>Path to the Ultralytics settings YAML file. Default is USER_CONFIG_DIR / 'settings.yaml'.</p> <code>SETTINGS_YAML</code> <code>version</code> <code>str</code> <p>Settings version. In case of local version mismatch, new default settings will be saved.</p> <code>'0.0.4'</code> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>class SettingsManager(dict):\n    \"\"\"\n    Manages Ultralytics settings stored in a YAML file.\n\n    Args:\n        file (str | Path): Path to the Ultralytics settings YAML file. Default is USER_CONFIG_DIR / 'settings.yaml'.\n        version (str): Settings version. In case of local version mismatch, new default settings will be saved.\n    \"\"\"\n\n    def __init__(self, file=SETTINGS_YAML, version=\"0.0.4\"):\n        \"\"\"Initialize the SettingsManager with default settings, load and validate current settings from the YAML\n        file.\n        \"\"\"\n        import copy\n        import hashlib\n\n        from ultralytics.utils.checks import check_version\n        from ultralytics.utils.torch_utils import torch_distributed_zero_first\n\n        git_dir = get_git_dir()\n        root = git_dir or Path()\n        datasets_root = (root.parent if git_dir and is_dir_writeable(root.parent) else root).resolve()\n\n        self.file = Path(file)\n        self.version = version\n        self.defaults = {\n            \"settings_version\": version,\n            \"datasets_dir\": str(datasets_root / \"datasets\"),\n            \"weights_dir\": str(root / \"weights\"),\n            \"runs_dir\": str(root / \"runs\"),\n            \"uuid\": hashlib.sha256(str(uuid.getnode()).encode()).hexdigest(),\n            \"sync\": True,\n            \"api_key\": \"\",\n            \"openai_api_key\": \"\",\n            \"clearml\": True,  # integrations\n            \"comet\": True,\n            \"dvc\": True,\n            \"hub\": True,\n            \"mlflow\": True,\n            \"neptune\": True,\n            \"raytune\": True,\n            \"tensorboard\": True,\n            \"wandb\": True,\n        }\n\n        super().__init__(copy.deepcopy(self.defaults))\n\n        with torch_distributed_zero_first(RANK):\n            if not self.file.exists():\n                self.save()\n\n            self.load()\n            correct_keys = self.keys() == self.defaults.keys()\n            correct_types = all(type(a) is type(b) for a, b in zip(self.values(), self.defaults.values()))\n            correct_version = check_version(self[\"settings_version\"], self.version)\n            if not (correct_keys and correct_types and correct_version):\n                LOGGER.warning(\n                    \"WARNING \u26a0\ufe0f Ultralytics settings reset to default values. This may be due to a possible problem \"\n                    \"with your settings or a recent ultralytics package update. \"\n                    f\"\\nView settings with 'yolo settings' or at '{self.file}'\"\n                    \"\\nUpdate settings with 'yolo settings key=value', i.e. 'yolo settings runs_dir=path/to/dir'.\"\n                )\n                self.reset()\n\n    def load(self):\n        \"\"\"Loads settings from the YAML file.\"\"\"\n        super().update(yaml_load(self.file))\n\n    def save(self):\n        \"\"\"Saves the current settings to the YAML file.\"\"\"\n        yaml_save(self.file, dict(self))\n\n    def update(self, *args, **kwargs):\n        \"\"\"Updates a setting value in the current settings.\"\"\"\n        super().update(*args, **kwargs)\n        self.save()\n\n    def reset(self):\n        \"\"\"Resets the settings to default and saves them.\"\"\"\n        self.clear()\n        self.update(self.defaults)\n        self.save()\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.SettingsManager.__init__","title":"<code>__init__(file=SETTINGS_YAML, version='0.0.4')</code>","text":"<p>Initialize the SettingsManager with default settings, load and validate current settings from the YAML file.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def __init__(self, file=SETTINGS_YAML, version=\"0.0.4\"):\n    \"\"\"Initialize the SettingsManager with default settings, load and validate current settings from the YAML\n    file.\n    \"\"\"\n    import copy\n    import hashlib\n\n    from ultralytics.utils.checks import check_version\n    from ultralytics.utils.torch_utils import torch_distributed_zero_first\n\n    git_dir = get_git_dir()\n    root = git_dir or Path()\n    datasets_root = (root.parent if git_dir and is_dir_writeable(root.parent) else root).resolve()\n\n    self.file = Path(file)\n    self.version = version\n    self.defaults = {\n        \"settings_version\": version,\n        \"datasets_dir\": str(datasets_root / \"datasets\"),\n        \"weights_dir\": str(root / \"weights\"),\n        \"runs_dir\": str(root / \"runs\"),\n        \"uuid\": hashlib.sha256(str(uuid.getnode()).encode()).hexdigest(),\n        \"sync\": True,\n        \"api_key\": \"\",\n        \"openai_api_key\": \"\",\n        \"clearml\": True,  # integrations\n        \"comet\": True,\n        \"dvc\": True,\n        \"hub\": True,\n        \"mlflow\": True,\n        \"neptune\": True,\n        \"raytune\": True,\n        \"tensorboard\": True,\n        \"wandb\": True,\n    }\n\n    super().__init__(copy.deepcopy(self.defaults))\n\n    with torch_distributed_zero_first(RANK):\n        if not self.file.exists():\n            self.save()\n\n        self.load()\n        correct_keys = self.keys() == self.defaults.keys()\n        correct_types = all(type(a) is type(b) for a, b in zip(self.values(), self.defaults.values()))\n        correct_version = check_version(self[\"settings_version\"], self.version)\n        if not (correct_keys and correct_types and correct_version):\n            LOGGER.warning(\n                \"WARNING \u26a0\ufe0f Ultralytics settings reset to default values. This may be due to a possible problem \"\n                \"with your settings or a recent ultralytics package update. \"\n                f\"\\nView settings with 'yolo settings' or at '{self.file}'\"\n                \"\\nUpdate settings with 'yolo settings key=value', i.e. 'yolo settings runs_dir=path/to/dir'.\"\n            )\n            self.reset()\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.SettingsManager.load","title":"<code>load()</code>","text":"<p>Loads settings from the YAML file.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def load(self):\n    \"\"\"Loads settings from the YAML file.\"\"\"\n    super().update(yaml_load(self.file))\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.SettingsManager.reset","title":"<code>reset()</code>","text":"<p>Resets the settings to default and saves them.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def reset(self):\n    \"\"\"Resets the settings to default and saves them.\"\"\"\n    self.clear()\n    self.update(self.defaults)\n    self.save()\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.SettingsManager.save","title":"<code>save()</code>","text":"<p>Saves the current settings to the YAML file.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def save(self):\n    \"\"\"Saves the current settings to the YAML file.\"\"\"\n    yaml_save(self.file, dict(self))\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.SettingsManager.update","title":"<code>update(*args, **kwargs)</code>","text":"<p>Updates a setting value in the current settings.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def update(self, *args, **kwargs):\n    \"\"\"Updates a setting value in the current settings.\"\"\"\n    super().update(*args, **kwargs)\n    self.save()\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.plt_settings","title":"<code>ultralytics.utils.plt_settings(rcparams=None, backend='Agg')</code>","text":"<p>Decorator to temporarily set rc parameters and the backend for a plotting function.</p> Example <p>decorator: @plt_settings({\"font.size\": 12}) context manager: with plt_settings({\"font.size\": 12}):</p> <p>Parameters:</p> Name Type Description Default <code>rcparams</code> <code>dict</code> <p>Dictionary of rc parameters to set.</p> <code>None</code> <code>backend</code> <code>str</code> <p>Name of the backend to use. Defaults to 'Agg'.</p> <code>'Agg'</code> <p>Returns:</p> Type Description <code>Callable</code> <p>Decorated function with temporarily set rc parameters and backend. This decorator can be applied to any function that needs to have specific matplotlib rc parameters and backend for its execution.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def plt_settings(rcparams=None, backend=\"Agg\"):\n    \"\"\"\n    Decorator to temporarily set rc parameters and the backend for a plotting function.\n\n    Example:\n        decorator: @plt_settings({\"font.size\": 12})\n        context manager: with plt_settings({\"font.size\": 12}):\n\n    Args:\n        rcparams (dict): Dictionary of rc parameters to set.\n        backend (str, optional): Name of the backend to use. Defaults to 'Agg'.\n\n    Returns:\n        (Callable): Decorated function with temporarily set rc parameters and backend. This decorator can be\n            applied to any function that needs to have specific matplotlib rc parameters and backend for its execution.\n    \"\"\"\n\n    if rcparams is None:\n        rcparams = {\"font.size\": 11}\n\n    def decorator(func):\n        \"\"\"Decorator to apply temporary rc parameters and backend to a function.\"\"\"\n\n        def wrapper(*args, **kwargs):\n            \"\"\"Sets rc parameters and backend, calls the original function, and restores the settings.\"\"\"\n            original_backend = plt.get_backend()\n            if backend != original_backend:\n                plt.close(\"all\")  # auto-close()ing of figures upon backend switching is deprecated since 3.8\n                plt.switch_backend(backend)\n\n            with plt.rc_context(rcparams):\n                result = func(*args, **kwargs)\n\n            if backend != original_backend:\n                plt.close(\"all\")\n                plt.switch_backend(original_backend)\n            return result\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.set_logging","title":"<code>ultralytics.utils.set_logging(name=LOGGING_NAME, verbose=True)</code>","text":"<p>Sets up logging for the given name with UTF-8 encoding support.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def set_logging(name=LOGGING_NAME, verbose=True):\n    \"\"\"Sets up logging for the given name with UTF-8 encoding support.\"\"\"\n    level = logging.INFO if verbose and RANK in {-1, 0} else logging.ERROR  # rank in world for Multi-GPU trainings\n\n    # Configure the console (stdout) encoding to UTF-8\n    formatter = logging.Formatter(\"%(message)s\")  # Default formatter\n    if WINDOWS and sys.stdout.encoding != \"utf-8\":\n        try:\n            if hasattr(sys.stdout, \"reconfigure\"):\n                sys.stdout.reconfigure(encoding=\"utf-8\")\n            elif hasattr(sys.stdout, \"buffer\"):\n                import io\n\n                sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding=\"utf-8\")\n            else:\n                sys.stdout.encoding = \"utf-8\"\n        except Exception as e:\n            print(f\"Creating custom formatter for non UTF-8 environments due to {e}\")\n\n            class CustomFormatter(logging.Formatter):\n                def format(self, record):\n                    \"\"\"Sets up logging with UTF-8 encoding and configurable verbosity.\"\"\"\n                    return emojis(super().format(record))\n\n            formatter = CustomFormatter(\"%(message)s\")  # Use CustomFormatter to eliminate UTF-8 output as last recourse\n\n    # Create and configure the StreamHandler\n    stream_handler = logging.StreamHandler(sys.stdout)\n    stream_handler.setFormatter(formatter)\n    stream_handler.setLevel(level)\n\n    logger = logging.getLogger(name)\n    logger.setLevel(level)\n    logger.addHandler(stream_handler)\n    logger.propagate = False\n    return logger\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.emojis","title":"<code>ultralytics.utils.emojis(string='')</code>","text":"<p>Return platform-dependent emoji-safe version of string.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def emojis(string=\"\"):\n    \"\"\"Return platform-dependent emoji-safe version of string.\"\"\"\n    return string.encode().decode(\"ascii\", \"ignore\") if WINDOWS else string\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.yaml_save","title":"<code>ultralytics.utils.yaml_save(file='data.yaml', data=None, header='')</code>","text":"<p>Save YAML data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>File name. Default is 'data.yaml'.</p> <code>'data.yaml'</code> <code>data</code> <code>dict</code> <p>Data to save in YAML format.</p> <code>None</code> <code>header</code> <code>str</code> <p>YAML header to add.</p> <code>''</code> <p>Returns:</p> Type Description <code>None</code> <p>Data is saved to the specified file.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def yaml_save(file=\"data.yaml\", data=None, header=\"\"):\n    \"\"\"\n    Save YAML data to a file.\n\n    Args:\n        file (str, optional): File name. Default is 'data.yaml'.\n        data (dict): Data to save in YAML format.\n        header (str, optional): YAML header to add.\n\n    Returns:\n        (None): Data is saved to the specified file.\n    \"\"\"\n    if data is None:\n        data = {}\n    file = Path(file)\n    if not file.parent.exists():\n        # Create parent directories if they don't exist\n        file.parent.mkdir(parents=True, exist_ok=True)\n\n    # Convert Path objects to strings\n    valid_types = int, float, str, bool, list, tuple, dict, type(None)\n    for k, v in data.items():\n        if not isinstance(v, valid_types):\n            data[k] = str(v)\n\n    # Dump data to file in YAML format\n    with open(file, \"w\", errors=\"ignore\", encoding=\"utf-8\") as f:\n        if header:\n            f.write(header)\n        yaml.safe_dump(data, f, sort_keys=False, allow_unicode=True)\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.yaml_load","title":"<code>ultralytics.utils.yaml_load(file='data.yaml', append_filename=False)</code>","text":"<p>Load YAML data from a file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>File name. Default is 'data.yaml'.</p> <code>'data.yaml'</code> <code>append_filename</code> <code>bool</code> <p>Add the YAML filename to the YAML dictionary. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>YAML data and file name.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def yaml_load(file=\"data.yaml\", append_filename=False):\n    \"\"\"\n    Load YAML data from a file.\n\n    Args:\n        file (str, optional): File name. Default is 'data.yaml'.\n        append_filename (bool): Add the YAML filename to the YAML dictionary. Default is False.\n\n    Returns:\n        (dict): YAML data and file name.\n    \"\"\"\n    assert Path(file).suffix in (\".yaml\", \".yml\"), f\"Attempting to load non-YAML file {file} with yaml_load()\"\n    with open(file, errors=\"ignore\", encoding=\"utf-8\") as f:\n        s = f.read()  # string\n\n        # Remove special characters\n        if not s.isprintable():\n            s = re.sub(r\"[^\\x09\\x0A\\x0D\\x20-\\x7E\\x85\\xA0-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010ffff]+\", \"\", s)\n\n        # Add YAML filename to dict and return\n        data = yaml.safe_load(s) or {}  # always return a dict (yaml.safe_load() may return None for empty files)\n        if append_filename:\n            data[\"yaml_file\"] = str(file)\n        return data\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.yaml_print","title":"<code>ultralytics.utils.yaml_print(yaml_file)</code>","text":"<p>Pretty prints a YAML file or a YAML-formatted dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>yaml_file</code> <code>Union[str, Path, dict]</code> <p>The file path of the YAML file or a YAML-formatted dictionary.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def yaml_print(yaml_file: Union[str, Path, dict]) -&gt; None:\n    \"\"\"\n    Pretty prints a YAML file or a YAML-formatted dictionary.\n\n    Args:\n        yaml_file: The file path of the YAML file or a YAML-formatted dictionary.\n\n    Returns:\n        None\n    \"\"\"\n    yaml_dict = yaml_load(yaml_file) if isinstance(yaml_file, (str, Path)) else yaml_file\n    dump = yaml.dump(yaml_dict, sort_keys=False, allow_unicode=True)\n    LOGGER.info(f\"Printing '{colorstr('bold', 'black', yaml_file)}'\\n\\n{dump}\")\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.is_ubuntu","title":"<code>ultralytics.utils.is_ubuntu()</code>","text":"<p>Check if the OS is Ubuntu.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if OS is Ubuntu, False otherwise.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def is_ubuntu() -&gt; bool:\n    \"\"\"\n    Check if the OS is Ubuntu.\n\n    Returns:\n        (bool): True if OS is Ubuntu, False otherwise.\n    \"\"\"\n    with contextlib.suppress(FileNotFoundError):\n        with open(\"/etc/os-release\") as f:\n            return \"ID=ubuntu\" in f.read()\n    return False\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.is_colab","title":"<code>ultralytics.utils.is_colab()</code>","text":"<p>Check if the current script is running inside a Google Colab notebook.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if running inside a Colab notebook, False otherwise.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def is_colab():\n    \"\"\"\n    Check if the current script is running inside a Google Colab notebook.\n\n    Returns:\n        (bool): True if running inside a Colab notebook, False otherwise.\n    \"\"\"\n    return \"COLAB_RELEASE_TAG\" in os.environ or \"COLAB_BACKEND_VERSION\" in os.environ\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.is_kaggle","title":"<code>ultralytics.utils.is_kaggle()</code>","text":"<p>Check if the current script is running inside a Kaggle kernel.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if running inside a Kaggle kernel, False otherwise.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def is_kaggle():\n    \"\"\"\n    Check if the current script is running inside a Kaggle kernel.\n\n    Returns:\n        (bool): True if running inside a Kaggle kernel, False otherwise.\n    \"\"\"\n    return os.environ.get(\"PWD\") == \"/kaggle/working\" and os.environ.get(\"KAGGLE_URL_BASE\") == \"https://www.kaggle.com\"\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.is_jupyter","title":"<code>ultralytics.utils.is_jupyter()</code>","text":"<p>Check if the current script is running inside a Jupyter Notebook. Verified on Colab, Jupyterlab, Kaggle, Paperspace.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if running inside a Jupyter Notebook, False otherwise.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def is_jupyter():\n    \"\"\"\n    Check if the current script is running inside a Jupyter Notebook. Verified on Colab, Jupyterlab, Kaggle, Paperspace.\n\n    Returns:\n        (bool): True if running inside a Jupyter Notebook, False otherwise.\n    \"\"\"\n    with contextlib.suppress(Exception):\n        from IPython import get_ipython\n\n        return get_ipython() is not None\n    return False\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.is_docker","title":"<code>ultralytics.utils.is_docker()</code>","text":"<p>Determine if the script is running inside a Docker container.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the script is running inside a Docker container, False otherwise.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def is_docker() -&gt; bool:\n    \"\"\"\n    Determine if the script is running inside a Docker container.\n\n    Returns:\n        (bool): True if the script is running inside a Docker container, False otherwise.\n    \"\"\"\n    file = Path(\"/proc/self/cgroup\")\n    if file.exists():\n        with open(file) as f:\n            return \"docker\" in f.read()\n    else:\n        return False\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.is_online","title":"<code>ultralytics.utils.is_online()</code>","text":"<p>Check internet connectivity by attempting to connect to a known online host.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if connection is successful, False otherwise.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def is_online() -&gt; bool:\n    \"\"\"\n    Check internet connectivity by attempting to connect to a known online host.\n\n    Returns:\n        (bool): True if connection is successful, False otherwise.\n    \"\"\"\n    import socket\n\n    for host in \"1.1.1.1\", \"8.8.8.8\", \"223.5.5.5\":  # Cloudflare, Google, AliDNS:\n        try:\n            test_connection = socket.create_connection(address=(host, 53), timeout=2)\n        except (socket.timeout, socket.gaierror, OSError):\n            continue\n        else:\n            # If the connection was successful, close it to avoid a ResourceWarning\n            test_connection.close()\n            return True\n    return False\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.is_pip_package","title":"<code>ultralytics.utils.is_pip_package(filepath=__name__)</code>","text":"<p>Determines if the file at the given filepath is part of a pip package.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The filepath to check.</p> <code>__name__</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the file is part of a pip package, False otherwise.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def is_pip_package(filepath: str = __name__) -&gt; bool:\n    \"\"\"\n    Determines if the file at the given filepath is part of a pip package.\n\n    Args:\n        filepath (str): The filepath to check.\n\n    Returns:\n        (bool): True if the file is part of a pip package, False otherwise.\n    \"\"\"\n    import importlib.util\n\n    # Get the spec for the module\n    spec = importlib.util.find_spec(filepath)\n\n    # Return whether the spec is not None and the origin is not None (indicating it is a package)\n    return spec is not None and spec.origin is not None\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.is_dir_writeable","title":"<code>ultralytics.utils.is_dir_writeable(dir_path)</code>","text":"<p>Check if a directory is writeable.</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>str | Path</code> <p>The path to the directory.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the directory is writeable, False otherwise.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def is_dir_writeable(dir_path: Union[str, Path]) -&gt; bool:\n    \"\"\"\n    Check if a directory is writeable.\n\n    Args:\n        dir_path (str | Path): The path to the directory.\n\n    Returns:\n        (bool): True if the directory is writeable, False otherwise.\n    \"\"\"\n    return os.access(str(dir_path), os.W_OK)\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.is_pytest_running","title":"<code>ultralytics.utils.is_pytest_running()</code>","text":"<p>Determines whether pytest is currently running or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if pytest is running, False otherwise.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def is_pytest_running():\n    \"\"\"\n    Determines whether pytest is currently running or not.\n\n    Returns:\n        (bool): True if pytest is running, False otherwise.\n    \"\"\"\n    return (\"PYTEST_CURRENT_TEST\" in os.environ) or (\"pytest\" in sys.modules) or (\"pytest\" in Path(sys.argv[0]).stem)\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.is_github_action_running","title":"<code>ultralytics.utils.is_github_action_running()</code>","text":"<p>Determine if the current environment is a GitHub Actions runner.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the current environment is a GitHub Actions runner, False otherwise.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def is_github_action_running() -&gt; bool:\n    \"\"\"\n    Determine if the current environment is a GitHub Actions runner.\n\n    Returns:\n        (bool): True if the current environment is a GitHub Actions runner, False otherwise.\n    \"\"\"\n    return \"GITHUB_ACTIONS\" in os.environ and \"GITHUB_WORKFLOW\" in os.environ and \"RUNNER_OS\" in os.environ\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.is_git_dir","title":"<code>ultralytics.utils.is_git_dir()</code>","text":"<p>Determines whether the current file is part of a git repository. If the current file is not part of a git repository, returns None.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if current file is part of a git repository.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def is_git_dir():\n    \"\"\"\n    Determines whether the current file is part of a git repository. If the current file is not part of a git\n    repository, returns None.\n\n    Returns:\n        (bool): True if current file is part of a git repository.\n    \"\"\"\n    return get_git_dir() is not None\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.get_git_dir","title":"<code>ultralytics.utils.get_git_dir()</code>","text":"<p>Determines whether the current file is part of a git repository and if so, returns the repository root directory. If the current file is not part of a git repository, returns None.</p> <p>Returns:</p> Type Description <code>Path | None</code> <p>Git root directory if found or None if not found.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def get_git_dir():\n    \"\"\"\n    Determines whether the current file is part of a git repository and if so, returns the repository root directory. If\n    the current file is not part of a git repository, returns None.\n\n    Returns:\n        (Path | None): Git root directory if found or None if not found.\n    \"\"\"\n    for d in Path(__file__).parents:\n        if (d / \".git\").is_dir():\n            return d\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.get_git_origin_url","title":"<code>ultralytics.utils.get_git_origin_url()</code>","text":"<p>Retrieves the origin URL of a git repository.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>The origin URL of the git repository or None if not git directory.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def get_git_origin_url():\n    \"\"\"\n    Retrieves the origin URL of a git repository.\n\n    Returns:\n        (str | None): The origin URL of the git repository or None if not git directory.\n    \"\"\"\n    if is_git_dir():\n        with contextlib.suppress(subprocess.CalledProcessError):\n            origin = subprocess.check_output([\"git\", \"config\", \"--get\", \"remote.origin.url\"])\n            return origin.decode().strip()\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.get_git_branch","title":"<code>ultralytics.utils.get_git_branch()</code>","text":"<p>Returns the current git branch name. If not in a git repository, returns None.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>The current git branch name or None if not a git directory.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def get_git_branch():\n    \"\"\"\n    Returns the current git branch name. If not in a git repository, returns None.\n\n    Returns:\n        (str | None): The current git branch name or None if not a git directory.\n    \"\"\"\n    if is_git_dir():\n        with contextlib.suppress(subprocess.CalledProcessError):\n            origin = subprocess.check_output([\"git\", \"rev-parse\", \"--abbrev-ref\", \"HEAD\"])\n            return origin.decode().strip()\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.get_default_args","title":"<code>ultralytics.utils.get_default_args(func)</code>","text":"<p>Returns a dictionary of default arguments for a function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>The function to inspect.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary where each key is a parameter name, and each value is the default value of that parameter.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def get_default_args(func):\n    \"\"\"\n    Returns a dictionary of default arguments for a function.\n\n    Args:\n        func (callable): The function to inspect.\n\n    Returns:\n        (dict): A dictionary where each key is a parameter name, and each value is the default value of that parameter.\n    \"\"\"\n    signature = inspect.signature(func)\n    return {k: v.default for k, v in signature.parameters.items() if v.default is not inspect.Parameter.empty}\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.get_ubuntu_version","title":"<code>ultralytics.utils.get_ubuntu_version()</code>","text":"<p>Retrieve the Ubuntu version if the OS is Ubuntu.</p> <p>Returns:</p> Type Description <code>str</code> <p>Ubuntu version or None if not an Ubuntu OS.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def get_ubuntu_version():\n    \"\"\"\n    Retrieve the Ubuntu version if the OS is Ubuntu.\n\n    Returns:\n        (str): Ubuntu version or None if not an Ubuntu OS.\n    \"\"\"\n    if is_ubuntu():\n        with contextlib.suppress(FileNotFoundError, AttributeError):\n            with open(\"/etc/os-release\") as f:\n                return re.search(r'VERSION_ID=\"(\\d+\\.\\d+)\"', f.read())[1]\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.get_user_config_dir","title":"<code>ultralytics.utils.get_user_config_dir(sub_dir='Ultralytics')</code>","text":"<p>Get the user config directory.</p> <p>Parameters:</p> Name Type Description Default <code>sub_dir</code> <code>str</code> <p>The name of the subdirectory to create.</p> <code>'Ultralytics'</code> <p>Returns:</p> Type Description <code>Path</code> <p>The path to the user config directory.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def get_user_config_dir(sub_dir=\"Ultralytics\"):\n    \"\"\"\n    Get the user config directory.\n\n    Args:\n        sub_dir (str): The name of the subdirectory to create.\n\n    Returns:\n        (Path): The path to the user config directory.\n    \"\"\"\n    # Return the appropriate config directory for each operating system\n    if WINDOWS:\n        path = Path.home() / \"AppData\" / \"Roaming\" / sub_dir\n    elif MACOS:  # macOS\n        path = Path.home() / \"Library\" / \"Application Support\" / sub_dir\n    elif LINUX:\n        path = Path.home() / \".config\" / sub_dir\n    else:\n        raise ValueError(f\"Unsupported operating system: {platform.system()}\")\n\n    # GCP and AWS lambda fix, only /tmp is writeable\n    if not is_dir_writeable(path.parent):\n        LOGGER.warning(\n            f\"WARNING \u26a0\ufe0f user config directory '{path}' is not writeable, defaulting to '/tmp' or CWD.\"\n            \"Alternatively you can define a YOLO_CONFIG_DIR environment variable for this path.\"\n        )\n        path = Path(\"/tmp\") / sub_dir if is_dir_writeable(\"/tmp\") else Path().cwd() / sub_dir\n\n    # Create the subdirectory if it does not exist\n    path.mkdir(parents=True, exist_ok=True)\n\n    return path\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.colorstr","title":"<code>ultralytics.utils.colorstr(*input)</code>","text":"<p>Colors a string based on the provided color and style arguments. Utilizes ANSI escape codes. See https://en.wikipedia.org/wiki/ANSI_escape_code for more details.</p> This function can be called in two ways <ul> <li>colorstr('color', 'style', 'your string')</li> <li>colorstr('your string')</li> </ul> <p>In the second form, 'blue' and 'bold' will be applied by default.</p> <p>Parameters:</p> Name Type Description Default <code>*input</code> <code>str</code> <p>A sequence of strings where the first n-1 strings are color and style arguments,           and the last string is the one to be colored.</p> <code>()</code> Supported Colors and Styles <p>Basic Colors: 'black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white' Bright Colors: 'bright_black', 'bright_red', 'bright_green', 'bright_yellow',                'bright_blue', 'bright_magenta', 'bright_cyan', 'bright_white' Misc: 'end', 'bold', 'underline'</p> <p>Returns:</p> Type Description <code>str</code> <p>The input string wrapped with ANSI escape codes for the specified color and style.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; colorstr('blue', 'bold', 'hello world')\n&gt;&gt;&gt; '\u001b[34m\u001b[1mhello world\u001b[0m'\n</code></pre> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def colorstr(*input):\n    \"\"\"\n    Colors a string based on the provided color and style arguments. Utilizes ANSI escape codes.\n    See https://en.wikipedia.org/wiki/ANSI_escape_code for more details.\n\n    This function can be called in two ways:\n        - colorstr('color', 'style', 'your string')\n        - colorstr('your string')\n\n    In the second form, 'blue' and 'bold' will be applied by default.\n\n    Args:\n        *input (str): A sequence of strings where the first n-1 strings are color and style arguments,\n                      and the last string is the one to be colored.\n\n    Supported Colors and Styles:\n        Basic Colors: 'black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'\n        Bright Colors: 'bright_black', 'bright_red', 'bright_green', 'bright_yellow',\n                       'bright_blue', 'bright_magenta', 'bright_cyan', 'bright_white'\n        Misc: 'end', 'bold', 'underline'\n\n    Returns:\n        (str): The input string wrapped with ANSI escape codes for the specified color and style.\n\n    Examples:\n        &gt;&gt;&gt; colorstr('blue', 'bold', 'hello world')\n        &gt;&gt;&gt; '\\033[34m\\033[1mhello world\\033[0m'\n    \"\"\"\n    *args, string = input if len(input) &gt; 1 else (\"blue\", \"bold\", input[0])  # color arguments, string\n    colors = {\n        \"black\": \"\\033[30m\",  # basic colors\n        \"red\": \"\\033[31m\",\n        \"green\": \"\\033[32m\",\n        \"yellow\": \"\\033[33m\",\n        \"blue\": \"\\033[34m\",\n        \"magenta\": \"\\033[35m\",\n        \"cyan\": \"\\033[36m\",\n        \"white\": \"\\033[37m\",\n        \"bright_black\": \"\\033[90m\",  # bright colors\n        \"bright_red\": \"\\033[91m\",\n        \"bright_green\": \"\\033[92m\",\n        \"bright_yellow\": \"\\033[93m\",\n        \"bright_blue\": \"\\033[94m\",\n        \"bright_magenta\": \"\\033[95m\",\n        \"bright_cyan\": \"\\033[96m\",\n        \"bright_white\": \"\\033[97m\",\n        \"end\": \"\\033[0m\",  # misc\n        \"bold\": \"\\033[1m\",\n        \"underline\": \"\\033[4m\",\n    }\n    return \"\".join(colors[x] for x in args) + f\"{string}\" + colors[\"end\"]\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.remove_colorstr","title":"<code>ultralytics.utils.remove_colorstr(input_string)</code>","text":"<p>Removes ANSI escape codes from a string, effectively un-coloring it.</p> <p>Parameters:</p> Name Type Description Default <code>input_string</code> <code>str</code> <p>The string to remove color and style from.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A new string with all ANSI escape codes removed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; remove_colorstr(colorstr('blue', 'bold', 'hello world'))\n&gt;&gt;&gt; 'hello world'\n</code></pre> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def remove_colorstr(input_string):\n    \"\"\"\n    Removes ANSI escape codes from a string, effectively un-coloring it.\n\n    Args:\n        input_string (str): The string to remove color and style from.\n\n    Returns:\n        (str): A new string with all ANSI escape codes removed.\n\n    Examples:\n        &gt;&gt;&gt; remove_colorstr(colorstr('blue', 'bold', 'hello world'))\n        &gt;&gt;&gt; 'hello world'\n    \"\"\"\n    ansi_escape = re.compile(r\"\\x1B\\[[0-9;]*[A-Za-z]\")\n    return ansi_escape.sub(\"\", input_string)\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.threaded","title":"<code>ultralytics.utils.threaded(func)</code>","text":"<p>Multi-threads a target function by default and returns the thread or function result.</p> <p>Use as @threaded decorator. The function runs in a separate thread unless 'threaded=False' is passed.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def threaded(func):\n    \"\"\"\n    Multi-threads a target function by default and returns the thread or function result.\n\n    Use as @threaded decorator. The function runs in a separate thread unless 'threaded=False' is passed.\n    \"\"\"\n\n    def wrapper(*args, **kwargs):\n        \"\"\"Multi-threads a given function based on 'threaded' kwarg and returns the thread or function result.\"\"\"\n        if kwargs.pop(\"threaded\", True):  # run in thread\n            thread = threading.Thread(target=func, args=args, kwargs=kwargs, daemon=True)\n            thread.start()\n            return thread\n        else:\n            return func(*args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.set_sentry","title":"<code>ultralytics.utils.set_sentry()</code>","text":"<p>Initialize the Sentry SDK for error tracking and reporting. Only used if sentry_sdk package is installed and sync=True in settings. Run 'yolo settings' to see and update settings YAML file.</p> <p>Conditions required to send errors (ALL conditions must be met or no errors will be reported):     - sentry_sdk package is installed     - sync=True in YOLO settings     - pytest is not running     - running in a pip package installation     - running in a non-git directory     - running with rank -1 or 0     - online environment     - CLI used to run package (checked with 'yolo' as the name of the main CLI command)</p> <p>The function also configures Sentry SDK to ignore KeyboardInterrupt and FileNotFoundError exceptions and to exclude events with 'out of memory' in their exception message.</p> <p>Additionally, the function sets custom tags and user information for Sentry events.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def set_sentry():\n    \"\"\"\n    Initialize the Sentry SDK for error tracking and reporting. Only used if sentry_sdk package is installed and\n    sync=True in settings. Run 'yolo settings' to see and update settings YAML file.\n\n    Conditions required to send errors (ALL conditions must be met or no errors will be reported):\n        - sentry_sdk package is installed\n        - sync=True in YOLO settings\n        - pytest is not running\n        - running in a pip package installation\n        - running in a non-git directory\n        - running with rank -1 or 0\n        - online environment\n        - CLI used to run package (checked with 'yolo' as the name of the main CLI command)\n\n    The function also configures Sentry SDK to ignore KeyboardInterrupt and FileNotFoundError\n    exceptions and to exclude events with 'out of memory' in their exception message.\n\n    Additionally, the function sets custom tags and user information for Sentry events.\n    \"\"\"\n\n    def before_send(event, hint):\n        \"\"\"\n        Modify the event before sending it to Sentry based on specific exception types and messages.\n\n        Args:\n            event (dict): The event dictionary containing information about the error.\n            hint (dict): A dictionary containing additional information about the error.\n\n        Returns:\n            dict: The modified event or None if the event should not be sent to Sentry.\n        \"\"\"\n        if \"exc_info\" in hint:\n            exc_type, exc_value, tb = hint[\"exc_info\"]\n            if exc_type in (KeyboardInterrupt, FileNotFoundError) or \"out of memory\" in str(exc_value):\n                return None  # do not send event\n\n        event[\"tags\"] = {\n            \"sys_argv\": sys.argv[0],\n            \"sys_argv_name\": Path(sys.argv[0]).name,\n            \"install\": \"git\" if is_git_dir() else \"pip\" if is_pip_package() else \"other\",\n            \"os\": ENVIRONMENT,\n        }\n        return event\n\n    if (\n        SETTINGS[\"sync\"]\n        and RANK in (-1, 0)\n        and Path(sys.argv[0]).name == \"yolo\"\n        and not TESTS_RUNNING\n        and ONLINE\n        and is_pip_package()\n        and not is_git_dir()\n    ):\n        # If sentry_sdk package is not installed then return and do not use Sentry\n        try:\n            import sentry_sdk  # noqa\n        except ImportError:\n            return\n\n        sentry_sdk.init(\n            dsn=\"https://5ff1556b71594bfea135ff0203a0d290@o4504521589325824.ingest.sentry.io/4504521592406016\",\n            debug=False,\n            traces_sample_rate=1.0,\n            release=__version__,\n            environment=\"production\",  # 'dev' or 'production'\n            before_send=before_send,\n            ignore_errors=[KeyboardInterrupt, FileNotFoundError],\n        )\n        sentry_sdk.set_user({\"id\": SETTINGS[\"uuid\"]})  # SHA-256 anonymized UUID hash\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.deprecation_warn","title":"<code>ultralytics.utils.deprecation_warn(arg, new_arg, version=None)</code>","text":"<p>Issue a deprecation warning when a deprecated argument is used, suggesting an updated argument.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def deprecation_warn(arg, new_arg, version=None):\n    \"\"\"Issue a deprecation warning when a deprecated argument is used, suggesting an updated argument.\"\"\"\n    if not version:\n        version = float(__version__[:3]) + 0.2  # deprecate after 2nd major release\n    LOGGER.warning(\n        f\"WARNING \u26a0\ufe0f '{arg}' is deprecated and will be removed in 'ultralytics {version}' in the future. \"\n        f\"Please use '{new_arg}' instead.\"\n    )\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.clean_url","title":"<code>ultralytics.utils.clean_url(url)</code>","text":"<p>Strip auth from URL, i.e. https://url.com/file.txt?auth -&gt; https://url.com/file.txt.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def clean_url(url):\n    \"\"\"Strip auth from URL, i.e. https://url.com/file.txt?auth -&gt; https://url.com/file.txt.\"\"\"\n    url = Path(url).as_posix().replace(\":/\", \"://\")  # Pathlib turns :// -&gt; :/, as_posix() for Windows\n    return urllib.parse.unquote(url).split(\"?\")[0]  # '%2F' to '/', split https://url.com/file.txt?auth\n</code></pre>"},{"location":"reference/utils/__init__/#ultralytics.utils.url2file","title":"<code>ultralytics.utils.url2file(url)</code>","text":"<p>Convert URL to filename, i.e. https://url.com/file.txt?auth -&gt; file.txt.</p> Source code in <code>ultralytics/utils/__init__.py</code> <pre><code>def url2file(url):\n    \"\"\"Convert URL to filename, i.e. https://url.com/file.txt?auth -&gt; file.txt.\"\"\"\n    return Path(clean_url(url)).name\n</code></pre>"},{"location":"reference/utils/autobatch/","title":"Reference for <code>ultralytics/utils/autobatch.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/autobatch.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/autobatch/#ultralytics.utils.autobatch.check_train_batch_size","title":"<code>ultralytics.utils.autobatch.check_train_batch_size(model, imgsz=640, amp=True)</code>","text":"<p>Check YOLO training batch size using the autobatch() function.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Module</code> <p>YOLO model to check batch size for.</p> required <code>imgsz</code> <code>int</code> <p>Image size used for training.</p> <code>640</code> <code>amp</code> <code>bool</code> <p>If True, use automatic mixed precision (AMP) for training.</p> <code>True</code> <p>Returns:</p> Type Description <code>int</code> <p>Optimal batch size computed using the autobatch() function.</p> Source code in <code>ultralytics/utils/autobatch.py</code> <pre><code>def check_train_batch_size(model, imgsz=640, amp=True):\n    \"\"\"\n    Check YOLO training batch size using the autobatch() function.\n\n    Args:\n        model (torch.nn.Module): YOLO model to check batch size for.\n        imgsz (int): Image size used for training.\n        amp (bool): If True, use automatic mixed precision (AMP) for training.\n\n    Returns:\n        (int): Optimal batch size computed using the autobatch() function.\n    \"\"\"\n\n    with torch.cuda.amp.autocast(amp):\n        return autobatch(deepcopy(model).train(), imgsz)  # compute optimal batch size\n</code></pre>"},{"location":"reference/utils/autobatch/#ultralytics.utils.autobatch.autobatch","title":"<code>ultralytics.utils.autobatch.autobatch(model, imgsz=640, fraction=0.6, batch_size=DEFAULT_CFG.batch)</code>","text":"<p>Automatically estimate the best YOLO batch size to use a fraction of the available CUDA memory.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>module</code> <p>YOLO model to compute batch size for.</p> required <code>imgsz</code> <code>int</code> <p>The image size used as input for the YOLO model. Defaults to 640.</p> <code>640</code> <code>fraction</code> <code>float</code> <p>The fraction of available CUDA memory to use. Defaults to 0.60.</p> <code>0.6</code> <code>batch_size</code> <code>int</code> <p>The default batch size to use if an error is detected. Defaults to 16.</p> <code>batch</code> <p>Returns:</p> Type Description <code>int</code> <p>The optimal batch size.</p> Source code in <code>ultralytics/utils/autobatch.py</code> <pre><code>def autobatch(model, imgsz=640, fraction=0.60, batch_size=DEFAULT_CFG.batch):\n    \"\"\"\n    Automatically estimate the best YOLO batch size to use a fraction of the available CUDA memory.\n\n    Args:\n        model (torch.nn.module): YOLO model to compute batch size for.\n        imgsz (int, optional): The image size used as input for the YOLO model. Defaults to 640.\n        fraction (float, optional): The fraction of available CUDA memory to use. Defaults to 0.60.\n        batch_size (int, optional): The default batch size to use if an error is detected. Defaults to 16.\n\n    Returns:\n        (int): The optimal batch size.\n    \"\"\"\n\n    # Check device\n    prefix = colorstr(\"AutoBatch: \")\n    LOGGER.info(f\"{prefix}Computing optimal batch size for imgsz={imgsz}\")\n    device = next(model.parameters()).device  # get model device\n    if device.type == \"cpu\":\n        LOGGER.info(f\"{prefix}CUDA not detected, using default CPU batch-size {batch_size}\")\n        return batch_size\n    if torch.backends.cudnn.benchmark:\n        LOGGER.info(f\"{prefix} \u26a0\ufe0f Requires torch.backends.cudnn.benchmark=False, using default batch-size {batch_size}\")\n        return batch_size\n\n    # Inspect CUDA memory\n    gb = 1 &lt;&lt; 30  # bytes to GiB (1024 ** 3)\n    d = str(device).upper()  # 'CUDA:0'\n    properties = torch.cuda.get_device_properties(device)  # device properties\n    t = properties.total_memory / gb  # GiB total\n    r = torch.cuda.memory_reserved(device) / gb  # GiB reserved\n    a = torch.cuda.memory_allocated(device) / gb  # GiB allocated\n    f = t - (r + a)  # GiB free\n    LOGGER.info(f\"{prefix}{d} ({properties.name}) {t:.2f}G total, {r:.2f}G reserved, {a:.2f}G allocated, {f:.2f}G free\")\n\n    # Profile batch sizes\n    batch_sizes = [1, 2, 4, 8, 16]\n    try:\n        img = [torch.empty(b, 3, imgsz, imgsz) for b in batch_sizes]\n        results = profile(img, model, n=3, device=device)\n\n        # Fit a solution\n        y = [x[2] for x in results if x]  # memory [2]\n        p = np.polyfit(batch_sizes[: len(y)], y, deg=1)  # first degree polynomial fit\n        b = int((f * fraction - p[1]) / p[0])  # y intercept (optimal batch size)\n        if None in results:  # some sizes failed\n            i = results.index(None)  # first fail index\n            if b &gt;= batch_sizes[i]:  # y intercept above failure point\n                b = batch_sizes[max(i - 1, 0)]  # select prior safe point\n        if b &lt; 1 or b &gt; 1024:  # b outside of safe range\n            b = batch_size\n            LOGGER.info(f\"{prefix}WARNING \u26a0\ufe0f CUDA anomaly detected, using default batch-size {batch_size}.\")\n\n        fraction = (np.polyval(p, b) + r + a) / t  # actual fraction predicted\n        LOGGER.info(f\"{prefix}Using batch-size {b} for {d} {t * fraction:.2f}G/{t:.2f}G ({fraction * 100:.0f}%) \u2705\")\n        return b\n    except Exception as e:\n        LOGGER.warning(f\"{prefix}WARNING \u26a0\ufe0f error detected: {e},  using default batch-size {batch_size}.\")\n        return batch_size\n</code></pre>"},{"location":"reference/utils/benchmarks/","title":"Reference for <code>ultralytics/utils/benchmarks.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/benchmarks.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/benchmarks/#ultralytics.utils.benchmarks.ProfileModels","title":"<code>ultralytics.utils.benchmarks.ProfileModels</code>","text":"<p>ProfileModels class for profiling different models on ONNX and TensorRT.</p> <p>This class profiles the performance of different models, provided their paths. The profiling includes parameters such as model speed and FLOPs.</p> <p>Attributes:</p> Name Type Description <code>paths</code> <code>list</code> <p>Paths of the models to profile.</p> <code>num_timed_runs</code> <code>int</code> <p>Number of timed runs for the profiling. Default is 100.</p> <code>num_warmup_runs</code> <code>int</code> <p>Number of warmup runs before profiling. Default is 10.</p> <code>min_time</code> <code>float</code> <p>Minimum number of seconds to profile for. Default is 60.</p> <code>imgsz</code> <code>int</code> <p>Image size used in the models. Default is 640.</p> <p>Methods:</p> Name Description <code>profile</code> <p>Profiles the models and prints the result.</p> Example <pre><code>from ultralytics.utils.benchmarks import ProfileModels\n\nProfileModels(['yolov8n.yaml', 'yolov8s.yaml'], imgsz=640).profile()\n</code></pre> Source code in <code>ultralytics/utils/benchmarks.py</code> <pre><code>class ProfileModels:\n    \"\"\"\n    ProfileModels class for profiling different models on ONNX and TensorRT.\n\n    This class profiles the performance of different models, provided their paths. The profiling includes parameters such as\n    model speed and FLOPs.\n\n    Attributes:\n        paths (list): Paths of the models to profile.\n        num_timed_runs (int): Number of timed runs for the profiling. Default is 100.\n        num_warmup_runs (int): Number of warmup runs before profiling. Default is 10.\n        min_time (float): Minimum number of seconds to profile for. Default is 60.\n        imgsz (int): Image size used in the models. Default is 640.\n\n    Methods:\n        profile(): Profiles the models and prints the result.\n\n    Example:\n        ```python\n        from ultralytics.utils.benchmarks import ProfileModels\n\n        ProfileModels(['yolov8n.yaml', 'yolov8s.yaml'], imgsz=640).profile()\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        paths: list,\n        num_timed_runs=100,\n        num_warmup_runs=10,\n        min_time=60,\n        imgsz=640,\n        half=True,\n        trt=True,\n        device=None,\n    ):\n        \"\"\"\n        Initialize the ProfileModels class for profiling models.\n\n        Args:\n            paths (list): List of paths of the models to be profiled.\n            num_timed_runs (int, optional): Number of timed runs for the profiling. Default is 100.\n            num_warmup_runs (int, optional): Number of warmup runs before the actual profiling starts. Default is 10.\n            min_time (float, optional): Minimum time in seconds for profiling a model. Default is 60.\n            imgsz (int, optional): Size of the image used during profiling. Default is 640.\n            half (bool, optional): Flag to indicate whether to use half-precision floating point for profiling. Default is True.\n            trt (bool, optional): Flag to indicate whether to profile using TensorRT. Default is True.\n            device (torch.device, optional): Device used for profiling. If None, it is determined automatically. Default is None.\n        \"\"\"\n        self.paths = paths\n        self.num_timed_runs = num_timed_runs\n        self.num_warmup_runs = num_warmup_runs\n        self.min_time = min_time\n        self.imgsz = imgsz\n        self.half = half\n        self.trt = trt  # run TensorRT profiling\n        self.device = device or torch.device(0 if torch.cuda.is_available() else \"cpu\")\n\n    def profile(self):\n        \"\"\"Logs the benchmarking results of a model, checks metrics against floor and returns the results.\"\"\"\n        files = self.get_files()\n\n        if not files:\n            print(\"No matching *.pt or *.onnx files found.\")\n            return\n\n        table_rows = []\n        output = []\n        for file in files:\n            engine_file = file.with_suffix(\".engine\")\n            if file.suffix in (\".pt\", \".yaml\", \".yml\"):\n                model = YOLO(str(file))\n                model.fuse()  # to report correct params and GFLOPs in model.info()\n                model_info = model.info()\n                if self.trt and self.device.type != \"cpu\" and not engine_file.is_file():\n                    engine_file = model.export(\n                        format=\"engine\", half=self.half, imgsz=self.imgsz, device=self.device, verbose=False\n                    )\n                onnx_file = model.export(\n                    format=\"onnx\", half=self.half, imgsz=self.imgsz, simplify=True, device=self.device, verbose=False\n                )\n            elif file.suffix == \".onnx\":\n                model_info = self.get_onnx_model_info(file)\n                onnx_file = file\n            else:\n                continue\n\n            t_engine = self.profile_tensorrt_model(str(engine_file))\n            t_onnx = self.profile_onnx_model(str(onnx_file))\n            table_rows.append(self.generate_table_row(file.stem, t_onnx, t_engine, model_info))\n            output.append(self.generate_results_dict(file.stem, t_onnx, t_engine, model_info))\n\n        self.print_table(table_rows)\n        return output\n\n    def get_files(self):\n        \"\"\"Returns a list of paths for all relevant model files given by the user.\"\"\"\n        files = []\n        for path in self.paths:\n            path = Path(path)\n            if path.is_dir():\n                extensions = [\"*.pt\", \"*.onnx\", \"*.yaml\"]\n                files.extend([file for ext in extensions for file in glob.glob(str(path / ext))])\n            elif path.suffix in {\".pt\", \".yaml\", \".yml\"}:  # add non-existing\n                files.append(str(path))\n            else:\n                files.extend(glob.glob(str(path)))\n\n        print(f\"Profiling: {sorted(files)}\")\n        return [Path(file) for file in sorted(files)]\n\n    def get_onnx_model_info(self, onnx_file: str):\n        \"\"\"Retrieves the information including number of layers, parameters, gradients and FLOPs for an ONNX model\n        file.\n        \"\"\"\n        # return (num_layers, num_params, num_gradients, num_flops)\n        return 0.0, 0.0, 0.0, 0.0\n\n    def iterative_sigma_clipping(self, data, sigma=2, max_iters=3):\n        \"\"\"Applies an iterative sigma clipping algorithm to the given data times number of iterations.\"\"\"\n        data = np.array(data)\n        for _ in range(max_iters):\n            mean, std = np.mean(data), np.std(data)\n            clipped_data = data[(data &gt; mean - sigma * std) &amp; (data &lt; mean + sigma * std)]\n            if len(clipped_data) == len(data):\n                break\n            data = clipped_data\n        return data\n\n    def profile_tensorrt_model(self, engine_file: str, eps: float = 1e-3):\n        \"\"\"Profiles the TensorRT model, measuring average run time and standard deviation among runs.\"\"\"\n        if not self.trt or not Path(engine_file).is_file():\n            return 0.0, 0.0\n\n        # Model and input\n        model = YOLO(engine_file)\n        input_data = np.random.rand(self.imgsz, self.imgsz, 3).astype(np.float32)  # must be FP32\n\n        # Warmup runs\n        elapsed = 0.0\n        for _ in range(3):\n            start_time = time.time()\n            for _ in range(self.num_warmup_runs):\n                model(input_data, imgsz=self.imgsz, verbose=False)\n            elapsed = time.time() - start_time\n\n        # Compute number of runs as higher of min_time or num_timed_runs\n        num_runs = max(round(self.min_time / (elapsed + eps) * self.num_warmup_runs), self.num_timed_runs * 50)\n\n        # Timed runs\n        run_times = []\n        for _ in TQDM(range(num_runs), desc=engine_file):\n            results = model(input_data, imgsz=self.imgsz, verbose=False)\n            run_times.append(results[0].speed[\"inference\"])  # Convert to milliseconds\n\n        run_times = self.iterative_sigma_clipping(np.array(run_times), sigma=2, max_iters=3)  # sigma clipping\n        return np.mean(run_times), np.std(run_times)\n\n    def profile_onnx_model(self, onnx_file: str, eps: float = 1e-3):\n        \"\"\"Profiles an ONNX model by executing it multiple times and returns the mean and standard deviation of run\n        times.\n        \"\"\"\n        check_requirements(\"onnxruntime\")\n        import onnxruntime as ort\n\n        # Session with either 'TensorrtExecutionProvider', 'CUDAExecutionProvider', 'CPUExecutionProvider'\n        sess_options = ort.SessionOptions()\n        sess_options.graph_optimization_level = ort.GraphOptimizationLevel.ORT_ENABLE_ALL\n        sess_options.intra_op_num_threads = 8  # Limit the number of threads\n        sess = ort.InferenceSession(onnx_file, sess_options, providers=[\"CPUExecutionProvider\"])\n\n        input_tensor = sess.get_inputs()[0]\n        input_type = input_tensor.type\n\n        # Mapping ONNX datatype to numpy datatype\n        if \"float16\" in input_type:\n            input_dtype = np.float16\n        elif \"float\" in input_type:\n            input_dtype = np.float32\n        elif \"double\" in input_type:\n            input_dtype = np.float64\n        elif \"int64\" in input_type:\n            input_dtype = np.int64\n        elif \"int32\" in input_type:\n            input_dtype = np.int32\n        else:\n            raise ValueError(f\"Unsupported ONNX datatype {input_type}\")\n\n        input_data = np.random.rand(*input_tensor.shape).astype(input_dtype)\n        input_name = input_tensor.name\n        output_name = sess.get_outputs()[0].name\n\n        # Warmup runs\n        elapsed = 0.0\n        for _ in range(3):\n            start_time = time.time()\n            for _ in range(self.num_warmup_runs):\n                sess.run([output_name], {input_name: input_data})\n            elapsed = time.time() - start_time\n\n        # Compute number of runs as higher of min_time or num_timed_runs\n        num_runs = max(round(self.min_time / (elapsed + eps) * self.num_warmup_runs), self.num_timed_runs)\n\n        # Timed runs\n        run_times = []\n        for _ in TQDM(range(num_runs), desc=onnx_file):\n            start_time = time.time()\n            sess.run([output_name], {input_name: input_data})\n            run_times.append((time.time() - start_time) * 1000)  # Convert to milliseconds\n\n        run_times = self.iterative_sigma_clipping(np.array(run_times), sigma=2, max_iters=5)  # sigma clipping\n        return np.mean(run_times), np.std(run_times)\n\n    def generate_table_row(self, model_name, t_onnx, t_engine, model_info):\n        \"\"\"Generates a formatted string for a table row that includes model performance and metric details.\"\"\"\n        layers, params, gradients, flops = model_info\n        return f\"| {model_name:18s} | {self.imgsz} | - | {t_onnx[0]:.2f} \u00b1 {t_onnx[1]:.2f} ms | {t_engine[0]:.2f} \u00b1 {t_engine[1]:.2f} ms | {params / 1e6:.1f} | {flops:.1f} |\"\n\n    def generate_results_dict(self, model_name, t_onnx, t_engine, model_info):\n        \"\"\"Generates a dictionary of model details including name, parameters, GFLOPS and speed metrics.\"\"\"\n        layers, params, gradients, flops = model_info\n        return {\n            \"model/name\": model_name,\n            \"model/parameters\": params,\n            \"model/GFLOPs\": round(flops, 3),\n            \"model/speed_ONNX(ms)\": round(t_onnx[0], 3),\n            \"model/speed_TensorRT(ms)\": round(t_engine[0], 3),\n        }\n\n    def print_table(self, table_rows):\n        \"\"\"Formats and prints a comparison table for different models with given statistics and performance data.\"\"\"\n        gpu = torch.cuda.get_device_name(0) if torch.cuda.is_available() else \"GPU\"\n        header = f\"| Model | size&lt;br&gt;&lt;sup&gt;(pixels) | mAP&lt;sup&gt;val&lt;br&gt;50-95 | Speed&lt;br&gt;&lt;sup&gt;CPU ONNX&lt;br&gt;(ms) | Speed&lt;br&gt;&lt;sup&gt;{gpu} TensorRT&lt;br&gt;(ms) | params&lt;br&gt;&lt;sup&gt;(M) | FLOPs&lt;br&gt;&lt;sup&gt;(B) |\"\n        separator = \"|-------------|---------------------|--------------------|------------------------------|-----------------------------------|------------------|-----------------|\"\n\n        print(f\"\\n\\n{header}\")\n        print(separator)\n        for row in table_rows:\n            print(row)\n</code></pre>"},{"location":"reference/utils/benchmarks/#ultralytics.utils.benchmarks.ProfileModels.__init__","title":"<code>__init__(paths, num_timed_runs=100, num_warmup_runs=10, min_time=60, imgsz=640, half=True, trt=True, device=None)</code>","text":"<p>Initialize the ProfileModels class for profiling models.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>list</code> <p>List of paths of the models to be profiled.</p> required <code>num_timed_runs</code> <code>int</code> <p>Number of timed runs for the profiling. Default is 100.</p> <code>100</code> <code>num_warmup_runs</code> <code>int</code> <p>Number of warmup runs before the actual profiling starts. Default is 10.</p> <code>10</code> <code>min_time</code> <code>float</code> <p>Minimum time in seconds for profiling a model. Default is 60.</p> <code>60</code> <code>imgsz</code> <code>int</code> <p>Size of the image used during profiling. Default is 640.</p> <code>640</code> <code>half</code> <code>bool</code> <p>Flag to indicate whether to use half-precision floating point for profiling. Default is True.</p> <code>True</code> <code>trt</code> <code>bool</code> <p>Flag to indicate whether to profile using TensorRT. Default is True.</p> <code>True</code> <code>device</code> <code>device</code> <p>Device used for profiling. If None, it is determined automatically. Default is None.</p> <code>None</code> Source code in <code>ultralytics/utils/benchmarks.py</code> <pre><code>def __init__(\n    self,\n    paths: list,\n    num_timed_runs=100,\n    num_warmup_runs=10,\n    min_time=60,\n    imgsz=640,\n    half=True,\n    trt=True,\n    device=None,\n):\n    \"\"\"\n    Initialize the ProfileModels class for profiling models.\n\n    Args:\n        paths (list): List of paths of the models to be profiled.\n        num_timed_runs (int, optional): Number of timed runs for the profiling. Default is 100.\n        num_warmup_runs (int, optional): Number of warmup runs before the actual profiling starts. Default is 10.\n        min_time (float, optional): Minimum time in seconds for profiling a model. Default is 60.\n        imgsz (int, optional): Size of the image used during profiling. Default is 640.\n        half (bool, optional): Flag to indicate whether to use half-precision floating point for profiling. Default is True.\n        trt (bool, optional): Flag to indicate whether to profile using TensorRT. Default is True.\n        device (torch.device, optional): Device used for profiling. If None, it is determined automatically. Default is None.\n    \"\"\"\n    self.paths = paths\n    self.num_timed_runs = num_timed_runs\n    self.num_warmup_runs = num_warmup_runs\n    self.min_time = min_time\n    self.imgsz = imgsz\n    self.half = half\n    self.trt = trt  # run TensorRT profiling\n    self.device = device or torch.device(0 if torch.cuda.is_available() else \"cpu\")\n</code></pre>"},{"location":"reference/utils/benchmarks/#ultralytics.utils.benchmarks.ProfileModels.generate_results_dict","title":"<code>generate_results_dict(model_name, t_onnx, t_engine, model_info)</code>","text":"<p>Generates a dictionary of model details including name, parameters, GFLOPS and speed metrics.</p> Source code in <code>ultralytics/utils/benchmarks.py</code> <pre><code>def generate_results_dict(self, model_name, t_onnx, t_engine, model_info):\n    \"\"\"Generates a dictionary of model details including name, parameters, GFLOPS and speed metrics.\"\"\"\n    layers, params, gradients, flops = model_info\n    return {\n        \"model/name\": model_name,\n        \"model/parameters\": params,\n        \"model/GFLOPs\": round(flops, 3),\n        \"model/speed_ONNX(ms)\": round(t_onnx[0], 3),\n        \"model/speed_TensorRT(ms)\": round(t_engine[0], 3),\n    }\n</code></pre>"},{"location":"reference/utils/benchmarks/#ultralytics.utils.benchmarks.ProfileModels.generate_table_row","title":"<code>generate_table_row(model_name, t_onnx, t_engine, model_info)</code>","text":"<p>Generates a formatted string for a table row that includes model performance and metric details.</p> Source code in <code>ultralytics/utils/benchmarks.py</code> <pre><code>def generate_table_row(self, model_name, t_onnx, t_engine, model_info):\n    \"\"\"Generates a formatted string for a table row that includes model performance and metric details.\"\"\"\n    layers, params, gradients, flops = model_info\n    return f\"| {model_name:18s} | {self.imgsz} | - | {t_onnx[0]:.2f} \u00b1 {t_onnx[1]:.2f} ms | {t_engine[0]:.2f} \u00b1 {t_engine[1]:.2f} ms | {params / 1e6:.1f} | {flops:.1f} |\"\n</code></pre>"},{"location":"reference/utils/benchmarks/#ultralytics.utils.benchmarks.ProfileModels.get_files","title":"<code>get_files()</code>","text":"<p>Returns a list of paths for all relevant model files given by the user.</p> Source code in <code>ultralytics/utils/benchmarks.py</code> <pre><code>def get_files(self):\n    \"\"\"Returns a list of paths for all relevant model files given by the user.\"\"\"\n    files = []\n    for path in self.paths:\n        path = Path(path)\n        if path.is_dir():\n            extensions = [\"*.pt\", \"*.onnx\", \"*.yaml\"]\n            files.extend([file for ext in extensions for file in glob.glob(str(path / ext))])\n        elif path.suffix in {\".pt\", \".yaml\", \".yml\"}:  # add non-existing\n            files.append(str(path))\n        else:\n            files.extend(glob.glob(str(path)))\n\n    print(f\"Profiling: {sorted(files)}\")\n    return [Path(file) for file in sorted(files)]\n</code></pre>"},{"location":"reference/utils/benchmarks/#ultralytics.utils.benchmarks.ProfileModels.get_onnx_model_info","title":"<code>get_onnx_model_info(onnx_file)</code>","text":"<p>Retrieves the information including number of layers, parameters, gradients and FLOPs for an ONNX model file.</p> Source code in <code>ultralytics/utils/benchmarks.py</code> <pre><code>def get_onnx_model_info(self, onnx_file: str):\n    \"\"\"Retrieves the information including number of layers, parameters, gradients and FLOPs for an ONNX model\n    file.\n    \"\"\"\n    # return (num_layers, num_params, num_gradients, num_flops)\n    return 0.0, 0.0, 0.0, 0.0\n</code></pre>"},{"location":"reference/utils/benchmarks/#ultralytics.utils.benchmarks.ProfileModels.iterative_sigma_clipping","title":"<code>iterative_sigma_clipping(data, sigma=2, max_iters=3)</code>","text":"<p>Applies an iterative sigma clipping algorithm to the given data times number of iterations.</p> Source code in <code>ultralytics/utils/benchmarks.py</code> <pre><code>def iterative_sigma_clipping(self, data, sigma=2, max_iters=3):\n    \"\"\"Applies an iterative sigma clipping algorithm to the given data times number of iterations.\"\"\"\n    data = np.array(data)\n    for _ in range(max_iters):\n        mean, std = np.mean(data), np.std(data)\n        clipped_data = data[(data &gt; mean - sigma * std) &amp; (data &lt; mean + sigma * std)]\n        if len(clipped_data) == len(data):\n            break\n        data = clipped_data\n    return data\n</code></pre>"},{"location":"reference/utils/benchmarks/#ultralytics.utils.benchmarks.ProfileModels.print_table","title":"<code>print_table(table_rows)</code>","text":"<p>Formats and prints a comparison table for different models with given statistics and performance data.</p> Source code in <code>ultralytics/utils/benchmarks.py</code> <pre><code>def print_table(self, table_rows):\n    \"\"\"Formats and prints a comparison table for different models with given statistics and performance data.\"\"\"\n    gpu = torch.cuda.get_device_name(0) if torch.cuda.is_available() else \"GPU\"\n    header = f\"| Model | size&lt;br&gt;&lt;sup&gt;(pixels) | mAP&lt;sup&gt;val&lt;br&gt;50-95 | Speed&lt;br&gt;&lt;sup&gt;CPU ONNX&lt;br&gt;(ms) | Speed&lt;br&gt;&lt;sup&gt;{gpu} TensorRT&lt;br&gt;(ms) | params&lt;br&gt;&lt;sup&gt;(M) | FLOPs&lt;br&gt;&lt;sup&gt;(B) |\"\n    separator = \"|-------------|---------------------|--------------------|------------------------------|-----------------------------------|------------------|-----------------|\"\n\n    print(f\"\\n\\n{header}\")\n    print(separator)\n    for row in table_rows:\n        print(row)\n</code></pre>"},{"location":"reference/utils/benchmarks/#ultralytics.utils.benchmarks.ProfileModels.profile","title":"<code>profile()</code>","text":"<p>Logs the benchmarking results of a model, checks metrics against floor and returns the results.</p> Source code in <code>ultralytics/utils/benchmarks.py</code> <pre><code>def profile(self):\n    \"\"\"Logs the benchmarking results of a model, checks metrics against floor and returns the results.\"\"\"\n    files = self.get_files()\n\n    if not files:\n        print(\"No matching *.pt or *.onnx files found.\")\n        return\n\n    table_rows = []\n    output = []\n    for file in files:\n        engine_file = file.with_suffix(\".engine\")\n        if file.suffix in (\".pt\", \".yaml\", \".yml\"):\n            model = YOLO(str(file))\n            model.fuse()  # to report correct params and GFLOPs in model.info()\n            model_info = model.info()\n            if self.trt and self.device.type != \"cpu\" and not engine_file.is_file():\n                engine_file = model.export(\n                    format=\"engine\", half=self.half, imgsz=self.imgsz, device=self.device, verbose=False\n                )\n            onnx_file = model.export(\n                format=\"onnx\", half=self.half, imgsz=self.imgsz, simplify=True, device=self.device, verbose=False\n            )\n        elif file.suffix == \".onnx\":\n            model_info = self.get_onnx_model_info(file)\n            onnx_file = file\n        else:\n            continue\n\n        t_engine = self.profile_tensorrt_model(str(engine_file))\n        t_onnx = self.profile_onnx_model(str(onnx_file))\n        table_rows.append(self.generate_table_row(file.stem, t_onnx, t_engine, model_info))\n        output.append(self.generate_results_dict(file.stem, t_onnx, t_engine, model_info))\n\n    self.print_table(table_rows)\n    return output\n</code></pre>"},{"location":"reference/utils/benchmarks/#ultralytics.utils.benchmarks.ProfileModels.profile_onnx_model","title":"<code>profile_onnx_model(onnx_file, eps=0.001)</code>","text":"<p>Profiles an ONNX model by executing it multiple times and returns the mean and standard deviation of run times.</p> Source code in <code>ultralytics/utils/benchmarks.py</code> <pre><code>def profile_onnx_model(self, onnx_file: str, eps: float = 1e-3):\n    \"\"\"Profiles an ONNX model by executing it multiple times and returns the mean and standard deviation of run\n    times.\n    \"\"\"\n    check_requirements(\"onnxruntime\")\n    import onnxruntime as ort\n\n    # Session with either 'TensorrtExecutionProvider', 'CUDAExecutionProvider', 'CPUExecutionProvider'\n    sess_options = ort.SessionOptions()\n    sess_options.graph_optimization_level = ort.GraphOptimizationLevel.ORT_ENABLE_ALL\n    sess_options.intra_op_num_threads = 8  # Limit the number of threads\n    sess = ort.InferenceSession(onnx_file, sess_options, providers=[\"CPUExecutionProvider\"])\n\n    input_tensor = sess.get_inputs()[0]\n    input_type = input_tensor.type\n\n    # Mapping ONNX datatype to numpy datatype\n    if \"float16\" in input_type:\n        input_dtype = np.float16\n    elif \"float\" in input_type:\n        input_dtype = np.float32\n    elif \"double\" in input_type:\n        input_dtype = np.float64\n    elif \"int64\" in input_type:\n        input_dtype = np.int64\n    elif \"int32\" in input_type:\n        input_dtype = np.int32\n    else:\n        raise ValueError(f\"Unsupported ONNX datatype {input_type}\")\n\n    input_data = np.random.rand(*input_tensor.shape).astype(input_dtype)\n    input_name = input_tensor.name\n    output_name = sess.get_outputs()[0].name\n\n    # Warmup runs\n    elapsed = 0.0\n    for _ in range(3):\n        start_time = time.time()\n        for _ in range(self.num_warmup_runs):\n            sess.run([output_name], {input_name: input_data})\n        elapsed = time.time() - start_time\n\n    # Compute number of runs as higher of min_time or num_timed_runs\n    num_runs = max(round(self.min_time / (elapsed + eps) * self.num_warmup_runs), self.num_timed_runs)\n\n    # Timed runs\n    run_times = []\n    for _ in TQDM(range(num_runs), desc=onnx_file):\n        start_time = time.time()\n        sess.run([output_name], {input_name: input_data})\n        run_times.append((time.time() - start_time) * 1000)  # Convert to milliseconds\n\n    run_times = self.iterative_sigma_clipping(np.array(run_times), sigma=2, max_iters=5)  # sigma clipping\n    return np.mean(run_times), np.std(run_times)\n</code></pre>"},{"location":"reference/utils/benchmarks/#ultralytics.utils.benchmarks.ProfileModels.profile_tensorrt_model","title":"<code>profile_tensorrt_model(engine_file, eps=0.001)</code>","text":"<p>Profiles the TensorRT model, measuring average run time and standard deviation among runs.</p> Source code in <code>ultralytics/utils/benchmarks.py</code> <pre><code>def profile_tensorrt_model(self, engine_file: str, eps: float = 1e-3):\n    \"\"\"Profiles the TensorRT model, measuring average run time and standard deviation among runs.\"\"\"\n    if not self.trt or not Path(engine_file).is_file():\n        return 0.0, 0.0\n\n    # Model and input\n    model = YOLO(engine_file)\n    input_data = np.random.rand(self.imgsz, self.imgsz, 3).astype(np.float32)  # must be FP32\n\n    # Warmup runs\n    elapsed = 0.0\n    for _ in range(3):\n        start_time = time.time()\n        for _ in range(self.num_warmup_runs):\n            model(input_data, imgsz=self.imgsz, verbose=False)\n        elapsed = time.time() - start_time\n\n    # Compute number of runs as higher of min_time or num_timed_runs\n    num_runs = max(round(self.min_time / (elapsed + eps) * self.num_warmup_runs), self.num_timed_runs * 50)\n\n    # Timed runs\n    run_times = []\n    for _ in TQDM(range(num_runs), desc=engine_file):\n        results = model(input_data, imgsz=self.imgsz, verbose=False)\n        run_times.append(results[0].speed[\"inference\"])  # Convert to milliseconds\n\n    run_times = self.iterative_sigma_clipping(np.array(run_times), sigma=2, max_iters=3)  # sigma clipping\n    return np.mean(run_times), np.std(run_times)\n</code></pre>"},{"location":"reference/utils/benchmarks/#ultralytics.utils.benchmarks.benchmark","title":"<code>ultralytics.utils.benchmarks.benchmark(model=WEIGHTS_DIR / 'yolov8n.pt', data=None, imgsz=160, half=False, int8=False, device='cpu', verbose=False)</code>","text":"<p>Benchmark a YOLO model across different formats for speed and accuracy.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str | Path | optional</code> <p>Path to the model file or directory. Default is Path(SETTINGS['weights_dir']) / 'yolov8n.pt'.</p> <code>WEIGHTS_DIR / 'yolov8n.pt'</code> <code>data</code> <code>str</code> <p>Dataset to evaluate on, inherited from TASK2DATA if not passed. Default is None.</p> <code>None</code> <code>imgsz</code> <code>int</code> <p>Image size for the benchmark. Default is 160.</p> <code>160</code> <code>half</code> <code>bool</code> <p>Use half-precision for the model if True. Default is False.</p> <code>False</code> <code>int8</code> <code>bool</code> <p>Use int8-precision for the model if True. Default is False.</p> <code>False</code> <code>device</code> <code>str</code> <p>Device to run the benchmark on, either 'cpu' or 'cuda'. Default is 'cpu'.</p> <code>'cpu'</code> <code>verbose</code> <code>bool | float | optional</code> <p>If True or a float, assert benchmarks pass with given metric. Default is False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>df</code> <code>DataFrame</code> <p>A pandas DataFrame with benchmark results for each format, including file size, metric, and inference time.</p> Example <pre><code>from ultralytics.utils.benchmarks import benchmark\n\nbenchmark(model='yolov8n.pt', imgsz=640)\n</code></pre> Source code in <code>ultralytics/utils/benchmarks.py</code> <pre><code>def benchmark(\n    model=WEIGHTS_DIR / \"yolov8n.pt\", data=None, imgsz=160, half=False, int8=False, device=\"cpu\", verbose=False\n):\n    \"\"\"\n    Benchmark a YOLO model across different formats for speed and accuracy.\n\n    Args:\n        model (str | Path | optional): Path to the model file or directory. Default is\n            Path(SETTINGS['weights_dir']) / 'yolov8n.pt'.\n        data (str, optional): Dataset to evaluate on, inherited from TASK2DATA if not passed. Default is None.\n        imgsz (int, optional): Image size for the benchmark. Default is 160.\n        half (bool, optional): Use half-precision for the model if True. Default is False.\n        int8 (bool, optional): Use int8-precision for the model if True. Default is False.\n        device (str, optional): Device to run the benchmark on, either 'cpu' or 'cuda'. Default is 'cpu'.\n        verbose (bool | float | optional): If True or a float, assert benchmarks pass with given metric.\n            Default is False.\n\n    Returns:\n        df (pandas.DataFrame): A pandas DataFrame with benchmark results for each format, including file size,\n            metric, and inference time.\n\n    Example:\n        ```python\n        from ultralytics.utils.benchmarks import benchmark\n\n        benchmark(model='yolov8n.pt', imgsz=640)\n        ```\n    \"\"\"\n\n    import pandas as pd\n\n    pd.options.display.max_columns = 10\n    pd.options.display.width = 120\n    device = select_device(device, verbose=False)\n    if isinstance(model, (str, Path)):\n        model = YOLO(model)\n\n    y = []\n    t0 = time.time()\n    for i, (name, format, suffix, cpu, gpu) in export_formats().iterrows():  # index, (name, format, suffix, CPU, GPU)\n        emoji, filename = \"\u274c\", None  # export defaults\n        try:\n            assert i != 9 or LINUX, \"Edge TPU export only supported on Linux\"\n            if i == 10:\n                assert MACOS or LINUX, \"TF.js export only supported on macOS and Linux\"\n            elif i == 11:\n                assert sys.version_info &lt; (3, 11), \"PaddlePaddle export only supported on Python&lt;=3.10\"\n            if \"cpu\" in device.type:\n                assert cpu, \"inference not supported on CPU\"\n            if \"cuda\" in device.type:\n                assert gpu, \"inference not supported on GPU\"\n\n            # Export\n            if format == \"-\":\n                filename = model.ckpt_path or model.cfg\n                exported_model = model  # PyTorch format\n            else:\n                filename = model.export(imgsz=imgsz, format=format, half=half, int8=int8, device=device, verbose=False)\n                exported_model = YOLO(filename, task=model.task)\n                assert suffix in str(filename), \"export failed\"\n            emoji = \"\u274e\"  # indicates export succeeded\n\n            # Predict\n            assert model.task != \"pose\" or i != 7, \"GraphDef Pose inference is not supported\"\n            assert i not in (9, 10), \"inference not supported\"  # Edge TPU and TF.js are unsupported\n            assert i != 5 or platform.system() == \"Darwin\", \"inference only supported on macOS&gt;=10.13\"  # CoreML\n            exported_model.predict(ASSETS / \"bus.jpg\", imgsz=imgsz, device=device, half=half)\n\n            # Validate\n            data = data or TASK2DATA[model.task]  # task to dataset, i.e. coco8.yaml for task=detect\n            key = TASK2METRIC[model.task]  # task to metric, i.e. metrics/mAP50-95(B) for task=detect\n            results = exported_model.val(\n                data=data, batch=1, imgsz=imgsz, plots=False, device=device, half=half, int8=int8, verbose=False\n            )\n            metric, speed = results.results_dict[key], results.speed[\"inference\"]\n            y.append([name, \"\u2705\", round(file_size(filename), 1), round(metric, 4), round(speed, 2)])\n        except Exception as e:\n            if verbose:\n                assert type(e) is AssertionError, f\"Benchmark failure for {name}: {e}\"\n            LOGGER.warning(f\"ERROR \u274c\ufe0f Benchmark failure for {name}: {e}\")\n            y.append([name, emoji, round(file_size(filename), 1), None, None])  # mAP, t_inference\n\n    # Print results\n    check_yolo(device=device)  # print system info\n    df = pd.DataFrame(y, columns=[\"Format\", \"Status\u2754\", \"Size (MB)\", key, \"Inference time (ms/im)\"])\n\n    name = Path(model.ckpt_path).name\n    s = f\"\\nBenchmarks complete for {name} on {data} at imgsz={imgsz} ({time.time() - t0:.2f}s)\\n{df}\\n\"\n    LOGGER.info(s)\n    with open(\"benchmarks.log\", \"a\", errors=\"ignore\", encoding=\"utf-8\") as f:\n        f.write(s)\n\n    if verbose and isinstance(verbose, float):\n        metrics = df[key].array  # values to compare to floor\n        floor = verbose  # minimum metric floor to pass, i.e. = 0.29 mAP for YOLOv5n\n        assert all(x &gt; floor for x in metrics if pd.notna(x)), f\"Benchmark failure: metric(s) &lt; floor {floor}\"\n\n    return df\n</code></pre>"},{"location":"reference/utils/checks/","title":"Reference for <code>ultralytics/utils/checks.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/checks.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/checks/#ultralytics.utils.checks.parse_requirements","title":"<code>ultralytics.utils.checks.parse_requirements(file_path=ROOT.parent / 'requirements.txt', package='')</code>","text":"<p>Parse a requirements.txt file, ignoring lines that start with '#' and any text after '#'.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>Path to the requirements.txt file.</p> <code>parent / 'requirements.txt'</code> <code>package</code> <code>str</code> <p>Python package to use instead of requirements.txt file, i.e. package='ultralytics'.</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Dict[str, str]]</code> <p>List of parsed requirements as dictionaries with <code>name</code> and <code>specifier</code> keys.</p> Example <pre><code>from ultralytics.utils.checks import parse_requirements\n\nparse_requirements(package='ultralytics')\n</code></pre> Source code in <code>ultralytics/utils/checks.py</code> <pre><code>def parse_requirements(file_path=ROOT.parent / \"requirements.txt\", package=\"\"):\n    \"\"\"\n    Parse a requirements.txt file, ignoring lines that start with '#' and any text after '#'.\n\n    Args:\n        file_path (Path): Path to the requirements.txt file.\n        package (str, optional): Python package to use instead of requirements.txt file, i.e. package='ultralytics'.\n\n    Returns:\n        (List[Dict[str, str]]): List of parsed requirements as dictionaries with `name` and `specifier` keys.\n\n    Example:\n        ```python\n        from ultralytics.utils.checks import parse_requirements\n\n        parse_requirements(package='ultralytics')\n        ```\n    \"\"\"\n\n    if package:\n        requires = [x for x in metadata.distribution(package).requires if \"extra == \" not in x]\n    else:\n        requires = Path(file_path).read_text().splitlines()\n\n    requirements = []\n    for line in requires:\n        line = line.strip()\n        if line and not line.startswith(\"#\"):\n            line = line.split(\"#\")[0].strip()  # ignore inline comments\n            match = re.match(r\"([a-zA-Z0-9-_]+)\\s*([&lt;&gt;!=~]+.*)?\", line)\n            if match:\n                requirements.append(SimpleNamespace(name=match[1], specifier=match[2].strip() if match[2] else \"\"))\n\n    return requirements\n</code></pre>"},{"location":"reference/utils/checks/#ultralytics.utils.checks.parse_version","title":"<code>ultralytics.utils.checks.parse_version(version='0.0.0')</code>","text":"<p>Convert a version string to a tuple of integers, ignoring any extra non-numeric string attached to the version. This function replaces deprecated 'pkg_resources.parse_version(v)'.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>Version string, i.e. '2.0.1+cpu'</p> <code>'0.0.0'</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of integers representing the numeric part of the version and the extra string, i.e. (2, 0, 1)</p> Source code in <code>ultralytics/utils/checks.py</code> <pre><code>def parse_version(version=\"0.0.0\") -&gt; tuple:\n    \"\"\"\n    Convert a version string to a tuple of integers, ignoring any extra non-numeric string attached to the version. This\n    function replaces deprecated 'pkg_resources.parse_version(v)'.\n\n    Args:\n        version (str): Version string, i.e. '2.0.1+cpu'\n\n    Returns:\n        (tuple): Tuple of integers representing the numeric part of the version and the extra string, i.e. (2, 0, 1)\n    \"\"\"\n    try:\n        return tuple(map(int, re.findall(r\"\\d+\", version)[:3]))  # '2.0.1+cpu' -&gt; (2, 0, 1)\n    except Exception as e:\n        LOGGER.warning(f\"WARNING \u26a0\ufe0f failure for parse_version({version}), returning (0, 0, 0): {e}\")\n        return 0, 0, 0\n</code></pre>"},{"location":"reference/utils/checks/#ultralytics.utils.checks.is_ascii","title":"<code>ultralytics.utils.checks.is_ascii(s)</code>","text":"<p>Check if a string is composed of only ASCII characters.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>String to be checked.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the string is composed only of ASCII characters, False otherwise.</p> Source code in <code>ultralytics/utils/checks.py</code> <pre><code>def is_ascii(s) -&gt; bool:\n    \"\"\"\n    Check if a string is composed of only ASCII characters.\n\n    Args:\n        s (str): String to be checked.\n\n    Returns:\n        bool: True if the string is composed only of ASCII characters, False otherwise.\n    \"\"\"\n    # Convert list, tuple, None, etc. to string\n    s = str(s)\n\n    # Check if the string is composed of only ASCII characters\n    return all(ord(c) &lt; 128 for c in s)\n</code></pre>"},{"location":"reference/utils/checks/#ultralytics.utils.checks.check_imgsz","title":"<code>ultralytics.utils.checks.check_imgsz(imgsz, stride=32, min_dim=1, max_dim=2, floor=0)</code>","text":"<p>Verify image size is a multiple of the given stride in each dimension. If the image size is not a multiple of the stride, update it to the nearest multiple of the stride that is greater than or equal to the given floor value.</p> <p>Parameters:</p> Name Type Description Default <code>imgsz</code> <code>int | cList[int]</code> <p>Image size.</p> required <code>stride</code> <code>int</code> <p>Stride value.</p> <code>32</code> <code>min_dim</code> <code>int</code> <p>Minimum number of dimensions.</p> <code>1</code> <code>max_dim</code> <code>int</code> <p>Maximum number of dimensions.</p> <code>2</code> <code>floor</code> <code>int</code> <p>Minimum allowed value for image size.</p> <code>0</code> <p>Returns:</p> Type Description <code>List[int]</code> <p>Updated image size.</p> Source code in <code>ultralytics/utils/checks.py</code> <pre><code>def check_imgsz(imgsz, stride=32, min_dim=1, max_dim=2, floor=0):\n    \"\"\"\n    Verify image size is a multiple of the given stride in each dimension. If the image size is not a multiple of the\n    stride, update it to the nearest multiple of the stride that is greater than or equal to the given floor value.\n\n    Args:\n        imgsz (int | cList[int]): Image size.\n        stride (int): Stride value.\n        min_dim (int): Minimum number of dimensions.\n        max_dim (int): Maximum number of dimensions.\n        floor (int): Minimum allowed value for image size.\n\n    Returns:\n        (List[int]): Updated image size.\n    \"\"\"\n    # Convert stride to integer if it is a tensor\n    stride = int(stride.max() if isinstance(stride, torch.Tensor) else stride)\n\n    # Convert image size to list if it is an integer\n    if isinstance(imgsz, int):\n        imgsz = [imgsz]\n    elif isinstance(imgsz, (list, tuple)):\n        imgsz = list(imgsz)\n    else:\n        raise TypeError(\n            f\"'imgsz={imgsz}' is of invalid type {type(imgsz).__name__}. \"\n            f\"Valid imgsz types are int i.e. 'imgsz=640' or list i.e. 'imgsz=[640,640]'\"\n        )\n\n    # Apply max_dim\n    if len(imgsz) &gt; max_dim:\n        msg = (\n            \"'train' and 'val' imgsz must be an integer, while 'predict' and 'export' imgsz may be a [h, w] list \"\n            \"or an integer, i.e. 'yolo export imgsz=640,480' or 'yolo export imgsz=640'\"\n        )\n        if max_dim != 1:\n            raise ValueError(f\"imgsz={imgsz} is not a valid image size. {msg}\")\n        LOGGER.warning(f\"WARNING \u26a0\ufe0f updating to 'imgsz={max(imgsz)}'. {msg}\")\n        imgsz = [max(imgsz)]\n    # Make image size a multiple of the stride\n    sz = [max(math.ceil(x / stride) * stride, floor) for x in imgsz]\n\n    # Print warning message if image size was updated\n    if sz != imgsz:\n        LOGGER.warning(f\"WARNING \u26a0\ufe0f imgsz={imgsz} must be multiple of max stride {stride}, updating to {sz}\")\n\n    # Add missing dimensions if necessary\n    sz = [sz[0], sz[0]] if min_dim == 2 and len(sz) == 1 else sz[0] if min_dim == 1 and len(sz) == 1 else sz\n\n    return sz\n</code></pre>"},{"location":"reference/utils/checks/#ultralytics.utils.checks.check_version","title":"<code>ultralytics.utils.checks.check_version(current='0.0.0', required='0.0.0', name='version', hard=False, verbose=False, msg='')</code>","text":"<p>Check current version against the required version or range.</p> <p>Parameters:</p> Name Type Description Default <code>current</code> <code>str</code> <p>Current version or package name to get version from.</p> <code>'0.0.0'</code> <code>required</code> <code>str</code> <p>Required version or range (in pip-style format).</p> <code>'0.0.0'</code> <code>name</code> <code>str</code> <p>Name to be used in warning message.</p> <code>'version'</code> <code>hard</code> <code>bool</code> <p>If True, raise an AssertionError if the requirement is not met.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>If True, print warning message if requirement is not met.</p> <code>False</code> <code>msg</code> <code>str</code> <p>Extra message to display if verbose.</p> <code>''</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if requirement is met, False otherwise.</p> Example <pre><code># Check if current version is exactly 22.04\ncheck_version(current='22.04', required='==22.04')\n\n# Check if current version is greater than or equal to 22.04\ncheck_version(current='22.10', required='22.04')  # assumes '&gt;=' inequality if none passed\n\n# Check if current version is less than or equal to 22.04\ncheck_version(current='22.04', required='&lt;=22.04')\n\n# Check if current version is between 20.04 (inclusive) and 22.04 (exclusive)\ncheck_version(current='21.10', required='&gt;20.04,&lt;22.04')\n</code></pre> Source code in <code>ultralytics/utils/checks.py</code> <pre><code>def check_version(\n    current: str = \"0.0.0\",\n    required: str = \"0.0.0\",\n    name: str = \"version\",\n    hard: bool = False,\n    verbose: bool = False,\n    msg: str = \"\",\n) -&gt; bool:\n    \"\"\"\n    Check current version against the required version or range.\n\n    Args:\n        current (str): Current version or package name to get version from.\n        required (str): Required version or range (in pip-style format).\n        name (str, optional): Name to be used in warning message.\n        hard (bool, optional): If True, raise an AssertionError if the requirement is not met.\n        verbose (bool, optional): If True, print warning message if requirement is not met.\n        msg (str, optional): Extra message to display if verbose.\n\n    Returns:\n        (bool): True if requirement is met, False otherwise.\n\n    Example:\n        ```python\n        # Check if current version is exactly 22.04\n        check_version(current='22.04', required='==22.04')\n\n        # Check if current version is greater than or equal to 22.04\n        check_version(current='22.10', required='22.04')  # assumes '&gt;=' inequality if none passed\n\n        # Check if current version is less than or equal to 22.04\n        check_version(current='22.04', required='&lt;=22.04')\n\n        # Check if current version is between 20.04 (inclusive) and 22.04 (exclusive)\n        check_version(current='21.10', required='&gt;20.04,&lt;22.04')\n        ```\n    \"\"\"\n    if not current:  # if current is '' or None\n        LOGGER.warning(f\"WARNING \u26a0\ufe0f invalid check_version({current}, {required}) requested, please check values.\")\n        return True\n    elif not current[0].isdigit():  # current is package name rather than version string, i.e. current='ultralytics'\n        try:\n            name = current  # assigned package name to 'name' arg\n            current = metadata.version(current)  # get version string from package name\n        except metadata.PackageNotFoundError:\n            if hard:\n                raise ModuleNotFoundError(emojis(f\"WARNING \u26a0\ufe0f {current} package is required but not installed\"))\n            else:\n                return False\n\n    if not required:  # if required is '' or None\n        return True\n\n    op = \"\"\n    version = \"\"\n    result = True\n    c = parse_version(current)  # '1.2.3' -&gt; (1, 2, 3)\n    for r in required.strip(\",\").split(\",\"):\n        op, version = re.match(r\"([^0-9]*)([\\d.]+)\", r).groups()  # split '&gt;=22.04' -&gt; ('&gt;=', '22.04')\n        v = parse_version(version)  # '1.2.3' -&gt; (1, 2, 3)\n        if op == \"==\" and c != v:\n            result = False\n        elif op == \"!=\" and c == v:\n            result = False\n        elif op in (\"&gt;=\", \"\") and not (c &gt;= v):  # if no constraint passed assume '&gt;=required'\n            result = False\n        elif op == \"&lt;=\" and not (c &lt;= v):\n            result = False\n        elif op == \"&gt;\" and not (c &gt; v):\n            result = False\n        elif op == \"&lt;\" and not (c &lt; v):\n            result = False\n    if not result:\n        warning = f\"WARNING \u26a0\ufe0f {name}{op}{version} is required, but {name}=={current} is currently installed {msg}\"\n        if hard:\n            raise ModuleNotFoundError(emojis(warning))  # assert version requirements met\n        if verbose:\n            LOGGER.warning(warning)\n    return result\n</code></pre>"},{"location":"reference/utils/checks/#ultralytics.utils.checks.check_latest_pypi_version","title":"<code>ultralytics.utils.checks.check_latest_pypi_version(package_name='ultralytics')</code>","text":"<p>Returns the latest version of a PyPI package without downloading or installing it.</p> <p>Parameters:</p> Name Type Description Default <code>package_name</code> <code>str</code> <p>The name of the package to find the latest version for.</p> <code>'ultralytics'</code> <p>Returns:</p> Type Description <code>str</code> <p>The latest version of the package.</p> Source code in <code>ultralytics/utils/checks.py</code> <pre><code>def check_latest_pypi_version(package_name=\"ultralytics\"):\n    \"\"\"\n    Returns the latest version of a PyPI package without downloading or installing it.\n\n    Parameters:\n        package_name (str): The name of the package to find the latest version for.\n\n    Returns:\n        (str): The latest version of the package.\n    \"\"\"\n    with contextlib.suppress(Exception):\n        requests.packages.urllib3.disable_warnings()  # Disable the InsecureRequestWarning\n        response = requests.get(f\"https://pypi.org/pypi/{package_name}/json\", timeout=3)\n        if response.status_code == 200:\n            return response.json()[\"info\"][\"version\"]\n</code></pre>"},{"location":"reference/utils/checks/#ultralytics.utils.checks.check_pip_update_available","title":"<code>ultralytics.utils.checks.check_pip_update_available()</code>","text":"<p>Checks if a new version of the ultralytics package is available on PyPI.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if an update is available, False otherwise.</p> Source code in <code>ultralytics/utils/checks.py</code> <pre><code>def check_pip_update_available():\n    \"\"\"\n    Checks if a new version of the ultralytics package is available on PyPI.\n\n    Returns:\n        (bool): True if an update is available, False otherwise.\n    \"\"\"\n    if ONLINE and is_pip_package():\n        with contextlib.suppress(Exception):\n            from ultralytics import __version__\n\n            latest = check_latest_pypi_version()\n            if check_version(__version__, f\"&lt;{latest}\"):  # check if current version is &lt; latest version\n                LOGGER.info(\n                    f\"New https://pypi.org/project/ultralytics/{latest} available \ud83d\ude03 \"\n                    f\"Update with 'pip install -U ultralytics'\"\n                )\n                return True\n    return False\n</code></pre>"},{"location":"reference/utils/checks/#ultralytics.utils.checks.check_font","title":"<code>ultralytics.utils.checks.check_font(font='Arial.ttf')</code>","text":"<p>Find font locally or download to user's configuration directory if it does not already exist.</p> <p>Parameters:</p> Name Type Description Default <code>font</code> <code>str</code> <p>Path or name of font.</p> <code>'Arial.ttf'</code> <p>Returns:</p> Name Type Description <code>file</code> <code>Path</code> <p>Resolved font file path.</p> Source code in <code>ultralytics/utils/checks.py</code> <pre><code>@ThreadingLocked()\ndef check_font(font=\"Arial.ttf\"):\n    \"\"\"\n    Find font locally or download to user's configuration directory if it does not already exist.\n\n    Args:\n        font (str): Path or name of font.\n\n    Returns:\n        file (Path): Resolved font file path.\n    \"\"\"\n    name = Path(font).name\n\n    # Check USER_CONFIG_DIR\n    file = USER_CONFIG_DIR / name\n    if file.exists():\n        return file\n\n    # Check system fonts\n    matches = [s for s in font_manager.findSystemFonts() if font in s]\n    if any(matches):\n        return matches[0]\n\n    # Download to USER_CONFIG_DIR if missing\n    url = f\"https://ultralytics.com/assets/{name}\"\n    if downloads.is_url(url):\n        downloads.safe_download(url=url, file=file)\n        return file\n</code></pre>"},{"location":"reference/utils/checks/#ultralytics.utils.checks.check_python","title":"<code>ultralytics.utils.checks.check_python(minimum='3.8.0')</code>","text":"<p>Check current python version against the required minimum version.</p> <p>Parameters:</p> Name Type Description Default <code>minimum</code> <code>str</code> <p>Required minimum version of python.</p> <code>'3.8.0'</code> <p>Returns:</p> Type Description <code>bool</code> <p>None</p> Source code in <code>ultralytics/utils/checks.py</code> <pre><code>def check_python(minimum: str = \"3.8.0\") -&gt; bool:\n    \"\"\"\n    Check current python version against the required minimum version.\n\n    Args:\n        minimum (str): Required minimum version of python.\n\n    Returns:\n        None\n    \"\"\"\n    return check_version(platform.python_version(), minimum, name=\"Python \", hard=True)\n</code></pre>"},{"location":"reference/utils/checks/#ultralytics.utils.checks.check_requirements","title":"<code>ultralytics.utils.checks.check_requirements(requirements=ROOT.parent / 'requirements.txt', exclude=(), install=True, cmds='')</code>","text":"<p>Check if installed dependencies meet YOLOv8 requirements and attempt to auto-update if needed.</p> <p>Parameters:</p> Name Type Description Default <code>requirements</code> <code>Union[Path, str, List[str]]</code> <p>Path to a requirements.txt file, a single package requirement as a string, or a list of package requirements as strings.</p> <code>parent / 'requirements.txt'</code> <code>exclude</code> <code>Tuple[str]</code> <p>Tuple of package names to exclude from checking.</p> <code>()</code> <code>install</code> <code>bool</code> <p>If True, attempt to auto-update packages that don't meet requirements.</p> <code>True</code> <code>cmds</code> <code>str</code> <p>Additional commands to pass to the pip install command when auto-updating.</p> <code>''</code> Example <pre><code>from ultralytics.utils.checks import check_requirements\n\n# Check a requirements.txt file\ncheck_requirements('path/to/requirements.txt')\n\n# Check a single package\ncheck_requirements('ultralytics&gt;=8.0.0')\n\n# Check multiple packages\ncheck_requirements(['numpy', 'ultralytics&gt;=8.0.0'])\n</code></pre> Source code in <code>ultralytics/utils/checks.py</code> <pre><code>@TryExcept()\ndef check_requirements(requirements=ROOT.parent / \"requirements.txt\", exclude=(), install=True, cmds=\"\"):\n    \"\"\"\n    Check if installed dependencies meet YOLOv8 requirements and attempt to auto-update if needed.\n\n    Args:\n        requirements (Union[Path, str, List[str]]): Path to a requirements.txt file, a single package requirement as a\n            string, or a list of package requirements as strings.\n        exclude (Tuple[str]): Tuple of package names to exclude from checking.\n        install (bool): If True, attempt to auto-update packages that don't meet requirements.\n        cmds (str): Additional commands to pass to the pip install command when auto-updating.\n\n    Example:\n        ```python\n        from ultralytics.utils.checks import check_requirements\n\n        # Check a requirements.txt file\n        check_requirements('path/to/requirements.txt')\n\n        # Check a single package\n        check_requirements('ultralytics&gt;=8.0.0')\n\n        # Check multiple packages\n        check_requirements(['numpy', 'ultralytics&gt;=8.0.0'])\n        ```\n    \"\"\"\n\n    prefix = colorstr(\"red\", \"bold\", \"requirements:\")\n    check_python()  # check python version\n    check_torchvision()  # check torch-torchvision compatibility\n    if isinstance(requirements, Path):  # requirements.txt file\n        file = requirements.resolve()\n        assert file.exists(), f\"{prefix} {file} not found, check failed.\"\n        requirements = [f\"{x.name}{x.specifier}\" for x in parse_requirements(file) if x.name not in exclude]\n    elif isinstance(requirements, str):\n        requirements = [requirements]\n\n    pkgs = []\n    for r in requirements:\n        r_stripped = r.split(\"/\")[-1].replace(\".git\", \"\")  # replace git+https://org/repo.git -&gt; 'repo'\n        match = re.match(r\"([a-zA-Z0-9-_]+)([&lt;&gt;!=~]+.*)?\", r_stripped)\n        name, required = match[1], match[2].strip() if match[2] else \"\"\n        try:\n            assert check_version(metadata.version(name), required)  # exception if requirements not met\n        except (AssertionError, metadata.PackageNotFoundError):\n            pkgs.append(r)\n\n    s = \" \".join(f'\"{x}\"' for x in pkgs)  # console string\n    if s:\n        if install and AUTOINSTALL:  # check environment variable\n            n = len(pkgs)  # number of packages updates\n            LOGGER.info(f\"{prefix} Ultralytics requirement{'s' * (n &gt; 1)} {pkgs} not found, attempting AutoUpdate...\")\n            try:\n                t = time.time()\n                assert is_online(), \"AutoUpdate skipped (offline)\"\n                LOGGER.info(subprocess.check_output(f\"pip install --no-cache {s} {cmds}\", shell=True).decode())\n                dt = time.time() - t\n                LOGGER.info(\n                    f\"{prefix} AutoUpdate success \u2705 {dt:.1f}s, installed {n} package{'s' * (n &gt; 1)}: {pkgs}\\n\"\n                    f\"{prefix} \u26a0\ufe0f {colorstr('bold', 'Restart runtime or rerun command for updates to take effect')}\\n\"\n                )\n            except Exception as e:\n                LOGGER.warning(f\"{prefix} \u274c {e}\")\n                return False\n        else:\n            return False\n\n    return True\n</code></pre>"},{"location":"reference/utils/checks/#ultralytics.utils.checks.check_torchvision","title":"<code>ultralytics.utils.checks.check_torchvision()</code>","text":"<p>Checks the installed versions of PyTorch and Torchvision to ensure they're compatible.</p> <p>This function checks the installed versions of PyTorch and Torchvision, and warns if they're incompatible according to the provided compatibility table based on: https://github.com/pytorch/vision#installation.</p> <p>The compatibility table is a dictionary where the keys are PyTorch versions and the values are lists of compatible Torchvision versions.</p> Source code in <code>ultralytics/utils/checks.py</code> <pre><code>def check_torchvision():\n    \"\"\"\n    Checks the installed versions of PyTorch and Torchvision to ensure they're compatible.\n\n    This function checks the installed versions of PyTorch and Torchvision, and warns if they're incompatible according\n    to the provided compatibility table based on:\n    https://github.com/pytorch/vision#installation.\n\n    The compatibility table is a dictionary where the keys are PyTorch versions and the values are lists of compatible\n    Torchvision versions.\n    \"\"\"\n\n    import torchvision\n\n    # Compatibility table\n    compatibility_table = {\"2.0\": [\"0.15\"], \"1.13\": [\"0.14\"], \"1.12\": [\"0.13\"]}\n\n    # Extract only the major and minor versions\n    v_torch = \".\".join(torch.__version__.split(\"+\")[0].split(\".\")[:2])\n    v_torchvision = \".\".join(torchvision.__version__.split(\"+\")[0].split(\".\")[:2])\n\n    if v_torch in compatibility_table:\n        compatible_versions = compatibility_table[v_torch]\n        if all(v_torchvision != v for v in compatible_versions):\n            print(\n                f\"WARNING \u26a0\ufe0f torchvision=={v_torchvision} is incompatible with torch=={v_torch}.\\n\"\n                f\"Run 'pip install torchvision=={compatible_versions[0]}' to fix torchvision or \"\n                \"'pip install -U torch torchvision' to update both.\\n\"\n                \"For a full compatibility table see https://github.com/pytorch/vision#installation\"\n            )\n</code></pre>"},{"location":"reference/utils/checks/#ultralytics.utils.checks.check_suffix","title":"<code>ultralytics.utils.checks.check_suffix(file='yolov8n.pt', suffix='.pt', msg='')</code>","text":"<p>Check file(s) for acceptable suffix.</p> Source code in <code>ultralytics/utils/checks.py</code> <pre><code>def check_suffix(file=\"yolov8n.pt\", suffix=\".pt\", msg=\"\"):\n    \"\"\"Check file(s) for acceptable suffix.\"\"\"\n    if file and suffix:\n        if isinstance(suffix, str):\n            suffix = (suffix,)\n        for f in file if isinstance(file, (list, tuple)) else [file]:\n            s = Path(f).suffix.lower().strip()  # file suffix\n            if len(s):\n                assert s in suffix, f\"{msg}{f} acceptable suffix is {suffix}, not {s}\"\n</code></pre>"},{"location":"reference/utils/checks/#ultralytics.utils.checks.check_yolov5u_filename","title":"<code>ultralytics.utils.checks.check_yolov5u_filename(file, verbose=True)</code>","text":"<p>Replace legacy YOLOv5 filenames with updated YOLOv5u filenames.</p> Source code in <code>ultralytics/utils/checks.py</code> <pre><code>def check_yolov5u_filename(file: str, verbose: bool = True):\n    \"\"\"Replace legacy YOLOv5 filenames with updated YOLOv5u filenames.\"\"\"\n    if \"yolov3\" in file or \"yolov5\" in file:\n        if \"u.yaml\" in file:\n            file = file.replace(\"u.yaml\", \".yaml\")  # i.e. yolov5nu.yaml -&gt; yolov5n.yaml\n        elif \".pt\" in file and \"u\" not in file:\n            original_file = file\n            file = re.sub(r\"(.*yolov5([nsmlx]))\\.pt\", \"\\\\1u.pt\", file)  # i.e. yolov5n.pt -&gt; yolov5nu.pt\n            file = re.sub(r\"(.*yolov5([nsmlx])6)\\.pt\", \"\\\\1u.pt\", file)  # i.e. yolov5n6.pt -&gt; yolov5n6u.pt\n            file = re.sub(r\"(.*yolov3(|-tiny|-spp))\\.pt\", \"\\\\1u.pt\", file)  # i.e. yolov3-spp.pt -&gt; yolov3-sppu.pt\n            if file != original_file and verbose:\n                LOGGER.info(\n                    f\"PRO TIP \ud83d\udca1 Replace 'model={original_file}' with new 'model={file}'.\\nYOLOv5 'u' models are \"\n                    f\"trained with https://github.com/ultralytics/ultralytics and feature improved performance vs \"\n                    f\"standard YOLOv5 models trained with https://github.com/ultralytics/yolov5.\\n\"\n                )\n    return file\n</code></pre>"},{"location":"reference/utils/checks/#ultralytics.utils.checks.check_model_file_from_stem","title":"<code>ultralytics.utils.checks.check_model_file_from_stem(model='yolov8n')</code>","text":"<p>Return a model filename from a valid model stem.</p> Source code in <code>ultralytics/utils/checks.py</code> <pre><code>def check_model_file_from_stem(model=\"yolov8n\"):\n    \"\"\"Return a model filename from a valid model stem.\"\"\"\n    if model and not Path(model).suffix and Path(model).stem in downloads.GITHUB_ASSETS_STEMS:\n        return Path(model).with_suffix(\".pt\")  # add suffix, i.e. yolov8n -&gt; yolov8n.pt\n    else:\n        return model\n</code></pre>"},{"location":"reference/utils/checks/#ultralytics.utils.checks.check_file","title":"<code>ultralytics.utils.checks.check_file(file, suffix='', download=True, hard=True)</code>","text":"<p>Search/download file (if necessary) and return path.</p> Source code in <code>ultralytics/utils/checks.py</code> <pre><code>def check_file(file, suffix=\"\", download=True, hard=True):\n    \"\"\"Search/download file (if necessary) and return path.\"\"\"\n    check_suffix(file, suffix)  # optional\n    file = str(file).strip()  # convert to string and strip spaces\n    file = check_yolov5u_filename(file)  # yolov5n -&gt; yolov5nu\n    if (\n        not file\n        or (\"://\" not in file and Path(file).exists())  # '://' check required in Windows Python&lt;3.10\n        or file.lower().startswith(\"grpc://\")\n    ):  # file exists or gRPC Triton images\n        return file\n    elif download and file.lower().startswith((\"https://\", \"http://\", \"rtsp://\", \"rtmp://\", \"tcp://\")):  # download\n        url = file  # warning: Pathlib turns :// -&gt; :/\n        file = url2file(file)  # '%2F' to '/', split https://url.com/file.txt?auth\n        if Path(file).exists():\n            LOGGER.info(f\"Found {clean_url(url)} locally at {file}\")  # file already exists\n        else:\n            downloads.safe_download(url=url, file=file, unzip=False)\n        return file\n    else:  # search\n        files = glob.glob(str(ROOT / \"cfg\" / \"**\" / file), recursive=True)  # find file\n        if not files and hard:\n            raise FileNotFoundError(f\"'{file}' does not exist\")\n        elif len(files) &gt; 1 and hard:\n            raise FileNotFoundError(f\"Multiple files match '{file}', specify exact path: {files}\")\n        return files[0] if len(files) else []  # return file\n</code></pre>"},{"location":"reference/utils/checks/#ultralytics.utils.checks.check_yaml","title":"<code>ultralytics.utils.checks.check_yaml(file, suffix=('.yaml', '.yml'), hard=True)</code>","text":"<p>Search/download YAML file (if necessary) and return path, checking suffix.</p> Source code in <code>ultralytics/utils/checks.py</code> <pre><code>def check_yaml(file, suffix=(\".yaml\", \".yml\"), hard=True):\n    \"\"\"Search/download YAML file (if necessary) and return path, checking suffix.\"\"\"\n    return check_file(file, suffix, hard=hard)\n</code></pre>"},{"location":"reference/utils/checks/#ultralytics.utils.checks.check_is_path_safe","title":"<code>ultralytics.utils.checks.check_is_path_safe(basedir, path)</code>","text":"<p>Check if the resolved path is under the intended directory to prevent path traversal.</p> <p>Parameters:</p> Name Type Description Default <code>basedir</code> <code>Path | str</code> <p>The intended directory.</p> required <code>path</code> <code>Path | str</code> <p>The path to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the path is safe, False otherwise.</p> Source code in <code>ultralytics/utils/checks.py</code> <pre><code>def check_is_path_safe(basedir, path):\n    \"\"\"\n    Check if the resolved path is under the intended directory to prevent path traversal.\n\n    Args:\n        basedir (Path | str): The intended directory.\n        path (Path | str): The path to check.\n\n    Returns:\n        (bool): True if the path is safe, False otherwise.\n    \"\"\"\n    base_dir_resolved = Path(basedir).resolve()\n    path_resolved = Path(path).resolve()\n\n    return path_resolved.is_file() and path_resolved.parts[: len(base_dir_resolved.parts)] == base_dir_resolved.parts\n</code></pre>"},{"location":"reference/utils/checks/#ultralytics.utils.checks.check_imshow","title":"<code>ultralytics.utils.checks.check_imshow(warn=False)</code>","text":"<p>Check if environment supports image displays.</p> Source code in <code>ultralytics/utils/checks.py</code> <pre><code>def check_imshow(warn=False):\n    \"\"\"Check if environment supports image displays.\"\"\"\n    try:\n        if LINUX:\n            assert \"DISPLAY\" in os.environ and not is_docker() and not is_colab() and not is_kaggle()\n        cv2.imshow(\"test\", np.zeros((8, 8, 3), dtype=np.uint8))  # show a small 8-pixel image\n        cv2.waitKey(1)\n        cv2.destroyAllWindows()\n        cv2.waitKey(1)\n        return True\n    except Exception as e:\n        if warn:\n            LOGGER.warning(f\"WARNING \u26a0\ufe0f Environment does not support cv2.imshow() or PIL Image.show()\\n{e}\")\n        return False\n</code></pre>"},{"location":"reference/utils/checks/#ultralytics.utils.checks.check_yolo","title":"<code>ultralytics.utils.checks.check_yolo(verbose=True, device='')</code>","text":"<p>Return a human-readable YOLO software and hardware summary.</p> Source code in <code>ultralytics/utils/checks.py</code> <pre><code>def check_yolo(verbose=True, device=\"\"):\n    \"\"\"Return a human-readable YOLO software and hardware summary.\"\"\"\n    import psutil\n\n    from ultralytics.utils.torch_utils import select_device\n\n    if is_jupyter():\n        if check_requirements(\"wandb\", install=False):\n            os.system(\"pip uninstall -y wandb\")  # uninstall wandb: unwanted account creation prompt with infinite hang\n        if is_colab():\n            shutil.rmtree(\"sample_data\", ignore_errors=True)  # remove colab /sample_data directory\n\n    if verbose:\n        # System info\n        gib = 1 &lt;&lt; 30  # bytes per GiB\n        ram = psutil.virtual_memory().total\n        total, used, free = shutil.disk_usage(\"/\")\n        s = f\"({os.cpu_count()} CPUs, {ram / gib:.1f} GB RAM, {(total - free) / gib:.1f}/{total / gib:.1f} GB disk)\"\n        with contextlib.suppress(Exception):  # clear display if ipython is installed\n            from IPython import display\n\n            display.clear_output()\n    else:\n        s = \"\"\n\n    select_device(device=device, newline=False)\n    LOGGER.info(f\"Setup complete \u2705 {s}\")\n</code></pre>"},{"location":"reference/utils/checks/#ultralytics.utils.checks.collect_system_info","title":"<code>ultralytics.utils.checks.collect_system_info()</code>","text":"<p>Collect and print relevant system information including OS, Python, RAM, CPU, and CUDA.</p> Source code in <code>ultralytics/utils/checks.py</code> <pre><code>def collect_system_info():\n    \"\"\"Collect and print relevant system information including OS, Python, RAM, CPU, and CUDA.\"\"\"\n\n    import psutil\n\n    from ultralytics.utils import ENVIRONMENT, is_git_dir\n    from ultralytics.utils.torch_utils import get_cpu_info\n\n    ram_info = psutil.virtual_memory().total / (1024**3)  # Convert bytes to GB\n    check_yolo()\n    LOGGER.info(\n        f\"\\n{'OS':&lt;20}{platform.platform()}\\n\"\n        f\"{'Environment':&lt;20}{ENVIRONMENT}\\n\"\n        f\"{'Python':&lt;20}{sys.version.split()[0]}\\n\"\n        f\"{'Install':&lt;20}{'git' if is_git_dir() else 'pip' if is_pip_package() else 'other'}\\n\"\n        f\"{'RAM':&lt;20}{ram_info:.2f} GB\\n\"\n        f\"{'CPU':&lt;20}{get_cpu_info()}\\n\"\n        f\"{'CUDA':&lt;20}{torch.version.cuda if torch and torch.cuda.is_available() else None}\\n\"\n    )\n\n    for r in parse_requirements(package=\"ultralytics\"):\n        try:\n            current = metadata.version(r.name)\n            is_met = \"\u2705 \" if check_version(current, str(r.specifier), hard=True) else \"\u274c \"\n        except metadata.PackageNotFoundError:\n            current = \"(not installed)\"\n            is_met = \"\u274c \"\n        LOGGER.info(f\"{r.name:&lt;20}{is_met}{current}{r.specifier}\")\n\n    if is_github_action_running():\n        LOGGER.info(\n            f\"\\nRUNNER_OS: {os.getenv('RUNNER_OS')}\\n\"\n            f\"GITHUB_EVENT_NAME: {os.getenv('GITHUB_EVENT_NAME')}\\n\"\n            f\"GITHUB_WORKFLOW: {os.getenv('GITHUB_WORKFLOW')}\\n\"\n            f\"GITHUB_ACTOR: {os.getenv('GITHUB_ACTOR')}\\n\"\n            f\"GITHUB_REPOSITORY: {os.getenv('GITHUB_REPOSITORY')}\\n\"\n            f\"GITHUB_REPOSITORY_OWNER: {os.getenv('GITHUB_REPOSITORY_OWNER')}\\n\"\n        )\n</code></pre>"},{"location":"reference/utils/checks/#ultralytics.utils.checks.check_amp","title":"<code>ultralytics.utils.checks.check_amp(model)</code>","text":"<p>This function checks the PyTorch Automatic Mixed Precision (AMP) functionality of a YOLOv8 model. If the checks fail, it means there are anomalies with AMP on the system that may cause NaN losses or zero-mAP results, so AMP will be disabled during training.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Module</code> <p>A YOLOv8 model instance.</p> required Example <pre><code>from ultralytics import YOLO\nfrom ultralytics.utils.checks import check_amp\n\nmodel = YOLO('yolov8n.pt').model.cuda()\ncheck_amp(model)\n</code></pre> <p>Returns:</p> Type Description <code>bool</code> <p>Returns True if the AMP functionality works correctly with YOLOv8 model, else False.</p> Source code in <code>ultralytics/utils/checks.py</code> <pre><code>def check_amp(model):\n    \"\"\"\n    This function checks the PyTorch Automatic Mixed Precision (AMP) functionality of a YOLOv8 model. If the checks\n    fail, it means there are anomalies with AMP on the system that may cause NaN losses or zero-mAP results, so AMP will\n    be disabled during training.\n\n    Args:\n        model (nn.Module): A YOLOv8 model instance.\n\n    Example:\n        ```python\n        from ultralytics import YOLO\n        from ultralytics.utils.checks import check_amp\n\n        model = YOLO('yolov8n.pt').model.cuda()\n        check_amp(model)\n        ```\n\n    Returns:\n        (bool): Returns True if the AMP functionality works correctly with YOLOv8 model, else False.\n    \"\"\"\n    device = next(model.parameters()).device  # get model device\n    if device.type in (\"cpu\", \"mps\"):\n        return False  # AMP only used on CUDA devices\n\n    def amp_allclose(m, im):\n        \"\"\"All close FP32 vs AMP results.\"\"\"\n        a = m(im, device=device, verbose=False)[0].boxes.data  # FP32 inference\n        with torch.cuda.amp.autocast(True):\n            b = m(im, device=device, verbose=False)[0].boxes.data  # AMP inference\n        del m\n        return a.shape == b.shape and torch.allclose(a, b.float(), atol=0.5)  # close to 0.5 absolute tolerance\n\n    im = ASSETS / \"bus.jpg\"  # image to check\n    prefix = colorstr(\"AMP: \")\n    LOGGER.info(f\"{prefix}running Automatic Mixed Precision (AMP) checks with YOLOv8n...\")\n    warning_msg = \"Setting 'amp=True'. If you experience zero-mAP or NaN losses you can disable AMP with amp=False.\"\n    try:\n        from ultralytics import YOLO\n\n        assert amp_allclose(YOLO(\"yolov8n.pt\"), im)\n        LOGGER.info(f\"{prefix}checks passed \u2705\")\n    except ConnectionError:\n        LOGGER.warning(f\"{prefix}checks skipped \u26a0\ufe0f, offline and unable to download YOLOv8n. {warning_msg}\")\n    except (AttributeError, ModuleNotFoundError):\n        LOGGER.warning(\n            f\"{prefix}checks skipped \u26a0\ufe0f. \"\n            f\"Unable to load YOLOv8n due to possible Ultralytics package modifications. {warning_msg}\"\n        )\n    except AssertionError:\n        LOGGER.warning(\n            f\"{prefix}checks failed \u274c. Anomalies were detected with AMP on your system that may lead to \"\n            f\"NaN losses or zero-mAP results, so AMP will be disabled during training.\"\n        )\n        return False\n    return True\n</code></pre>"},{"location":"reference/utils/checks/#ultralytics.utils.checks.git_describe","title":"<code>ultralytics.utils.checks.git_describe(path=ROOT)</code>","text":"<p>Return human-readable git description, i.e. v5.0-5-g3e25f1e https://git-scm.com/docs/git-describe.</p> Source code in <code>ultralytics/utils/checks.py</code> <pre><code>def git_describe(path=ROOT):  # path must be a directory\n    \"\"\"Return human-readable git description, i.e. v5.0-5-g3e25f1e https://git-scm.com/docs/git-describe.\"\"\"\n    with contextlib.suppress(Exception):\n        return subprocess.check_output(f\"git -C {path} describe --tags --long --always\", shell=True).decode()[:-1]\n    return \"\"\n</code></pre>"},{"location":"reference/utils/checks/#ultralytics.utils.checks.print_args","title":"<code>ultralytics.utils.checks.print_args(args=None, show_file=True, show_func=False)</code>","text":"<p>Print function arguments (optional args dict).</p> Source code in <code>ultralytics/utils/checks.py</code> <pre><code>def print_args(args: Optional[dict] = None, show_file=True, show_func=False):\n    \"\"\"Print function arguments (optional args dict).\"\"\"\n\n    def strip_auth(v):\n        \"\"\"Clean longer Ultralytics HUB URLs by stripping potential authentication information.\"\"\"\n        return clean_url(v) if (isinstance(v, str) and v.startswith(\"http\") and len(v) &gt; 100) else v\n\n    x = inspect.currentframe().f_back  # previous frame\n    file, _, func, _, _ = inspect.getframeinfo(x)\n    if args is None:  # get args automatically\n        args, _, _, frm = inspect.getargvalues(x)\n        args = {k: v for k, v in frm.items() if k in args}\n    try:\n        file = Path(file).resolve().relative_to(ROOT).with_suffix(\"\")\n    except ValueError:\n        file = Path(file).stem\n    s = (f\"{file}: \" if show_file else \"\") + (f\"{func}: \" if show_func else \"\")\n    LOGGER.info(colorstr(s) + \", \".join(f\"{k}={strip_auth(v)}\" for k, v in args.items()))\n</code></pre>"},{"location":"reference/utils/checks/#ultralytics.utils.checks.cuda_device_count","title":"<code>ultralytics.utils.checks.cuda_device_count()</code>","text":"<p>Get the number of NVIDIA GPUs available in the environment.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of NVIDIA GPUs available.</p> Source code in <code>ultralytics/utils/checks.py</code> <pre><code>def cuda_device_count() -&gt; int:\n    \"\"\"\n    Get the number of NVIDIA GPUs available in the environment.\n\n    Returns:\n        (int): The number of NVIDIA GPUs available.\n    \"\"\"\n    try:\n        # Run the nvidia-smi command and capture its output\n        output = subprocess.check_output(\n            [\"nvidia-smi\", \"--query-gpu=count\", \"--format=csv,noheader,nounits\"], encoding=\"utf-8\"\n        )\n\n        # Take the first line and strip any leading/trailing white space\n        first_line = output.strip().split(\"\\n\")[0]\n\n        return int(first_line)\n    except (subprocess.CalledProcessError, FileNotFoundError, ValueError):\n        # If the command fails, nvidia-smi is not found, or output is not an integer, assume no GPUs are available\n        return 0\n</code></pre>"},{"location":"reference/utils/checks/#ultralytics.utils.checks.cuda_is_available","title":"<code>ultralytics.utils.checks.cuda_is_available()</code>","text":"<p>Check if CUDA is available in the environment.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if one or more NVIDIA GPUs are available, False otherwise.</p> Source code in <code>ultralytics/utils/checks.py</code> <pre><code>def cuda_is_available() -&gt; bool:\n    \"\"\"\n    Check if CUDA is available in the environment.\n\n    Returns:\n        (bool): True if one or more NVIDIA GPUs are available, False otherwise.\n    \"\"\"\n    return cuda_device_count() &gt; 0\n</code></pre>"},{"location":"reference/utils/dist/","title":"Reference for <code>ultralytics/utils/dist.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/dist.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/dist/#ultralytics.utils.dist.find_free_network_port","title":"<code>ultralytics.utils.dist.find_free_network_port()</code>","text":"<p>Finds a free port on localhost.</p> <p>It is useful in single-node training when we don't want to connect to a real main node but have to set the <code>MASTER_PORT</code> environment variable.</p> Source code in <code>ultralytics/utils/dist.py</code> <pre><code>def find_free_network_port() -&gt; int:\n    \"\"\"\n    Finds a free port on localhost.\n\n    It is useful in single-node training when we don't want to connect to a real main node but have to set the\n    `MASTER_PORT` environment variable.\n    \"\"\"\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.bind((\"127.0.0.1\", 0))\n        return s.getsockname()[1]  # port\n</code></pre>"},{"location":"reference/utils/dist/#ultralytics.utils.dist.generate_ddp_file","title":"<code>ultralytics.utils.dist.generate_ddp_file(trainer)</code>","text":"<p>Generates a DDP file and returns its file name.</p> Source code in <code>ultralytics/utils/dist.py</code> <pre><code>def generate_ddp_file(trainer):\n    \"\"\"Generates a DDP file and returns its file name.\"\"\"\n    module, name = f\"{trainer.__class__.__module__}.{trainer.__class__.__name__}\".rsplit(\".\", 1)\n\n    content = f\"\"\"\n# Ultralytics Multi-GPU training temp file (should be automatically deleted after use)\noverrides = {vars(trainer.args)}\n\nif __name__ == \"__main__\":\n    from {module} import {name}\n    from ultralytics.utils import DEFAULT_CFG_DICT\n\n    cfg = DEFAULT_CFG_DICT.copy()\n    cfg.update(save_dir='')   # handle the extra key 'save_dir'\n    trainer = {name}(cfg=cfg, overrides=overrides)\n    results = trainer.train()\n\"\"\"\n    (USER_CONFIG_DIR / \"DDP\").mkdir(exist_ok=True)\n    with tempfile.NamedTemporaryFile(\n        prefix=\"_temp_\",\n        suffix=f\"{id(trainer)}.py\",\n        mode=\"w+\",\n        encoding=\"utf-8\",\n        dir=USER_CONFIG_DIR / \"DDP\",\n        delete=False,\n    ) as file:\n        file.write(content)\n    return file.name\n</code></pre>"},{"location":"reference/utils/dist/#ultralytics.utils.dist.generate_ddp_command","title":"<code>ultralytics.utils.dist.generate_ddp_command(world_size, trainer)</code>","text":"<p>Generates and returns command for distributed training.</p> Source code in <code>ultralytics/utils/dist.py</code> <pre><code>def generate_ddp_command(world_size, trainer):\n    \"\"\"Generates and returns command for distributed training.\"\"\"\n    import __main__  # noqa local import to avoid https://github.com/Lightning-AI/lightning/issues/15218\n\n    if not trainer.resume:\n        shutil.rmtree(trainer.save_dir)  # remove the save_dir\n    file = generate_ddp_file(trainer)\n    dist_cmd = \"torch.distributed.run\" if TORCH_1_9 else \"torch.distributed.launch\"\n    port = find_free_network_port()\n    cmd = [sys.executable, \"-m\", dist_cmd, \"--nproc_per_node\", f\"{world_size}\", \"--master_port\", f\"{port}\", file]\n    return cmd, file\n</code></pre>"},{"location":"reference/utils/dist/#ultralytics.utils.dist.ddp_cleanup","title":"<code>ultralytics.utils.dist.ddp_cleanup(trainer, file)</code>","text":"<p>Delete temp file if created.</p> Source code in <code>ultralytics/utils/dist.py</code> <pre><code>def ddp_cleanup(trainer, file):\n    \"\"\"Delete temp file if created.\"\"\"\n    if f\"{id(trainer)}.py\" in file:  # if temp_file suffix in file\n        os.remove(file)\n</code></pre>"},{"location":"reference/utils/downloads/","title":"Reference for <code>ultralytics/utils/downloads.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/downloads.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/downloads/#ultralytics.utils.downloads.is_url","title":"<code>ultralytics.utils.downloads.is_url(url, check=True)</code>","text":"<p>Validates if the given string is a URL and optionally checks if the URL exists online.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The string to be validated as a URL.</p> required <code>check</code> <code>bool</code> <p>If True, performs an additional check to see if the URL exists online. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>Returns True if the string is a valid URL. If 'check' is True, also returns True if the URL exists online. Returns False otherwise.</p> Example <pre><code>valid = is_url(\"https://www.example.com\")\n</code></pre> Source code in <code>ultralytics/utils/downloads.py</code> <pre><code>def is_url(url, check=True):\n    \"\"\"\n    Validates if the given string is a URL and optionally checks if the URL exists online.\n\n    Args:\n        url (str): The string to be validated as a URL.\n        check (bool, optional): If True, performs an additional check to see if the URL exists online.\n            Defaults to True.\n\n    Returns:\n        (bool): Returns True if the string is a valid URL. If 'check' is True, also returns True if the URL exists online.\n            Returns False otherwise.\n\n    Example:\n        ```python\n        valid = is_url(\"https://www.example.com\")\n        ```\n    \"\"\"\n    with contextlib.suppress(Exception):\n        url = str(url)\n        result = parse.urlparse(url)\n        assert all([result.scheme, result.netloc])  # check if is url\n        if check:\n            with request.urlopen(url) as response:\n                return response.getcode() == 200  # check if exists online\n        return True\n    return False\n</code></pre>"},{"location":"reference/utils/downloads/#ultralytics.utils.downloads.delete_dsstore","title":"<code>ultralytics.utils.downloads.delete_dsstore(path, files_to_delete=('.DS_Store', '__MACOSX'))</code>","text":"<p>Deletes all \".DS_store\" files under a specified directory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The directory path where the \".DS_store\" files should be deleted.</p> required <code>files_to_delete</code> <code>tuple</code> <p>The files to be deleted.</p> <code>('.DS_Store', '__MACOSX')</code> Example <pre><code>from ultralytics.utils.downloads import delete_dsstore\n\ndelete_dsstore('path/to/dir')\n</code></pre> Note <p>\".DS_store\" files are created by the Apple operating system and contain metadata about folders and files. They are hidden system files and can cause issues when transferring files between different operating systems.</p> Source code in <code>ultralytics/utils/downloads.py</code> <pre><code>def delete_dsstore(path, files_to_delete=(\".DS_Store\", \"__MACOSX\")):\n    \"\"\"\n    Deletes all \".DS_store\" files under a specified directory.\n\n    Args:\n        path (str, optional): The directory path where the \".DS_store\" files should be deleted.\n        files_to_delete (tuple): The files to be deleted.\n\n    Example:\n        ```python\n        from ultralytics.utils.downloads import delete_dsstore\n\n        delete_dsstore('path/to/dir')\n        ```\n\n    Note:\n        \".DS_store\" files are created by the Apple operating system and contain metadata about folders and files. They\n        are hidden system files and can cause issues when transferring files between different operating systems.\n    \"\"\"\n    for file in files_to_delete:\n        matches = list(Path(path).rglob(file))\n        LOGGER.info(f\"Deleting {file} files: {matches}\")\n        for f in matches:\n            f.unlink()\n</code></pre>"},{"location":"reference/utils/downloads/#ultralytics.utils.downloads.zip_directory","title":"<code>ultralytics.utils.downloads.zip_directory(directory, compress=True, exclude=('.DS_Store', '__MACOSX'), progress=True)</code>","text":"<p>Zips the contents of a directory, excluding files containing strings in the exclude list. The resulting zip file is named after the directory and placed alongside it.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str | Path</code> <p>The path to the directory to be zipped.</p> required <code>compress</code> <code>bool</code> <p>Whether to compress the files while zipping. Default is True.</p> <code>True</code> <code>exclude</code> <code>tuple</code> <p>A tuple of filename strings to be excluded. Defaults to ('.DS_Store', '__MACOSX').</p> <code>('.DS_Store', '__MACOSX')</code> <code>progress</code> <code>bool</code> <p>Whether to display a progress bar. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Path</code> <p>The path to the resulting zip file.</p> Example <pre><code>from ultralytics.utils.downloads import zip_directory\n\nfile = zip_directory('path/to/dir')\n</code></pre> Source code in <code>ultralytics/utils/downloads.py</code> <pre><code>def zip_directory(directory, compress=True, exclude=(\".DS_Store\", \"__MACOSX\"), progress=True):\n    \"\"\"\n    Zips the contents of a directory, excluding files containing strings in the exclude list. The resulting zip file is\n    named after the directory and placed alongside it.\n\n    Args:\n        directory (str | Path): The path to the directory to be zipped.\n        compress (bool): Whether to compress the files while zipping. Default is True.\n        exclude (tuple, optional): A tuple of filename strings to be excluded. Defaults to ('.DS_Store', '__MACOSX').\n        progress (bool, optional): Whether to display a progress bar. Defaults to True.\n\n    Returns:\n        (Path): The path to the resulting zip file.\n\n    Example:\n        ```python\n        from ultralytics.utils.downloads import zip_directory\n\n        file = zip_directory('path/to/dir')\n        ```\n    \"\"\"\n    from zipfile import ZIP_DEFLATED, ZIP_STORED, ZipFile\n\n    delete_dsstore(directory)\n    directory = Path(directory)\n    if not directory.is_dir():\n        raise FileNotFoundError(f\"Directory '{directory}' does not exist.\")\n\n    # Unzip with progress bar\n    files_to_zip = [f for f in directory.rglob(\"*\") if f.is_file() and all(x not in f.name for x in exclude)]\n    zip_file = directory.with_suffix(\".zip\")\n    compression = ZIP_DEFLATED if compress else ZIP_STORED\n    with ZipFile(zip_file, \"w\", compression) as f:\n        for file in TQDM(files_to_zip, desc=f\"Zipping {directory} to {zip_file}...\", unit=\"file\", disable=not progress):\n            f.write(file, file.relative_to(directory))\n\n    return zip_file  # return path to zip file\n</code></pre>"},{"location":"reference/utils/downloads/#ultralytics.utils.downloads.unzip_file","title":"<code>ultralytics.utils.downloads.unzip_file(file, path=None, exclude=('.DS_Store', '__MACOSX'), exist_ok=False, progress=True)</code>","text":"<p>Unzips a *.zip file to the specified path, excluding files containing strings in the exclude list.</p> <p>If the zipfile does not contain a single top-level directory, the function will create a new directory with the same name as the zipfile (without the extension) to extract its contents. If a path is not provided, the function will use the parent directory of the zipfile as the default path.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>The path to the zipfile to be extracted.</p> required <code>path</code> <code>str</code> <p>The path to extract the zipfile to. Defaults to None.</p> <code>None</code> <code>exclude</code> <code>tuple</code> <p>A tuple of filename strings to be excluded. Defaults to ('.DS_Store', '__MACOSX').</p> <code>('.DS_Store', '__MACOSX')</code> <code>exist_ok</code> <code>bool</code> <p>Whether to overwrite existing contents if they exist. Defaults to False.</p> <code>False</code> <code>progress</code> <code>bool</code> <p>Whether to display a progress bar. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>BadZipFile</code> <p>If the provided file does not exist or is not a valid zipfile.</p> <p>Returns:</p> Type Description <code>Path</code> <p>The path to the directory where the zipfile was extracted.</p> Example <pre><code>from ultralytics.utils.downloads import unzip_file\n\ndir = unzip_file('path/to/file.zip')\n</code></pre> Source code in <code>ultralytics/utils/downloads.py</code> <pre><code>def unzip_file(file, path=None, exclude=(\".DS_Store\", \"__MACOSX\"), exist_ok=False, progress=True):\n    \"\"\"\n    Unzips a *.zip file to the specified path, excluding files containing strings in the exclude list.\n\n    If the zipfile does not contain a single top-level directory, the function will create a new\n    directory with the same name as the zipfile (without the extension) to extract its contents.\n    If a path is not provided, the function will use the parent directory of the zipfile as the default path.\n\n    Args:\n        file (str): The path to the zipfile to be extracted.\n        path (str, optional): The path to extract the zipfile to. Defaults to None.\n        exclude (tuple, optional): A tuple of filename strings to be excluded. Defaults to ('.DS_Store', '__MACOSX').\n        exist_ok (bool, optional): Whether to overwrite existing contents if they exist. Defaults to False.\n        progress (bool, optional): Whether to display a progress bar. Defaults to True.\n\n    Raises:\n        BadZipFile: If the provided file does not exist or is not a valid zipfile.\n\n    Returns:\n        (Path): The path to the directory where the zipfile was extracted.\n\n    Example:\n        ```python\n        from ultralytics.utils.downloads import unzip_file\n\n        dir = unzip_file('path/to/file.zip')\n        ```\n    \"\"\"\n    from zipfile import BadZipFile, ZipFile, is_zipfile\n\n    if not (Path(file).exists() and is_zipfile(file)):\n        raise BadZipFile(f\"File '{file}' does not exist or is a bad zip file.\")\n    if path is None:\n        path = Path(file).parent  # default path\n\n    # Unzip the file contents\n    with ZipFile(file) as zipObj:\n        files = [f for f in zipObj.namelist() if all(x not in f for x in exclude)]\n        top_level_dirs = {Path(f).parts[0] for f in files}\n\n        if len(top_level_dirs) &gt; 1 or (len(files) &gt; 1 and not files[0].endswith(\"/\")):\n            # Zip has multiple files at top level\n            path = extract_path = Path(path) / Path(file).stem  # i.e. ../datasets/coco8\n        else:\n            # Zip has 1 top-level directory\n            extract_path = path  # i.e. ../datasets\n            path = Path(path) / list(top_level_dirs)[0]  # i.e. ../datasets/coco8\n\n        # Check if destination directory already exists and contains files\n        if path.exists() and any(path.iterdir()) and not exist_ok:\n            # If it exists and is not empty, return the path without unzipping\n            LOGGER.warning(f\"WARNING \u26a0\ufe0f Skipping {file} unzip as destination directory {path} is not empty.\")\n            return path\n\n        for f in TQDM(files, desc=f\"Unzipping {file} to {Path(path).resolve()}...\", unit=\"file\", disable=not progress):\n            # Ensure the file is within the extract_path to avoid path traversal security vulnerability\n            if \"..\" in Path(f).parts:\n                LOGGER.warning(f\"Potentially insecure file path: {f}, skipping extraction.\")\n                continue\n            zipObj.extract(f, extract_path)\n\n    return path  # return unzip dir\n</code></pre>"},{"location":"reference/utils/downloads/#ultralytics.utils.downloads.check_disk_space","title":"<code>ultralytics.utils.downloads.check_disk_space(url='https://ultralytics.com/assets/coco128.zip', sf=1.5, hard=True)</code>","text":"<p>Check if there is sufficient disk space to download and store a file.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to the file. Defaults to 'https://ultralytics.com/assets/coco128.zip'.</p> <code>'https://ultralytics.com/assets/coco128.zip'</code> <code>sf</code> <code>float</code> <p>Safety factor, the multiplier for the required free space. Defaults to 2.0.</p> <code>1.5</code> <code>hard</code> <code>bool</code> <p>Whether to throw an error or not on insufficient disk space. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if there is sufficient disk space, False otherwise.</p> Source code in <code>ultralytics/utils/downloads.py</code> <pre><code>def check_disk_space(url=\"https://ultralytics.com/assets/coco128.zip\", sf=1.5, hard=True):\n    \"\"\"\n    Check if there is sufficient disk space to download and store a file.\n\n    Args:\n        url (str, optional): The URL to the file. Defaults to 'https://ultralytics.com/assets/coco128.zip'.\n        sf (float, optional): Safety factor, the multiplier for the required free space. Defaults to 2.0.\n        hard (bool, optional): Whether to throw an error or not on insufficient disk space. Defaults to True.\n\n    Returns:\n        (bool): True if there is sufficient disk space, False otherwise.\n    \"\"\"\n    try:\n        r = requests.head(url)  # response\n        assert r.status_code &lt; 400, f\"URL error for {url}: {r.status_code} {r.reason}\"  # check response\n    except Exception:\n        return True  # requests issue, default to True\n\n    # Check file size\n    gib = 1 &lt;&lt; 30  # bytes per GiB\n    data = int(r.headers.get(\"Content-Length\", 0)) / gib  # file size (GB)\n    total, used, free = (x / gib for x in shutil.disk_usage(Path.cwd()))  # bytes\n\n    if data * sf &lt; free:\n        return True  # sufficient space\n\n    # Insufficient space\n    text = (\n        f\"WARNING \u26a0\ufe0f Insufficient free disk space {free:.1f} GB &lt; {data * sf:.3f} GB required, \"\n        f\"Please free {data * sf - free:.1f} GB additional disk space and try again.\"\n    )\n    if hard:\n        raise MemoryError(text)\n    LOGGER.warning(text)\n    return False\n</code></pre>"},{"location":"reference/utils/downloads/#ultralytics.utils.downloads.get_google_drive_file_info","title":"<code>ultralytics.utils.downloads.get_google_drive_file_info(link)</code>","text":"<p>Retrieves the direct download link and filename for a shareable Google Drive file link.</p> <p>Parameters:</p> Name Type Description Default <code>link</code> <code>str</code> <p>The shareable link of the Google Drive file.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Direct download URL for the Google Drive file.</p> <code>str</code> <p>Original filename of the Google Drive file. If filename extraction fails, returns None.</p> Example <pre><code>from ultralytics.utils.downloads import get_google_drive_file_info\n\nlink = \"https://drive.google.com/file/d/1cqT-cJgANNrhIHCrEufUYhQ4RqiWG_lJ/view?usp=drive_link\"\nurl, filename = get_google_drive_file_info(link)\n</code></pre> Source code in <code>ultralytics/utils/downloads.py</code> <pre><code>def get_google_drive_file_info(link):\n    \"\"\"\n    Retrieves the direct download link and filename for a shareable Google Drive file link.\n\n    Args:\n        link (str): The shareable link of the Google Drive file.\n\n    Returns:\n        (str): Direct download URL for the Google Drive file.\n        (str): Original filename of the Google Drive file. If filename extraction fails, returns None.\n\n    Example:\n        ```python\n        from ultralytics.utils.downloads import get_google_drive_file_info\n\n        link = \"https://drive.google.com/file/d/1cqT-cJgANNrhIHCrEufUYhQ4RqiWG_lJ/view?usp=drive_link\"\n        url, filename = get_google_drive_file_info(link)\n        ```\n    \"\"\"\n    file_id = link.split(\"/d/\")[1].split(\"/view\")[0]\n    drive_url = f\"https://drive.google.com/uc?export=download&amp;id={file_id}\"\n    filename = None\n\n    # Start session\n    with requests.Session() as session:\n        response = session.get(drive_url, stream=True)\n        if \"quota exceeded\" in str(response.content.lower()):\n            raise ConnectionError(\n                emojis(\n                    f\"\u274c  Google Drive file download quota exceeded. \"\n                    f\"Please try again later or download this file manually at {link}.\"\n                )\n            )\n        for k, v in response.cookies.items():\n            if k.startswith(\"download_warning\"):\n                drive_url += f\"&amp;confirm={v}\"  # v is token\n        cd = response.headers.get(\"content-disposition\")\n        if cd:\n            filename = re.findall('filename=\"(.+)\"', cd)[0]\n    return drive_url, filename\n</code></pre>"},{"location":"reference/utils/downloads/#ultralytics.utils.downloads.safe_download","title":"<code>ultralytics.utils.downloads.safe_download(url, file=None, dir=None, unzip=True, delete=False, curl=False, retry=3, min_bytes=1.0, exist_ok=False, progress=True)</code>","text":"<p>Downloads files from a URL, with options for retrying, unzipping, and deleting the downloaded file.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the file to be downloaded.</p> required <code>file</code> <code>str</code> <p>The filename of the downloaded file. If not provided, the file will be saved with the same name as the URL.</p> <code>None</code> <code>dir</code> <code>str</code> <p>The directory to save the downloaded file. If not provided, the file will be saved in the current working directory.</p> <code>None</code> <code>unzip</code> <code>bool</code> <p>Whether to unzip the downloaded file. Default: True.</p> <code>True</code> <code>delete</code> <code>bool</code> <p>Whether to delete the downloaded file after unzipping. Default: False.</p> <code>False</code> <code>curl</code> <code>bool</code> <p>Whether to use curl command line tool for downloading. Default: False.</p> <code>False</code> <code>retry</code> <code>int</code> <p>The number of times to retry the download in case of failure. Default: 3.</p> <code>3</code> <code>min_bytes</code> <code>float</code> <p>The minimum number of bytes that the downloaded file should have, to be considered a successful download. Default: 1E0.</p> <code>1.0</code> <code>exist_ok</code> <code>bool</code> <p>Whether to overwrite existing contents during unzipping. Defaults to False.</p> <code>False</code> <code>progress</code> <code>bool</code> <p>Whether to display a progress bar during the download. Default: True.</p> <code>True</code> Example <pre><code>from ultralytics.utils.downloads import safe_download\n\nlink = \"https://ultralytics.com/assets/bus.jpg\"\npath = safe_download(link)\n</code></pre> Source code in <code>ultralytics/utils/downloads.py</code> <pre><code>def safe_download(\n    url,\n    file=None,\n    dir=None,\n    unzip=True,\n    delete=False,\n    curl=False,\n    retry=3,\n    min_bytes=1e0,\n    exist_ok=False,\n    progress=True,\n):\n    \"\"\"\n    Downloads files from a URL, with options for retrying, unzipping, and deleting the downloaded file.\n\n    Args:\n        url (str): The URL of the file to be downloaded.\n        file (str, optional): The filename of the downloaded file.\n            If not provided, the file will be saved with the same name as the URL.\n        dir (str, optional): The directory to save the downloaded file.\n            If not provided, the file will be saved in the current working directory.\n        unzip (bool, optional): Whether to unzip the downloaded file. Default: True.\n        delete (bool, optional): Whether to delete the downloaded file after unzipping. Default: False.\n        curl (bool, optional): Whether to use curl command line tool for downloading. Default: False.\n        retry (int, optional): The number of times to retry the download in case of failure. Default: 3.\n        min_bytes (float, optional): The minimum number of bytes that the downloaded file should have, to be considered\n            a successful download. Default: 1E0.\n        exist_ok (bool, optional): Whether to overwrite existing contents during unzipping. Defaults to False.\n        progress (bool, optional): Whether to display a progress bar during the download. Default: True.\n\n    Example:\n        ```python\n        from ultralytics.utils.downloads import safe_download\n\n        link = \"https://ultralytics.com/assets/bus.jpg\"\n        path = safe_download(link)\n        ```\n    \"\"\"\n    gdrive = url.startswith(\"https://drive.google.com/\")  # check if the URL is a Google Drive link\n    if gdrive:\n        url, file = get_google_drive_file_info(url)\n\n    f = Path(dir or \".\") / (file or url2file(url))  # URL converted to filename\n    if \"://\" not in str(url) and Path(url).is_file():  # URL exists ('://' check required in Windows Python&lt;3.10)\n        f = Path(url)  # filename\n    elif not f.is_file():  # URL and file do not exist\n        desc = f\"Downloading {url if gdrive else clean_url(url)} to '{f}'\"\n        LOGGER.info(f\"{desc}...\")\n        f.parent.mkdir(parents=True, exist_ok=True)  # make directory if missing\n        check_disk_space(url)\n        for i in range(retry + 1):\n            try:\n                if curl or i &gt; 0:  # curl download with retry, continue\n                    s = \"sS\" * (not progress)  # silent\n                    r = subprocess.run([\"curl\", \"-#\", f\"-{s}L\", url, \"-o\", f, \"--retry\", \"3\", \"-C\", \"-\"]).returncode\n                    assert r == 0, f\"Curl return value {r}\"\n                else:  # urllib download\n                    method = \"torch\"\n                    if method == \"torch\":\n                        torch.hub.download_url_to_file(url, f, progress=progress)\n                    else:\n                        with request.urlopen(url) as response, TQDM(\n                            total=int(response.getheader(\"Content-Length\", 0)),\n                            desc=desc,\n                            disable=not progress,\n                            unit=\"B\",\n                            unit_scale=True,\n                            unit_divisor=1024,\n                        ) as pbar:\n                            with open(f, \"wb\") as f_opened:\n                                for data in response:\n                                    f_opened.write(data)\n                                    pbar.update(len(data))\n\n                if f.exists():\n                    if f.stat().st_size &gt; min_bytes:\n                        break  # success\n                    f.unlink()  # remove partial downloads\n            except Exception as e:\n                if i == 0 and not is_online():\n                    raise ConnectionError(emojis(f\"\u274c  Download failure for {url}. Environment is not online.\")) from e\n                elif i &gt;= retry:\n                    raise ConnectionError(emojis(f\"\u274c  Download failure for {url}. Retry limit reached.\")) from e\n                LOGGER.warning(f\"\u26a0\ufe0f Download failure, retrying {i + 1}/{retry} {url}...\")\n\n    if unzip and f.exists() and f.suffix in (\"\", \".zip\", \".tar\", \".gz\"):\n        from zipfile import is_zipfile\n\n        unzip_dir = (dir or f.parent).resolve()  # unzip to dir if provided else unzip in place\n        if is_zipfile(f):\n            unzip_dir = unzip_file(file=f, path=unzip_dir, exist_ok=exist_ok, progress=progress)  # unzip\n        elif f.suffix in (\".tar\", \".gz\"):\n            LOGGER.info(f\"Unzipping {f} to {unzip_dir}...\")\n            subprocess.run([\"tar\", \"xf\" if f.suffix == \".tar\" else \"xfz\", f, \"--directory\", unzip_dir], check=True)\n        if delete:\n            f.unlink()  # remove zip\n        return unzip_dir\n</code></pre>"},{"location":"reference/utils/downloads/#ultralytics.utils.downloads.get_github_assets","title":"<code>ultralytics.utils.downloads.get_github_assets(repo='ultralytics/assets', version='latest', retry=False)</code>","text":"<p>Retrieve the specified version's tag and assets from a GitHub repository. If the version is not specified, the function fetches the latest release assets.</p> <p>Parameters:</p> Name Type Description Default <code>repo</code> <code>str</code> <p>The GitHub repository in the format 'owner/repo'. Defaults to 'ultralytics/assets'.</p> <code>'ultralytics/assets'</code> <code>version</code> <code>str</code> <p>The release version to fetch assets from. Defaults to 'latest'.</p> <code>'latest'</code> <code>retry</code> <code>bool</code> <p>Flag to retry the request in case of a failure. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the release tag and a list of asset names.</p> Example <pre><code>tag, assets = get_github_assets(repo='ultralytics/assets', version='latest')\n</code></pre> Source code in <code>ultralytics/utils/downloads.py</code> <pre><code>def get_github_assets(repo=\"ultralytics/assets\", version=\"latest\", retry=False):\n    \"\"\"\n    Retrieve the specified version's tag and assets from a GitHub repository. If the version is not specified, the\n    function fetches the latest release assets.\n\n    Args:\n        repo (str, optional): The GitHub repository in the format 'owner/repo'. Defaults to 'ultralytics/assets'.\n        version (str, optional): The release version to fetch assets from. Defaults to 'latest'.\n        retry (bool, optional): Flag to retry the request in case of a failure. Defaults to False.\n\n    Returns:\n        (tuple): A tuple containing the release tag and a list of asset names.\n\n    Example:\n        ```python\n        tag, assets = get_github_assets(repo='ultralytics/assets', version='latest')\n        ```\n    \"\"\"\n\n    if version != \"latest\":\n        version = f\"tags/{version}\"  # i.e. tags/v6.2\n    url = f\"https://api.github.com/repos/{repo}/releases/{version}\"\n    r = requests.get(url)  # github api\n    if r.status_code != 200 and r.reason != \"rate limit exceeded\" and retry:  # failed and not 403 rate limit exceeded\n        r = requests.get(url)  # try again\n    if r.status_code != 200:\n        LOGGER.warning(f\"\u26a0\ufe0f GitHub assets check failure for {url}: {r.status_code} {r.reason}\")\n        return \"\", []\n    data = r.json()\n    return data[\"tag_name\"], [x[\"name\"] for x in data[\"assets\"]]  # tag, assets i.e. ['yolov8n.pt', 'yolov8s.pt', ...]\n</code></pre>"},{"location":"reference/utils/downloads/#ultralytics.utils.downloads.attempt_download_asset","title":"<code>ultralytics.utils.downloads.attempt_download_asset(file, repo='ultralytics/assets', release='v0.0.0', **kwargs)</code>","text":"<p>Attempt to download a file from GitHub release assets if it is not found locally. The function checks for the file locally first, then tries to download it from the specified GitHub repository release.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path</code> <p>The filename or file path to be downloaded.</p> required <code>repo</code> <code>str</code> <p>The GitHub repository in the format 'owner/repo'. Defaults to 'ultralytics/assets'.</p> <code>'ultralytics/assets'</code> <code>release</code> <code>str</code> <p>The specific release version to be downloaded. Defaults to 'v0.0.0'.</p> <code>'v0.0.0'</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for the download process.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The path to the downloaded file.</p> Example <pre><code>file_path = attempt_download_asset('yolov5s.pt', repo='ultralytics/assets', release='latest')\n</code></pre> Source code in <code>ultralytics/utils/downloads.py</code> <pre><code>def attempt_download_asset(file, repo=\"ultralytics/assets\", release=\"v0.0.0\", **kwargs):\n    \"\"\"\n    Attempt to download a file from GitHub release assets if it is not found locally. The function checks for the file\n    locally first, then tries to download it from the specified GitHub repository release.\n\n    Args:\n        file (str | Path): The filename or file path to be downloaded.\n        repo (str, optional): The GitHub repository in the format 'owner/repo'. Defaults to 'ultralytics/assets'.\n        release (str, optional): The specific release version to be downloaded. Defaults to 'v0.0.0'.\n        **kwargs (dict): Additional keyword arguments for the download process.\n\n    Returns:\n        (str): The path to the downloaded file.\n\n    Example:\n        ```python\n        file_path = attempt_download_asset('yolov5s.pt', repo='ultralytics/assets', release='latest')\n        ```\n    \"\"\"\n    from ultralytics.utils import SETTINGS  # scoped for circular import\n\n    # YOLOv3/5u updates\n    file = str(file)\n    file = checks.check_yolov5u_filename(file)\n    file = Path(file.strip().replace(\"'\", \"\"))\n    if file.exists():\n        return str(file)\n    elif (SETTINGS[\"weights_dir\"] / file).exists():\n        return str(SETTINGS[\"weights_dir\"] / file)\n    else:\n        # URL specified\n        name = Path(parse.unquote(str(file))).name  # decode '%2F' to '/' etc.\n        download_url = f\"https://github.com/{repo}/releases/download\"\n        if str(file).startswith((\"http:/\", \"https:/\")):  # download\n            url = str(file).replace(\":/\", \"://\")  # Pathlib turns :// -&gt; :/\n            file = url2file(name)  # parse authentication https://url.com/file.txt?auth...\n            if Path(file).is_file():\n                LOGGER.info(f\"Found {clean_url(url)} locally at {file}\")  # file already exists\n            else:\n                safe_download(url=url, file=file, min_bytes=1e5, **kwargs)\n\n        elif repo == GITHUB_ASSETS_REPO and name in GITHUB_ASSETS_NAMES:\n            safe_download(url=f\"{download_url}/{release}/{name}\", file=file, min_bytes=1e5, **kwargs)\n\n        else:\n            tag, assets = get_github_assets(repo, release)\n            if not assets:\n                tag, assets = get_github_assets(repo)  # latest release\n            if name in assets:\n                safe_download(url=f\"{download_url}/{tag}/{name}\", file=file, min_bytes=1e5, **kwargs)\n\n        return str(file)\n</code></pre>"},{"location":"reference/utils/downloads/#ultralytics.utils.downloads.download","title":"<code>ultralytics.utils.downloads.download(url, dir=Path.cwd(), unzip=True, delete=False, curl=False, threads=1, retry=3, exist_ok=False)</code>","text":"<p>Downloads files from specified URLs to a given directory. Supports concurrent downloads if multiple threads are specified.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str | list</code> <p>The URL or list of URLs of the files to be downloaded.</p> required <code>dir</code> <code>Path</code> <p>The directory where the files will be saved. Defaults to the current working directory.</p> <code>cwd()</code> <code>unzip</code> <code>bool</code> <p>Flag to unzip the files after downloading. Defaults to True.</p> <code>True</code> <code>delete</code> <code>bool</code> <p>Flag to delete the zip files after extraction. Defaults to False.</p> <code>False</code> <code>curl</code> <code>bool</code> <p>Flag to use curl for downloading. Defaults to False.</p> <code>False</code> <code>threads</code> <code>int</code> <p>Number of threads to use for concurrent downloads. Defaults to 1.</p> <code>1</code> <code>retry</code> <code>int</code> <p>Number of retries in case of download failure. Defaults to 3.</p> <code>3</code> <code>exist_ok</code> <code>bool</code> <p>Whether to overwrite existing contents during unzipping. Defaults to False.</p> <code>False</code> Example <pre><code>download('https://ultralytics.com/assets/example.zip', dir='path/to/dir', unzip=True)\n</code></pre> Source code in <code>ultralytics/utils/downloads.py</code> <pre><code>def download(url, dir=Path.cwd(), unzip=True, delete=False, curl=False, threads=1, retry=3, exist_ok=False):\n    \"\"\"\n    Downloads files from specified URLs to a given directory. Supports concurrent downloads if multiple threads are\n    specified.\n\n    Args:\n        url (str | list): The URL or list of URLs of the files to be downloaded.\n        dir (Path, optional): The directory where the files will be saved. Defaults to the current working directory.\n        unzip (bool, optional): Flag to unzip the files after downloading. Defaults to True.\n        delete (bool, optional): Flag to delete the zip files after extraction. Defaults to False.\n        curl (bool, optional): Flag to use curl for downloading. Defaults to False.\n        threads (int, optional): Number of threads to use for concurrent downloads. Defaults to 1.\n        retry (int, optional): Number of retries in case of download failure. Defaults to 3.\n        exist_ok (bool, optional): Whether to overwrite existing contents during unzipping. Defaults to False.\n\n    Example:\n        ```python\n        download('https://ultralytics.com/assets/example.zip', dir='path/to/dir', unzip=True)\n        ```\n    \"\"\"\n    dir = Path(dir)\n    dir.mkdir(parents=True, exist_ok=True)  # make directory\n    if threads &gt; 1:\n        with ThreadPool(threads) as pool:\n            pool.map(\n                lambda x: safe_download(\n                    url=x[0],\n                    dir=x[1],\n                    unzip=unzip,\n                    delete=delete,\n                    curl=curl,\n                    retry=retry,\n                    exist_ok=exist_ok,\n                    progress=threads &lt;= 1,\n                ),\n                zip(url, repeat(dir)),\n            )\n            pool.close()\n            pool.join()\n    else:\n        for u in [url] if isinstance(url, (str, Path)) else url:\n            safe_download(url=u, dir=dir, unzip=unzip, delete=delete, curl=curl, retry=retry, exist_ok=exist_ok)\n</code></pre>"},{"location":"reference/utils/errors/","title":"Reference for <code>ultralytics/utils/errors.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/errors.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/utils/errors/#ultralytics.utils.errors.HUBModelError","title":"<code>ultralytics.utils.errors.HUBModelError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Custom exception class for handling errors related to model fetching in Ultralytics YOLO.</p> <p>This exception is raised when a requested model is not found or cannot be retrieved. The message is also processed to include emojis for better user experience.</p> <p>Attributes:</p> Name Type Description <code>message</code> <code>str</code> <p>The error message displayed when the exception is raised.</p> Note <p>The message is automatically processed through the 'emojis' function from the 'ultralytics.utils' package.</p> Source code in <code>ultralytics/utils/errors.py</code> <pre><code>class HUBModelError(Exception):\n    \"\"\"\n    Custom exception class for handling errors related to model fetching in Ultralytics YOLO.\n\n    This exception is raised when a requested model is not found or cannot be retrieved.\n    The message is also processed to include emojis for better user experience.\n\n    Attributes:\n        message (str): The error message displayed when the exception is raised.\n\n    Note:\n        The message is automatically processed through the 'emojis' function from the 'ultralytics.utils' package.\n    \"\"\"\n\n    def __init__(self, message=\"Model not found. Please check model URL and try again.\"):\n        \"\"\"Create an exception for when a model is not found.\"\"\"\n        super().__init__(emojis(message))\n</code></pre>"},{"location":"reference/utils/errors/#ultralytics.utils.errors.HUBModelError.__init__","title":"<code>__init__(message='Model not found. Please check model URL and try again.')</code>","text":"<p>Create an exception for when a model is not found.</p> Source code in <code>ultralytics/utils/errors.py</code> <pre><code>def __init__(self, message=\"Model not found. Please check model URL and try again.\"):\n    \"\"\"Create an exception for when a model is not found.\"\"\"\n    super().__init__(emojis(message))\n</code></pre>"},{"location":"reference/utils/files/","title":"Reference for <code>ultralytics/utils/files.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/files.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/files/#ultralytics.utils.files.WorkingDirectory","title":"<code>ultralytics.utils.files.WorkingDirectory</code>","text":"<p>             Bases: <code>ContextDecorator</code></p> <p>Usage: @WorkingDirectory(dir) decorator or 'with WorkingDirectory(dir):' context manager.</p> Source code in <code>ultralytics/utils/files.py</code> <pre><code>class WorkingDirectory(contextlib.ContextDecorator):\n    \"\"\"Usage: @WorkingDirectory(dir) decorator or 'with WorkingDirectory(dir):' context manager.\"\"\"\n\n    def __init__(self, new_dir):\n        \"\"\"Sets the working directory to 'new_dir' upon instantiation.\"\"\"\n        self.dir = new_dir  # new dir\n        self.cwd = Path.cwd().resolve()  # current dir\n\n    def __enter__(self):\n        \"\"\"Changes the current directory to the specified directory.\"\"\"\n        os.chdir(self.dir)\n\n    def __exit__(self, exc_type, exc_val, exc_tb):  # noqa\n        \"\"\"Restore the current working directory on context exit.\"\"\"\n        os.chdir(self.cwd)\n</code></pre>"},{"location":"reference/utils/files/#ultralytics.utils.files.WorkingDirectory.__enter__","title":"<code>__enter__()</code>","text":"<p>Changes the current directory to the specified directory.</p> Source code in <code>ultralytics/utils/files.py</code> <pre><code>def __enter__(self):\n    \"\"\"Changes the current directory to the specified directory.\"\"\"\n    os.chdir(self.dir)\n</code></pre>"},{"location":"reference/utils/files/#ultralytics.utils.files.WorkingDirectory.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Restore the current working directory on context exit.</p> Source code in <code>ultralytics/utils/files.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):  # noqa\n    \"\"\"Restore the current working directory on context exit.\"\"\"\n    os.chdir(self.cwd)\n</code></pre>"},{"location":"reference/utils/files/#ultralytics.utils.files.WorkingDirectory.__init__","title":"<code>__init__(new_dir)</code>","text":"<p>Sets the working directory to 'new_dir' upon instantiation.</p> Source code in <code>ultralytics/utils/files.py</code> <pre><code>def __init__(self, new_dir):\n    \"\"\"Sets the working directory to 'new_dir' upon instantiation.\"\"\"\n    self.dir = new_dir  # new dir\n    self.cwd = Path.cwd().resolve()  # current dir\n</code></pre>"},{"location":"reference/utils/files/#ultralytics.utils.files.spaces_in_path","title":"<code>ultralytics.utils.files.spaces_in_path(path)</code>","text":"<p>Context manager to handle paths with spaces in their names. If a path contains spaces, it replaces them with underscores, copies the file/directory to the new path, executes the context code block, then copies the file/directory back to its original location.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The original path.</p> required <p>Yields:</p> Type Description <code>Path</code> <p>Temporary path with spaces replaced by underscores if spaces were present, otherwise the original path.</p> Example <pre><code>with ultralytics.utils.files import spaces_in_path\n\nwith spaces_in_path('/path/with spaces') as new_path:\n    # Your code here\n</code></pre> Source code in <code>ultralytics/utils/files.py</code> <pre><code>@contextmanager\ndef spaces_in_path(path):\n    \"\"\"\n    Context manager to handle paths with spaces in their names. If a path contains spaces, it replaces them with\n    underscores, copies the file/directory to the new path, executes the context code block, then copies the\n    file/directory back to its original location.\n\n    Args:\n        path (str | Path): The original path.\n\n    Yields:\n        (Path): Temporary path with spaces replaced by underscores if spaces were present, otherwise the original path.\n\n    Example:\n        ```python\n        with ultralytics.utils.files import spaces_in_path\n\n        with spaces_in_path('/path/with spaces') as new_path:\n            # Your code here\n        ```\n    \"\"\"\n\n    # If path has spaces, replace them with underscores\n    if \" \" in str(path):\n        string = isinstance(path, str)  # input type\n        path = Path(path)\n\n        # Create a temporary directory and construct the new path\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            tmp_path = Path(tmp_dir) / path.name.replace(\" \", \"_\")\n\n            # Copy file/directory\n            if path.is_dir():\n                # tmp_path.mkdir(parents=True, exist_ok=True)\n                shutil.copytree(path, tmp_path)\n            elif path.is_file():\n                tmp_path.parent.mkdir(parents=True, exist_ok=True)\n                shutil.copy2(path, tmp_path)\n\n            try:\n                # Yield the temporary path\n                yield str(tmp_path) if string else tmp_path\n\n            finally:\n                # Copy file/directory back\n                if tmp_path.is_dir():\n                    shutil.copytree(tmp_path, path, dirs_exist_ok=True)\n                elif tmp_path.is_file():\n                    shutil.copy2(tmp_path, path)  # Copy back the file\n\n    else:\n        # If there are no spaces, just yield the original path\n        yield path\n</code></pre>"},{"location":"reference/utils/files/#ultralytics.utils.files.increment_path","title":"<code>ultralytics.utils.files.increment_path(path, exist_ok=False, sep='', mkdir=False)</code>","text":"<p>Increments a file or directory path, i.e. runs/exp --&gt; runs/exp{sep}2, runs/exp{sep}3, ... etc.</p> <p>If the path exists and exist_ok is not set to True, the path will be incremented by appending a number and sep to the end of the path. If the path is a file, the file extension will be preserved. If the path is a directory, the number will be appended directly to the end of the path. If mkdir is set to True, the path will be created as a directory if it does not already exist.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>(str, Path)</code> <p>Path to increment.</p> required <code>exist_ok</code> <code>bool</code> <p>If True, the path will not be incremented and returned as-is. Defaults to False.</p> <code>False</code> <code>sep</code> <code>str</code> <p>Separator to use between the path and the incrementation number. Defaults to ''.</p> <code>''</code> <code>mkdir</code> <code>bool</code> <p>Create a directory if it does not exist. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Path</code> <p>Incremented path.</p> Source code in <code>ultralytics/utils/files.py</code> <pre><code>def increment_path(path, exist_ok=False, sep=\"\", mkdir=False):\n    \"\"\"\n    Increments a file or directory path, i.e. runs/exp --&gt; runs/exp{sep}2, runs/exp{sep}3, ... etc.\n\n    If the path exists and exist_ok is not set to True, the path will be incremented by appending a number and sep to\n    the end of the path. If the path is a file, the file extension will be preserved. If the path is a directory, the\n    number will be appended directly to the end of the path. If mkdir is set to True, the path will be created as a\n    directory if it does not already exist.\n\n    Args:\n        path (str, pathlib.Path): Path to increment.\n        exist_ok (bool, optional): If True, the path will not be incremented and returned as-is. Defaults to False.\n        sep (str, optional): Separator to use between the path and the incrementation number. Defaults to ''.\n        mkdir (bool, optional): Create a directory if it does not exist. Defaults to False.\n\n    Returns:\n        (pathlib.Path): Incremented path.\n    \"\"\"\n    path = Path(path)  # os-agnostic\n    if path.exists() and not exist_ok:\n        path, suffix = (path.with_suffix(\"\"), path.suffix) if path.is_file() else (path, \"\")\n\n        # Method 1\n        for n in range(2, 9999):\n            p = f\"{path}{sep}{n}{suffix}\"  # increment path\n            if not os.path.exists(p):\n                break\n        path = Path(p)\n\n    if mkdir:\n        path.mkdir(parents=True, exist_ok=True)  # make directory\n\n    return path\n</code></pre>"},{"location":"reference/utils/files/#ultralytics.utils.files.file_age","title":"<code>ultralytics.utils.files.file_age(path=__file__)</code>","text":"<p>Return days since last file update.</p> Source code in <code>ultralytics/utils/files.py</code> <pre><code>def file_age(path=__file__):\n    \"\"\"Return days since last file update.\"\"\"\n    dt = datetime.now() - datetime.fromtimestamp(Path(path).stat().st_mtime)  # delta\n    return dt.days  # + dt.seconds / 86400  # fractional days\n</code></pre>"},{"location":"reference/utils/files/#ultralytics.utils.files.file_date","title":"<code>ultralytics.utils.files.file_date(path=__file__)</code>","text":"<p>Return human-readable file modification date, i.e. '2021-3-26'.</p> Source code in <code>ultralytics/utils/files.py</code> <pre><code>def file_date(path=__file__):\n    \"\"\"Return human-readable file modification date, i.e. '2021-3-26'.\"\"\"\n    t = datetime.fromtimestamp(Path(path).stat().st_mtime)\n    return f\"{t.year}-{t.month}-{t.day}\"\n</code></pre>"},{"location":"reference/utils/files/#ultralytics.utils.files.file_size","title":"<code>ultralytics.utils.files.file_size(path)</code>","text":"<p>Return file/dir size (MB).</p> Source code in <code>ultralytics/utils/files.py</code> <pre><code>def file_size(path):\n    \"\"\"Return file/dir size (MB).\"\"\"\n    if isinstance(path, (str, Path)):\n        mb = 1 &lt;&lt; 20  # bytes to MiB (1024 ** 2)\n        path = Path(path)\n        if path.is_file():\n            return path.stat().st_size / mb\n        elif path.is_dir():\n            return sum(f.stat().st_size for f in path.glob(\"**/*\") if f.is_file()) / mb\n    return 0.0\n</code></pre>"},{"location":"reference/utils/files/#ultralytics.utils.files.get_latest_run","title":"<code>ultralytics.utils.files.get_latest_run(search_dir='.')</code>","text":"<p>Return path to most recent 'last.pt' in /runs (i.e. to --resume from).</p> Source code in <code>ultralytics/utils/files.py</code> <pre><code>def get_latest_run(search_dir=\".\"):\n    \"\"\"Return path to most recent 'last.pt' in /runs (i.e. to --resume from).\"\"\"\n    last_list = glob.glob(f\"{search_dir}/**/last*.pt\", recursive=True)\n    return max(last_list, key=os.path.getctime) if last_list else \"\"\n</code></pre>"},{"location":"reference/utils/instance/","title":"Reference for <code>ultralytics/utils/instance.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/instance.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/instance/#ultralytics.utils.instance.Bboxes","title":"<code>ultralytics.utils.instance.Bboxes</code>","text":"<p>A class for handling bounding boxes.</p> <p>The class supports various bounding box formats like 'xyxy', 'xywh', and 'ltwh'. Bounding box data should be provided in numpy arrays.</p> <p>Attributes:</p> Name Type Description <code>bboxes</code> <code>ndarray</code> <p>The bounding boxes stored in a 2D numpy array.</p> <code>format</code> <code>str</code> <p>The format of the bounding boxes ('xyxy', 'xywh', or 'ltwh').</p> Note <p>This class does not handle normalization or denormalization of bounding boxes.</p> Source code in <code>ultralytics/utils/instance.py</code> <pre><code>class Bboxes:\n    \"\"\"\n    A class for handling bounding boxes.\n\n    The class supports various bounding box formats like 'xyxy', 'xywh', and 'ltwh'.\n    Bounding box data should be provided in numpy arrays.\n\n    Attributes:\n        bboxes (numpy.ndarray): The bounding boxes stored in a 2D numpy array.\n        format (str): The format of the bounding boxes ('xyxy', 'xywh', or 'ltwh').\n\n    Note:\n        This class does not handle normalization or denormalization of bounding boxes.\n    \"\"\"\n\n    def __init__(self, bboxes, format=\"xyxy\") -&gt; None:\n        \"\"\"Initializes the Bboxes class with bounding box data in a specified format.\"\"\"\n        assert format in _formats, f\"Invalid bounding box format: {format}, format must be one of {_formats}\"\n        bboxes = bboxes[None, :] if bboxes.ndim == 1 else bboxes\n        assert bboxes.ndim == 2\n        assert bboxes.shape[1] == 4\n        self.bboxes = bboxes\n        self.format = format\n        # self.normalized = normalized\n\n    def convert(self, format):\n        \"\"\"Converts bounding box format from one type to another.\"\"\"\n        assert format in _formats, f\"Invalid bounding box format: {format}, format must be one of {_formats}\"\n        if self.format == format:\n            return\n        elif self.format == \"xyxy\":\n            func = xyxy2xywh if format == \"xywh\" else xyxy2ltwh\n        elif self.format == \"xywh\":\n            func = xywh2xyxy if format == \"xyxy\" else xywh2ltwh\n        else:\n            func = ltwh2xyxy if format == \"xyxy\" else ltwh2xywh\n        self.bboxes = func(self.bboxes)\n        self.format = format\n\n    def areas(self):\n        \"\"\"Return box areas.\"\"\"\n        self.convert(\"xyxy\")\n        return (self.bboxes[:, 2] - self.bboxes[:, 0]) * (self.bboxes[:, 3] - self.bboxes[:, 1])\n\n    # def denormalize(self, w, h):\n    #    if not self.normalized:\n    #         return\n    #     assert (self.bboxes &lt;= 1.0).all()\n    #     self.bboxes[:, 0::2] *= w\n    #     self.bboxes[:, 1::2] *= h\n    #     self.normalized = False\n    #\n    # def normalize(self, w, h):\n    #     if self.normalized:\n    #         return\n    #     assert (self.bboxes &gt; 1.0).any()\n    #     self.bboxes[:, 0::2] /= w\n    #     self.bboxes[:, 1::2] /= h\n    #     self.normalized = True\n\n    def mul(self, scale):\n        \"\"\"\n        Args:\n            scale (tuple | list | int): the scale for four coords.\n        \"\"\"\n        if isinstance(scale, Number):\n            scale = to_4tuple(scale)\n        assert isinstance(scale, (tuple, list))\n        assert len(scale) == 4\n        self.bboxes[:, 0] *= scale[0]\n        self.bboxes[:, 1] *= scale[1]\n        self.bboxes[:, 2] *= scale[2]\n        self.bboxes[:, 3] *= scale[3]\n\n    def add(self, offset):\n        \"\"\"\n        Args:\n            offset (tuple | list | int): the offset for four coords.\n        \"\"\"\n        if isinstance(offset, Number):\n            offset = to_4tuple(offset)\n        assert isinstance(offset, (tuple, list))\n        assert len(offset) == 4\n        self.bboxes[:, 0] += offset[0]\n        self.bboxes[:, 1] += offset[1]\n        self.bboxes[:, 2] += offset[2]\n        self.bboxes[:, 3] += offset[3]\n\n    def __len__(self):\n        \"\"\"Return the number of boxes.\"\"\"\n        return len(self.bboxes)\n\n    @classmethod\n    def concatenate(cls, boxes_list: List[\"Bboxes\"], axis=0) -&gt; \"Bboxes\":\n        \"\"\"\n        Concatenate a list of Bboxes objects into a single Bboxes object.\n\n        Args:\n            boxes_list (List[Bboxes]): A list of Bboxes objects to concatenate.\n            axis (int, optional): The axis along which to concatenate the bounding boxes.\n                                   Defaults to 0.\n\n        Returns:\n            Bboxes: A new Bboxes object containing the concatenated bounding boxes.\n\n        Note:\n            The input should be a list or tuple of Bboxes objects.\n        \"\"\"\n        assert isinstance(boxes_list, (list, tuple))\n        if not boxes_list:\n            return cls(np.empty(0))\n        assert all(isinstance(box, Bboxes) for box in boxes_list)\n\n        if len(boxes_list) == 1:\n            return boxes_list[0]\n        return cls(np.concatenate([b.bboxes for b in boxes_list], axis=axis))\n\n    def __getitem__(self, index) -&gt; \"Bboxes\":\n        \"\"\"\n        Retrieve a specific bounding box or a set of bounding boxes using indexing.\n\n        Args:\n            index (int, slice, or np.ndarray): The index, slice, or boolean array to select\n                                               the desired bounding boxes.\n\n        Returns:\n            Bboxes: A new Bboxes object containing the selected bounding boxes.\n\n        Raises:\n            AssertionError: If the indexed bounding boxes do not form a 2-dimensional matrix.\n\n        Note:\n            When using boolean indexing, make sure to provide a boolean array with the same\n            length as the number of bounding boxes.\n        \"\"\"\n        if isinstance(index, int):\n            return Bboxes(self.bboxes[index].view(1, -1))\n        b = self.bboxes[index]\n        assert b.ndim == 2, f\"Indexing on Bboxes with {index} failed to return a matrix!\"\n        return Bboxes(b)\n</code></pre>"},{"location":"reference/utils/instance/#ultralytics.utils.instance.Bboxes.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Retrieve a specific bounding box or a set of bounding boxes using indexing.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int, slice, or np.ndarray</code> <p>The index, slice, or boolean array to select                                the desired bounding boxes.</p> required <p>Returns:</p> Name Type Description <code>Bboxes</code> <code>Bboxes</code> <p>A new Bboxes object containing the selected bounding boxes.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the indexed bounding boxes do not form a 2-dimensional matrix.</p> Note <p>When using boolean indexing, make sure to provide a boolean array with the same length as the number of bounding boxes.</p> Source code in <code>ultralytics/utils/instance.py</code> <pre><code>def __getitem__(self, index) -&gt; \"Bboxes\":\n    \"\"\"\n    Retrieve a specific bounding box or a set of bounding boxes using indexing.\n\n    Args:\n        index (int, slice, or np.ndarray): The index, slice, or boolean array to select\n                                           the desired bounding boxes.\n\n    Returns:\n        Bboxes: A new Bboxes object containing the selected bounding boxes.\n\n    Raises:\n        AssertionError: If the indexed bounding boxes do not form a 2-dimensional matrix.\n\n    Note:\n        When using boolean indexing, make sure to provide a boolean array with the same\n        length as the number of bounding boxes.\n    \"\"\"\n    if isinstance(index, int):\n        return Bboxes(self.bboxes[index].view(1, -1))\n    b = self.bboxes[index]\n    assert b.ndim == 2, f\"Indexing on Bboxes with {index} failed to return a matrix!\"\n    return Bboxes(b)\n</code></pre>"},{"location":"reference/utils/instance/#ultralytics.utils.instance.Bboxes.__init__","title":"<code>__init__(bboxes, format='xyxy')</code>","text":"<p>Initializes the Bboxes class with bounding box data in a specified format.</p> Source code in <code>ultralytics/utils/instance.py</code> <pre><code>def __init__(self, bboxes, format=\"xyxy\") -&gt; None:\n    \"\"\"Initializes the Bboxes class with bounding box data in a specified format.\"\"\"\n    assert format in _formats, f\"Invalid bounding box format: {format}, format must be one of {_formats}\"\n    bboxes = bboxes[None, :] if bboxes.ndim == 1 else bboxes\n    assert bboxes.ndim == 2\n    assert bboxes.shape[1] == 4\n    self.bboxes = bboxes\n    self.format = format\n</code></pre>"},{"location":"reference/utils/instance/#ultralytics.utils.instance.Bboxes.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of boxes.</p> Source code in <code>ultralytics/utils/instance.py</code> <pre><code>def __len__(self):\n    \"\"\"Return the number of boxes.\"\"\"\n    return len(self.bboxes)\n</code></pre>"},{"location":"reference/utils/instance/#ultralytics.utils.instance.Bboxes.add","title":"<code>add(offset)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>offset</code> <code>tuple | list | int</code> <p>the offset for four coords.</p> required Source code in <code>ultralytics/utils/instance.py</code> <pre><code>def add(self, offset):\n    \"\"\"\n    Args:\n        offset (tuple | list | int): the offset for four coords.\n    \"\"\"\n    if isinstance(offset, Number):\n        offset = to_4tuple(offset)\n    assert isinstance(offset, (tuple, list))\n    assert len(offset) == 4\n    self.bboxes[:, 0] += offset[0]\n    self.bboxes[:, 1] += offset[1]\n    self.bboxes[:, 2] += offset[2]\n    self.bboxes[:, 3] += offset[3]\n</code></pre>"},{"location":"reference/utils/instance/#ultralytics.utils.instance.Bboxes.areas","title":"<code>areas()</code>","text":"<p>Return box areas.</p> Source code in <code>ultralytics/utils/instance.py</code> <pre><code>def areas(self):\n    \"\"\"Return box areas.\"\"\"\n    self.convert(\"xyxy\")\n    return (self.bboxes[:, 2] - self.bboxes[:, 0]) * (self.bboxes[:, 3] - self.bboxes[:, 1])\n</code></pre>"},{"location":"reference/utils/instance/#ultralytics.utils.instance.Bboxes.concatenate","title":"<code>concatenate(boxes_list, axis=0)</code>  <code>classmethod</code>","text":"<p>Concatenate a list of Bboxes objects into a single Bboxes object.</p> <p>Parameters:</p> Name Type Description Default <code>boxes_list</code> <code>List[Bboxes]</code> <p>A list of Bboxes objects to concatenate.</p> required <code>axis</code> <code>int</code> <p>The axis along which to concatenate the bounding boxes.                    Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>Bboxes</code> <code>Bboxes</code> <p>A new Bboxes object containing the concatenated bounding boxes.</p> Note <p>The input should be a list or tuple of Bboxes objects.</p> Source code in <code>ultralytics/utils/instance.py</code> <pre><code>@classmethod\ndef concatenate(cls, boxes_list: List[\"Bboxes\"], axis=0) -&gt; \"Bboxes\":\n    \"\"\"\n    Concatenate a list of Bboxes objects into a single Bboxes object.\n\n    Args:\n        boxes_list (List[Bboxes]): A list of Bboxes objects to concatenate.\n        axis (int, optional): The axis along which to concatenate the bounding boxes.\n                               Defaults to 0.\n\n    Returns:\n        Bboxes: A new Bboxes object containing the concatenated bounding boxes.\n\n    Note:\n        The input should be a list or tuple of Bboxes objects.\n    \"\"\"\n    assert isinstance(boxes_list, (list, tuple))\n    if not boxes_list:\n        return cls(np.empty(0))\n    assert all(isinstance(box, Bboxes) for box in boxes_list)\n\n    if len(boxes_list) == 1:\n        return boxes_list[0]\n    return cls(np.concatenate([b.bboxes for b in boxes_list], axis=axis))\n</code></pre>"},{"location":"reference/utils/instance/#ultralytics.utils.instance.Bboxes.convert","title":"<code>convert(format)</code>","text":"<p>Converts bounding box format from one type to another.</p> Source code in <code>ultralytics/utils/instance.py</code> <pre><code>def convert(self, format):\n    \"\"\"Converts bounding box format from one type to another.\"\"\"\n    assert format in _formats, f\"Invalid bounding box format: {format}, format must be one of {_formats}\"\n    if self.format == format:\n        return\n    elif self.format == \"xyxy\":\n        func = xyxy2xywh if format == \"xywh\" else xyxy2ltwh\n    elif self.format == \"xywh\":\n        func = xywh2xyxy if format == \"xyxy\" else xywh2ltwh\n    else:\n        func = ltwh2xyxy if format == \"xyxy\" else ltwh2xywh\n    self.bboxes = func(self.bboxes)\n    self.format = format\n</code></pre>"},{"location":"reference/utils/instance/#ultralytics.utils.instance.Bboxes.mul","title":"<code>mul(scale)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>scale</code> <code>tuple | list | int</code> <p>the scale for four coords.</p> required Source code in <code>ultralytics/utils/instance.py</code> <pre><code>def mul(self, scale):\n    \"\"\"\n    Args:\n        scale (tuple | list | int): the scale for four coords.\n    \"\"\"\n    if isinstance(scale, Number):\n        scale = to_4tuple(scale)\n    assert isinstance(scale, (tuple, list))\n    assert len(scale) == 4\n    self.bboxes[:, 0] *= scale[0]\n    self.bboxes[:, 1] *= scale[1]\n    self.bboxes[:, 2] *= scale[2]\n    self.bboxes[:, 3] *= scale[3]\n</code></pre>"},{"location":"reference/utils/instance/#ultralytics.utils.instance.Instances","title":"<code>ultralytics.utils.instance.Instances</code>","text":"<p>Container for bounding boxes, segments, and keypoints of detected objects in an image.</p> <p>Attributes:</p> Name Type Description <code>_bboxes</code> <code>Bboxes</code> <p>Internal object for handling bounding box operations.</p> <code>keypoints</code> <code>ndarray</code> <p>keypoints(x, y, visible) with shape [N, 17, 3]. Default is None.</p> <code>normalized</code> <code>bool</code> <p>Flag indicating whether the bounding box coordinates are normalized.</p> <code>segments</code> <code>ndarray</code> <p>Segments array with shape [N, 1000, 2] after resampling.</p> <p>Parameters:</p> Name Type Description Default <code>bboxes</code> <code>ndarray</code> <p>An array of bounding boxes with shape [N, 4].</p> required <code>segments</code> <code>list | ndarray</code> <p>A list or array of object segments. Default is None.</p> <code>None</code> <code>keypoints</code> <code>ndarray</code> <p>An array of keypoints with shape [N, 17, 3]. Default is None.</p> <code>None</code> <code>bbox_format</code> <code>str</code> <p>The format of bounding boxes ('xywh' or 'xyxy'). Default is 'xywh'.</p> <code>'xywh'</code> <code>normalized</code> <code>bool</code> <p>Whether the bounding box coordinates are normalized. Default is True.</p> <code>True</code> <p>Examples:</p> <pre><code># Create an Instances object\ninstances = Instances(\n    bboxes=np.array([[10, 10, 30, 30], [20, 20, 40, 40]]),\n    segments=[np.array([[5, 5], [10, 10]]), np.array([[15, 15], [20, 20]])],\n    keypoints=np.array([[[5, 5, 1], [10, 10, 1]], [[15, 15, 1], [20, 20, 1]]])\n)\n</code></pre> Note <p>The bounding box format is either 'xywh' or 'xyxy', and is determined by the <code>bbox_format</code> argument. This class does not perform input validation, and it assumes the inputs are well-formed.</p> Source code in <code>ultralytics/utils/instance.py</code> <pre><code>class Instances:\n    \"\"\"\n    Container for bounding boxes, segments, and keypoints of detected objects in an image.\n\n    Attributes:\n        _bboxes (Bboxes): Internal object for handling bounding box operations.\n        keypoints (ndarray): keypoints(x, y, visible) with shape [N, 17, 3]. Default is None.\n        normalized (bool): Flag indicating whether the bounding box coordinates are normalized.\n        segments (ndarray): Segments array with shape [N, 1000, 2] after resampling.\n\n    Args:\n        bboxes (ndarray): An array of bounding boxes with shape [N, 4].\n        segments (list | ndarray, optional): A list or array of object segments. Default is None.\n        keypoints (ndarray, optional): An array of keypoints with shape [N, 17, 3]. Default is None.\n        bbox_format (str, optional): The format of bounding boxes ('xywh' or 'xyxy'). Default is 'xywh'.\n        normalized (bool, optional): Whether the bounding box coordinates are normalized. Default is True.\n\n    Examples:\n        ```python\n        # Create an Instances object\n        instances = Instances(\n            bboxes=np.array([[10, 10, 30, 30], [20, 20, 40, 40]]),\n            segments=[np.array([[5, 5], [10, 10]]), np.array([[15, 15], [20, 20]])],\n            keypoints=np.array([[[5, 5, 1], [10, 10, 1]], [[15, 15, 1], [20, 20, 1]]])\n        )\n        ```\n\n    Note:\n        The bounding box format is either 'xywh' or 'xyxy', and is determined by the `bbox_format` argument.\n        This class does not perform input validation, and it assumes the inputs are well-formed.\n    \"\"\"\n\n    def __init__(self, bboxes, segments=None, keypoints=None, bbox_format=\"xywh\", normalized=True) -&gt; None:\n        \"\"\"\n        Args:\n            bboxes (ndarray): bboxes with shape [N, 4].\n            segments (list | ndarray): segments.\n            keypoints (ndarray): keypoints(x, y, visible) with shape [N, 17, 3].\n        \"\"\"\n        self._bboxes = Bboxes(bboxes=bboxes, format=bbox_format)\n        self.keypoints = keypoints\n        self.normalized = normalized\n        self.segments = segments\n\n    def convert_bbox(self, format):\n        \"\"\"Convert bounding box format.\"\"\"\n        self._bboxes.convert(format=format)\n\n    @property\n    def bbox_areas(self):\n        \"\"\"Calculate the area of bounding boxes.\"\"\"\n        return self._bboxes.areas()\n\n    def scale(self, scale_w, scale_h, bbox_only=False):\n        \"\"\"This might be similar with denormalize func but without normalized sign.\"\"\"\n        self._bboxes.mul(scale=(scale_w, scale_h, scale_w, scale_h))\n        if bbox_only:\n            return\n        self.segments[..., 0] *= scale_w\n        self.segments[..., 1] *= scale_h\n        if self.keypoints is not None:\n            self.keypoints[..., 0] *= scale_w\n            self.keypoints[..., 1] *= scale_h\n\n    def denormalize(self, w, h):\n        \"\"\"Denormalizes boxes, segments, and keypoints from normalized coordinates.\"\"\"\n        if not self.normalized:\n            return\n        self._bboxes.mul(scale=(w, h, w, h))\n        self.segments[..., 0] *= w\n        self.segments[..., 1] *= h\n        if self.keypoints is not None:\n            self.keypoints[..., 0] *= w\n            self.keypoints[..., 1] *= h\n        self.normalized = False\n\n    def normalize(self, w, h):\n        \"\"\"Normalize bounding boxes, segments, and keypoints to image dimensions.\"\"\"\n        if self.normalized:\n            return\n        self._bboxes.mul(scale=(1 / w, 1 / h, 1 / w, 1 / h))\n        self.segments[..., 0] /= w\n        self.segments[..., 1] /= h\n        if self.keypoints is not None:\n            self.keypoints[..., 0] /= w\n            self.keypoints[..., 1] /= h\n        self.normalized = True\n\n    def add_padding(self, padw, padh):\n        \"\"\"Handle rect and mosaic situation.\"\"\"\n        assert not self.normalized, \"you should add padding with absolute coordinates.\"\n        self._bboxes.add(offset=(padw, padh, padw, padh))\n        self.segments[..., 0] += padw\n        self.segments[..., 1] += padh\n        if self.keypoints is not None:\n            self.keypoints[..., 0] += padw\n            self.keypoints[..., 1] += padh\n\n    def __getitem__(self, index) -&gt; \"Instances\":\n        \"\"\"\n        Retrieve a specific instance or a set of instances using indexing.\n\n        Args:\n            index (int, slice, or np.ndarray): The index, slice, or boolean array to select\n                                               the desired instances.\n\n        Returns:\n            Instances: A new Instances object containing the selected bounding boxes,\n                       segments, and keypoints if present.\n\n        Note:\n            When using boolean indexing, make sure to provide a boolean array with the same\n            length as the number of instances.\n        \"\"\"\n        segments = self.segments[index] if len(self.segments) else self.segments\n        keypoints = self.keypoints[index] if self.keypoints is not None else None\n        bboxes = self.bboxes[index]\n        bbox_format = self._bboxes.format\n        return Instances(\n            bboxes=bboxes,\n            segments=segments,\n            keypoints=keypoints,\n            bbox_format=bbox_format,\n            normalized=self.normalized,\n        )\n\n    def flipud(self, h):\n        \"\"\"Flips the coordinates of bounding boxes, segments, and keypoints vertically.\"\"\"\n        if self._bboxes.format == \"xyxy\":\n            y1 = self.bboxes[:, 1].copy()\n            y2 = self.bboxes[:, 3].copy()\n            self.bboxes[:, 1] = h - y2\n            self.bboxes[:, 3] = h - y1\n        else:\n            self.bboxes[:, 1] = h - self.bboxes[:, 1]\n        self.segments[..., 1] = h - self.segments[..., 1]\n        if self.keypoints is not None:\n            self.keypoints[..., 1] = h - self.keypoints[..., 1]\n\n    def fliplr(self, w):\n        \"\"\"Reverses the order of the bounding boxes and segments horizontally.\"\"\"\n        if self._bboxes.format == \"xyxy\":\n            x1 = self.bboxes[:, 0].copy()\n            x2 = self.bboxes[:, 2].copy()\n            self.bboxes[:, 0] = w - x2\n            self.bboxes[:, 2] = w - x1\n        else:\n            self.bboxes[:, 0] = w - self.bboxes[:, 0]\n        self.segments[..., 0] = w - self.segments[..., 0]\n        if self.keypoints is not None:\n            self.keypoints[..., 0] = w - self.keypoints[..., 0]\n\n    def clip(self, w, h):\n        \"\"\"Clips bounding boxes, segments, and keypoints values to stay within image boundaries.\"\"\"\n        ori_format = self._bboxes.format\n        self.convert_bbox(format=\"xyxy\")\n        self.bboxes[:, [0, 2]] = self.bboxes[:, [0, 2]].clip(0, w)\n        self.bboxes[:, [1, 3]] = self.bboxes[:, [1, 3]].clip(0, h)\n        if ori_format != \"xyxy\":\n            self.convert_bbox(format=ori_format)\n        self.segments[..., 0] = self.segments[..., 0].clip(0, w)\n        self.segments[..., 1] = self.segments[..., 1].clip(0, h)\n        if self.keypoints is not None:\n            self.keypoints[..., 0] = self.keypoints[..., 0].clip(0, w)\n            self.keypoints[..., 1] = self.keypoints[..., 1].clip(0, h)\n\n    def remove_zero_area_boxes(self):\n        \"\"\"\n        Remove zero-area boxes, i.e. after clipping some boxes may have zero width or height.\n\n        This removes them.\n        \"\"\"\n        good = self.bbox_areas &gt; 0\n        if not all(good):\n            self._bboxes = self._bboxes[good]\n            if len(self.segments):\n                self.segments = self.segments[good]\n            if self.keypoints is not None:\n                self.keypoints = self.keypoints[good]\n        return good\n\n    def update(self, bboxes, segments=None, keypoints=None):\n        \"\"\"Updates instance variables.\"\"\"\n        self._bboxes = Bboxes(bboxes, format=self._bboxes.format)\n        if segments is not None:\n            self.segments = segments\n        if keypoints is not None:\n            self.keypoints = keypoints\n\n    def __len__(self):\n        \"\"\"Return the length of the instance list.\"\"\"\n        return len(self.bboxes)\n\n    @classmethod\n    def concatenate(cls, instances_list: List[\"Instances\"], axis=0) -&gt; \"Instances\":\n        \"\"\"\n        Concatenates a list of Instances objects into a single Instances object.\n\n        Args:\n            instances_list (List[Instances]): A list of Instances objects to concatenate.\n            axis (int, optional): The axis along which the arrays will be concatenated. Defaults to 0.\n\n        Returns:\n            Instances: A new Instances object containing the concatenated bounding boxes,\n                       segments, and keypoints if present.\n\n        Note:\n            The `Instances` objects in the list should have the same properties, such as\n            the format of the bounding boxes, whether keypoints are present, and if the\n            coordinates are normalized.\n        \"\"\"\n        assert isinstance(instances_list, (list, tuple))\n        if not instances_list:\n            return cls(np.empty(0))\n        assert all(isinstance(instance, Instances) for instance in instances_list)\n\n        if len(instances_list) == 1:\n            return instances_list[0]\n\n        use_keypoint = instances_list[0].keypoints is not None\n        bbox_format = instances_list[0]._bboxes.format\n        normalized = instances_list[0].normalized\n\n        cat_boxes = np.concatenate([ins.bboxes for ins in instances_list], axis=axis)\n        cat_segments = np.concatenate([b.segments for b in instances_list], axis=axis)\n        cat_keypoints = np.concatenate([b.keypoints for b in instances_list], axis=axis) if use_keypoint else None\n        return cls(cat_boxes, cat_segments, cat_keypoints, bbox_format, normalized)\n\n    @property\n    def bboxes(self):\n        \"\"\"Return bounding boxes.\"\"\"\n        return self._bboxes.bboxes\n</code></pre>"},{"location":"reference/utils/instance/#ultralytics.utils.instance.Instances.bbox_areas","title":"<code>bbox_areas</code>  <code>property</code>","text":"<p>Calculate the area of bounding boxes.</p>"},{"location":"reference/utils/instance/#ultralytics.utils.instance.Instances.bboxes","title":"<code>bboxes</code>  <code>property</code>","text":"<p>Return bounding boxes.</p>"},{"location":"reference/utils/instance/#ultralytics.utils.instance.Instances.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Retrieve a specific instance or a set of instances using indexing.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int, slice, or np.ndarray</code> <p>The index, slice, or boolean array to select                                the desired instances.</p> required <p>Returns:</p> Name Type Description <code>Instances</code> <code>Instances</code> <p>A new Instances object containing the selected bounding boxes,        segments, and keypoints if present.</p> Note <p>When using boolean indexing, make sure to provide a boolean array with the same length as the number of instances.</p> Source code in <code>ultralytics/utils/instance.py</code> <pre><code>def __getitem__(self, index) -&gt; \"Instances\":\n    \"\"\"\n    Retrieve a specific instance or a set of instances using indexing.\n\n    Args:\n        index (int, slice, or np.ndarray): The index, slice, or boolean array to select\n                                           the desired instances.\n\n    Returns:\n        Instances: A new Instances object containing the selected bounding boxes,\n                   segments, and keypoints if present.\n\n    Note:\n        When using boolean indexing, make sure to provide a boolean array with the same\n        length as the number of instances.\n    \"\"\"\n    segments = self.segments[index] if len(self.segments) else self.segments\n    keypoints = self.keypoints[index] if self.keypoints is not None else None\n    bboxes = self.bboxes[index]\n    bbox_format = self._bboxes.format\n    return Instances(\n        bboxes=bboxes,\n        segments=segments,\n        keypoints=keypoints,\n        bbox_format=bbox_format,\n        normalized=self.normalized,\n    )\n</code></pre>"},{"location":"reference/utils/instance/#ultralytics.utils.instance.Instances.__init__","title":"<code>__init__(bboxes, segments=None, keypoints=None, bbox_format='xywh', normalized=True)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>bboxes</code> <code>ndarray</code> <p>bboxes with shape [N, 4].</p> required <code>segments</code> <code>list | ndarray</code> <p>segments.</p> <code>None</code> <code>keypoints</code> <code>ndarray</code> <p>keypoints(x, y, visible) with shape [N, 17, 3].</p> <code>None</code> Source code in <code>ultralytics/utils/instance.py</code> <pre><code>def __init__(self, bboxes, segments=None, keypoints=None, bbox_format=\"xywh\", normalized=True) -&gt; None:\n    \"\"\"\n    Args:\n        bboxes (ndarray): bboxes with shape [N, 4].\n        segments (list | ndarray): segments.\n        keypoints (ndarray): keypoints(x, y, visible) with shape [N, 17, 3].\n    \"\"\"\n    self._bboxes = Bboxes(bboxes=bboxes, format=bbox_format)\n    self.keypoints = keypoints\n    self.normalized = normalized\n    self.segments = segments\n</code></pre>"},{"location":"reference/utils/instance/#ultralytics.utils.instance.Instances.__len__","title":"<code>__len__()</code>","text":"<p>Return the length of the instance list.</p> Source code in <code>ultralytics/utils/instance.py</code> <pre><code>def __len__(self):\n    \"\"\"Return the length of the instance list.\"\"\"\n    return len(self.bboxes)\n</code></pre>"},{"location":"reference/utils/instance/#ultralytics.utils.instance.Instances.add_padding","title":"<code>add_padding(padw, padh)</code>","text":"<p>Handle rect and mosaic situation.</p> Source code in <code>ultralytics/utils/instance.py</code> <pre><code>def add_padding(self, padw, padh):\n    \"\"\"Handle rect and mosaic situation.\"\"\"\n    assert not self.normalized, \"you should add padding with absolute coordinates.\"\n    self._bboxes.add(offset=(padw, padh, padw, padh))\n    self.segments[..., 0] += padw\n    self.segments[..., 1] += padh\n    if self.keypoints is not None:\n        self.keypoints[..., 0] += padw\n        self.keypoints[..., 1] += padh\n</code></pre>"},{"location":"reference/utils/instance/#ultralytics.utils.instance.Instances.clip","title":"<code>clip(w, h)</code>","text":"<p>Clips bounding boxes, segments, and keypoints values to stay within image boundaries.</p> Source code in <code>ultralytics/utils/instance.py</code> <pre><code>def clip(self, w, h):\n    \"\"\"Clips bounding boxes, segments, and keypoints values to stay within image boundaries.\"\"\"\n    ori_format = self._bboxes.format\n    self.convert_bbox(format=\"xyxy\")\n    self.bboxes[:, [0, 2]] = self.bboxes[:, [0, 2]].clip(0, w)\n    self.bboxes[:, [1, 3]] = self.bboxes[:, [1, 3]].clip(0, h)\n    if ori_format != \"xyxy\":\n        self.convert_bbox(format=ori_format)\n    self.segments[..., 0] = self.segments[..., 0].clip(0, w)\n    self.segments[..., 1] = self.segments[..., 1].clip(0, h)\n    if self.keypoints is not None:\n        self.keypoints[..., 0] = self.keypoints[..., 0].clip(0, w)\n        self.keypoints[..., 1] = self.keypoints[..., 1].clip(0, h)\n</code></pre>"},{"location":"reference/utils/instance/#ultralytics.utils.instance.Instances.concatenate","title":"<code>concatenate(instances_list, axis=0)</code>  <code>classmethod</code>","text":"<p>Concatenates a list of Instances objects into a single Instances object.</p> <p>Parameters:</p> Name Type Description Default <code>instances_list</code> <code>List[Instances]</code> <p>A list of Instances objects to concatenate.</p> required <code>axis</code> <code>int</code> <p>The axis along which the arrays will be concatenated. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>Instances</code> <code>Instances</code> <p>A new Instances object containing the concatenated bounding boxes,        segments, and keypoints if present.</p> Note <p>The <code>Instances</code> objects in the list should have the same properties, such as the format of the bounding boxes, whether keypoints are present, and if the coordinates are normalized.</p> Source code in <code>ultralytics/utils/instance.py</code> <pre><code>@classmethod\ndef concatenate(cls, instances_list: List[\"Instances\"], axis=0) -&gt; \"Instances\":\n    \"\"\"\n    Concatenates a list of Instances objects into a single Instances object.\n\n    Args:\n        instances_list (List[Instances]): A list of Instances objects to concatenate.\n        axis (int, optional): The axis along which the arrays will be concatenated. Defaults to 0.\n\n    Returns:\n        Instances: A new Instances object containing the concatenated bounding boxes,\n                   segments, and keypoints if present.\n\n    Note:\n        The `Instances` objects in the list should have the same properties, such as\n        the format of the bounding boxes, whether keypoints are present, and if the\n        coordinates are normalized.\n    \"\"\"\n    assert isinstance(instances_list, (list, tuple))\n    if not instances_list:\n        return cls(np.empty(0))\n    assert all(isinstance(instance, Instances) for instance in instances_list)\n\n    if len(instances_list) == 1:\n        return instances_list[0]\n\n    use_keypoint = instances_list[0].keypoints is not None\n    bbox_format = instances_list[0]._bboxes.format\n    normalized = instances_list[0].normalized\n\n    cat_boxes = np.concatenate([ins.bboxes for ins in instances_list], axis=axis)\n    cat_segments = np.concatenate([b.segments for b in instances_list], axis=axis)\n    cat_keypoints = np.concatenate([b.keypoints for b in instances_list], axis=axis) if use_keypoint else None\n    return cls(cat_boxes, cat_segments, cat_keypoints, bbox_format, normalized)\n</code></pre>"},{"location":"reference/utils/instance/#ultralytics.utils.instance.Instances.convert_bbox","title":"<code>convert_bbox(format)</code>","text":"<p>Convert bounding box format.</p> Source code in <code>ultralytics/utils/instance.py</code> <pre><code>def convert_bbox(self, format):\n    \"\"\"Convert bounding box format.\"\"\"\n    self._bboxes.convert(format=format)\n</code></pre>"},{"location":"reference/utils/instance/#ultralytics.utils.instance.Instances.denormalize","title":"<code>denormalize(w, h)</code>","text":"<p>Denormalizes boxes, segments, and keypoints from normalized coordinates.</p> Source code in <code>ultralytics/utils/instance.py</code> <pre><code>def denormalize(self, w, h):\n    \"\"\"Denormalizes boxes, segments, and keypoints from normalized coordinates.\"\"\"\n    if not self.normalized:\n        return\n    self._bboxes.mul(scale=(w, h, w, h))\n    self.segments[..., 0] *= w\n    self.segments[..., 1] *= h\n    if self.keypoints is not None:\n        self.keypoints[..., 0] *= w\n        self.keypoints[..., 1] *= h\n    self.normalized = False\n</code></pre>"},{"location":"reference/utils/instance/#ultralytics.utils.instance.Instances.fliplr","title":"<code>fliplr(w)</code>","text":"<p>Reverses the order of the bounding boxes and segments horizontally.</p> Source code in <code>ultralytics/utils/instance.py</code> <pre><code>def fliplr(self, w):\n    \"\"\"Reverses the order of the bounding boxes and segments horizontally.\"\"\"\n    if self._bboxes.format == \"xyxy\":\n        x1 = self.bboxes[:, 0].copy()\n        x2 = self.bboxes[:, 2].copy()\n        self.bboxes[:, 0] = w - x2\n        self.bboxes[:, 2] = w - x1\n    else:\n        self.bboxes[:, 0] = w - self.bboxes[:, 0]\n    self.segments[..., 0] = w - self.segments[..., 0]\n    if self.keypoints is not None:\n        self.keypoints[..., 0] = w - self.keypoints[..., 0]\n</code></pre>"},{"location":"reference/utils/instance/#ultralytics.utils.instance.Instances.flipud","title":"<code>flipud(h)</code>","text":"<p>Flips the coordinates of bounding boxes, segments, and keypoints vertically.</p> Source code in <code>ultralytics/utils/instance.py</code> <pre><code>def flipud(self, h):\n    \"\"\"Flips the coordinates of bounding boxes, segments, and keypoints vertically.\"\"\"\n    if self._bboxes.format == \"xyxy\":\n        y1 = self.bboxes[:, 1].copy()\n        y2 = self.bboxes[:, 3].copy()\n        self.bboxes[:, 1] = h - y2\n        self.bboxes[:, 3] = h - y1\n    else:\n        self.bboxes[:, 1] = h - self.bboxes[:, 1]\n    self.segments[..., 1] = h - self.segments[..., 1]\n    if self.keypoints is not None:\n        self.keypoints[..., 1] = h - self.keypoints[..., 1]\n</code></pre>"},{"location":"reference/utils/instance/#ultralytics.utils.instance.Instances.normalize","title":"<code>normalize(w, h)</code>","text":"<p>Normalize bounding boxes, segments, and keypoints to image dimensions.</p> Source code in <code>ultralytics/utils/instance.py</code> <pre><code>def normalize(self, w, h):\n    \"\"\"Normalize bounding boxes, segments, and keypoints to image dimensions.\"\"\"\n    if self.normalized:\n        return\n    self._bboxes.mul(scale=(1 / w, 1 / h, 1 / w, 1 / h))\n    self.segments[..., 0] /= w\n    self.segments[..., 1] /= h\n    if self.keypoints is not None:\n        self.keypoints[..., 0] /= w\n        self.keypoints[..., 1] /= h\n    self.normalized = True\n</code></pre>"},{"location":"reference/utils/instance/#ultralytics.utils.instance.Instances.remove_zero_area_boxes","title":"<code>remove_zero_area_boxes()</code>","text":"<p>Remove zero-area boxes, i.e. after clipping some boxes may have zero width or height.</p> <p>This removes them.</p> Source code in <code>ultralytics/utils/instance.py</code> <pre><code>def remove_zero_area_boxes(self):\n    \"\"\"\n    Remove zero-area boxes, i.e. after clipping some boxes may have zero width or height.\n\n    This removes them.\n    \"\"\"\n    good = self.bbox_areas &gt; 0\n    if not all(good):\n        self._bboxes = self._bboxes[good]\n        if len(self.segments):\n            self.segments = self.segments[good]\n        if self.keypoints is not None:\n            self.keypoints = self.keypoints[good]\n    return good\n</code></pre>"},{"location":"reference/utils/instance/#ultralytics.utils.instance.Instances.scale","title":"<code>scale(scale_w, scale_h, bbox_only=False)</code>","text":"<p>This might be similar with denormalize func but without normalized sign.</p> Source code in <code>ultralytics/utils/instance.py</code> <pre><code>def scale(self, scale_w, scale_h, bbox_only=False):\n    \"\"\"This might be similar with denormalize func but without normalized sign.\"\"\"\n    self._bboxes.mul(scale=(scale_w, scale_h, scale_w, scale_h))\n    if bbox_only:\n        return\n    self.segments[..., 0] *= scale_w\n    self.segments[..., 1] *= scale_h\n    if self.keypoints is not None:\n        self.keypoints[..., 0] *= scale_w\n        self.keypoints[..., 1] *= scale_h\n</code></pre>"},{"location":"reference/utils/instance/#ultralytics.utils.instance.Instances.update","title":"<code>update(bboxes, segments=None, keypoints=None)</code>","text":"<p>Updates instance variables.</p> Source code in <code>ultralytics/utils/instance.py</code> <pre><code>def update(self, bboxes, segments=None, keypoints=None):\n    \"\"\"Updates instance variables.\"\"\"\n    self._bboxes = Bboxes(bboxes, format=self._bboxes.format)\n    if segments is not None:\n        self.segments = segments\n    if keypoints is not None:\n        self.keypoints = keypoints\n</code></pre>"},{"location":"reference/utils/instance/#ultralytics.utils.instance._ntuple","title":"<code>ultralytics.utils.instance._ntuple(n)</code>","text":"<p>From PyTorch internals.</p> Source code in <code>ultralytics/utils/instance.py</code> <pre><code>def _ntuple(n):\n    \"\"\"From PyTorch internals.\"\"\"\n\n    def parse(x):\n        \"\"\"Parse bounding boxes format between XYWH and LTWH.\"\"\"\n        return x if isinstance(x, abc.Iterable) else tuple(repeat(x, n))\n\n    return parse\n</code></pre>"},{"location":"reference/utils/loss/","title":"Reference for <code>ultralytics/utils/loss.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/loss.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.VarifocalLoss","title":"<code>ultralytics.utils.loss.VarifocalLoss</code>","text":"<p>             Bases: <code>Module</code></p> <p>Varifocal loss by Zhang et al.</p> <p>https://arxiv.org/abs/2008.13367.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>class VarifocalLoss(nn.Module):\n    \"\"\"\n    Varifocal loss by Zhang et al.\n\n    https://arxiv.org/abs/2008.13367.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the VarifocalLoss class.\"\"\"\n        super().__init__()\n\n    @staticmethod\n    def forward(pred_score, gt_score, label, alpha=0.75, gamma=2.0):\n        \"\"\"Computes varfocal loss.\"\"\"\n        weight = alpha * pred_score.sigmoid().pow(gamma) * (1 - label) + gt_score * label\n        with torch.cuda.amp.autocast(enabled=False):\n            loss = (\n                (F.binary_cross_entropy_with_logits(pred_score.float(), gt_score.float(), reduction=\"none\") * weight)\n                .mean(1)\n                .sum()\n            )\n        return loss\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.VarifocalLoss.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the VarifocalLoss class.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the VarifocalLoss class.\"\"\"\n    super().__init__()\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.VarifocalLoss.forward","title":"<code>forward(pred_score, gt_score, label, alpha=0.75, gamma=2.0)</code>  <code>staticmethod</code>","text":"<p>Computes varfocal loss.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>@staticmethod\ndef forward(pred_score, gt_score, label, alpha=0.75, gamma=2.0):\n    \"\"\"Computes varfocal loss.\"\"\"\n    weight = alpha * pred_score.sigmoid().pow(gamma) * (1 - label) + gt_score * label\n    with torch.cuda.amp.autocast(enabled=False):\n        loss = (\n            (F.binary_cross_entropy_with_logits(pred_score.float(), gt_score.float(), reduction=\"none\") * weight)\n            .mean(1)\n            .sum()\n        )\n    return loss\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.FocalLoss","title":"<code>ultralytics.utils.loss.FocalLoss</code>","text":"<p>             Bases: <code>Module</code></p> <p>Wraps focal loss around existing loss_fcn(), i.e. criteria = FocalLoss(nn.BCEWithLogitsLoss(), gamma=1.5).</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>class FocalLoss(nn.Module):\n    \"\"\"Wraps focal loss around existing loss_fcn(), i.e. criteria = FocalLoss(nn.BCEWithLogitsLoss(), gamma=1.5).\"\"\"\n\n    def __init__(\n        self,\n    ):\n        \"\"\"Initializer for FocalLoss class with no parameters.\"\"\"\n        super().__init__()\n\n    @staticmethod\n    def forward(pred, label, gamma=1.5, alpha=0.25):\n        \"\"\"Calculates and updates confusion matrix for object detection/classification tasks.\"\"\"\n        loss = F.binary_cross_entropy_with_logits(pred, label, reduction=\"none\")\n        # p_t = torch.exp(-loss)\n        # loss *= self.alpha * (1.000001 - p_t) ** self.gamma  # non-zero power for gradient stability\n\n        # TF implementation https://github.com/tensorflow/addons/blob/v0.7.1/tensorflow_addons/losses/focal_loss.py\n        pred_prob = pred.sigmoid()  # prob from logits\n        p_t = label * pred_prob + (1 - label) * (1 - pred_prob)\n        modulating_factor = (1.0 - p_t) ** gamma\n        loss *= modulating_factor\n        if alpha &gt; 0:\n            alpha_factor = label * alpha + (1 - label) * (1 - alpha)\n            loss *= alpha_factor\n        return loss.mean(1).sum()\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.FocalLoss.__init__","title":"<code>__init__()</code>","text":"<p>Initializer for FocalLoss class with no parameters.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>def __init__(\n    self,\n):\n    \"\"\"Initializer for FocalLoss class with no parameters.\"\"\"\n    super().__init__()\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.FocalLoss.forward","title":"<code>forward(pred, label, gamma=1.5, alpha=0.25)</code>  <code>staticmethod</code>","text":"<p>Calculates and updates confusion matrix for object detection/classification tasks.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>@staticmethod\ndef forward(pred, label, gamma=1.5, alpha=0.25):\n    \"\"\"Calculates and updates confusion matrix for object detection/classification tasks.\"\"\"\n    loss = F.binary_cross_entropy_with_logits(pred, label, reduction=\"none\")\n    # p_t = torch.exp(-loss)\n    # loss *= self.alpha * (1.000001 - p_t) ** self.gamma  # non-zero power for gradient stability\n\n    # TF implementation https://github.com/tensorflow/addons/blob/v0.7.1/tensorflow_addons/losses/focal_loss.py\n    pred_prob = pred.sigmoid()  # prob from logits\n    p_t = label * pred_prob + (1 - label) * (1 - pred_prob)\n    modulating_factor = (1.0 - p_t) ** gamma\n    loss *= modulating_factor\n    if alpha &gt; 0:\n        alpha_factor = label * alpha + (1 - label) * (1 - alpha)\n        loss *= alpha_factor\n    return loss.mean(1).sum()\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.BboxLoss","title":"<code>ultralytics.utils.loss.BboxLoss</code>","text":"<p>             Bases: <code>Module</code></p> <p>Criterion class for computing training losses during training.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>class BboxLoss(nn.Module):\n    \"\"\"Criterion class for computing training losses during training.\"\"\"\n\n    def __init__(self, reg_max, use_dfl=False):\n        \"\"\"Initialize the BboxLoss module with regularization maximum and DFL settings.\"\"\"\n        super().__init__()\n        self.reg_max = reg_max\n        self.use_dfl = use_dfl\n\n    def forward(self, pred_dist, pred_bboxes, anchor_points, target_bboxes, target_scores, target_scores_sum, fg_mask):\n        \"\"\"IoU loss.\"\"\"\n        weight = target_scores.sum(-1)[fg_mask].unsqueeze(-1)\n        iou = bbox_iou(pred_bboxes[fg_mask], target_bboxes[fg_mask], xywh=False, CIoU=True)\n        loss_iou = ((1.0 - iou) * weight).sum() / target_scores_sum\n\n        # DFL loss\n        if self.use_dfl:\n            target_ltrb = bbox2dist(anchor_points, target_bboxes, self.reg_max)\n            loss_dfl = self._df_loss(pred_dist[fg_mask].view(-1, self.reg_max + 1), target_ltrb[fg_mask]) * weight\n            loss_dfl = loss_dfl.sum() / target_scores_sum\n        else:\n            loss_dfl = torch.tensor(0.0).to(pred_dist.device)\n\n        return loss_iou, loss_dfl\n\n    @staticmethod\n    def _df_loss(pred_dist, target):\n        \"\"\"Return sum of left and right DFL losses.\"\"\"\n        # Distribution Focal Loss (DFL) proposed in Generalized Focal Loss https://ieeexplore.ieee.org/document/9792391\n        tl = target.long()  # target left\n        tr = tl + 1  # target right\n        wl = tr - target  # weight left\n        wr = 1 - wl  # weight right\n        return (\n            F.cross_entropy(pred_dist, tl.view(-1), reduction=\"none\").view(tl.shape) * wl\n            + F.cross_entropy(pred_dist, tr.view(-1), reduction=\"none\").view(tl.shape) * wr\n        ).mean(-1, keepdim=True)\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.BboxLoss.__init__","title":"<code>__init__(reg_max, use_dfl=False)</code>","text":"<p>Initialize the BboxLoss module with regularization maximum and DFL settings.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>def __init__(self, reg_max, use_dfl=False):\n    \"\"\"Initialize the BboxLoss module with regularization maximum and DFL settings.\"\"\"\n    super().__init__()\n    self.reg_max = reg_max\n    self.use_dfl = use_dfl\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.BboxLoss.forward","title":"<code>forward(pred_dist, pred_bboxes, anchor_points, target_bboxes, target_scores, target_scores_sum, fg_mask)</code>","text":"<p>IoU loss.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>def forward(self, pred_dist, pred_bboxes, anchor_points, target_bboxes, target_scores, target_scores_sum, fg_mask):\n    \"\"\"IoU loss.\"\"\"\n    weight = target_scores.sum(-1)[fg_mask].unsqueeze(-1)\n    iou = bbox_iou(pred_bboxes[fg_mask], target_bboxes[fg_mask], xywh=False, CIoU=True)\n    loss_iou = ((1.0 - iou) * weight).sum() / target_scores_sum\n\n    # DFL loss\n    if self.use_dfl:\n        target_ltrb = bbox2dist(anchor_points, target_bboxes, self.reg_max)\n        loss_dfl = self._df_loss(pred_dist[fg_mask].view(-1, self.reg_max + 1), target_ltrb[fg_mask]) * weight\n        loss_dfl = loss_dfl.sum() / target_scores_sum\n    else:\n        loss_dfl = torch.tensor(0.0).to(pred_dist.device)\n\n    return loss_iou, loss_dfl\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.RotatedBboxLoss","title":"<code>ultralytics.utils.loss.RotatedBboxLoss</code>","text":"<p>             Bases: <code>BboxLoss</code></p> <p>Criterion class for computing training losses during training.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>class RotatedBboxLoss(BboxLoss):\n    \"\"\"Criterion class for computing training losses during training.\"\"\"\n\n    def __init__(self, reg_max, use_dfl=False):\n        \"\"\"Initialize the BboxLoss module with regularization maximum and DFL settings.\"\"\"\n        super().__init__(reg_max, use_dfl)\n\n    def forward(self, pred_dist, pred_bboxes, anchor_points, target_bboxes, target_scores, target_scores_sum, fg_mask):\n        \"\"\"IoU loss.\"\"\"\n        weight = target_scores.sum(-1)[fg_mask].unsqueeze(-1)\n        iou = probiou(pred_bboxes[fg_mask], target_bboxes[fg_mask])\n        loss_iou = ((1.0 - iou) * weight).sum() / target_scores_sum\n\n        # DFL loss\n        if self.use_dfl:\n            target_ltrb = bbox2dist(anchor_points, xywh2xyxy(target_bboxes[..., :4]), self.reg_max)\n            loss_dfl = self._df_loss(pred_dist[fg_mask].view(-1, self.reg_max + 1), target_ltrb[fg_mask]) * weight\n            loss_dfl = loss_dfl.sum() / target_scores_sum\n        else:\n            loss_dfl = torch.tensor(0.0).to(pred_dist.device)\n\n        return loss_iou, loss_dfl\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.RotatedBboxLoss.__init__","title":"<code>__init__(reg_max, use_dfl=False)</code>","text":"<p>Initialize the BboxLoss module with regularization maximum and DFL settings.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>def __init__(self, reg_max, use_dfl=False):\n    \"\"\"Initialize the BboxLoss module with regularization maximum and DFL settings.\"\"\"\n    super().__init__(reg_max, use_dfl)\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.RotatedBboxLoss.forward","title":"<code>forward(pred_dist, pred_bboxes, anchor_points, target_bboxes, target_scores, target_scores_sum, fg_mask)</code>","text":"<p>IoU loss.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>def forward(self, pred_dist, pred_bboxes, anchor_points, target_bboxes, target_scores, target_scores_sum, fg_mask):\n    \"\"\"IoU loss.\"\"\"\n    weight = target_scores.sum(-1)[fg_mask].unsqueeze(-1)\n    iou = probiou(pred_bboxes[fg_mask], target_bboxes[fg_mask])\n    loss_iou = ((1.0 - iou) * weight).sum() / target_scores_sum\n\n    # DFL loss\n    if self.use_dfl:\n        target_ltrb = bbox2dist(anchor_points, xywh2xyxy(target_bboxes[..., :4]), self.reg_max)\n        loss_dfl = self._df_loss(pred_dist[fg_mask].view(-1, self.reg_max + 1), target_ltrb[fg_mask]) * weight\n        loss_dfl = loss_dfl.sum() / target_scores_sum\n    else:\n        loss_dfl = torch.tensor(0.0).to(pred_dist.device)\n\n    return loss_iou, loss_dfl\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.KeypointLoss","title":"<code>ultralytics.utils.loss.KeypointLoss</code>","text":"<p>             Bases: <code>Module</code></p> <p>Criterion class for computing training losses.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>class KeypointLoss(nn.Module):\n    \"\"\"Criterion class for computing training losses.\"\"\"\n\n    def __init__(self, sigmas) -&gt; None:\n        \"\"\"Initialize the KeypointLoss class.\"\"\"\n        super().__init__()\n        self.sigmas = sigmas\n\n    def forward(self, pred_kpts, gt_kpts, kpt_mask, area):\n        \"\"\"Calculates keypoint loss factor and Euclidean distance loss for predicted and actual keypoints.\"\"\"\n        d = (pred_kpts[..., 0] - gt_kpts[..., 0]) ** 2 + (pred_kpts[..., 1] - gt_kpts[..., 1]) ** 2\n        kpt_loss_factor = kpt_mask.shape[1] / (torch.sum(kpt_mask != 0, dim=1) + 1e-9)\n        # e = d / (2 * (area * self.sigmas) ** 2 + 1e-9)  # from formula\n        e = d / (2 * self.sigmas) ** 2 / (area + 1e-9) / 2  # from cocoeval\n        return (kpt_loss_factor.view(-1, 1) * ((1 - torch.exp(-e)) * kpt_mask)).mean()\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.KeypointLoss.__init__","title":"<code>__init__(sigmas)</code>","text":"<p>Initialize the KeypointLoss class.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>def __init__(self, sigmas) -&gt; None:\n    \"\"\"Initialize the KeypointLoss class.\"\"\"\n    super().__init__()\n    self.sigmas = sigmas\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.KeypointLoss.forward","title":"<code>forward(pred_kpts, gt_kpts, kpt_mask, area)</code>","text":"<p>Calculates keypoint loss factor and Euclidean distance loss for predicted and actual keypoints.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>def forward(self, pred_kpts, gt_kpts, kpt_mask, area):\n    \"\"\"Calculates keypoint loss factor and Euclidean distance loss for predicted and actual keypoints.\"\"\"\n    d = (pred_kpts[..., 0] - gt_kpts[..., 0]) ** 2 + (pred_kpts[..., 1] - gt_kpts[..., 1]) ** 2\n    kpt_loss_factor = kpt_mask.shape[1] / (torch.sum(kpt_mask != 0, dim=1) + 1e-9)\n    # e = d / (2 * (area * self.sigmas) ** 2 + 1e-9)  # from formula\n    e = d / (2 * self.sigmas) ** 2 / (area + 1e-9) / 2  # from cocoeval\n    return (kpt_loss_factor.view(-1, 1) * ((1 - torch.exp(-e)) * kpt_mask)).mean()\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.v8DetectionLoss","title":"<code>ultralytics.utils.loss.v8DetectionLoss</code>","text":"<p>Criterion class for computing training losses.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>class v8DetectionLoss:\n    \"\"\"Criterion class for computing training losses.\"\"\"\n\n    def __init__(self, model):  # model must be de-paralleled\n        \"\"\"Initializes v8DetectionLoss with the model, defining model-related properties and BCE loss function.\"\"\"\n        device = next(model.parameters()).device  # get model device\n        h = model.args  # hyperparameters\n\n        m = model.model[-1]  # Detect() module\n        self.bce = nn.BCEWithLogitsLoss(reduction=\"none\")\n        self.hyp = h\n        self.stride = m.stride  # model strides\n        self.nc = m.nc  # number of classes\n        self.no = m.no\n        self.reg_max = m.reg_max\n        self.device = device\n\n        self.use_dfl = m.reg_max &gt; 1\n\n        self.assigner = TaskAlignedAssigner(topk=10, num_classes=self.nc, alpha=0.5, beta=6.0)\n        self.bbox_loss = BboxLoss(m.reg_max - 1, use_dfl=self.use_dfl).to(device)\n        self.proj = torch.arange(m.reg_max, dtype=torch.float, device=device)\n\n    def preprocess(self, targets, batch_size, scale_tensor):\n        \"\"\"Preprocesses the target counts and matches with the input batch size to output a tensor.\"\"\"\n        if targets.shape[0] == 0:\n            out = torch.zeros(batch_size, 0, 5, device=self.device)\n        else:\n            i = targets[:, 0]  # image index\n            _, counts = i.unique(return_counts=True)\n            counts = counts.to(dtype=torch.int32)\n            out = torch.zeros(batch_size, counts.max(), 5, device=self.device)\n            for j in range(batch_size):\n                matches = i == j\n                n = matches.sum()\n                if n:\n                    out[j, :n] = targets[matches, 1:]\n            out[..., 1:5] = xywh2xyxy(out[..., 1:5].mul_(scale_tensor))\n        return out\n\n    def bbox_decode(self, anchor_points, pred_dist):\n        \"\"\"Decode predicted object bounding box coordinates from anchor points and distribution.\"\"\"\n        if self.use_dfl:\n            b, a, c = pred_dist.shape  # batch, anchors, channels\n            pred_dist = pred_dist.view(b, a, 4, c // 4).softmax(3).matmul(self.proj.type(pred_dist.dtype))\n            # pred_dist = pred_dist.view(b, a, c // 4, 4).transpose(2,3).softmax(3).matmul(self.proj.type(pred_dist.dtype))\n            # pred_dist = (pred_dist.view(b, a, c // 4, 4).softmax(2) * self.proj.type(pred_dist.dtype).view(1, 1, -1, 1)).sum(2)\n        return dist2bbox(pred_dist, anchor_points, xywh=False)\n\n    def __call__(self, preds, batch):\n        \"\"\"Calculate the sum of the loss for box, cls and dfl multiplied by batch size.\"\"\"\n        loss = torch.zeros(3, device=self.device)  # box, cls, dfl\n        feats = preds[1] if isinstance(preds, tuple) else preds\n        pred_distri, pred_scores = torch.cat([xi.view(feats[0].shape[0], self.no, -1) for xi in feats], 2).split(\n            (self.reg_max * 4, self.nc), 1\n        )\n\n        pred_scores = pred_scores.permute(0, 2, 1).contiguous()\n        pred_distri = pred_distri.permute(0, 2, 1).contiguous()\n\n        dtype = pred_scores.dtype\n        batch_size = pred_scores.shape[0]\n        imgsz = torch.tensor(feats[0].shape[2:], device=self.device, dtype=dtype) * self.stride[0]  # image size (h,w)\n        anchor_points, stride_tensor = make_anchors(feats, self.stride, 0.5)\n\n        # Targets\n        targets = torch.cat((batch[\"batch_idx\"].view(-1, 1), batch[\"cls\"].view(-1, 1), batch[\"bboxes\"]), 1)\n        targets = self.preprocess(targets.to(self.device), batch_size, scale_tensor=imgsz[[1, 0, 1, 0]])\n        gt_labels, gt_bboxes = targets.split((1, 4), 2)  # cls, xyxy\n        mask_gt = gt_bboxes.sum(2, keepdim=True).gt_(0)\n\n        # Pboxes\n        pred_bboxes = self.bbox_decode(anchor_points, pred_distri)  # xyxy, (b, h*w, 4)\n\n        _, target_bboxes, target_scores, fg_mask, _ = self.assigner(\n            pred_scores.detach().sigmoid(),\n            (pred_bboxes.detach() * stride_tensor).type(gt_bboxes.dtype),\n            anchor_points * stride_tensor,\n            gt_labels,\n            gt_bboxes,\n            mask_gt,\n        )\n\n        target_scores_sum = max(target_scores.sum(), 1)\n\n        # Cls loss\n        # loss[1] = self.varifocal_loss(pred_scores, target_scores, target_labels) / target_scores_sum  # VFL way\n        loss[1] = self.bce(pred_scores, target_scores.to(dtype)).sum() / target_scores_sum  # BCE\n\n        # Bbox loss\n        if fg_mask.sum():\n            target_bboxes /= stride_tensor\n            loss[0], loss[2] = self.bbox_loss(\n                pred_distri, pred_bboxes, anchor_points, target_bboxes, target_scores, target_scores_sum, fg_mask\n            )\n\n        loss[0] *= self.hyp.box  # box gain\n        loss[1] *= self.hyp.cls  # cls gain\n        loss[2] *= self.hyp.dfl  # dfl gain\n\n        return loss.sum() * batch_size, loss.detach()  # loss(box, cls, dfl)\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.v8DetectionLoss.__call__","title":"<code>__call__(preds, batch)</code>","text":"<p>Calculate the sum of the loss for box, cls and dfl multiplied by batch size.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>def __call__(self, preds, batch):\n    \"\"\"Calculate the sum of the loss for box, cls and dfl multiplied by batch size.\"\"\"\n    loss = torch.zeros(3, device=self.device)  # box, cls, dfl\n    feats = preds[1] if isinstance(preds, tuple) else preds\n    pred_distri, pred_scores = torch.cat([xi.view(feats[0].shape[0], self.no, -1) for xi in feats], 2).split(\n        (self.reg_max * 4, self.nc), 1\n    )\n\n    pred_scores = pred_scores.permute(0, 2, 1).contiguous()\n    pred_distri = pred_distri.permute(0, 2, 1).contiguous()\n\n    dtype = pred_scores.dtype\n    batch_size = pred_scores.shape[0]\n    imgsz = torch.tensor(feats[0].shape[2:], device=self.device, dtype=dtype) * self.stride[0]  # image size (h,w)\n    anchor_points, stride_tensor = make_anchors(feats, self.stride, 0.5)\n\n    # Targets\n    targets = torch.cat((batch[\"batch_idx\"].view(-1, 1), batch[\"cls\"].view(-1, 1), batch[\"bboxes\"]), 1)\n    targets = self.preprocess(targets.to(self.device), batch_size, scale_tensor=imgsz[[1, 0, 1, 0]])\n    gt_labels, gt_bboxes = targets.split((1, 4), 2)  # cls, xyxy\n    mask_gt = gt_bboxes.sum(2, keepdim=True).gt_(0)\n\n    # Pboxes\n    pred_bboxes = self.bbox_decode(anchor_points, pred_distri)  # xyxy, (b, h*w, 4)\n\n    _, target_bboxes, target_scores, fg_mask, _ = self.assigner(\n        pred_scores.detach().sigmoid(),\n        (pred_bboxes.detach() * stride_tensor).type(gt_bboxes.dtype),\n        anchor_points * stride_tensor,\n        gt_labels,\n        gt_bboxes,\n        mask_gt,\n    )\n\n    target_scores_sum = max(target_scores.sum(), 1)\n\n    # Cls loss\n    # loss[1] = self.varifocal_loss(pred_scores, target_scores, target_labels) / target_scores_sum  # VFL way\n    loss[1] = self.bce(pred_scores, target_scores.to(dtype)).sum() / target_scores_sum  # BCE\n\n    # Bbox loss\n    if fg_mask.sum():\n        target_bboxes /= stride_tensor\n        loss[0], loss[2] = self.bbox_loss(\n            pred_distri, pred_bboxes, anchor_points, target_bboxes, target_scores, target_scores_sum, fg_mask\n        )\n\n    loss[0] *= self.hyp.box  # box gain\n    loss[1] *= self.hyp.cls  # cls gain\n    loss[2] *= self.hyp.dfl  # dfl gain\n\n    return loss.sum() * batch_size, loss.detach()  # loss(box, cls, dfl)\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.v8DetectionLoss.__init__","title":"<code>__init__(model)</code>","text":"<p>Initializes v8DetectionLoss with the model, defining model-related properties and BCE loss function.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>def __init__(self, model):  # model must be de-paralleled\n    \"\"\"Initializes v8DetectionLoss with the model, defining model-related properties and BCE loss function.\"\"\"\n    device = next(model.parameters()).device  # get model device\n    h = model.args  # hyperparameters\n\n    m = model.model[-1]  # Detect() module\n    self.bce = nn.BCEWithLogitsLoss(reduction=\"none\")\n    self.hyp = h\n    self.stride = m.stride  # model strides\n    self.nc = m.nc  # number of classes\n    self.no = m.no\n    self.reg_max = m.reg_max\n    self.device = device\n\n    self.use_dfl = m.reg_max &gt; 1\n\n    self.assigner = TaskAlignedAssigner(topk=10, num_classes=self.nc, alpha=0.5, beta=6.0)\n    self.bbox_loss = BboxLoss(m.reg_max - 1, use_dfl=self.use_dfl).to(device)\n    self.proj = torch.arange(m.reg_max, dtype=torch.float, device=device)\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.v8DetectionLoss.bbox_decode","title":"<code>bbox_decode(anchor_points, pred_dist)</code>","text":"<p>Decode predicted object bounding box coordinates from anchor points and distribution.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>def bbox_decode(self, anchor_points, pred_dist):\n    \"\"\"Decode predicted object bounding box coordinates from anchor points and distribution.\"\"\"\n    if self.use_dfl:\n        b, a, c = pred_dist.shape  # batch, anchors, channels\n        pred_dist = pred_dist.view(b, a, 4, c // 4).softmax(3).matmul(self.proj.type(pred_dist.dtype))\n        # pred_dist = pred_dist.view(b, a, c // 4, 4).transpose(2,3).softmax(3).matmul(self.proj.type(pred_dist.dtype))\n        # pred_dist = (pred_dist.view(b, a, c // 4, 4).softmax(2) * self.proj.type(pred_dist.dtype).view(1, 1, -1, 1)).sum(2)\n    return dist2bbox(pred_dist, anchor_points, xywh=False)\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.v8DetectionLoss.preprocess","title":"<code>preprocess(targets, batch_size, scale_tensor)</code>","text":"<p>Preprocesses the target counts and matches with the input batch size to output a tensor.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>def preprocess(self, targets, batch_size, scale_tensor):\n    \"\"\"Preprocesses the target counts and matches with the input batch size to output a tensor.\"\"\"\n    if targets.shape[0] == 0:\n        out = torch.zeros(batch_size, 0, 5, device=self.device)\n    else:\n        i = targets[:, 0]  # image index\n        _, counts = i.unique(return_counts=True)\n        counts = counts.to(dtype=torch.int32)\n        out = torch.zeros(batch_size, counts.max(), 5, device=self.device)\n        for j in range(batch_size):\n            matches = i == j\n            n = matches.sum()\n            if n:\n                out[j, :n] = targets[matches, 1:]\n        out[..., 1:5] = xywh2xyxy(out[..., 1:5].mul_(scale_tensor))\n    return out\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.v8SegmentationLoss","title":"<code>ultralytics.utils.loss.v8SegmentationLoss</code>","text":"<p>             Bases: <code>v8DetectionLoss</code></p> <p>Criterion class for computing training losses.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>class v8SegmentationLoss(v8DetectionLoss):\n    \"\"\"Criterion class for computing training losses.\"\"\"\n\n    def __init__(self, model):  # model must be de-paralleled\n        \"\"\"Initializes the v8SegmentationLoss class, taking a de-paralleled model as argument.\"\"\"\n        super().__init__(model)\n        self.overlap = model.args.overlap_mask\n\n    def __call__(self, preds, batch):\n        \"\"\"Calculate and return the loss for the YOLO model.\"\"\"\n        loss = torch.zeros(4, device=self.device)  # box, cls, dfl\n        feats, pred_masks, proto = preds if len(preds) == 3 else preds[1]\n        batch_size, _, mask_h, mask_w = proto.shape  # batch size, number of masks, mask height, mask width\n        pred_distri, pred_scores = torch.cat([xi.view(feats[0].shape[0], self.no, -1) for xi in feats], 2).split(\n            (self.reg_max * 4, self.nc), 1\n        )\n\n        # B, grids, ..\n        pred_scores = pred_scores.permute(0, 2, 1).contiguous()\n        pred_distri = pred_distri.permute(0, 2, 1).contiguous()\n        pred_masks = pred_masks.permute(0, 2, 1).contiguous()\n\n        dtype = pred_scores.dtype\n        imgsz = torch.tensor(feats[0].shape[2:], device=self.device, dtype=dtype) * self.stride[0]  # image size (h,w)\n        anchor_points, stride_tensor = make_anchors(feats, self.stride, 0.5)\n\n        # Targets\n        try:\n            batch_idx = batch[\"batch_idx\"].view(-1, 1)\n            targets = torch.cat((batch_idx, batch[\"cls\"].view(-1, 1), batch[\"bboxes\"]), 1)\n            targets = self.preprocess(targets.to(self.device), batch_size, scale_tensor=imgsz[[1, 0, 1, 0]])\n            gt_labels, gt_bboxes = targets.split((1, 4), 2)  # cls, xyxy\n            mask_gt = gt_bboxes.sum(2, keepdim=True).gt_(0)\n        except RuntimeError as e:\n            raise TypeError(\n                \"ERROR \u274c segment dataset incorrectly formatted or not a segment dataset.\\n\"\n                \"This error can occur when incorrectly training a 'segment' model on a 'detect' dataset, \"\n                \"i.e. 'yolo train model=yolov8n-seg.pt data=coco8.yaml'.\\nVerify your dataset is a \"\n                \"correctly formatted 'segment' dataset using 'data=coco8-seg.yaml' \"\n                \"as an example.\\nSee https://docs.ultralytics.com/datasets/segment/ for help.\"\n            ) from e\n\n        # Pboxes\n        pred_bboxes = self.bbox_decode(anchor_points, pred_distri)  # xyxy, (b, h*w, 4)\n\n        _, target_bboxes, target_scores, fg_mask, target_gt_idx = self.assigner(\n            pred_scores.detach().sigmoid(),\n            (pred_bboxes.detach() * stride_tensor).type(gt_bboxes.dtype),\n            anchor_points * stride_tensor,\n            gt_labels,\n            gt_bboxes,\n            mask_gt,\n        )\n\n        target_scores_sum = max(target_scores.sum(), 1)\n\n        # Cls loss\n        # loss[1] = self.varifocal_loss(pred_scores, target_scores, target_labels) / target_scores_sum  # VFL way\n        loss[2] = self.bce(pred_scores, target_scores.to(dtype)).sum() / target_scores_sum  # BCE\n\n        if fg_mask.sum():\n            # Bbox loss\n            loss[0], loss[3] = self.bbox_loss(\n                pred_distri,\n                pred_bboxes,\n                anchor_points,\n                target_bboxes / stride_tensor,\n                target_scores,\n                target_scores_sum,\n                fg_mask,\n            )\n            # Masks loss\n            masks = batch[\"masks\"].to(self.device).float()\n            if tuple(masks.shape[-2:]) != (mask_h, mask_w):  # downsample\n                masks = F.interpolate(masks[None], (mask_h, mask_w), mode=\"nearest\")[0]\n\n            loss[1] = self.calculate_segmentation_loss(\n                fg_mask, masks, target_gt_idx, target_bboxes, batch_idx, proto, pred_masks, imgsz, self.overlap\n            )\n\n        # WARNING: lines below prevent Multi-GPU DDP 'unused gradient' PyTorch errors, do not remove\n        else:\n            loss[1] += (proto * 0).sum() + (pred_masks * 0).sum()  # inf sums may lead to nan loss\n\n        loss[0] *= self.hyp.box  # box gain\n        loss[1] *= self.hyp.box  # seg gain\n        loss[2] *= self.hyp.cls  # cls gain\n        loss[3] *= self.hyp.dfl  # dfl gain\n\n        return loss.sum() * batch_size, loss.detach()  # loss(box, cls, dfl)\n\n    @staticmethod\n    def single_mask_loss(\n        gt_mask: torch.Tensor, pred: torch.Tensor, proto: torch.Tensor, xyxy: torch.Tensor, area: torch.Tensor\n    ) -&gt; torch.Tensor:\n        \"\"\"\n        Compute the instance segmentation loss for a single image.\n\n        Args:\n            gt_mask (torch.Tensor): Ground truth mask of shape (n, H, W), where n is the number of objects.\n            pred (torch.Tensor): Predicted mask coefficients of shape (n, 32).\n            proto (torch.Tensor): Prototype masks of shape (32, H, W).\n            xyxy (torch.Tensor): Ground truth bounding boxes in xyxy format, normalized to [0, 1], of shape (n, 4).\n            area (torch.Tensor): Area of each ground truth bounding box of shape (n,).\n\n        Returns:\n            (torch.Tensor): The calculated mask loss for a single image.\n\n        Notes:\n            The function uses the equation pred_mask = torch.einsum('in,nhw-&gt;ihw', pred, proto) to produce the\n            predicted masks from the prototype masks and predicted mask coefficients.\n        \"\"\"\n        pred_mask = torch.einsum(\"in,nhw-&gt;ihw\", pred, proto)  # (n, 32) @ (32, 80, 80) -&gt; (n, 80, 80)\n        loss = F.binary_cross_entropy_with_logits(pred_mask, gt_mask, reduction=\"none\")\n        return (crop_mask(loss, xyxy).mean(dim=(1, 2)) / area).sum()\n\n    def calculate_segmentation_loss(\n        self,\n        fg_mask: torch.Tensor,\n        masks: torch.Tensor,\n        target_gt_idx: torch.Tensor,\n        target_bboxes: torch.Tensor,\n        batch_idx: torch.Tensor,\n        proto: torch.Tensor,\n        pred_masks: torch.Tensor,\n        imgsz: torch.Tensor,\n        overlap: bool,\n    ) -&gt; torch.Tensor:\n        \"\"\"\n        Calculate the loss for instance segmentation.\n\n        Args:\n            fg_mask (torch.Tensor): A binary tensor of shape (BS, N_anchors) indicating which anchors are positive.\n            masks (torch.Tensor): Ground truth masks of shape (BS, H, W) if `overlap` is False, otherwise (BS, ?, H, W).\n            target_gt_idx (torch.Tensor): Indexes of ground truth objects for each anchor of shape (BS, N_anchors).\n            target_bboxes (torch.Tensor): Ground truth bounding boxes for each anchor of shape (BS, N_anchors, 4).\n            batch_idx (torch.Tensor): Batch indices of shape (N_labels_in_batch, 1).\n            proto (torch.Tensor): Prototype masks of shape (BS, 32, H, W).\n            pred_masks (torch.Tensor): Predicted masks for each anchor of shape (BS, N_anchors, 32).\n            imgsz (torch.Tensor): Size of the input image as a tensor of shape (2), i.e., (H, W).\n            overlap (bool): Whether the masks in `masks` tensor overlap.\n\n        Returns:\n            (torch.Tensor): The calculated loss for instance segmentation.\n\n        Notes:\n            The batch loss can be computed for improved speed at higher memory usage.\n            For example, pred_mask can be computed as follows:\n                pred_mask = torch.einsum('in,nhw-&gt;ihw', pred, proto)  # (i, 32) @ (32, 160, 160) -&gt; (i, 160, 160)\n        \"\"\"\n        _, _, mask_h, mask_w = proto.shape\n        loss = 0\n\n        # Normalize to 0-1\n        target_bboxes_normalized = target_bboxes / imgsz[[1, 0, 1, 0]]\n\n        # Areas of target bboxes\n        marea = xyxy2xywh(target_bboxes_normalized)[..., 2:].prod(2)\n\n        # Normalize to mask size\n        mxyxy = target_bboxes_normalized * torch.tensor([mask_w, mask_h, mask_w, mask_h], device=proto.device)\n\n        for i, single_i in enumerate(zip(fg_mask, target_gt_idx, pred_masks, proto, mxyxy, marea, masks)):\n            fg_mask_i, target_gt_idx_i, pred_masks_i, proto_i, mxyxy_i, marea_i, masks_i = single_i\n            if fg_mask_i.any():\n                mask_idx = target_gt_idx_i[fg_mask_i]\n                if overlap:\n                    gt_mask = masks_i == (mask_idx + 1).view(-1, 1, 1)\n                    gt_mask = gt_mask.float()\n                else:\n                    gt_mask = masks[batch_idx.view(-1) == i][mask_idx]\n\n                loss += self.single_mask_loss(\n                    gt_mask, pred_masks_i[fg_mask_i], proto_i, mxyxy_i[fg_mask_i], marea_i[fg_mask_i]\n                )\n\n            # WARNING: lines below prevents Multi-GPU DDP 'unused gradient' PyTorch errors, do not remove\n            else:\n                loss += (proto * 0).sum() + (pred_masks * 0).sum()  # inf sums may lead to nan loss\n\n        return loss / fg_mask.sum()\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.v8SegmentationLoss.__call__","title":"<code>__call__(preds, batch)</code>","text":"<p>Calculate and return the loss for the YOLO model.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>def __call__(self, preds, batch):\n    \"\"\"Calculate and return the loss for the YOLO model.\"\"\"\n    loss = torch.zeros(4, device=self.device)  # box, cls, dfl\n    feats, pred_masks, proto = preds if len(preds) == 3 else preds[1]\n    batch_size, _, mask_h, mask_w = proto.shape  # batch size, number of masks, mask height, mask width\n    pred_distri, pred_scores = torch.cat([xi.view(feats[0].shape[0], self.no, -1) for xi in feats], 2).split(\n        (self.reg_max * 4, self.nc), 1\n    )\n\n    # B, grids, ..\n    pred_scores = pred_scores.permute(0, 2, 1).contiguous()\n    pred_distri = pred_distri.permute(0, 2, 1).contiguous()\n    pred_masks = pred_masks.permute(0, 2, 1).contiguous()\n\n    dtype = pred_scores.dtype\n    imgsz = torch.tensor(feats[0].shape[2:], device=self.device, dtype=dtype) * self.stride[0]  # image size (h,w)\n    anchor_points, stride_tensor = make_anchors(feats, self.stride, 0.5)\n\n    # Targets\n    try:\n        batch_idx = batch[\"batch_idx\"].view(-1, 1)\n        targets = torch.cat((batch_idx, batch[\"cls\"].view(-1, 1), batch[\"bboxes\"]), 1)\n        targets = self.preprocess(targets.to(self.device), batch_size, scale_tensor=imgsz[[1, 0, 1, 0]])\n        gt_labels, gt_bboxes = targets.split((1, 4), 2)  # cls, xyxy\n        mask_gt = gt_bboxes.sum(2, keepdim=True).gt_(0)\n    except RuntimeError as e:\n        raise TypeError(\n            \"ERROR \u274c segment dataset incorrectly formatted or not a segment dataset.\\n\"\n            \"This error can occur when incorrectly training a 'segment' model on a 'detect' dataset, \"\n            \"i.e. 'yolo train model=yolov8n-seg.pt data=coco8.yaml'.\\nVerify your dataset is a \"\n            \"correctly formatted 'segment' dataset using 'data=coco8-seg.yaml' \"\n            \"as an example.\\nSee https://docs.ultralytics.com/datasets/segment/ for help.\"\n        ) from e\n\n    # Pboxes\n    pred_bboxes = self.bbox_decode(anchor_points, pred_distri)  # xyxy, (b, h*w, 4)\n\n    _, target_bboxes, target_scores, fg_mask, target_gt_idx = self.assigner(\n        pred_scores.detach().sigmoid(),\n        (pred_bboxes.detach() * stride_tensor).type(gt_bboxes.dtype),\n        anchor_points * stride_tensor,\n        gt_labels,\n        gt_bboxes,\n        mask_gt,\n    )\n\n    target_scores_sum = max(target_scores.sum(), 1)\n\n    # Cls loss\n    # loss[1] = self.varifocal_loss(pred_scores, target_scores, target_labels) / target_scores_sum  # VFL way\n    loss[2] = self.bce(pred_scores, target_scores.to(dtype)).sum() / target_scores_sum  # BCE\n\n    if fg_mask.sum():\n        # Bbox loss\n        loss[0], loss[3] = self.bbox_loss(\n            pred_distri,\n            pred_bboxes,\n            anchor_points,\n            target_bboxes / stride_tensor,\n            target_scores,\n            target_scores_sum,\n            fg_mask,\n        )\n        # Masks loss\n        masks = batch[\"masks\"].to(self.device).float()\n        if tuple(masks.shape[-2:]) != (mask_h, mask_w):  # downsample\n            masks = F.interpolate(masks[None], (mask_h, mask_w), mode=\"nearest\")[0]\n\n        loss[1] = self.calculate_segmentation_loss(\n            fg_mask, masks, target_gt_idx, target_bboxes, batch_idx, proto, pred_masks, imgsz, self.overlap\n        )\n\n    # WARNING: lines below prevent Multi-GPU DDP 'unused gradient' PyTorch errors, do not remove\n    else:\n        loss[1] += (proto * 0).sum() + (pred_masks * 0).sum()  # inf sums may lead to nan loss\n\n    loss[0] *= self.hyp.box  # box gain\n    loss[1] *= self.hyp.box  # seg gain\n    loss[2] *= self.hyp.cls  # cls gain\n    loss[3] *= self.hyp.dfl  # dfl gain\n\n    return loss.sum() * batch_size, loss.detach()  # loss(box, cls, dfl)\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.v8SegmentationLoss.__init__","title":"<code>__init__(model)</code>","text":"<p>Initializes the v8SegmentationLoss class, taking a de-paralleled model as argument.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>def __init__(self, model):  # model must be de-paralleled\n    \"\"\"Initializes the v8SegmentationLoss class, taking a de-paralleled model as argument.\"\"\"\n    super().__init__(model)\n    self.overlap = model.args.overlap_mask\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.v8SegmentationLoss.calculate_segmentation_loss","title":"<code>calculate_segmentation_loss(fg_mask, masks, target_gt_idx, target_bboxes, batch_idx, proto, pred_masks, imgsz, overlap)</code>","text":"<p>Calculate the loss for instance segmentation.</p> <p>Parameters:</p> Name Type Description Default <code>fg_mask</code> <code>Tensor</code> <p>A binary tensor of shape (BS, N_anchors) indicating which anchors are positive.</p> required <code>masks</code> <code>Tensor</code> <p>Ground truth masks of shape (BS, H, W) if <code>overlap</code> is False, otherwise (BS, ?, H, W).</p> required <code>target_gt_idx</code> <code>Tensor</code> <p>Indexes of ground truth objects for each anchor of shape (BS, N_anchors).</p> required <code>target_bboxes</code> <code>Tensor</code> <p>Ground truth bounding boxes for each anchor of shape (BS, N_anchors, 4).</p> required <code>batch_idx</code> <code>Tensor</code> <p>Batch indices of shape (N_labels_in_batch, 1).</p> required <code>proto</code> <code>Tensor</code> <p>Prototype masks of shape (BS, 32, H, W).</p> required <code>pred_masks</code> <code>Tensor</code> <p>Predicted masks for each anchor of shape (BS, N_anchors, 32).</p> required <code>imgsz</code> <code>Tensor</code> <p>Size of the input image as a tensor of shape (2), i.e., (H, W).</p> required <code>overlap</code> <code>bool</code> <p>Whether the masks in <code>masks</code> tensor overlap.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The calculated loss for instance segmentation.</p> Notes <p>The batch loss can be computed for improved speed at higher memory usage. For example, pred_mask can be computed as follows:     pred_mask = torch.einsum('in,nhw-&gt;ihw', pred, proto)  # (i, 32) @ (32, 160, 160) -&gt; (i, 160, 160)</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>def calculate_segmentation_loss(\n    self,\n    fg_mask: torch.Tensor,\n    masks: torch.Tensor,\n    target_gt_idx: torch.Tensor,\n    target_bboxes: torch.Tensor,\n    batch_idx: torch.Tensor,\n    proto: torch.Tensor,\n    pred_masks: torch.Tensor,\n    imgsz: torch.Tensor,\n    overlap: bool,\n) -&gt; torch.Tensor:\n    \"\"\"\n    Calculate the loss for instance segmentation.\n\n    Args:\n        fg_mask (torch.Tensor): A binary tensor of shape (BS, N_anchors) indicating which anchors are positive.\n        masks (torch.Tensor): Ground truth masks of shape (BS, H, W) if `overlap` is False, otherwise (BS, ?, H, W).\n        target_gt_idx (torch.Tensor): Indexes of ground truth objects for each anchor of shape (BS, N_anchors).\n        target_bboxes (torch.Tensor): Ground truth bounding boxes for each anchor of shape (BS, N_anchors, 4).\n        batch_idx (torch.Tensor): Batch indices of shape (N_labels_in_batch, 1).\n        proto (torch.Tensor): Prototype masks of shape (BS, 32, H, W).\n        pred_masks (torch.Tensor): Predicted masks for each anchor of shape (BS, N_anchors, 32).\n        imgsz (torch.Tensor): Size of the input image as a tensor of shape (2), i.e., (H, W).\n        overlap (bool): Whether the masks in `masks` tensor overlap.\n\n    Returns:\n        (torch.Tensor): The calculated loss for instance segmentation.\n\n    Notes:\n        The batch loss can be computed for improved speed at higher memory usage.\n        For example, pred_mask can be computed as follows:\n            pred_mask = torch.einsum('in,nhw-&gt;ihw', pred, proto)  # (i, 32) @ (32, 160, 160) -&gt; (i, 160, 160)\n    \"\"\"\n    _, _, mask_h, mask_w = proto.shape\n    loss = 0\n\n    # Normalize to 0-1\n    target_bboxes_normalized = target_bboxes / imgsz[[1, 0, 1, 0]]\n\n    # Areas of target bboxes\n    marea = xyxy2xywh(target_bboxes_normalized)[..., 2:].prod(2)\n\n    # Normalize to mask size\n    mxyxy = target_bboxes_normalized * torch.tensor([mask_w, mask_h, mask_w, mask_h], device=proto.device)\n\n    for i, single_i in enumerate(zip(fg_mask, target_gt_idx, pred_masks, proto, mxyxy, marea, masks)):\n        fg_mask_i, target_gt_idx_i, pred_masks_i, proto_i, mxyxy_i, marea_i, masks_i = single_i\n        if fg_mask_i.any():\n            mask_idx = target_gt_idx_i[fg_mask_i]\n            if overlap:\n                gt_mask = masks_i == (mask_idx + 1).view(-1, 1, 1)\n                gt_mask = gt_mask.float()\n            else:\n                gt_mask = masks[batch_idx.view(-1) == i][mask_idx]\n\n            loss += self.single_mask_loss(\n                gt_mask, pred_masks_i[fg_mask_i], proto_i, mxyxy_i[fg_mask_i], marea_i[fg_mask_i]\n            )\n\n        # WARNING: lines below prevents Multi-GPU DDP 'unused gradient' PyTorch errors, do not remove\n        else:\n            loss += (proto * 0).sum() + (pred_masks * 0).sum()  # inf sums may lead to nan loss\n\n    return loss / fg_mask.sum()\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.v8SegmentationLoss.single_mask_loss","title":"<code>single_mask_loss(gt_mask, pred, proto, xyxy, area)</code>  <code>staticmethod</code>","text":"<p>Compute the instance segmentation loss for a single image.</p> <p>Parameters:</p> Name Type Description Default <code>gt_mask</code> <code>Tensor</code> <p>Ground truth mask of shape (n, H, W), where n is the number of objects.</p> required <code>pred</code> <code>Tensor</code> <p>Predicted mask coefficients of shape (n, 32).</p> required <code>proto</code> <code>Tensor</code> <p>Prototype masks of shape (32, H, W).</p> required <code>xyxy</code> <code>Tensor</code> <p>Ground truth bounding boxes in xyxy format, normalized to [0, 1], of shape (n, 4).</p> required <code>area</code> <code>Tensor</code> <p>Area of each ground truth bounding box of shape (n,).</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The calculated mask loss for a single image.</p> Notes <p>The function uses the equation pred_mask = torch.einsum('in,nhw-&gt;ihw', pred, proto) to produce the predicted masks from the prototype masks and predicted mask coefficients.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>@staticmethod\ndef single_mask_loss(\n    gt_mask: torch.Tensor, pred: torch.Tensor, proto: torch.Tensor, xyxy: torch.Tensor, area: torch.Tensor\n) -&gt; torch.Tensor:\n    \"\"\"\n    Compute the instance segmentation loss for a single image.\n\n    Args:\n        gt_mask (torch.Tensor): Ground truth mask of shape (n, H, W), where n is the number of objects.\n        pred (torch.Tensor): Predicted mask coefficients of shape (n, 32).\n        proto (torch.Tensor): Prototype masks of shape (32, H, W).\n        xyxy (torch.Tensor): Ground truth bounding boxes in xyxy format, normalized to [0, 1], of shape (n, 4).\n        area (torch.Tensor): Area of each ground truth bounding box of shape (n,).\n\n    Returns:\n        (torch.Tensor): The calculated mask loss for a single image.\n\n    Notes:\n        The function uses the equation pred_mask = torch.einsum('in,nhw-&gt;ihw', pred, proto) to produce the\n        predicted masks from the prototype masks and predicted mask coefficients.\n    \"\"\"\n    pred_mask = torch.einsum(\"in,nhw-&gt;ihw\", pred, proto)  # (n, 32) @ (32, 80, 80) -&gt; (n, 80, 80)\n    loss = F.binary_cross_entropy_with_logits(pred_mask, gt_mask, reduction=\"none\")\n    return (crop_mask(loss, xyxy).mean(dim=(1, 2)) / area).sum()\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.v8PoseLoss","title":"<code>ultralytics.utils.loss.v8PoseLoss</code>","text":"<p>             Bases: <code>v8DetectionLoss</code></p> <p>Criterion class for computing training losses.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>class v8PoseLoss(v8DetectionLoss):\n    \"\"\"Criterion class for computing training losses.\"\"\"\n\n    def __init__(self, model):  # model must be de-paralleled\n        \"\"\"Initializes v8PoseLoss with model, sets keypoint variables and declares a keypoint loss instance.\"\"\"\n        super().__init__(model)\n        self.kpt_shape = model.model[-1].kpt_shape\n        self.bce_pose = nn.BCEWithLogitsLoss()\n        is_pose = self.kpt_shape == [17, 3]\n        nkpt = self.kpt_shape[0]  # number of keypoints\n        sigmas = torch.from_numpy(OKS_SIGMA).to(self.device) if is_pose else torch.ones(nkpt, device=self.device) / nkpt\n        self.keypoint_loss = KeypointLoss(sigmas=sigmas)\n\n    def __call__(self, preds, batch):\n        \"\"\"Calculate the total loss and detach it.\"\"\"\n        loss = torch.zeros(5, device=self.device)  # box, cls, dfl, kpt_location, kpt_visibility\n        feats, pred_kpts = preds if isinstance(preds[0], list) else preds[1]\n        pred_distri, pred_scores = torch.cat([xi.view(feats[0].shape[0], self.no, -1) for xi in feats], 2).split(\n            (self.reg_max * 4, self.nc), 1\n        )\n\n        # B, grids, ..\n        pred_scores = pred_scores.permute(0, 2, 1).contiguous()\n        pred_distri = pred_distri.permute(0, 2, 1).contiguous()\n        pred_kpts = pred_kpts.permute(0, 2, 1).contiguous()\n\n        dtype = pred_scores.dtype\n        imgsz = torch.tensor(feats[0].shape[2:], device=self.device, dtype=dtype) * self.stride[0]  # image size (h,w)\n        anchor_points, stride_tensor = make_anchors(feats, self.stride, 0.5)\n\n        # Targets\n        batch_size = pred_scores.shape[0]\n        batch_idx = batch[\"batch_idx\"].view(-1, 1)\n        targets = torch.cat((batch_idx, batch[\"cls\"].view(-1, 1), batch[\"bboxes\"]), 1)\n        targets = self.preprocess(targets.to(self.device), batch_size, scale_tensor=imgsz[[1, 0, 1, 0]])\n        gt_labels, gt_bboxes = targets.split((1, 4), 2)  # cls, xyxy\n        mask_gt = gt_bboxes.sum(2, keepdim=True).gt_(0)\n\n        # Pboxes\n        pred_bboxes = self.bbox_decode(anchor_points, pred_distri)  # xyxy, (b, h*w, 4)\n        pred_kpts = self.kpts_decode(anchor_points, pred_kpts.view(batch_size, -1, *self.kpt_shape))  # (b, h*w, 17, 3)\n\n        _, target_bboxes, target_scores, fg_mask, target_gt_idx = self.assigner(\n            pred_scores.detach().sigmoid(),\n            (pred_bboxes.detach() * stride_tensor).type(gt_bboxes.dtype),\n            anchor_points * stride_tensor,\n            gt_labels,\n            gt_bboxes,\n            mask_gt,\n        )\n\n        target_scores_sum = max(target_scores.sum(), 1)\n\n        # Cls loss\n        # loss[1] = self.varifocal_loss(pred_scores, target_scores, target_labels) / target_scores_sum  # VFL way\n        loss[3] = self.bce(pred_scores, target_scores.to(dtype)).sum() / target_scores_sum  # BCE\n\n        # Bbox loss\n        if fg_mask.sum():\n            target_bboxes /= stride_tensor\n            loss[0], loss[4] = self.bbox_loss(\n                pred_distri, pred_bboxes, anchor_points, target_bboxes, target_scores, target_scores_sum, fg_mask\n            )\n            keypoints = batch[\"keypoints\"].to(self.device).float().clone()\n            keypoints[..., 0] *= imgsz[1]\n            keypoints[..., 1] *= imgsz[0]\n\n            loss[1], loss[2] = self.calculate_keypoints_loss(\n                fg_mask, target_gt_idx, keypoints, batch_idx, stride_tensor, target_bboxes, pred_kpts\n            )\n\n        loss[0] *= self.hyp.box  # box gain\n        loss[1] *= self.hyp.pose  # pose gain\n        loss[2] *= self.hyp.kobj  # kobj gain\n        loss[3] *= self.hyp.cls  # cls gain\n        loss[4] *= self.hyp.dfl  # dfl gain\n\n        return loss.sum() * batch_size, loss.detach()  # loss(box, cls, dfl)\n\n    @staticmethod\n    def kpts_decode(anchor_points, pred_kpts):\n        \"\"\"Decodes predicted keypoints to image coordinates.\"\"\"\n        y = pred_kpts.clone()\n        y[..., :2] *= 2.0\n        y[..., 0] += anchor_points[:, [0]] - 0.5\n        y[..., 1] += anchor_points[:, [1]] - 0.5\n        return y\n\n    def calculate_keypoints_loss(\n        self, masks, target_gt_idx, keypoints, batch_idx, stride_tensor, target_bboxes, pred_kpts\n    ):\n        \"\"\"\n        Calculate the keypoints loss for the model.\n\n        This function calculates the keypoints loss and keypoints object loss for a given batch. The keypoints loss is\n        based on the difference between the predicted keypoints and ground truth keypoints. The keypoints object loss is\n        a binary classification loss that classifies whether a keypoint is present or not.\n\n        Args:\n            masks (torch.Tensor): Binary mask tensor indicating object presence, shape (BS, N_anchors).\n            target_gt_idx (torch.Tensor): Index tensor mapping anchors to ground truth objects, shape (BS, N_anchors).\n            keypoints (torch.Tensor): Ground truth keypoints, shape (N_kpts_in_batch, N_kpts_per_object, kpts_dim).\n            batch_idx (torch.Tensor): Batch index tensor for keypoints, shape (N_kpts_in_batch, 1).\n            stride_tensor (torch.Tensor): Stride tensor for anchors, shape (N_anchors, 1).\n            target_bboxes (torch.Tensor): Ground truth boxes in (x1, y1, x2, y2) format, shape (BS, N_anchors, 4).\n            pred_kpts (torch.Tensor): Predicted keypoints, shape (BS, N_anchors, N_kpts_per_object, kpts_dim).\n\n        Returns:\n            (tuple): Returns a tuple containing:\n                - kpts_loss (torch.Tensor): The keypoints loss.\n                - kpts_obj_loss (torch.Tensor): The keypoints object loss.\n        \"\"\"\n        batch_idx = batch_idx.flatten()\n        batch_size = len(masks)\n\n        # Find the maximum number of keypoints in a single image\n        max_kpts = torch.unique(batch_idx, return_counts=True)[1].max()\n\n        # Create a tensor to hold batched keypoints\n        batched_keypoints = torch.zeros(\n            (batch_size, max_kpts, keypoints.shape[1], keypoints.shape[2]), device=keypoints.device\n        )\n\n        # TODO: any idea how to vectorize this?\n        # Fill batched_keypoints with keypoints based on batch_idx\n        for i in range(batch_size):\n            keypoints_i = keypoints[batch_idx == i]\n            batched_keypoints[i, : keypoints_i.shape[0]] = keypoints_i\n\n        # Expand dimensions of target_gt_idx to match the shape of batched_keypoints\n        target_gt_idx_expanded = target_gt_idx.unsqueeze(-1).unsqueeze(-1)\n\n        # Use target_gt_idx_expanded to select keypoints from batched_keypoints\n        selected_keypoints = batched_keypoints.gather(\n            1, target_gt_idx_expanded.expand(-1, -1, keypoints.shape[1], keypoints.shape[2])\n        )\n\n        # Divide coordinates by stride\n        selected_keypoints /= stride_tensor.view(1, -1, 1, 1)\n\n        kpts_loss = 0\n        kpts_obj_loss = 0\n\n        if masks.any():\n            gt_kpt = selected_keypoints[masks]\n            area = xyxy2xywh(target_bboxes[masks])[:, 2:].prod(1, keepdim=True)\n            pred_kpt = pred_kpts[masks]\n            kpt_mask = gt_kpt[..., 2] != 0 if gt_kpt.shape[-1] == 3 else torch.full_like(gt_kpt[..., 0], True)\n            kpts_loss = self.keypoint_loss(pred_kpt, gt_kpt, kpt_mask, area)  # pose loss\n\n            if pred_kpt.shape[-1] == 3:\n                kpts_obj_loss = self.bce_pose(pred_kpt[..., 2], kpt_mask.float())  # keypoint obj loss\n\n        return kpts_loss, kpts_obj_loss\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.v8PoseLoss.__call__","title":"<code>__call__(preds, batch)</code>","text":"<p>Calculate the total loss and detach it.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>def __call__(self, preds, batch):\n    \"\"\"Calculate the total loss and detach it.\"\"\"\n    loss = torch.zeros(5, device=self.device)  # box, cls, dfl, kpt_location, kpt_visibility\n    feats, pred_kpts = preds if isinstance(preds[0], list) else preds[1]\n    pred_distri, pred_scores = torch.cat([xi.view(feats[0].shape[0], self.no, -1) for xi in feats], 2).split(\n        (self.reg_max * 4, self.nc), 1\n    )\n\n    # B, grids, ..\n    pred_scores = pred_scores.permute(0, 2, 1).contiguous()\n    pred_distri = pred_distri.permute(0, 2, 1).contiguous()\n    pred_kpts = pred_kpts.permute(0, 2, 1).contiguous()\n\n    dtype = pred_scores.dtype\n    imgsz = torch.tensor(feats[0].shape[2:], device=self.device, dtype=dtype) * self.stride[0]  # image size (h,w)\n    anchor_points, stride_tensor = make_anchors(feats, self.stride, 0.5)\n\n    # Targets\n    batch_size = pred_scores.shape[0]\n    batch_idx = batch[\"batch_idx\"].view(-1, 1)\n    targets = torch.cat((batch_idx, batch[\"cls\"].view(-1, 1), batch[\"bboxes\"]), 1)\n    targets = self.preprocess(targets.to(self.device), batch_size, scale_tensor=imgsz[[1, 0, 1, 0]])\n    gt_labels, gt_bboxes = targets.split((1, 4), 2)  # cls, xyxy\n    mask_gt = gt_bboxes.sum(2, keepdim=True).gt_(0)\n\n    # Pboxes\n    pred_bboxes = self.bbox_decode(anchor_points, pred_distri)  # xyxy, (b, h*w, 4)\n    pred_kpts = self.kpts_decode(anchor_points, pred_kpts.view(batch_size, -1, *self.kpt_shape))  # (b, h*w, 17, 3)\n\n    _, target_bboxes, target_scores, fg_mask, target_gt_idx = self.assigner(\n        pred_scores.detach().sigmoid(),\n        (pred_bboxes.detach() * stride_tensor).type(gt_bboxes.dtype),\n        anchor_points * stride_tensor,\n        gt_labels,\n        gt_bboxes,\n        mask_gt,\n    )\n\n    target_scores_sum = max(target_scores.sum(), 1)\n\n    # Cls loss\n    # loss[1] = self.varifocal_loss(pred_scores, target_scores, target_labels) / target_scores_sum  # VFL way\n    loss[3] = self.bce(pred_scores, target_scores.to(dtype)).sum() / target_scores_sum  # BCE\n\n    # Bbox loss\n    if fg_mask.sum():\n        target_bboxes /= stride_tensor\n        loss[0], loss[4] = self.bbox_loss(\n            pred_distri, pred_bboxes, anchor_points, target_bboxes, target_scores, target_scores_sum, fg_mask\n        )\n        keypoints = batch[\"keypoints\"].to(self.device).float().clone()\n        keypoints[..., 0] *= imgsz[1]\n        keypoints[..., 1] *= imgsz[0]\n\n        loss[1], loss[2] = self.calculate_keypoints_loss(\n            fg_mask, target_gt_idx, keypoints, batch_idx, stride_tensor, target_bboxes, pred_kpts\n        )\n\n    loss[0] *= self.hyp.box  # box gain\n    loss[1] *= self.hyp.pose  # pose gain\n    loss[2] *= self.hyp.kobj  # kobj gain\n    loss[3] *= self.hyp.cls  # cls gain\n    loss[4] *= self.hyp.dfl  # dfl gain\n\n    return loss.sum() * batch_size, loss.detach()  # loss(box, cls, dfl)\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.v8PoseLoss.__init__","title":"<code>__init__(model)</code>","text":"<p>Initializes v8PoseLoss with model, sets keypoint variables and declares a keypoint loss instance.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>def __init__(self, model):  # model must be de-paralleled\n    \"\"\"Initializes v8PoseLoss with model, sets keypoint variables and declares a keypoint loss instance.\"\"\"\n    super().__init__(model)\n    self.kpt_shape = model.model[-1].kpt_shape\n    self.bce_pose = nn.BCEWithLogitsLoss()\n    is_pose = self.kpt_shape == [17, 3]\n    nkpt = self.kpt_shape[0]  # number of keypoints\n    sigmas = torch.from_numpy(OKS_SIGMA).to(self.device) if is_pose else torch.ones(nkpt, device=self.device) / nkpt\n    self.keypoint_loss = KeypointLoss(sigmas=sigmas)\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.v8PoseLoss.calculate_keypoints_loss","title":"<code>calculate_keypoints_loss(masks, target_gt_idx, keypoints, batch_idx, stride_tensor, target_bboxes, pred_kpts)</code>","text":"<p>Calculate the keypoints loss for the model.</p> <p>This function calculates the keypoints loss and keypoints object loss for a given batch. The keypoints loss is based on the difference between the predicted keypoints and ground truth keypoints. The keypoints object loss is a binary classification loss that classifies whether a keypoint is present or not.</p> <p>Parameters:</p> Name Type Description Default <code>masks</code> <code>Tensor</code> <p>Binary mask tensor indicating object presence, shape (BS, N_anchors).</p> required <code>target_gt_idx</code> <code>Tensor</code> <p>Index tensor mapping anchors to ground truth objects, shape (BS, N_anchors).</p> required <code>keypoints</code> <code>Tensor</code> <p>Ground truth keypoints, shape (N_kpts_in_batch, N_kpts_per_object, kpts_dim).</p> required <code>batch_idx</code> <code>Tensor</code> <p>Batch index tensor for keypoints, shape (N_kpts_in_batch, 1).</p> required <code>stride_tensor</code> <code>Tensor</code> <p>Stride tensor for anchors, shape (N_anchors, 1).</p> required <code>target_bboxes</code> <code>Tensor</code> <p>Ground truth boxes in (x1, y1, x2, y2) format, shape (BS, N_anchors, 4).</p> required <code>pred_kpts</code> <code>Tensor</code> <p>Predicted keypoints, shape (BS, N_anchors, N_kpts_per_object, kpts_dim).</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>Returns a tuple containing: - kpts_loss (torch.Tensor): The keypoints loss. - kpts_obj_loss (torch.Tensor): The keypoints object loss.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>def calculate_keypoints_loss(\n    self, masks, target_gt_idx, keypoints, batch_idx, stride_tensor, target_bboxes, pred_kpts\n):\n    \"\"\"\n    Calculate the keypoints loss for the model.\n\n    This function calculates the keypoints loss and keypoints object loss for a given batch. The keypoints loss is\n    based on the difference between the predicted keypoints and ground truth keypoints. The keypoints object loss is\n    a binary classification loss that classifies whether a keypoint is present or not.\n\n    Args:\n        masks (torch.Tensor): Binary mask tensor indicating object presence, shape (BS, N_anchors).\n        target_gt_idx (torch.Tensor): Index tensor mapping anchors to ground truth objects, shape (BS, N_anchors).\n        keypoints (torch.Tensor): Ground truth keypoints, shape (N_kpts_in_batch, N_kpts_per_object, kpts_dim).\n        batch_idx (torch.Tensor): Batch index tensor for keypoints, shape (N_kpts_in_batch, 1).\n        stride_tensor (torch.Tensor): Stride tensor for anchors, shape (N_anchors, 1).\n        target_bboxes (torch.Tensor): Ground truth boxes in (x1, y1, x2, y2) format, shape (BS, N_anchors, 4).\n        pred_kpts (torch.Tensor): Predicted keypoints, shape (BS, N_anchors, N_kpts_per_object, kpts_dim).\n\n    Returns:\n        (tuple): Returns a tuple containing:\n            - kpts_loss (torch.Tensor): The keypoints loss.\n            - kpts_obj_loss (torch.Tensor): The keypoints object loss.\n    \"\"\"\n    batch_idx = batch_idx.flatten()\n    batch_size = len(masks)\n\n    # Find the maximum number of keypoints in a single image\n    max_kpts = torch.unique(batch_idx, return_counts=True)[1].max()\n\n    # Create a tensor to hold batched keypoints\n    batched_keypoints = torch.zeros(\n        (batch_size, max_kpts, keypoints.shape[1], keypoints.shape[2]), device=keypoints.device\n    )\n\n    # TODO: any idea how to vectorize this?\n    # Fill batched_keypoints with keypoints based on batch_idx\n    for i in range(batch_size):\n        keypoints_i = keypoints[batch_idx == i]\n        batched_keypoints[i, : keypoints_i.shape[0]] = keypoints_i\n\n    # Expand dimensions of target_gt_idx to match the shape of batched_keypoints\n    target_gt_idx_expanded = target_gt_idx.unsqueeze(-1).unsqueeze(-1)\n\n    # Use target_gt_idx_expanded to select keypoints from batched_keypoints\n    selected_keypoints = batched_keypoints.gather(\n        1, target_gt_idx_expanded.expand(-1, -1, keypoints.shape[1], keypoints.shape[2])\n    )\n\n    # Divide coordinates by stride\n    selected_keypoints /= stride_tensor.view(1, -1, 1, 1)\n\n    kpts_loss = 0\n    kpts_obj_loss = 0\n\n    if masks.any():\n        gt_kpt = selected_keypoints[masks]\n        area = xyxy2xywh(target_bboxes[masks])[:, 2:].prod(1, keepdim=True)\n        pred_kpt = pred_kpts[masks]\n        kpt_mask = gt_kpt[..., 2] != 0 if gt_kpt.shape[-1] == 3 else torch.full_like(gt_kpt[..., 0], True)\n        kpts_loss = self.keypoint_loss(pred_kpt, gt_kpt, kpt_mask, area)  # pose loss\n\n        if pred_kpt.shape[-1] == 3:\n            kpts_obj_loss = self.bce_pose(pred_kpt[..., 2], kpt_mask.float())  # keypoint obj loss\n\n    return kpts_loss, kpts_obj_loss\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.v8PoseLoss.kpts_decode","title":"<code>kpts_decode(anchor_points, pred_kpts)</code>  <code>staticmethod</code>","text":"<p>Decodes predicted keypoints to image coordinates.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>@staticmethod\ndef kpts_decode(anchor_points, pred_kpts):\n    \"\"\"Decodes predicted keypoints to image coordinates.\"\"\"\n    y = pred_kpts.clone()\n    y[..., :2] *= 2.0\n    y[..., 0] += anchor_points[:, [0]] - 0.5\n    y[..., 1] += anchor_points[:, [1]] - 0.5\n    return y\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.v8ClassificationLoss","title":"<code>ultralytics.utils.loss.v8ClassificationLoss</code>","text":"<p>Criterion class for computing training losses.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>class v8ClassificationLoss:\n    \"\"\"Criterion class for computing training losses.\"\"\"\n\n    def __call__(self, preds, batch):\n        \"\"\"Compute the classification loss between predictions and true labels.\"\"\"\n        loss = torch.nn.functional.cross_entropy(preds, batch[\"cls\"], reduction=\"mean\")\n        loss_items = loss.detach()\n        return loss, loss_items\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.v8ClassificationLoss.__call__","title":"<code>__call__(preds, batch)</code>","text":"<p>Compute the classification loss between predictions and true labels.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>def __call__(self, preds, batch):\n    \"\"\"Compute the classification loss between predictions and true labels.\"\"\"\n    loss = torch.nn.functional.cross_entropy(preds, batch[\"cls\"], reduction=\"mean\")\n    loss_items = loss.detach()\n    return loss, loss_items\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.v8OBBLoss","title":"<code>ultralytics.utils.loss.v8OBBLoss</code>","text":"<p>             Bases: <code>v8DetectionLoss</code></p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>class v8OBBLoss(v8DetectionLoss):\n    def __init__(self, model):  # model must be de-paralleled\n        super().__init__(model)\n        self.assigner = RotatedTaskAlignedAssigner(topk=10, num_classes=self.nc, alpha=0.5, beta=6.0)\n        self.bbox_loss = RotatedBboxLoss(self.reg_max - 1, use_dfl=self.use_dfl).to(self.device)\n\n    def preprocess(self, targets, batch_size, scale_tensor):\n        \"\"\"Preprocesses the target counts and matches with the input batch size to output a tensor.\"\"\"\n        if targets.shape[0] == 0:\n            out = torch.zeros(batch_size, 0, 6, device=self.device)\n        else:\n            i = targets[:, 0]  # image index\n            _, counts = i.unique(return_counts=True)\n            counts = counts.to(dtype=torch.int32)\n            out = torch.zeros(batch_size, counts.max(), 6, device=self.device)\n            for j in range(batch_size):\n                matches = i == j\n                n = matches.sum()\n                if n:\n                    bboxes = targets[matches, 2:]\n                    bboxes[..., :4].mul_(scale_tensor)\n                    out[j, :n] = torch.cat([targets[matches, 1:2], bboxes], dim=-1)\n        return out\n\n    def __call__(self, preds, batch):\n        \"\"\"Calculate and return the loss for the YOLO model.\"\"\"\n        loss = torch.zeros(3, device=self.device)  # box, cls, dfl\n        feats, pred_angle = preds if isinstance(preds[0], list) else preds[1]\n        batch_size = pred_angle.shape[0]  # batch size, number of masks, mask height, mask width\n        pred_distri, pred_scores = torch.cat([xi.view(feats[0].shape[0], self.no, -1) for xi in feats], 2).split(\n            (self.reg_max * 4, self.nc), 1\n        )\n\n        # b, grids, ..\n        pred_scores = pred_scores.permute(0, 2, 1).contiguous()\n        pred_distri = pred_distri.permute(0, 2, 1).contiguous()\n        pred_angle = pred_angle.permute(0, 2, 1).contiguous()\n\n        dtype = pred_scores.dtype\n        imgsz = torch.tensor(feats[0].shape[2:], device=self.device, dtype=dtype) * self.stride[0]  # image size (h,w)\n        anchor_points, stride_tensor = make_anchors(feats, self.stride, 0.5)\n\n        # targets\n        try:\n            batch_idx = batch[\"batch_idx\"].view(-1, 1)\n            targets = torch.cat((batch_idx, batch[\"cls\"].view(-1, 1), batch[\"bboxes\"].view(-1, 5)), 1)\n            rw, rh = targets[:, 4] * imgsz[0].item(), targets[:, 5] * imgsz[1].item()\n            targets = targets[(rw &gt;= 2) &amp; (rh &gt;= 2)]  # filter rboxes of tiny size to stabilize training\n            targets = self.preprocess(targets.to(self.device), batch_size, scale_tensor=imgsz[[1, 0, 1, 0]])\n            gt_labels, gt_bboxes = targets.split((1, 5), 2)  # cls, xywhr\n            mask_gt = gt_bboxes.sum(2, keepdim=True).gt_(0)\n        except RuntimeError as e:\n            raise TypeError(\n                \"ERROR \u274c OBB dataset incorrectly formatted or not a OBB dataset.\\n\"\n                \"This error can occur when incorrectly training a 'OBB' model on a 'detect' dataset, \"\n                \"i.e. 'yolo train model=yolov8n-obb.pt data=coco8.yaml'.\\nVerify your dataset is a \"\n                \"correctly formatted 'OBB' dataset using 'data=coco8-obb.yaml' \"\n                \"as an example.\\nSee https://docs.ultralytics.com/datasets/obb/ for help.\"\n            ) from e\n\n        # Pboxes\n        pred_bboxes = self.bbox_decode(anchor_points, pred_distri, pred_angle)  # xyxy, (b, h*w, 4)\n\n        bboxes_for_assigner = pred_bboxes.clone().detach()\n        # Only the first four elements need to be scaled\n        bboxes_for_assigner[..., :4] *= stride_tensor\n        _, target_bboxes, target_scores, fg_mask, _ = self.assigner(\n            pred_scores.detach().sigmoid(),\n            bboxes_for_assigner.type(gt_bboxes.dtype),\n            anchor_points * stride_tensor,\n            gt_labels,\n            gt_bboxes,\n            mask_gt,\n        )\n\n        target_scores_sum = max(target_scores.sum(), 1)\n\n        # Cls loss\n        # loss[1] = self.varifocal_loss(pred_scores, target_scores, target_labels) / target_scores_sum  # VFL way\n        loss[1] = self.bce(pred_scores, target_scores.to(dtype)).sum() / target_scores_sum  # BCE\n\n        # Bbox loss\n        if fg_mask.sum():\n            target_bboxes[..., :4] /= stride_tensor\n            loss[0], loss[2] = self.bbox_loss(\n                pred_distri, pred_bboxes, anchor_points, target_bboxes, target_scores, target_scores_sum, fg_mask\n            )\n        else:\n            loss[0] += (pred_angle * 0).sum()\n\n        loss[0] *= self.hyp.box  # box gain\n        loss[1] *= self.hyp.cls  # cls gain\n        loss[2] *= self.hyp.dfl  # dfl gain\n\n        return loss.sum() * batch_size, loss.detach()  # loss(box, cls, dfl)\n\n    def bbox_decode(self, anchor_points, pred_dist, pred_angle):\n        \"\"\"\n        Decode predicted object bounding box coordinates from anchor points and distribution.\n\n        Args:\n            anchor_points (torch.Tensor): Anchor points, (h*w, 2).\n            pred_dist (torch.Tensor): Predicted rotated distance, (bs, h*w, 4).\n            pred_angle (torch.Tensor): Predicted angle, (bs, h*w, 1).\n        Returns:\n            (torch.Tensor): Predicted rotated bounding boxes with angles, (bs, h*w, 5).\n        \"\"\"\n        if self.use_dfl:\n            b, a, c = pred_dist.shape  # batch, anchors, channels\n            pred_dist = pred_dist.view(b, a, 4, c // 4).softmax(3).matmul(self.proj.type(pred_dist.dtype))\n        return torch.cat((dist2rbox(pred_dist, pred_angle, anchor_points), pred_angle), dim=-1)\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.v8OBBLoss.__call__","title":"<code>__call__(preds, batch)</code>","text":"<p>Calculate and return the loss for the YOLO model.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>def __call__(self, preds, batch):\n    \"\"\"Calculate and return the loss for the YOLO model.\"\"\"\n    loss = torch.zeros(3, device=self.device)  # box, cls, dfl\n    feats, pred_angle = preds if isinstance(preds[0], list) else preds[1]\n    batch_size = pred_angle.shape[0]  # batch size, number of masks, mask height, mask width\n    pred_distri, pred_scores = torch.cat([xi.view(feats[0].shape[0], self.no, -1) for xi in feats], 2).split(\n        (self.reg_max * 4, self.nc), 1\n    )\n\n    # b, grids, ..\n    pred_scores = pred_scores.permute(0, 2, 1).contiguous()\n    pred_distri = pred_distri.permute(0, 2, 1).contiguous()\n    pred_angle = pred_angle.permute(0, 2, 1).contiguous()\n\n    dtype = pred_scores.dtype\n    imgsz = torch.tensor(feats[0].shape[2:], device=self.device, dtype=dtype) * self.stride[0]  # image size (h,w)\n    anchor_points, stride_tensor = make_anchors(feats, self.stride, 0.5)\n\n    # targets\n    try:\n        batch_idx = batch[\"batch_idx\"].view(-1, 1)\n        targets = torch.cat((batch_idx, batch[\"cls\"].view(-1, 1), batch[\"bboxes\"].view(-1, 5)), 1)\n        rw, rh = targets[:, 4] * imgsz[0].item(), targets[:, 5] * imgsz[1].item()\n        targets = targets[(rw &gt;= 2) &amp; (rh &gt;= 2)]  # filter rboxes of tiny size to stabilize training\n        targets = self.preprocess(targets.to(self.device), batch_size, scale_tensor=imgsz[[1, 0, 1, 0]])\n        gt_labels, gt_bboxes = targets.split((1, 5), 2)  # cls, xywhr\n        mask_gt = gt_bboxes.sum(2, keepdim=True).gt_(0)\n    except RuntimeError as e:\n        raise TypeError(\n            \"ERROR \u274c OBB dataset incorrectly formatted or not a OBB dataset.\\n\"\n            \"This error can occur when incorrectly training a 'OBB' model on a 'detect' dataset, \"\n            \"i.e. 'yolo train model=yolov8n-obb.pt data=coco8.yaml'.\\nVerify your dataset is a \"\n            \"correctly formatted 'OBB' dataset using 'data=coco8-obb.yaml' \"\n            \"as an example.\\nSee https://docs.ultralytics.com/datasets/obb/ for help.\"\n        ) from e\n\n    # Pboxes\n    pred_bboxes = self.bbox_decode(anchor_points, pred_distri, pred_angle)  # xyxy, (b, h*w, 4)\n\n    bboxes_for_assigner = pred_bboxes.clone().detach()\n    # Only the first four elements need to be scaled\n    bboxes_for_assigner[..., :4] *= stride_tensor\n    _, target_bboxes, target_scores, fg_mask, _ = self.assigner(\n        pred_scores.detach().sigmoid(),\n        bboxes_for_assigner.type(gt_bboxes.dtype),\n        anchor_points * stride_tensor,\n        gt_labels,\n        gt_bboxes,\n        mask_gt,\n    )\n\n    target_scores_sum = max(target_scores.sum(), 1)\n\n    # Cls loss\n    # loss[1] = self.varifocal_loss(pred_scores, target_scores, target_labels) / target_scores_sum  # VFL way\n    loss[1] = self.bce(pred_scores, target_scores.to(dtype)).sum() / target_scores_sum  # BCE\n\n    # Bbox loss\n    if fg_mask.sum():\n        target_bboxes[..., :4] /= stride_tensor\n        loss[0], loss[2] = self.bbox_loss(\n            pred_distri, pred_bboxes, anchor_points, target_bboxes, target_scores, target_scores_sum, fg_mask\n        )\n    else:\n        loss[0] += (pred_angle * 0).sum()\n\n    loss[0] *= self.hyp.box  # box gain\n    loss[1] *= self.hyp.cls  # cls gain\n    loss[2] *= self.hyp.dfl  # dfl gain\n\n    return loss.sum() * batch_size, loss.detach()  # loss(box, cls, dfl)\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.v8OBBLoss.bbox_decode","title":"<code>bbox_decode(anchor_points, pred_dist, pred_angle)</code>","text":"<p>Decode predicted object bounding box coordinates from anchor points and distribution.</p> <p>Parameters:</p> Name Type Description Default <code>anchor_points</code> <code>Tensor</code> <p>Anchor points, (h*w, 2).</p> required <code>pred_dist</code> <code>Tensor</code> <p>Predicted rotated distance, (bs, h*w, 4).</p> required <code>pred_angle</code> <code>Tensor</code> <p>Predicted angle, (bs, h*w, 1).</p> required <p>Returns:     (torch.Tensor): Predicted rotated bounding boxes with angles, (bs, h*w, 5).</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>def bbox_decode(self, anchor_points, pred_dist, pred_angle):\n    \"\"\"\n    Decode predicted object bounding box coordinates from anchor points and distribution.\n\n    Args:\n        anchor_points (torch.Tensor): Anchor points, (h*w, 2).\n        pred_dist (torch.Tensor): Predicted rotated distance, (bs, h*w, 4).\n        pred_angle (torch.Tensor): Predicted angle, (bs, h*w, 1).\n    Returns:\n        (torch.Tensor): Predicted rotated bounding boxes with angles, (bs, h*w, 5).\n    \"\"\"\n    if self.use_dfl:\n        b, a, c = pred_dist.shape  # batch, anchors, channels\n        pred_dist = pred_dist.view(b, a, 4, c // 4).softmax(3).matmul(self.proj.type(pred_dist.dtype))\n    return torch.cat((dist2rbox(pred_dist, pred_angle, anchor_points), pred_angle), dim=-1)\n</code></pre>"},{"location":"reference/utils/loss/#ultralytics.utils.loss.v8OBBLoss.preprocess","title":"<code>preprocess(targets, batch_size, scale_tensor)</code>","text":"<p>Preprocesses the target counts and matches with the input batch size to output a tensor.</p> Source code in <code>ultralytics/utils/loss.py</code> <pre><code>def preprocess(self, targets, batch_size, scale_tensor):\n    \"\"\"Preprocesses the target counts and matches with the input batch size to output a tensor.\"\"\"\n    if targets.shape[0] == 0:\n        out = torch.zeros(batch_size, 0, 6, device=self.device)\n    else:\n        i = targets[:, 0]  # image index\n        _, counts = i.unique(return_counts=True)\n        counts = counts.to(dtype=torch.int32)\n        out = torch.zeros(batch_size, counts.max(), 6, device=self.device)\n        for j in range(batch_size):\n            matches = i == j\n            n = matches.sum()\n            if n:\n                bboxes = targets[matches, 2:]\n                bboxes[..., :4].mul_(scale_tensor)\n                out[j, :n] = torch.cat([targets[matches, 1:2], bboxes], dim=-1)\n    return out\n</code></pre>"},{"location":"reference/utils/metrics/","title":"Reference for <code>ultralytics/utils/metrics.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/metrics.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.ConfusionMatrix","title":"<code>ultralytics.utils.metrics.ConfusionMatrix</code>","text":"<p>A class for calculating and updating a confusion matrix for object detection and classification tasks.</p> <p>Attributes:</p> Name Type Description <code>task</code> <code>str</code> <p>The type of task, either 'detect' or 'classify'.</p> <code>matrix</code> <code>array</code> <p>The confusion matrix, with dimensions depending on the task.</p> <code>nc</code> <code>int</code> <p>The number of classes.</p> <code>conf</code> <code>float</code> <p>The confidence threshold for detections.</p> <code>iou_thres</code> <code>float</code> <p>The Intersection over Union threshold.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>class ConfusionMatrix:\n    \"\"\"\n    A class for calculating and updating a confusion matrix for object detection and classification tasks.\n\n    Attributes:\n        task (str): The type of task, either 'detect' or 'classify'.\n        matrix (np.array): The confusion matrix, with dimensions depending on the task.\n        nc (int): The number of classes.\n        conf (float): The confidence threshold for detections.\n        iou_thres (float): The Intersection over Union threshold.\n    \"\"\"\n\n    def __init__(self, nc, conf=0.25, iou_thres=0.45, task=\"detect\"):\n        \"\"\"Initialize attributes for the YOLO model.\"\"\"\n        self.task = task\n        self.matrix = np.zeros((nc + 1, nc + 1)) if self.task == \"detect\" else np.zeros((nc, nc))\n        self.nc = nc  # number of classes\n        self.conf = 0.25 if conf in (None, 0.001) else conf  # apply 0.25 if default val conf is passed\n        self.iou_thres = iou_thres\n\n    def process_cls_preds(self, preds, targets):\n        \"\"\"\n        Update confusion matrix for classification task.\n\n        Args:\n            preds (Array[N, min(nc,5)]): Predicted class labels.\n            targets (Array[N, 1]): Ground truth class labels.\n        \"\"\"\n        preds, targets = torch.cat(preds)[:, 0], torch.cat(targets)\n        for p, t in zip(preds.cpu().numpy(), targets.cpu().numpy()):\n            self.matrix[p][t] += 1\n\n    def process_batch(self, detections, gt_bboxes, gt_cls):\n        \"\"\"\n        Update confusion matrix for object detection task.\n\n        Args:\n            detections (Array[N, 6]): Detected bounding boxes and their associated information.\n                                      Each row should contain (x1, y1, x2, y2, conf, class).\n            gt_bboxes (Array[M, 4]): Ground truth bounding boxes with xyxy format.\n            gt_cls (Array[M]): The class labels.\n        \"\"\"\n        if gt_cls.size(0) == 0:  # Check if labels is empty\n            if detections is not None:\n                detections = detections[detections[:, 4] &gt; self.conf]\n                detection_classes = detections[:, 5].int()\n                for dc in detection_classes:\n                    self.matrix[dc, self.nc] += 1  # false positives\n            return\n        if detections is None:\n            gt_classes = gt_cls.int()\n            for gc in gt_classes:\n                self.matrix[self.nc, gc] += 1  # background FN\n            return\n\n        detections = detections[detections[:, 4] &gt; self.conf]\n        gt_classes = gt_cls.int()\n        detection_classes = detections[:, 5].int()\n        iou = box_iou(gt_bboxes, detections[:, :4])\n\n        x = torch.where(iou &gt; self.iou_thres)\n        if x[0].shape[0]:\n            matches = torch.cat((torch.stack(x, 1), iou[x[0], x[1]][:, None]), 1).cpu().numpy()\n            if x[0].shape[0] &gt; 1:\n                matches = matches[matches[:, 2].argsort()[::-1]]\n                matches = matches[np.unique(matches[:, 1], return_index=True)[1]]\n                matches = matches[matches[:, 2].argsort()[::-1]]\n                matches = matches[np.unique(matches[:, 0], return_index=True)[1]]\n        else:\n            matches = np.zeros((0, 3))\n\n        n = matches.shape[0] &gt; 0\n        m0, m1, _ = matches.transpose().astype(int)\n        for i, gc in enumerate(gt_classes):\n            j = m0 == i\n            if n and sum(j) == 1:\n                self.matrix[detection_classes[m1[j]], gc] += 1  # correct\n            else:\n                self.matrix[self.nc, gc] += 1  # true background\n\n        if n:\n            for i, dc in enumerate(detection_classes):\n                if not any(m1 == i):\n                    self.matrix[dc, self.nc] += 1  # predicted background\n\n    def matrix(self):\n        \"\"\"Returns the confusion matrix.\"\"\"\n        return self.matrix\n\n    def tp_fp(self):\n        \"\"\"Returns true positives and false positives.\"\"\"\n        tp = self.matrix.diagonal()  # true positives\n        fp = self.matrix.sum(1) - tp  # false positives\n        # fn = self.matrix.sum(0) - tp  # false negatives (missed detections)\n        return (tp[:-1], fp[:-1]) if self.task == \"detect\" else (tp, fp)  # remove background class if task=detect\n\n    @TryExcept(\"WARNING \u26a0\ufe0f ConfusionMatrix plot failure\")\n    @plt_settings()\n    def plot(self, normalize=True, save_dir=\"\", names=(), on_plot=None):\n        \"\"\"\n        Plot the confusion matrix using seaborn and save it to a file.\n\n        Args:\n            normalize (bool): Whether to normalize the confusion matrix.\n            save_dir (str): Directory where the plot will be saved.\n            names (tuple): Names of classes, used as labels on the plot.\n            on_plot (func): An optional callback to pass plots path and data when they are rendered.\n        \"\"\"\n        import seaborn as sn\n\n        array = self.matrix / ((self.matrix.sum(0).reshape(1, -1) + 1e-9) if normalize else 1)  # normalize columns\n        array[array &lt; 0.005] = np.nan  # don't annotate (would appear as 0.00)\n\n        fig, ax = plt.subplots(1, 1, figsize=(12, 9), tight_layout=True)\n        nc, nn = self.nc, len(names)  # number of classes, names\n        sn.set(font_scale=1.0 if nc &lt; 50 else 0.8)  # for label size\n        labels = (0 &lt; nn &lt; 99) and (nn == nc)  # apply names to ticklabels\n        ticklabels = (list(names) + [\"background\"]) if labels else \"auto\"\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")  # suppress empty matrix RuntimeWarning: All-NaN slice encountered\n            sn.heatmap(\n                array,\n                ax=ax,\n                annot=nc &lt; 30,\n                annot_kws={\"size\": 8},\n                cmap=\"Blues\",\n                fmt=\".2f\" if normalize else \".0f\",\n                square=True,\n                vmin=0.0,\n                xticklabels=ticklabels,\n                yticklabels=ticklabels,\n            ).set_facecolor((1, 1, 1))\n        title = \"Confusion Matrix\" + \" Normalized\" * normalize\n        ax.set_xlabel(\"True\")\n        ax.set_ylabel(\"Predicted\")\n        ax.set_title(title)\n        plot_fname = Path(save_dir) / f'{title.lower().replace(\" \", \"_\")}.png'\n        fig.savefig(plot_fname, dpi=250)\n        plt.close(fig)\n        if on_plot:\n            on_plot(plot_fname)\n\n    def print(self):\n        \"\"\"Print the confusion matrix to the console.\"\"\"\n        for i in range(self.nc + 1):\n            LOGGER.info(\" \".join(map(str, self.matrix[i])))\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.ConfusionMatrix.__init__","title":"<code>__init__(nc, conf=0.25, iou_thres=0.45, task='detect')</code>","text":"<p>Initialize attributes for the YOLO model.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def __init__(self, nc, conf=0.25, iou_thres=0.45, task=\"detect\"):\n    \"\"\"Initialize attributes for the YOLO model.\"\"\"\n    self.task = task\n    self.matrix = np.zeros((nc + 1, nc + 1)) if self.task == \"detect\" else np.zeros((nc, nc))\n    self.nc = nc  # number of classes\n    self.conf = 0.25 if conf in (None, 0.001) else conf  # apply 0.25 if default val conf is passed\n    self.iou_thres = iou_thres\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.ConfusionMatrix.matrix","title":"<code>matrix()</code>","text":"<p>Returns the confusion matrix.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def matrix(self):\n    \"\"\"Returns the confusion matrix.\"\"\"\n    return self.matrix\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.ConfusionMatrix.plot","title":"<code>plot(normalize=True, save_dir='', names=(), on_plot=None)</code>","text":"<p>Plot the confusion matrix using seaborn and save it to a file.</p> <p>Parameters:</p> Name Type Description Default <code>normalize</code> <code>bool</code> <p>Whether to normalize the confusion matrix.</p> <code>True</code> <code>save_dir</code> <code>str</code> <p>Directory where the plot will be saved.</p> <code>''</code> <code>names</code> <code>tuple</code> <p>Names of classes, used as labels on the plot.</p> <code>()</code> <code>on_plot</code> <code>func</code> <p>An optional callback to pass plots path and data when they are rendered.</p> <code>None</code> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>@TryExcept(\"WARNING \u26a0\ufe0f ConfusionMatrix plot failure\")\n@plt_settings()\ndef plot(self, normalize=True, save_dir=\"\", names=(), on_plot=None):\n    \"\"\"\n    Plot the confusion matrix using seaborn and save it to a file.\n\n    Args:\n        normalize (bool): Whether to normalize the confusion matrix.\n        save_dir (str): Directory where the plot will be saved.\n        names (tuple): Names of classes, used as labels on the plot.\n        on_plot (func): An optional callback to pass plots path and data when they are rendered.\n    \"\"\"\n    import seaborn as sn\n\n    array = self.matrix / ((self.matrix.sum(0).reshape(1, -1) + 1e-9) if normalize else 1)  # normalize columns\n    array[array &lt; 0.005] = np.nan  # don't annotate (would appear as 0.00)\n\n    fig, ax = plt.subplots(1, 1, figsize=(12, 9), tight_layout=True)\n    nc, nn = self.nc, len(names)  # number of classes, names\n    sn.set(font_scale=1.0 if nc &lt; 50 else 0.8)  # for label size\n    labels = (0 &lt; nn &lt; 99) and (nn == nc)  # apply names to ticklabels\n    ticklabels = (list(names) + [\"background\"]) if labels else \"auto\"\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")  # suppress empty matrix RuntimeWarning: All-NaN slice encountered\n        sn.heatmap(\n            array,\n            ax=ax,\n            annot=nc &lt; 30,\n            annot_kws={\"size\": 8},\n            cmap=\"Blues\",\n            fmt=\".2f\" if normalize else \".0f\",\n            square=True,\n            vmin=0.0,\n            xticklabels=ticklabels,\n            yticklabels=ticklabels,\n        ).set_facecolor((1, 1, 1))\n    title = \"Confusion Matrix\" + \" Normalized\" * normalize\n    ax.set_xlabel(\"True\")\n    ax.set_ylabel(\"Predicted\")\n    ax.set_title(title)\n    plot_fname = Path(save_dir) / f'{title.lower().replace(\" \", \"_\")}.png'\n    fig.savefig(plot_fname, dpi=250)\n    plt.close(fig)\n    if on_plot:\n        on_plot(plot_fname)\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.ConfusionMatrix.print","title":"<code>print()</code>","text":"<p>Print the confusion matrix to the console.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def print(self):\n    \"\"\"Print the confusion matrix to the console.\"\"\"\n    for i in range(self.nc + 1):\n        LOGGER.info(\" \".join(map(str, self.matrix[i])))\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.ConfusionMatrix.process_batch","title":"<code>process_batch(detections, gt_bboxes, gt_cls)</code>","text":"<p>Update confusion matrix for object detection task.</p> <p>Parameters:</p> Name Type Description Default <code>detections</code> <code>Array[N, 6]</code> <p>Detected bounding boxes and their associated information.                       Each row should contain (x1, y1, x2, y2, conf, class).</p> required <code>gt_bboxes</code> <code>Array[M, 4]</code> <p>Ground truth bounding boxes with xyxy format.</p> required <code>gt_cls</code> <code>Array[M]</code> <p>The class labels.</p> required Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def process_batch(self, detections, gt_bboxes, gt_cls):\n    \"\"\"\n    Update confusion matrix for object detection task.\n\n    Args:\n        detections (Array[N, 6]): Detected bounding boxes and their associated information.\n                                  Each row should contain (x1, y1, x2, y2, conf, class).\n        gt_bboxes (Array[M, 4]): Ground truth bounding boxes with xyxy format.\n        gt_cls (Array[M]): The class labels.\n    \"\"\"\n    if gt_cls.size(0) == 0:  # Check if labels is empty\n        if detections is not None:\n            detections = detections[detections[:, 4] &gt; self.conf]\n            detection_classes = detections[:, 5].int()\n            for dc in detection_classes:\n                self.matrix[dc, self.nc] += 1  # false positives\n        return\n    if detections is None:\n        gt_classes = gt_cls.int()\n        for gc in gt_classes:\n            self.matrix[self.nc, gc] += 1  # background FN\n        return\n\n    detections = detections[detections[:, 4] &gt; self.conf]\n    gt_classes = gt_cls.int()\n    detection_classes = detections[:, 5].int()\n    iou = box_iou(gt_bboxes, detections[:, :4])\n\n    x = torch.where(iou &gt; self.iou_thres)\n    if x[0].shape[0]:\n        matches = torch.cat((torch.stack(x, 1), iou[x[0], x[1]][:, None]), 1).cpu().numpy()\n        if x[0].shape[0] &gt; 1:\n            matches = matches[matches[:, 2].argsort()[::-1]]\n            matches = matches[np.unique(matches[:, 1], return_index=True)[1]]\n            matches = matches[matches[:, 2].argsort()[::-1]]\n            matches = matches[np.unique(matches[:, 0], return_index=True)[1]]\n    else:\n        matches = np.zeros((0, 3))\n\n    n = matches.shape[0] &gt; 0\n    m0, m1, _ = matches.transpose().astype(int)\n    for i, gc in enumerate(gt_classes):\n        j = m0 == i\n        if n and sum(j) == 1:\n            self.matrix[detection_classes[m1[j]], gc] += 1  # correct\n        else:\n            self.matrix[self.nc, gc] += 1  # true background\n\n    if n:\n        for i, dc in enumerate(detection_classes):\n            if not any(m1 == i):\n                self.matrix[dc, self.nc] += 1  # predicted background\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.ConfusionMatrix.process_cls_preds","title":"<code>process_cls_preds(preds, targets)</code>","text":"<p>Update confusion matrix for classification task.</p> <p>Parameters:</p> Name Type Description Default <code>preds</code> <code>Array[N, min(nc, 5)]</code> <p>Predicted class labels.</p> required <code>targets</code> <code>Array[N, 1]</code> <p>Ground truth class labels.</p> required Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def process_cls_preds(self, preds, targets):\n    \"\"\"\n    Update confusion matrix for classification task.\n\n    Args:\n        preds (Array[N, min(nc,5)]): Predicted class labels.\n        targets (Array[N, 1]): Ground truth class labels.\n    \"\"\"\n    preds, targets = torch.cat(preds)[:, 0], torch.cat(targets)\n    for p, t in zip(preds.cpu().numpy(), targets.cpu().numpy()):\n        self.matrix[p][t] += 1\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.ConfusionMatrix.tp_fp","title":"<code>tp_fp()</code>","text":"<p>Returns true positives and false positives.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def tp_fp(self):\n    \"\"\"Returns true positives and false positives.\"\"\"\n    tp = self.matrix.diagonal()  # true positives\n    fp = self.matrix.sum(1) - tp  # false positives\n    # fn = self.matrix.sum(0) - tp  # false negatives (missed detections)\n    return (tp[:-1], fp[:-1]) if self.task == \"detect\" else (tp, fp)  # remove background class if task=detect\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.Metric","title":"<code>ultralytics.utils.metrics.Metric</code>","text":"<p>             Bases: <code>SimpleClass</code></p> <p>Class for computing evaluation metrics for YOLOv8 model.</p> <p>Attributes:</p> Name Type Description <code>p</code> <code>list</code> <p>Precision for each class. Shape: (nc,).</p> <code>r</code> <code>list</code> <p>Recall for each class. Shape: (nc,).</p> <code>f1</code> <code>list</code> <p>F1 score for each class. Shape: (nc,).</p> <code>all_ap</code> <code>list</code> <p>AP scores for all classes and all IoU thresholds. Shape: (nc, 10).</p> <code>ap_class_index</code> <code>list</code> <p>Index of class for each AP score. Shape: (nc,).</p> <code>nc</code> <code>int</code> <p>Number of classes.</p> <p>Methods:</p> Name Description <code>ap50</code> <p>AP at IoU threshold of 0.5 for all classes. Returns: List of AP scores. Shape: (nc,) or [].</p> <code>ap</code> <p>AP at IoU thresholds from 0.5 to 0.95 for all classes. Returns: List of AP scores. Shape: (nc,) or [].</p> <code>mp</code> <p>Mean precision of all classes. Returns: Float.</p> <code>mr</code> <p>Mean recall of all classes. Returns: Float.</p> <code>map50</code> <p>Mean AP at IoU threshold of 0.5 for all classes. Returns: Float.</p> <code>map75</code> <p>Mean AP at IoU threshold of 0.75 for all classes. Returns: Float.</p> <code>map</code> <p>Mean AP at IoU thresholds from 0.5 to 0.95 for all classes. Returns: Float.</p> <code>mean_results</code> <p>Mean of results, returns mp, mr, map50, map.</p> <code>class_result</code> <p>Class-aware result, returns p[i], r[i], ap50[i], ap[i].</p> <code>maps</code> <p>mAP of each class. Returns: Array of mAP scores, shape: (nc,).</p> <code>fitness</code> <p>Model fitness as a weighted combination of metrics. Returns: Float.</p> <code>update</code> <p>Update metric attributes with new evaluation results.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>class Metric(SimpleClass):\n    \"\"\"\n    Class for computing evaluation metrics for YOLOv8 model.\n\n    Attributes:\n        p (list): Precision for each class. Shape: (nc,).\n        r (list): Recall for each class. Shape: (nc,).\n        f1 (list): F1 score for each class. Shape: (nc,).\n        all_ap (list): AP scores for all classes and all IoU thresholds. Shape: (nc, 10).\n        ap_class_index (list): Index of class for each AP score. Shape: (nc,).\n        nc (int): Number of classes.\n\n    Methods:\n        ap50(): AP at IoU threshold of 0.5 for all classes. Returns: List of AP scores. Shape: (nc,) or [].\n        ap(): AP at IoU thresholds from 0.5 to 0.95 for all classes. Returns: List of AP scores. Shape: (nc,) or [].\n        mp(): Mean precision of all classes. Returns: Float.\n        mr(): Mean recall of all classes. Returns: Float.\n        map50(): Mean AP at IoU threshold of 0.5 for all classes. Returns: Float.\n        map75(): Mean AP at IoU threshold of 0.75 for all classes. Returns: Float.\n        map(): Mean AP at IoU thresholds from 0.5 to 0.95 for all classes. Returns: Float.\n        mean_results(): Mean of results, returns mp, mr, map50, map.\n        class_result(i): Class-aware result, returns p[i], r[i], ap50[i], ap[i].\n        maps(): mAP of each class. Returns: Array of mAP scores, shape: (nc,).\n        fitness(): Model fitness as a weighted combination of metrics. Returns: Float.\n        update(results): Update metric attributes with new evaluation results.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initializes a Metric instance for computing evaluation metrics for the YOLOv8 model.\"\"\"\n        self.p = []  # (nc, )\n        self.r = []  # (nc, )\n        self.f1 = []  # (nc, )\n        self.all_ap = []  # (nc, 10)\n        self.ap_class_index = []  # (nc, )\n        self.nc = 0\n\n    @property\n    def ap50(self):\n        \"\"\"\n        Returns the Average Precision (AP) at an IoU threshold of 0.5 for all classes.\n\n        Returns:\n            (np.ndarray, list): Array of shape (nc,) with AP50 values per class, or an empty list if not available.\n        \"\"\"\n        return self.all_ap[:, 0] if len(self.all_ap) else []\n\n    @property\n    def ap(self):\n        \"\"\"\n        Returns the Average Precision (AP) at an IoU threshold of 0.5-0.95 for all classes.\n\n        Returns:\n            (np.ndarray, list): Array of shape (nc,) with AP50-95 values per class, or an empty list if not available.\n        \"\"\"\n        return self.all_ap.mean(1) if len(self.all_ap) else []\n\n    @property\n    def mp(self):\n        \"\"\"\n        Returns the Mean Precision of all classes.\n\n        Returns:\n            (float): The mean precision of all classes.\n        \"\"\"\n        return self.p.mean() if len(self.p) else 0.0\n\n    @property\n    def mr(self):\n        \"\"\"\n        Returns the Mean Recall of all classes.\n\n        Returns:\n            (float): The mean recall of all classes.\n        \"\"\"\n        return self.r.mean() if len(self.r) else 0.0\n\n    @property\n    def map50(self):\n        \"\"\"\n        Returns the mean Average Precision (mAP) at an IoU threshold of 0.5.\n\n        Returns:\n            (float): The mAP50 at an IoU threshold of 0.5.\n        \"\"\"\n        return self.all_ap[:, 0].mean() if len(self.all_ap) else 0.0\n\n    @property\n    def map75(self):\n        \"\"\"\n        Returns the mean Average Precision (mAP) at an IoU threshold of 0.75.\n\n        Returns:\n            (float): The mAP50 at an IoU threshold of 0.75.\n        \"\"\"\n        return self.all_ap[:, 5].mean() if len(self.all_ap) else 0.0\n\n    @property\n    def map(self):\n        \"\"\"\n        Returns the mean Average Precision (mAP) over IoU thresholds of 0.5 - 0.95 in steps of 0.05.\n\n        Returns:\n            (float): The mAP over IoU thresholds of 0.5 - 0.95 in steps of 0.05.\n        \"\"\"\n        return self.all_ap.mean() if len(self.all_ap) else 0.0\n\n    def mean_results(self):\n        \"\"\"Mean of results, return mp, mr, map50, map.\"\"\"\n        return [self.mp, self.mr, self.map50, self.map]\n\n    def class_result(self, i):\n        \"\"\"Class-aware result, return p[i], r[i], ap50[i], ap[i].\"\"\"\n        return self.p[i], self.r[i], self.ap50[i], self.ap[i]\n\n    @property\n    def maps(self):\n        \"\"\"MAP of each class.\"\"\"\n        maps = np.zeros(self.nc) + self.map\n        for i, c in enumerate(self.ap_class_index):\n            maps[c] = self.ap[i]\n        return maps\n\n    def fitness(self):\n        \"\"\"Model fitness as a weighted combination of metrics.\"\"\"\n        w = [0.0, 0.0, 0.1, 0.9]  # weights for [P, R, mAP@0.5, mAP@0.5:0.95]\n        return (np.array(self.mean_results()) * w).sum()\n\n    def update(self, results):\n        \"\"\"\n        Updates the evaluation metrics of the model with a new set of results.\n\n        Args:\n            results (tuple): A tuple containing the following evaluation metrics:\n                - p (list): Precision for each class. Shape: (nc,).\n                - r (list): Recall for each class. Shape: (nc,).\n                - f1 (list): F1 score for each class. Shape: (nc,).\n                - all_ap (list): AP scores for all classes and all IoU thresholds. Shape: (nc, 10).\n                - ap_class_index (list): Index of class for each AP score. Shape: (nc,).\n\n        Side Effects:\n            Updates the class attributes `self.p`, `self.r`, `self.f1`, `self.all_ap`, and `self.ap_class_index` based\n            on the values provided in the `results` tuple.\n        \"\"\"\n        (\n            self.p,\n            self.r,\n            self.f1,\n            self.all_ap,\n            self.ap_class_index,\n            self.p_curve,\n            self.r_curve,\n            self.f1_curve,\n            self.px,\n            self.prec_values,\n        ) = results\n\n    @property\n    def curves(self):\n        \"\"\"Returns a list of curves for accessing specific metrics curves.\"\"\"\n        return []\n\n    @property\n    def curves_results(self):\n        \"\"\"Returns a list of curves for accessing specific metrics curves.\"\"\"\n        return [\n            [self.px, self.prec_values, \"Recall\", \"Precision\"],\n            [self.px, self.f1_curve, \"Confidence\", \"F1\"],\n            [self.px, self.p_curve, \"Confidence\", \"Precision\"],\n            [self.px, self.r_curve, \"Confidence\", \"Recall\"],\n        ]\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.Metric.ap","title":"<code>ap</code>  <code>property</code>","text":"<p>Returns the Average Precision (AP) at an IoU threshold of 0.5-0.95 for all classes.</p> <p>Returns:</p> Type Description <code>(ndarray, list)</code> <p>Array of shape (nc,) with AP50-95 values per class, or an empty list if not available.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.Metric.ap50","title":"<code>ap50</code>  <code>property</code>","text":"<p>Returns the Average Precision (AP) at an IoU threshold of 0.5 for all classes.</p> <p>Returns:</p> Type Description <code>(ndarray, list)</code> <p>Array of shape (nc,) with AP50 values per class, or an empty list if not available.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.Metric.curves","title":"<code>curves</code>  <code>property</code>","text":"<p>Returns a list of curves for accessing specific metrics curves.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.Metric.curves_results","title":"<code>curves_results</code>  <code>property</code>","text":"<p>Returns a list of curves for accessing specific metrics curves.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.Metric.map","title":"<code>map</code>  <code>property</code>","text":"<p>Returns the mean Average Precision (mAP) over IoU thresholds of 0.5 - 0.95 in steps of 0.05.</p> <p>Returns:</p> Type Description <code>float</code> <p>The mAP over IoU thresholds of 0.5 - 0.95 in steps of 0.05.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.Metric.map50","title":"<code>map50</code>  <code>property</code>","text":"<p>Returns the mean Average Precision (mAP) at an IoU threshold of 0.5.</p> <p>Returns:</p> Type Description <code>float</code> <p>The mAP50 at an IoU threshold of 0.5.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.Metric.map75","title":"<code>map75</code>  <code>property</code>","text":"<p>Returns the mean Average Precision (mAP) at an IoU threshold of 0.75.</p> <p>Returns:</p> Type Description <code>float</code> <p>The mAP50 at an IoU threshold of 0.75.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.Metric.maps","title":"<code>maps</code>  <code>property</code>","text":"<p>MAP of each class.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.Metric.mp","title":"<code>mp</code>  <code>property</code>","text":"<p>Returns the Mean Precision of all classes.</p> <p>Returns:</p> Type Description <code>float</code> <p>The mean precision of all classes.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.Metric.mr","title":"<code>mr</code>  <code>property</code>","text":"<p>Returns the Mean Recall of all classes.</p> <p>Returns:</p> Type Description <code>float</code> <p>The mean recall of all classes.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.Metric.__init__","title":"<code>__init__()</code>","text":"<p>Initializes a Metric instance for computing evaluation metrics for the YOLOv8 model.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initializes a Metric instance for computing evaluation metrics for the YOLOv8 model.\"\"\"\n    self.p = []  # (nc, )\n    self.r = []  # (nc, )\n    self.f1 = []  # (nc, )\n    self.all_ap = []  # (nc, 10)\n    self.ap_class_index = []  # (nc, )\n    self.nc = 0\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.Metric.class_result","title":"<code>class_result(i)</code>","text":"<p>Class-aware result, return p[i], r[i], ap50[i], ap[i].</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def class_result(self, i):\n    \"\"\"Class-aware result, return p[i], r[i], ap50[i], ap[i].\"\"\"\n    return self.p[i], self.r[i], self.ap50[i], self.ap[i]\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.Metric.fitness","title":"<code>fitness()</code>","text":"<p>Model fitness as a weighted combination of metrics.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def fitness(self):\n    \"\"\"Model fitness as a weighted combination of metrics.\"\"\"\n    w = [0.0, 0.0, 0.1, 0.9]  # weights for [P, R, mAP@0.5, mAP@0.5:0.95]\n    return (np.array(self.mean_results()) * w).sum()\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.Metric.mean_results","title":"<code>mean_results()</code>","text":"<p>Mean of results, return mp, mr, map50, map.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def mean_results(self):\n    \"\"\"Mean of results, return mp, mr, map50, map.\"\"\"\n    return [self.mp, self.mr, self.map50, self.map]\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.Metric.update","title":"<code>update(results)</code>","text":"<p>Updates the evaluation metrics of the model with a new set of results.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>tuple</code> <p>A tuple containing the following evaluation metrics: - p (list): Precision for each class. Shape: (nc,). - r (list): Recall for each class. Shape: (nc,). - f1 (list): F1 score for each class. Shape: (nc,). - all_ap (list): AP scores for all classes and all IoU thresholds. Shape: (nc, 10). - ap_class_index (list): Index of class for each AP score. Shape: (nc,).</p> required Side Effects <p>Updates the class attributes <code>self.p</code>, <code>self.r</code>, <code>self.f1</code>, <code>self.all_ap</code>, and <code>self.ap_class_index</code> based on the values provided in the <code>results</code> tuple.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def update(self, results):\n    \"\"\"\n    Updates the evaluation metrics of the model with a new set of results.\n\n    Args:\n        results (tuple): A tuple containing the following evaluation metrics:\n            - p (list): Precision for each class. Shape: (nc,).\n            - r (list): Recall for each class. Shape: (nc,).\n            - f1 (list): F1 score for each class. Shape: (nc,).\n            - all_ap (list): AP scores for all classes and all IoU thresholds. Shape: (nc, 10).\n            - ap_class_index (list): Index of class for each AP score. Shape: (nc,).\n\n    Side Effects:\n        Updates the class attributes `self.p`, `self.r`, `self.f1`, `self.all_ap`, and `self.ap_class_index` based\n        on the values provided in the `results` tuple.\n    \"\"\"\n    (\n        self.p,\n        self.r,\n        self.f1,\n        self.all_ap,\n        self.ap_class_index,\n        self.p_curve,\n        self.r_curve,\n        self.f1_curve,\n        self.px,\n        self.prec_values,\n    ) = results\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.DetMetrics","title":"<code>ultralytics.utils.metrics.DetMetrics</code>","text":"<p>             Bases: <code>SimpleClass</code></p> <p>This class is a utility class for computing detection metrics such as precision, recall, and mean average precision (mAP) of an object detection model.</p> <p>Parameters:</p> Name Type Description Default <code>save_dir</code> <code>Path</code> <p>A path to the directory where the output plots will be saved. Defaults to current directory.</p> <code>Path('.')</code> <code>plot</code> <code>bool</code> <p>A flag that indicates whether to plot precision-recall curves for each class. Defaults to False.</p> <code>False</code> <code>on_plot</code> <code>func</code> <p>An optional callback to pass plots path and data when they are rendered. Defaults to None.</p> <code>None</code> <code>names</code> <code>tuple of str</code> <p>A tuple of strings that represents the names of the classes. Defaults to an empty tuple.</p> <code>()</code> <p>Attributes:</p> Name Type Description <code>save_dir</code> <code>Path</code> <p>A path to the directory where the output plots will be saved.</p> <code>plot</code> <code>bool</code> <p>A flag that indicates whether to plot the precision-recall curves for each class.</p> <code>on_plot</code> <code>func</code> <p>An optional callback to pass plots path and data when they are rendered.</p> <code>names</code> <code>tuple of str</code> <p>A tuple of strings that represents the names of the classes.</p> <code>box</code> <code>Metric</code> <p>An instance of the Metric class for storing the results of the detection metrics.</p> <code>speed</code> <code>dict</code> <p>A dictionary for storing the execution time of different parts of the detection process.</p> <p>Methods:</p> Name Description <code>process</code> <p>Updates the metric results with the latest batch of predictions.</p> <code>keys</code> <p>Returns a list of keys for accessing the computed detection metrics.</p> <code>mean_results</code> <p>Returns a list of mean values for the computed detection metrics.</p> <code>class_result</code> <p>Returns a list of values for the computed detection metrics for a specific class.</p> <code>maps</code> <p>Returns a dictionary of mean average precision (mAP) values for different IoU thresholds.</p> <code>fitness</code> <p>Computes the fitness score based on the computed detection metrics.</p> <code>ap_class_index</code> <p>Returns a list of class indices sorted by their average precision (AP) values.</p> <code>results_dict</code> <p>Returns a dictionary that maps detection metric keys to their computed values.</p> <code>curves</code> <p>TODO</p> <code>curves_results</code> <p>TODO</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>class DetMetrics(SimpleClass):\n    \"\"\"\n    This class is a utility class for computing detection metrics such as precision, recall, and mean average precision\n    (mAP) of an object detection model.\n\n    Args:\n        save_dir (Path): A path to the directory where the output plots will be saved. Defaults to current directory.\n        plot (bool): A flag that indicates whether to plot precision-recall curves for each class. Defaults to False.\n        on_plot (func): An optional callback to pass plots path and data when they are rendered. Defaults to None.\n        names (tuple of str): A tuple of strings that represents the names of the classes. Defaults to an empty tuple.\n\n    Attributes:\n        save_dir (Path): A path to the directory where the output plots will be saved.\n        plot (bool): A flag that indicates whether to plot the precision-recall curves for each class.\n        on_plot (func): An optional callback to pass plots path and data when they are rendered.\n        names (tuple of str): A tuple of strings that represents the names of the classes.\n        box (Metric): An instance of the Metric class for storing the results of the detection metrics.\n        speed (dict): A dictionary for storing the execution time of different parts of the detection process.\n\n    Methods:\n        process(tp, conf, pred_cls, target_cls): Updates the metric results with the latest batch of predictions.\n        keys: Returns a list of keys for accessing the computed detection metrics.\n        mean_results: Returns a list of mean values for the computed detection metrics.\n        class_result(i): Returns a list of values for the computed detection metrics for a specific class.\n        maps: Returns a dictionary of mean average precision (mAP) values for different IoU thresholds.\n        fitness: Computes the fitness score based on the computed detection metrics.\n        ap_class_index: Returns a list of class indices sorted by their average precision (AP) values.\n        results_dict: Returns a dictionary that maps detection metric keys to their computed values.\n        curves: TODO\n        curves_results: TODO\n    \"\"\"\n\n    def __init__(self, save_dir=Path(\".\"), plot=False, on_plot=None, names=()) -&gt; None:\n        \"\"\"Initialize a DetMetrics instance with a save directory, plot flag, callback function, and class names.\"\"\"\n        self.save_dir = save_dir\n        self.plot = plot\n        self.on_plot = on_plot\n        self.names = names\n        self.box = Metric()\n        self.speed = {\"preprocess\": 0.0, \"inference\": 0.0, \"loss\": 0.0, \"postprocess\": 0.0}\n        self.task = \"detect\"\n\n    def process(self, tp, conf, pred_cls, target_cls):\n        \"\"\"Process predicted results for object detection and update metrics.\"\"\"\n        results = ap_per_class(\n            tp,\n            conf,\n            pred_cls,\n            target_cls,\n            plot=self.plot,\n            save_dir=self.save_dir,\n            names=self.names,\n            on_plot=self.on_plot,\n        )[2:]\n        self.box.nc = len(self.names)\n        self.box.update(results)\n\n    @property\n    def keys(self):\n        \"\"\"Returns a list of keys for accessing specific metrics.\"\"\"\n        return [\"metrics/precision(B)\", \"metrics/recall(B)\", \"metrics/mAP50(B)\", \"metrics/mAP50-95(B)\"]\n\n    def mean_results(self):\n        \"\"\"Calculate mean of detected objects &amp; return precision, recall, mAP50, and mAP50-95.\"\"\"\n        return self.box.mean_results()\n\n    def class_result(self, i):\n        \"\"\"Return the result of evaluating the performance of an object detection model on a specific class.\"\"\"\n        return self.box.class_result(i)\n\n    @property\n    def maps(self):\n        \"\"\"Returns mean Average Precision (mAP) scores per class.\"\"\"\n        return self.box.maps\n\n    @property\n    def fitness(self):\n        \"\"\"Returns the fitness of box object.\"\"\"\n        return self.box.fitness()\n\n    @property\n    def ap_class_index(self):\n        \"\"\"Returns the average precision index per class.\"\"\"\n        return self.box.ap_class_index\n\n    @property\n    def results_dict(self):\n        \"\"\"Returns dictionary of computed performance metrics and statistics.\"\"\"\n        return dict(zip(self.keys + [\"fitness\"], self.mean_results() + [self.fitness]))\n\n    @property\n    def curves(self):\n        \"\"\"Returns a list of curves for accessing specific metrics curves.\"\"\"\n        return [\"Precision-Recall(B)\", \"F1-Confidence(B)\", \"Precision-Confidence(B)\", \"Recall-Confidence(B)\"]\n\n    @property\n    def curves_results(self):\n        \"\"\"Returns dictionary of computed performance metrics and statistics.\"\"\"\n        return self.box.curves_results\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.DetMetrics.ap_class_index","title":"<code>ap_class_index</code>  <code>property</code>","text":"<p>Returns the average precision index per class.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.DetMetrics.curves","title":"<code>curves</code>  <code>property</code>","text":"<p>Returns a list of curves for accessing specific metrics curves.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.DetMetrics.curves_results","title":"<code>curves_results</code>  <code>property</code>","text":"<p>Returns dictionary of computed performance metrics and statistics.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.DetMetrics.fitness","title":"<code>fitness</code>  <code>property</code>","text":"<p>Returns the fitness of box object.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.DetMetrics.keys","title":"<code>keys</code>  <code>property</code>","text":"<p>Returns a list of keys for accessing specific metrics.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.DetMetrics.maps","title":"<code>maps</code>  <code>property</code>","text":"<p>Returns mean Average Precision (mAP) scores per class.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.DetMetrics.results_dict","title":"<code>results_dict</code>  <code>property</code>","text":"<p>Returns dictionary of computed performance metrics and statistics.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.DetMetrics.__init__","title":"<code>__init__(save_dir=Path('.'), plot=False, on_plot=None, names=())</code>","text":"<p>Initialize a DetMetrics instance with a save directory, plot flag, callback function, and class names.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def __init__(self, save_dir=Path(\".\"), plot=False, on_plot=None, names=()) -&gt; None:\n    \"\"\"Initialize a DetMetrics instance with a save directory, plot flag, callback function, and class names.\"\"\"\n    self.save_dir = save_dir\n    self.plot = plot\n    self.on_plot = on_plot\n    self.names = names\n    self.box = Metric()\n    self.speed = {\"preprocess\": 0.0, \"inference\": 0.0, \"loss\": 0.0, \"postprocess\": 0.0}\n    self.task = \"detect\"\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.DetMetrics.class_result","title":"<code>class_result(i)</code>","text":"<p>Return the result of evaluating the performance of an object detection model on a specific class.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def class_result(self, i):\n    \"\"\"Return the result of evaluating the performance of an object detection model on a specific class.\"\"\"\n    return self.box.class_result(i)\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.DetMetrics.mean_results","title":"<code>mean_results()</code>","text":"<p>Calculate mean of detected objects &amp; return precision, recall, mAP50, and mAP50-95.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def mean_results(self):\n    \"\"\"Calculate mean of detected objects &amp; return precision, recall, mAP50, and mAP50-95.\"\"\"\n    return self.box.mean_results()\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.DetMetrics.process","title":"<code>process(tp, conf, pred_cls, target_cls)</code>","text":"<p>Process predicted results for object detection and update metrics.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def process(self, tp, conf, pred_cls, target_cls):\n    \"\"\"Process predicted results for object detection and update metrics.\"\"\"\n    results = ap_per_class(\n        tp,\n        conf,\n        pred_cls,\n        target_cls,\n        plot=self.plot,\n        save_dir=self.save_dir,\n        names=self.names,\n        on_plot=self.on_plot,\n    )[2:]\n    self.box.nc = len(self.names)\n    self.box.update(results)\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.SegmentMetrics","title":"<code>ultralytics.utils.metrics.SegmentMetrics</code>","text":"<p>             Bases: <code>SimpleClass</code></p> <p>Calculates and aggregates detection and segmentation metrics over a given set of classes.</p> <p>Parameters:</p> Name Type Description Default <code>save_dir</code> <code>Path</code> <p>Path to the directory where the output plots should be saved. Default is the current directory.</p> <code>Path('.')</code> <code>plot</code> <code>bool</code> <p>Whether to save the detection and segmentation plots. Default is False.</p> <code>False</code> <code>on_plot</code> <code>func</code> <p>An optional callback to pass plots path and data when they are rendered. Defaults to None.</p> <code>None</code> <code>names</code> <code>list</code> <p>List of class names. Default is an empty list.</p> <code>()</code> <p>Attributes:</p> Name Type Description <code>save_dir</code> <code>Path</code> <p>Path to the directory where the output plots should be saved.</p> <code>plot</code> <code>bool</code> <p>Whether to save the detection and segmentation plots.</p> <code>on_plot</code> <code>func</code> <p>An optional callback to pass plots path and data when they are rendered.</p> <code>names</code> <code>list</code> <p>List of class names.</p> <code>box</code> <code>Metric</code> <p>An instance of the Metric class to calculate box detection metrics.</p> <code>seg</code> <code>Metric</code> <p>An instance of the Metric class to calculate mask segmentation metrics.</p> <code>speed</code> <code>dict</code> <p>Dictionary to store the time taken in different phases of inference.</p> <p>Methods:</p> Name Description <code>process</code> <p>Processes metrics over the given set of predictions.</p> <code>mean_results</code> <p>Returns the mean of the detection and segmentation metrics over all the classes.</p> <code>class_result</code> <p>Returns the detection and segmentation metrics of class <code>i</code>.</p> <code>maps</code> <p>Returns the mean Average Precision (mAP) scores for IoU thresholds ranging from 0.50 to 0.95.</p> <code>fitness</code> <p>Returns the fitness scores, which are a single weighted combination of metrics.</p> <code>ap_class_index</code> <p>Returns the list of indices of classes used to compute Average Precision (AP).</p> <code>results_dict</code> <p>Returns the dictionary containing all the detection and segmentation metrics and fitness score.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>class SegmentMetrics(SimpleClass):\n    \"\"\"\n    Calculates and aggregates detection and segmentation metrics over a given set of classes.\n\n    Args:\n        save_dir (Path): Path to the directory where the output plots should be saved. Default is the current directory.\n        plot (bool): Whether to save the detection and segmentation plots. Default is False.\n        on_plot (func): An optional callback to pass plots path and data when they are rendered. Defaults to None.\n        names (list): List of class names. Default is an empty list.\n\n    Attributes:\n        save_dir (Path): Path to the directory where the output plots should be saved.\n        plot (bool): Whether to save the detection and segmentation plots.\n        on_plot (func): An optional callback to pass plots path and data when they are rendered.\n        names (list): List of class names.\n        box (Metric): An instance of the Metric class to calculate box detection metrics.\n        seg (Metric): An instance of the Metric class to calculate mask segmentation metrics.\n        speed (dict): Dictionary to store the time taken in different phases of inference.\n\n    Methods:\n        process(tp_m, tp_b, conf, pred_cls, target_cls): Processes metrics over the given set of predictions.\n        mean_results(): Returns the mean of the detection and segmentation metrics over all the classes.\n        class_result(i): Returns the detection and segmentation metrics of class `i`.\n        maps: Returns the mean Average Precision (mAP) scores for IoU thresholds ranging from 0.50 to 0.95.\n        fitness: Returns the fitness scores, which are a single weighted combination of metrics.\n        ap_class_index: Returns the list of indices of classes used to compute Average Precision (AP).\n        results_dict: Returns the dictionary containing all the detection and segmentation metrics and fitness score.\n    \"\"\"\n\n    def __init__(self, save_dir=Path(\".\"), plot=False, on_plot=None, names=()) -&gt; None:\n        \"\"\"Initialize a SegmentMetrics instance with a save directory, plot flag, callback function, and class names.\"\"\"\n        self.save_dir = save_dir\n        self.plot = plot\n        self.on_plot = on_plot\n        self.names = names\n        self.box = Metric()\n        self.seg = Metric()\n        self.speed = {\"preprocess\": 0.0, \"inference\": 0.0, \"loss\": 0.0, \"postprocess\": 0.0}\n        self.task = \"segment\"\n\n    def process(self, tp, tp_m, conf, pred_cls, target_cls):\n        \"\"\"\n        Processes the detection and segmentation metrics over the given set of predictions.\n\n        Args:\n            tp (list): List of True Positive boxes.\n            tp_m (list): List of True Positive masks.\n            conf (list): List of confidence scores.\n            pred_cls (list): List of predicted classes.\n            target_cls (list): List of target classes.\n        \"\"\"\n\n        results_mask = ap_per_class(\n            tp_m,\n            conf,\n            pred_cls,\n            target_cls,\n            plot=self.plot,\n            on_plot=self.on_plot,\n            save_dir=self.save_dir,\n            names=self.names,\n            prefix=\"Mask\",\n        )[2:]\n        self.seg.nc = len(self.names)\n        self.seg.update(results_mask)\n        results_box = ap_per_class(\n            tp,\n            conf,\n            pred_cls,\n            target_cls,\n            plot=self.plot,\n            on_plot=self.on_plot,\n            save_dir=self.save_dir,\n            names=self.names,\n            prefix=\"Box\",\n        )[2:]\n        self.box.nc = len(self.names)\n        self.box.update(results_box)\n\n    @property\n    def keys(self):\n        \"\"\"Returns a list of keys for accessing metrics.\"\"\"\n        return [\n            \"metrics/precision(B)\",\n            \"metrics/recall(B)\",\n            \"metrics/mAP50(B)\",\n            \"metrics/mAP50-95(B)\",\n            \"metrics/precision(M)\",\n            \"metrics/recall(M)\",\n            \"metrics/mAP50(M)\",\n            \"metrics/mAP50-95(M)\",\n        ]\n\n    def mean_results(self):\n        \"\"\"Return the mean metrics for bounding box and segmentation results.\"\"\"\n        return self.box.mean_results() + self.seg.mean_results()\n\n    def class_result(self, i):\n        \"\"\"Returns classification results for a specified class index.\"\"\"\n        return self.box.class_result(i) + self.seg.class_result(i)\n\n    @property\n    def maps(self):\n        \"\"\"Returns mAP scores for object detection and semantic segmentation models.\"\"\"\n        return self.box.maps + self.seg.maps\n\n    @property\n    def fitness(self):\n        \"\"\"Get the fitness score for both segmentation and bounding box models.\"\"\"\n        return self.seg.fitness() + self.box.fitness()\n\n    @property\n    def ap_class_index(self):\n        \"\"\"Boxes and masks have the same ap_class_index.\"\"\"\n        return self.box.ap_class_index\n\n    @property\n    def results_dict(self):\n        \"\"\"Returns results of object detection model for evaluation.\"\"\"\n        return dict(zip(self.keys + [\"fitness\"], self.mean_results() + [self.fitness]))\n\n    @property\n    def curves(self):\n        \"\"\"Returns a list of curves for accessing specific metrics curves.\"\"\"\n        return [\n            \"Precision-Recall(B)\",\n            \"F1-Confidence(B)\",\n            \"Precision-Confidence(B)\",\n            \"Recall-Confidence(B)\",\n            \"Precision-Recall(M)\",\n            \"F1-Confidence(M)\",\n            \"Precision-Confidence(M)\",\n            \"Recall-Confidence(M)\",\n        ]\n\n    @property\n    def curves_results(self):\n        \"\"\"Returns dictionary of computed performance metrics and statistics.\"\"\"\n        return self.box.curves_results + self.seg.curves_results\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.SegmentMetrics.ap_class_index","title":"<code>ap_class_index</code>  <code>property</code>","text":"<p>Boxes and masks have the same ap_class_index.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.SegmentMetrics.curves","title":"<code>curves</code>  <code>property</code>","text":"<p>Returns a list of curves for accessing specific metrics curves.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.SegmentMetrics.curves_results","title":"<code>curves_results</code>  <code>property</code>","text":"<p>Returns dictionary of computed performance metrics and statistics.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.SegmentMetrics.fitness","title":"<code>fitness</code>  <code>property</code>","text":"<p>Get the fitness score for both segmentation and bounding box models.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.SegmentMetrics.keys","title":"<code>keys</code>  <code>property</code>","text":"<p>Returns a list of keys for accessing metrics.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.SegmentMetrics.maps","title":"<code>maps</code>  <code>property</code>","text":"<p>Returns mAP scores for object detection and semantic segmentation models.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.SegmentMetrics.results_dict","title":"<code>results_dict</code>  <code>property</code>","text":"<p>Returns results of object detection model for evaluation.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.SegmentMetrics.__init__","title":"<code>__init__(save_dir=Path('.'), plot=False, on_plot=None, names=())</code>","text":"<p>Initialize a SegmentMetrics instance with a save directory, plot flag, callback function, and class names.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def __init__(self, save_dir=Path(\".\"), plot=False, on_plot=None, names=()) -&gt; None:\n    \"\"\"Initialize a SegmentMetrics instance with a save directory, plot flag, callback function, and class names.\"\"\"\n    self.save_dir = save_dir\n    self.plot = plot\n    self.on_plot = on_plot\n    self.names = names\n    self.box = Metric()\n    self.seg = Metric()\n    self.speed = {\"preprocess\": 0.0, \"inference\": 0.0, \"loss\": 0.0, \"postprocess\": 0.0}\n    self.task = \"segment\"\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.SegmentMetrics.class_result","title":"<code>class_result(i)</code>","text":"<p>Returns classification results for a specified class index.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def class_result(self, i):\n    \"\"\"Returns classification results for a specified class index.\"\"\"\n    return self.box.class_result(i) + self.seg.class_result(i)\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.SegmentMetrics.mean_results","title":"<code>mean_results()</code>","text":"<p>Return the mean metrics for bounding box and segmentation results.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def mean_results(self):\n    \"\"\"Return the mean metrics for bounding box and segmentation results.\"\"\"\n    return self.box.mean_results() + self.seg.mean_results()\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.SegmentMetrics.process","title":"<code>process(tp, tp_m, conf, pred_cls, target_cls)</code>","text":"<p>Processes the detection and segmentation metrics over the given set of predictions.</p> <p>Parameters:</p> Name Type Description Default <code>tp</code> <code>list</code> <p>List of True Positive boxes.</p> required <code>tp_m</code> <code>list</code> <p>List of True Positive masks.</p> required <code>conf</code> <code>list</code> <p>List of confidence scores.</p> required <code>pred_cls</code> <code>list</code> <p>List of predicted classes.</p> required <code>target_cls</code> <code>list</code> <p>List of target classes.</p> required Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def process(self, tp, tp_m, conf, pred_cls, target_cls):\n    \"\"\"\n    Processes the detection and segmentation metrics over the given set of predictions.\n\n    Args:\n        tp (list): List of True Positive boxes.\n        tp_m (list): List of True Positive masks.\n        conf (list): List of confidence scores.\n        pred_cls (list): List of predicted classes.\n        target_cls (list): List of target classes.\n    \"\"\"\n\n    results_mask = ap_per_class(\n        tp_m,\n        conf,\n        pred_cls,\n        target_cls,\n        plot=self.plot,\n        on_plot=self.on_plot,\n        save_dir=self.save_dir,\n        names=self.names,\n        prefix=\"Mask\",\n    )[2:]\n    self.seg.nc = len(self.names)\n    self.seg.update(results_mask)\n    results_box = ap_per_class(\n        tp,\n        conf,\n        pred_cls,\n        target_cls,\n        plot=self.plot,\n        on_plot=self.on_plot,\n        save_dir=self.save_dir,\n        names=self.names,\n        prefix=\"Box\",\n    )[2:]\n    self.box.nc = len(self.names)\n    self.box.update(results_box)\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.PoseMetrics","title":"<code>ultralytics.utils.metrics.PoseMetrics</code>","text":"<p>             Bases: <code>SegmentMetrics</code></p> <p>Calculates and aggregates detection and pose metrics over a given set of classes.</p> <p>Parameters:</p> Name Type Description Default <code>save_dir</code> <code>Path</code> <p>Path to the directory where the output plots should be saved. Default is the current directory.</p> <code>Path('.')</code> <code>plot</code> <code>bool</code> <p>Whether to save the detection and segmentation plots. Default is False.</p> <code>False</code> <code>on_plot</code> <code>func</code> <p>An optional callback to pass plots path and data when they are rendered. Defaults to None.</p> <code>None</code> <code>names</code> <code>list</code> <p>List of class names. Default is an empty list.</p> <code>()</code> <p>Attributes:</p> Name Type Description <code>save_dir</code> <code>Path</code> <p>Path to the directory where the output plots should be saved.</p> <code>plot</code> <code>bool</code> <p>Whether to save the detection and segmentation plots.</p> <code>on_plot</code> <code>func</code> <p>An optional callback to pass plots path and data when they are rendered.</p> <code>names</code> <code>list</code> <p>List of class names.</p> <code>box</code> <code>Metric</code> <p>An instance of the Metric class to calculate box detection metrics.</p> <code>pose</code> <code>Metric</code> <p>An instance of the Metric class to calculate mask segmentation metrics.</p> <code>speed</code> <code>dict</code> <p>Dictionary to store the time taken in different phases of inference.</p> <p>Methods:</p> Name Description <code>process</code> <p>Processes metrics over the given set of predictions.</p> <code>mean_results</code> <p>Returns the mean of the detection and segmentation metrics over all the classes.</p> <code>class_result</code> <p>Returns the detection and segmentation metrics of class <code>i</code>.</p> <code>maps</code> <p>Returns the mean Average Precision (mAP) scores for IoU thresholds ranging from 0.50 to 0.95.</p> <code>fitness</code> <p>Returns the fitness scores, which are a single weighted combination of metrics.</p> <code>ap_class_index</code> <p>Returns the list of indices of classes used to compute Average Precision (AP).</p> <code>results_dict</code> <p>Returns the dictionary containing all the detection and segmentation metrics and fitness score.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>class PoseMetrics(SegmentMetrics):\n    \"\"\"\n    Calculates and aggregates detection and pose metrics over a given set of classes.\n\n    Args:\n        save_dir (Path): Path to the directory where the output plots should be saved. Default is the current directory.\n        plot (bool): Whether to save the detection and segmentation plots. Default is False.\n        on_plot (func): An optional callback to pass plots path and data when they are rendered. Defaults to None.\n        names (list): List of class names. Default is an empty list.\n\n    Attributes:\n        save_dir (Path): Path to the directory where the output plots should be saved.\n        plot (bool): Whether to save the detection and segmentation plots.\n        on_plot (func): An optional callback to pass plots path and data when they are rendered.\n        names (list): List of class names.\n        box (Metric): An instance of the Metric class to calculate box detection metrics.\n        pose (Metric): An instance of the Metric class to calculate mask segmentation metrics.\n        speed (dict): Dictionary to store the time taken in different phases of inference.\n\n    Methods:\n        process(tp_m, tp_b, conf, pred_cls, target_cls): Processes metrics over the given set of predictions.\n        mean_results(): Returns the mean of the detection and segmentation metrics over all the classes.\n        class_result(i): Returns the detection and segmentation metrics of class `i`.\n        maps: Returns the mean Average Precision (mAP) scores for IoU thresholds ranging from 0.50 to 0.95.\n        fitness: Returns the fitness scores, which are a single weighted combination of metrics.\n        ap_class_index: Returns the list of indices of classes used to compute Average Precision (AP).\n        results_dict: Returns the dictionary containing all the detection and segmentation metrics and fitness score.\n    \"\"\"\n\n    def __init__(self, save_dir=Path(\".\"), plot=False, on_plot=None, names=()) -&gt; None:\n        \"\"\"Initialize the PoseMetrics class with directory path, class names, and plotting options.\"\"\"\n        super().__init__(save_dir, plot, names)\n        self.save_dir = save_dir\n        self.plot = plot\n        self.on_plot = on_plot\n        self.names = names\n        self.box = Metric()\n        self.pose = Metric()\n        self.speed = {\"preprocess\": 0.0, \"inference\": 0.0, \"loss\": 0.0, \"postprocess\": 0.0}\n        self.task = \"pose\"\n\n    def process(self, tp, tp_p, conf, pred_cls, target_cls):\n        \"\"\"\n        Processes the detection and pose metrics over the given set of predictions.\n\n        Args:\n            tp (list): List of True Positive boxes.\n            tp_p (list): List of True Positive keypoints.\n            conf (list): List of confidence scores.\n            pred_cls (list): List of predicted classes.\n            target_cls (list): List of target classes.\n        \"\"\"\n\n        results_pose = ap_per_class(\n            tp_p,\n            conf,\n            pred_cls,\n            target_cls,\n            plot=self.plot,\n            on_plot=self.on_plot,\n            save_dir=self.save_dir,\n            names=self.names,\n            prefix=\"Pose\",\n        )[2:]\n        self.pose.nc = len(self.names)\n        self.pose.update(results_pose)\n        results_box = ap_per_class(\n            tp,\n            conf,\n            pred_cls,\n            target_cls,\n            plot=self.plot,\n            on_plot=self.on_plot,\n            save_dir=self.save_dir,\n            names=self.names,\n            prefix=\"Box\",\n        )[2:]\n        self.box.nc = len(self.names)\n        self.box.update(results_box)\n\n    @property\n    def keys(self):\n        \"\"\"Returns list of evaluation metric keys.\"\"\"\n        return [\n            \"metrics/precision(B)\",\n            \"metrics/recall(B)\",\n            \"metrics/mAP50(B)\",\n            \"metrics/mAP50-95(B)\",\n            \"metrics/precision(P)\",\n            \"metrics/recall(P)\",\n            \"metrics/mAP50(P)\",\n            \"metrics/mAP50-95(P)\",\n        ]\n\n    def mean_results(self):\n        \"\"\"Return the mean results of box and pose.\"\"\"\n        return self.box.mean_results() + self.pose.mean_results()\n\n    def class_result(self, i):\n        \"\"\"Return the class-wise detection results for a specific class i.\"\"\"\n        return self.box.class_result(i) + self.pose.class_result(i)\n\n    @property\n    def maps(self):\n        \"\"\"Returns the mean average precision (mAP) per class for both box and pose detections.\"\"\"\n        return self.box.maps + self.pose.maps\n\n    @property\n    def fitness(self):\n        \"\"\"Computes classification metrics and speed using the `targets` and `pred` inputs.\"\"\"\n        return self.pose.fitness() + self.box.fitness()\n\n    @property\n    def curves(self):\n        \"\"\"Returns a list of curves for accessing specific metrics curves.\"\"\"\n        return [\n            \"Precision-Recall(B)\",\n            \"F1-Confidence(B)\",\n            \"Precision-Confidence(B)\",\n            \"Recall-Confidence(B)\",\n            \"Precision-Recall(P)\",\n            \"F1-Confidence(P)\",\n            \"Precision-Confidence(P)\",\n            \"Recall-Confidence(P)\",\n        ]\n\n    @property\n    def curves_results(self):\n        \"\"\"Returns dictionary of computed performance metrics and statistics.\"\"\"\n        return self.box.curves_results + self.pose.curves_results\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.PoseMetrics.curves","title":"<code>curves</code>  <code>property</code>","text":"<p>Returns a list of curves for accessing specific metrics curves.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.PoseMetrics.curves_results","title":"<code>curves_results</code>  <code>property</code>","text":"<p>Returns dictionary of computed performance metrics and statistics.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.PoseMetrics.fitness","title":"<code>fitness</code>  <code>property</code>","text":"<p>Computes classification metrics and speed using the <code>targets</code> and <code>pred</code> inputs.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.PoseMetrics.keys","title":"<code>keys</code>  <code>property</code>","text":"<p>Returns list of evaluation metric keys.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.PoseMetrics.maps","title":"<code>maps</code>  <code>property</code>","text":"<p>Returns the mean average precision (mAP) per class for both box and pose detections.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.PoseMetrics.__init__","title":"<code>__init__(save_dir=Path('.'), plot=False, on_plot=None, names=())</code>","text":"<p>Initialize the PoseMetrics class with directory path, class names, and plotting options.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def __init__(self, save_dir=Path(\".\"), plot=False, on_plot=None, names=()) -&gt; None:\n    \"\"\"Initialize the PoseMetrics class with directory path, class names, and plotting options.\"\"\"\n    super().__init__(save_dir, plot, names)\n    self.save_dir = save_dir\n    self.plot = plot\n    self.on_plot = on_plot\n    self.names = names\n    self.box = Metric()\n    self.pose = Metric()\n    self.speed = {\"preprocess\": 0.0, \"inference\": 0.0, \"loss\": 0.0, \"postprocess\": 0.0}\n    self.task = \"pose\"\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.PoseMetrics.class_result","title":"<code>class_result(i)</code>","text":"<p>Return the class-wise detection results for a specific class i.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def class_result(self, i):\n    \"\"\"Return the class-wise detection results for a specific class i.\"\"\"\n    return self.box.class_result(i) + self.pose.class_result(i)\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.PoseMetrics.mean_results","title":"<code>mean_results()</code>","text":"<p>Return the mean results of box and pose.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def mean_results(self):\n    \"\"\"Return the mean results of box and pose.\"\"\"\n    return self.box.mean_results() + self.pose.mean_results()\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.PoseMetrics.process","title":"<code>process(tp, tp_p, conf, pred_cls, target_cls)</code>","text":"<p>Processes the detection and pose metrics over the given set of predictions.</p> <p>Parameters:</p> Name Type Description Default <code>tp</code> <code>list</code> <p>List of True Positive boxes.</p> required <code>tp_p</code> <code>list</code> <p>List of True Positive keypoints.</p> required <code>conf</code> <code>list</code> <p>List of confidence scores.</p> required <code>pred_cls</code> <code>list</code> <p>List of predicted classes.</p> required <code>target_cls</code> <code>list</code> <p>List of target classes.</p> required Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def process(self, tp, tp_p, conf, pred_cls, target_cls):\n    \"\"\"\n    Processes the detection and pose metrics over the given set of predictions.\n\n    Args:\n        tp (list): List of True Positive boxes.\n        tp_p (list): List of True Positive keypoints.\n        conf (list): List of confidence scores.\n        pred_cls (list): List of predicted classes.\n        target_cls (list): List of target classes.\n    \"\"\"\n\n    results_pose = ap_per_class(\n        tp_p,\n        conf,\n        pred_cls,\n        target_cls,\n        plot=self.plot,\n        on_plot=self.on_plot,\n        save_dir=self.save_dir,\n        names=self.names,\n        prefix=\"Pose\",\n    )[2:]\n    self.pose.nc = len(self.names)\n    self.pose.update(results_pose)\n    results_box = ap_per_class(\n        tp,\n        conf,\n        pred_cls,\n        target_cls,\n        plot=self.plot,\n        on_plot=self.on_plot,\n        save_dir=self.save_dir,\n        names=self.names,\n        prefix=\"Box\",\n    )[2:]\n    self.box.nc = len(self.names)\n    self.box.update(results_box)\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.ClassifyMetrics","title":"<code>ultralytics.utils.metrics.ClassifyMetrics</code>","text":"<p>             Bases: <code>SimpleClass</code></p> <p>Class for computing classification metrics including top-1 and top-5 accuracy.</p> <p>Attributes:</p> Name Type Description <code>top1</code> <code>float</code> <p>The top-1 accuracy.</p> <code>top5</code> <code>float</code> <p>The top-5 accuracy.</p> <code>speed</code> <code>Dict[str, float]</code> <p>A dictionary containing the time taken for each step in the pipeline.</p> Properties <p>fitness (float): The fitness of the model, which is equal to top-5 accuracy. results_dict (Dict[str, Union[float, str]]): A dictionary containing the classification metrics and fitness. keys (List[str]): A list of keys for the results_dict.</p> <p>Methods:</p> Name Description <code>process</code> <p>Processes the targets and predictions to compute classification metrics.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>class ClassifyMetrics(SimpleClass):\n    \"\"\"\n    Class for computing classification metrics including top-1 and top-5 accuracy.\n\n    Attributes:\n        top1 (float): The top-1 accuracy.\n        top5 (float): The top-5 accuracy.\n        speed (Dict[str, float]): A dictionary containing the time taken for each step in the pipeline.\n\n    Properties:\n        fitness (float): The fitness of the model, which is equal to top-5 accuracy.\n        results_dict (Dict[str, Union[float, str]]): A dictionary containing the classification metrics and fitness.\n        keys (List[str]): A list of keys for the results_dict.\n\n    Methods:\n        process(targets, pred): Processes the targets and predictions to compute classification metrics.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize a ClassifyMetrics instance.\"\"\"\n        self.top1 = 0\n        self.top5 = 0\n        self.speed = {\"preprocess\": 0.0, \"inference\": 0.0, \"loss\": 0.0, \"postprocess\": 0.0}\n        self.task = \"classify\"\n\n    def process(self, targets, pred):\n        \"\"\"Target classes and predicted classes.\"\"\"\n        pred, targets = torch.cat(pred), torch.cat(targets)\n        correct = (targets[:, None] == pred).float()\n        acc = torch.stack((correct[:, 0], correct.max(1).values), dim=1)  # (top1, top5) accuracy\n        self.top1, self.top5 = acc.mean(0).tolist()\n\n    @property\n    def fitness(self):\n        \"\"\"Returns mean of top-1 and top-5 accuracies as fitness score.\"\"\"\n        return (self.top1 + self.top5) / 2\n\n    @property\n    def results_dict(self):\n        \"\"\"Returns a dictionary with model's performance metrics and fitness score.\"\"\"\n        return dict(zip(self.keys + [\"fitness\"], [self.top1, self.top5, self.fitness]))\n\n    @property\n    def keys(self):\n        \"\"\"Returns a list of keys for the results_dict property.\"\"\"\n        return [\"metrics/accuracy_top1\", \"metrics/accuracy_top5\"]\n\n    @property\n    def curves(self):\n        \"\"\"Returns a list of curves for accessing specific metrics curves.\"\"\"\n        return []\n\n    @property\n    def curves_results(self):\n        \"\"\"Returns a list of curves for accessing specific metrics curves.\"\"\"\n        return []\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.ClassifyMetrics.curves","title":"<code>curves</code>  <code>property</code>","text":"<p>Returns a list of curves for accessing specific metrics curves.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.ClassifyMetrics.curves_results","title":"<code>curves_results</code>  <code>property</code>","text":"<p>Returns a list of curves for accessing specific metrics curves.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.ClassifyMetrics.fitness","title":"<code>fitness</code>  <code>property</code>","text":"<p>Returns mean of top-1 and top-5 accuracies as fitness score.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.ClassifyMetrics.keys","title":"<code>keys</code>  <code>property</code>","text":"<p>Returns a list of keys for the results_dict property.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.ClassifyMetrics.results_dict","title":"<code>results_dict</code>  <code>property</code>","text":"<p>Returns a dictionary with model's performance metrics and fitness score.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.ClassifyMetrics.__init__","title":"<code>__init__()</code>","text":"<p>Initialize a ClassifyMetrics instance.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize a ClassifyMetrics instance.\"\"\"\n    self.top1 = 0\n    self.top5 = 0\n    self.speed = {\"preprocess\": 0.0, \"inference\": 0.0, \"loss\": 0.0, \"postprocess\": 0.0}\n    self.task = \"classify\"\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.ClassifyMetrics.process","title":"<code>process(targets, pred)</code>","text":"<p>Target classes and predicted classes.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def process(self, targets, pred):\n    \"\"\"Target classes and predicted classes.\"\"\"\n    pred, targets = torch.cat(pred), torch.cat(targets)\n    correct = (targets[:, None] == pred).float()\n    acc = torch.stack((correct[:, 0], correct.max(1).values), dim=1)  # (top1, top5) accuracy\n    self.top1, self.top5 = acc.mean(0).tolist()\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.OBBMetrics","title":"<code>ultralytics.utils.metrics.OBBMetrics</code>","text":"<p>             Bases: <code>SimpleClass</code></p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>class OBBMetrics(SimpleClass):\n    def __init__(self, save_dir=Path(\".\"), plot=False, on_plot=None, names=()) -&gt; None:\n        self.save_dir = save_dir\n        self.plot = plot\n        self.on_plot = on_plot\n        self.names = names\n        self.box = Metric()\n        self.speed = {\"preprocess\": 0.0, \"inference\": 0.0, \"loss\": 0.0, \"postprocess\": 0.0}\n\n    def process(self, tp, conf, pred_cls, target_cls):\n        \"\"\"Process predicted results for object detection and update metrics.\"\"\"\n        results = ap_per_class(\n            tp,\n            conf,\n            pred_cls,\n            target_cls,\n            plot=self.plot,\n            save_dir=self.save_dir,\n            names=self.names,\n            on_plot=self.on_plot,\n        )[2:]\n        self.box.nc = len(self.names)\n        self.box.update(results)\n\n    @property\n    def keys(self):\n        \"\"\"Returns a list of keys for accessing specific metrics.\"\"\"\n        return [\"metrics/precision(B)\", \"metrics/recall(B)\", \"metrics/mAP50(B)\", \"metrics/mAP50-95(B)\"]\n\n    def mean_results(self):\n        \"\"\"Calculate mean of detected objects &amp; return precision, recall, mAP50, and mAP50-95.\"\"\"\n        return self.box.mean_results()\n\n    def class_result(self, i):\n        \"\"\"Return the result of evaluating the performance of an object detection model on a specific class.\"\"\"\n        return self.box.class_result(i)\n\n    @property\n    def maps(self):\n        \"\"\"Returns mean Average Precision (mAP) scores per class.\"\"\"\n        return self.box.maps\n\n    @property\n    def fitness(self):\n        \"\"\"Returns the fitness of box object.\"\"\"\n        return self.box.fitness()\n\n    @property\n    def ap_class_index(self):\n        \"\"\"Returns the average precision index per class.\"\"\"\n        return self.box.ap_class_index\n\n    @property\n    def results_dict(self):\n        \"\"\"Returns dictionary of computed performance metrics and statistics.\"\"\"\n        return dict(zip(self.keys + [\"fitness\"], self.mean_results() + [self.fitness]))\n\n    @property\n    def curves(self):\n        \"\"\"Returns a list of curves for accessing specific metrics curves.\"\"\"\n        return []\n\n    @property\n    def curves_results(self):\n        \"\"\"Returns a list of curves for accessing specific metrics curves.\"\"\"\n        return []\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.OBBMetrics.ap_class_index","title":"<code>ap_class_index</code>  <code>property</code>","text":"<p>Returns the average precision index per class.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.OBBMetrics.curves","title":"<code>curves</code>  <code>property</code>","text":"<p>Returns a list of curves for accessing specific metrics curves.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.OBBMetrics.curves_results","title":"<code>curves_results</code>  <code>property</code>","text":"<p>Returns a list of curves for accessing specific metrics curves.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.OBBMetrics.fitness","title":"<code>fitness</code>  <code>property</code>","text":"<p>Returns the fitness of box object.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.OBBMetrics.keys","title":"<code>keys</code>  <code>property</code>","text":"<p>Returns a list of keys for accessing specific metrics.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.OBBMetrics.maps","title":"<code>maps</code>  <code>property</code>","text":"<p>Returns mean Average Precision (mAP) scores per class.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.OBBMetrics.results_dict","title":"<code>results_dict</code>  <code>property</code>","text":"<p>Returns dictionary of computed performance metrics and statistics.</p>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.OBBMetrics.class_result","title":"<code>class_result(i)</code>","text":"<p>Return the result of evaluating the performance of an object detection model on a specific class.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def class_result(self, i):\n    \"\"\"Return the result of evaluating the performance of an object detection model on a specific class.\"\"\"\n    return self.box.class_result(i)\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.OBBMetrics.mean_results","title":"<code>mean_results()</code>","text":"<p>Calculate mean of detected objects &amp; return precision, recall, mAP50, and mAP50-95.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def mean_results(self):\n    \"\"\"Calculate mean of detected objects &amp; return precision, recall, mAP50, and mAP50-95.\"\"\"\n    return self.box.mean_results()\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.OBBMetrics.process","title":"<code>process(tp, conf, pred_cls, target_cls)</code>","text":"<p>Process predicted results for object detection and update metrics.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def process(self, tp, conf, pred_cls, target_cls):\n    \"\"\"Process predicted results for object detection and update metrics.\"\"\"\n    results = ap_per_class(\n        tp,\n        conf,\n        pred_cls,\n        target_cls,\n        plot=self.plot,\n        save_dir=self.save_dir,\n        names=self.names,\n        on_plot=self.on_plot,\n    )[2:]\n    self.box.nc = len(self.names)\n    self.box.update(results)\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.bbox_ioa","title":"<code>ultralytics.utils.metrics.bbox_ioa(box1, box2, iou=False, eps=1e-07)</code>","text":"<p>Calculate the intersection over box2 area given box1 and box2. Boxes are in x1y1x2y2 format.</p> <p>Parameters:</p> Name Type Description Default <code>box1</code> <code>array</code> <p>A numpy array of shape (n, 4) representing n bounding boxes.</p> required <code>box2</code> <code>array</code> <p>A numpy array of shape (m, 4) representing m bounding boxes.</p> required <code>iou</code> <code>bool</code> <p>Calculate the standard iou if True else return inter_area/box2_area.</p> <code>False</code> <code>eps</code> <code>float</code> <p>A small value to avoid division by zero. Defaults to 1e-7.</p> <code>1e-07</code> <p>Returns:</p> Type Description <code>array</code> <p>A numpy array of shape (n, m) representing the intersection over box2 area.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def bbox_ioa(box1, box2, iou=False, eps=1e-7):\n    \"\"\"\n    Calculate the intersection over box2 area given box1 and box2. Boxes are in x1y1x2y2 format.\n\n    Args:\n        box1 (np.array): A numpy array of shape (n, 4) representing n bounding boxes.\n        box2 (np.array): A numpy array of shape (m, 4) representing m bounding boxes.\n        iou (bool): Calculate the standard iou if True else return inter_area/box2_area.\n        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.\n\n    Returns:\n        (np.array): A numpy array of shape (n, m) representing the intersection over box2 area.\n    \"\"\"\n\n    # Get the coordinates of bounding boxes\n    b1_x1, b1_y1, b1_x2, b1_y2 = box1.T\n    b2_x1, b2_y1, b2_x2, b2_y2 = box2.T\n\n    # Intersection area\n    inter_area = (np.minimum(b1_x2[:, None], b2_x2) - np.maximum(b1_x1[:, None], b2_x1)).clip(0) * (\n        np.minimum(b1_y2[:, None], b2_y2) - np.maximum(b1_y1[:, None], b2_y1)\n    ).clip(0)\n\n    # Box2 area\n    area = (b2_x2 - b2_x1) * (b2_y2 - b2_y1)\n    if iou:\n        box1_area = (b1_x2 - b1_x1) * (b1_y2 - b1_y1)\n        area = area + box1_area[:, None] - inter_area\n\n    # Intersection over box2 area\n    return inter_area / (area + eps)\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.box_iou","title":"<code>ultralytics.utils.metrics.box_iou(box1, box2, eps=1e-07)</code>","text":"<p>Calculate intersection-over-union (IoU) of boxes. Both sets of boxes are expected to be in (x1, y1, x2, y2) format. Based on https://github.com/pytorch/vision/blob/master/torchvision/ops/boxes.py</p> <p>Parameters:</p> Name Type Description Default <code>box1</code> <code>Tensor</code> <p>A tensor of shape (N, 4) representing N bounding boxes.</p> required <code>box2</code> <code>Tensor</code> <p>A tensor of shape (M, 4) representing M bounding boxes.</p> required <code>eps</code> <code>float</code> <p>A small value to avoid division by zero. Defaults to 1e-7.</p> <code>1e-07</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>An NxM tensor containing the pairwise IoU values for every element in box1 and box2.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def box_iou(box1, box2, eps=1e-7):\n    \"\"\"\n    Calculate intersection-over-union (IoU) of boxes. Both sets of boxes are expected to be in (x1, y1, x2, y2) format.\n    Based on https://github.com/pytorch/vision/blob/master/torchvision/ops/boxes.py\n\n    Args:\n        box1 (torch.Tensor): A tensor of shape (N, 4) representing N bounding boxes.\n        box2 (torch.Tensor): A tensor of shape (M, 4) representing M bounding boxes.\n        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.\n\n    Returns:\n        (torch.Tensor): An NxM tensor containing the pairwise IoU values for every element in box1 and box2.\n    \"\"\"\n\n    # inter(N,M) = (rb(N,M,2) - lt(N,M,2)).clamp(0).prod(2)\n    (a1, a2), (b1, b2) = box1.unsqueeze(1).chunk(2, 2), box2.unsqueeze(0).chunk(2, 2)\n    inter = (torch.min(a2, b2) - torch.max(a1, b1)).clamp_(0).prod(2)\n\n    # IoU = inter / (area1 + area2 - inter)\n    return inter / ((a2 - a1).prod(2) + (b2 - b1).prod(2) - inter + eps)\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.bbox_iou","title":"<code>ultralytics.utils.metrics.bbox_iou(box1, box2, xywh=True, GIoU=False, DIoU=False, CIoU=False, eps=1e-07)</code>","text":"<p>Calculate Intersection over Union (IoU) of box1(1, 4) to box2(n, 4).</p> <p>Parameters:</p> Name Type Description Default <code>box1</code> <code>Tensor</code> <p>A tensor representing a single bounding box with shape (1, 4).</p> required <code>box2</code> <code>Tensor</code> <p>A tensor representing n bounding boxes with shape (n, 4).</p> required <code>xywh</code> <code>bool</code> <p>If True, input boxes are in (x, y, w, h) format. If False, input boxes are in                    (x1, y1, x2, y2) format. Defaults to True.</p> <code>True</code> <code>GIoU</code> <code>bool</code> <p>If True, calculate Generalized IoU. Defaults to False.</p> <code>False</code> <code>DIoU</code> <code>bool</code> <p>If True, calculate Distance IoU. Defaults to False.</p> <code>False</code> <code>CIoU</code> <code>bool</code> <p>If True, calculate Complete IoU. Defaults to False.</p> <code>False</code> <code>eps</code> <code>float</code> <p>A small value to avoid division by zero. Defaults to 1e-7.</p> <code>1e-07</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>IoU, GIoU, DIoU, or CIoU values depending on the specified flags.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def bbox_iou(box1, box2, xywh=True, GIoU=False, DIoU=False, CIoU=False, eps=1e-7):\n    \"\"\"\n    Calculate Intersection over Union (IoU) of box1(1, 4) to box2(n, 4).\n\n    Args:\n        box1 (torch.Tensor): A tensor representing a single bounding box with shape (1, 4).\n        box2 (torch.Tensor): A tensor representing n bounding boxes with shape (n, 4).\n        xywh (bool, optional): If True, input boxes are in (x, y, w, h) format. If False, input boxes are in\n                               (x1, y1, x2, y2) format. Defaults to True.\n        GIoU (bool, optional): If True, calculate Generalized IoU. Defaults to False.\n        DIoU (bool, optional): If True, calculate Distance IoU. Defaults to False.\n        CIoU (bool, optional): If True, calculate Complete IoU. Defaults to False.\n        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.\n\n    Returns:\n        (torch.Tensor): IoU, GIoU, DIoU, or CIoU values depending on the specified flags.\n    \"\"\"\n\n    # Get the coordinates of bounding boxes\n    if xywh:  # transform from xywh to xyxy\n        (x1, y1, w1, h1), (x2, y2, w2, h2) = box1.chunk(4, -1), box2.chunk(4, -1)\n        w1_, h1_, w2_, h2_ = w1 / 2, h1 / 2, w2 / 2, h2 / 2\n        b1_x1, b1_x2, b1_y1, b1_y2 = x1 - w1_, x1 + w1_, y1 - h1_, y1 + h1_\n        b2_x1, b2_x2, b2_y1, b2_y2 = x2 - w2_, x2 + w2_, y2 - h2_, y2 + h2_\n    else:  # x1, y1, x2, y2 = box1\n        b1_x1, b1_y1, b1_x2, b1_y2 = box1.chunk(4, -1)\n        b2_x1, b2_y1, b2_x2, b2_y2 = box2.chunk(4, -1)\n        w1, h1 = b1_x2 - b1_x1, b1_y2 - b1_y1 + eps\n        w2, h2 = b2_x2 - b2_x1, b2_y2 - b2_y1 + eps\n\n    # Intersection area\n    inter = (b1_x2.minimum(b2_x2) - b1_x1.maximum(b2_x1)).clamp_(0) * (\n        b1_y2.minimum(b2_y2) - b1_y1.maximum(b2_y1)\n    ).clamp_(0)\n\n    # Union Area\n    union = w1 * h1 + w2 * h2 - inter + eps\n\n    # IoU\n    iou = inter / union\n    if CIoU or DIoU or GIoU:\n        cw = b1_x2.maximum(b2_x2) - b1_x1.minimum(b2_x1)  # convex (smallest enclosing box) width\n        ch = b1_y2.maximum(b2_y2) - b1_y1.minimum(b2_y1)  # convex height\n        if CIoU or DIoU:  # Distance or Complete IoU https://arxiv.org/abs/1911.08287v1\n            c2 = cw**2 + ch**2 + eps  # convex diagonal squared\n            rho2 = ((b2_x1 + b2_x2 - b1_x1 - b1_x2) ** 2 + (b2_y1 + b2_y2 - b1_y1 - b1_y2) ** 2) / 4  # center dist ** 2\n            if CIoU:  # https://github.com/Zzh-tju/DIoU-SSD-pytorch/blob/master/utils/box/box_utils.py#L47\n                v = (4 / math.pi**2) * (torch.atan(w2 / h2) - torch.atan(w1 / h1)).pow(2)\n                with torch.no_grad():\n                    alpha = v / (v - iou + (1 + eps))\n                return iou - (rho2 / c2 + v * alpha)  # CIoU\n            return iou - rho2 / c2  # DIoU\n        c_area = cw * ch + eps  # convex area\n        return iou - (c_area - union) / c_area  # GIoU https://arxiv.org/pdf/1902.09630.pdf\n    return iou  # IoU\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.mask_iou","title":"<code>ultralytics.utils.metrics.mask_iou(mask1, mask2, eps=1e-07)</code>","text":"<p>Calculate masks IoU.</p> <p>Parameters:</p> Name Type Description Default <code>mask1</code> <code>Tensor</code> <p>A tensor of shape (N, n) where N is the number of ground truth objects and n is the             product of image width and height.</p> required <code>mask2</code> <code>Tensor</code> <p>A tensor of shape (M, n) where M is the number of predicted objects and n is the             product of image width and height.</p> required <code>eps</code> <code>float</code> <p>A small value to avoid division by zero. Defaults to 1e-7.</p> <code>1e-07</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>A tensor of shape (N, M) representing masks IoU.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def mask_iou(mask1, mask2, eps=1e-7):\n    \"\"\"\n    Calculate masks IoU.\n\n    Args:\n        mask1 (torch.Tensor): A tensor of shape (N, n) where N is the number of ground truth objects and n is the\n                        product of image width and height.\n        mask2 (torch.Tensor): A tensor of shape (M, n) where M is the number of predicted objects and n is the\n                        product of image width and height.\n        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.\n\n    Returns:\n        (torch.Tensor): A tensor of shape (N, M) representing masks IoU.\n    \"\"\"\n    intersection = torch.matmul(mask1, mask2.T).clamp_(0)\n    union = (mask1.sum(1)[:, None] + mask2.sum(1)[None]) - intersection  # (area1 + area2) - intersection\n    return intersection / (union + eps)\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.kpt_iou","title":"<code>ultralytics.utils.metrics.kpt_iou(kpt1, kpt2, area, sigma, eps=1e-07)</code>","text":"<p>Calculate Object Keypoint Similarity (OKS).</p> <p>Parameters:</p> Name Type Description Default <code>kpt1</code> <code>Tensor</code> <p>A tensor of shape (N, 17, 3) representing ground truth keypoints.</p> required <code>kpt2</code> <code>Tensor</code> <p>A tensor of shape (M, 17, 3) representing predicted keypoints.</p> required <code>area</code> <code>Tensor</code> <p>A tensor of shape (N,) representing areas from ground truth.</p> required <code>sigma</code> <code>list</code> <p>A list containing 17 values representing keypoint scales.</p> required <code>eps</code> <code>float</code> <p>A small value to avoid division by zero. Defaults to 1e-7.</p> <code>1e-07</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>A tensor of shape (N, M) representing keypoint similarities.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def kpt_iou(kpt1, kpt2, area, sigma, eps=1e-7):\n    \"\"\"\n    Calculate Object Keypoint Similarity (OKS).\n\n    Args:\n        kpt1 (torch.Tensor): A tensor of shape (N, 17, 3) representing ground truth keypoints.\n        kpt2 (torch.Tensor): A tensor of shape (M, 17, 3) representing predicted keypoints.\n        area (torch.Tensor): A tensor of shape (N,) representing areas from ground truth.\n        sigma (list): A list containing 17 values representing keypoint scales.\n        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.\n\n    Returns:\n        (torch.Tensor): A tensor of shape (N, M) representing keypoint similarities.\n    \"\"\"\n    d = (kpt1[:, None, :, 0] - kpt2[..., 0]) ** 2 + (kpt1[:, None, :, 1] - kpt2[..., 1]) ** 2  # (N, M, 17)\n    sigma = torch.tensor(sigma, device=kpt1.device, dtype=kpt1.dtype)  # (17, )\n    kpt_mask = kpt1[..., 2] != 0  # (N, 17)\n    e = d / (2 * sigma) ** 2 / (area[:, None, None] + eps) / 2  # from cocoeval\n    # e = d / ((area[None, :, None] + eps) * sigma) ** 2 / 2  # from formula\n    return (torch.exp(-e) * kpt_mask[:, None]).sum(-1) / (kpt_mask.sum(-1)[:, None] + eps)\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics._get_covariance_matrix","title":"<code>ultralytics.utils.metrics._get_covariance_matrix(boxes)</code>","text":"<p>Generating covariance matrix from obbs.</p> <p>Parameters:</p> Name Type Description Default <code>boxes</code> <code>Tensor</code> <p>A tensor of shape (N, 5) representing rotated bounding boxes, with xywhr format.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>Covariance metrixs corresponding to original rotated bounding boxes.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def _get_covariance_matrix(boxes):\n    \"\"\"\n    Generating covariance matrix from obbs.\n\n    Args:\n        boxes (torch.Tensor): A tensor of shape (N, 5) representing rotated bounding boxes, with xywhr format.\n\n    Returns:\n        (torch.Tensor): Covariance metrixs corresponding to original rotated bounding boxes.\n    \"\"\"\n    # Gaussian bounding boxes, ignored the center points(the first two columns) cause it's not needed here.\n    gbbs = torch.cat((torch.pow(boxes[:, 2:4], 2) / 12, boxes[:, 4:]), dim=-1)\n    a, b, c = gbbs.split(1, dim=-1)\n    return (\n        a * torch.cos(c) ** 2 + b * torch.sin(c) ** 2,\n        a * torch.sin(c) ** 2 + b * torch.cos(c) ** 2,\n        a * torch.cos(c) * torch.sin(c) - b * torch.sin(c) * torch.cos(c),\n    )\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.probiou","title":"<code>ultralytics.utils.metrics.probiou(obb1, obb2, CIoU=False, eps=1e-07)</code>","text":"<p>Calculate the prob iou between oriented bounding boxes, https://arxiv.org/pdf/2106.06072v1.pdf.</p> <p>Parameters:</p> Name Type Description Default <code>obb1</code> <code>Tensor</code> <p>A tensor of shape (N, 5) representing ground truth obbs, with xywhr format.</p> required <code>obb2</code> <code>Tensor</code> <p>A tensor of shape (N, 5) representing predicted obbs, with xywhr format.</p> required <code>eps</code> <code>float</code> <p>A small value to avoid division by zero. Defaults to 1e-7.</p> <code>1e-07</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>A tensor of shape (N, ) representing obb similarities.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def probiou(obb1, obb2, CIoU=False, eps=1e-7):\n    \"\"\"\n    Calculate the prob iou between oriented bounding boxes, https://arxiv.org/pdf/2106.06072v1.pdf.\n\n    Args:\n        obb1 (torch.Tensor): A tensor of shape (N, 5) representing ground truth obbs, with xywhr format.\n        obb2 (torch.Tensor): A tensor of shape (N, 5) representing predicted obbs, with xywhr format.\n        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.\n\n    Returns:\n        (torch.Tensor): A tensor of shape (N, ) representing obb similarities.\n    \"\"\"\n    x1, y1 = obb1[..., :2].split(1, dim=-1)\n    x2, y2 = obb2[..., :2].split(1, dim=-1)\n    a1, b1, c1 = _get_covariance_matrix(obb1)\n    a2, b2, c2 = _get_covariance_matrix(obb2)\n\n    t1 = (\n        ((a1 + a2) * (torch.pow(y1 - y2, 2)) + (b1 + b2) * (torch.pow(x1 - x2, 2)))\n        / ((a1 + a2) * (b1 + b2) - (torch.pow(c1 + c2, 2)) + eps)\n    ) * 0.25\n    t2 = (((c1 + c2) * (x2 - x1) * (y1 - y2)) / ((a1 + a2) * (b1 + b2) - (torch.pow(c1 + c2, 2)) + eps)) * 0.5\n    t3 = (\n        torch.log(\n            ((a1 + a2) * (b1 + b2) - (torch.pow(c1 + c2, 2)))\n            / (4 * torch.sqrt((a1 * b1 - torch.pow(c1, 2)).clamp_(0) * (a2 * b2 - torch.pow(c2, 2)).clamp_(0)) + eps)\n            + eps\n        )\n        * 0.5\n    )\n    bd = t1 + t2 + t3\n    bd = torch.clamp(bd, eps, 100.0)\n    hd = torch.sqrt(1.0 - torch.exp(-bd) + eps)\n    iou = 1 - hd\n    if CIoU:  # only include the wh aspect ratio part\n        w1, h1 = obb1[..., 2:4].split(1, dim=-1)\n        w2, h2 = obb2[..., 2:4].split(1, dim=-1)\n        v = (4 / math.pi**2) * (torch.atan(w2 / h2) - torch.atan(w1 / h1)).pow(2)\n        with torch.no_grad():\n            alpha = v / (v - iou + (1 + eps))\n        return iou - v * alpha  # CIoU\n    return iou\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.batch_probiou","title":"<code>ultralytics.utils.metrics.batch_probiou(obb1, obb2, eps=1e-07)</code>","text":"<p>Calculate the prob iou between oriented bounding boxes, https://arxiv.org/pdf/2106.06072v1.pdf.</p> <p>Parameters:</p> Name Type Description Default <code>obb1</code> <code>Tensor</code> <p>A tensor of shape (N, 5) representing ground truth obbs, with xywhr format.</p> required <code>obb2</code> <code>Tensor</code> <p>A tensor of shape (M, 5) representing predicted obbs, with xywhr format.</p> required <code>eps</code> <code>float</code> <p>A small value to avoid division by zero. Defaults to 1e-7.</p> <code>1e-07</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>A tensor of shape (N, M) representing obb similarities.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def batch_probiou(obb1, obb2, eps=1e-7):\n    \"\"\"\n    Calculate the prob iou between oriented bounding boxes, https://arxiv.org/pdf/2106.06072v1.pdf.\n\n    Args:\n        obb1 (torch.Tensor): A tensor of shape (N, 5) representing ground truth obbs, with xywhr format.\n        obb2 (torch.Tensor): A tensor of shape (M, 5) representing predicted obbs, with xywhr format.\n        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-7.\n\n    Returns:\n        (torch.Tensor): A tensor of shape (N, M) representing obb similarities.\n    \"\"\"\n    x1, y1 = obb1[..., :2].split(1, dim=-1)\n    x2, y2 = (x.squeeze(-1)[None] for x in obb2[..., :2].split(1, dim=-1))\n    a1, b1, c1 = _get_covariance_matrix(obb1)\n    a2, b2, c2 = (x.squeeze(-1)[None] for x in _get_covariance_matrix(obb2))\n\n    t1 = (\n        ((a1 + a2) * (torch.pow(y1 - y2, 2)) + (b1 + b2) * (torch.pow(x1 - x2, 2)))\n        / ((a1 + a2) * (b1 + b2) - (torch.pow(c1 + c2, 2)) + eps)\n    ) * 0.25\n    t2 = (((c1 + c2) * (x2 - x1) * (y1 - y2)) / ((a1 + a2) * (b1 + b2) - (torch.pow(c1 + c2, 2)) + eps)) * 0.5\n    t3 = (\n        torch.log(\n            ((a1 + a2) * (b1 + b2) - (torch.pow(c1 + c2, 2)))\n            / (4 * torch.sqrt((a1 * b1 - torch.pow(c1, 2)).clamp_(0) * (a2 * b2 - torch.pow(c2, 2)).clamp_(0)) + eps)\n            + eps\n        )\n        * 0.5\n    )\n    bd = t1 + t2 + t3\n    bd = torch.clamp(bd, eps, 100.0)\n    hd = torch.sqrt(1.0 - torch.exp(-bd) + eps)\n    return 1 - hd\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.smooth_BCE","title":"<code>ultralytics.utils.metrics.smooth_BCE(eps=0.1)</code>","text":"<p>Computes smoothed positive and negative Binary Cross-Entropy targets.</p> <p>This function calculates positive and negative label smoothing BCE targets based on a given epsilon value. For implementation details, refer to https://github.com/ultralytics/yolov3/issues/238#issuecomment-598028441.</p> <p>Parameters:</p> Name Type Description Default <code>eps</code> <code>float</code> <p>The epsilon value for label smoothing. Defaults to 0.1.</p> <code>0.1</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the positive and negative label smoothing BCE targets.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def smooth_BCE(eps=0.1):\n    \"\"\"\n    Computes smoothed positive and negative Binary Cross-Entropy targets.\n\n    This function calculates positive and negative label smoothing BCE targets based on a given epsilon value.\n    For implementation details, refer to https://github.com/ultralytics/yolov3/issues/238#issuecomment-598028441.\n\n    Args:\n        eps (float, optional): The epsilon value for label smoothing. Defaults to 0.1.\n\n    Returns:\n        (tuple): A tuple containing the positive and negative label smoothing BCE targets.\n    \"\"\"\n    return 1.0 - 0.5 * eps, 0.5 * eps\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.smooth","title":"<code>ultralytics.utils.metrics.smooth(y, f=0.05)</code>","text":"<p>Box filter of fraction f.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def smooth(y, f=0.05):\n    \"\"\"Box filter of fraction f.\"\"\"\n    nf = round(len(y) * f * 2) // 2 + 1  # number of filter elements (must be odd)\n    p = np.ones(nf // 2)  # ones padding\n    yp = np.concatenate((p * y[0], y, p * y[-1]), 0)  # y padded\n    return np.convolve(yp, np.ones(nf) / nf, mode=\"valid\")  # y-smoothed\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.plot_pr_curve","title":"<code>ultralytics.utils.metrics.plot_pr_curve(px, py, ap, save_dir=Path('pr_curve.png'), names=(), on_plot=None)</code>","text":"<p>Plots a precision-recall curve.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>@plt_settings()\ndef plot_pr_curve(px, py, ap, save_dir=Path(\"pr_curve.png\"), names=(), on_plot=None):\n    \"\"\"Plots a precision-recall curve.\"\"\"\n    fig, ax = plt.subplots(1, 1, figsize=(9, 6), tight_layout=True)\n    py = np.stack(py, axis=1)\n\n    if 0 &lt; len(names) &lt; 21:  # display per-class legend if &lt; 21 classes\n        for i, y in enumerate(py.T):\n            ax.plot(px, y, linewidth=1, label=f\"{names[i]} {ap[i, 0]:.3f}\")  # plot(recall, precision)\n    else:\n        ax.plot(px, py, linewidth=1, color=\"grey\")  # plot(recall, precision)\n\n    ax.plot(px, py.mean(1), linewidth=3, color=\"blue\", label=\"all classes %.3f mAP@0.5\" % ap[:, 0].mean())\n    ax.set_xlabel(\"Recall\")\n    ax.set_ylabel(\"Precision\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.legend(bbox_to_anchor=(1.04, 1), loc=\"upper left\")\n    ax.set_title(\"Precision-Recall Curve\")\n    fig.savefig(save_dir, dpi=250)\n    plt.close(fig)\n    if on_plot:\n        on_plot(save_dir)\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.plot_mc_curve","title":"<code>ultralytics.utils.metrics.plot_mc_curve(px, py, save_dir=Path('mc_curve.png'), names=(), xlabel='Confidence', ylabel='Metric', on_plot=None)</code>","text":"<p>Plots a metric-confidence curve.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>@plt_settings()\ndef plot_mc_curve(px, py, save_dir=Path(\"mc_curve.png\"), names=(), xlabel=\"Confidence\", ylabel=\"Metric\", on_plot=None):\n    \"\"\"Plots a metric-confidence curve.\"\"\"\n    fig, ax = plt.subplots(1, 1, figsize=(9, 6), tight_layout=True)\n\n    if 0 &lt; len(names) &lt; 21:  # display per-class legend if &lt; 21 classes\n        for i, y in enumerate(py):\n            ax.plot(px, y, linewidth=1, label=f\"{names[i]}\")  # plot(confidence, metric)\n    else:\n        ax.plot(px, py.T, linewidth=1, color=\"grey\")  # plot(confidence, metric)\n\n    y = smooth(py.mean(0), 0.05)\n    ax.plot(px, y, linewidth=3, color=\"blue\", label=f\"all classes {y.max():.2f} at {px[y.argmax()]:.3f}\")\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(ylabel)\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.legend(bbox_to_anchor=(1.04, 1), loc=\"upper left\")\n    ax.set_title(f\"{ylabel}-Confidence Curve\")\n    fig.savefig(save_dir, dpi=250)\n    plt.close(fig)\n    if on_plot:\n        on_plot(save_dir)\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.compute_ap","title":"<code>ultralytics.utils.metrics.compute_ap(recall, precision)</code>","text":"<p>Compute the average precision (AP) given the recall and precision curves.</p> <p>Parameters:</p> Name Type Description Default <code>recall</code> <code>list</code> <p>The recall curve.</p> required <code>precision</code> <code>list</code> <p>The precision curve.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Average precision.</p> <code>ndarray</code> <p>Precision envelope curve.</p> <code>ndarray</code> <p>Modified recall curve with sentinel values added at the beginning and end.</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def compute_ap(recall, precision):\n    \"\"\"\n    Compute the average precision (AP) given the recall and precision curves.\n\n    Args:\n        recall (list): The recall curve.\n        precision (list): The precision curve.\n\n    Returns:\n        (float): Average precision.\n        (np.ndarray): Precision envelope curve.\n        (np.ndarray): Modified recall curve with sentinel values added at the beginning and end.\n    \"\"\"\n\n    # Append sentinel values to beginning and end\n    mrec = np.concatenate(([0.0], recall, [1.0]))\n    mpre = np.concatenate(([1.0], precision, [0.0]))\n\n    # Compute the precision envelope\n    mpre = np.flip(np.maximum.accumulate(np.flip(mpre)))\n\n    # Integrate area under curve\n    method = \"interp\"  # methods: 'continuous', 'interp'\n    if method == \"interp\":\n        x = np.linspace(0, 1, 101)  # 101-point interp (COCO)\n        ap = np.trapz(np.interp(x, mrec, mpre), x)  # integrate\n    else:  # 'continuous'\n        i = np.where(mrec[1:] != mrec[:-1])[0]  # points where x-axis (recall) changes\n        ap = np.sum((mrec[i + 1] - mrec[i]) * mpre[i + 1])  # area under curve\n\n    return ap, mpre, mrec\n</code></pre>"},{"location":"reference/utils/metrics/#ultralytics.utils.metrics.ap_per_class","title":"<code>ultralytics.utils.metrics.ap_per_class(tp, conf, pred_cls, target_cls, plot=False, on_plot=None, save_dir=Path(), names=(), eps=1e-16, prefix='')</code>","text":"<p>Computes the average precision per class for object detection evaluation.</p> <p>Parameters:</p> Name Type Description Default <code>tp</code> <code>ndarray</code> <p>Binary array indicating whether the detection is correct (True) or not (False).</p> required <code>conf</code> <code>ndarray</code> <p>Array of confidence scores of the detections.</p> required <code>pred_cls</code> <code>ndarray</code> <p>Array of predicted classes of the detections.</p> required <code>target_cls</code> <code>ndarray</code> <p>Array of true classes of the detections.</p> required <code>plot</code> <code>bool</code> <p>Whether to plot PR curves or not. Defaults to False.</p> <code>False</code> <code>on_plot</code> <code>func</code> <p>A callback to pass plots path and data when they are rendered. Defaults to None.</p> <code>None</code> <code>save_dir</code> <code>Path</code> <p>Directory to save the PR curves. Defaults to an empty path.</p> <code>Path()</code> <code>names</code> <code>tuple</code> <p>Tuple of class names to plot PR curves. Defaults to an empty tuple.</p> <code>()</code> <code>eps</code> <code>float</code> <p>A small value to avoid division by zero. Defaults to 1e-16.</p> <code>1e-16</code> <code>prefix</code> <code>str</code> <p>A prefix string for saving the plot files. Defaults to an empty string.</p> <code>''</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of six arrays and one array of unique classes, where: tp (np.ndarray): True positive counts at threshold given by max F1 metric for each class.Shape: (nc,). fp (np.ndarray): False positive counts at threshold given by max F1 metric for each class. Shape: (nc,). p (np.ndarray): Precision values at threshold given by max F1 metric for each class. Shape: (nc,). r (np.ndarray): Recall values at threshold given by max F1 metric for each class. Shape: (nc,). f1 (np.ndarray): F1-score values at threshold given by max F1 metric for each class. Shape: (nc,). ap (np.ndarray): Average precision for each class at different IoU thresholds. Shape: (nc, 10). unique_classes (np.ndarray): An array of unique classes that have data. Shape: (nc,). p_curve (np.ndarray): Precision curves for each class. Shape: (nc, 1000). r_curve (np.ndarray): Recall curves for each class. Shape: (nc, 1000). f1_curve (np.ndarray): F1-score curves for each class. Shape: (nc, 1000). x (np.ndarray): X-axis values for the curves. Shape: (1000,). prec_values: Precision values at mAP@0.5 for each class. Shape: (nc, 1000).</p> Source code in <code>ultralytics/utils/metrics.py</code> <pre><code>def ap_per_class(\n    tp, conf, pred_cls, target_cls, plot=False, on_plot=None, save_dir=Path(), names=(), eps=1e-16, prefix=\"\"\n):\n    \"\"\"\n    Computes the average precision per class for object detection evaluation.\n\n    Args:\n        tp (np.ndarray): Binary array indicating whether the detection is correct (True) or not (False).\n        conf (np.ndarray): Array of confidence scores of the detections.\n        pred_cls (np.ndarray): Array of predicted classes of the detections.\n        target_cls (np.ndarray): Array of true classes of the detections.\n        plot (bool, optional): Whether to plot PR curves or not. Defaults to False.\n        on_plot (func, optional): A callback to pass plots path and data when they are rendered. Defaults to None.\n        save_dir (Path, optional): Directory to save the PR curves. Defaults to an empty path.\n        names (tuple, optional): Tuple of class names to plot PR curves. Defaults to an empty tuple.\n        eps (float, optional): A small value to avoid division by zero. Defaults to 1e-16.\n        prefix (str, optional): A prefix string for saving the plot files. Defaults to an empty string.\n\n    Returns:\n        (tuple): A tuple of six arrays and one array of unique classes, where:\n            tp (np.ndarray): True positive counts at threshold given by max F1 metric for each class.Shape: (nc,).\n            fp (np.ndarray): False positive counts at threshold given by max F1 metric for each class. Shape: (nc,).\n            p (np.ndarray): Precision values at threshold given by max F1 metric for each class. Shape: (nc,).\n            r (np.ndarray): Recall values at threshold given by max F1 metric for each class. Shape: (nc,).\n            f1 (np.ndarray): F1-score values at threshold given by max F1 metric for each class. Shape: (nc,).\n            ap (np.ndarray): Average precision for each class at different IoU thresholds. Shape: (nc, 10).\n            unique_classes (np.ndarray): An array of unique classes that have data. Shape: (nc,).\n            p_curve (np.ndarray): Precision curves for each class. Shape: (nc, 1000).\n            r_curve (np.ndarray): Recall curves for each class. Shape: (nc, 1000).\n            f1_curve (np.ndarray): F1-score curves for each class. Shape: (nc, 1000).\n            x (np.ndarray): X-axis values for the curves. Shape: (1000,).\n            prec_values: Precision values at mAP@0.5 for each class. Shape: (nc, 1000).\n    \"\"\"\n\n    # Sort by objectness\n    i = np.argsort(-conf)\n    tp, conf, pred_cls = tp[i], conf[i], pred_cls[i]\n\n    # Find unique classes\n    unique_classes, nt = np.unique(target_cls, return_counts=True)\n    nc = unique_classes.shape[0]  # number of classes, number of detections\n\n    # Create Precision-Recall curve and compute AP for each class\n    x, prec_values = np.linspace(0, 1, 1000), []\n\n    # Average precision, precision and recall curves\n    ap, p_curve, r_curve = np.zeros((nc, tp.shape[1])), np.zeros((nc, 1000)), np.zeros((nc, 1000))\n    for ci, c in enumerate(unique_classes):\n        i = pred_cls == c\n        n_l = nt[ci]  # number of labels\n        n_p = i.sum()  # number of predictions\n        if n_p == 0 or n_l == 0:\n            continue\n\n        # Accumulate FPs and TPs\n        fpc = (1 - tp[i]).cumsum(0)\n        tpc = tp[i].cumsum(0)\n\n        # Recall\n        recall = tpc / (n_l + eps)  # recall curve\n        r_curve[ci] = np.interp(-x, -conf[i], recall[:, 0], left=0)  # negative x, xp because xp decreases\n\n        # Precision\n        precision = tpc / (tpc + fpc)  # precision curve\n        p_curve[ci] = np.interp(-x, -conf[i], precision[:, 0], left=1)  # p at pr_score\n\n        # AP from recall-precision curve\n        for j in range(tp.shape[1]):\n            ap[ci, j], mpre, mrec = compute_ap(recall[:, j], precision[:, j])\n            if plot and j == 0:\n                prec_values.append(np.interp(x, mrec, mpre))  # precision at mAP@0.5\n\n    prec_values = np.array(prec_values)  # (nc, 1000)\n\n    # Compute F1 (harmonic mean of precision and recall)\n    f1_curve = 2 * p_curve * r_curve / (p_curve + r_curve + eps)\n    names = [v for k, v in names.items() if k in unique_classes]  # list: only classes that have data\n    names = dict(enumerate(names))  # to dict\n    if plot:\n        plot_pr_curve(x, prec_values, ap, save_dir / f\"{prefix}PR_curve.png\", names, on_plot=on_plot)\n        plot_mc_curve(x, f1_curve, save_dir / f\"{prefix}F1_curve.png\", names, ylabel=\"F1\", on_plot=on_plot)\n        plot_mc_curve(x, p_curve, save_dir / f\"{prefix}P_curve.png\", names, ylabel=\"Precision\", on_plot=on_plot)\n        plot_mc_curve(x, r_curve, save_dir / f\"{prefix}R_curve.png\", names, ylabel=\"Recall\", on_plot=on_plot)\n\n    i = smooth(f1_curve.mean(0), 0.1).argmax()  # max F1 index\n    p, r, f1 = p_curve[:, i], r_curve[:, i], f1_curve[:, i]  # max-F1 precision, recall, F1 values\n    tp = (r * nt).round()  # true positives\n    fp = (tp / (p + eps) - tp).round()  # false positives\n    return tp, fp, p, r, f1, ap, unique_classes.astype(int), p_curve, r_curve, f1_curve, x, prec_values\n</code></pre>"},{"location":"reference/utils/ops/","title":"Reference for <code>ultralytics/utils/ops.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/ops.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.Profile","title":"<code>ultralytics.utils.ops.Profile</code>","text":"<p>             Bases: <code>ContextDecorator</code></p> <p>YOLOv8 Profile class. Use as a decorator with @Profile() or as a context manager with 'with Profile():'.</p> Example <pre><code>from ultralytics.utils.ops import Profile\n\nwith Profile() as dt:\n    pass  # slow operation here\n\nprint(dt)  # prints \"Elapsed time is 9.5367431640625e-07 s\"\n</code></pre> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>class Profile(contextlib.ContextDecorator):\n    \"\"\"\n    YOLOv8 Profile class. Use as a decorator with @Profile() or as a context manager with 'with Profile():'.\n\n    Example:\n        ```python\n        from ultralytics.utils.ops import Profile\n\n        with Profile() as dt:\n            pass  # slow operation here\n\n        print(dt)  # prints \"Elapsed time is 9.5367431640625e-07 s\"\n        ```\n    \"\"\"\n\n    def __init__(self, t=0.0):\n        \"\"\"\n        Initialize the Profile class.\n\n        Args:\n            t (float): Initial time. Defaults to 0.0.\n        \"\"\"\n        self.t = t\n        self.cuda = torch.cuda.is_available()\n\n    def __enter__(self):\n        \"\"\"Start timing.\"\"\"\n        self.start = self.time()\n        return self\n\n    def __exit__(self, type, value, traceback):  # noqa\n        \"\"\"Stop timing.\"\"\"\n        self.dt = self.time() - self.start  # delta-time\n        self.t += self.dt  # accumulate dt\n\n    def __str__(self):\n        \"\"\"Returns a human-readable string representing the accumulated elapsed time in the profiler.\"\"\"\n        return f\"Elapsed time is {self.t} s\"\n\n    def time(self):\n        \"\"\"Get current time.\"\"\"\n        if self.cuda:\n            torch.cuda.synchronize()\n        return time.time()\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.Profile.__enter__","title":"<code>__enter__()</code>","text":"<p>Start timing.</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def __enter__(self):\n    \"\"\"Start timing.\"\"\"\n    self.start = self.time()\n    return self\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.Profile.__exit__","title":"<code>__exit__(type, value, traceback)</code>","text":"<p>Stop timing.</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def __exit__(self, type, value, traceback):  # noqa\n    \"\"\"Stop timing.\"\"\"\n    self.dt = self.time() - self.start  # delta-time\n    self.t += self.dt  # accumulate dt\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.Profile.__init__","title":"<code>__init__(t=0.0)</code>","text":"<p>Initialize the Profile class.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Initial time. Defaults to 0.0.</p> <code>0.0</code> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def __init__(self, t=0.0):\n    \"\"\"\n    Initialize the Profile class.\n\n    Args:\n        t (float): Initial time. Defaults to 0.0.\n    \"\"\"\n    self.t = t\n    self.cuda = torch.cuda.is_available()\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.Profile.__str__","title":"<code>__str__()</code>","text":"<p>Returns a human-readable string representing the accumulated elapsed time in the profiler.</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def __str__(self):\n    \"\"\"Returns a human-readable string representing the accumulated elapsed time in the profiler.\"\"\"\n    return f\"Elapsed time is {self.t} s\"\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.Profile.time","title":"<code>time()</code>","text":"<p>Get current time.</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def time(self):\n    \"\"\"Get current time.\"\"\"\n    if self.cuda:\n        torch.cuda.synchronize()\n    return time.time()\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.segment2box","title":"<code>ultralytics.utils.ops.segment2box(segment, width=640, height=640)</code>","text":"<p>Convert 1 segment label to 1 box label, applying inside-image constraint, i.e. (xy1, xy2, ...) to (xyxy).</p> <p>Parameters:</p> Name Type Description Default <code>segment</code> <code>Tensor</code> <p>the segment label</p> required <code>width</code> <code>int</code> <p>the width of the image. Defaults to 640</p> <code>640</code> <code>height</code> <code>int</code> <p>The height of the image. Defaults to 640</p> <code>640</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>the minimum and maximum x and y values of the segment.</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def segment2box(segment, width=640, height=640):\n    \"\"\"\n    Convert 1 segment label to 1 box label, applying inside-image constraint, i.e. (xy1, xy2, ...) to (xyxy).\n\n    Args:\n        segment (torch.Tensor): the segment label\n        width (int): the width of the image. Defaults to 640\n        height (int): The height of the image. Defaults to 640\n\n    Returns:\n        (np.ndarray): the minimum and maximum x and y values of the segment.\n    \"\"\"\n    # Convert 1 segment label to 1 box label, applying inside-image constraint, i.e. (xy1, xy2, ...) to (xyxy)\n    x, y = segment.T  # segment xy\n    inside = (x &gt;= 0) &amp; (y &gt;= 0) &amp; (x &lt;= width) &amp; (y &lt;= height)\n    x = x[inside]\n    y = y[inside]\n    return (\n        np.array([x.min(), y.min(), x.max(), y.max()], dtype=segment.dtype)\n        if any(x)\n        else np.zeros(4, dtype=segment.dtype)\n    )  # xyxy\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.scale_boxes","title":"<code>ultralytics.utils.ops.scale_boxes(img1_shape, boxes, img0_shape, ratio_pad=None, padding=True, xywh=False)</code>","text":"<p>Rescales bounding boxes (in the format of xyxy by default) from the shape of the image they were originally specified in (img1_shape) to the shape of a different image (img0_shape).</p> <p>Parameters:</p> Name Type Description Default <code>img1_shape</code> <code>tuple</code> <p>The shape of the image that the bounding boxes are for, in the format of (height, width).</p> required <code>boxes</code> <code>Tensor</code> <p>the bounding boxes of the objects in the image, in the format of (x1, y1, x2, y2)</p> required <code>img0_shape</code> <code>tuple</code> <p>the shape of the target image, in the format of (height, width).</p> required <code>ratio_pad</code> <code>tuple</code> <p>a tuple of (ratio, pad) for scaling the boxes. If not provided, the ratio and pad will be calculated based on the size difference between the two images.</p> <code>None</code> <code>padding</code> <code>bool</code> <p>If True, assuming the boxes is based on image augmented by yolo style. If False then do regular rescaling.</p> <code>True</code> <code>xywh</code> <code>bool</code> <p>The box format is xywh or not, default=False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>boxes</code> <code>Tensor</code> <p>The scaled bounding boxes, in the format of (x1, y1, x2, y2)</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def scale_boxes(img1_shape, boxes, img0_shape, ratio_pad=None, padding=True, xywh=False):\n    \"\"\"\n    Rescales bounding boxes (in the format of xyxy by default) from the shape of the image they were originally\n    specified in (img1_shape) to the shape of a different image (img0_shape).\n\n    Args:\n        img1_shape (tuple): The shape of the image that the bounding boxes are for, in the format of (height, width).\n        boxes (torch.Tensor): the bounding boxes of the objects in the image, in the format of (x1, y1, x2, y2)\n        img0_shape (tuple): the shape of the target image, in the format of (height, width).\n        ratio_pad (tuple): a tuple of (ratio, pad) for scaling the boxes. If not provided, the ratio and pad will be\n            calculated based on the size difference between the two images.\n        padding (bool): If True, assuming the boxes is based on image augmented by yolo style. If False then do regular\n            rescaling.\n        xywh (bool): The box format is xywh or not, default=False.\n\n    Returns:\n        boxes (torch.Tensor): The scaled bounding boxes, in the format of (x1, y1, x2, y2)\n    \"\"\"\n    if ratio_pad is None:  # calculate from img0_shape\n        gain = min(img1_shape[0] / img0_shape[0], img1_shape[1] / img0_shape[1])  # gain  = old / new\n        pad = (\n            round((img1_shape[1] - img0_shape[1] * gain) / 2 - 0.1),\n            round((img1_shape[0] - img0_shape[0] * gain) / 2 - 0.1),\n        )  # wh padding\n    else:\n        gain = ratio_pad[0][0]\n        pad = ratio_pad[1]\n\n    if padding:\n        boxes[..., 0] -= pad[0]  # x padding\n        boxes[..., 1] -= pad[1]  # y padding\n        if not xywh:\n            boxes[..., 2] -= pad[0]  # x padding\n            boxes[..., 3] -= pad[1]  # y padding\n    boxes[..., :4] /= gain\n    return clip_boxes(boxes, img0_shape)\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.make_divisible","title":"<code>ultralytics.utils.ops.make_divisible(x, divisor)</code>","text":"<p>Returns the nearest number that is divisible by the given divisor.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The number to make divisible.</p> required <code>divisor</code> <code>int | Tensor</code> <p>The divisor.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The nearest number divisible by the divisor.</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def make_divisible(x, divisor):\n    \"\"\"\n    Returns the nearest number that is divisible by the given divisor.\n\n    Args:\n        x (int): The number to make divisible.\n        divisor (int | torch.Tensor): The divisor.\n\n    Returns:\n        (int): The nearest number divisible by the divisor.\n    \"\"\"\n    if isinstance(divisor, torch.Tensor):\n        divisor = int(divisor.max())  # to int\n    return math.ceil(x / divisor) * divisor\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.nms_rotated","title":"<code>ultralytics.utils.ops.nms_rotated(boxes, scores, threshold=0.45)</code>","text":"<p>NMS for obbs, powered by probiou and fast-nms.</p> <p>Parameters:</p> Name Type Description Default <code>boxes</code> <code>Tensor</code> <p>(N, 5), xywhr.</p> required <code>scores</code> <code>Tensor</code> <p>(N, ).</p> required <code>threshold</code> <code>float</code> <p>Iou threshold.</p> <code>0.45</code> <p>Returns:</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def nms_rotated(boxes, scores, threshold=0.45):\n    \"\"\"\n    NMS for obbs, powered by probiou and fast-nms.\n\n    Args:\n        boxes (torch.Tensor): (N, 5), xywhr.\n        scores (torch.Tensor): (N, ).\n        threshold (float): Iou threshold.\n\n    Returns:\n    \"\"\"\n    if len(boxes) == 0:\n        return np.empty((0,), dtype=np.int8)\n    sorted_idx = torch.argsort(scores, descending=True)\n    boxes = boxes[sorted_idx]\n    ious = batch_probiou(boxes, boxes).triu_(diagonal=1)\n    pick = torch.nonzero(ious.max(dim=0)[0] &lt; threshold).squeeze_(-1)\n    return sorted_idx[pick]\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.non_max_suppression","title":"<code>ultralytics.utils.ops.non_max_suppression(prediction, conf_thres=0.25, iou_thres=0.45, classes=None, agnostic=False, multi_label=False, labels=(), max_det=300, nc=0, max_time_img=0.05, max_nms=30000, max_wh=7680, rotated=False)</code>","text":"<p>Perform non-maximum suppression (NMS) on a set of boxes, with support for masks and multiple labels per box.</p> <p>Parameters:</p> Name Type Description Default <code>prediction</code> <code>Tensor</code> <p>A tensor of shape (batch_size, num_classes + 4 + num_masks, num_boxes) containing the predicted boxes, classes, and masks. The tensor should be in the format output by a model, such as YOLO.</p> required <code>conf_thres</code> <code>float</code> <p>The confidence threshold below which boxes will be filtered out. Valid values are between 0.0 and 1.0.</p> <code>0.25</code> <code>iou_thres</code> <code>float</code> <p>The IoU threshold below which boxes will be filtered out during NMS. Valid values are between 0.0 and 1.0.</p> <code>0.45</code> <code>classes</code> <code>List[int]</code> <p>A list of class indices to consider. If None, all classes will be considered.</p> <code>None</code> <code>agnostic</code> <code>bool</code> <p>If True, the model is agnostic to the number of classes, and all classes will be considered as one.</p> <code>False</code> <code>multi_label</code> <code>bool</code> <p>If True, each box may have multiple labels.</p> <code>False</code> <code>labels</code> <code>List[List[Union[int, float, Tensor]]]</code> <p>A list of lists, where each inner list contains the apriori labels for a given image. The list should be in the format output by a dataloader, with each label being a tuple of (class_index, x1, y1, x2, y2).</p> <code>()</code> <code>max_det</code> <code>int</code> <p>The maximum number of boxes to keep after NMS.</p> <code>300</code> <code>nc</code> <code>int</code> <p>The number of classes output by the model. Any indices after this will be considered masks.</p> <code>0</code> <code>max_time_img</code> <code>float</code> <p>The maximum time (seconds) for processing one image.</p> <code>0.05</code> <code>max_nms</code> <code>int</code> <p>The maximum number of boxes into torchvision.ops.nms().</p> <code>30000</code> <code>max_wh</code> <code>int</code> <p>The maximum box width and height in pixels</p> <code>7680</code> <p>Returns:</p> Type Description <code>List[Tensor]</code> <p>A list of length batch_size, where each element is a tensor of shape (num_boxes, 6 + num_masks) containing the kept boxes, with columns (x1, y1, x2, y2, confidence, class, mask1, mask2, ...).</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def non_max_suppression(\n    prediction,\n    conf_thres=0.25,\n    iou_thres=0.45,\n    classes=None,\n    agnostic=False,\n    multi_label=False,\n    labels=(),\n    max_det=300,\n    nc=0,  # number of classes (optional)\n    max_time_img=0.05,\n    max_nms=30000,\n    max_wh=7680,\n    rotated=False,\n):\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of boxes, with support for masks and multiple labels per box.\n\n    Args:\n        prediction (torch.Tensor): A tensor of shape (batch_size, num_classes + 4 + num_masks, num_boxes)\n            containing the predicted boxes, classes, and masks. The tensor should be in the format\n            output by a model, such as YOLO.\n        conf_thres (float): The confidence threshold below which boxes will be filtered out.\n            Valid values are between 0.0 and 1.0.\n        iou_thres (float): The IoU threshold below which boxes will be filtered out during NMS.\n            Valid values are between 0.0 and 1.0.\n        classes (List[int]): A list of class indices to consider. If None, all classes will be considered.\n        agnostic (bool): If True, the model is agnostic to the number of classes, and all\n            classes will be considered as one.\n        multi_label (bool): If True, each box may have multiple labels.\n        labels (List[List[Union[int, float, torch.Tensor]]]): A list of lists, where each inner\n            list contains the apriori labels for a given image. The list should be in the format\n            output by a dataloader, with each label being a tuple of (class_index, x1, y1, x2, y2).\n        max_det (int): The maximum number of boxes to keep after NMS.\n        nc (int, optional): The number of classes output by the model. Any indices after this will be considered masks.\n        max_time_img (float): The maximum time (seconds) for processing one image.\n        max_nms (int): The maximum number of boxes into torchvision.ops.nms().\n        max_wh (int): The maximum box width and height in pixels\n\n    Returns:\n        (List[torch.Tensor]): A list of length batch_size, where each element is a tensor of\n            shape (num_boxes, 6 + num_masks) containing the kept boxes, with columns\n            (x1, y1, x2, y2, confidence, class, mask1, mask2, ...).\n    \"\"\"\n\n    # Checks\n    assert 0 &lt;= conf_thres &lt;= 1, f\"Invalid Confidence threshold {conf_thres}, valid values are between 0.0 and 1.0\"\n    assert 0 &lt;= iou_thres &lt;= 1, f\"Invalid IoU {iou_thres}, valid values are between 0.0 and 1.0\"\n    if isinstance(prediction, (list, tuple)):  # YOLOv8 model in validation model, output = (inference_out, loss_out)\n        prediction = prediction[0]  # select only inference output\n\n    bs = prediction.shape[0]  # batch size\n    nc = nc or (prediction.shape[1] - 4)  # number of classes\n    nm = prediction.shape[1] - nc - 4\n    mi = 4 + nc  # mask start index\n    xc = prediction[:, 4:mi].amax(1) &gt; conf_thres  # candidates\n\n    # Settings\n    # min_wh = 2  # (pixels) minimum box width and height\n    time_limit = 0.5 + max_time_img * bs  # seconds to quit after\n    multi_label &amp;= nc &gt; 1  # multiple labels per box (adds 0.5ms/img)\n\n    prediction = prediction.transpose(-1, -2)  # shape(1,84,6300) to shape(1,6300,84)\n    if not rotated:\n        prediction[..., :4] = xywh2xyxy(prediction[..., :4])  # xywh to xyxy\n\n    t = time.time()\n    output = [torch.zeros((0, 6 + nm), device=prediction.device)] * bs\n    for xi, x in enumerate(prediction):  # image index, image inference\n        # Apply constraints\n        # x[((x[:, 2:4] &lt; min_wh) | (x[:, 2:4] &gt; max_wh)).any(1), 4] = 0  # width-height\n        x = x[xc[xi]]  # confidence\n\n        # Cat apriori labels if autolabelling\n        if labels and len(labels[xi]) and not rotated:\n            lb = labels[xi]\n            v = torch.zeros((len(lb), nc + nm + 4), device=x.device)\n            v[:, :4] = xywh2xyxy(lb[:, 1:5])  # box\n            v[range(len(lb)), lb[:, 0].long() + 4] = 1.0  # cls\n            x = torch.cat((x, v), 0)\n\n        # If none remain process next image\n        if not x.shape[0]:\n            continue\n\n        # Detections matrix nx6 (xyxy, conf, cls)\n        box, cls, mask = x.split((4, nc, nm), 1)\n\n        if multi_label:\n            i, j = torch.where(cls &gt; conf_thres)\n            x = torch.cat((box[i], x[i, 4 + j, None], j[:, None].float(), mask[i]), 1)\n        else:  # best class only\n            conf, j = cls.max(1, keepdim=True)\n            x = torch.cat((box, conf, j.float(), mask), 1)[conf.view(-1) &gt; conf_thres]\n\n        # Filter by class\n        if classes is not None:\n            x = x[(x[:, 5:6] == torch.tensor(classes, device=x.device)).any(1)]\n\n        # Check shape\n        n = x.shape[0]  # number of boxes\n        if not n:  # no boxes\n            continue\n        if n &gt; max_nms:  # excess boxes\n            x = x[x[:, 4].argsort(descending=True)[:max_nms]]  # sort by confidence and remove excess boxes\n\n        # Batched NMS\n        c = x[:, 5:6] * (0 if agnostic else max_wh)  # classes\n        scores = x[:, 4]  # scores\n        if rotated:\n            boxes = torch.cat((x[:, :2] + c, x[:, 2:4], x[:, -1:]), dim=-1)  # xywhr\n            i = nms_rotated(boxes, scores, iou_thres)\n        else:\n            boxes = x[:, :4] + c  # boxes (offset by class)\n            i = torchvision.ops.nms(boxes, scores, iou_thres)  # NMS\n        i = i[:max_det]  # limit detections\n\n        # # Experimental\n        # merge = False  # use merge-NMS\n        # if merge and (1 &lt; n &lt; 3E3):  # Merge NMS (boxes merged using weighted mean)\n        #     # Update boxes as boxes(i,4) = weights(i,n) * boxes(n,4)\n        #     from .metrics import box_iou\n        #     iou = box_iou(boxes[i], boxes) &gt; iou_thres  # iou matrix\n        #     weights = iou * scores[None]  # box weights\n        #     x[i, :4] = torch.mm(weights, x[:, :4]).float() / weights.sum(1, keepdim=True)  # merged boxes\n        #     redundant = True  # require redundant detections\n        #     if redundant:\n        #         i = i[iou.sum(1) &gt; 1]  # require redundancy\n\n        output[xi] = x[i]\n        if (time.time() - t) &gt; time_limit:\n            LOGGER.warning(f\"WARNING \u26a0\ufe0f NMS time limit {time_limit:.3f}s exceeded\")\n            break  # time limit exceeded\n\n    return output\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.clip_boxes","title":"<code>ultralytics.utils.ops.clip_boxes(boxes, shape)</code>","text":"<p>Takes a list of bounding boxes and a shape (height, width) and clips the bounding boxes to the shape.</p> <p>Parameters:</p> Name Type Description Default <code>boxes</code> <code>Tensor</code> <p>the bounding boxes to clip</p> required <code>shape</code> <code>tuple</code> <p>the shape of the image</p> required <p>Returns:</p> Type Description <code>Tensor | ndarray</code> <p>Clipped boxes</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def clip_boxes(boxes, shape):\n    \"\"\"\n    Takes a list of bounding boxes and a shape (height, width) and clips the bounding boxes to the shape.\n\n    Args:\n        boxes (torch.Tensor): the bounding boxes to clip\n        shape (tuple): the shape of the image\n\n    Returns:\n        (torch.Tensor | numpy.ndarray): Clipped boxes\n    \"\"\"\n    if isinstance(boxes, torch.Tensor):  # faster individually (WARNING: inplace .clamp_() Apple MPS bug)\n        boxes[..., 0] = boxes[..., 0].clamp(0, shape[1])  # x1\n        boxes[..., 1] = boxes[..., 1].clamp(0, shape[0])  # y1\n        boxes[..., 2] = boxes[..., 2].clamp(0, shape[1])  # x2\n        boxes[..., 3] = boxes[..., 3].clamp(0, shape[0])  # y2\n    else:  # np.array (faster grouped)\n        boxes[..., [0, 2]] = boxes[..., [0, 2]].clip(0, shape[1])  # x1, x2\n        boxes[..., [1, 3]] = boxes[..., [1, 3]].clip(0, shape[0])  # y1, y2\n    return boxes\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.clip_coords","title":"<code>ultralytics.utils.ops.clip_coords(coords, shape)</code>","text":"<p>Clip line coordinates to the image boundaries.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>Tensor | ndarray</code> <p>A list of line coordinates.</p> required <code>shape</code> <code>tuple</code> <p>A tuple of integers representing the size of the image in the format (height, width).</p> required <p>Returns:</p> Type Description <code>Tensor | ndarray</code> <p>Clipped coordinates</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def clip_coords(coords, shape):\n    \"\"\"\n    Clip line coordinates to the image boundaries.\n\n    Args:\n        coords (torch.Tensor | numpy.ndarray): A list of line coordinates.\n        shape (tuple): A tuple of integers representing the size of the image in the format (height, width).\n\n    Returns:\n        (torch.Tensor | numpy.ndarray): Clipped coordinates\n    \"\"\"\n    if isinstance(coords, torch.Tensor):  # faster individually (WARNING: inplace .clamp_() Apple MPS bug)\n        coords[..., 0] = coords[..., 0].clamp(0, shape[1])  # x\n        coords[..., 1] = coords[..., 1].clamp(0, shape[0])  # y\n    else:  # np.array (faster grouped)\n        coords[..., 0] = coords[..., 0].clip(0, shape[1])  # x\n        coords[..., 1] = coords[..., 1].clip(0, shape[0])  # y\n    return coords\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.scale_image","title":"<code>ultralytics.utils.ops.scale_image(masks, im0_shape, ratio_pad=None)</code>","text":"<p>Takes a mask, and resizes it to the original image size.</p> <p>Parameters:</p> Name Type Description Default <code>masks</code> <code>ndarray</code> <p>resized and padded masks/images, [h, w, num]/[h, w, 3].</p> required <code>im0_shape</code> <code>tuple</code> <p>the original image shape</p> required <code>ratio_pad</code> <code>tuple</code> <p>the ratio of the padding to the original image.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>masks</code> <code>Tensor</code> <p>The masks that are being returned.</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def scale_image(masks, im0_shape, ratio_pad=None):\n    \"\"\"\n    Takes a mask, and resizes it to the original image size.\n\n    Args:\n        masks (np.ndarray): resized and padded masks/images, [h, w, num]/[h, w, 3].\n        im0_shape (tuple): the original image shape\n        ratio_pad (tuple): the ratio of the padding to the original image.\n\n    Returns:\n        masks (torch.Tensor): The masks that are being returned.\n    \"\"\"\n    # Rescale coordinates (xyxy) from im1_shape to im0_shape\n    im1_shape = masks.shape\n    if im1_shape[:2] == im0_shape[:2]:\n        return masks\n    if ratio_pad is None:  # calculate from im0_shape\n        gain = min(im1_shape[0] / im0_shape[0], im1_shape[1] / im0_shape[1])  # gain  = old / new\n        pad = (im1_shape[1] - im0_shape[1] * gain) / 2, (im1_shape[0] - im0_shape[0] * gain) / 2  # wh padding\n    else:\n        # gain = ratio_pad[0][0]\n        pad = ratio_pad[1]\n    top, left = (int(round(pad[1] - 0.1)), int(round(pad[0] - 0.1)))  # y, x\n    bottom, right = (int(round(im1_shape[0] - pad[1] + 0.1)), int(round(im1_shape[1] - pad[0] + 0.1)))\n\n    if len(masks.shape) &lt; 2:\n        raise ValueError(f'\"len of masks shape\" should be 2 or 3, but got {len(masks.shape)}')\n    masks = masks[top:bottom, left:right]\n    masks = cv2.resize(masks, (im0_shape[1], im0_shape[0]))\n    if len(masks.shape) == 2:\n        masks = masks[:, :, None]\n\n    return masks\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.xyxy2xywh","title":"<code>ultralytics.utils.ops.xyxy2xywh(x)</code>","text":"<p>Convert bounding box coordinates from (x1, y1, x2, y2) format to (x, y, width, height) format where (x1, y1) is the top-left corner and (x2, y2) is the bottom-right corner.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray | Tensor</code> <p>The input bounding box coordinates in (x1, y1, x2, y2) format.</p> required <p>Returns:</p> Name Type Description <code>y</code> <code>ndarray | Tensor</code> <p>The bounding box coordinates in (x, y, width, height) format.</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def xyxy2xywh(x):\n    \"\"\"\n    Convert bounding box coordinates from (x1, y1, x2, y2) format to (x, y, width, height) format where (x1, y1) is the\n    top-left corner and (x2, y2) is the bottom-right corner.\n\n    Args:\n        x (np.ndarray | torch.Tensor): The input bounding box coordinates in (x1, y1, x2, y2) format.\n\n    Returns:\n        y (np.ndarray | torch.Tensor): The bounding box coordinates in (x, y, width, height) format.\n    \"\"\"\n    assert x.shape[-1] == 4, f\"input shape last dimension expected 4 but input shape is {x.shape}\"\n    y = torch.empty_like(x) if isinstance(x, torch.Tensor) else np.empty_like(x)  # faster than clone/copy\n    y[..., 0] = (x[..., 0] + x[..., 2]) / 2  # x center\n    y[..., 1] = (x[..., 1] + x[..., 3]) / 2  # y center\n    y[..., 2] = x[..., 2] - x[..., 0]  # width\n    y[..., 3] = x[..., 3] - x[..., 1]  # height\n    return y\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.xywh2xyxy","title":"<code>ultralytics.utils.ops.xywh2xyxy(x)</code>","text":"<p>Convert bounding box coordinates from (x, y, width, height) format to (x1, y1, x2, y2) format where (x1, y1) is the top-left corner and (x2, y2) is the bottom-right corner.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray | Tensor</code> <p>The input bounding box coordinates in (x, y, width, height) format.</p> required <p>Returns:</p> Name Type Description <code>y</code> <code>ndarray | Tensor</code> <p>The bounding box coordinates in (x1, y1, x2, y2) format.</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def xywh2xyxy(x):\n    \"\"\"\n    Convert bounding box coordinates from (x, y, width, height) format to (x1, y1, x2, y2) format where (x1, y1) is the\n    top-left corner and (x2, y2) is the bottom-right corner.\n\n    Args:\n        x (np.ndarray | torch.Tensor): The input bounding box coordinates in (x, y, width, height) format.\n\n    Returns:\n        y (np.ndarray | torch.Tensor): The bounding box coordinates in (x1, y1, x2, y2) format.\n    \"\"\"\n    assert x.shape[-1] == 4, f\"input shape last dimension expected 4 but input shape is {x.shape}\"\n    y = torch.empty_like(x) if isinstance(x, torch.Tensor) else np.empty_like(x)  # faster than clone/copy\n    dw = x[..., 2] / 2  # half-width\n    dh = x[..., 3] / 2  # half-height\n    y[..., 0] = x[..., 0] - dw  # top left x\n    y[..., 1] = x[..., 1] - dh  # top left y\n    y[..., 2] = x[..., 0] + dw  # bottom right x\n    y[..., 3] = x[..., 1] + dh  # bottom right y\n    return y\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.xywhn2xyxy","title":"<code>ultralytics.utils.ops.xywhn2xyxy(x, w=640, h=640, padw=0, padh=0)</code>","text":"<p>Convert normalized bounding box coordinates to pixel coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray | Tensor</code> <p>The bounding box coordinates.</p> required <code>w</code> <code>int</code> <p>Width of the image. Defaults to 640</p> <code>640</code> <code>h</code> <code>int</code> <p>Height of the image. Defaults to 640</p> <code>640</code> <code>padw</code> <code>int</code> <p>Padding width. Defaults to 0</p> <code>0</code> <code>padh</code> <code>int</code> <p>Padding height. Defaults to 0</p> <code>0</code> <p>Returns:     y (np.ndarray | torch.Tensor): The coordinates of the bounding box in the format [x1, y1, x2, y2] where         x1,y1 is the top-left corner, x2,y2 is the bottom-right corner of the bounding box.</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def xywhn2xyxy(x, w=640, h=640, padw=0, padh=0):\n    \"\"\"\n    Convert normalized bounding box coordinates to pixel coordinates.\n\n    Args:\n        x (np.ndarray | torch.Tensor): The bounding box coordinates.\n        w (int): Width of the image. Defaults to 640\n        h (int): Height of the image. Defaults to 640\n        padw (int): Padding width. Defaults to 0\n        padh (int): Padding height. Defaults to 0\n    Returns:\n        y (np.ndarray | torch.Tensor): The coordinates of the bounding box in the format [x1, y1, x2, y2] where\n            x1,y1 is the top-left corner, x2,y2 is the bottom-right corner of the bounding box.\n    \"\"\"\n    assert x.shape[-1] == 4, f\"input shape last dimension expected 4 but input shape is {x.shape}\"\n    y = torch.empty_like(x) if isinstance(x, torch.Tensor) else np.empty_like(x)  # faster than clone/copy\n    y[..., 0] = w * (x[..., 0] - x[..., 2] / 2) + padw  # top left x\n    y[..., 1] = h * (x[..., 1] - x[..., 3] / 2) + padh  # top left y\n    y[..., 2] = w * (x[..., 0] + x[..., 2] / 2) + padw  # bottom right x\n    y[..., 3] = h * (x[..., 1] + x[..., 3] / 2) + padh  # bottom right y\n    return y\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.xyxy2xywhn","title":"<code>ultralytics.utils.ops.xyxy2xywhn(x, w=640, h=640, clip=False, eps=0.0)</code>","text":"<p>Convert bounding box coordinates from (x1, y1, x2, y2) format to (x, y, width, height, normalized) format. x, y, width and height are normalized to image dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray | Tensor</code> <p>The input bounding box coordinates in (x1, y1, x2, y2) format.</p> required <code>w</code> <code>int</code> <p>The width of the image. Defaults to 640</p> <code>640</code> <code>h</code> <code>int</code> <p>The height of the image. Defaults to 640</p> <code>640</code> <code>clip</code> <code>bool</code> <p>If True, the boxes will be clipped to the image boundaries. Defaults to False</p> <code>False</code> <code>eps</code> <code>float</code> <p>The minimum value of the box's width and height. Defaults to 0.0</p> <code>0.0</code> <p>Returns:</p> Name Type Description <code>y</code> <code>ndarray | Tensor</code> <p>The bounding box coordinates in (x, y, width, height, normalized) format</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def xyxy2xywhn(x, w=640, h=640, clip=False, eps=0.0):\n    \"\"\"\n    Convert bounding box coordinates from (x1, y1, x2, y2) format to (x, y, width, height, normalized) format. x, y,\n    width and height are normalized to image dimensions.\n\n    Args:\n        x (np.ndarray | torch.Tensor): The input bounding box coordinates in (x1, y1, x2, y2) format.\n        w (int): The width of the image. Defaults to 640\n        h (int): The height of the image. Defaults to 640\n        clip (bool): If True, the boxes will be clipped to the image boundaries. Defaults to False\n        eps (float): The minimum value of the box's width and height. Defaults to 0.0\n\n    Returns:\n        y (np.ndarray | torch.Tensor): The bounding box coordinates in (x, y, width, height, normalized) format\n    \"\"\"\n    if clip:\n        x = clip_boxes(x, (h - eps, w - eps))\n    assert x.shape[-1] == 4, f\"input shape last dimension expected 4 but input shape is {x.shape}\"\n    y = torch.empty_like(x) if isinstance(x, torch.Tensor) else np.empty_like(x)  # faster than clone/copy\n    y[..., 0] = ((x[..., 0] + x[..., 2]) / 2) / w  # x center\n    y[..., 1] = ((x[..., 1] + x[..., 3]) / 2) / h  # y center\n    y[..., 2] = (x[..., 2] - x[..., 0]) / w  # width\n    y[..., 3] = (x[..., 3] - x[..., 1]) / h  # height\n    return y\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.xywh2ltwh","title":"<code>ultralytics.utils.ops.xywh2ltwh(x)</code>","text":"<p>Convert the bounding box format from [x, y, w, h] to [x1, y1, w, h], where x1, y1 are the top-left coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray | Tensor</code> <p>The input tensor with the bounding box coordinates in the xywh format</p> required <p>Returns:</p> Name Type Description <code>y</code> <code>ndarray | Tensor</code> <p>The bounding box coordinates in the xyltwh format</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def xywh2ltwh(x):\n    \"\"\"\n    Convert the bounding box format from [x, y, w, h] to [x1, y1, w, h], where x1, y1 are the top-left coordinates.\n\n    Args:\n        x (np.ndarray | torch.Tensor): The input tensor with the bounding box coordinates in the xywh format\n\n    Returns:\n        y (np.ndarray | torch.Tensor): The bounding box coordinates in the xyltwh format\n    \"\"\"\n    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)\n    y[..., 0] = x[..., 0] - x[..., 2] / 2  # top left x\n    y[..., 1] = x[..., 1] - x[..., 3] / 2  # top left y\n    return y\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.xyxy2ltwh","title":"<code>ultralytics.utils.ops.xyxy2ltwh(x)</code>","text":"<p>Convert nx4 bounding boxes from [x1, y1, x2, y2] to [x1, y1, w, h], where xy1=top-left, xy2=bottom-right.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray | Tensor</code> <p>The input tensor with the bounding boxes coordinates in the xyxy format</p> required <p>Returns:</p> Name Type Description <code>y</code> <code>ndarray | Tensor</code> <p>The bounding box coordinates in the xyltwh format.</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def xyxy2ltwh(x):\n    \"\"\"\n    Convert nx4 bounding boxes from [x1, y1, x2, y2] to [x1, y1, w, h], where xy1=top-left, xy2=bottom-right.\n\n    Args:\n        x (np.ndarray | torch.Tensor): The input tensor with the bounding boxes coordinates in the xyxy format\n\n    Returns:\n        y (np.ndarray | torch.Tensor): The bounding box coordinates in the xyltwh format.\n    \"\"\"\n    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)\n    y[..., 2] = x[..., 2] - x[..., 0]  # width\n    y[..., 3] = x[..., 3] - x[..., 1]  # height\n    return y\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.ltwh2xywh","title":"<code>ultralytics.utils.ops.ltwh2xywh(x)</code>","text":"<p>Convert nx4 boxes from [x1, y1, w, h] to [x, y, w, h] where xy1=top-left, xy=center.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>the input tensor</p> required <p>Returns:</p> Name Type Description <code>y</code> <code>ndarray | Tensor</code> <p>The bounding box coordinates in the xywh format.</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def ltwh2xywh(x):\n    \"\"\"\n    Convert nx4 boxes from [x1, y1, w, h] to [x, y, w, h] where xy1=top-left, xy=center.\n\n    Args:\n        x (torch.Tensor): the input tensor\n\n    Returns:\n        y (np.ndarray | torch.Tensor): The bounding box coordinates in the xywh format.\n    \"\"\"\n    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)\n    y[..., 0] = x[..., 0] + x[..., 2] / 2  # center x\n    y[..., 1] = x[..., 1] + x[..., 3] / 2  # center y\n    return y\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.xyxyxyxy2xywhr","title":"<code>ultralytics.utils.ops.xyxyxyxy2xywhr(corners)</code>","text":"<p>Convert batched Oriented Bounding Boxes (OBB) from [xy1, xy2, xy3, xy4] to [xywh, rotation]. Rotation values are expected in degrees from 0 to 90.</p> <p>Parameters:</p> Name Type Description Default <code>corners</code> <code>ndarray | Tensor</code> <p>Input corners of shape (n, 8).</p> required <p>Returns:</p> Type Description <code>ndarray | Tensor</code> <p>Converted data in [cx, cy, w, h, rotation] format of shape (n, 5).</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def xyxyxyxy2xywhr(corners):\n    \"\"\"\n    Convert batched Oriented Bounding Boxes (OBB) from [xy1, xy2, xy3, xy4] to [xywh, rotation]. Rotation values are\n    expected in degrees from 0 to 90.\n\n    Args:\n        corners (numpy.ndarray | torch.Tensor): Input corners of shape (n, 8).\n\n    Returns:\n        (numpy.ndarray | torch.Tensor): Converted data in [cx, cy, w, h, rotation] format of shape (n, 5).\n    \"\"\"\n    is_torch = isinstance(corners, torch.Tensor)\n    points = corners.cpu().numpy() if is_torch else corners\n    points = points.reshape(len(corners), -1, 2)\n    rboxes = []\n    for pts in points:\n        # NOTE: Use cv2.minAreaRect to get accurate xywhr,\n        # especially some objects are cut off by augmentations in dataloader.\n        (x, y), (w, h), angle = cv2.minAreaRect(pts)\n        rboxes.append([x, y, w, h, angle / 180 * np.pi])\n    rboxes = (\n        torch.tensor(rboxes, device=corners.device, dtype=corners.dtype)\n        if is_torch\n        else np.asarray(rboxes, dtype=points.dtype)\n    )\n    return rboxes\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.xywhr2xyxyxyxy","title":"<code>ultralytics.utils.ops.xywhr2xyxyxyxy(center)</code>","text":"<p>Convert batched Oriented Bounding Boxes (OBB) from [xywh, rotation] to [xy1, xy2, xy3, xy4]. Rotation values should be in degrees from 0 to 90.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>ndarray | Tensor</code> <p>Input data in [cx, cy, w, h, rotation] format of shape (n, 5) or (b, n, 5).</p> required <p>Returns:</p> Type Description <code>ndarray | Tensor</code> <p>Converted corner points of shape (n, 4, 2) or (b, n, 4, 2).</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def xywhr2xyxyxyxy(center):\n    \"\"\"\n    Convert batched Oriented Bounding Boxes (OBB) from [xywh, rotation] to [xy1, xy2, xy3, xy4]. Rotation values should\n    be in degrees from 0 to 90.\n\n    Args:\n        center (numpy.ndarray | torch.Tensor): Input data in [cx, cy, w, h, rotation] format of shape (n, 5) or (b, n, 5).\n\n    Returns:\n        (numpy.ndarray | torch.Tensor): Converted corner points of shape (n, 4, 2) or (b, n, 4, 2).\n    \"\"\"\n    is_numpy = isinstance(center, np.ndarray)\n    cos, sin = (np.cos, np.sin) if is_numpy else (torch.cos, torch.sin)\n\n    ctr = center[..., :2]\n    w, h, angle = (center[..., i : i + 1] for i in range(2, 5))\n    cos_value, sin_value = cos(angle), sin(angle)\n    vec1 = [w / 2 * cos_value, w / 2 * sin_value]\n    vec2 = [-h / 2 * sin_value, h / 2 * cos_value]\n    vec1 = np.concatenate(vec1, axis=-1) if is_numpy else torch.cat(vec1, dim=-1)\n    vec2 = np.concatenate(vec2, axis=-1) if is_numpy else torch.cat(vec2, dim=-1)\n    pt1 = ctr + vec1 + vec2\n    pt2 = ctr + vec1 - vec2\n    pt3 = ctr - vec1 - vec2\n    pt4 = ctr - vec1 + vec2\n    return np.stack([pt1, pt2, pt3, pt4], axis=-2) if is_numpy else torch.stack([pt1, pt2, pt3, pt4], dim=-2)\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.ltwh2xyxy","title":"<code>ultralytics.utils.ops.ltwh2xyxy(x)</code>","text":"<p>It converts the bounding box from [x1, y1, w, h] to [x1, y1, x2, y2] where xy1=top-left, xy2=bottom-right.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray | Tensor</code> <p>the input image</p> required <p>Returns:</p> Name Type Description <code>y</code> <code>ndarray | Tensor</code> <p>the xyxy coordinates of the bounding boxes.</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def ltwh2xyxy(x):\n    \"\"\"\n    It converts the bounding box from [x1, y1, w, h] to [x1, y1, x2, y2] where xy1=top-left, xy2=bottom-right.\n\n    Args:\n        x (np.ndarray | torch.Tensor): the input image\n\n    Returns:\n        y (np.ndarray | torch.Tensor): the xyxy coordinates of the bounding boxes.\n    \"\"\"\n    y = x.clone() if isinstance(x, torch.Tensor) else np.copy(x)\n    y[..., 2] = x[..., 2] + x[..., 0]  # width\n    y[..., 3] = x[..., 3] + x[..., 1]  # height\n    return y\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.segments2boxes","title":"<code>ultralytics.utils.ops.segments2boxes(segments)</code>","text":"<p>It converts segment labels to box labels, i.e. (cls, xy1, xy2, ...) to (cls, xywh)</p> <p>Parameters:</p> Name Type Description Default <code>segments</code> <code>list</code> <p>list of segments, each segment is a list of points, each point is a list of x, y coordinates</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>the xywh coordinates of the bounding boxes.</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def segments2boxes(segments):\n    \"\"\"\n    It converts segment labels to box labels, i.e. (cls, xy1, xy2, ...) to (cls, xywh)\n\n    Args:\n        segments (list): list of segments, each segment is a list of points, each point is a list of x, y coordinates\n\n    Returns:\n        (np.ndarray): the xywh coordinates of the bounding boxes.\n    \"\"\"\n    boxes = []\n    for s in segments:\n        x, y = s.T  # segment xy\n        boxes.append([x.min(), y.min(), x.max(), y.max()])  # cls, xyxy\n    return xyxy2xywh(np.array(boxes))  # cls, xywh\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.resample_segments","title":"<code>ultralytics.utils.ops.resample_segments(segments, n=1000)</code>","text":"<p>Inputs a list of segments (n,2) and returns a list of segments (n,2) up-sampled to n points each.</p> <p>Parameters:</p> Name Type Description Default <code>segments</code> <code>list</code> <p>a list of (n,2) arrays, where n is the number of points in the segment.</p> required <code>n</code> <code>int</code> <p>number of points to resample the segment to. Defaults to 1000</p> <code>1000</code> <p>Returns:</p> Name Type Description <code>segments</code> <code>list</code> <p>the resampled segments.</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def resample_segments(segments, n=1000):\n    \"\"\"\n    Inputs a list of segments (n,2) and returns a list of segments (n,2) up-sampled to n points each.\n\n    Args:\n        segments (list): a list of (n,2) arrays, where n is the number of points in the segment.\n        n (int): number of points to resample the segment to. Defaults to 1000\n\n    Returns:\n        segments (list): the resampled segments.\n    \"\"\"\n    for i, s in enumerate(segments):\n        s = np.concatenate((s, s[0:1, :]), axis=0)\n        x = np.linspace(0, len(s) - 1, n)\n        xp = np.arange(len(s))\n        segments[i] = (\n            np.concatenate([np.interp(x, xp, s[:, i]) for i in range(2)], dtype=np.float32).reshape(2, -1).T\n        )  # segment xy\n    return segments\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.crop_mask","title":"<code>ultralytics.utils.ops.crop_mask(masks, boxes)</code>","text":"<p>It takes a mask and a bounding box, and returns a mask that is cropped to the bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>masks</code> <code>Tensor</code> <p>[n, h, w] tensor of masks</p> required <code>boxes</code> <code>Tensor</code> <p>[n, 4] tensor of bbox coordinates in relative point form</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The masks are being cropped to the bounding box.</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def crop_mask(masks, boxes):\n    \"\"\"\n    It takes a mask and a bounding box, and returns a mask that is cropped to the bounding box.\n\n    Args:\n        masks (torch.Tensor): [n, h, w] tensor of masks\n        boxes (torch.Tensor): [n, 4] tensor of bbox coordinates in relative point form\n\n    Returns:\n        (torch.Tensor): The masks are being cropped to the bounding box.\n    \"\"\"\n    n, h, w = masks.shape\n    x1, y1, x2, y2 = torch.chunk(boxes[:, :, None], 4, 1)  # x1 shape(n,1,1)\n    r = torch.arange(w, device=masks.device, dtype=x1.dtype)[None, None, :]  # rows shape(1,1,w)\n    c = torch.arange(h, device=masks.device, dtype=x1.dtype)[None, :, None]  # cols shape(1,h,1)\n\n    return masks * ((r &gt;= x1) * (r &lt; x2) * (c &gt;= y1) * (c &lt; y2))\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.process_mask_upsample","title":"<code>ultralytics.utils.ops.process_mask_upsample(protos, masks_in, bboxes, shape)</code>","text":"<p>Takes the output of the mask head, and applies the mask to the bounding boxes. This produces masks of higher quality but is slower.</p> <p>Parameters:</p> Name Type Description Default <code>protos</code> <code>Tensor</code> <p>[mask_dim, mask_h, mask_w]</p> required <code>masks_in</code> <code>Tensor</code> <p>[n, mask_dim], n is number of masks after nms</p> required <code>bboxes</code> <code>Tensor</code> <p>[n, 4], n is number of masks after nms</p> required <code>shape</code> <code>tuple</code> <p>the size of the input image (h,w)</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The upsampled masks.</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def process_mask_upsample(protos, masks_in, bboxes, shape):\n    \"\"\"\n    Takes the output of the mask head, and applies the mask to the bounding boxes. This produces masks of higher quality\n    but is slower.\n\n    Args:\n        protos (torch.Tensor): [mask_dim, mask_h, mask_w]\n        masks_in (torch.Tensor): [n, mask_dim], n is number of masks after nms\n        bboxes (torch.Tensor): [n, 4], n is number of masks after nms\n        shape (tuple): the size of the input image (h,w)\n\n    Returns:\n        (torch.Tensor): The upsampled masks.\n    \"\"\"\n    c, mh, mw = protos.shape  # CHW\n    masks = (masks_in @ protos.float().view(c, -1)).sigmoid().view(-1, mh, mw)\n    masks = F.interpolate(masks[None], shape, mode=\"bilinear\", align_corners=False)[0]  # CHW\n    masks = crop_mask(masks, bboxes)  # CHW\n    return masks.gt_(0.5)\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.process_mask","title":"<code>ultralytics.utils.ops.process_mask(protos, masks_in, bboxes, shape, upsample=False)</code>","text":"<p>Apply masks to bounding boxes using the output of the mask head.</p> <p>Parameters:</p> Name Type Description Default <code>protos</code> <code>Tensor</code> <p>A tensor of shape [mask_dim, mask_h, mask_w].</p> required <code>masks_in</code> <code>Tensor</code> <p>A tensor of shape [n, mask_dim], where n is the number of masks after NMS.</p> required <code>bboxes</code> <code>Tensor</code> <p>A tensor of shape [n, 4], where n is the number of masks after NMS.</p> required <code>shape</code> <code>tuple</code> <p>A tuple of integers representing the size of the input image in the format (h, w).</p> required <code>upsample</code> <code>bool</code> <p>A flag to indicate whether to upsample the mask to the original image size. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>A binary mask tensor of shape [n, h, w], where n is the number of masks after NMS, and h and w are the height and width of the input image. The mask is applied to the bounding boxes.</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def process_mask(protos, masks_in, bboxes, shape, upsample=False):\n    \"\"\"\n    Apply masks to bounding boxes using the output of the mask head.\n\n    Args:\n        protos (torch.Tensor): A tensor of shape [mask_dim, mask_h, mask_w].\n        masks_in (torch.Tensor): A tensor of shape [n, mask_dim], where n is the number of masks after NMS.\n        bboxes (torch.Tensor): A tensor of shape [n, 4], where n is the number of masks after NMS.\n        shape (tuple): A tuple of integers representing the size of the input image in the format (h, w).\n        upsample (bool): A flag to indicate whether to upsample the mask to the original image size. Default is False.\n\n    Returns:\n        (torch.Tensor): A binary mask tensor of shape [n, h, w], where n is the number of masks after NMS, and h and w\n            are the height and width of the input image. The mask is applied to the bounding boxes.\n    \"\"\"\n\n    c, mh, mw = protos.shape  # CHW\n    ih, iw = shape\n    masks = (masks_in @ protos.float().view(c, -1)).sigmoid().view(-1, mh, mw)  # CHW\n\n    downsampled_bboxes = bboxes.clone()\n    downsampled_bboxes[:, 0] *= mw / iw\n    downsampled_bboxes[:, 2] *= mw / iw\n    downsampled_bboxes[:, 3] *= mh / ih\n    downsampled_bboxes[:, 1] *= mh / ih\n\n    masks = crop_mask(masks, downsampled_bboxes)  # CHW\n    if upsample:\n        masks = F.interpolate(masks[None], shape, mode=\"bilinear\", align_corners=False)[0]  # CHW\n    return masks.gt_(0.5)\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.process_mask_native","title":"<code>ultralytics.utils.ops.process_mask_native(protos, masks_in, bboxes, shape)</code>","text":"<p>It takes the output of the mask head, and crops it after upsampling to the bounding boxes.</p> <p>Parameters:</p> Name Type Description Default <code>protos</code> <code>Tensor</code> <p>[mask_dim, mask_h, mask_w]</p> required <code>masks_in</code> <code>Tensor</code> <p>[n, mask_dim], n is number of masks after nms</p> required <code>bboxes</code> <code>Tensor</code> <p>[n, 4], n is number of masks after nms</p> required <code>shape</code> <code>tuple</code> <p>the size of the input image (h,w)</p> required <p>Returns:</p> Name Type Description <code>masks</code> <code>Tensor</code> <p>The returned masks with dimensions [h, w, n]</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def process_mask_native(protos, masks_in, bboxes, shape):\n    \"\"\"\n    It takes the output of the mask head, and crops it after upsampling to the bounding boxes.\n\n    Args:\n        protos (torch.Tensor): [mask_dim, mask_h, mask_w]\n        masks_in (torch.Tensor): [n, mask_dim], n is number of masks after nms\n        bboxes (torch.Tensor): [n, 4], n is number of masks after nms\n        shape (tuple): the size of the input image (h,w)\n\n    Returns:\n        masks (torch.Tensor): The returned masks with dimensions [h, w, n]\n    \"\"\"\n    c, mh, mw = protos.shape  # CHW\n    masks = (masks_in @ protos.float().view(c, -1)).sigmoid().view(-1, mh, mw)\n    masks = scale_masks(masks[None], shape)[0]  # CHW\n    masks = crop_mask(masks, bboxes)  # CHW\n    return masks.gt_(0.5)\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.scale_masks","title":"<code>ultralytics.utils.ops.scale_masks(masks, shape, padding=True)</code>","text":"<p>Rescale segment masks to shape.</p> <p>Parameters:</p> Name Type Description Default <code>masks</code> <code>Tensor</code> <p>(N, C, H, W).</p> required <code>shape</code> <code>tuple</code> <p>Height and width.</p> required <code>padding</code> <code>bool</code> <p>If True, assuming the boxes is based on image augmented by yolo style. If False then do regular rescaling.</p> <code>True</code> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def scale_masks(masks, shape, padding=True):\n    \"\"\"\n    Rescale segment masks to shape.\n\n    Args:\n        masks (torch.Tensor): (N, C, H, W).\n        shape (tuple): Height and width.\n        padding (bool): If True, assuming the boxes is based on image augmented by yolo style. If False then do regular\n            rescaling.\n    \"\"\"\n    mh, mw = masks.shape[2:]\n    gain = min(mh / shape[0], mw / shape[1])  # gain  = old / new\n    pad = [mw - shape[1] * gain, mh - shape[0] * gain]  # wh padding\n    if padding:\n        pad[0] /= 2\n        pad[1] /= 2\n    top, left = (int(round(pad[1] - 0.1)), int(round(pad[0] - 0.1))) if padding else (0, 0)  # y, x\n    bottom, right = (int(round(mh - pad[1] + 0.1)), int(round(mw - pad[0] + 0.1)))\n    masks = masks[..., top:bottom, left:right]\n\n    masks = F.interpolate(masks, shape, mode=\"bilinear\", align_corners=False)  # NCHW\n    return masks\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.scale_coords","title":"<code>ultralytics.utils.ops.scale_coords(img1_shape, coords, img0_shape, ratio_pad=None, normalize=False, padding=True)</code>","text":"<p>Rescale segment coordinates (xy) from img1_shape to img0_shape.</p> <p>Parameters:</p> Name Type Description Default <code>img1_shape</code> <code>tuple</code> <p>The shape of the image that the coords are from.</p> required <code>coords</code> <code>Tensor</code> <p>the coords to be scaled of shape n,2.</p> required <code>img0_shape</code> <code>tuple</code> <p>the shape of the image that the segmentation is being applied to.</p> required <code>ratio_pad</code> <code>tuple</code> <p>the ratio of the image size to the padded image size.</p> <code>None</code> <code>normalize</code> <code>bool</code> <p>If True, the coordinates will be normalized to the range [0, 1]. Defaults to False.</p> <code>False</code> <code>padding</code> <code>bool</code> <p>If True, assuming the boxes is based on image augmented by yolo style. If False then do regular rescaling.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>coords</code> <code>Tensor</code> <p>The scaled coordinates.</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def scale_coords(img1_shape, coords, img0_shape, ratio_pad=None, normalize=False, padding=True):\n    \"\"\"\n    Rescale segment coordinates (xy) from img1_shape to img0_shape.\n\n    Args:\n        img1_shape (tuple): The shape of the image that the coords are from.\n        coords (torch.Tensor): the coords to be scaled of shape n,2.\n        img0_shape (tuple): the shape of the image that the segmentation is being applied to.\n        ratio_pad (tuple): the ratio of the image size to the padded image size.\n        normalize (bool): If True, the coordinates will be normalized to the range [0, 1]. Defaults to False.\n        padding (bool): If True, assuming the boxes is based on image augmented by yolo style. If False then do regular\n            rescaling.\n\n    Returns:\n        coords (torch.Tensor): The scaled coordinates.\n    \"\"\"\n    if ratio_pad is None:  # calculate from img0_shape\n        gain = min(img1_shape[0] / img0_shape[0], img1_shape[1] / img0_shape[1])  # gain  = old / new\n        pad = (img1_shape[1] - img0_shape[1] * gain) / 2, (img1_shape[0] - img0_shape[0] * gain) / 2  # wh padding\n    else:\n        gain = ratio_pad[0][0]\n        pad = ratio_pad[1]\n\n    if padding:\n        coords[..., 0] -= pad[0]  # x padding\n        coords[..., 1] -= pad[1]  # y padding\n    coords[..., 0] /= gain\n    coords[..., 1] /= gain\n    coords = clip_coords(coords, img0_shape)\n    if normalize:\n        coords[..., 0] /= img0_shape[1]  # width\n        coords[..., 1] /= img0_shape[0]  # height\n    return coords\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.masks2segments","title":"<code>ultralytics.utils.ops.masks2segments(masks, strategy='largest')</code>","text":"<p>It takes a list of masks(n,h,w) and returns a list of segments(n,xy)</p> <p>Parameters:</p> Name Type Description Default <code>masks</code> <code>Tensor</code> <p>the output of the model, which is a tensor of shape (batch_size, 160, 160)</p> required <code>strategy</code> <code>str</code> <p>'concat' or 'largest'. Defaults to largest</p> <code>'largest'</code> <p>Returns:</p> Name Type Description <code>segments</code> <code>List</code> <p>list of segment masks</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def masks2segments(masks, strategy=\"largest\"):\n    \"\"\"\n    It takes a list of masks(n,h,w) and returns a list of segments(n,xy)\n\n    Args:\n        masks (torch.Tensor): the output of the model, which is a tensor of shape (batch_size, 160, 160)\n        strategy (str): 'concat' or 'largest'. Defaults to largest\n\n    Returns:\n        segments (List): list of segment masks\n    \"\"\"\n    segments = []\n    for x in masks.int().cpu().numpy().astype(\"uint8\"):\n        c = cv2.findContours(x, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)[0]\n        if c:\n            if strategy == \"concat\":  # concatenate all segments\n                c = np.concatenate([x.reshape(-1, 2) for x in c])\n            elif strategy == \"largest\":  # select largest segment\n                c = np.array(c[np.array([len(x) for x in c]).argmax()]).reshape(-1, 2)\n        else:\n            c = np.zeros((0, 2))  # no segments found\n        segments.append(c.astype(\"float32\"))\n    return segments\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.convert_torch2numpy_batch","title":"<code>ultralytics.utils.ops.convert_torch2numpy_batch(batch)</code>","text":"<p>Convert a batch of FP32 torch tensors (0.0-1.0) to a NumPy uint8 array (0-255), changing from BCHW to BHWC layout.</p> <p>Parameters:</p> Name Type Description Default <code>batch</code> <code>Tensor</code> <p>Input tensor batch of shape (Batch, Channels, Height, Width) and dtype torch.float32.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Output NumPy array batch of shape (Batch, Height, Width, Channels) and dtype uint8.</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def convert_torch2numpy_batch(batch: torch.Tensor) -&gt; np.ndarray:\n    \"\"\"\n    Convert a batch of FP32 torch tensors (0.0-1.0) to a NumPy uint8 array (0-255), changing from BCHW to BHWC layout.\n\n    Args:\n        batch (torch.Tensor): Input tensor batch of shape (Batch, Channels, Height, Width) and dtype torch.float32.\n\n    Returns:\n        (np.ndarray): Output NumPy array batch of shape (Batch, Height, Width, Channels) and dtype uint8.\n    \"\"\"\n    return (batch.permute(0, 2, 3, 1).contiguous() * 255).clamp(0, 255).to(torch.uint8).cpu().numpy()\n</code></pre>"},{"location":"reference/utils/ops/#ultralytics.utils.ops.clean_str","title":"<code>ultralytics.utils.ops.clean_str(s)</code>","text":"<p>Cleans a string by replacing special characters with underscore _</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>a string needing special characters replaced</p> required <p>Returns:</p> Type Description <code>str</code> <p>a string with special characters replaced by an underscore _</p> Source code in <code>ultralytics/utils/ops.py</code> <pre><code>def clean_str(s):\n    \"\"\"\n    Cleans a string by replacing special characters with underscore _\n\n    Args:\n        s (str): a string needing special characters replaced\n\n    Returns:\n        (str): a string with special characters replaced by an underscore _\n    \"\"\"\n    return re.sub(pattern=\"[|@#!\u00a1\u00b7$\u20ac%&amp;()=?\u00bf^*;:,\u00a8\u00b4&gt;&lt;+]\", repl=\"_\", string=s)\n</code></pre>"},{"location":"reference/utils/patches/","title":"Reference for <code>ultralytics/utils/patches.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/patches.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/patches/#ultralytics.utils.patches.imread","title":"<code>ultralytics.utils.patches.imread(filename, flags=cv2.IMREAD_COLOR)</code>","text":"<p>Read an image from a file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the file to read.</p> required <code>flags</code> <code>int</code> <p>Flag that can take values of cv2.IMREAD_*. Defaults to cv2.IMREAD_COLOR.</p> <code>IMREAD_COLOR</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The read image.</p> Source code in <code>ultralytics/utils/patches.py</code> <pre><code>def imread(filename: str, flags: int = cv2.IMREAD_COLOR):\n    \"\"\"\n    Read an image from a file.\n\n    Args:\n        filename (str): Path to the file to read.\n        flags (int, optional): Flag that can take values of cv2.IMREAD_*. Defaults to cv2.IMREAD_COLOR.\n\n    Returns:\n        (np.ndarray): The read image.\n    \"\"\"\n    return cv2.imdecode(np.fromfile(filename, np.uint8), flags)\n</code></pre>"},{"location":"reference/utils/patches/#ultralytics.utils.patches.imwrite","title":"<code>ultralytics.utils.patches.imwrite(filename, img, params=None)</code>","text":"<p>Write an image to a file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the file to write.</p> required <code>img</code> <code>ndarray</code> <p>Image to write.</p> required <code>params</code> <code>list of ints</code> <p>Additional parameters. See OpenCV documentation.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the file was written, False otherwise.</p> Source code in <code>ultralytics/utils/patches.py</code> <pre><code>def imwrite(filename: str, img: np.ndarray, params=None):\n    \"\"\"\n    Write an image to a file.\n\n    Args:\n        filename (str): Path to the file to write.\n        img (np.ndarray): Image to write.\n        params (list of ints, optional): Additional parameters. See OpenCV documentation.\n\n    Returns:\n        (bool): True if the file was written, False otherwise.\n    \"\"\"\n    try:\n        cv2.imencode(Path(filename).suffix, img, params)[1].tofile(filename)\n        return True\n    except Exception:\n        return False\n</code></pre>"},{"location":"reference/utils/patches/#ultralytics.utils.patches.imshow","title":"<code>ultralytics.utils.patches.imshow(winname, mat)</code>","text":"<p>Displays an image in the specified window.</p> <p>Parameters:</p> Name Type Description Default <code>winname</code> <code>str</code> <p>Name of the window.</p> required <code>mat</code> <code>ndarray</code> <p>Image to be shown.</p> required Source code in <code>ultralytics/utils/patches.py</code> <pre><code>def imshow(winname: str, mat: np.ndarray):\n    \"\"\"\n    Displays an image in the specified window.\n\n    Args:\n        winname (str): Name of the window.\n        mat (np.ndarray): Image to be shown.\n    \"\"\"\n    _imshow(winname.encode(\"unicode_escape\").decode(), mat)\n</code></pre>"},{"location":"reference/utils/patches/#ultralytics.utils.patches.torch_save","title":"<code>ultralytics.utils.patches.torch_save(*args, **kwargs)</code>","text":"<p>Use dill (if exists) to serialize the lambda functions where pickle does not do this.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>tuple</code> <p>Positional arguments to pass to torch.save.</p> <code>()</code> <code>**kwargs</code> <code>dict</code> <p>Keyword arguments to pass to torch.save.</p> <code>{}</code> Source code in <code>ultralytics/utils/patches.py</code> <pre><code>def torch_save(*args, **kwargs):\n    \"\"\"\n    Use dill (if exists) to serialize the lambda functions where pickle does not do this.\n\n    Args:\n        *args (tuple): Positional arguments to pass to torch.save.\n        **kwargs (dict): Keyword arguments to pass to torch.save.\n    \"\"\"\n    try:\n        import dill as pickle  # noqa\n    except ImportError:\n        import pickle\n\n    if \"pickle_module\" not in kwargs:\n        kwargs[\"pickle_module\"] = pickle  # noqa\n    return _torch_save(*args, **kwargs)\n</code></pre>"},{"location":"reference/utils/plotting/","title":"Reference for <code>ultralytics/utils/plotting.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/plotting.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.Colors","title":"<code>ultralytics.utils.plotting.Colors</code>","text":"<p>Ultralytics default color palette https://ultralytics.com/.</p> <p>This class provides methods to work with the Ultralytics color palette, including converting hex color codes to RGB values.</p> <p>Attributes:</p> Name Type Description <code>palette</code> <code>list of tuple</code> <p>List of RGB color values.</p> <code>n</code> <code>int</code> <p>The number of colors in the palette.</p> <code>pose_palette</code> <code>array</code> <p>A specific color palette array with dtype np.uint8.</p> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>class Colors:\n    \"\"\"\n    Ultralytics default color palette https://ultralytics.com/.\n\n    This class provides methods to work with the Ultralytics color palette, including converting hex color codes to\n    RGB values.\n\n    Attributes:\n        palette (list of tuple): List of RGB color values.\n        n (int): The number of colors in the palette.\n        pose_palette (np.array): A specific color palette array with dtype np.uint8.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize colors as hex = matplotlib.colors.TABLEAU_COLORS.values().\"\"\"\n        hexs = (\n            \"FF3838\",\n            \"FF9D97\",\n            \"FF701F\",\n            \"FFB21D\",\n            \"CFD231\",\n            \"48F90A\",\n            \"92CC17\",\n            \"3DDB86\",\n            \"1A9334\",\n            \"00D4BB\",\n            \"2C99A8\",\n            \"00C2FF\",\n            \"344593\",\n            \"6473FF\",\n            \"0018EC\",\n            \"8438FF\",\n            \"520085\",\n            \"CB38FF\",\n            \"FF95C8\",\n            \"FF37C7\",\n        )\n        self.palette = [self.hex2rgb(f\"#{c}\") for c in hexs]\n        self.n = len(self.palette)\n        self.pose_palette = np.array(\n            [\n                [255, 128, 0],\n                [255, 153, 51],\n                [255, 178, 102],\n                [230, 230, 0],\n                [255, 153, 255],\n                [153, 204, 255],\n                [255, 102, 255],\n                [255, 51, 255],\n                [102, 178, 255],\n                [51, 153, 255],\n                [255, 153, 153],\n                [255, 102, 102],\n                [255, 51, 51],\n                [153, 255, 153],\n                [102, 255, 102],\n                [51, 255, 51],\n                [0, 255, 0],\n                [0, 0, 255],\n                [255, 0, 0],\n                [255, 255, 255],\n            ],\n            dtype=np.uint8,\n        )\n\n    def __call__(self, i, bgr=False):\n        \"\"\"Converts hex color codes to RGB values.\"\"\"\n        c = self.palette[int(i) % self.n]\n        return (c[2], c[1], c[0]) if bgr else c\n\n    @staticmethod\n    def hex2rgb(h):\n        \"\"\"Converts hex color codes to RGB values (i.e. default PIL order).\"\"\"\n        return tuple(int(h[1 + i : 1 + i + 2], 16) for i in (0, 2, 4))\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.Colors.__call__","title":"<code>__call__(i, bgr=False)</code>","text":"<p>Converts hex color codes to RGB values.</p> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>def __call__(self, i, bgr=False):\n    \"\"\"Converts hex color codes to RGB values.\"\"\"\n    c = self.palette[int(i) % self.n]\n    return (c[2], c[1], c[0]) if bgr else c\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.Colors.__init__","title":"<code>__init__()</code>","text":"<p>Initialize colors as hex = matplotlib.colors.TABLEAU_COLORS.values().</p> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize colors as hex = matplotlib.colors.TABLEAU_COLORS.values().\"\"\"\n    hexs = (\n        \"FF3838\",\n        \"FF9D97\",\n        \"FF701F\",\n        \"FFB21D\",\n        \"CFD231\",\n        \"48F90A\",\n        \"92CC17\",\n        \"3DDB86\",\n        \"1A9334\",\n        \"00D4BB\",\n        \"2C99A8\",\n        \"00C2FF\",\n        \"344593\",\n        \"6473FF\",\n        \"0018EC\",\n        \"8438FF\",\n        \"520085\",\n        \"CB38FF\",\n        \"FF95C8\",\n        \"FF37C7\",\n    )\n    self.palette = [self.hex2rgb(f\"#{c}\") for c in hexs]\n    self.n = len(self.palette)\n    self.pose_palette = np.array(\n        [\n            [255, 128, 0],\n            [255, 153, 51],\n            [255, 178, 102],\n            [230, 230, 0],\n            [255, 153, 255],\n            [153, 204, 255],\n            [255, 102, 255],\n            [255, 51, 255],\n            [102, 178, 255],\n            [51, 153, 255],\n            [255, 153, 153],\n            [255, 102, 102],\n            [255, 51, 51],\n            [153, 255, 153],\n            [102, 255, 102],\n            [51, 255, 51],\n            [0, 255, 0],\n            [0, 0, 255],\n            [255, 0, 0],\n            [255, 255, 255],\n        ],\n        dtype=np.uint8,\n    )\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.Colors.hex2rgb","title":"<code>hex2rgb(h)</code>  <code>staticmethod</code>","text":"<p>Converts hex color codes to RGB values (i.e. default PIL order).</p> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>@staticmethod\ndef hex2rgb(h):\n    \"\"\"Converts hex color codes to RGB values (i.e. default PIL order).\"\"\"\n    return tuple(int(h[1 + i : 1 + i + 2], 16) for i in (0, 2, 4))\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.Annotator","title":"<code>ultralytics.utils.plotting.Annotator</code>","text":"<p>Ultralytics Annotator for train/val mosaics and JPGs and predictions annotations.</p> <p>Attributes:</p> Name Type Description <code>im</code> <code>Image.Image or numpy array</code> <p>The image to annotate.</p> <code>pil</code> <code>bool</code> <p>Whether to use PIL or cv2 for drawing annotations.</p> <code>font</code> <code>truetype or load_default</code> <p>Font used for text annotations.</p> <code>lw</code> <code>float</code> <p>Line width for drawing.</p> <code>skeleton</code> <code>List[List[int]]</code> <p>Skeleton structure for keypoints.</p> <code>limb_color</code> <code>List[int]</code> <p>Color palette for limbs.</p> <code>kpt_color</code> <code>List[int]</code> <p>Color palette for keypoints.</p> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>class Annotator:\n    \"\"\"\n    Ultralytics Annotator for train/val mosaics and JPGs and predictions annotations.\n\n    Attributes:\n        im (Image.Image or numpy array): The image to annotate.\n        pil (bool): Whether to use PIL or cv2 for drawing annotations.\n        font (ImageFont.truetype or ImageFont.load_default): Font used for text annotations.\n        lw (float): Line width for drawing.\n        skeleton (List[List[int]]): Skeleton structure for keypoints.\n        limb_color (List[int]): Color palette for limbs.\n        kpt_color (List[int]): Color palette for keypoints.\n    \"\"\"\n\n    def __init__(self, im, line_width=None, font_size=None, font=\"Arial.ttf\", pil=False, example=\"abc\"):\n        \"\"\"Initialize the Annotator class with image and line width along with color palette for keypoints and limbs.\"\"\"\n        assert im.data.contiguous, \"Image not contiguous. Apply np.ascontiguousarray(im) to Annotator() input images.\"\n        non_ascii = not is_ascii(example)  # non-latin labels, i.e. asian, arabic, cyrillic\n        self.pil = pil or non_ascii\n        self.lw = line_width or max(round(sum(im.shape) / 2 * 0.003), 2)  # line width\n        if self.pil:  # use PIL\n            self.im = im if isinstance(im, Image.Image) else Image.fromarray(im)\n            self.draw = ImageDraw.Draw(self.im)\n            try:\n                font = check_font(\"Arial.Unicode.ttf\" if non_ascii else font)\n                size = font_size or max(round(sum(self.im.size) / 2 * 0.035), 12)\n                self.font = ImageFont.truetype(str(font), size)\n            except Exception:\n                self.font = ImageFont.load_default()\n            # Deprecation fix for w, h = getsize(string) -&gt; _, _, w, h = getbox(string)\n            if check_version(pil_version, \"9.2.0\"):\n                self.font.getsize = lambda x: self.font.getbbox(x)[2:4]  # text width, height\n        else:  # use cv2\n            self.im = im if im.flags.writeable else im.copy()\n            self.tf = max(self.lw - 1, 1)  # font thickness\n            self.sf = self.lw / 3  # font scale\n        # Pose\n        self.skeleton = [\n            [16, 14],\n            [14, 12],\n            [17, 15],\n            [15, 13],\n            [12, 13],\n            [6, 12],\n            [7, 13],\n            [6, 7],\n            [6, 8],\n            [7, 9],\n            [8, 10],\n            [9, 11],\n            [2, 3],\n            [1, 2],\n            [1, 3],\n            [2, 4],\n            [3, 5],\n            [4, 6],\n            [5, 7],\n        ]\n\n        self.limb_color = colors.pose_palette[[9, 9, 9, 9, 7, 7, 7, 0, 0, 0, 0, 0, 16, 16, 16, 16, 16, 16, 16]]\n        self.kpt_color = colors.pose_palette[[16, 16, 16, 16, 16, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9]]\n\n    def box_label(self, box, label=\"\", color=(128, 128, 128), txt_color=(255, 255, 255), rotated=False):\n        \"\"\"Add one xyxy box to image with label.\"\"\"\n        if isinstance(box, torch.Tensor):\n            box = box.tolist()\n        if self.pil or not is_ascii(label):\n            if rotated:\n                p1 = box[0]\n                # NOTE: PIL-version polygon needs tuple type.\n                self.draw.polygon([tuple(b) for b in box], width=self.lw, outline=color)\n            else:\n                p1 = (box[0], box[1])\n                self.draw.rectangle(box, width=self.lw, outline=color)  # box\n            if label:\n                w, h = self.font.getsize(label)  # text width, height\n                outside = p1[1] - h &gt;= 0  # label fits outside box\n                self.draw.rectangle(\n                    (p1[0], p1[1] - h if outside else p1[1], p1[0] + w + 1, p1[1] + 1 if outside else p1[1] + h + 1),\n                    fill=color,\n                )\n                # self.draw.text((box[0], box[1]), label, fill=txt_color, font=self.font, anchor='ls')  # for PIL&gt;8.0\n                self.draw.text((p1[0], p1[1] - h if outside else p1[1]), label, fill=txt_color, font=self.font)\n        else:  # cv2\n            if rotated:\n                p1 = [int(b) for b in box[0]]\n                # NOTE: cv2-version polylines needs np.asarray type.\n                cv2.polylines(self.im, [np.asarray(box, dtype=int)], True, color, self.lw)\n            else:\n                p1, p2 = (int(box[0]), int(box[1])), (int(box[2]), int(box[3]))\n                cv2.rectangle(self.im, p1, p2, color, thickness=self.lw, lineType=cv2.LINE_AA)\n            if label:\n                w, h = cv2.getTextSize(label, 0, fontScale=self.sf, thickness=self.tf)[0]  # text width, height\n                outside = p1[1] - h &gt;= 3\n                p2 = p1[0] + w, p1[1] - h - 3 if outside else p1[1] + h + 3\n                cv2.rectangle(self.im, p1, p2, color, -1, cv2.LINE_AA)  # filled\n                cv2.putText(\n                    self.im,\n                    label,\n                    (p1[0], p1[1] - 2 if outside else p1[1] + h + 2),\n                    0,\n                    self.sf,\n                    txt_color,\n                    thickness=self.tf,\n                    lineType=cv2.LINE_AA,\n                )\n\n    def masks(self, masks, colors, im_gpu, alpha=0.5, retina_masks=False):\n        \"\"\"\n        Plot masks on image.\n\n        Args:\n            masks (tensor): Predicted masks on cuda, shape: [n, h, w]\n            colors (List[List[Int]]): Colors for predicted masks, [[r, g, b] * n]\n            im_gpu (tensor): Image is in cuda, shape: [3, h, w], range: [0, 1]\n            alpha (float): Mask transparency: 0.0 fully transparent, 1.0 opaque\n            retina_masks (bool): Whether to use high resolution masks or not. Defaults to False.\n        \"\"\"\n        if self.pil:\n            # Convert to numpy first\n            self.im = np.asarray(self.im).copy()\n        if len(masks) == 0:\n            self.im[:] = im_gpu.permute(1, 2, 0).contiguous().cpu().numpy() * 255\n        if im_gpu.device != masks.device:\n            im_gpu = im_gpu.to(masks.device)\n        colors = torch.tensor(colors, device=masks.device, dtype=torch.float32) / 255.0  # shape(n,3)\n        colors = colors[:, None, None]  # shape(n,1,1,3)\n        masks = masks.unsqueeze(3)  # shape(n,h,w,1)\n        masks_color = masks * (colors * alpha)  # shape(n,h,w,3)\n\n        inv_alpha_masks = (1 - masks * alpha).cumprod(0)  # shape(n,h,w,1)\n        mcs = masks_color.max(dim=0).values  # shape(n,h,w,3)\n\n        im_gpu = im_gpu.flip(dims=[0])  # flip channel\n        im_gpu = im_gpu.permute(1, 2, 0).contiguous()  # shape(h,w,3)\n        im_gpu = im_gpu * inv_alpha_masks[-1] + mcs\n        im_mask = im_gpu * 255\n        im_mask_np = im_mask.byte().cpu().numpy()\n        self.im[:] = im_mask_np if retina_masks else ops.scale_image(im_mask_np, self.im.shape)\n        if self.pil:\n            # Convert im back to PIL and update draw\n            self.fromarray(self.im)\n\n    def kpts(self, kpts, shape=(640, 640), radius=5, kpt_line=True):\n        \"\"\"\n        Plot keypoints on the image.\n\n        Args:\n            kpts (tensor): Predicted keypoints with shape [17, 3]. Each keypoint has (x, y, confidence).\n            shape (tuple): Image shape as a tuple (h, w), where h is the height and w is the width.\n            radius (int, optional): Radius of the drawn keypoints. Default is 5.\n            kpt_line (bool, optional): If True, the function will draw lines connecting keypoints\n                                       for human pose. Default is True.\n\n        Note: `kpt_line=True` currently only supports human pose plotting.\n        \"\"\"\n        if self.pil:\n            # Convert to numpy first\n            self.im = np.asarray(self.im).copy()\n        nkpt, ndim = kpts.shape\n        is_pose = nkpt == 17 and ndim == 3\n        kpt_line &amp;= is_pose  # `kpt_line=True` for now only supports human pose plotting\n        for i, k in enumerate(kpts):\n            color_k = [int(x) for x in self.kpt_color[i]] if is_pose else colors(i)\n            x_coord, y_coord = k[0], k[1]\n            if x_coord % shape[1] != 0 and y_coord % shape[0] != 0:\n                if len(k) == 3:\n                    conf = k[2]\n                    if conf &lt; 0.5:\n                        continue\n                cv2.circle(self.im, (int(x_coord), int(y_coord)), radius, color_k, -1, lineType=cv2.LINE_AA)\n\n        if kpt_line:\n            ndim = kpts.shape[-1]\n            for i, sk in enumerate(self.skeleton):\n                pos1 = (int(kpts[(sk[0] - 1), 0]), int(kpts[(sk[0] - 1), 1]))\n                pos2 = (int(kpts[(sk[1] - 1), 0]), int(kpts[(sk[1] - 1), 1]))\n                if ndim == 3:\n                    conf1 = kpts[(sk[0] - 1), 2]\n                    conf2 = kpts[(sk[1] - 1), 2]\n                    if conf1 &lt; 0.5 or conf2 &lt; 0.5:\n                        continue\n                if pos1[0] % shape[1] == 0 or pos1[1] % shape[0] == 0 or pos1[0] &lt; 0 or pos1[1] &lt; 0:\n                    continue\n                if pos2[0] % shape[1] == 0 or pos2[1] % shape[0] == 0 or pos2[0] &lt; 0 or pos2[1] &lt; 0:\n                    continue\n                cv2.line(self.im, pos1, pos2, [int(x) for x in self.limb_color[i]], thickness=2, lineType=cv2.LINE_AA)\n        if self.pil:\n            # Convert im back to PIL and update draw\n            self.fromarray(self.im)\n\n    def rectangle(self, xy, fill=None, outline=None, width=1):\n        \"\"\"Add rectangle to image (PIL-only).\"\"\"\n        self.draw.rectangle(xy, fill, outline, width)\n\n    def text(self, xy, text, txt_color=(255, 255, 255), anchor=\"top\", box_style=False):\n        \"\"\"Adds text to an image using PIL or cv2.\"\"\"\n        if anchor == \"bottom\":  # start y from font bottom\n            w, h = self.font.getsize(text)  # text width, height\n            xy[1] += 1 - h\n        if self.pil:\n            if box_style:\n                w, h = self.font.getsize(text)\n                self.draw.rectangle((xy[0], xy[1], xy[0] + w + 1, xy[1] + h + 1), fill=txt_color)\n                # Using `txt_color` for background and draw fg with white color\n                txt_color = (255, 255, 255)\n            if \"\\n\" in text:\n                lines = text.split(\"\\n\")\n                _, h = self.font.getsize(text)\n                for line in lines:\n                    self.draw.text(xy, line, fill=txt_color, font=self.font)\n                    xy[1] += h\n            else:\n                self.draw.text(xy, text, fill=txt_color, font=self.font)\n        else:\n            if box_style:\n                w, h = cv2.getTextSize(text, 0, fontScale=self.sf, thickness=self.tf)[0]  # text width, height\n                outside = xy[1] - h &gt;= 3\n                p2 = xy[0] + w, xy[1] - h - 3 if outside else xy[1] + h + 3\n                cv2.rectangle(self.im, xy, p2, txt_color, -1, cv2.LINE_AA)  # filled\n                # Using `txt_color` for background and draw fg with white color\n                txt_color = (255, 255, 255)\n            cv2.putText(self.im, text, xy, 0, self.sf, txt_color, thickness=self.tf, lineType=cv2.LINE_AA)\n\n    def fromarray(self, im):\n        \"\"\"Update self.im from a numpy array.\"\"\"\n        self.im = im if isinstance(im, Image.Image) else Image.fromarray(im)\n        self.draw = ImageDraw.Draw(self.im)\n\n    def result(self):\n        \"\"\"Return annotated image as array.\"\"\"\n        return np.asarray(self.im)\n\n    # Object Counting Annotator\n    def draw_region(self, reg_pts=None, color=(0, 255, 0), thickness=5):\n        \"\"\"\n        Draw region line\n        Args:\n            reg_pts (list): Region Points (for line 2 points, for region 4 points)\n            color (tuple): Region Color value\n            thickness (int): Region area thickness value\n        \"\"\"\n        cv2.polylines(self.im, [np.array(reg_pts, dtype=np.int32)], isClosed=True, color=color, thickness=thickness)\n\n    def draw_centroid_and_tracks(self, track, color=(255, 0, 255), track_thickness=2):\n        \"\"\"\n        Draw centroid point and track trails\n        Args:\n            track (list): object tracking points for trails display\n            color (tuple): tracks line color\n            track_thickness (int): track line thickness value\n        \"\"\"\n        points = np.hstack(track).astype(np.int32).reshape((-1, 1, 2))\n        cv2.polylines(self.im, [points], isClosed=False, color=color, thickness=track_thickness)\n        cv2.circle(self.im, (int(track[-1][0]), int(track[-1][1])), track_thickness * 2, color, -1)\n\n    def count_labels(self, counts=0, count_txt_size=2, color=(255, 255, 255), txt_color=(0, 0, 0)):\n        \"\"\"\n        Plot counts for object counter\n        Args:\n            counts (int): objects counts value\n            count_txt_size (int): text size for counts display\n            color (tuple): background color of counts display\n            txt_color (tuple): text color of counts display\n        \"\"\"\n        self.tf = count_txt_size\n        tl = self.tf or round(0.002 * (self.im.shape[0] + self.im.shape[1]) / 2) + 1\n        tf = max(tl - 1, 1)\n        gap = int(24 * tl)  # gap between in_count and out_count based on line_thickness\n\n        # Get text size for in_count and out_count\n        t_size_in = cv2.getTextSize(str(counts), 0, fontScale=tl / 2, thickness=tf)[0]\n\n        # Calculate positions for counts label\n        text_width = t_size_in[0]\n        text_x = (self.im.shape[1] - text_width) // 2  # Center x-coordinate\n        text_y = t_size_in[1]\n\n        # Create a rounded rectangle for in_count\n        cv2.rectangle(\n            self.im, (text_x - 5, text_y - 5), (text_x + text_width + 7, text_y + t_size_in[1] + 7), color, -1\n        )\n        cv2.putText(\n            self.im, str(counts), (text_x, text_y + t_size_in[1]), 0, tl / 2, txt_color, self.tf, lineType=cv2.LINE_AA\n        )\n\n    @staticmethod\n    def estimate_pose_angle(a, b, c):\n        \"\"\"Calculate the pose angle for object\n        Args:\n            a (float) : The value of pose point a\n            b (float): The value of pose point b\n            c (float): The value o pose point c\n        Returns:\n            angle (degree): Degree value of angle between three points\n        \"\"\"\n        a, b, c = np.array(a), np.array(b), np.array(c)\n        radians = np.arctan2(c[1] - b[1], c[0] - b[0]) - np.arctan2(a[1] - b[1], a[0] - b[0])\n        angle = np.abs(radians * 180.0 / np.pi)\n        if angle &gt; 180.0:\n            angle = 360 - angle\n        return angle\n\n    def draw_specific_points(self, keypoints, indices=[2, 5, 7], shape=(640, 640), radius=2):\n        \"\"\"\n        Draw specific keypoints for gym steps counting.\n\n        Args:\n            keypoints (list): list of keypoints data to be plotted\n            indices (list): keypoints ids list to be plotted\n            shape (tuple): imgsz for model inference\n            radius (int): Keypoint radius value\n        \"\"\"\n        nkpts, ndim = keypoints.shape\n        nkpts == 17 and ndim == 3\n        for i, k in enumerate(keypoints):\n            if i in indices:\n                x_coord, y_coord = k[0], k[1]\n                if x_coord % shape[1] != 0 and y_coord % shape[0] != 0:\n                    if len(k) == 3:\n                        conf = k[2]\n                        if conf &lt; 0.5:\n                            continue\n                    cv2.circle(self.im, (int(x_coord), int(y_coord)), radius, (0, 255, 0), -1, lineType=cv2.LINE_AA)\n        return self.im\n\n    def plot_angle_and_count_and_stage(self, angle_text, count_text, stage_text, center_kpt, line_thickness=2):\n        \"\"\"\n        Plot the pose angle, count value and step stage.\n\n        Args:\n            angle_text (str): angle value for workout monitoring\n            count_text (str): counts value for workout monitoring\n            stage_text (str): stage decision for workout monitoring\n            center_kpt (int): centroid pose index for workout monitoring\n            line_thickness (int): thickness for text display\n        \"\"\"\n        angle_text, count_text, stage_text = (f\" {angle_text:.2f}\", \"Steps : \" + f\"{count_text}\", f\" {stage_text}\")\n        font_scale = 0.6 + (line_thickness / 10.0)\n\n        # Draw angle\n        (angle_text_width, angle_text_height), _ = cv2.getTextSize(angle_text, 0, font_scale, line_thickness)\n        angle_text_position = (int(center_kpt[0]), int(center_kpt[1]))\n        angle_background_position = (angle_text_position[0], angle_text_position[1] - angle_text_height - 5)\n        angle_background_size = (angle_text_width + 2 * 5, angle_text_height + 2 * 5 + (line_thickness * 2))\n        cv2.rectangle(\n            self.im,\n            angle_background_position,\n            (\n                angle_background_position[0] + angle_background_size[0],\n                angle_background_position[1] + angle_background_size[1],\n            ),\n            (255, 255, 255),\n            -1,\n        )\n        cv2.putText(self.im, angle_text, angle_text_position, 0, font_scale, (0, 0, 0), line_thickness)\n\n        # Draw Counts\n        (count_text_width, count_text_height), _ = cv2.getTextSize(count_text, 0, font_scale, line_thickness)\n        count_text_position = (angle_text_position[0], angle_text_position[1] + angle_text_height + 20)\n        count_background_position = (\n            angle_background_position[0],\n            angle_background_position[1] + angle_background_size[1] + 5,\n        )\n        count_background_size = (count_text_width + 10, count_text_height + 10 + (line_thickness * 2))\n\n        cv2.rectangle(\n            self.im,\n            count_background_position,\n            (\n                count_background_position[0] + count_background_size[0],\n                count_background_position[1] + count_background_size[1],\n            ),\n            (255, 255, 255),\n            -1,\n        )\n        cv2.putText(self.im, count_text, count_text_position, 0, font_scale, (0, 0, 0), line_thickness)\n\n        # Draw Stage\n        (stage_text_width, stage_text_height), _ = cv2.getTextSize(stage_text, 0, font_scale, line_thickness)\n        stage_text_position = (int(center_kpt[0]), int(center_kpt[1]) + angle_text_height + count_text_height + 40)\n        stage_background_position = (stage_text_position[0], stage_text_position[1] - stage_text_height - 5)\n        stage_background_size = (stage_text_width + 10, stage_text_height + 10)\n\n        cv2.rectangle(\n            self.im,\n            stage_background_position,\n            (\n                stage_background_position[0] + stage_background_size[0],\n                stage_background_position[1] + stage_background_size[1],\n            ),\n            (255, 255, 255),\n            -1,\n        )\n        cv2.putText(self.im, stage_text, stage_text_position, 0, font_scale, (0, 0, 0), line_thickness)\n\n    def seg_bbox(self, mask, mask_color=(255, 0, 255), det_label=None, track_label=None):\n        \"\"\"\n        Function for drawing segmented object in bounding box shape.\n\n        Args:\n            mask (list): masks data list for instance segmentation area plotting\n            mask_color (tuple): mask foreground color\n            det_label (str): Detection label text\n            track_label (str): Tracking label text\n        \"\"\"\n        cv2.polylines(self.im, [np.int32([mask])], isClosed=True, color=mask_color, thickness=2)\n\n        label = f\"Track ID: {track_label}\" if track_label else det_label\n        text_size, _ = cv2.getTextSize(label, 0, 0.7, 1)\n\n        cv2.rectangle(\n            self.im,\n            (int(mask[0][0]) - text_size[0] // 2 - 10, int(mask[0][1]) - text_size[1] - 10),\n            (int(mask[0][0]) + text_size[0] // 2 + 5, int(mask[0][1] + 5)),\n            mask_color,\n            -1,\n        )\n\n        cv2.putText(\n            self.im, label, (int(mask[0][0]) - text_size[0] // 2, int(mask[0][1]) - 5), 0, 0.7, (255, 255, 255), 2\n        )\n\n    def visioneye(self, box, center_point, color=(235, 219, 11), pin_color=(255, 0, 255), thickness=2, pins_radius=10):\n        \"\"\"\n        Function for pinpoint human-vision eye mapping and plotting.\n\n        Args:\n            box (list): Bounding box coordinates\n            center_point (tuple): center point for vision eye view\n            color (tuple): object centroid and line color value\n            pin_color (tuple): visioneye point color value\n            thickness (int): int value for line thickness\n            pins_radius (int): visioneye point radius value\n        \"\"\"\n        center_bbox = int((box[0] + box[2]) / 2), int((box[1] + box[3]) / 2)\n        cv2.circle(self.im, center_point, pins_radius, pin_color, -1)\n        cv2.circle(self.im, center_bbox, pins_radius, color, -1)\n        cv2.line(self.im, center_point, center_bbox, color, thickness)\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.Annotator.__init__","title":"<code>__init__(im, line_width=None, font_size=None, font='Arial.ttf', pil=False, example='abc')</code>","text":"<p>Initialize the Annotator class with image and line width along with color palette for keypoints and limbs.</p> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>def __init__(self, im, line_width=None, font_size=None, font=\"Arial.ttf\", pil=False, example=\"abc\"):\n    \"\"\"Initialize the Annotator class with image and line width along with color palette for keypoints and limbs.\"\"\"\n    assert im.data.contiguous, \"Image not contiguous. Apply np.ascontiguousarray(im) to Annotator() input images.\"\n    non_ascii = not is_ascii(example)  # non-latin labels, i.e. asian, arabic, cyrillic\n    self.pil = pil or non_ascii\n    self.lw = line_width or max(round(sum(im.shape) / 2 * 0.003), 2)  # line width\n    if self.pil:  # use PIL\n        self.im = im if isinstance(im, Image.Image) else Image.fromarray(im)\n        self.draw = ImageDraw.Draw(self.im)\n        try:\n            font = check_font(\"Arial.Unicode.ttf\" if non_ascii else font)\n            size = font_size or max(round(sum(self.im.size) / 2 * 0.035), 12)\n            self.font = ImageFont.truetype(str(font), size)\n        except Exception:\n            self.font = ImageFont.load_default()\n        # Deprecation fix for w, h = getsize(string) -&gt; _, _, w, h = getbox(string)\n        if check_version(pil_version, \"9.2.0\"):\n            self.font.getsize = lambda x: self.font.getbbox(x)[2:4]  # text width, height\n    else:  # use cv2\n        self.im = im if im.flags.writeable else im.copy()\n        self.tf = max(self.lw - 1, 1)  # font thickness\n        self.sf = self.lw / 3  # font scale\n    # Pose\n    self.skeleton = [\n        [16, 14],\n        [14, 12],\n        [17, 15],\n        [15, 13],\n        [12, 13],\n        [6, 12],\n        [7, 13],\n        [6, 7],\n        [6, 8],\n        [7, 9],\n        [8, 10],\n        [9, 11],\n        [2, 3],\n        [1, 2],\n        [1, 3],\n        [2, 4],\n        [3, 5],\n        [4, 6],\n        [5, 7],\n    ]\n\n    self.limb_color = colors.pose_palette[[9, 9, 9, 9, 7, 7, 7, 0, 0, 0, 0, 0, 16, 16, 16, 16, 16, 16, 16]]\n    self.kpt_color = colors.pose_palette[[16, 16, 16, 16, 16, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9, 9, 9]]\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.Annotator.box_label","title":"<code>box_label(box, label='', color=(128, 128, 128), txt_color=(255, 255, 255), rotated=False)</code>","text":"<p>Add one xyxy box to image with label.</p> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>def box_label(self, box, label=\"\", color=(128, 128, 128), txt_color=(255, 255, 255), rotated=False):\n    \"\"\"Add one xyxy box to image with label.\"\"\"\n    if isinstance(box, torch.Tensor):\n        box = box.tolist()\n    if self.pil or not is_ascii(label):\n        if rotated:\n            p1 = box[0]\n            # NOTE: PIL-version polygon needs tuple type.\n            self.draw.polygon([tuple(b) for b in box], width=self.lw, outline=color)\n        else:\n            p1 = (box[0], box[1])\n            self.draw.rectangle(box, width=self.lw, outline=color)  # box\n        if label:\n            w, h = self.font.getsize(label)  # text width, height\n            outside = p1[1] - h &gt;= 0  # label fits outside box\n            self.draw.rectangle(\n                (p1[0], p1[1] - h if outside else p1[1], p1[0] + w + 1, p1[1] + 1 if outside else p1[1] + h + 1),\n                fill=color,\n            )\n            # self.draw.text((box[0], box[1]), label, fill=txt_color, font=self.font, anchor='ls')  # for PIL&gt;8.0\n            self.draw.text((p1[0], p1[1] - h if outside else p1[1]), label, fill=txt_color, font=self.font)\n    else:  # cv2\n        if rotated:\n            p1 = [int(b) for b in box[0]]\n            # NOTE: cv2-version polylines needs np.asarray type.\n            cv2.polylines(self.im, [np.asarray(box, dtype=int)], True, color, self.lw)\n        else:\n            p1, p2 = (int(box[0]), int(box[1])), (int(box[2]), int(box[3]))\n            cv2.rectangle(self.im, p1, p2, color, thickness=self.lw, lineType=cv2.LINE_AA)\n        if label:\n            w, h = cv2.getTextSize(label, 0, fontScale=self.sf, thickness=self.tf)[0]  # text width, height\n            outside = p1[1] - h &gt;= 3\n            p2 = p1[0] + w, p1[1] - h - 3 if outside else p1[1] + h + 3\n            cv2.rectangle(self.im, p1, p2, color, -1, cv2.LINE_AA)  # filled\n            cv2.putText(\n                self.im,\n                label,\n                (p1[0], p1[1] - 2 if outside else p1[1] + h + 2),\n                0,\n                self.sf,\n                txt_color,\n                thickness=self.tf,\n                lineType=cv2.LINE_AA,\n            )\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.Annotator.count_labels","title":"<code>count_labels(counts=0, count_txt_size=2, color=(255, 255, 255), txt_color=(0, 0, 0))</code>","text":"<p>Plot counts for object counter Args:     counts (int): objects counts value     count_txt_size (int): text size for counts display     color (tuple): background color of counts display     txt_color (tuple): text color of counts display</p> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>def count_labels(self, counts=0, count_txt_size=2, color=(255, 255, 255), txt_color=(0, 0, 0)):\n    \"\"\"\n    Plot counts for object counter\n    Args:\n        counts (int): objects counts value\n        count_txt_size (int): text size for counts display\n        color (tuple): background color of counts display\n        txt_color (tuple): text color of counts display\n    \"\"\"\n    self.tf = count_txt_size\n    tl = self.tf or round(0.002 * (self.im.shape[0] + self.im.shape[1]) / 2) + 1\n    tf = max(tl - 1, 1)\n    gap = int(24 * tl)  # gap between in_count and out_count based on line_thickness\n\n    # Get text size for in_count and out_count\n    t_size_in = cv2.getTextSize(str(counts), 0, fontScale=tl / 2, thickness=tf)[0]\n\n    # Calculate positions for counts label\n    text_width = t_size_in[0]\n    text_x = (self.im.shape[1] - text_width) // 2  # Center x-coordinate\n    text_y = t_size_in[1]\n\n    # Create a rounded rectangle for in_count\n    cv2.rectangle(\n        self.im, (text_x - 5, text_y - 5), (text_x + text_width + 7, text_y + t_size_in[1] + 7), color, -1\n    )\n    cv2.putText(\n        self.im, str(counts), (text_x, text_y + t_size_in[1]), 0, tl / 2, txt_color, self.tf, lineType=cv2.LINE_AA\n    )\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.Annotator.draw_centroid_and_tracks","title":"<code>draw_centroid_and_tracks(track, color=(255, 0, 255), track_thickness=2)</code>","text":"<p>Draw centroid point and track trails Args:     track (list): object tracking points for trails display     color (tuple): tracks line color     track_thickness (int): track line thickness value</p> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>def draw_centroid_and_tracks(self, track, color=(255, 0, 255), track_thickness=2):\n    \"\"\"\n    Draw centroid point and track trails\n    Args:\n        track (list): object tracking points for trails display\n        color (tuple): tracks line color\n        track_thickness (int): track line thickness value\n    \"\"\"\n    points = np.hstack(track).astype(np.int32).reshape((-1, 1, 2))\n    cv2.polylines(self.im, [points], isClosed=False, color=color, thickness=track_thickness)\n    cv2.circle(self.im, (int(track[-1][0]), int(track[-1][1])), track_thickness * 2, color, -1)\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.Annotator.draw_region","title":"<code>draw_region(reg_pts=None, color=(0, 255, 0), thickness=5)</code>","text":"<p>Draw region line Args:     reg_pts (list): Region Points (for line 2 points, for region 4 points)     color (tuple): Region Color value     thickness (int): Region area thickness value</p> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>def draw_region(self, reg_pts=None, color=(0, 255, 0), thickness=5):\n    \"\"\"\n    Draw region line\n    Args:\n        reg_pts (list): Region Points (for line 2 points, for region 4 points)\n        color (tuple): Region Color value\n        thickness (int): Region area thickness value\n    \"\"\"\n    cv2.polylines(self.im, [np.array(reg_pts, dtype=np.int32)], isClosed=True, color=color, thickness=thickness)\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.Annotator.draw_specific_points","title":"<code>draw_specific_points(keypoints, indices=[2, 5, 7], shape=(640, 640), radius=2)</code>","text":"<p>Draw specific keypoints for gym steps counting.</p> <p>Parameters:</p> Name Type Description Default <code>keypoints</code> <code>list</code> <p>list of keypoints data to be plotted</p> required <code>indices</code> <code>list</code> <p>keypoints ids list to be plotted</p> <code>[2, 5, 7]</code> <code>shape</code> <code>tuple</code> <p>imgsz for model inference</p> <code>(640, 640)</code> <code>radius</code> <code>int</code> <p>Keypoint radius value</p> <code>2</code> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>def draw_specific_points(self, keypoints, indices=[2, 5, 7], shape=(640, 640), radius=2):\n    \"\"\"\n    Draw specific keypoints for gym steps counting.\n\n    Args:\n        keypoints (list): list of keypoints data to be plotted\n        indices (list): keypoints ids list to be plotted\n        shape (tuple): imgsz for model inference\n        radius (int): Keypoint radius value\n    \"\"\"\n    nkpts, ndim = keypoints.shape\n    nkpts == 17 and ndim == 3\n    for i, k in enumerate(keypoints):\n        if i in indices:\n            x_coord, y_coord = k[0], k[1]\n            if x_coord % shape[1] != 0 and y_coord % shape[0] != 0:\n                if len(k) == 3:\n                    conf = k[2]\n                    if conf &lt; 0.5:\n                        continue\n                cv2.circle(self.im, (int(x_coord), int(y_coord)), radius, (0, 255, 0), -1, lineType=cv2.LINE_AA)\n    return self.im\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.Annotator.estimate_pose_angle","title":"<code>estimate_pose_angle(a, b, c)</code>  <code>staticmethod</code>","text":"<p>Calculate the pose angle for object Args:     a (float) : The value of pose point a     b (float): The value of pose point b     c (float): The value o pose point c Returns:     angle (degree): Degree value of angle between three points</p> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>@staticmethod\ndef estimate_pose_angle(a, b, c):\n    \"\"\"Calculate the pose angle for object\n    Args:\n        a (float) : The value of pose point a\n        b (float): The value of pose point b\n        c (float): The value o pose point c\n    Returns:\n        angle (degree): Degree value of angle between three points\n    \"\"\"\n    a, b, c = np.array(a), np.array(b), np.array(c)\n    radians = np.arctan2(c[1] - b[1], c[0] - b[0]) - np.arctan2(a[1] - b[1], a[0] - b[0])\n    angle = np.abs(radians * 180.0 / np.pi)\n    if angle &gt; 180.0:\n        angle = 360 - angle\n    return angle\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.Annotator.fromarray","title":"<code>fromarray(im)</code>","text":"<p>Update self.im from a numpy array.</p> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>def fromarray(self, im):\n    \"\"\"Update self.im from a numpy array.\"\"\"\n    self.im = im if isinstance(im, Image.Image) else Image.fromarray(im)\n    self.draw = ImageDraw.Draw(self.im)\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.Annotator.kpts","title":"<code>kpts(kpts, shape=(640, 640), radius=5, kpt_line=True)</code>","text":"<p>Plot keypoints on the image.</p> <p>Parameters:</p> Name Type Description Default <code>kpts</code> <code>tensor</code> <p>Predicted keypoints with shape [17, 3]. Each keypoint has (x, y, confidence).</p> required <code>shape</code> <code>tuple</code> <p>Image shape as a tuple (h, w), where h is the height and w is the width.</p> <code>(640, 640)</code> <code>radius</code> <code>int</code> <p>Radius of the drawn keypoints. Default is 5.</p> <code>5</code> <code>kpt_line</code> <code>bool</code> <p>If True, the function will draw lines connecting keypoints                        for human pose. Default is True.</p> <code>True</code> <p>Note: <code>kpt_line=True</code> currently only supports human pose plotting.</p> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>def kpts(self, kpts, shape=(640, 640), radius=5, kpt_line=True):\n    \"\"\"\n    Plot keypoints on the image.\n\n    Args:\n        kpts (tensor): Predicted keypoints with shape [17, 3]. Each keypoint has (x, y, confidence).\n        shape (tuple): Image shape as a tuple (h, w), where h is the height and w is the width.\n        radius (int, optional): Radius of the drawn keypoints. Default is 5.\n        kpt_line (bool, optional): If True, the function will draw lines connecting keypoints\n                                   for human pose. Default is True.\n\n    Note: `kpt_line=True` currently only supports human pose plotting.\n    \"\"\"\n    if self.pil:\n        # Convert to numpy first\n        self.im = np.asarray(self.im).copy()\n    nkpt, ndim = kpts.shape\n    is_pose = nkpt == 17 and ndim == 3\n    kpt_line &amp;= is_pose  # `kpt_line=True` for now only supports human pose plotting\n    for i, k in enumerate(kpts):\n        color_k = [int(x) for x in self.kpt_color[i]] if is_pose else colors(i)\n        x_coord, y_coord = k[0], k[1]\n        if x_coord % shape[1] != 0 and y_coord % shape[0] != 0:\n            if len(k) == 3:\n                conf = k[2]\n                if conf &lt; 0.5:\n                    continue\n            cv2.circle(self.im, (int(x_coord), int(y_coord)), radius, color_k, -1, lineType=cv2.LINE_AA)\n\n    if kpt_line:\n        ndim = kpts.shape[-1]\n        for i, sk in enumerate(self.skeleton):\n            pos1 = (int(kpts[(sk[0] - 1), 0]), int(kpts[(sk[0] - 1), 1]))\n            pos2 = (int(kpts[(sk[1] - 1), 0]), int(kpts[(sk[1] - 1), 1]))\n            if ndim == 3:\n                conf1 = kpts[(sk[0] - 1), 2]\n                conf2 = kpts[(sk[1] - 1), 2]\n                if conf1 &lt; 0.5 or conf2 &lt; 0.5:\n                    continue\n            if pos1[0] % shape[1] == 0 or pos1[1] % shape[0] == 0 or pos1[0] &lt; 0 or pos1[1] &lt; 0:\n                continue\n            if pos2[0] % shape[1] == 0 or pos2[1] % shape[0] == 0 or pos2[0] &lt; 0 or pos2[1] &lt; 0:\n                continue\n            cv2.line(self.im, pos1, pos2, [int(x) for x in self.limb_color[i]], thickness=2, lineType=cv2.LINE_AA)\n    if self.pil:\n        # Convert im back to PIL and update draw\n        self.fromarray(self.im)\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.Annotator.masks","title":"<code>masks(masks, colors, im_gpu, alpha=0.5, retina_masks=False)</code>","text":"<p>Plot masks on image.</p> <p>Parameters:</p> Name Type Description Default <code>masks</code> <code>tensor</code> <p>Predicted masks on cuda, shape: [n, h, w]</p> required <code>colors</code> <code>List[List[Int]]</code> <p>Colors for predicted masks, [[r, g, b] * n]</p> required <code>im_gpu</code> <code>tensor</code> <p>Image is in cuda, shape: [3, h, w], range: [0, 1]</p> required <code>alpha</code> <code>float</code> <p>Mask transparency: 0.0 fully transparent, 1.0 opaque</p> <code>0.5</code> <code>retina_masks</code> <code>bool</code> <p>Whether to use high resolution masks or not. Defaults to False.</p> <code>False</code> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>def masks(self, masks, colors, im_gpu, alpha=0.5, retina_masks=False):\n    \"\"\"\n    Plot masks on image.\n\n    Args:\n        masks (tensor): Predicted masks on cuda, shape: [n, h, w]\n        colors (List[List[Int]]): Colors for predicted masks, [[r, g, b] * n]\n        im_gpu (tensor): Image is in cuda, shape: [3, h, w], range: [0, 1]\n        alpha (float): Mask transparency: 0.0 fully transparent, 1.0 opaque\n        retina_masks (bool): Whether to use high resolution masks or not. Defaults to False.\n    \"\"\"\n    if self.pil:\n        # Convert to numpy first\n        self.im = np.asarray(self.im).copy()\n    if len(masks) == 0:\n        self.im[:] = im_gpu.permute(1, 2, 0).contiguous().cpu().numpy() * 255\n    if im_gpu.device != masks.device:\n        im_gpu = im_gpu.to(masks.device)\n    colors = torch.tensor(colors, device=masks.device, dtype=torch.float32) / 255.0  # shape(n,3)\n    colors = colors[:, None, None]  # shape(n,1,1,3)\n    masks = masks.unsqueeze(3)  # shape(n,h,w,1)\n    masks_color = masks * (colors * alpha)  # shape(n,h,w,3)\n\n    inv_alpha_masks = (1 - masks * alpha).cumprod(0)  # shape(n,h,w,1)\n    mcs = masks_color.max(dim=0).values  # shape(n,h,w,3)\n\n    im_gpu = im_gpu.flip(dims=[0])  # flip channel\n    im_gpu = im_gpu.permute(1, 2, 0).contiguous()  # shape(h,w,3)\n    im_gpu = im_gpu * inv_alpha_masks[-1] + mcs\n    im_mask = im_gpu * 255\n    im_mask_np = im_mask.byte().cpu().numpy()\n    self.im[:] = im_mask_np if retina_masks else ops.scale_image(im_mask_np, self.im.shape)\n    if self.pil:\n        # Convert im back to PIL and update draw\n        self.fromarray(self.im)\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.Annotator.plot_angle_and_count_and_stage","title":"<code>plot_angle_and_count_and_stage(angle_text, count_text, stage_text, center_kpt, line_thickness=2)</code>","text":"<p>Plot the pose angle, count value and step stage.</p> <p>Parameters:</p> Name Type Description Default <code>angle_text</code> <code>str</code> <p>angle value for workout monitoring</p> required <code>count_text</code> <code>str</code> <p>counts value for workout monitoring</p> required <code>stage_text</code> <code>str</code> <p>stage decision for workout monitoring</p> required <code>center_kpt</code> <code>int</code> <p>centroid pose index for workout monitoring</p> required <code>line_thickness</code> <code>int</code> <p>thickness for text display</p> <code>2</code> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>def plot_angle_and_count_and_stage(self, angle_text, count_text, stage_text, center_kpt, line_thickness=2):\n    \"\"\"\n    Plot the pose angle, count value and step stage.\n\n    Args:\n        angle_text (str): angle value for workout monitoring\n        count_text (str): counts value for workout monitoring\n        stage_text (str): stage decision for workout monitoring\n        center_kpt (int): centroid pose index for workout monitoring\n        line_thickness (int): thickness for text display\n    \"\"\"\n    angle_text, count_text, stage_text = (f\" {angle_text:.2f}\", \"Steps : \" + f\"{count_text}\", f\" {stage_text}\")\n    font_scale = 0.6 + (line_thickness / 10.0)\n\n    # Draw angle\n    (angle_text_width, angle_text_height), _ = cv2.getTextSize(angle_text, 0, font_scale, line_thickness)\n    angle_text_position = (int(center_kpt[0]), int(center_kpt[1]))\n    angle_background_position = (angle_text_position[0], angle_text_position[1] - angle_text_height - 5)\n    angle_background_size = (angle_text_width + 2 * 5, angle_text_height + 2 * 5 + (line_thickness * 2))\n    cv2.rectangle(\n        self.im,\n        angle_background_position,\n        (\n            angle_background_position[0] + angle_background_size[0],\n            angle_background_position[1] + angle_background_size[1],\n        ),\n        (255, 255, 255),\n        -1,\n    )\n    cv2.putText(self.im, angle_text, angle_text_position, 0, font_scale, (0, 0, 0), line_thickness)\n\n    # Draw Counts\n    (count_text_width, count_text_height), _ = cv2.getTextSize(count_text, 0, font_scale, line_thickness)\n    count_text_position = (angle_text_position[0], angle_text_position[1] + angle_text_height + 20)\n    count_background_position = (\n        angle_background_position[0],\n        angle_background_position[1] + angle_background_size[1] + 5,\n    )\n    count_background_size = (count_text_width + 10, count_text_height + 10 + (line_thickness * 2))\n\n    cv2.rectangle(\n        self.im,\n        count_background_position,\n        (\n            count_background_position[0] + count_background_size[0],\n            count_background_position[1] + count_background_size[1],\n        ),\n        (255, 255, 255),\n        -1,\n    )\n    cv2.putText(self.im, count_text, count_text_position, 0, font_scale, (0, 0, 0), line_thickness)\n\n    # Draw Stage\n    (stage_text_width, stage_text_height), _ = cv2.getTextSize(stage_text, 0, font_scale, line_thickness)\n    stage_text_position = (int(center_kpt[0]), int(center_kpt[1]) + angle_text_height + count_text_height + 40)\n    stage_background_position = (stage_text_position[0], stage_text_position[1] - stage_text_height - 5)\n    stage_background_size = (stage_text_width + 10, stage_text_height + 10)\n\n    cv2.rectangle(\n        self.im,\n        stage_background_position,\n        (\n            stage_background_position[0] + stage_background_size[0],\n            stage_background_position[1] + stage_background_size[1],\n        ),\n        (255, 255, 255),\n        -1,\n    )\n    cv2.putText(self.im, stage_text, stage_text_position, 0, font_scale, (0, 0, 0), line_thickness)\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.Annotator.rectangle","title":"<code>rectangle(xy, fill=None, outline=None, width=1)</code>","text":"<p>Add rectangle to image (PIL-only).</p> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>def rectangle(self, xy, fill=None, outline=None, width=1):\n    \"\"\"Add rectangle to image (PIL-only).\"\"\"\n    self.draw.rectangle(xy, fill, outline, width)\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.Annotator.result","title":"<code>result()</code>","text":"<p>Return annotated image as array.</p> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>def result(self):\n    \"\"\"Return annotated image as array.\"\"\"\n    return np.asarray(self.im)\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.Annotator.seg_bbox","title":"<code>seg_bbox(mask, mask_color=(255, 0, 255), det_label=None, track_label=None)</code>","text":"<p>Function for drawing segmented object in bounding box shape.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>list</code> <p>masks data list for instance segmentation area plotting</p> required <code>mask_color</code> <code>tuple</code> <p>mask foreground color</p> <code>(255, 0, 255)</code> <code>det_label</code> <code>str</code> <p>Detection label text</p> <code>None</code> <code>track_label</code> <code>str</code> <p>Tracking label text</p> <code>None</code> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>def seg_bbox(self, mask, mask_color=(255, 0, 255), det_label=None, track_label=None):\n    \"\"\"\n    Function for drawing segmented object in bounding box shape.\n\n    Args:\n        mask (list): masks data list for instance segmentation area plotting\n        mask_color (tuple): mask foreground color\n        det_label (str): Detection label text\n        track_label (str): Tracking label text\n    \"\"\"\n    cv2.polylines(self.im, [np.int32([mask])], isClosed=True, color=mask_color, thickness=2)\n\n    label = f\"Track ID: {track_label}\" if track_label else det_label\n    text_size, _ = cv2.getTextSize(label, 0, 0.7, 1)\n\n    cv2.rectangle(\n        self.im,\n        (int(mask[0][0]) - text_size[0] // 2 - 10, int(mask[0][1]) - text_size[1] - 10),\n        (int(mask[0][0]) + text_size[0] // 2 + 5, int(mask[0][1] + 5)),\n        mask_color,\n        -1,\n    )\n\n    cv2.putText(\n        self.im, label, (int(mask[0][0]) - text_size[0] // 2, int(mask[0][1]) - 5), 0, 0.7, (255, 255, 255), 2\n    )\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.Annotator.text","title":"<code>text(xy, text, txt_color=(255, 255, 255), anchor='top', box_style=False)</code>","text":"<p>Adds text to an image using PIL or cv2.</p> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>def text(self, xy, text, txt_color=(255, 255, 255), anchor=\"top\", box_style=False):\n    \"\"\"Adds text to an image using PIL or cv2.\"\"\"\n    if anchor == \"bottom\":  # start y from font bottom\n        w, h = self.font.getsize(text)  # text width, height\n        xy[1] += 1 - h\n    if self.pil:\n        if box_style:\n            w, h = self.font.getsize(text)\n            self.draw.rectangle((xy[0], xy[1], xy[0] + w + 1, xy[1] + h + 1), fill=txt_color)\n            # Using `txt_color` for background and draw fg with white color\n            txt_color = (255, 255, 255)\n        if \"\\n\" in text:\n            lines = text.split(\"\\n\")\n            _, h = self.font.getsize(text)\n            for line in lines:\n                self.draw.text(xy, line, fill=txt_color, font=self.font)\n                xy[1] += h\n        else:\n            self.draw.text(xy, text, fill=txt_color, font=self.font)\n    else:\n        if box_style:\n            w, h = cv2.getTextSize(text, 0, fontScale=self.sf, thickness=self.tf)[0]  # text width, height\n            outside = xy[1] - h &gt;= 3\n            p2 = xy[0] + w, xy[1] - h - 3 if outside else xy[1] + h + 3\n            cv2.rectangle(self.im, xy, p2, txt_color, -1, cv2.LINE_AA)  # filled\n            # Using `txt_color` for background and draw fg with white color\n            txt_color = (255, 255, 255)\n        cv2.putText(self.im, text, xy, 0, self.sf, txt_color, thickness=self.tf, lineType=cv2.LINE_AA)\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.Annotator.visioneye","title":"<code>visioneye(box, center_point, color=(235, 219, 11), pin_color=(255, 0, 255), thickness=2, pins_radius=10)</code>","text":"<p>Function for pinpoint human-vision eye mapping and plotting.</p> <p>Parameters:</p> Name Type Description Default <code>box</code> <code>list</code> <p>Bounding box coordinates</p> required <code>center_point</code> <code>tuple</code> <p>center point for vision eye view</p> required <code>color</code> <code>tuple</code> <p>object centroid and line color value</p> <code>(235, 219, 11)</code> <code>pin_color</code> <code>tuple</code> <p>visioneye point color value</p> <code>(255, 0, 255)</code> <code>thickness</code> <code>int</code> <p>int value for line thickness</p> <code>2</code> <code>pins_radius</code> <code>int</code> <p>visioneye point radius value</p> <code>10</code> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>def visioneye(self, box, center_point, color=(235, 219, 11), pin_color=(255, 0, 255), thickness=2, pins_radius=10):\n    \"\"\"\n    Function for pinpoint human-vision eye mapping and plotting.\n\n    Args:\n        box (list): Bounding box coordinates\n        center_point (tuple): center point for vision eye view\n        color (tuple): object centroid and line color value\n        pin_color (tuple): visioneye point color value\n        thickness (int): int value for line thickness\n        pins_radius (int): visioneye point radius value\n    \"\"\"\n    center_bbox = int((box[0] + box[2]) / 2), int((box[1] + box[3]) / 2)\n    cv2.circle(self.im, center_point, pins_radius, pin_color, -1)\n    cv2.circle(self.im, center_bbox, pins_radius, color, -1)\n    cv2.line(self.im, center_point, center_bbox, color, thickness)\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.plot_labels","title":"<code>ultralytics.utils.plotting.plot_labels(boxes, cls, names=(), save_dir=Path(''), on_plot=None)</code>","text":"<p>Plot training labels including class histograms and box statistics.</p> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>@TryExcept()  # known issue https://github.com/ultralytics/yolov5/issues/5395\n@plt_settings()\ndef plot_labels(boxes, cls, names=(), save_dir=Path(\"\"), on_plot=None):\n    \"\"\"Plot training labels including class histograms and box statistics.\"\"\"\n    import pandas as pd\n    import seaborn as sn\n\n    # Filter matplotlib&gt;=3.7.2 warning and Seaborn use_inf and is_categorical FutureWarnings\n    warnings.filterwarnings(\"ignore\", category=UserWarning, message=\"The figure layout has changed to tight\")\n    warnings.filterwarnings(\"ignore\", category=FutureWarning)\n\n    # Plot dataset labels\n    LOGGER.info(f\"Plotting labels to {save_dir / 'labels.jpg'}... \")\n    nc = int(cls.max() + 1)  # number of classes\n    boxes = boxes[:1000000]  # limit to 1M boxes\n    x = pd.DataFrame(boxes, columns=[\"x\", \"y\", \"width\", \"height\"])\n\n    # Seaborn correlogram\n    sn.pairplot(x, corner=True, diag_kind=\"auto\", kind=\"hist\", diag_kws=dict(bins=50), plot_kws=dict(pmax=0.9))\n    plt.savefig(save_dir / \"labels_correlogram.jpg\", dpi=200)\n    plt.close()\n\n    # Matplotlib labels\n    ax = plt.subplots(2, 2, figsize=(8, 8), tight_layout=True)[1].ravel()\n    y = ax[0].hist(cls, bins=np.linspace(0, nc, nc + 1) - 0.5, rwidth=0.8)\n    for i in range(nc):\n        y[2].patches[i].set_color([x / 255 for x in colors(i)])\n    ax[0].set_ylabel(\"instances\")\n    if 0 &lt; len(names) &lt; 30:\n        ax[0].set_xticks(range(len(names)))\n        ax[0].set_xticklabels(list(names.values()), rotation=90, fontsize=10)\n    else:\n        ax[0].set_xlabel(\"classes\")\n    sn.histplot(x, x=\"x\", y=\"y\", ax=ax[2], bins=50, pmax=0.9)\n    sn.histplot(x, x=\"width\", y=\"height\", ax=ax[3], bins=50, pmax=0.9)\n\n    # Rectangles\n    boxes[:, 0:2] = 0.5  # center\n    boxes = ops.xywh2xyxy(boxes) * 1000\n    img = Image.fromarray(np.ones((1000, 1000, 3), dtype=np.uint8) * 255)\n    for cls, box in zip(cls[:500], boxes[:500]):\n        ImageDraw.Draw(img).rectangle(box, width=1, outline=colors(cls))  # plot\n    ax[1].imshow(img)\n    ax[1].axis(\"off\")\n\n    for a in [0, 1, 2, 3]:\n        for s in [\"top\", \"right\", \"left\", \"bottom\"]:\n            ax[a].spines[s].set_visible(False)\n\n    fname = save_dir / \"labels.jpg\"\n    plt.savefig(fname, dpi=200)\n    plt.close()\n    if on_plot:\n        on_plot(fname)\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.save_one_box","title":"<code>ultralytics.utils.plotting.save_one_box(xyxy, im, file=Path('im.jpg'), gain=1.02, pad=10, square=False, BGR=False, save=True)</code>","text":"<p>Save image crop as {file} with crop size multiple {gain} and {pad} pixels. Save and/or return crop.</p> <p>This function takes a bounding box and an image, and then saves a cropped portion of the image according to the bounding box. Optionally, the crop can be squared, and the function allows for gain and padding adjustments to the bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>xyxy</code> <code>Tensor or list</code> <p>A tensor or list representing the bounding box in xyxy format.</p> required <code>im</code> <code>ndarray</code> <p>The input image.</p> required <code>file</code> <code>Path</code> <p>The path where the cropped image will be saved. Defaults to 'im.jpg'.</p> <code>Path('im.jpg')</code> <code>gain</code> <code>float</code> <p>A multiplicative factor to increase the size of the bounding box. Defaults to 1.02.</p> <code>1.02</code> <code>pad</code> <code>int</code> <p>The number of pixels to add to the width and height of the bounding box. Defaults to 10.</p> <code>10</code> <code>square</code> <code>bool</code> <p>If True, the bounding box will be transformed into a square. Defaults to False.</p> <code>False</code> <code>BGR</code> <code>bool</code> <p>If True, the image will be saved in BGR format, otherwise in RGB. Defaults to False.</p> <code>False</code> <code>save</code> <code>bool</code> <p>If True, the cropped image will be saved to disk. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The cropped image.</p> Example <pre><code>from ultralytics.utils.plotting import save_one_box\n\nxyxy = [50, 50, 150, 150]\nim = cv2.imread('image.jpg')\ncropped_im = save_one_box(xyxy, im, file='cropped.jpg', square=True)\n</code></pre> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>def save_one_box(xyxy, im, file=Path(\"im.jpg\"), gain=1.02, pad=10, square=False, BGR=False, save=True):\n    \"\"\"\n    Save image crop as {file} with crop size multiple {gain} and {pad} pixels. Save and/or return crop.\n\n    This function takes a bounding box and an image, and then saves a cropped portion of the image according\n    to the bounding box. Optionally, the crop can be squared, and the function allows for gain and padding\n    adjustments to the bounding box.\n\n    Args:\n        xyxy (torch.Tensor or list): A tensor or list representing the bounding box in xyxy format.\n        im (numpy.ndarray): The input image.\n        file (Path, optional): The path where the cropped image will be saved. Defaults to 'im.jpg'.\n        gain (float, optional): A multiplicative factor to increase the size of the bounding box. Defaults to 1.02.\n        pad (int, optional): The number of pixels to add to the width and height of the bounding box. Defaults to 10.\n        square (bool, optional): If True, the bounding box will be transformed into a square. Defaults to False.\n        BGR (bool, optional): If True, the image will be saved in BGR format, otherwise in RGB. Defaults to False.\n        save (bool, optional): If True, the cropped image will be saved to disk. Defaults to True.\n\n    Returns:\n        (numpy.ndarray): The cropped image.\n\n    Example:\n        ```python\n        from ultralytics.utils.plotting import save_one_box\n\n        xyxy = [50, 50, 150, 150]\n        im = cv2.imread('image.jpg')\n        cropped_im = save_one_box(xyxy, im, file='cropped.jpg', square=True)\n        ```\n    \"\"\"\n\n    if not isinstance(xyxy, torch.Tensor):  # may be list\n        xyxy = torch.stack(xyxy)\n    b = ops.xyxy2xywh(xyxy.view(-1, 4))  # boxes\n    if square:\n        b[:, 2:] = b[:, 2:].max(1)[0].unsqueeze(1)  # attempt rectangle to square\n    b[:, 2:] = b[:, 2:] * gain + pad  # box wh * gain + pad\n    xyxy = ops.xywh2xyxy(b).long()\n    xyxy = ops.clip_boxes(xyxy, im.shape)\n    crop = im[int(xyxy[0, 1]) : int(xyxy[0, 3]), int(xyxy[0, 0]) : int(xyxy[0, 2]), :: (1 if BGR else -1)]\n    if save:\n        file.parent.mkdir(parents=True, exist_ok=True)  # make directory\n        f = str(increment_path(file).with_suffix(\".jpg\"))\n        # cv2.imwrite(f, crop)  # save BGR, https://github.com/ultralytics/yolov5/issues/7007 chroma subsampling issue\n        Image.fromarray(crop[..., ::-1]).save(f, quality=95, subsampling=0)  # save RGB\n    return crop\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.plot_images","title":"<code>ultralytics.utils.plotting.plot_images(images, batch_idx, cls, bboxes=np.zeros(0, dtype=np.float32), confs=None, masks=np.zeros(0, dtype=np.uint8), kpts=np.zeros((0, 51), dtype=np.float32), paths=None, fname='images.jpg', names=None, on_plot=None, max_subplots=16, save=True)</code>","text":"<p>Plot image grid with labels.</p> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>@threaded\ndef plot_images(\n    images,\n    batch_idx,\n    cls,\n    bboxes=np.zeros(0, dtype=np.float32),\n    confs=None,\n    masks=np.zeros(0, dtype=np.uint8),\n    kpts=np.zeros((0, 51), dtype=np.float32),\n    paths=None,\n    fname=\"images.jpg\",\n    names=None,\n    on_plot=None,\n    max_subplots=16,\n    save=True,\n):\n    \"\"\"Plot image grid with labels.\"\"\"\n    if isinstance(images, torch.Tensor):\n        images = images.cpu().float().numpy()\n    if isinstance(cls, torch.Tensor):\n        cls = cls.cpu().numpy()\n    if isinstance(bboxes, torch.Tensor):\n        bboxes = bboxes.cpu().numpy()\n    if isinstance(masks, torch.Tensor):\n        masks = masks.cpu().numpy().astype(int)\n    if isinstance(kpts, torch.Tensor):\n        kpts = kpts.cpu().numpy()\n    if isinstance(batch_idx, torch.Tensor):\n        batch_idx = batch_idx.cpu().numpy()\n\n    max_size = 1920  # max image size\n    bs, _, h, w = images.shape  # batch size, _, height, width\n    bs = min(bs, max_subplots)  # limit plot images\n    ns = np.ceil(bs**0.5)  # number of subplots (square)\n    if np.max(images[0]) &lt;= 1:\n        images *= 255  # de-normalise (optional)\n\n    # Build Image\n    mosaic = np.full((int(ns * h), int(ns * w), 3), 255, dtype=np.uint8)  # init\n    for i in range(bs):\n        x, y = int(w * (i // ns)), int(h * (i % ns))  # block origin\n        mosaic[y : y + h, x : x + w, :] = images[i].transpose(1, 2, 0)\n\n    # Resize (optional)\n    scale = max_size / ns / max(h, w)\n    if scale &lt; 1:\n        h = math.ceil(scale * h)\n        w = math.ceil(scale * w)\n        mosaic = cv2.resize(mosaic, tuple(int(x * ns) for x in (w, h)))\n\n    # Annotate\n    fs = int((h + w) * ns * 0.01)  # font size\n    annotator = Annotator(mosaic, line_width=round(fs / 10), font_size=fs, pil=True, example=names)\n    for i in range(bs):\n        x, y = int(w * (i // ns)), int(h * (i % ns))  # block origin\n        annotator.rectangle([x, y, x + w, y + h], None, (255, 255, 255), width=2)  # borders\n        if paths:\n            annotator.text((x + 5, y + 5), text=Path(paths[i]).name[:40], txt_color=(220, 220, 220))  # filenames\n        if len(cls) &gt; 0:\n            idx = batch_idx == i\n            classes = cls[idx].astype(\"int\")\n            labels = confs is None\n\n            if len(bboxes):\n                boxes = bboxes[idx]\n                conf = confs[idx] if confs is not None else None  # check for confidence presence (label vs pred)\n                if len(boxes):\n                    if boxes[:, :4].max() &lt;= 1.1:  # if normalized with tolerance 0.1\n                        boxes[:, [0, 2]] *= w  # scale to pixels\n                        boxes[:, [1, 3]] *= h\n                    elif scale &lt; 1:  # absolute coords need scale if image scales\n                        boxes[:, :4] *= scale\n                boxes[:, 0] += x\n                boxes[:, 1] += y\n                is_obb = boxes.shape[-1] == 5  # xywhr\n                boxes = ops.xywhr2xyxyxyxy(boxes) if is_obb else ops.xywh2xyxy(boxes)\n                for j, box in enumerate(boxes.astype(np.int64).tolist()):\n                    c = classes[j]\n                    color = colors(c)\n                    c = names.get(c, c) if names else c\n                    if labels or conf[j] &gt; 0.25:  # 0.25 conf thresh\n                        label = f\"{c}\" if labels else f\"{c} {conf[j]:.1f}\"\n                        annotator.box_label(box, label, color=color, rotated=is_obb)\n\n            elif len(classes):\n                for c in classes:\n                    color = colors(c)\n                    c = names.get(c, c) if names else c\n                    annotator.text((x, y), f\"{c}\", txt_color=color, box_style=True)\n\n            # Plot keypoints\n            if len(kpts):\n                kpts_ = kpts[idx].copy()\n                if len(kpts_):\n                    if kpts_[..., 0].max() &lt;= 1.01 or kpts_[..., 1].max() &lt;= 1.01:  # if normalized with tolerance .01\n                        kpts_[..., 0] *= w  # scale to pixels\n                        kpts_[..., 1] *= h\n                    elif scale &lt; 1:  # absolute coords need scale if image scales\n                        kpts_ *= scale\n                kpts_[..., 0] += x\n                kpts_[..., 1] += y\n                for j in range(len(kpts_)):\n                    if labels or conf[j] &gt; 0.25:  # 0.25 conf thresh\n                        annotator.kpts(kpts_[j])\n\n            # Plot masks\n            if len(masks):\n                if idx.shape[0] == masks.shape[0]:  # overlap_masks=False\n                    image_masks = masks[idx]\n                else:  # overlap_masks=True\n                    image_masks = masks[[i]]  # (1, 640, 640)\n                    nl = idx.sum()\n                    index = np.arange(nl).reshape((nl, 1, 1)) + 1\n                    image_masks = np.repeat(image_masks, nl, axis=0)\n                    image_masks = np.where(image_masks == index, 1.0, 0.0)\n\n                im = np.asarray(annotator.im).copy()\n                for j in range(len(image_masks)):\n                    if labels or conf[j] &gt; 0.25:  # 0.25 conf thresh\n                        color = colors(classes[j])\n                        mh, mw = image_masks[j].shape\n                        if mh != h or mw != w:\n                            mask = image_masks[j].astype(np.uint8)\n                            mask = cv2.resize(mask, (w, h))\n                            mask = mask.astype(bool)\n                        else:\n                            mask = image_masks[j].astype(bool)\n                        with contextlib.suppress(Exception):\n                            im[y : y + h, x : x + w, :][mask] = (\n                                im[y : y + h, x : x + w, :][mask] * 0.4 + np.array(color) * 0.6\n                            )\n                annotator.fromarray(im)\n    if save:\n        annotator.im.save(fname)  # save\n        if on_plot:\n            on_plot(fname)\n    else:\n        return np.asarray(annotator.im)\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.plot_results","title":"<code>ultralytics.utils.plotting.plot_results(file='path/to/results.csv', dir='', segment=False, pose=False, classify=False, on_plot=None)</code>","text":"<p>Plot training results from a results CSV file. The function supports various types of data including segmentation, pose estimation, and classification. Plots are saved as 'results.png' in the directory where the CSV is located.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>Path to the CSV file containing the training results. Defaults to 'path/to/results.csv'.</p> <code>'path/to/results.csv'</code> <code>dir</code> <code>str</code> <p>Directory where the CSV file is located if 'file' is not provided. Defaults to ''.</p> <code>''</code> <code>segment</code> <code>bool</code> <p>Flag to indicate if the data is for segmentation. Defaults to False.</p> <code>False</code> <code>pose</code> <code>bool</code> <p>Flag to indicate if the data is for pose estimation. Defaults to False.</p> <code>False</code> <code>classify</code> <code>bool</code> <p>Flag to indicate if the data is for classification. Defaults to False.</p> <code>False</code> <code>on_plot</code> <code>callable</code> <p>Callback function to be executed after plotting. Takes filename as an argument. Defaults to None.</p> <code>None</code> Example <pre><code>from ultralytics.utils.plotting import plot_results\n\nplot_results('path/to/results.csv', segment=True)\n</code></pre> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>@plt_settings()\ndef plot_results(file=\"path/to/results.csv\", dir=\"\", segment=False, pose=False, classify=False, on_plot=None):\n    \"\"\"\n    Plot training results from a results CSV file. The function supports various types of data including segmentation,\n    pose estimation, and classification. Plots are saved as 'results.png' in the directory where the CSV is located.\n\n    Args:\n        file (str, optional): Path to the CSV file containing the training results. Defaults to 'path/to/results.csv'.\n        dir (str, optional): Directory where the CSV file is located if 'file' is not provided. Defaults to ''.\n        segment (bool, optional): Flag to indicate if the data is for segmentation. Defaults to False.\n        pose (bool, optional): Flag to indicate if the data is for pose estimation. Defaults to False.\n        classify (bool, optional): Flag to indicate if the data is for classification. Defaults to False.\n        on_plot (callable, optional): Callback function to be executed after plotting. Takes filename as an argument.\n            Defaults to None.\n\n    Example:\n        ```python\n        from ultralytics.utils.plotting import plot_results\n\n        plot_results('path/to/results.csv', segment=True)\n        ```\n    \"\"\"\n    import pandas as pd\n    from scipy.ndimage import gaussian_filter1d\n\n    save_dir = Path(file).parent if file else Path(dir)\n    if classify:\n        fig, ax = plt.subplots(2, 2, figsize=(6, 6), tight_layout=True)\n        index = [1, 4, 2, 3]\n    elif segment:\n        fig, ax = plt.subplots(2, 8, figsize=(18, 6), tight_layout=True)\n        index = [1, 2, 3, 4, 5, 6, 9, 10, 13, 14, 15, 16, 7, 8, 11, 12]\n    elif pose:\n        fig, ax = plt.subplots(2, 9, figsize=(21, 6), tight_layout=True)\n        index = [1, 2, 3, 4, 5, 6, 7, 10, 11, 14, 15, 16, 17, 18, 8, 9, 12, 13]\n    else:\n        fig, ax = plt.subplots(2, 5, figsize=(12, 6), tight_layout=True)\n        index = [1, 2, 3, 4, 5, 8, 9, 10, 6, 7]\n    ax = ax.ravel()\n    files = list(save_dir.glob(\"results*.csv\"))\n    assert len(files), f\"No results.csv files found in {save_dir.resolve()}, nothing to plot.\"\n    for f in files:\n        try:\n            data = pd.read_csv(f)\n            s = [x.strip() for x in data.columns]\n            x = data.values[:, 0]\n            for i, j in enumerate(index):\n                y = data.values[:, j].astype(\"float\")\n                # y[y == 0] = np.nan  # don't show zero values\n                ax[i].plot(x, y, marker=\".\", label=f.stem, linewidth=2, markersize=8)  # actual results\n                ax[i].plot(x, gaussian_filter1d(y, sigma=3), \":\", label=\"smooth\", linewidth=2)  # smoothing line\n                ax[i].set_title(s[j], fontsize=12)\n                # if j in [8, 9, 10]:  # share train and val loss y axes\n                #     ax[i].get_shared_y_axes().join(ax[i], ax[i - 5])\n        except Exception as e:\n            LOGGER.warning(f\"WARNING: Plotting error for {f}: {e}\")\n    ax[1].legend()\n    fname = save_dir / \"results.png\"\n    fig.savefig(fname, dpi=200)\n    plt.close()\n    if on_plot:\n        on_plot(fname)\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.plt_color_scatter","title":"<code>ultralytics.utils.plotting.plt_color_scatter(v, f, bins=20, cmap='viridis', alpha=0.8, edgecolors='none')</code>","text":"<p>Plots a scatter plot with points colored based on a 2D histogram.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>array - like</code> <p>Values for the x-axis.</p> required <code>f</code> <code>array - like</code> <p>Values for the y-axis.</p> required <code>bins</code> <code>int</code> <p>Number of bins for the histogram. Defaults to 20.</p> <code>20</code> <code>cmap</code> <code>str</code> <p>Colormap for the scatter plot. Defaults to 'viridis'.</p> <code>'viridis'</code> <code>alpha</code> <code>float</code> <p>Alpha for the scatter plot. Defaults to 0.8.</p> <code>0.8</code> <code>edgecolors</code> <code>str</code> <p>Edge colors for the scatter plot. Defaults to 'none'.</p> <code>'none'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; v = np.random.rand(100)\n&gt;&gt;&gt; f = np.random.rand(100)\n&gt;&gt;&gt; plt_color_scatter(v, f)\n</code></pre> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>def plt_color_scatter(v, f, bins=20, cmap=\"viridis\", alpha=0.8, edgecolors=\"none\"):\n    \"\"\"\n    Plots a scatter plot with points colored based on a 2D histogram.\n\n    Args:\n        v (array-like): Values for the x-axis.\n        f (array-like): Values for the y-axis.\n        bins (int, optional): Number of bins for the histogram. Defaults to 20.\n        cmap (str, optional): Colormap for the scatter plot. Defaults to 'viridis'.\n        alpha (float, optional): Alpha for the scatter plot. Defaults to 0.8.\n        edgecolors (str, optional): Edge colors for the scatter plot. Defaults to 'none'.\n\n    Examples:\n        &gt;&gt;&gt; v = np.random.rand(100)\n        &gt;&gt;&gt; f = np.random.rand(100)\n        &gt;&gt;&gt; plt_color_scatter(v, f)\n    \"\"\"\n\n    # Calculate 2D histogram and corresponding colors\n    hist, xedges, yedges = np.histogram2d(v, f, bins=bins)\n    colors = [\n        hist[\n            min(np.digitize(v[i], xedges, right=True) - 1, hist.shape[0] - 1),\n            min(np.digitize(f[i], yedges, right=True) - 1, hist.shape[1] - 1),\n        ]\n        for i in range(len(v))\n    ]\n\n    # Scatter plot\n    plt.scatter(v, f, c=colors, cmap=cmap, alpha=alpha, edgecolors=edgecolors)\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.plot_tune_results","title":"<code>ultralytics.utils.plotting.plot_tune_results(csv_file='tune_results.csv')</code>","text":"<p>Plot the evolution results stored in an 'tune_results.csv' file. The function generates a scatter plot for each key in the CSV, color-coded based on fitness scores. The best-performing configurations are highlighted on the plots.</p> <p>Parameters:</p> Name Type Description Default <code>csv_file</code> <code>str</code> <p>Path to the CSV file containing the tuning results. Defaults to 'tune_results.csv'.</p> <code>'tune_results.csv'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; plot_tune_results('path/to/tune_results.csv')\n</code></pre> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>def plot_tune_results(csv_file=\"tune_results.csv\"):\n    \"\"\"\n    Plot the evolution results stored in an 'tune_results.csv' file. The function generates a scatter plot for each key\n    in the CSV, color-coded based on fitness scores. The best-performing configurations are highlighted on the plots.\n\n    Args:\n        csv_file (str, optional): Path to the CSV file containing the tuning results. Defaults to 'tune_results.csv'.\n\n    Examples:\n        &gt;&gt;&gt; plot_tune_results('path/to/tune_results.csv')\n    \"\"\"\n\n    import pandas as pd\n    from scipy.ndimage import gaussian_filter1d\n\n    # Scatter plots for each hyperparameter\n    csv_file = Path(csv_file)\n    data = pd.read_csv(csv_file)\n    num_metrics_columns = 1\n    keys = [x.strip() for x in data.columns][num_metrics_columns:]\n    x = data.values\n    fitness = x[:, 0]  # fitness\n    j = np.argmax(fitness)  # max fitness index\n    n = math.ceil(len(keys) ** 0.5)  # columns and rows in plot\n    plt.figure(figsize=(10, 10), tight_layout=True)\n    for i, k in enumerate(keys):\n        v = x[:, i + num_metrics_columns]\n        mu = v[j]  # best single result\n        plt.subplot(n, n, i + 1)\n        plt_color_scatter(v, fitness, cmap=\"viridis\", alpha=0.8, edgecolors=\"none\")\n        plt.plot(mu, fitness.max(), \"k+\", markersize=15)\n        plt.title(f\"{k} = {mu:.3g}\", fontdict={\"size\": 9})  # limit to 40 characters\n        plt.tick_params(axis=\"both\", labelsize=8)  # Set axis label size to 8\n        if i % n != 0:\n            plt.yticks([])\n\n    file = csv_file.with_name(\"tune_scatter_plots.png\")  # filename\n    plt.savefig(file, dpi=200)\n    plt.close()\n    LOGGER.info(f\"Saved {file}\")\n\n    # Fitness vs iteration\n    x = range(1, len(fitness) + 1)\n    plt.figure(figsize=(10, 6), tight_layout=True)\n    plt.plot(x, fitness, marker=\"o\", linestyle=\"none\", label=\"fitness\")\n    plt.plot(x, gaussian_filter1d(fitness, sigma=3), \":\", label=\"smoothed\", linewidth=2)  # smoothing line\n    plt.title(\"Fitness vs Iteration\")\n    plt.xlabel(\"Iteration\")\n    plt.ylabel(\"Fitness\")\n    plt.grid(True)\n    plt.legend()\n\n    file = csv_file.with_name(\"tune_fitness.png\")  # filename\n    plt.savefig(file, dpi=200)\n    plt.close()\n    LOGGER.info(f\"Saved {file}\")\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.output_to_target","title":"<code>ultralytics.utils.plotting.output_to_target(output, max_det=300)</code>","text":"<p>Convert model output to target format [batch_id, class_id, x, y, w, h, conf] for plotting.</p> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>def output_to_target(output, max_det=300):\n    \"\"\"Convert model output to target format [batch_id, class_id, x, y, w, h, conf] for plotting.\"\"\"\n    targets = []\n    for i, o in enumerate(output):\n        box, conf, cls = o[:max_det, :6].cpu().split((4, 1, 1), 1)\n        j = torch.full((conf.shape[0], 1), i)\n        targets.append(torch.cat((j, cls, ops.xyxy2xywh(box), conf), 1))\n    targets = torch.cat(targets, 0).numpy()\n    return targets[:, 0], targets[:, 1], targets[:, 2:-1], targets[:, -1]\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.output_to_rotated_target","title":"<code>ultralytics.utils.plotting.output_to_rotated_target(output, max_det=300)</code>","text":"<p>Convert model output to target format [batch_id, class_id, x, y, w, h, conf] for plotting.</p> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>def output_to_rotated_target(output, max_det=300):\n    \"\"\"Convert model output to target format [batch_id, class_id, x, y, w, h, conf] for plotting.\"\"\"\n    targets = []\n    for i, o in enumerate(output):\n        box, conf, cls, angle = o[:max_det].cpu().split((4, 1, 1, 1), 1)\n        j = torch.full((conf.shape[0], 1), i)\n        targets.append(torch.cat((j, cls, box, angle, conf), 1))\n    targets = torch.cat(targets, 0).numpy()\n    return targets[:, 0], targets[:, 1], targets[:, 2:-1], targets[:, -1]\n</code></pre>"},{"location":"reference/utils/plotting/#ultralytics.utils.plotting.feature_visualization","title":"<code>ultralytics.utils.plotting.feature_visualization(x, module_type, stage, n=32, save_dir=Path('runs/detect/exp'))</code>","text":"<p>Visualize feature maps of a given model module during inference.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>Features to be visualized.</p> required <code>module_type</code> <code>str</code> <p>Module type.</p> required <code>stage</code> <code>int</code> <p>Module stage within the model.</p> required <code>n</code> <code>int</code> <p>Maximum number of feature maps to plot. Defaults to 32.</p> <code>32</code> <code>save_dir</code> <code>Path</code> <p>Directory to save results. Defaults to Path('runs/detect/exp').</p> <code>Path('runs/detect/exp')</code> Source code in <code>ultralytics/utils/plotting.py</code> <pre><code>def feature_visualization(x, module_type, stage, n=32, save_dir=Path(\"runs/detect/exp\")):\n    \"\"\"\n    Visualize feature maps of a given model module during inference.\n\n    Args:\n        x (torch.Tensor): Features to be visualized.\n        module_type (str): Module type.\n        stage (int): Module stage within the model.\n        n (int, optional): Maximum number of feature maps to plot. Defaults to 32.\n        save_dir (Path, optional): Directory to save results. Defaults to Path('runs/detect/exp').\n    \"\"\"\n    for m in [\"Detect\", \"Pose\", \"Segment\"]:\n        if m in module_type:\n            return\n    batch, channels, height, width = x.shape  # batch, channels, height, width\n    if height &gt; 1 and width &gt; 1:\n        f = save_dir / f\"stage{stage}_{module_type.split('.')[-1]}_features.png\"  # filename\n\n        blocks = torch.chunk(x[0].cpu(), channels, dim=0)  # select batch index 0, block by channels\n        n = min(n, channels)  # number of plots\n        fig, ax = plt.subplots(math.ceil(n / 8), 8, tight_layout=True)  # 8 rows x n/8 cols\n        ax = ax.ravel()\n        plt.subplots_adjust(wspace=0.05, hspace=0.05)\n        for i in range(n):\n            ax[i].imshow(blocks[i].squeeze())  # cmap='gray'\n            ax[i].axis(\"off\")\n\n        LOGGER.info(f\"Saving {f}... ({n}/{channels})\")\n        plt.savefig(f, dpi=300, bbox_inches=\"tight\")\n        plt.close()\n        np.save(str(f.with_suffix(\".npy\")), x[0].cpu().numpy())  # npy save\n</code></pre>"},{"location":"reference/utils/tal/","title":"Reference for <code>ultralytics/utils/tal.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/tal.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/tal/#ultralytics.utils.tal.TaskAlignedAssigner","title":"<code>ultralytics.utils.tal.TaskAlignedAssigner</code>","text":"<p>             Bases: <code>Module</code></p> <p>A task-aligned assigner for object detection.</p> <p>This class assigns ground-truth (gt) objects to anchors based on the task-aligned metric, which combines both classification and localization information.</p> <p>Attributes:</p> Name Type Description <code>topk</code> <code>int</code> <p>The number of top candidates to consider.</p> <code>num_classes</code> <code>int</code> <p>The number of object classes.</p> <code>alpha</code> <code>float</code> <p>The alpha parameter for the classification component of the task-aligned metric.</p> <code>beta</code> <code>float</code> <p>The beta parameter for the localization component of the task-aligned metric.</p> <code>eps</code> <code>float</code> <p>A small value to prevent division by zero.</p> Source code in <code>ultralytics/utils/tal.py</code> <pre><code>class TaskAlignedAssigner(nn.Module):\n    \"\"\"\n    A task-aligned assigner for object detection.\n\n    This class assigns ground-truth (gt) objects to anchors based on the task-aligned metric, which combines both\n    classification and localization information.\n\n    Attributes:\n        topk (int): The number of top candidates to consider.\n        num_classes (int): The number of object classes.\n        alpha (float): The alpha parameter for the classification component of the task-aligned metric.\n        beta (float): The beta parameter for the localization component of the task-aligned metric.\n        eps (float): A small value to prevent division by zero.\n    \"\"\"\n\n    def __init__(self, topk=13, num_classes=80, alpha=1.0, beta=6.0, eps=1e-9):\n        \"\"\"Initialize a TaskAlignedAssigner object with customizable hyperparameters.\"\"\"\n        super().__init__()\n        self.topk = topk\n        self.num_classes = num_classes\n        self.bg_idx = num_classes\n        self.alpha = alpha\n        self.beta = beta\n        self.eps = eps\n\n    @torch.no_grad()\n    def forward(self, pd_scores, pd_bboxes, anc_points, gt_labels, gt_bboxes, mask_gt):\n        \"\"\"\n        Compute the task-aligned assignment. Reference code is available at\n        https://github.com/Nioolek/PPYOLOE_pytorch/blob/master/ppyoloe/assigner/tal_assigner.py.\n\n        Args:\n            pd_scores (Tensor): shape(bs, num_total_anchors, num_classes)\n            pd_bboxes (Tensor): shape(bs, num_total_anchors, 4)\n            anc_points (Tensor): shape(num_total_anchors, 2)\n            gt_labels (Tensor): shape(bs, n_max_boxes, 1)\n            gt_bboxes (Tensor): shape(bs, n_max_boxes, 4)\n            mask_gt (Tensor): shape(bs, n_max_boxes, 1)\n\n        Returns:\n            target_labels (Tensor): shape(bs, num_total_anchors)\n            target_bboxes (Tensor): shape(bs, num_total_anchors, 4)\n            target_scores (Tensor): shape(bs, num_total_anchors, num_classes)\n            fg_mask (Tensor): shape(bs, num_total_anchors)\n            target_gt_idx (Tensor): shape(bs, num_total_anchors)\n        \"\"\"\n        self.bs = pd_scores.size(0)\n        self.n_max_boxes = gt_bboxes.size(1)\n\n        if self.n_max_boxes == 0:\n            device = gt_bboxes.device\n            return (\n                torch.full_like(pd_scores[..., 0], self.bg_idx).to(device),\n                torch.zeros_like(pd_bboxes).to(device),\n                torch.zeros_like(pd_scores).to(device),\n                torch.zeros_like(pd_scores[..., 0]).to(device),\n                torch.zeros_like(pd_scores[..., 0]).to(device),\n            )\n\n        mask_pos, align_metric, overlaps = self.get_pos_mask(\n            pd_scores, pd_bboxes, gt_labels, gt_bboxes, anc_points, mask_gt\n        )\n\n        target_gt_idx, fg_mask, mask_pos = self.select_highest_overlaps(mask_pos, overlaps, self.n_max_boxes)\n\n        # Assigned target\n        target_labels, target_bboxes, target_scores = self.get_targets(gt_labels, gt_bboxes, target_gt_idx, fg_mask)\n\n        # Normalize\n        align_metric *= mask_pos\n        pos_align_metrics = align_metric.amax(dim=-1, keepdim=True)  # b, max_num_obj\n        pos_overlaps = (overlaps * mask_pos).amax(dim=-1, keepdim=True)  # b, max_num_obj\n        norm_align_metric = (align_metric * pos_overlaps / (pos_align_metrics + self.eps)).amax(-2).unsqueeze(-1)\n        target_scores = target_scores * norm_align_metric\n\n        return target_labels, target_bboxes, target_scores, fg_mask.bool(), target_gt_idx\n\n    def get_pos_mask(self, pd_scores, pd_bboxes, gt_labels, gt_bboxes, anc_points, mask_gt):\n        \"\"\"Get in_gts mask, (b, max_num_obj, h*w).\"\"\"\n        mask_in_gts = self.select_candidates_in_gts(anc_points, gt_bboxes)\n        # Get anchor_align metric, (b, max_num_obj, h*w)\n        align_metric, overlaps = self.get_box_metrics(pd_scores, pd_bboxes, gt_labels, gt_bboxes, mask_in_gts * mask_gt)\n        # Get topk_metric mask, (b, max_num_obj, h*w)\n        mask_topk = self.select_topk_candidates(align_metric, topk_mask=mask_gt.expand(-1, -1, self.topk).bool())\n        # Merge all mask to a final mask, (b, max_num_obj, h*w)\n        mask_pos = mask_topk * mask_in_gts * mask_gt\n\n        return mask_pos, align_metric, overlaps\n\n    def get_box_metrics(self, pd_scores, pd_bboxes, gt_labels, gt_bboxes, mask_gt):\n        \"\"\"Compute alignment metric given predicted and ground truth bounding boxes.\"\"\"\n        na = pd_bboxes.shape[-2]\n        mask_gt = mask_gt.bool()  # b, max_num_obj, h*w\n        overlaps = torch.zeros([self.bs, self.n_max_boxes, na], dtype=pd_bboxes.dtype, device=pd_bboxes.device)\n        bbox_scores = torch.zeros([self.bs, self.n_max_boxes, na], dtype=pd_scores.dtype, device=pd_scores.device)\n\n        ind = torch.zeros([2, self.bs, self.n_max_boxes], dtype=torch.long)  # 2, b, max_num_obj\n        ind[0] = torch.arange(end=self.bs).view(-1, 1).expand(-1, self.n_max_boxes)  # b, max_num_obj\n        ind[1] = gt_labels.squeeze(-1)  # b, max_num_obj\n        # Get the scores of each grid for each gt cls\n        bbox_scores[mask_gt] = pd_scores[ind[0], :, ind[1]][mask_gt]  # b, max_num_obj, h*w\n\n        # (b, max_num_obj, 1, 4), (b, 1, h*w, 4)\n        pd_boxes = pd_bboxes.unsqueeze(1).expand(-1, self.n_max_boxes, -1, -1)[mask_gt]\n        gt_boxes = gt_bboxes.unsqueeze(2).expand(-1, -1, na, -1)[mask_gt]\n        overlaps[mask_gt] = self.iou_calculation(gt_boxes, pd_boxes)\n\n        align_metric = bbox_scores.pow(self.alpha) * overlaps.pow(self.beta)\n        return align_metric, overlaps\n\n    def iou_calculation(self, gt_bboxes, pd_bboxes):\n        \"\"\"Iou calculation for horizontal bounding boxes.\"\"\"\n        return bbox_iou(gt_bboxes, pd_bboxes, xywh=False, CIoU=True).squeeze(-1).clamp_(0)\n\n    def select_topk_candidates(self, metrics, largest=True, topk_mask=None):\n        \"\"\"\n        Select the top-k candidates based on the given metrics.\n\n        Args:\n            metrics (Tensor): A tensor of shape (b, max_num_obj, h*w), where b is the batch size,\n                              max_num_obj is the maximum number of objects, and h*w represents the\n                              total number of anchor points.\n            largest (bool): If True, select the largest values; otherwise, select the smallest values.\n            topk_mask (Tensor): An optional boolean tensor of shape (b, max_num_obj, topk), where\n                                topk is the number of top candidates to consider. If not provided,\n                                the top-k values are automatically computed based on the given metrics.\n\n        Returns:\n            (Tensor): A tensor of shape (b, max_num_obj, h*w) containing the selected top-k candidates.\n        \"\"\"\n\n        # (b, max_num_obj, topk)\n        topk_metrics, topk_idxs = torch.topk(metrics, self.topk, dim=-1, largest=largest)\n        if topk_mask is None:\n            topk_mask = (topk_metrics.max(-1, keepdim=True)[0] &gt; self.eps).expand_as(topk_idxs)\n        # (b, max_num_obj, topk)\n        topk_idxs.masked_fill_(~topk_mask, 0)\n\n        # (b, max_num_obj, topk, h*w) -&gt; (b, max_num_obj, h*w)\n        count_tensor = torch.zeros(metrics.shape, dtype=torch.int8, device=topk_idxs.device)\n        ones = torch.ones_like(topk_idxs[:, :, :1], dtype=torch.int8, device=topk_idxs.device)\n        for k in range(self.topk):\n            # Expand topk_idxs for each value of k and add 1 at the specified positions\n            count_tensor.scatter_add_(-1, topk_idxs[:, :, k : k + 1], ones)\n        # count_tensor.scatter_add_(-1, topk_idxs, torch.ones_like(topk_idxs, dtype=torch.int8, device=topk_idxs.device))\n        # Filter invalid bboxes\n        count_tensor.masked_fill_(count_tensor &gt; 1, 0)\n\n        return count_tensor.to(metrics.dtype)\n\n    def get_targets(self, gt_labels, gt_bboxes, target_gt_idx, fg_mask):\n        \"\"\"\n        Compute target labels, target bounding boxes, and target scores for the positive anchor points.\n\n        Args:\n            gt_labels (Tensor): Ground truth labels of shape (b, max_num_obj, 1), where b is the\n                                batch size and max_num_obj is the maximum number of objects.\n            gt_bboxes (Tensor): Ground truth bounding boxes of shape (b, max_num_obj, 4).\n            target_gt_idx (Tensor): Indices of the assigned ground truth objects for positive\n                                    anchor points, with shape (b, h*w), where h*w is the total\n                                    number of anchor points.\n            fg_mask (Tensor): A boolean tensor of shape (b, h*w) indicating the positive\n                              (foreground) anchor points.\n\n        Returns:\n            (Tuple[Tensor, Tensor, Tensor]): A tuple containing the following tensors:\n                - target_labels (Tensor): Shape (b, h*w), containing the target labels for\n                                          positive anchor points.\n                - target_bboxes (Tensor): Shape (b, h*w, 4), containing the target bounding boxes\n                                          for positive anchor points.\n                - target_scores (Tensor): Shape (b, h*w, num_classes), containing the target scores\n                                          for positive anchor points, where num_classes is the number\n                                          of object classes.\n        \"\"\"\n\n        # Assigned target labels, (b, 1)\n        batch_ind = torch.arange(end=self.bs, dtype=torch.int64, device=gt_labels.device)[..., None]\n        target_gt_idx = target_gt_idx + batch_ind * self.n_max_boxes  # (b, h*w)\n        target_labels = gt_labels.long().flatten()[target_gt_idx]  # (b, h*w)\n\n        # Assigned target boxes, (b, max_num_obj, 4) -&gt; (b, h*w, 4)\n        target_bboxes = gt_bboxes.view(-1, gt_bboxes.shape[-1])[target_gt_idx]\n\n        # Assigned target scores\n        target_labels.clamp_(0)\n\n        # 10x faster than F.one_hot()\n        target_scores = torch.zeros(\n            (target_labels.shape[0], target_labels.shape[1], self.num_classes),\n            dtype=torch.int64,\n            device=target_labels.device,\n        )  # (b, h*w, 80)\n        target_scores.scatter_(2, target_labels.unsqueeze(-1), 1)\n\n        fg_scores_mask = fg_mask[:, :, None].repeat(1, 1, self.num_classes)  # (b, h*w, 80)\n        target_scores = torch.where(fg_scores_mask &gt; 0, target_scores, 0)\n\n        return target_labels, target_bboxes, target_scores\n\n    @staticmethod\n    def select_candidates_in_gts(xy_centers, gt_bboxes, eps=1e-9):\n        \"\"\"\n        Select the positive anchor center in gt.\n\n        Args:\n            xy_centers (Tensor): shape(h*w, 2)\n            gt_bboxes (Tensor): shape(b, n_boxes, 4)\n\n        Returns:\n            (Tensor): shape(b, n_boxes, h*w)\n        \"\"\"\n        n_anchors = xy_centers.shape[0]\n        bs, n_boxes, _ = gt_bboxes.shape\n        lt, rb = gt_bboxes.view(-1, 1, 4).chunk(2, 2)  # left-top, right-bottom\n        bbox_deltas = torch.cat((xy_centers[None] - lt, rb - xy_centers[None]), dim=2).view(bs, n_boxes, n_anchors, -1)\n        # return (bbox_deltas.min(3)[0] &gt; eps).to(gt_bboxes.dtype)\n        return bbox_deltas.amin(3).gt_(eps)\n\n    @staticmethod\n    def select_highest_overlaps(mask_pos, overlaps, n_max_boxes):\n        \"\"\"\n        If an anchor box is assigned to multiple gts, the one with the highest IoI will be selected.\n\n        Args:\n            mask_pos (Tensor): shape(b, n_max_boxes, h*w)\n            overlaps (Tensor): shape(b, n_max_boxes, h*w)\n\n        Returns:\n            target_gt_idx (Tensor): shape(b, h*w)\n            fg_mask (Tensor): shape(b, h*w)\n            mask_pos (Tensor): shape(b, n_max_boxes, h*w)\n        \"\"\"\n        # (b, n_max_boxes, h*w) -&gt; (b, h*w)\n        fg_mask = mask_pos.sum(-2)\n        if fg_mask.max() &gt; 1:  # one anchor is assigned to multiple gt_bboxes\n            mask_multi_gts = (fg_mask.unsqueeze(1) &gt; 1).expand(-1, n_max_boxes, -1)  # (b, n_max_boxes, h*w)\n            max_overlaps_idx = overlaps.argmax(1)  # (b, h*w)\n\n            is_max_overlaps = torch.zeros(mask_pos.shape, dtype=mask_pos.dtype, device=mask_pos.device)\n            is_max_overlaps.scatter_(1, max_overlaps_idx.unsqueeze(1), 1)\n\n            mask_pos = torch.where(mask_multi_gts, is_max_overlaps, mask_pos).float()  # (b, n_max_boxes, h*w)\n            fg_mask = mask_pos.sum(-2)\n        # Find each grid serve which gt(index)\n        target_gt_idx = mask_pos.argmax(-2)  # (b, h*w)\n        return target_gt_idx, fg_mask, mask_pos\n</code></pre>"},{"location":"reference/utils/tal/#ultralytics.utils.tal.TaskAlignedAssigner.__init__","title":"<code>__init__(topk=13, num_classes=80, alpha=1.0, beta=6.0, eps=1e-09)</code>","text":"<p>Initialize a TaskAlignedAssigner object with customizable hyperparameters.</p> Source code in <code>ultralytics/utils/tal.py</code> <pre><code>def __init__(self, topk=13, num_classes=80, alpha=1.0, beta=6.0, eps=1e-9):\n    \"\"\"Initialize a TaskAlignedAssigner object with customizable hyperparameters.\"\"\"\n    super().__init__()\n    self.topk = topk\n    self.num_classes = num_classes\n    self.bg_idx = num_classes\n    self.alpha = alpha\n    self.beta = beta\n    self.eps = eps\n</code></pre>"},{"location":"reference/utils/tal/#ultralytics.utils.tal.TaskAlignedAssigner.forward","title":"<code>forward(pd_scores, pd_bboxes, anc_points, gt_labels, gt_bboxes, mask_gt)</code>","text":"<p>Compute the task-aligned assignment. Reference code is available at https://github.com/Nioolek/PPYOLOE_pytorch/blob/master/ppyoloe/assigner/tal_assigner.py.</p> <p>Parameters:</p> Name Type Description Default <code>pd_scores</code> <code>Tensor</code> <p>shape(bs, num_total_anchors, num_classes)</p> required <code>pd_bboxes</code> <code>Tensor</code> <p>shape(bs, num_total_anchors, 4)</p> required <code>anc_points</code> <code>Tensor</code> <p>shape(num_total_anchors, 2)</p> required <code>gt_labels</code> <code>Tensor</code> <p>shape(bs, n_max_boxes, 1)</p> required <code>gt_bboxes</code> <code>Tensor</code> <p>shape(bs, n_max_boxes, 4)</p> required <code>mask_gt</code> <code>Tensor</code> <p>shape(bs, n_max_boxes, 1)</p> required <p>Returns:</p> Name Type Description <code>target_labels</code> <code>Tensor</code> <p>shape(bs, num_total_anchors)</p> <code>target_bboxes</code> <code>Tensor</code> <p>shape(bs, num_total_anchors, 4)</p> <code>target_scores</code> <code>Tensor</code> <p>shape(bs, num_total_anchors, num_classes)</p> <code>fg_mask</code> <code>Tensor</code> <p>shape(bs, num_total_anchors)</p> <code>target_gt_idx</code> <code>Tensor</code> <p>shape(bs, num_total_anchors)</p> Source code in <code>ultralytics/utils/tal.py</code> <pre><code>@torch.no_grad()\ndef forward(self, pd_scores, pd_bboxes, anc_points, gt_labels, gt_bboxes, mask_gt):\n    \"\"\"\n    Compute the task-aligned assignment. Reference code is available at\n    https://github.com/Nioolek/PPYOLOE_pytorch/blob/master/ppyoloe/assigner/tal_assigner.py.\n\n    Args:\n        pd_scores (Tensor): shape(bs, num_total_anchors, num_classes)\n        pd_bboxes (Tensor): shape(bs, num_total_anchors, 4)\n        anc_points (Tensor): shape(num_total_anchors, 2)\n        gt_labels (Tensor): shape(bs, n_max_boxes, 1)\n        gt_bboxes (Tensor): shape(bs, n_max_boxes, 4)\n        mask_gt (Tensor): shape(bs, n_max_boxes, 1)\n\n    Returns:\n        target_labels (Tensor): shape(bs, num_total_anchors)\n        target_bboxes (Tensor): shape(bs, num_total_anchors, 4)\n        target_scores (Tensor): shape(bs, num_total_anchors, num_classes)\n        fg_mask (Tensor): shape(bs, num_total_anchors)\n        target_gt_idx (Tensor): shape(bs, num_total_anchors)\n    \"\"\"\n    self.bs = pd_scores.size(0)\n    self.n_max_boxes = gt_bboxes.size(1)\n\n    if self.n_max_boxes == 0:\n        device = gt_bboxes.device\n        return (\n            torch.full_like(pd_scores[..., 0], self.bg_idx).to(device),\n            torch.zeros_like(pd_bboxes).to(device),\n            torch.zeros_like(pd_scores).to(device),\n            torch.zeros_like(pd_scores[..., 0]).to(device),\n            torch.zeros_like(pd_scores[..., 0]).to(device),\n        )\n\n    mask_pos, align_metric, overlaps = self.get_pos_mask(\n        pd_scores, pd_bboxes, gt_labels, gt_bboxes, anc_points, mask_gt\n    )\n\n    target_gt_idx, fg_mask, mask_pos = self.select_highest_overlaps(mask_pos, overlaps, self.n_max_boxes)\n\n    # Assigned target\n    target_labels, target_bboxes, target_scores = self.get_targets(gt_labels, gt_bboxes, target_gt_idx, fg_mask)\n\n    # Normalize\n    align_metric *= mask_pos\n    pos_align_metrics = align_metric.amax(dim=-1, keepdim=True)  # b, max_num_obj\n    pos_overlaps = (overlaps * mask_pos).amax(dim=-1, keepdim=True)  # b, max_num_obj\n    norm_align_metric = (align_metric * pos_overlaps / (pos_align_metrics + self.eps)).amax(-2).unsqueeze(-1)\n    target_scores = target_scores * norm_align_metric\n\n    return target_labels, target_bboxes, target_scores, fg_mask.bool(), target_gt_idx\n</code></pre>"},{"location":"reference/utils/tal/#ultralytics.utils.tal.TaskAlignedAssigner.get_box_metrics","title":"<code>get_box_metrics(pd_scores, pd_bboxes, gt_labels, gt_bboxes, mask_gt)</code>","text":"<p>Compute alignment metric given predicted and ground truth bounding boxes.</p> Source code in <code>ultralytics/utils/tal.py</code> <pre><code>def get_box_metrics(self, pd_scores, pd_bboxes, gt_labels, gt_bboxes, mask_gt):\n    \"\"\"Compute alignment metric given predicted and ground truth bounding boxes.\"\"\"\n    na = pd_bboxes.shape[-2]\n    mask_gt = mask_gt.bool()  # b, max_num_obj, h*w\n    overlaps = torch.zeros([self.bs, self.n_max_boxes, na], dtype=pd_bboxes.dtype, device=pd_bboxes.device)\n    bbox_scores = torch.zeros([self.bs, self.n_max_boxes, na], dtype=pd_scores.dtype, device=pd_scores.device)\n\n    ind = torch.zeros([2, self.bs, self.n_max_boxes], dtype=torch.long)  # 2, b, max_num_obj\n    ind[0] = torch.arange(end=self.bs).view(-1, 1).expand(-1, self.n_max_boxes)  # b, max_num_obj\n    ind[1] = gt_labels.squeeze(-1)  # b, max_num_obj\n    # Get the scores of each grid for each gt cls\n    bbox_scores[mask_gt] = pd_scores[ind[0], :, ind[1]][mask_gt]  # b, max_num_obj, h*w\n\n    # (b, max_num_obj, 1, 4), (b, 1, h*w, 4)\n    pd_boxes = pd_bboxes.unsqueeze(1).expand(-1, self.n_max_boxes, -1, -1)[mask_gt]\n    gt_boxes = gt_bboxes.unsqueeze(2).expand(-1, -1, na, -1)[mask_gt]\n    overlaps[mask_gt] = self.iou_calculation(gt_boxes, pd_boxes)\n\n    align_metric = bbox_scores.pow(self.alpha) * overlaps.pow(self.beta)\n    return align_metric, overlaps\n</code></pre>"},{"location":"reference/utils/tal/#ultralytics.utils.tal.TaskAlignedAssigner.get_pos_mask","title":"<code>get_pos_mask(pd_scores, pd_bboxes, gt_labels, gt_bboxes, anc_points, mask_gt)</code>","text":"<p>Get in_gts mask, (b, max_num_obj, h*w).</p> Source code in <code>ultralytics/utils/tal.py</code> <pre><code>def get_pos_mask(self, pd_scores, pd_bboxes, gt_labels, gt_bboxes, anc_points, mask_gt):\n    \"\"\"Get in_gts mask, (b, max_num_obj, h*w).\"\"\"\n    mask_in_gts = self.select_candidates_in_gts(anc_points, gt_bboxes)\n    # Get anchor_align metric, (b, max_num_obj, h*w)\n    align_metric, overlaps = self.get_box_metrics(pd_scores, pd_bboxes, gt_labels, gt_bboxes, mask_in_gts * mask_gt)\n    # Get topk_metric mask, (b, max_num_obj, h*w)\n    mask_topk = self.select_topk_candidates(align_metric, topk_mask=mask_gt.expand(-1, -1, self.topk).bool())\n    # Merge all mask to a final mask, (b, max_num_obj, h*w)\n    mask_pos = mask_topk * mask_in_gts * mask_gt\n\n    return mask_pos, align_metric, overlaps\n</code></pre>"},{"location":"reference/utils/tal/#ultralytics.utils.tal.TaskAlignedAssigner.get_targets","title":"<code>get_targets(gt_labels, gt_bboxes, target_gt_idx, fg_mask)</code>","text":"<p>Compute target labels, target bounding boxes, and target scores for the positive anchor points.</p> <p>Parameters:</p> Name Type Description Default <code>gt_labels</code> <code>Tensor</code> <p>Ground truth labels of shape (b, max_num_obj, 1), where b is the                 batch size and max_num_obj is the maximum number of objects.</p> required <code>gt_bboxes</code> <code>Tensor</code> <p>Ground truth bounding boxes of shape (b, max_num_obj, 4).</p> required <code>target_gt_idx</code> <code>Tensor</code> <p>Indices of the assigned ground truth objects for positive                     anchor points, with shape (b, hw), where hw is the total                     number of anchor points.</p> required <code>fg_mask</code> <code>Tensor</code> <p>A boolean tensor of shape (b, h*w) indicating the positive               (foreground) anchor points.</p> required <p>Returns:</p> Type Description <code>Tuple[Tensor, Tensor, Tensor]</code> <p>A tuple containing the following tensors: - target_labels (Tensor): Shape (b, hw), containing the target labels for                           positive anchor points. - target_bboxes (Tensor): Shape (b, hw, 4), containing the target bounding boxes                           for positive anchor points. - target_scores (Tensor): Shape (b, h*w, num_classes), containing the target scores                           for positive anchor points, where num_classes is the number                           of object classes.</p> Source code in <code>ultralytics/utils/tal.py</code> <pre><code>def get_targets(self, gt_labels, gt_bboxes, target_gt_idx, fg_mask):\n    \"\"\"\n    Compute target labels, target bounding boxes, and target scores for the positive anchor points.\n\n    Args:\n        gt_labels (Tensor): Ground truth labels of shape (b, max_num_obj, 1), where b is the\n                            batch size and max_num_obj is the maximum number of objects.\n        gt_bboxes (Tensor): Ground truth bounding boxes of shape (b, max_num_obj, 4).\n        target_gt_idx (Tensor): Indices of the assigned ground truth objects for positive\n                                anchor points, with shape (b, h*w), where h*w is the total\n                                number of anchor points.\n        fg_mask (Tensor): A boolean tensor of shape (b, h*w) indicating the positive\n                          (foreground) anchor points.\n\n    Returns:\n        (Tuple[Tensor, Tensor, Tensor]): A tuple containing the following tensors:\n            - target_labels (Tensor): Shape (b, h*w), containing the target labels for\n                                      positive anchor points.\n            - target_bboxes (Tensor): Shape (b, h*w, 4), containing the target bounding boxes\n                                      for positive anchor points.\n            - target_scores (Tensor): Shape (b, h*w, num_classes), containing the target scores\n                                      for positive anchor points, where num_classes is the number\n                                      of object classes.\n    \"\"\"\n\n    # Assigned target labels, (b, 1)\n    batch_ind = torch.arange(end=self.bs, dtype=torch.int64, device=gt_labels.device)[..., None]\n    target_gt_idx = target_gt_idx + batch_ind * self.n_max_boxes  # (b, h*w)\n    target_labels = gt_labels.long().flatten()[target_gt_idx]  # (b, h*w)\n\n    # Assigned target boxes, (b, max_num_obj, 4) -&gt; (b, h*w, 4)\n    target_bboxes = gt_bboxes.view(-1, gt_bboxes.shape[-1])[target_gt_idx]\n\n    # Assigned target scores\n    target_labels.clamp_(0)\n\n    # 10x faster than F.one_hot()\n    target_scores = torch.zeros(\n        (target_labels.shape[0], target_labels.shape[1], self.num_classes),\n        dtype=torch.int64,\n        device=target_labels.device,\n    )  # (b, h*w, 80)\n    target_scores.scatter_(2, target_labels.unsqueeze(-1), 1)\n\n    fg_scores_mask = fg_mask[:, :, None].repeat(1, 1, self.num_classes)  # (b, h*w, 80)\n    target_scores = torch.where(fg_scores_mask &gt; 0, target_scores, 0)\n\n    return target_labels, target_bboxes, target_scores\n</code></pre>"},{"location":"reference/utils/tal/#ultralytics.utils.tal.TaskAlignedAssigner.iou_calculation","title":"<code>iou_calculation(gt_bboxes, pd_bboxes)</code>","text":"<p>Iou calculation for horizontal bounding boxes.</p> Source code in <code>ultralytics/utils/tal.py</code> <pre><code>def iou_calculation(self, gt_bboxes, pd_bboxes):\n    \"\"\"Iou calculation for horizontal bounding boxes.\"\"\"\n    return bbox_iou(gt_bboxes, pd_bboxes, xywh=False, CIoU=True).squeeze(-1).clamp_(0)\n</code></pre>"},{"location":"reference/utils/tal/#ultralytics.utils.tal.TaskAlignedAssigner.select_candidates_in_gts","title":"<code>select_candidates_in_gts(xy_centers, gt_bboxes, eps=1e-09)</code>  <code>staticmethod</code>","text":"<p>Select the positive anchor center in gt.</p> <p>Parameters:</p> Name Type Description Default <code>xy_centers</code> <code>Tensor</code> <p>shape(h*w, 2)</p> required <code>gt_bboxes</code> <code>Tensor</code> <p>shape(b, n_boxes, 4)</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>shape(b, n_boxes, h*w)</p> Source code in <code>ultralytics/utils/tal.py</code> <pre><code>@staticmethod\ndef select_candidates_in_gts(xy_centers, gt_bboxes, eps=1e-9):\n    \"\"\"\n    Select the positive anchor center in gt.\n\n    Args:\n        xy_centers (Tensor): shape(h*w, 2)\n        gt_bboxes (Tensor): shape(b, n_boxes, 4)\n\n    Returns:\n        (Tensor): shape(b, n_boxes, h*w)\n    \"\"\"\n    n_anchors = xy_centers.shape[0]\n    bs, n_boxes, _ = gt_bboxes.shape\n    lt, rb = gt_bboxes.view(-1, 1, 4).chunk(2, 2)  # left-top, right-bottom\n    bbox_deltas = torch.cat((xy_centers[None] - lt, rb - xy_centers[None]), dim=2).view(bs, n_boxes, n_anchors, -1)\n    # return (bbox_deltas.min(3)[0] &gt; eps).to(gt_bboxes.dtype)\n    return bbox_deltas.amin(3).gt_(eps)\n</code></pre>"},{"location":"reference/utils/tal/#ultralytics.utils.tal.TaskAlignedAssigner.select_highest_overlaps","title":"<code>select_highest_overlaps(mask_pos, overlaps, n_max_boxes)</code>  <code>staticmethod</code>","text":"<p>If an anchor box is assigned to multiple gts, the one with the highest IoI will be selected.</p> <p>Parameters:</p> Name Type Description Default <code>mask_pos</code> <code>Tensor</code> <p>shape(b, n_max_boxes, h*w)</p> required <code>overlaps</code> <code>Tensor</code> <p>shape(b, n_max_boxes, h*w)</p> required <p>Returns:</p> Name Type Description <code>target_gt_idx</code> <code>Tensor</code> <p>shape(b, h*w)</p> <code>fg_mask</code> <code>Tensor</code> <p>shape(b, h*w)</p> <code>mask_pos</code> <code>Tensor</code> <p>shape(b, n_max_boxes, h*w)</p> Source code in <code>ultralytics/utils/tal.py</code> <pre><code>@staticmethod\ndef select_highest_overlaps(mask_pos, overlaps, n_max_boxes):\n    \"\"\"\n    If an anchor box is assigned to multiple gts, the one with the highest IoI will be selected.\n\n    Args:\n        mask_pos (Tensor): shape(b, n_max_boxes, h*w)\n        overlaps (Tensor): shape(b, n_max_boxes, h*w)\n\n    Returns:\n        target_gt_idx (Tensor): shape(b, h*w)\n        fg_mask (Tensor): shape(b, h*w)\n        mask_pos (Tensor): shape(b, n_max_boxes, h*w)\n    \"\"\"\n    # (b, n_max_boxes, h*w) -&gt; (b, h*w)\n    fg_mask = mask_pos.sum(-2)\n    if fg_mask.max() &gt; 1:  # one anchor is assigned to multiple gt_bboxes\n        mask_multi_gts = (fg_mask.unsqueeze(1) &gt; 1).expand(-1, n_max_boxes, -1)  # (b, n_max_boxes, h*w)\n        max_overlaps_idx = overlaps.argmax(1)  # (b, h*w)\n\n        is_max_overlaps = torch.zeros(mask_pos.shape, dtype=mask_pos.dtype, device=mask_pos.device)\n        is_max_overlaps.scatter_(1, max_overlaps_idx.unsqueeze(1), 1)\n\n        mask_pos = torch.where(mask_multi_gts, is_max_overlaps, mask_pos).float()  # (b, n_max_boxes, h*w)\n        fg_mask = mask_pos.sum(-2)\n    # Find each grid serve which gt(index)\n    target_gt_idx = mask_pos.argmax(-2)  # (b, h*w)\n    return target_gt_idx, fg_mask, mask_pos\n</code></pre>"},{"location":"reference/utils/tal/#ultralytics.utils.tal.TaskAlignedAssigner.select_topk_candidates","title":"<code>select_topk_candidates(metrics, largest=True, topk_mask=None)</code>","text":"<p>Select the top-k candidates based on the given metrics.</p> <p>Parameters:</p> Name Type Description Default <code>metrics</code> <code>Tensor</code> <p>A tensor of shape (b, max_num_obj, hw), where b is the batch size,               max_num_obj is the maximum number of objects, and hw represents the               total number of anchor points.</p> required <code>largest</code> <code>bool</code> <p>If True, select the largest values; otherwise, select the smallest values.</p> <code>True</code> <code>topk_mask</code> <code>Tensor</code> <p>An optional boolean tensor of shape (b, max_num_obj, topk), where                 topk is the number of top candidates to consider. If not provided,                 the top-k values are automatically computed based on the given metrics.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>A tensor of shape (b, max_num_obj, h*w) containing the selected top-k candidates.</p> Source code in <code>ultralytics/utils/tal.py</code> <pre><code>def select_topk_candidates(self, metrics, largest=True, topk_mask=None):\n    \"\"\"\n    Select the top-k candidates based on the given metrics.\n\n    Args:\n        metrics (Tensor): A tensor of shape (b, max_num_obj, h*w), where b is the batch size,\n                          max_num_obj is the maximum number of objects, and h*w represents the\n                          total number of anchor points.\n        largest (bool): If True, select the largest values; otherwise, select the smallest values.\n        topk_mask (Tensor): An optional boolean tensor of shape (b, max_num_obj, topk), where\n                            topk is the number of top candidates to consider. If not provided,\n                            the top-k values are automatically computed based on the given metrics.\n\n    Returns:\n        (Tensor): A tensor of shape (b, max_num_obj, h*w) containing the selected top-k candidates.\n    \"\"\"\n\n    # (b, max_num_obj, topk)\n    topk_metrics, topk_idxs = torch.topk(metrics, self.topk, dim=-1, largest=largest)\n    if topk_mask is None:\n        topk_mask = (topk_metrics.max(-1, keepdim=True)[0] &gt; self.eps).expand_as(topk_idxs)\n    # (b, max_num_obj, topk)\n    topk_idxs.masked_fill_(~topk_mask, 0)\n\n    # (b, max_num_obj, topk, h*w) -&gt; (b, max_num_obj, h*w)\n    count_tensor = torch.zeros(metrics.shape, dtype=torch.int8, device=topk_idxs.device)\n    ones = torch.ones_like(topk_idxs[:, :, :1], dtype=torch.int8, device=topk_idxs.device)\n    for k in range(self.topk):\n        # Expand topk_idxs for each value of k and add 1 at the specified positions\n        count_tensor.scatter_add_(-1, topk_idxs[:, :, k : k + 1], ones)\n    # count_tensor.scatter_add_(-1, topk_idxs, torch.ones_like(topk_idxs, dtype=torch.int8, device=topk_idxs.device))\n    # Filter invalid bboxes\n    count_tensor.masked_fill_(count_tensor &gt; 1, 0)\n\n    return count_tensor.to(metrics.dtype)\n</code></pre>"},{"location":"reference/utils/tal/#ultralytics.utils.tal.RotatedTaskAlignedAssigner","title":"<code>ultralytics.utils.tal.RotatedTaskAlignedAssigner</code>","text":"<p>             Bases: <code>TaskAlignedAssigner</code></p> Source code in <code>ultralytics/utils/tal.py</code> <pre><code>class RotatedTaskAlignedAssigner(TaskAlignedAssigner):\n    def iou_calculation(self, gt_bboxes, pd_bboxes):\n        \"\"\"Iou calculation for rotated bounding boxes.\"\"\"\n        return probiou(gt_bboxes, pd_bboxes).squeeze(-1).clamp_(0)\n\n    @staticmethod\n    def select_candidates_in_gts(xy_centers, gt_bboxes):\n        \"\"\"\n        Select the positive anchor center in gt for rotated bounding boxes.\n\n        Args:\n            xy_centers (Tensor): shape(h*w, 2)\n            gt_bboxes (Tensor): shape(b, n_boxes, 5)\n\n        Returns:\n            (Tensor): shape(b, n_boxes, h*w)\n        \"\"\"\n        # (b, n_boxes, 5) --&gt; (b, n_boxes, 4, 2)\n        corners = xywhr2xyxyxyxy(gt_bboxes)\n        # (b, n_boxes, 1, 2)\n        a, b, _, d = corners.split(1, dim=-2)\n        ab = b - a\n        ad = d - a\n\n        # (b, n_boxes, h*w, 2)\n        ap = xy_centers - a\n        norm_ab = (ab * ab).sum(dim=-1)\n        norm_ad = (ad * ad).sum(dim=-1)\n        ap_dot_ab = (ap * ab).sum(dim=-1)\n        ap_dot_ad = (ap * ad).sum(dim=-1)\n        is_in_box = (ap_dot_ab &gt;= 0) &amp; (ap_dot_ab &lt;= norm_ab) &amp; (ap_dot_ad &gt;= 0) &amp; (ap_dot_ad &lt;= norm_ad)\n        return is_in_box\n</code></pre>"},{"location":"reference/utils/tal/#ultralytics.utils.tal.RotatedTaskAlignedAssigner.iou_calculation","title":"<code>iou_calculation(gt_bboxes, pd_bboxes)</code>","text":"<p>Iou calculation for rotated bounding boxes.</p> Source code in <code>ultralytics/utils/tal.py</code> <pre><code>def iou_calculation(self, gt_bboxes, pd_bboxes):\n    \"\"\"Iou calculation for rotated bounding boxes.\"\"\"\n    return probiou(gt_bboxes, pd_bboxes).squeeze(-1).clamp_(0)\n</code></pre>"},{"location":"reference/utils/tal/#ultralytics.utils.tal.RotatedTaskAlignedAssigner.select_candidates_in_gts","title":"<code>select_candidates_in_gts(xy_centers, gt_bboxes)</code>  <code>staticmethod</code>","text":"<p>Select the positive anchor center in gt for rotated bounding boxes.</p> <p>Parameters:</p> Name Type Description Default <code>xy_centers</code> <code>Tensor</code> <p>shape(h*w, 2)</p> required <code>gt_bboxes</code> <code>Tensor</code> <p>shape(b, n_boxes, 5)</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>shape(b, n_boxes, h*w)</p> Source code in <code>ultralytics/utils/tal.py</code> <pre><code>@staticmethod\ndef select_candidates_in_gts(xy_centers, gt_bboxes):\n    \"\"\"\n    Select the positive anchor center in gt for rotated bounding boxes.\n\n    Args:\n        xy_centers (Tensor): shape(h*w, 2)\n        gt_bboxes (Tensor): shape(b, n_boxes, 5)\n\n    Returns:\n        (Tensor): shape(b, n_boxes, h*w)\n    \"\"\"\n    # (b, n_boxes, 5) --&gt; (b, n_boxes, 4, 2)\n    corners = xywhr2xyxyxyxy(gt_bboxes)\n    # (b, n_boxes, 1, 2)\n    a, b, _, d = corners.split(1, dim=-2)\n    ab = b - a\n    ad = d - a\n\n    # (b, n_boxes, h*w, 2)\n    ap = xy_centers - a\n    norm_ab = (ab * ab).sum(dim=-1)\n    norm_ad = (ad * ad).sum(dim=-1)\n    ap_dot_ab = (ap * ab).sum(dim=-1)\n    ap_dot_ad = (ap * ad).sum(dim=-1)\n    is_in_box = (ap_dot_ab &gt;= 0) &amp; (ap_dot_ab &lt;= norm_ab) &amp; (ap_dot_ad &gt;= 0) &amp; (ap_dot_ad &lt;= norm_ad)\n    return is_in_box\n</code></pre>"},{"location":"reference/utils/tal/#ultralytics.utils.tal.make_anchors","title":"<code>ultralytics.utils.tal.make_anchors(feats, strides, grid_cell_offset=0.5)</code>","text":"<p>Generate anchors from features.</p> Source code in <code>ultralytics/utils/tal.py</code> <pre><code>def make_anchors(feats, strides, grid_cell_offset=0.5):\n    \"\"\"Generate anchors from features.\"\"\"\n    anchor_points, stride_tensor = [], []\n    assert feats is not None\n    dtype, device = feats[0].dtype, feats[0].device\n    for i, stride in enumerate(strides):\n        _, _, h, w = feats[i].shape\n        sx = torch.arange(end=w, device=device, dtype=dtype) + grid_cell_offset  # shift x\n        sy = torch.arange(end=h, device=device, dtype=dtype) + grid_cell_offset  # shift y\n        sy, sx = torch.meshgrid(sy, sx, indexing=\"ij\") if TORCH_1_10 else torch.meshgrid(sy, sx)\n        anchor_points.append(torch.stack((sx, sy), -1).view(-1, 2))\n        stride_tensor.append(torch.full((h * w, 1), stride, dtype=dtype, device=device))\n    return torch.cat(anchor_points), torch.cat(stride_tensor)\n</code></pre>"},{"location":"reference/utils/tal/#ultralytics.utils.tal.dist2bbox","title":"<code>ultralytics.utils.tal.dist2bbox(distance, anchor_points, xywh=True, dim=-1)</code>","text":"<p>Transform distance(ltrb) to box(xywh or xyxy).</p> Source code in <code>ultralytics/utils/tal.py</code> <pre><code>def dist2bbox(distance, anchor_points, xywh=True, dim=-1):\n    \"\"\"Transform distance(ltrb) to box(xywh or xyxy).\"\"\"\n    lt, rb = distance.chunk(2, dim)\n    x1y1 = anchor_points - lt\n    x2y2 = anchor_points + rb\n    if xywh:\n        c_xy = (x1y1 + x2y2) / 2\n        wh = x2y2 - x1y1\n        return torch.cat((c_xy, wh), dim)  # xywh bbox\n    return torch.cat((x1y1, x2y2), dim)  # xyxy bbox\n</code></pre>"},{"location":"reference/utils/tal/#ultralytics.utils.tal.bbox2dist","title":"<code>ultralytics.utils.tal.bbox2dist(anchor_points, bbox, reg_max)</code>","text":"<p>Transform bbox(xyxy) to dist(ltrb).</p> Source code in <code>ultralytics/utils/tal.py</code> <pre><code>def bbox2dist(anchor_points, bbox, reg_max):\n    \"\"\"Transform bbox(xyxy) to dist(ltrb).\"\"\"\n    x1y1, x2y2 = bbox.chunk(2, -1)\n    return torch.cat((anchor_points - x1y1, x2y2 - anchor_points), -1).clamp_(0, reg_max - 0.01)  # dist (lt, rb)\n</code></pre>"},{"location":"reference/utils/tal/#ultralytics.utils.tal.dist2rbox","title":"<code>ultralytics.utils.tal.dist2rbox(pred_dist, pred_angle, anchor_points, dim=-1)</code>","text":"<p>Decode predicted object bounding box coordinates from anchor points and distribution.</p> <p>Parameters:</p> Name Type Description Default <code>pred_dist</code> <code>Tensor</code> <p>Predicted rotated distance, (bs, h*w, 4).</p> required <code>pred_angle</code> <code>Tensor</code> <p>Predicted angle, (bs, h*w, 1).</p> required <code>anchor_points</code> <code>Tensor</code> <p>Anchor points, (h*w, 2).</p> required <p>Returns:     (torch.Tensor): Predicted rotated bounding boxes, (bs, h*w, 4).</p> Source code in <code>ultralytics/utils/tal.py</code> <pre><code>def dist2rbox(pred_dist, pred_angle, anchor_points, dim=-1):\n    \"\"\"\n    Decode predicted object bounding box coordinates from anchor points and distribution.\n\n    Args:\n        pred_dist (torch.Tensor): Predicted rotated distance, (bs, h*w, 4).\n        pred_angle (torch.Tensor): Predicted angle, (bs, h*w, 1).\n        anchor_points (torch.Tensor): Anchor points, (h*w, 2).\n    Returns:\n        (torch.Tensor): Predicted rotated bounding boxes, (bs, h*w, 4).\n    \"\"\"\n    lt, rb = pred_dist.split(2, dim=dim)\n    cos, sin = torch.cos(pred_angle), torch.sin(pred_angle)\n    # (bs, h*w, 1)\n    xf, yf = ((rb - lt) / 2).split(1, dim=dim)\n    x, y = xf * cos - yf * sin, xf * sin + yf * cos\n    xy = torch.cat([x, y], dim=dim) + anchor_points\n    return torch.cat([xy, lt + rb], dim=dim)\n</code></pre>"},{"location":"reference/utils/torch_utils/","title":"Reference for <code>ultralytics/utils/torch_utils.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/torch_utils.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.ModelEMA","title":"<code>ultralytics.utils.torch_utils.ModelEMA</code>","text":"<p>Updated Exponential Moving Average (EMA) from https://github.com/rwightman/pytorch-image-models Keeps a moving average of everything in the model state_dict (parameters and buffers) For EMA details see https://www.tensorflow.org/api_docs/python/tf/train/ExponentialMovingAverage To disable EMA set the <code>enabled</code> attribute to <code>False</code>.</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>class ModelEMA:\n    \"\"\"Updated Exponential Moving Average (EMA) from https://github.com/rwightman/pytorch-image-models\n    Keeps a moving average of everything in the model state_dict (parameters and buffers)\n    For EMA details see https://www.tensorflow.org/api_docs/python/tf/train/ExponentialMovingAverage\n    To disable EMA set the `enabled` attribute to `False`.\n    \"\"\"\n\n    def __init__(self, model, decay=0.9999, tau=2000, updates=0):\n        \"\"\"Create EMA.\"\"\"\n        self.ema = deepcopy(de_parallel(model)).eval()  # FP32 EMA\n        self.updates = updates  # number of EMA updates\n        self.decay = lambda x: decay * (1 - math.exp(-x / tau))  # decay exponential ramp (to help early epochs)\n        for p in self.ema.parameters():\n            p.requires_grad_(False)\n        self.enabled = True\n\n    def update(self, model):\n        \"\"\"Update EMA parameters.\"\"\"\n        if self.enabled:\n            self.updates += 1\n            d = self.decay(self.updates)\n\n            msd = de_parallel(model).state_dict()  # model state_dict\n            for k, v in self.ema.state_dict().items():\n                if v.dtype.is_floating_point:  # true for FP16 and FP32\n                    v *= d\n                    v += (1 - d) * msd[k].detach()\n                    # assert v.dtype == msd[k].dtype == torch.float32, f'{k}: EMA {v.dtype},  model {msd[k].dtype}'\n\n    def update_attr(self, model, include=(), exclude=(\"process_group\", \"reducer\")):\n        \"\"\"Updates attributes and saves stripped model with optimizer removed.\"\"\"\n        if self.enabled:\n            copy_attr(self.ema, model, include, exclude)\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.ModelEMA.__init__","title":"<code>__init__(model, decay=0.9999, tau=2000, updates=0)</code>","text":"<p>Create EMA.</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def __init__(self, model, decay=0.9999, tau=2000, updates=0):\n    \"\"\"Create EMA.\"\"\"\n    self.ema = deepcopy(de_parallel(model)).eval()  # FP32 EMA\n    self.updates = updates  # number of EMA updates\n    self.decay = lambda x: decay * (1 - math.exp(-x / tau))  # decay exponential ramp (to help early epochs)\n    for p in self.ema.parameters():\n        p.requires_grad_(False)\n    self.enabled = True\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.ModelEMA.update","title":"<code>update(model)</code>","text":"<p>Update EMA parameters.</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def update(self, model):\n    \"\"\"Update EMA parameters.\"\"\"\n    if self.enabled:\n        self.updates += 1\n        d = self.decay(self.updates)\n\n        msd = de_parallel(model).state_dict()  # model state_dict\n        for k, v in self.ema.state_dict().items():\n            if v.dtype.is_floating_point:  # true for FP16 and FP32\n                v *= d\n                v += (1 - d) * msd[k].detach()\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.ModelEMA.update_attr","title":"<code>update_attr(model, include=(), exclude=('process_group', 'reducer'))</code>","text":"<p>Updates attributes and saves stripped model with optimizer removed.</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def update_attr(self, model, include=(), exclude=(\"process_group\", \"reducer\")):\n    \"\"\"Updates attributes and saves stripped model with optimizer removed.\"\"\"\n    if self.enabled:\n        copy_attr(self.ema, model, include, exclude)\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.EarlyStopping","title":"<code>ultralytics.utils.torch_utils.EarlyStopping</code>","text":"<p>Early stopping class that stops training when a specified number of epochs have passed without improvement.</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>class EarlyStopping:\n    \"\"\"Early stopping class that stops training when a specified number of epochs have passed without improvement.\"\"\"\n\n    def __init__(self, patience=50):\n        \"\"\"\n        Initialize early stopping object.\n\n        Args:\n            patience (int, optional): Number of epochs to wait after fitness stops improving before stopping.\n        \"\"\"\n        self.best_fitness = 0.0  # i.e. mAP\n        self.best_epoch = 0\n        self.patience = patience or float(\"inf\")  # epochs to wait after fitness stops improving to stop\n        self.possible_stop = False  # possible stop may occur next epoch\n\n    def __call__(self, epoch, fitness):\n        \"\"\"\n        Check whether to stop training.\n\n        Args:\n            epoch (int): Current epoch of training\n            fitness (float): Fitness value of current epoch\n\n        Returns:\n            (bool): True if training should stop, False otherwise\n        \"\"\"\n        if fitness is None:  # check if fitness=None (happens when val=False)\n            return False\n\n        if fitness &gt;= self.best_fitness:  # &gt;= 0 to allow for early zero-fitness stage of training\n            self.best_epoch = epoch\n            self.best_fitness = fitness\n        delta = epoch - self.best_epoch  # epochs without improvement\n        self.possible_stop = delta &gt;= (self.patience - 1)  # possible stop may occur next epoch\n        stop = delta &gt;= self.patience  # stop training if patience exceeded\n        if stop:\n            LOGGER.info(\n                f\"Stopping training early as no improvement observed in last {self.patience} epochs. \"\n                f\"Best results observed at epoch {self.best_epoch}, best model saved as best.pt.\\n\"\n                f\"To update EarlyStopping(patience={self.patience}) pass a new patience value, \"\n                f\"i.e. `patience=300` or use `patience=0` to disable EarlyStopping.\"\n            )\n        return stop\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.EarlyStopping.__call__","title":"<code>__call__(epoch, fitness)</code>","text":"<p>Check whether to stop training.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>int</code> <p>Current epoch of training</p> required <code>fitness</code> <code>float</code> <p>Fitness value of current epoch</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if training should stop, False otherwise</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def __call__(self, epoch, fitness):\n    \"\"\"\n    Check whether to stop training.\n\n    Args:\n        epoch (int): Current epoch of training\n        fitness (float): Fitness value of current epoch\n\n    Returns:\n        (bool): True if training should stop, False otherwise\n    \"\"\"\n    if fitness is None:  # check if fitness=None (happens when val=False)\n        return False\n\n    if fitness &gt;= self.best_fitness:  # &gt;= 0 to allow for early zero-fitness stage of training\n        self.best_epoch = epoch\n        self.best_fitness = fitness\n    delta = epoch - self.best_epoch  # epochs without improvement\n    self.possible_stop = delta &gt;= (self.patience - 1)  # possible stop may occur next epoch\n    stop = delta &gt;= self.patience  # stop training if patience exceeded\n    if stop:\n        LOGGER.info(\n            f\"Stopping training early as no improvement observed in last {self.patience} epochs. \"\n            f\"Best results observed at epoch {self.best_epoch}, best model saved as best.pt.\\n\"\n            f\"To update EarlyStopping(patience={self.patience}) pass a new patience value, \"\n            f\"i.e. `patience=300` or use `patience=0` to disable EarlyStopping.\"\n        )\n    return stop\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.EarlyStopping.__init__","title":"<code>__init__(patience=50)</code>","text":"<p>Initialize early stopping object.</p> <p>Parameters:</p> Name Type Description Default <code>patience</code> <code>int</code> <p>Number of epochs to wait after fitness stops improving before stopping.</p> <code>50</code> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def __init__(self, patience=50):\n    \"\"\"\n    Initialize early stopping object.\n\n    Args:\n        patience (int, optional): Number of epochs to wait after fitness stops improving before stopping.\n    \"\"\"\n    self.best_fitness = 0.0  # i.e. mAP\n    self.best_epoch = 0\n    self.patience = patience or float(\"inf\")  # epochs to wait after fitness stops improving to stop\n    self.possible_stop = False  # possible stop may occur next epoch\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.torch_distributed_zero_first","title":"<code>ultralytics.utils.torch_utils.torch_distributed_zero_first(local_rank)</code>","text":"<p>Decorator to make all processes in distributed training wait for each local_master to do something.</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>@contextmanager\ndef torch_distributed_zero_first(local_rank: int):\n    \"\"\"Decorator to make all processes in distributed training wait for each local_master to do something.\"\"\"\n    initialized = torch.distributed.is_available() and torch.distributed.is_initialized()\n    if initialized and local_rank not in (-1, 0):\n        dist.barrier(device_ids=[local_rank])\n    yield\n    if initialized and local_rank == 0:\n        dist.barrier(device_ids=[0])\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.smart_inference_mode","title":"<code>ultralytics.utils.torch_utils.smart_inference_mode()</code>","text":"<p>Applies torch.inference_mode() decorator if torch&gt;=1.9.0 else torch.no_grad() decorator.</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def smart_inference_mode():\n    \"\"\"Applies torch.inference_mode() decorator if torch&gt;=1.9.0 else torch.no_grad() decorator.\"\"\"\n\n    def decorate(fn):\n        \"\"\"Applies appropriate torch decorator for inference mode based on torch version.\"\"\"\n        if TORCH_1_9 and torch.is_inference_mode_enabled():\n            return fn  # already in inference_mode, act as a pass-through\n        else:\n            return (torch.inference_mode if TORCH_1_9 else torch.no_grad)()(fn)\n\n    return decorate\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.get_cpu_info","title":"<code>ultralytics.utils.torch_utils.get_cpu_info()</code>","text":"<p>Return a string with system CPU information, i.e. 'Apple M2'.</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def get_cpu_info():\n    \"\"\"Return a string with system CPU information, i.e. 'Apple M2'.\"\"\"\n    import cpuinfo  # pip install py-cpuinfo\n\n    k = \"brand_raw\", \"hardware_raw\", \"arch_string_raw\"  # info keys sorted by preference (not all keys always available)\n    info = cpuinfo.get_cpu_info()  # info dict\n    string = info.get(k[0] if k[0] in info else k[1] if k[1] in info else k[2], \"unknown\")\n    return string.replace(\"(R)\", \"\").replace(\"CPU \", \"\").replace(\"@ \", \"\")\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.select_device","title":"<code>ultralytics.utils.torch_utils.select_device(device='', batch=0, newline=False, verbose=True)</code>","text":"<p>Selects the appropriate PyTorch device based on the provided arguments.</p> <p>The function takes a string specifying the device or a torch.device object and returns a torch.device object representing the selected device. The function also validates the number of available devices and raises an exception if the requested device(s) are not available.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>str | device</code> <p>Device string or torch.device object. Options are 'None', 'cpu', or 'cuda', or '0' or '0,1,2,3'. Defaults to an empty string, which auto-selects the first available GPU, or CPU if no GPU is available.</p> <code>''</code> <code>batch</code> <code>int</code> <p>Batch size being used in your model. Defaults to 0.</p> <code>0</code> <code>newline</code> <code>bool</code> <p>If True, adds a newline at the end of the log string. Defaults to False.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>If True, logs the device information. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>device</code> <p>Selected device.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified device is not available or if the batch size is not a multiple of the number of devices when using multiple GPUs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; select_device('cuda:0')\ndevice(type='cuda', index=0)\n</code></pre> <pre><code>&gt;&gt;&gt; select_device('cpu')\ndevice(type='cpu')\n</code></pre> Note <p>Sets the 'CUDA_VISIBLE_DEVICES' environment variable for specifying which GPUs to use.</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def select_device(device=\"\", batch=0, newline=False, verbose=True):\n    \"\"\"\n    Selects the appropriate PyTorch device based on the provided arguments.\n\n    The function takes a string specifying the device or a torch.device object and returns a torch.device object\n    representing the selected device. The function also validates the number of available devices and raises an\n    exception if the requested device(s) are not available.\n\n    Args:\n        device (str | torch.device, optional): Device string or torch.device object.\n            Options are 'None', 'cpu', or 'cuda', or '0' or '0,1,2,3'. Defaults to an empty string, which auto-selects\n            the first available GPU, or CPU if no GPU is available.\n        batch (int, optional): Batch size being used in your model. Defaults to 0.\n        newline (bool, optional): If True, adds a newline at the end of the log string. Defaults to False.\n        verbose (bool, optional): If True, logs the device information. Defaults to True.\n\n    Returns:\n        (torch.device): Selected device.\n\n    Raises:\n        ValueError: If the specified device is not available or if the batch size is not a multiple of the number of\n            devices when using multiple GPUs.\n\n    Examples:\n        &gt;&gt;&gt; select_device('cuda:0')\n        device(type='cuda', index=0)\n\n        &gt;&gt;&gt; select_device('cpu')\n        device(type='cpu')\n\n    Note:\n        Sets the 'CUDA_VISIBLE_DEVICES' environment variable for specifying which GPUs to use.\n    \"\"\"\n\n    if isinstance(device, torch.device):\n        return device\n\n    s = f\"Ultralytics YOLOv{__version__} \ud83d\ude80 Python-{platform.python_version()} torch-{torch.__version__} \"\n    device = str(device).lower()\n    for remove in \"cuda:\", \"none\", \"(\", \")\", \"[\", \"]\", \"'\", \" \":\n        device = device.replace(remove, \"\")  # to string, 'cuda:0' -&gt; '0' and '(0, 1)' -&gt; '0,1'\n    cpu = device == \"cpu\"\n    mps = device in (\"mps\", \"mps:0\")  # Apple Metal Performance Shaders (MPS)\n    if cpu or mps:\n        os.environ[\"CUDA_VISIBLE_DEVICES\"] = \"-1\"  # force torch.cuda.is_available() = False\n    elif device:  # non-cpu device requested\n        if device == \"cuda\":\n            device = \"0\"\n        visible = os.environ.get(\"CUDA_VISIBLE_DEVICES\", None)\n        os.environ[\"CUDA_VISIBLE_DEVICES\"] = device  # set environment variable - must be before assert is_available()\n        if not (torch.cuda.is_available() and torch.cuda.device_count() &gt;= len(device.replace(\",\", \"\"))):\n            LOGGER.info(s)\n            install = (\n                \"See https://pytorch.org/get-started/locally/ for up-to-date torch install instructions if no \"\n                \"CUDA devices are seen by torch.\\n\"\n                if torch.cuda.device_count() == 0\n                else \"\"\n            )\n            raise ValueError(\n                f\"Invalid CUDA 'device={device}' requested.\"\n                f\" Use 'device=cpu' or pass valid CUDA device(s) if available,\"\n                f\" i.e. 'device=0' or 'device=0,1,2,3' for Multi-GPU.\\n\"\n                f\"\\ntorch.cuda.is_available(): {torch.cuda.is_available()}\"\n                f\"\\ntorch.cuda.device_count(): {torch.cuda.device_count()}\"\n                f\"\\nos.environ['CUDA_VISIBLE_DEVICES']: {visible}\\n\"\n                f\"{install}\"\n            )\n\n    if not cpu and not mps and torch.cuda.is_available():  # prefer GPU if available\n        devices = device.split(\",\") if device else \"0\"  # range(torch.cuda.device_count())  # i.e. 0,1,6,7\n        n = len(devices)  # device count\n        if n &gt; 1 and batch &gt; 0 and batch % n != 0:  # check batch_size is divisible by device_count\n            raise ValueError(\n                f\"'batch={batch}' must be a multiple of GPU count {n}. Try 'batch={batch // n * n}' or \"\n                f\"'batch={batch // n * n + n}', the nearest batch sizes evenly divisible by {n}.\"\n            )\n        space = \" \" * (len(s) + 1)\n        for i, d in enumerate(devices):\n            p = torch.cuda.get_device_properties(i)\n            s += f\"{'' if i == 0 else space}CUDA:{d} ({p.name}, {p.total_memory / (1 &lt;&lt; 20):.0f}MiB)\\n\"  # bytes to MB\n        arg = \"cuda:0\"\n    elif mps and TORCH_2_0 and torch.backends.mps.is_available():\n        # Prefer MPS if available\n        s += f\"MPS ({get_cpu_info()})\\n\"\n        arg = \"mps\"\n    else:  # revert to CPU\n        s += f\"CPU ({get_cpu_info()})\\n\"\n        arg = \"cpu\"\n\n    if verbose:\n        LOGGER.info(s if newline else s.rstrip())\n    return torch.device(arg)\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.time_sync","title":"<code>ultralytics.utils.torch_utils.time_sync()</code>","text":"<p>PyTorch-accurate time.</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def time_sync():\n    \"\"\"PyTorch-accurate time.\"\"\"\n    if torch.cuda.is_available():\n        torch.cuda.synchronize()\n    return time.time()\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.fuse_conv_and_bn","title":"<code>ultralytics.utils.torch_utils.fuse_conv_and_bn(conv, bn)</code>","text":"<p>Fuse Conv2d() and BatchNorm2d() layers https://tehnokv.com/posts/fusing-batchnorm-and-conv/.</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def fuse_conv_and_bn(conv, bn):\n    \"\"\"Fuse Conv2d() and BatchNorm2d() layers https://tehnokv.com/posts/fusing-batchnorm-and-conv/.\"\"\"\n    fusedconv = (\n        nn.Conv2d(\n            conv.in_channels,\n            conv.out_channels,\n            kernel_size=conv.kernel_size,\n            stride=conv.stride,\n            padding=conv.padding,\n            dilation=conv.dilation,\n            groups=conv.groups,\n            bias=True,\n        )\n        .requires_grad_(False)\n        .to(conv.weight.device)\n    )\n\n    # Prepare filters\n    w_conv = conv.weight.clone().view(conv.out_channels, -1)\n    w_bn = torch.diag(bn.weight.div(torch.sqrt(bn.eps + bn.running_var)))\n    fusedconv.weight.copy_(torch.mm(w_bn, w_conv).view(fusedconv.weight.shape))\n\n    # Prepare spatial bias\n    b_conv = torch.zeros(conv.weight.size(0), device=conv.weight.device) if conv.bias is None else conv.bias\n    b_bn = bn.bias - bn.weight.mul(bn.running_mean).div(torch.sqrt(bn.running_var + bn.eps))\n    fusedconv.bias.copy_(torch.mm(w_bn, b_conv.reshape(-1, 1)).reshape(-1) + b_bn)\n\n    return fusedconv\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.fuse_deconv_and_bn","title":"<code>ultralytics.utils.torch_utils.fuse_deconv_and_bn(deconv, bn)</code>","text":"<p>Fuse ConvTranspose2d() and BatchNorm2d() layers.</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def fuse_deconv_and_bn(deconv, bn):\n    \"\"\"Fuse ConvTranspose2d() and BatchNorm2d() layers.\"\"\"\n    fuseddconv = (\n        nn.ConvTranspose2d(\n            deconv.in_channels,\n            deconv.out_channels,\n            kernel_size=deconv.kernel_size,\n            stride=deconv.stride,\n            padding=deconv.padding,\n            output_padding=deconv.output_padding,\n            dilation=deconv.dilation,\n            groups=deconv.groups,\n            bias=True,\n        )\n        .requires_grad_(False)\n        .to(deconv.weight.device)\n    )\n\n    # Prepare filters\n    w_deconv = deconv.weight.clone().view(deconv.out_channels, -1)\n    w_bn = torch.diag(bn.weight.div(torch.sqrt(bn.eps + bn.running_var)))\n    fuseddconv.weight.copy_(torch.mm(w_bn, w_deconv).view(fuseddconv.weight.shape))\n\n    # Prepare spatial bias\n    b_conv = torch.zeros(deconv.weight.size(1), device=deconv.weight.device) if deconv.bias is None else deconv.bias\n    b_bn = bn.bias - bn.weight.mul(bn.running_mean).div(torch.sqrt(bn.running_var + bn.eps))\n    fuseddconv.bias.copy_(torch.mm(w_bn, b_conv.reshape(-1, 1)).reshape(-1) + b_bn)\n\n    return fuseddconv\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.model_info","title":"<code>ultralytics.utils.torch_utils.model_info(model, detailed=False, verbose=True, imgsz=640)</code>","text":"<p>Model information.</p> <p>imgsz may be int or list, i.e. imgsz=640 or imgsz=[640, 320].</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def model_info(model, detailed=False, verbose=True, imgsz=640):\n    \"\"\"\n    Model information.\n\n    imgsz may be int or list, i.e. imgsz=640 or imgsz=[640, 320].\n    \"\"\"\n    if not verbose:\n        return\n    n_p = get_num_params(model)  # number of parameters\n    n_g = get_num_gradients(model)  # number of gradients\n    n_l = len(list(model.modules()))  # number of layers\n    if detailed:\n        LOGGER.info(\n            f\"{'layer':&gt;5} {'name':&gt;40} {'gradient':&gt;9} {'parameters':&gt;12} {'shape':&gt;20} {'mu':&gt;10} {'sigma':&gt;10}\"\n        )\n        for i, (name, p) in enumerate(model.named_parameters()):\n            name = name.replace(\"module_list.\", \"\")\n            LOGGER.info(\n                \"%5g %40s %9s %12g %20s %10.3g %10.3g %10s\"\n                % (i, name, p.requires_grad, p.numel(), list(p.shape), p.mean(), p.std(), p.dtype)\n            )\n\n    flops = get_flops(model, imgsz)\n    fused = \" (fused)\" if getattr(model, \"is_fused\", lambda: False)() else \"\"\n    fs = f\", {flops:.1f} GFLOPs\" if flops else \"\"\n    yaml_file = getattr(model, \"yaml_file\", \"\") or getattr(model, \"yaml\", {}).get(\"yaml_file\", \"\")\n    model_name = Path(yaml_file).stem.replace(\"yolo\", \"YOLO\") or \"Model\"\n    LOGGER.info(f\"{model_name} summary{fused}: {n_l} layers, {n_p} parameters, {n_g} gradients{fs}\")\n    return n_l, n_p, n_g, flops\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.get_num_params","title":"<code>ultralytics.utils.torch_utils.get_num_params(model)</code>","text":"<p>Return the total number of parameters in a YOLO model.</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def get_num_params(model):\n    \"\"\"Return the total number of parameters in a YOLO model.\"\"\"\n    return sum(x.numel() for x in model.parameters())\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.get_num_gradients","title":"<code>ultralytics.utils.torch_utils.get_num_gradients(model)</code>","text":"<p>Return the total number of parameters with gradients in a YOLO model.</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def get_num_gradients(model):\n    \"\"\"Return the total number of parameters with gradients in a YOLO model.\"\"\"\n    return sum(x.numel() for x in model.parameters() if x.requires_grad)\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.model_info_for_loggers","title":"<code>ultralytics.utils.torch_utils.model_info_for_loggers(trainer)</code>","text":"<p>Return model info dict with useful model information.</p> Example <p>YOLOv8n info for loggers <pre><code>results = {'model/parameters': 3151904,\n           'model/GFLOPs': 8.746,\n           'model/speed_ONNX(ms)': 41.244,\n           'model/speed_TensorRT(ms)': 3.211,\n           'model/speed_PyTorch(ms)': 18.755}\n</code></pre></p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def model_info_for_loggers(trainer):\n    \"\"\"\n    Return model info dict with useful model information.\n\n    Example:\n        YOLOv8n info for loggers\n        ```python\n        results = {'model/parameters': 3151904,\n                   'model/GFLOPs': 8.746,\n                   'model/speed_ONNX(ms)': 41.244,\n                   'model/speed_TensorRT(ms)': 3.211,\n                   'model/speed_PyTorch(ms)': 18.755}\n        ```\n    \"\"\"\n    if trainer.args.profile:  # profile ONNX and TensorRT times\n        from ultralytics.utils.benchmarks import ProfileModels\n\n        results = ProfileModels([trainer.last], device=trainer.device).profile()[0]\n        results.pop(\"model/name\")\n    else:  # only return PyTorch times from most recent validation\n        results = {\n            \"model/parameters\": get_num_params(trainer.model),\n            \"model/GFLOPs\": round(get_flops(trainer.model), 3),\n        }\n    results[\"model/speed_PyTorch(ms)\"] = round(trainer.validator.speed[\"inference\"], 3)\n    return results\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.get_flops","title":"<code>ultralytics.utils.torch_utils.get_flops(model, imgsz=640)</code>","text":"<p>Return a YOLO model's FLOPs.</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def get_flops(model, imgsz=640):\n    \"\"\"Return a YOLO model's FLOPs.\"\"\"\n    if not thop:\n        return 0.0  # if not installed return 0.0 GFLOPs\n\n    try:\n        model = de_parallel(model)\n        p = next(model.parameters())\n        if not isinstance(imgsz, list):\n            imgsz = [imgsz, imgsz]  # expand if int/float\n        try:\n            # Use stride size for input tensor\n            stride = max(int(model.stride.max()), 32) if hasattr(model, \"stride\") else 32  # max stride\n            im = torch.empty((1, p.shape[1], stride, stride), device=p.device)  # input image in BCHW format\n            flops = thop.profile(deepcopy(model), inputs=[im], verbose=False)[0] / 1e9 * 2  # stride GFLOPs\n            return flops * imgsz[0] / stride * imgsz[1] / stride  # imgsz GFLOPs\n        except Exception:\n            # Use actual image size for input tensor (i.e. required for RTDETR models)\n            im = torch.empty((1, p.shape[1], *imgsz), device=p.device)  # input image in BCHW format\n            return thop.profile(deepcopy(model), inputs=[im], verbose=False)[0] / 1e9 * 2  # imgsz GFLOPs\n    except Exception:\n        return 0.0\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.get_flops_with_torch_profiler","title":"<code>ultralytics.utils.torch_utils.get_flops_with_torch_profiler(model, imgsz=640)</code>","text":"<p>Compute model FLOPs (thop alternative).</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def get_flops_with_torch_profiler(model, imgsz=640):\n    \"\"\"Compute model FLOPs (thop alternative).\"\"\"\n    if TORCH_2_0:\n        model = de_parallel(model)\n        p = next(model.parameters())\n        stride = (max(int(model.stride.max()), 32) if hasattr(model, \"stride\") else 32) * 2  # max stride\n        im = torch.zeros((1, p.shape[1], stride, stride), device=p.device)  # input image in BCHW format\n        with torch.profiler.profile(with_flops=True) as prof:\n            model(im)\n        flops = sum(x.flops for x in prof.key_averages()) / 1e9\n        imgsz = imgsz if isinstance(imgsz, list) else [imgsz, imgsz]  # expand if int/float\n        flops = flops * imgsz[0] / stride * imgsz[1] / stride  # 640x640 GFLOPs\n        return flops\n    return 0\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.initialize_weights","title":"<code>ultralytics.utils.torch_utils.initialize_weights(model)</code>","text":"<p>Initialize model weights to random values.</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def initialize_weights(model):\n    \"\"\"Initialize model weights to random values.\"\"\"\n    for m in model.modules():\n        t = type(m)\n        if t is nn.Conv2d:\n            pass  # nn.init.kaiming_normal_(m.weight, mode='fan_out', nonlinearity='relu')\n        elif t is nn.BatchNorm2d:\n            m.eps = 1e-3\n            m.momentum = 0.03\n        elif t in [nn.Hardswish, nn.LeakyReLU, nn.ReLU, nn.ReLU6, nn.SiLU]:\n            m.inplace = True\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.scale_img","title":"<code>ultralytics.utils.torch_utils.scale_img(img, ratio=1.0, same_shape=False, gs=32)</code>","text":"<p>Scales and pads an image tensor of shape img(bs,3,y,x) based on given ratio and grid size gs, optionally retaining the original shape.</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def scale_img(img, ratio=1.0, same_shape=False, gs=32):\n    \"\"\"Scales and pads an image tensor of shape img(bs,3,y,x) based on given ratio and grid size gs, optionally\n    retaining the original shape.\n    \"\"\"\n    if ratio == 1.0:\n        return img\n    h, w = img.shape[2:]\n    s = (int(h * ratio), int(w * ratio))  # new size\n    img = F.interpolate(img, size=s, mode=\"bilinear\", align_corners=False)  # resize\n    if not same_shape:  # pad/crop img\n        h, w = (math.ceil(x * ratio / gs) * gs for x in (h, w))\n    return F.pad(img, [0, w - s[1], 0, h - s[0]], value=0.447)  # value = imagenet mean\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.make_divisible","title":"<code>ultralytics.utils.torch_utils.make_divisible(x, divisor)</code>","text":"<p>Returns nearest x divisible by divisor.</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def make_divisible(x, divisor):\n    \"\"\"Returns nearest x divisible by divisor.\"\"\"\n    if isinstance(divisor, torch.Tensor):\n        divisor = int(divisor.max())  # to int\n    return math.ceil(x / divisor) * divisor\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.copy_attr","title":"<code>ultralytics.utils.torch_utils.copy_attr(a, b, include=(), exclude=())</code>","text":"<p>Copies attributes from object 'b' to object 'a', with options to include/exclude certain attributes.</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def copy_attr(a, b, include=(), exclude=()):\n    \"\"\"Copies attributes from object 'b' to object 'a', with options to include/exclude certain attributes.\"\"\"\n    for k, v in b.__dict__.items():\n        if (len(include) and k not in include) or k.startswith(\"_\") or k in exclude:\n            continue\n        else:\n            setattr(a, k, v)\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.get_latest_opset","title":"<code>ultralytics.utils.torch_utils.get_latest_opset()</code>","text":"<p>Return second-most (for maturity) recently supported ONNX opset by this version of torch.</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def get_latest_opset():\n    \"\"\"Return second-most (for maturity) recently supported ONNX opset by this version of torch.\"\"\"\n    return max(int(k[14:]) for k in vars(torch.onnx) if \"symbolic_opset\" in k) - 1  # opset\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.intersect_dicts","title":"<code>ultralytics.utils.torch_utils.intersect_dicts(da, db, exclude=())</code>","text":"<p>Returns a dictionary of intersecting keys with matching shapes, excluding 'exclude' keys, using da values.</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def intersect_dicts(da, db, exclude=()):\n    \"\"\"Returns a dictionary of intersecting keys with matching shapes, excluding 'exclude' keys, using da values.\"\"\"\n    return {k: v for k, v in da.items() if k in db and all(x not in k for x in exclude) and v.shape == db[k].shape}\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.is_parallel","title":"<code>ultralytics.utils.torch_utils.is_parallel(model)</code>","text":"<p>Returns True if model is of type DP or DDP.</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def is_parallel(model):\n    \"\"\"Returns True if model is of type DP or DDP.\"\"\"\n    return isinstance(model, (nn.parallel.DataParallel, nn.parallel.DistributedDataParallel))\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.de_parallel","title":"<code>ultralytics.utils.torch_utils.de_parallel(model)</code>","text":"<p>De-parallelize a model: returns single-GPU model if model is of type DP or DDP.</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def de_parallel(model):\n    \"\"\"De-parallelize a model: returns single-GPU model if model is of type DP or DDP.\"\"\"\n    return model.module if is_parallel(model) else model\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.one_cycle","title":"<code>ultralytics.utils.torch_utils.one_cycle(y1=0.0, y2=1.0, steps=100)</code>","text":"<p>Returns a lambda function for sinusoidal ramp from y1 to y2 https://arxiv.org/pdf/1812.01187.pdf.</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def one_cycle(y1=0.0, y2=1.0, steps=100):\n    \"\"\"Returns a lambda function for sinusoidal ramp from y1 to y2 https://arxiv.org/pdf/1812.01187.pdf.\"\"\"\n    return lambda x: max((1 - math.cos(x * math.pi / steps)) / 2, 0) * (y2 - y1) + y1\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.init_seeds","title":"<code>ultralytics.utils.torch_utils.init_seeds(seed=0, deterministic=False)</code>","text":"<p>Initialize random number generator (RNG) seeds https://pytorch.org/docs/stable/notes/randomness.html.</p> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def init_seeds(seed=0, deterministic=False):\n    \"\"\"Initialize random number generator (RNG) seeds https://pytorch.org/docs/stable/notes/randomness.html.\"\"\"\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)  # for Multi-GPU, exception safe\n    # torch.backends.cudnn.benchmark = True  # AutoBatch problem https://github.com/ultralytics/yolov5/issues/9287\n    if deterministic:\n        if TORCH_2_0:\n            torch.use_deterministic_algorithms(True, warn_only=True)  # warn if deterministic is not possible\n            torch.backends.cudnn.deterministic = True\n            os.environ[\"CUBLAS_WORKSPACE_CONFIG\"] = \":4096:8\"\n            os.environ[\"PYTHONHASHSEED\"] = str(seed)\n        else:\n            LOGGER.warning(\"WARNING \u26a0\ufe0f Upgrade to torch&gt;=2.0.0 for deterministic training.\")\n    else:\n        torch.use_deterministic_algorithms(False)\n        torch.backends.cudnn.deterministic = False\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.strip_optimizer","title":"<code>ultralytics.utils.torch_utils.strip_optimizer(f='best.pt', s='')</code>","text":"<p>Strip optimizer from 'f' to finalize training, optionally save as 's'.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>str</code> <p>file path to model to strip the optimizer from. Default is 'best.pt'.</p> <code>'best.pt'</code> <code>s</code> <code>str</code> <p>file path to save the model with stripped optimizer to. If not provided, 'f' will be overwritten.</p> <code>''</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Example <pre><code>from pathlib import Path\nfrom ultralytics.utils.torch_utils import strip_optimizer\n\nfor f in Path('path/to/weights').rglob('*.pt'):\n    strip_optimizer(f)\n</code></pre> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def strip_optimizer(f: Union[str, Path] = \"best.pt\", s: str = \"\") -&gt; None:\n    \"\"\"\n    Strip optimizer from 'f' to finalize training, optionally save as 's'.\n\n    Args:\n        f (str): file path to model to strip the optimizer from. Default is 'best.pt'.\n        s (str): file path to save the model with stripped optimizer to. If not provided, 'f' will be overwritten.\n\n    Returns:\n        None\n\n    Example:\n        ```python\n        from pathlib import Path\n        from ultralytics.utils.torch_utils import strip_optimizer\n\n        for f in Path('path/to/weights').rglob('*.pt'):\n            strip_optimizer(f)\n        ```\n    \"\"\"\n    x = torch.load(f, map_location=torch.device(\"cpu\"))\n    if \"model\" not in x:\n        LOGGER.info(f\"Skipping {f}, not a valid Ultralytics model.\")\n        return\n\n    if hasattr(x[\"model\"], \"args\"):\n        x[\"model\"].args = dict(x[\"model\"].args)  # convert from IterableSimpleNamespace to dict\n    args = {**DEFAULT_CFG_DICT, **x[\"train_args\"]} if \"train_args\" in x else None  # combine args\n    if x.get(\"ema\"):\n        x[\"model\"] = x[\"ema\"]  # replace model with ema\n    for k in \"optimizer\", \"best_fitness\", \"ema\", \"updates\":  # keys\n        x[k] = None\n    x[\"epoch\"] = -1\n    x[\"model\"].half()  # to FP16\n    for p in x[\"model\"].parameters():\n        p.requires_grad = False\n    x[\"train_args\"] = {k: v for k, v in args.items() if k in DEFAULT_CFG_KEYS}  # strip non-default keys\n    # x['model'].args = x['train_args']\n    torch.save(x, s or f)\n    mb = os.path.getsize(s or f) / 1e6  # file size\n    LOGGER.info(f\"Optimizer stripped from {f},{f' saved as {s},' if s else ''} {mb:.1f}MB\")\n</code></pre>"},{"location":"reference/utils/torch_utils/#ultralytics.utils.torch_utils.profile","title":"<code>ultralytics.utils.torch_utils.profile(input, ops, n=10, device=None)</code>","text":"<p>Ultralytics speed, memory and FLOPs profiler.</p> Example <pre><code>from ultralytics.utils.torch_utils import profile\n\ninput = torch.randn(16, 3, 640, 640)\nm1 = lambda x: x * torch.sigmoid(x)\nm2 = nn.SiLU()\nprofile(input, [m1, m2], n=100)  # profile over 100 iterations\n</code></pre> Source code in <code>ultralytics/utils/torch_utils.py</code> <pre><code>def profile(input, ops, n=10, device=None):\n    \"\"\"\n    Ultralytics speed, memory and FLOPs profiler.\n\n    Example:\n        ```python\n        from ultralytics.utils.torch_utils import profile\n\n        input = torch.randn(16, 3, 640, 640)\n        m1 = lambda x: x * torch.sigmoid(x)\n        m2 = nn.SiLU()\n        profile(input, [m1, m2], n=100)  # profile over 100 iterations\n        ```\n    \"\"\"\n    results = []\n    if not isinstance(device, torch.device):\n        device = select_device(device)\n    LOGGER.info(\n        f\"{'Params':&gt;12s}{'GFLOPs':&gt;12s}{'GPU_mem (GB)':&gt;14s}{'forward (ms)':&gt;14s}{'backward (ms)':&gt;14s}\"\n        f\"{'input':&gt;24s}{'output':&gt;24s}\"\n    )\n\n    for x in input if isinstance(input, list) else [input]:\n        x = x.to(device)\n        x.requires_grad = True\n        for m in ops if isinstance(ops, list) else [ops]:\n            m = m.to(device) if hasattr(m, \"to\") else m  # device\n            m = m.half() if hasattr(m, \"half\") and isinstance(x, torch.Tensor) and x.dtype is torch.float16 else m\n            tf, tb, t = 0, 0, [0, 0, 0]  # dt forward, backward\n            try:\n                flops = thop.profile(m, inputs=[x], verbose=False)[0] / 1e9 * 2 if thop else 0  # GFLOPs\n            except Exception:\n                flops = 0\n\n            try:\n                for _ in range(n):\n                    t[0] = time_sync()\n                    y = m(x)\n                    t[1] = time_sync()\n                    try:\n                        (sum(yi.sum() for yi in y) if isinstance(y, list) else y).sum().backward()\n                        t[2] = time_sync()\n                    except Exception:  # no backward method\n                        # print(e)  # for debug\n                        t[2] = float(\"nan\")\n                    tf += (t[1] - t[0]) * 1000 / n  # ms per op forward\n                    tb += (t[2] - t[1]) * 1000 / n  # ms per op backward\n                mem = torch.cuda.memory_reserved() / 1e9 if torch.cuda.is_available() else 0  # (GB)\n                s_in, s_out = (tuple(x.shape) if isinstance(x, torch.Tensor) else \"list\" for x in (x, y))  # shapes\n                p = sum(x.numel() for x in m.parameters()) if isinstance(m, nn.Module) else 0  # parameters\n                LOGGER.info(f\"{p:12}{flops:12.4g}{mem:&gt;14.3f}{tf:14.4g}{tb:14.4g}{str(s_in):&gt;24s}{str(s_out):&gt;24s}\")\n                results.append([p, flops, mem, tf, tb, s_in, s_out])\n            except Exception as e:\n                LOGGER.info(e)\n                results.append(None)\n            torch.cuda.empty_cache()\n    return results\n</code></pre>"},{"location":"reference/utils/triton/","title":"Reference for <code>ultralytics/utils/triton.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/triton.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p>"},{"location":"reference/utils/triton/#ultralytics.utils.triton.TritonRemoteModel","title":"<code>ultralytics.utils.triton.TritonRemoteModel</code>","text":"<p>Client for interacting with a remote Triton Inference Server model.</p> <p>Attributes:</p> Name Type Description <code>endpoint</code> <code>str</code> <p>The name of the model on the Triton server.</p> <code>url</code> <code>str</code> <p>The URL of the Triton server.</p> <code>triton_client</code> <p>The Triton client (either HTTP or gRPC).</p> <code>InferInput</code> <p>The input class for the Triton client.</p> <code>InferRequestedOutput</code> <p>The output request class for the Triton client.</p> <code>input_formats</code> <code>List[str]</code> <p>The data types of the model inputs.</p> <code>np_input_formats</code> <code>List[type]</code> <p>The numpy data types of the model inputs.</p> <code>input_names</code> <code>List[str]</code> <p>The names of the model inputs.</p> <code>output_names</code> <code>List[str]</code> <p>The names of the model outputs.</p> Source code in <code>ultralytics/utils/triton.py</code> <pre><code>class TritonRemoteModel:\n    \"\"\"\n    Client for interacting with a remote Triton Inference Server model.\n\n    Attributes:\n        endpoint (str): The name of the model on the Triton server.\n        url (str): The URL of the Triton server.\n        triton_client: The Triton client (either HTTP or gRPC).\n        InferInput: The input class for the Triton client.\n        InferRequestedOutput: The output request class for the Triton client.\n        input_formats (List[str]): The data types of the model inputs.\n        np_input_formats (List[type]): The numpy data types of the model inputs.\n        input_names (List[str]): The names of the model inputs.\n        output_names (List[str]): The names of the model outputs.\n    \"\"\"\n\n    def __init__(self, url: str, endpoint: str = \"\", scheme: str = \"\"):\n        \"\"\"\n        Initialize the TritonRemoteModel.\n\n        Arguments may be provided individually or parsed from a collective 'url' argument of the form\n            &lt;scheme&gt;://&lt;netloc&gt;/&lt;endpoint&gt;/&lt;task_name&gt;\n\n        Args:\n            url (str): The URL of the Triton server.\n            endpoint (str): The name of the model on the Triton server.\n            scheme (str): The communication scheme ('http' or 'grpc').\n        \"\"\"\n        if not endpoint and not scheme:  # Parse all args from URL string\n            splits = urlsplit(url)\n            endpoint = splits.path.strip(\"/\").split(\"/\")[0]\n            scheme = splits.scheme\n            url = splits.netloc\n\n        self.endpoint = endpoint\n        self.url = url\n\n        # Choose the Triton client based on the communication scheme\n        if scheme == \"http\":\n            import tritonclient.http as client  # noqa\n\n            self.triton_client = client.InferenceServerClient(url=self.url, verbose=False, ssl=False)\n            config = self.triton_client.get_model_config(endpoint)\n        else:\n            import tritonclient.grpc as client  # noqa\n\n            self.triton_client = client.InferenceServerClient(url=self.url, verbose=False, ssl=False)\n            config = self.triton_client.get_model_config(endpoint, as_json=True)[\"config\"]\n\n        # Sort output names alphabetically, i.e. 'output0', 'output1', etc.\n        config[\"output\"] = sorted(config[\"output\"], key=lambda x: x.get(\"name\"))\n\n        # Define model attributes\n        type_map = {\"TYPE_FP32\": np.float32, \"TYPE_FP16\": np.float16, \"TYPE_UINT8\": np.uint8}\n        self.InferRequestedOutput = client.InferRequestedOutput\n        self.InferInput = client.InferInput\n        self.input_formats = [x[\"data_type\"] for x in config[\"input\"]]\n        self.np_input_formats = [type_map[x] for x in self.input_formats]\n        self.input_names = [x[\"name\"] for x in config[\"input\"]]\n        self.output_names = [x[\"name\"] for x in config[\"output\"]]\n\n    def __call__(self, *inputs: np.ndarray) -&gt; List[np.ndarray]:\n        \"\"\"\n        Call the model with the given inputs.\n\n        Args:\n            *inputs (List[np.ndarray]): Input data to the model.\n\n        Returns:\n            List[np.ndarray]: Model outputs.\n        \"\"\"\n        infer_inputs = []\n        input_format = inputs[0].dtype\n        for i, x in enumerate(inputs):\n            if x.dtype != self.np_input_formats[i]:\n                x = x.astype(self.np_input_formats[i])\n            infer_input = self.InferInput(self.input_names[i], [*x.shape], self.input_formats[i].replace(\"TYPE_\", \"\"))\n            infer_input.set_data_from_numpy(x)\n            infer_inputs.append(infer_input)\n\n        infer_outputs = [self.InferRequestedOutput(output_name) for output_name in self.output_names]\n        outputs = self.triton_client.infer(model_name=self.endpoint, inputs=infer_inputs, outputs=infer_outputs)\n\n        return [outputs.as_numpy(output_name).astype(input_format) for output_name in self.output_names]\n</code></pre>"},{"location":"reference/utils/triton/#ultralytics.utils.triton.TritonRemoteModel.__call__","title":"<code>__call__(*inputs)</code>","text":"<p>Call the model with the given inputs.</p> <p>Parameters:</p> Name Type Description Default <code>*inputs</code> <code>List[ndarray]</code> <p>Input data to the model.</p> <code>()</code> <p>Returns:</p> Type Description <code>List[ndarray]</code> <p>List[np.ndarray]: Model outputs.</p> Source code in <code>ultralytics/utils/triton.py</code> <pre><code>def __call__(self, *inputs: np.ndarray) -&gt; List[np.ndarray]:\n    \"\"\"\n    Call the model with the given inputs.\n\n    Args:\n        *inputs (List[np.ndarray]): Input data to the model.\n\n    Returns:\n        List[np.ndarray]: Model outputs.\n    \"\"\"\n    infer_inputs = []\n    input_format = inputs[0].dtype\n    for i, x in enumerate(inputs):\n        if x.dtype != self.np_input_formats[i]:\n            x = x.astype(self.np_input_formats[i])\n        infer_input = self.InferInput(self.input_names[i], [*x.shape], self.input_formats[i].replace(\"TYPE_\", \"\"))\n        infer_input.set_data_from_numpy(x)\n        infer_inputs.append(infer_input)\n\n    infer_outputs = [self.InferRequestedOutput(output_name) for output_name in self.output_names]\n    outputs = self.triton_client.infer(model_name=self.endpoint, inputs=infer_inputs, outputs=infer_outputs)\n\n    return [outputs.as_numpy(output_name).astype(input_format) for output_name in self.output_names]\n</code></pre>"},{"location":"reference/utils/triton/#ultralytics.utils.triton.TritonRemoteModel.__init__","title":"<code>__init__(url, endpoint='', scheme='')</code>","text":"<p>Initialize the TritonRemoteModel.</p> <p>Arguments may be provided individually or parsed from a collective 'url' argument of the form     ://// <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the Triton server.</p> required <code>endpoint</code> <code>str</code> <p>The name of the model on the Triton server.</p> <code>''</code> <code>scheme</code> <code>str</code> <p>The communication scheme ('http' or 'grpc').</p> <code>''</code> Source code in <code>ultralytics/utils/triton.py</code> <pre><code>def __init__(self, url: str, endpoint: str = \"\", scheme: str = \"\"):\n    \"\"\"\n    Initialize the TritonRemoteModel.\n\n    Arguments may be provided individually or parsed from a collective 'url' argument of the form\n        &lt;scheme&gt;://&lt;netloc&gt;/&lt;endpoint&gt;/&lt;task_name&gt;\n\n    Args:\n        url (str): The URL of the Triton server.\n        endpoint (str): The name of the model on the Triton server.\n        scheme (str): The communication scheme ('http' or 'grpc').\n    \"\"\"\n    if not endpoint and not scheme:  # Parse all args from URL string\n        splits = urlsplit(url)\n        endpoint = splits.path.strip(\"/\").split(\"/\")[0]\n        scheme = splits.scheme\n        url = splits.netloc\n\n    self.endpoint = endpoint\n    self.url = url\n\n    # Choose the Triton client based on the communication scheme\n    if scheme == \"http\":\n        import tritonclient.http as client  # noqa\n\n        self.triton_client = client.InferenceServerClient(url=self.url, verbose=False, ssl=False)\n        config = self.triton_client.get_model_config(endpoint)\n    else:\n        import tritonclient.grpc as client  # noqa\n\n        self.triton_client = client.InferenceServerClient(url=self.url, verbose=False, ssl=False)\n        config = self.triton_client.get_model_config(endpoint, as_json=True)[\"config\"]\n\n    # Sort output names alphabetically, i.e. 'output0', 'output1', etc.\n    config[\"output\"] = sorted(config[\"output\"], key=lambda x: x.get(\"name\"))\n\n    # Define model attributes\n    type_map = {\"TYPE_FP32\": np.float32, \"TYPE_FP16\": np.float16, \"TYPE_UINT8\": np.uint8}\n    self.InferRequestedOutput = client.InferRequestedOutput\n    self.InferInput = client.InferInput\n    self.input_formats = [x[\"data_type\"] for x in config[\"input\"]]\n    self.np_input_formats = [type_map[x] for x in self.input_formats]\n    self.input_names = [x[\"name\"] for x in config[\"input\"]]\n    self.output_names = [x[\"name\"] for x in config[\"output\"]]\n</code></pre> <p></p>"},{"location":"reference/utils/tuner/","title":"Reference for <code>ultralytics/utils/tuner.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/tuner.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/utils/tuner/#ultralytics.utils.tuner.run_ray_tune","title":"<code>ultralytics.utils.tuner.run_ray_tune(model, space=None, grace_period=10, gpu_per_trial=None, max_samples=10, **train_args)</code>","text":"<p>Runs hyperparameter tuning using Ray Tune.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>YOLO</code> <p>Model to run the tuner on.</p> required <code>space</code> <code>dict</code> <p>The hyperparameter search space. Defaults to None.</p> <code>None</code> <code>grace_period</code> <code>int</code> <p>The grace period in epochs of the ASHA scheduler. Defaults to 10.</p> <code>10</code> <code>gpu_per_trial</code> <code>int</code> <p>The number of GPUs to allocate per trial. Defaults to None.</p> <code>None</code> <code>max_samples</code> <code>int</code> <p>The maximum number of trials to run. Defaults to 10.</p> <code>10</code> <code>train_args</code> <code>dict</code> <p>Additional arguments to pass to the <code>train()</code> method. Defaults to {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the results of the hyperparameter search.</p> Example <pre><code>from ultralytics import YOLO\n\n# Load a YOLOv8n model\nmodel = YOLO('yolov8n.pt')\n\n# Start tuning hyperparameters for YOLOv8n training on the COCO8 dataset\nresult_grid = model.tune(data='coco8.yaml', use_ray=True)\n</code></pre> Source code in <code>ultralytics/utils/tuner.py</code> <pre><code>def run_ray_tune(\n    model, space: dict = None, grace_period: int = 10, gpu_per_trial: int = None, max_samples: int = 10, **train_args\n):\n    \"\"\"\n    Runs hyperparameter tuning using Ray Tune.\n\n    Args:\n        model (YOLO): Model to run the tuner on.\n        space (dict, optional): The hyperparameter search space. Defaults to None.\n        grace_period (int, optional): The grace period in epochs of the ASHA scheduler. Defaults to 10.\n        gpu_per_trial (int, optional): The number of GPUs to allocate per trial. Defaults to None.\n        max_samples (int, optional): The maximum number of trials to run. Defaults to 10.\n        train_args (dict, optional): Additional arguments to pass to the `train()` method. Defaults to {}.\n\n    Returns:\n        (dict): A dictionary containing the results of the hyperparameter search.\n\n    Example:\n        ```python\n        from ultralytics import YOLO\n\n        # Load a YOLOv8n model\n        model = YOLO('yolov8n.pt')\n\n        # Start tuning hyperparameters for YOLOv8n training on the COCO8 dataset\n        result_grid = model.tune(data='coco8.yaml', use_ray=True)\n        ```\n    \"\"\"\n\n    LOGGER.info(\"\ud83d\udca1 Learn about RayTune at https://docs.ultralytics.com/integrations/ray-tune\")\n    if train_args is None:\n        train_args = {}\n\n    try:\n        subprocess.run(\"pip install ray[tune]\".split(), check=True)\n\n        import ray\n        from ray import tune\n        from ray.air import RunConfig\n        from ray.air.integrations.wandb import WandbLoggerCallback\n        from ray.tune.schedulers import ASHAScheduler\n    except ImportError:\n        raise ModuleNotFoundError('Tuning hyperparameters requires Ray Tune. Install with: pip install \"ray[tune]\"')\n\n    try:\n        import wandb\n\n        assert hasattr(wandb, \"__version__\")\n    except (ImportError, AssertionError):\n        wandb = False\n\n    default_space = {\n        # 'optimizer': tune.choice(['SGD', 'Adam', 'AdamW', 'NAdam', 'RAdam', 'RMSProp']),\n        \"lr0\": tune.uniform(1e-5, 1e-1),\n        \"lrf\": tune.uniform(0.01, 1.0),  # final OneCycleLR learning rate (lr0 * lrf)\n        \"momentum\": tune.uniform(0.6, 0.98),  # SGD momentum/Adam beta1\n        \"weight_decay\": tune.uniform(0.0, 0.001),  # optimizer weight decay 5e-4\n        \"warmup_epochs\": tune.uniform(0.0, 5.0),  # warmup epochs (fractions ok)\n        \"warmup_momentum\": tune.uniform(0.0, 0.95),  # warmup initial momentum\n        \"box\": tune.uniform(0.02, 0.2),  # box loss gain\n        \"cls\": tune.uniform(0.2, 4.0),  # cls loss gain (scale with pixels)\n        \"hsv_h\": tune.uniform(0.0, 0.1),  # image HSV-Hue augmentation (fraction)\n        \"hsv_s\": tune.uniform(0.0, 0.9),  # image HSV-Saturation augmentation (fraction)\n        \"hsv_v\": tune.uniform(0.0, 0.9),  # image HSV-Value augmentation (fraction)\n        \"degrees\": tune.uniform(0.0, 45.0),  # image rotation (+/- deg)\n        \"translate\": tune.uniform(0.0, 0.9),  # image translation (+/- fraction)\n        \"scale\": tune.uniform(0.0, 0.9),  # image scale (+/- gain)\n        \"shear\": tune.uniform(0.0, 10.0),  # image shear (+/- deg)\n        \"perspective\": tune.uniform(0.0, 0.001),  # image perspective (+/- fraction), range 0-0.001\n        \"flipud\": tune.uniform(0.0, 1.0),  # image flip up-down (probability)\n        \"fliplr\": tune.uniform(0.0, 1.0),  # image flip left-right (probability)\n        \"mosaic\": tune.uniform(0.0, 1.0),  # image mixup (probability)\n        \"mixup\": tune.uniform(0.0, 1.0),  # image mixup (probability)\n        \"copy_paste\": tune.uniform(0.0, 1.0),  # segment copy-paste (probability)\n    }\n\n    # Put the model in ray store\n    task = model.task\n    model_in_store = ray.put(model)\n\n    def _tune(config):\n        \"\"\"\n        Trains the YOLO model with the specified hyperparameters and additional arguments.\n\n        Args:\n            config (dict): A dictionary of hyperparameters to use for training.\n\n        Returns:\n            None.\n        \"\"\"\n        model_to_train = ray.get(model_in_store)  # get the model from ray store for tuning\n        model_to_train.reset_callbacks()\n        config.update(train_args)\n        results = model_to_train.train(**config)\n        return results.results_dict\n\n    # Get search space\n    if not space:\n        space = default_space\n        LOGGER.warning(\"WARNING \u26a0\ufe0f search space not provided, using default search space.\")\n\n    # Get dataset\n    data = train_args.get(\"data\", TASK2DATA[task])\n    space[\"data\"] = data\n    if \"data\" not in train_args:\n        LOGGER.warning(f'WARNING \u26a0\ufe0f data not provided, using default \"data={data}\".')\n\n    # Define the trainable function with allocated resources\n    trainable_with_resources = tune.with_resources(_tune, {\"cpu\": NUM_THREADS, \"gpu\": gpu_per_trial or 0})\n\n    # Define the ASHA scheduler for hyperparameter search\n    asha_scheduler = ASHAScheduler(\n        time_attr=\"epoch\",\n        metric=TASK2METRIC[task],\n        mode=\"max\",\n        max_t=train_args.get(\"epochs\") or DEFAULT_CFG_DICT[\"epochs\"] or 100,\n        grace_period=grace_period,\n        reduction_factor=3,\n    )\n\n    # Define the callbacks for the hyperparameter search\n    tuner_callbacks = [WandbLoggerCallback(project=\"YOLOv8-tune\")] if wandb else []\n\n    # Create the Ray Tune hyperparameter search tuner\n    tune_dir = get_save_dir(DEFAULT_CFG, name=\"tune\").resolve()  # must be absolute dir\n    tune_dir.mkdir(parents=True, exist_ok=True)\n    tuner = tune.Tuner(\n        trainable_with_resources,\n        param_space=space,\n        tune_config=tune.TuneConfig(scheduler=asha_scheduler, num_samples=max_samples),\n        run_config=RunConfig(callbacks=tuner_callbacks, storage_path=tune_dir),\n    )\n\n    # Run the hyperparameter search\n    tuner.fit()\n\n    # Return the results of the hyperparameter search\n    return tuner.get_results()\n</code></pre>"},{"location":"reference/utils/callbacks/base/","title":"Reference for <code>ultralytics/utils/callbacks/base.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/callbacks/base.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/callbacks/base/#ultralytics.utils.callbacks.base.on_pretrain_routine_start","title":"<code>ultralytics.utils.callbacks.base.on_pretrain_routine_start(trainer)</code>","text":"<p>Called before the pretraining routine starts.</p> Source code in <code>ultralytics/utils/callbacks/base.py</code> <pre><code>def on_pretrain_routine_start(trainer):\n    \"\"\"Called before the pretraining routine starts.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/utils/callbacks/base/#ultralytics.utils.callbacks.base.on_pretrain_routine_end","title":"<code>ultralytics.utils.callbacks.base.on_pretrain_routine_end(trainer)</code>","text":"<p>Called after the pretraining routine ends.</p> Source code in <code>ultralytics/utils/callbacks/base.py</code> <pre><code>def on_pretrain_routine_end(trainer):\n    \"\"\"Called after the pretraining routine ends.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/utils/callbacks/base/#ultralytics.utils.callbacks.base.on_train_start","title":"<code>ultralytics.utils.callbacks.base.on_train_start(trainer)</code>","text":"<p>Called when the training starts.</p> Source code in <code>ultralytics/utils/callbacks/base.py</code> <pre><code>def on_train_start(trainer):\n    \"\"\"Called when the training starts.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/utils/callbacks/base/#ultralytics.utils.callbacks.base.on_train_epoch_start","title":"<code>ultralytics.utils.callbacks.base.on_train_epoch_start(trainer)</code>","text":"<p>Called at the start of each training epoch.</p> Source code in <code>ultralytics/utils/callbacks/base.py</code> <pre><code>def on_train_epoch_start(trainer):\n    \"\"\"Called at the start of each training epoch.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/utils/callbacks/base/#ultralytics.utils.callbacks.base.on_train_batch_start","title":"<code>ultralytics.utils.callbacks.base.on_train_batch_start(trainer)</code>","text":"<p>Called at the start of each training batch.</p> Source code in <code>ultralytics/utils/callbacks/base.py</code> <pre><code>def on_train_batch_start(trainer):\n    \"\"\"Called at the start of each training batch.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/utils/callbacks/base/#ultralytics.utils.callbacks.base.optimizer_step","title":"<code>ultralytics.utils.callbacks.base.optimizer_step(trainer)</code>","text":"<p>Called when the optimizer takes a step.</p> Source code in <code>ultralytics/utils/callbacks/base.py</code> <pre><code>def optimizer_step(trainer):\n    \"\"\"Called when the optimizer takes a step.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/utils/callbacks/base/#ultralytics.utils.callbacks.base.on_before_zero_grad","title":"<code>ultralytics.utils.callbacks.base.on_before_zero_grad(trainer)</code>","text":"<p>Called before the gradients are set to zero.</p> Source code in <code>ultralytics/utils/callbacks/base.py</code> <pre><code>def on_before_zero_grad(trainer):\n    \"\"\"Called before the gradients are set to zero.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/utils/callbacks/base/#ultralytics.utils.callbacks.base.on_train_batch_end","title":"<code>ultralytics.utils.callbacks.base.on_train_batch_end(trainer)</code>","text":"<p>Called at the end of each training batch.</p> Source code in <code>ultralytics/utils/callbacks/base.py</code> <pre><code>def on_train_batch_end(trainer):\n    \"\"\"Called at the end of each training batch.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/utils/callbacks/base/#ultralytics.utils.callbacks.base.on_train_epoch_end","title":"<code>ultralytics.utils.callbacks.base.on_train_epoch_end(trainer)</code>","text":"<p>Called at the end of each training epoch.</p> Source code in <code>ultralytics/utils/callbacks/base.py</code> <pre><code>def on_train_epoch_end(trainer):\n    \"\"\"Called at the end of each training epoch.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/utils/callbacks/base/#ultralytics.utils.callbacks.base.on_fit_epoch_end","title":"<code>ultralytics.utils.callbacks.base.on_fit_epoch_end(trainer)</code>","text":"<p>Called at the end of each fit epoch (train + val).</p> Source code in <code>ultralytics/utils/callbacks/base.py</code> <pre><code>def on_fit_epoch_end(trainer):\n    \"\"\"Called at the end of each fit epoch (train + val).\"\"\"\n    pass\n</code></pre>"},{"location":"reference/utils/callbacks/base/#ultralytics.utils.callbacks.base.on_model_save","title":"<code>ultralytics.utils.callbacks.base.on_model_save(trainer)</code>","text":"<p>Called when the model is saved.</p> Source code in <code>ultralytics/utils/callbacks/base.py</code> <pre><code>def on_model_save(trainer):\n    \"\"\"Called when the model is saved.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/utils/callbacks/base/#ultralytics.utils.callbacks.base.on_train_end","title":"<code>ultralytics.utils.callbacks.base.on_train_end(trainer)</code>","text":"<p>Called when the training ends.</p> Source code in <code>ultralytics/utils/callbacks/base.py</code> <pre><code>def on_train_end(trainer):\n    \"\"\"Called when the training ends.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/utils/callbacks/base/#ultralytics.utils.callbacks.base.on_params_update","title":"<code>ultralytics.utils.callbacks.base.on_params_update(trainer)</code>","text":"<p>Called when the model parameters are updated.</p> Source code in <code>ultralytics/utils/callbacks/base.py</code> <pre><code>def on_params_update(trainer):\n    \"\"\"Called when the model parameters are updated.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/utils/callbacks/base/#ultralytics.utils.callbacks.base.teardown","title":"<code>ultralytics.utils.callbacks.base.teardown(trainer)</code>","text":"<p>Called during the teardown of the training process.</p> Source code in <code>ultralytics/utils/callbacks/base.py</code> <pre><code>def teardown(trainer):\n    \"\"\"Called during the teardown of the training process.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/utils/callbacks/base/#ultralytics.utils.callbacks.base.on_val_start","title":"<code>ultralytics.utils.callbacks.base.on_val_start(validator)</code>","text":"<p>Called when the validation starts.</p> Source code in <code>ultralytics/utils/callbacks/base.py</code> <pre><code>def on_val_start(validator):\n    \"\"\"Called when the validation starts.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/utils/callbacks/base/#ultralytics.utils.callbacks.base.on_val_batch_start","title":"<code>ultralytics.utils.callbacks.base.on_val_batch_start(validator)</code>","text":"<p>Called at the start of each validation batch.</p> Source code in <code>ultralytics/utils/callbacks/base.py</code> <pre><code>def on_val_batch_start(validator):\n    \"\"\"Called at the start of each validation batch.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/utils/callbacks/base/#ultralytics.utils.callbacks.base.on_val_batch_end","title":"<code>ultralytics.utils.callbacks.base.on_val_batch_end(validator)</code>","text":"<p>Called at the end of each validation batch.</p> Source code in <code>ultralytics/utils/callbacks/base.py</code> <pre><code>def on_val_batch_end(validator):\n    \"\"\"Called at the end of each validation batch.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/utils/callbacks/base/#ultralytics.utils.callbacks.base.on_val_end","title":"<code>ultralytics.utils.callbacks.base.on_val_end(validator)</code>","text":"<p>Called when the validation ends.</p> Source code in <code>ultralytics/utils/callbacks/base.py</code> <pre><code>def on_val_end(validator):\n    \"\"\"Called when the validation ends.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/utils/callbacks/base/#ultralytics.utils.callbacks.base.on_predict_start","title":"<code>ultralytics.utils.callbacks.base.on_predict_start(predictor)</code>","text":"<p>Called when the prediction starts.</p> Source code in <code>ultralytics/utils/callbacks/base.py</code> <pre><code>def on_predict_start(predictor):\n    \"\"\"Called when the prediction starts.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/utils/callbacks/base/#ultralytics.utils.callbacks.base.on_predict_batch_start","title":"<code>ultralytics.utils.callbacks.base.on_predict_batch_start(predictor)</code>","text":"<p>Called at the start of each prediction batch.</p> Source code in <code>ultralytics/utils/callbacks/base.py</code> <pre><code>def on_predict_batch_start(predictor):\n    \"\"\"Called at the start of each prediction batch.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/utils/callbacks/base/#ultralytics.utils.callbacks.base.on_predict_batch_end","title":"<code>ultralytics.utils.callbacks.base.on_predict_batch_end(predictor)</code>","text":"<p>Called at the end of each prediction batch.</p> Source code in <code>ultralytics/utils/callbacks/base.py</code> <pre><code>def on_predict_batch_end(predictor):\n    \"\"\"Called at the end of each prediction batch.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/utils/callbacks/base/#ultralytics.utils.callbacks.base.on_predict_postprocess_end","title":"<code>ultralytics.utils.callbacks.base.on_predict_postprocess_end(predictor)</code>","text":"<p>Called after the post-processing of the prediction ends.</p> Source code in <code>ultralytics/utils/callbacks/base.py</code> <pre><code>def on_predict_postprocess_end(predictor):\n    \"\"\"Called after the post-processing of the prediction ends.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/utils/callbacks/base/#ultralytics.utils.callbacks.base.on_predict_end","title":"<code>ultralytics.utils.callbacks.base.on_predict_end(predictor)</code>","text":"<p>Called when the prediction ends.</p> Source code in <code>ultralytics/utils/callbacks/base.py</code> <pre><code>def on_predict_end(predictor):\n    \"\"\"Called when the prediction ends.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/utils/callbacks/base/#ultralytics.utils.callbacks.base.on_export_start","title":"<code>ultralytics.utils.callbacks.base.on_export_start(exporter)</code>","text":"<p>Called when the model export starts.</p> Source code in <code>ultralytics/utils/callbacks/base.py</code> <pre><code>def on_export_start(exporter):\n    \"\"\"Called when the model export starts.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/utils/callbacks/base/#ultralytics.utils.callbacks.base.on_export_end","title":"<code>ultralytics.utils.callbacks.base.on_export_end(exporter)</code>","text":"<p>Called when the model export ends.</p> Source code in <code>ultralytics/utils/callbacks/base.py</code> <pre><code>def on_export_end(exporter):\n    \"\"\"Called when the model export ends.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/utils/callbacks/base/#ultralytics.utils.callbacks.base.get_default_callbacks","title":"<code>ultralytics.utils.callbacks.base.get_default_callbacks()</code>","text":"<p>Return a copy of the default_callbacks dictionary with lists as default values.</p> <p>Returns:</p> Type Description <code>defaultdict</code> <p>A defaultdict with keys from default_callbacks and empty lists as default values.</p> Source code in <code>ultralytics/utils/callbacks/base.py</code> <pre><code>def get_default_callbacks():\n    \"\"\"\n    Return a copy of the default_callbacks dictionary with lists as default values.\n\n    Returns:\n        (defaultdict): A defaultdict with keys from default_callbacks and empty lists as default values.\n    \"\"\"\n    return defaultdict(list, deepcopy(default_callbacks))\n</code></pre>"},{"location":"reference/utils/callbacks/base/#ultralytics.utils.callbacks.base.add_integration_callbacks","title":"<code>ultralytics.utils.callbacks.base.add_integration_callbacks(instance)</code>","text":"<p>Add integration callbacks from various sources to the instance's callbacks.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>(Trainer, Predictor, Validator, Exporter)</code> <p>An object with a 'callbacks' attribute that is a dictionary of callback lists.</p> required Source code in <code>ultralytics/utils/callbacks/base.py</code> <pre><code>def add_integration_callbacks(instance):\n    \"\"\"\n    Add integration callbacks from various sources to the instance's callbacks.\n\n    Args:\n        instance (Trainer, Predictor, Validator, Exporter): An object with a 'callbacks' attribute that is a dictionary\n            of callback lists.\n    \"\"\"\n\n    # Load HUB callbacks\n    from .hub import callbacks as hub_cb\n\n    callbacks_list = [hub_cb]\n\n    # Load training callbacks\n    if \"Trainer\" in instance.__class__.__name__:\n        from .clearml import callbacks as clear_cb\n        from .comet import callbacks as comet_cb\n        from .dvc import callbacks as dvc_cb\n        from .mlflow import callbacks as mlflow_cb\n        from .neptune import callbacks as neptune_cb\n        from .raytune import callbacks as tune_cb\n        from .tensorboard import callbacks as tb_cb\n        from .wb import callbacks as wb_cb\n\n        callbacks_list.extend([clear_cb, comet_cb, dvc_cb, mlflow_cb, neptune_cb, tune_cb, tb_cb, wb_cb])\n\n    # Add the callbacks to the callbacks dictionary\n    for callbacks in callbacks_list:\n        for k, v in callbacks.items():\n            if v not in instance.callbacks[k]:\n                instance.callbacks[k].append(v)\n</code></pre>"},{"location":"reference/utils/callbacks/clearml/","title":"Reference for <code>ultralytics/utils/callbacks/clearml.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/callbacks/clearml.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/callbacks/clearml/#ultralytics.utils.callbacks.clearml._log_debug_samples","title":"<code>ultralytics.utils.callbacks.clearml._log_debug_samples(files, title='Debug Samples')</code>","text":"<p>Log files (images) as debug samples in the ClearML task.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>list</code> <p>A list of file paths in PosixPath format.</p> required <code>title</code> <code>str</code> <p>A title that groups together images with the same values.</p> <code>'Debug Samples'</code> Source code in <code>ultralytics/utils/callbacks/clearml.py</code> <pre><code>def _log_debug_samples(files, title=\"Debug Samples\") -&gt; None:\n    \"\"\"\n    Log files (images) as debug samples in the ClearML task.\n\n    Args:\n        files (list): A list of file paths in PosixPath format.\n        title (str): A title that groups together images with the same values.\n    \"\"\"\n    import re\n\n    if task := Task.current_task():\n        for f in files:\n            if f.exists():\n                it = re.search(r\"_batch(\\d+)\", f.name)\n                iteration = int(it.groups()[0]) if it else 0\n                task.get_logger().report_image(\n                    title=title, series=f.name.replace(it.group(), \"\"), local_path=str(f), iteration=iteration\n                )\n</code></pre>"},{"location":"reference/utils/callbacks/clearml/#ultralytics.utils.callbacks.clearml._log_plot","title":"<code>ultralytics.utils.callbacks.clearml._log_plot(title, plot_path)</code>","text":"<p>Log an image as a plot in the plot section of ClearML.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The title of the plot.</p> required <code>plot_path</code> <code>str</code> <p>The path to the saved image file.</p> required Source code in <code>ultralytics/utils/callbacks/clearml.py</code> <pre><code>def _log_plot(title, plot_path) -&gt; None:\n    \"\"\"\n    Log an image as a plot in the plot section of ClearML.\n\n    Args:\n        title (str): The title of the plot.\n        plot_path (str): The path to the saved image file.\n    \"\"\"\n    import matplotlib.image as mpimg\n    import matplotlib.pyplot as plt\n\n    img = mpimg.imread(plot_path)\n    fig = plt.figure()\n    ax = fig.add_axes([0, 0, 1, 1], frameon=False, aspect=\"auto\", xticks=[], yticks=[])  # no ticks\n    ax.imshow(img)\n\n    Task.current_task().get_logger().report_matplotlib_figure(\n        title=title, series=\"\", figure=fig, report_interactive=False\n    )\n</code></pre>"},{"location":"reference/utils/callbacks/clearml/#ultralytics.utils.callbacks.clearml.on_pretrain_routine_start","title":"<code>ultralytics.utils.callbacks.clearml.on_pretrain_routine_start(trainer)</code>","text":"<p>Runs at start of pretraining routine; initializes and connects/ logs task to ClearML.</p> Source code in <code>ultralytics/utils/callbacks/clearml.py</code> <pre><code>def on_pretrain_routine_start(trainer):\n    \"\"\"Runs at start of pretraining routine; initializes and connects/ logs task to ClearML.\"\"\"\n    try:\n        if task := Task.current_task():\n            # Make sure the automatic pytorch and matplotlib bindings are disabled!\n            # We are logging these plots and model files manually in the integration\n            PatchPyTorchModelIO.update_current_task(None)\n            PatchedMatplotlib.update_current_task(None)\n        else:\n            task = Task.init(\n                project_name=trainer.args.project or \"YOLOv8\",\n                task_name=trainer.args.name,\n                tags=[\"YOLOv8\"],\n                output_uri=True,\n                reuse_last_task_id=False,\n                auto_connect_frameworks={\"pytorch\": False, \"matplotlib\": False},\n            )\n            LOGGER.warning(\n                \"ClearML Initialized a new task. If you want to run remotely, \"\n                \"please add clearml-init and connect your arguments before initializing YOLO.\"\n            )\n        task.connect(vars(trainer.args), name=\"General\")\n    except Exception as e:\n        LOGGER.warning(f\"WARNING \u26a0\ufe0f ClearML installed but not initialized correctly, not logging this run. {e}\")\n</code></pre>"},{"location":"reference/utils/callbacks/clearml/#ultralytics.utils.callbacks.clearml.on_train_epoch_end","title":"<code>ultralytics.utils.callbacks.clearml.on_train_epoch_end(trainer)</code>","text":"<p>Logs debug samples for the first epoch of YOLO training and report current training progress.</p> Source code in <code>ultralytics/utils/callbacks/clearml.py</code> <pre><code>def on_train_epoch_end(trainer):\n    \"\"\"Logs debug samples for the first epoch of YOLO training and report current training progress.\"\"\"\n    if task := Task.current_task():\n        # Log debug samples\n        if trainer.epoch == 1:\n            _log_debug_samples(sorted(trainer.save_dir.glob(\"train_batch*.jpg\")), \"Mosaic\")\n        # Report the current training progress\n        for k, v in trainer.label_loss_items(trainer.tloss, prefix=\"train\").items():\n            task.get_logger().report_scalar(\"train\", k, v, iteration=trainer.epoch)\n        for k, v in trainer.lr.items():\n            task.get_logger().report_scalar(\"lr\", k, v, iteration=trainer.epoch)\n</code></pre>"},{"location":"reference/utils/callbacks/clearml/#ultralytics.utils.callbacks.clearml.on_fit_epoch_end","title":"<code>ultralytics.utils.callbacks.clearml.on_fit_epoch_end(trainer)</code>","text":"<p>Reports model information to logger at the end of an epoch.</p> Source code in <code>ultralytics/utils/callbacks/clearml.py</code> <pre><code>def on_fit_epoch_end(trainer):\n    \"\"\"Reports model information to logger at the end of an epoch.\"\"\"\n    if task := Task.current_task():\n        # You should have access to the validation bboxes under jdict\n        task.get_logger().report_scalar(\n            title=\"Epoch Time\", series=\"Epoch Time\", value=trainer.epoch_time, iteration=trainer.epoch\n        )\n        for k, v in trainer.metrics.items():\n            task.get_logger().report_scalar(\"val\", k, v, iteration=trainer.epoch)\n        if trainer.epoch == 0:\n            from ultralytics.utils.torch_utils import model_info_for_loggers\n\n            for k, v in model_info_for_loggers(trainer).items():\n                task.get_logger().report_single_value(k, v)\n</code></pre>"},{"location":"reference/utils/callbacks/clearml/#ultralytics.utils.callbacks.clearml.on_val_end","title":"<code>ultralytics.utils.callbacks.clearml.on_val_end(validator)</code>","text":"<p>Logs validation results including labels and predictions.</p> Source code in <code>ultralytics/utils/callbacks/clearml.py</code> <pre><code>def on_val_end(validator):\n    \"\"\"Logs validation results including labels and predictions.\"\"\"\n    if Task.current_task():\n        # Log val_labels and val_pred\n        _log_debug_samples(sorted(validator.save_dir.glob(\"val*.jpg\")), \"Validation\")\n</code></pre>"},{"location":"reference/utils/callbacks/clearml/#ultralytics.utils.callbacks.clearml.on_train_end","title":"<code>ultralytics.utils.callbacks.clearml.on_train_end(trainer)</code>","text":"<p>Logs final model and its name on training completion.</p> Source code in <code>ultralytics/utils/callbacks/clearml.py</code> <pre><code>def on_train_end(trainer):\n    \"\"\"Logs final model and its name on training completion.\"\"\"\n    if task := Task.current_task():\n        # Log final results, CM matrix + PR plots\n        files = [\n            \"results.png\",\n            \"confusion_matrix.png\",\n            \"confusion_matrix_normalized.png\",\n            *(f\"{x}_curve.png\" for x in (\"F1\", \"PR\", \"P\", \"R\")),\n        ]\n        files = [(trainer.save_dir / f) for f in files if (trainer.save_dir / f).exists()]  # filter\n        for f in files:\n            _log_plot(title=f.stem, plot_path=f)\n        # Report final metrics\n        for k, v in trainer.validator.metrics.results_dict.items():\n            task.get_logger().report_single_value(k, v)\n        # Log the final model\n        task.update_output_model(model_path=str(trainer.best), model_name=trainer.args.name, auto_delete_file=False)\n</code></pre>"},{"location":"reference/utils/callbacks/comet/","title":"Reference for <code>ultralytics/utils/callbacks/comet.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/callbacks/comet.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/callbacks/comet/#ultralytics.utils.callbacks.comet._get_comet_mode","title":"<code>ultralytics.utils.callbacks.comet._get_comet_mode()</code>","text":"<p>Returns the mode of comet set in the environment variables, defaults to 'online' if not set.</p> Source code in <code>ultralytics/utils/callbacks/comet.py</code> <pre><code>def _get_comet_mode():\n    \"\"\"Returns the mode of comet set in the environment variables, defaults to 'online' if not set.\"\"\"\n    return os.getenv(\"COMET_MODE\", \"online\")\n</code></pre>"},{"location":"reference/utils/callbacks/comet/#ultralytics.utils.callbacks.comet._get_comet_model_name","title":"<code>ultralytics.utils.callbacks.comet._get_comet_model_name()</code>","text":"<p>Returns the model name for Comet from the environment variable 'COMET_MODEL_NAME' or defaults to 'YOLOv8'.</p> Source code in <code>ultralytics/utils/callbacks/comet.py</code> <pre><code>def _get_comet_model_name():\n    \"\"\"Returns the model name for Comet from the environment variable 'COMET_MODEL_NAME' or defaults to 'YOLOv8'.\"\"\"\n    return os.getenv(\"COMET_MODEL_NAME\", \"YOLOv8\")\n</code></pre>"},{"location":"reference/utils/callbacks/comet/#ultralytics.utils.callbacks.comet._get_eval_batch_logging_interval","title":"<code>ultralytics.utils.callbacks.comet._get_eval_batch_logging_interval()</code>","text":"<p>Get the evaluation batch logging interval from environment variable or use default value 1.</p> Source code in <code>ultralytics/utils/callbacks/comet.py</code> <pre><code>def _get_eval_batch_logging_interval():\n    \"\"\"Get the evaluation batch logging interval from environment variable or use default value 1.\"\"\"\n    return int(os.getenv(\"COMET_EVAL_BATCH_LOGGING_INTERVAL\", 1))\n</code></pre>"},{"location":"reference/utils/callbacks/comet/#ultralytics.utils.callbacks.comet._get_max_image_predictions_to_log","title":"<code>ultralytics.utils.callbacks.comet._get_max_image_predictions_to_log()</code>","text":"<p>Get the maximum number of image predictions to log from the environment variables.</p> Source code in <code>ultralytics/utils/callbacks/comet.py</code> <pre><code>def _get_max_image_predictions_to_log():\n    \"\"\"Get the maximum number of image predictions to log from the environment variables.\"\"\"\n    return int(os.getenv(\"COMET_MAX_IMAGE_PREDICTIONS\", 100))\n</code></pre>"},{"location":"reference/utils/callbacks/comet/#ultralytics.utils.callbacks.comet._scale_confidence_score","title":"<code>ultralytics.utils.callbacks.comet._scale_confidence_score(score)</code>","text":"<p>Scales the given confidence score by a factor specified in an environment variable.</p> Source code in <code>ultralytics/utils/callbacks/comet.py</code> <pre><code>def _scale_confidence_score(score):\n    \"\"\"Scales the given confidence score by a factor specified in an environment variable.\"\"\"\n    scale = float(os.getenv(\"COMET_MAX_CONFIDENCE_SCORE\", 100.0))\n    return score * scale\n</code></pre>"},{"location":"reference/utils/callbacks/comet/#ultralytics.utils.callbacks.comet._should_log_confusion_matrix","title":"<code>ultralytics.utils.callbacks.comet._should_log_confusion_matrix()</code>","text":"<p>Determines if the confusion matrix should be logged based on the environment variable settings.</p> Source code in <code>ultralytics/utils/callbacks/comet.py</code> <pre><code>def _should_log_confusion_matrix():\n    \"\"\"Determines if the confusion matrix should be logged based on the environment variable settings.\"\"\"\n    return os.getenv(\"COMET_EVAL_LOG_CONFUSION_MATRIX\", \"false\").lower() == \"true\"\n</code></pre>"},{"location":"reference/utils/callbacks/comet/#ultralytics.utils.callbacks.comet._should_log_image_predictions","title":"<code>ultralytics.utils.callbacks.comet._should_log_image_predictions()</code>","text":"<p>Determines whether to log image predictions based on a specified environment variable.</p> Source code in <code>ultralytics/utils/callbacks/comet.py</code> <pre><code>def _should_log_image_predictions():\n    \"\"\"Determines whether to log image predictions based on a specified environment variable.\"\"\"\n    return os.getenv(\"COMET_EVAL_LOG_IMAGE_PREDICTIONS\", \"true\").lower() == \"true\"\n</code></pre>"},{"location":"reference/utils/callbacks/comet/#ultralytics.utils.callbacks.comet._get_experiment_type","title":"<code>ultralytics.utils.callbacks.comet._get_experiment_type(mode, project_name)</code>","text":"<p>Return an experiment based on mode and project name.</p> Source code in <code>ultralytics/utils/callbacks/comet.py</code> <pre><code>def _get_experiment_type(mode, project_name):\n    \"\"\"Return an experiment based on mode and project name.\"\"\"\n    if mode == \"offline\":\n        return comet_ml.OfflineExperiment(project_name=project_name)\n\n    return comet_ml.Experiment(project_name=project_name)\n</code></pre>"},{"location":"reference/utils/callbacks/comet/#ultralytics.utils.callbacks.comet._create_experiment","title":"<code>ultralytics.utils.callbacks.comet._create_experiment(args)</code>","text":"<p>Ensures that the experiment object is only created in a single process during distributed training.</p> Source code in <code>ultralytics/utils/callbacks/comet.py</code> <pre><code>def _create_experiment(args):\n    \"\"\"Ensures that the experiment object is only created in a single process during distributed training.\"\"\"\n    if RANK not in (-1, 0):\n        return\n    try:\n        comet_mode = _get_comet_mode()\n        _project_name = os.getenv(\"COMET_PROJECT_NAME\", args.project)\n        experiment = _get_experiment_type(comet_mode, _project_name)\n        experiment.log_parameters(vars(args))\n        experiment.log_others(\n            {\n                \"eval_batch_logging_interval\": _get_eval_batch_logging_interval(),\n                \"log_confusion_matrix_on_eval\": _should_log_confusion_matrix(),\n                \"log_image_predictions\": _should_log_image_predictions(),\n                \"max_image_predictions\": _get_max_image_predictions_to_log(),\n            }\n        )\n        experiment.log_other(\"Created from\", \"yolov8\")\n\n    except Exception as e:\n        LOGGER.warning(f\"WARNING \u26a0\ufe0f Comet installed but not initialized correctly, not logging this run. {e}\")\n</code></pre>"},{"location":"reference/utils/callbacks/comet/#ultralytics.utils.callbacks.comet._fetch_trainer_metadata","title":"<code>ultralytics.utils.callbacks.comet._fetch_trainer_metadata(trainer)</code>","text":"<p>Returns metadata for YOLO training including epoch and asset saving status.</p> Source code in <code>ultralytics/utils/callbacks/comet.py</code> <pre><code>def _fetch_trainer_metadata(trainer):\n    \"\"\"Returns metadata for YOLO training including epoch and asset saving status.\"\"\"\n    curr_epoch = trainer.epoch + 1\n\n    train_num_steps_per_epoch = len(trainer.train_loader.dataset) // trainer.batch_size\n    curr_step = curr_epoch * train_num_steps_per_epoch\n    final_epoch = curr_epoch == trainer.epochs\n\n    save = trainer.args.save\n    save_period = trainer.args.save_period\n    save_interval = curr_epoch % save_period == 0\n    save_assets = save and save_period &gt; 0 and save_interval and not final_epoch\n\n    return dict(\n        curr_epoch=curr_epoch,\n        curr_step=curr_step,\n        save_assets=save_assets,\n        final_epoch=final_epoch,\n    )\n</code></pre>"},{"location":"reference/utils/callbacks/comet/#ultralytics.utils.callbacks.comet._scale_bounding_box_to_original_image_shape","title":"<code>ultralytics.utils.callbacks.comet._scale_bounding_box_to_original_image_shape(box, resized_image_shape, original_image_shape, ratio_pad)</code>","text":"<p>YOLOv8 resizes images during training and the label values are normalized based on this resized shape.</p> <p>This function rescales the bounding box labels to the original image shape.</p> Source code in <code>ultralytics/utils/callbacks/comet.py</code> <pre><code>def _scale_bounding_box_to_original_image_shape(box, resized_image_shape, original_image_shape, ratio_pad):\n    \"\"\"\n    YOLOv8 resizes images during training and the label values are normalized based on this resized shape.\n\n    This function rescales the bounding box labels to the original image shape.\n    \"\"\"\n\n    resized_image_height, resized_image_width = resized_image_shape\n\n    # Convert normalized xywh format predictions to xyxy in resized scale format\n    box = ops.xywhn2xyxy(box, h=resized_image_height, w=resized_image_width)\n    # Scale box predictions from resized image scale back to original image scale\n    box = ops.scale_boxes(resized_image_shape, box, original_image_shape, ratio_pad)\n    # Convert bounding box format from xyxy to xywh for Comet logging\n    box = ops.xyxy2xywh(box)\n    # Adjust xy center to correspond top-left corner\n    box[:2] -= box[2:] / 2\n    box = box.tolist()\n\n    return box\n</code></pre>"},{"location":"reference/utils/callbacks/comet/#ultralytics.utils.callbacks.comet._format_ground_truth_annotations_for_detection","title":"<code>ultralytics.utils.callbacks.comet._format_ground_truth_annotations_for_detection(img_idx, image_path, batch, class_name_map=None)</code>","text":"<p>Format ground truth annotations for detection.</p> Source code in <code>ultralytics/utils/callbacks/comet.py</code> <pre><code>def _format_ground_truth_annotations_for_detection(img_idx, image_path, batch, class_name_map=None):\n    \"\"\"Format ground truth annotations for detection.\"\"\"\n    indices = batch[\"batch_idx\"] == img_idx\n    bboxes = batch[\"bboxes\"][indices]\n    if len(bboxes) == 0:\n        LOGGER.debug(f\"COMET WARNING: Image: {image_path} has no bounding boxes labels\")\n        return None\n\n    cls_labels = batch[\"cls\"][indices].squeeze(1).tolist()\n    if class_name_map:\n        cls_labels = [str(class_name_map[label]) for label in cls_labels]\n\n    original_image_shape = batch[\"ori_shape\"][img_idx]\n    resized_image_shape = batch[\"resized_shape\"][img_idx]\n    ratio_pad = batch[\"ratio_pad\"][img_idx]\n\n    data = []\n    for box, label in zip(bboxes, cls_labels):\n        box = _scale_bounding_box_to_original_image_shape(box, resized_image_shape, original_image_shape, ratio_pad)\n        data.append(\n            {\n                \"boxes\": [box],\n                \"label\": f\"gt_{label}\",\n                \"score\": _scale_confidence_score(1.0),\n            }\n        )\n\n    return {\"name\": \"ground_truth\", \"data\": data}\n</code></pre>"},{"location":"reference/utils/callbacks/comet/#ultralytics.utils.callbacks.comet._format_prediction_annotations_for_detection","title":"<code>ultralytics.utils.callbacks.comet._format_prediction_annotations_for_detection(image_path, metadata, class_label_map=None)</code>","text":"<p>Format YOLO predictions for object detection visualization.</p> Source code in <code>ultralytics/utils/callbacks/comet.py</code> <pre><code>def _format_prediction_annotations_for_detection(image_path, metadata, class_label_map=None):\n    \"\"\"Format YOLO predictions for object detection visualization.\"\"\"\n    stem = image_path.stem\n    image_id = int(stem) if stem.isnumeric() else stem\n\n    predictions = metadata.get(image_id)\n    if not predictions:\n        LOGGER.debug(f\"COMET WARNING: Image: {image_path} has no bounding boxes predictions\")\n        return None\n\n    data = []\n    for prediction in predictions:\n        boxes = prediction[\"bbox\"]\n        score = _scale_confidence_score(prediction[\"score\"])\n        cls_label = prediction[\"category_id\"]\n        if class_label_map:\n            cls_label = str(class_label_map[cls_label])\n\n        data.append({\"boxes\": [boxes], \"label\": cls_label, \"score\": score})\n\n    return {\"name\": \"prediction\", \"data\": data}\n</code></pre>"},{"location":"reference/utils/callbacks/comet/#ultralytics.utils.callbacks.comet._fetch_annotations","title":"<code>ultralytics.utils.callbacks.comet._fetch_annotations(img_idx, image_path, batch, prediction_metadata_map, class_label_map)</code>","text":"<p>Join the ground truth and prediction annotations if they exist.</p> Source code in <code>ultralytics/utils/callbacks/comet.py</code> <pre><code>def _fetch_annotations(img_idx, image_path, batch, prediction_metadata_map, class_label_map):\n    \"\"\"Join the ground truth and prediction annotations if they exist.\"\"\"\n    ground_truth_annotations = _format_ground_truth_annotations_for_detection(\n        img_idx, image_path, batch, class_label_map\n    )\n    prediction_annotations = _format_prediction_annotations_for_detection(\n        image_path, prediction_metadata_map, class_label_map\n    )\n\n    annotations = [\n        annotation for annotation in [ground_truth_annotations, prediction_annotations] if annotation is not None\n    ]\n    return [annotations] if annotations else None\n</code></pre>"},{"location":"reference/utils/callbacks/comet/#ultralytics.utils.callbacks.comet._create_prediction_metadata_map","title":"<code>ultralytics.utils.callbacks.comet._create_prediction_metadata_map(model_predictions)</code>","text":"<p>Create metadata map for model predictions by groupings them based on image ID.</p> Source code in <code>ultralytics/utils/callbacks/comet.py</code> <pre><code>def _create_prediction_metadata_map(model_predictions):\n    \"\"\"Create metadata map for model predictions by groupings them based on image ID.\"\"\"\n    pred_metadata_map = {}\n    for prediction in model_predictions:\n        pred_metadata_map.setdefault(prediction[\"image_id\"], [])\n        pred_metadata_map[prediction[\"image_id\"]].append(prediction)\n\n    return pred_metadata_map\n</code></pre>"},{"location":"reference/utils/callbacks/comet/#ultralytics.utils.callbacks.comet._log_confusion_matrix","title":"<code>ultralytics.utils.callbacks.comet._log_confusion_matrix(experiment, trainer, curr_step, curr_epoch)</code>","text":"<p>Log the confusion matrix to Comet experiment.</p> Source code in <code>ultralytics/utils/callbacks/comet.py</code> <pre><code>def _log_confusion_matrix(experiment, trainer, curr_step, curr_epoch):\n    \"\"\"Log the confusion matrix to Comet experiment.\"\"\"\n    conf_mat = trainer.validator.confusion_matrix.matrix\n    names = list(trainer.data[\"names\"].values()) + [\"background\"]\n    experiment.log_confusion_matrix(\n        matrix=conf_mat,\n        labels=names,\n        max_categories=len(names),\n        epoch=curr_epoch,\n        step=curr_step,\n    )\n</code></pre>"},{"location":"reference/utils/callbacks/comet/#ultralytics.utils.callbacks.comet._log_images","title":"<code>ultralytics.utils.callbacks.comet._log_images(experiment, image_paths, curr_step, annotations=None)</code>","text":"<p>Logs images to the experiment with optional annotations.</p> Source code in <code>ultralytics/utils/callbacks/comet.py</code> <pre><code>def _log_images(experiment, image_paths, curr_step, annotations=None):\n    \"\"\"Logs images to the experiment with optional annotations.\"\"\"\n    if annotations:\n        for image_path, annotation in zip(image_paths, annotations):\n            experiment.log_image(image_path, name=image_path.stem, step=curr_step, annotations=annotation)\n\n    else:\n        for image_path in image_paths:\n            experiment.log_image(image_path, name=image_path.stem, step=curr_step)\n</code></pre>"},{"location":"reference/utils/callbacks/comet/#ultralytics.utils.callbacks.comet._log_image_predictions","title":"<code>ultralytics.utils.callbacks.comet._log_image_predictions(experiment, validator, curr_step)</code>","text":"<p>Logs predicted boxes for a single image during training.</p> Source code in <code>ultralytics/utils/callbacks/comet.py</code> <pre><code>def _log_image_predictions(experiment, validator, curr_step):\n    \"\"\"Logs predicted boxes for a single image during training.\"\"\"\n    global _comet_image_prediction_count\n\n    task = validator.args.task\n    if task not in COMET_SUPPORTED_TASKS:\n        return\n\n    jdict = validator.jdict\n    if not jdict:\n        return\n\n    predictions_metadata_map = _create_prediction_metadata_map(jdict)\n    dataloader = validator.dataloader\n    class_label_map = validator.names\n\n    batch_logging_interval = _get_eval_batch_logging_interval()\n    max_image_predictions = _get_max_image_predictions_to_log()\n\n    for batch_idx, batch in enumerate(dataloader):\n        if (batch_idx + 1) % batch_logging_interval != 0:\n            continue\n\n        image_paths = batch[\"im_file\"]\n        for img_idx, image_path in enumerate(image_paths):\n            if _comet_image_prediction_count &gt;= max_image_predictions:\n                return\n\n            image_path = Path(image_path)\n            annotations = _fetch_annotations(\n                img_idx,\n                image_path,\n                batch,\n                predictions_metadata_map,\n                class_label_map,\n            )\n            _log_images(\n                experiment,\n                [image_path],\n                curr_step,\n                annotations=annotations,\n            )\n            _comet_image_prediction_count += 1\n</code></pre>"},{"location":"reference/utils/callbacks/comet/#ultralytics.utils.callbacks.comet._log_plots","title":"<code>ultralytics.utils.callbacks.comet._log_plots(experiment, trainer)</code>","text":"<p>Logs evaluation plots and label plots for the experiment.</p> Source code in <code>ultralytics/utils/callbacks/comet.py</code> <pre><code>def _log_plots(experiment, trainer):\n    \"\"\"Logs evaluation plots and label plots for the experiment.\"\"\"\n    plot_filenames = [trainer.save_dir / f\"{plots}.png\" for plots in EVALUATION_PLOT_NAMES]\n    _log_images(experiment, plot_filenames, None)\n\n    label_plot_filenames = [trainer.save_dir / f\"{labels}.jpg\" for labels in LABEL_PLOT_NAMES]\n    _log_images(experiment, label_plot_filenames, None)\n</code></pre>"},{"location":"reference/utils/callbacks/comet/#ultralytics.utils.callbacks.comet._log_model","title":"<code>ultralytics.utils.callbacks.comet._log_model(experiment, trainer)</code>","text":"<p>Log the best-trained model to Comet.ml.</p> Source code in <code>ultralytics/utils/callbacks/comet.py</code> <pre><code>def _log_model(experiment, trainer):\n    \"\"\"Log the best-trained model to Comet.ml.\"\"\"\n    model_name = _get_comet_model_name()\n    experiment.log_model(\n        model_name,\n        file_or_folder=str(trainer.best),\n        file_name=\"best.pt\",\n        overwrite=True,\n    )\n</code></pre>"},{"location":"reference/utils/callbacks/comet/#ultralytics.utils.callbacks.comet.on_pretrain_routine_start","title":"<code>ultralytics.utils.callbacks.comet.on_pretrain_routine_start(trainer)</code>","text":"<p>Creates or resumes a CometML experiment at the start of a YOLO pre-training routine.</p> Source code in <code>ultralytics/utils/callbacks/comet.py</code> <pre><code>def on_pretrain_routine_start(trainer):\n    \"\"\"Creates or resumes a CometML experiment at the start of a YOLO pre-training routine.\"\"\"\n    experiment = comet_ml.get_global_experiment()\n    is_alive = getattr(experiment, \"alive\", False)\n    if not experiment or not is_alive:\n        _create_experiment(trainer.args)\n</code></pre>"},{"location":"reference/utils/callbacks/comet/#ultralytics.utils.callbacks.comet.on_train_epoch_end","title":"<code>ultralytics.utils.callbacks.comet.on_train_epoch_end(trainer)</code>","text":"<p>Log metrics and save batch images at the end of training epochs.</p> Source code in <code>ultralytics/utils/callbacks/comet.py</code> <pre><code>def on_train_epoch_end(trainer):\n    \"\"\"Log metrics and save batch images at the end of training epochs.\"\"\"\n    experiment = comet_ml.get_global_experiment()\n    if not experiment:\n        return\n\n    metadata = _fetch_trainer_metadata(trainer)\n    curr_epoch = metadata[\"curr_epoch\"]\n    curr_step = metadata[\"curr_step\"]\n\n    experiment.log_metrics(\n        trainer.label_loss_items(trainer.tloss, prefix=\"train\"),\n        step=curr_step,\n        epoch=curr_epoch,\n    )\n\n    if curr_epoch == 1:\n        _log_images(experiment, trainer.save_dir.glob(\"train_batch*.jpg\"), curr_step)\n</code></pre>"},{"location":"reference/utils/callbacks/comet/#ultralytics.utils.callbacks.comet.on_fit_epoch_end","title":"<code>ultralytics.utils.callbacks.comet.on_fit_epoch_end(trainer)</code>","text":"<p>Logs model assets at the end of each epoch.</p> Source code in <code>ultralytics/utils/callbacks/comet.py</code> <pre><code>def on_fit_epoch_end(trainer):\n    \"\"\"Logs model assets at the end of each epoch.\"\"\"\n    experiment = comet_ml.get_global_experiment()\n    if not experiment:\n        return\n\n    metadata = _fetch_trainer_metadata(trainer)\n    curr_epoch = metadata[\"curr_epoch\"]\n    curr_step = metadata[\"curr_step\"]\n    save_assets = metadata[\"save_assets\"]\n\n    experiment.log_metrics(trainer.metrics, step=curr_step, epoch=curr_epoch)\n    experiment.log_metrics(trainer.lr, step=curr_step, epoch=curr_epoch)\n    if curr_epoch == 1:\n        from ultralytics.utils.torch_utils import model_info_for_loggers\n\n        experiment.log_metrics(model_info_for_loggers(trainer), step=curr_step, epoch=curr_epoch)\n\n    if not save_assets:\n        return\n\n    _log_model(experiment, trainer)\n    if _should_log_confusion_matrix():\n        _log_confusion_matrix(experiment, trainer, curr_step, curr_epoch)\n    if _should_log_image_predictions():\n        _log_image_predictions(experiment, trainer.validator, curr_step)\n</code></pre>"},{"location":"reference/utils/callbacks/comet/#ultralytics.utils.callbacks.comet.on_train_end","title":"<code>ultralytics.utils.callbacks.comet.on_train_end(trainer)</code>","text":"<p>Perform operations at the end of training.</p> Source code in <code>ultralytics/utils/callbacks/comet.py</code> <pre><code>def on_train_end(trainer):\n    \"\"\"Perform operations at the end of training.\"\"\"\n    experiment = comet_ml.get_global_experiment()\n    if not experiment:\n        return\n\n    metadata = _fetch_trainer_metadata(trainer)\n    curr_epoch = metadata[\"curr_epoch\"]\n    curr_step = metadata[\"curr_step\"]\n    plots = trainer.args.plots\n\n    _log_model(experiment, trainer)\n    if plots:\n        _log_plots(experiment, trainer)\n\n    _log_confusion_matrix(experiment, trainer, curr_step, curr_epoch)\n    _log_image_predictions(experiment, trainer.validator, curr_step)\n    experiment.end()\n\n    global _comet_image_prediction_count\n    _comet_image_prediction_count = 0\n</code></pre>"},{"location":"reference/utils/callbacks/dvc/","title":"Reference for <code>ultralytics/utils/callbacks/dvc.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/callbacks/dvc.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/callbacks/dvc/#ultralytics.utils.callbacks.dvc._log_images","title":"<code>ultralytics.utils.callbacks.dvc._log_images(path, prefix='')</code>","text":"<p>Logs images at specified path with an optional prefix using DVCLive.</p> Source code in <code>ultralytics/utils/callbacks/dvc.py</code> <pre><code>def _log_images(path, prefix=\"\"):\n    \"\"\"Logs images at specified path with an optional prefix using DVCLive.\"\"\"\n    if live:\n        name = path.name\n\n        # Group images by batch to enable sliders in UI\n        if m := re.search(r\"_batch(\\d+)\", name):\n            ni = m[1]\n            new_stem = re.sub(r\"_batch(\\d+)\", \"_batch\", path.stem)\n            name = (Path(new_stem) / ni).with_suffix(path.suffix)\n\n        live.log_image(os.path.join(prefix, name), path)\n</code></pre>"},{"location":"reference/utils/callbacks/dvc/#ultralytics.utils.callbacks.dvc._log_plots","title":"<code>ultralytics.utils.callbacks.dvc._log_plots(plots, prefix='')</code>","text":"<p>Logs plot images for training progress if they have not been previously processed.</p> Source code in <code>ultralytics/utils/callbacks/dvc.py</code> <pre><code>def _log_plots(plots, prefix=\"\"):\n    \"\"\"Logs plot images for training progress if they have not been previously processed.\"\"\"\n    for name, params in plots.items():\n        timestamp = params[\"timestamp\"]\n        if _processed_plots.get(name) != timestamp:\n            _log_images(name, prefix)\n            _processed_plots[name] = timestamp\n</code></pre>"},{"location":"reference/utils/callbacks/dvc/#ultralytics.utils.callbacks.dvc._log_confusion_matrix","title":"<code>ultralytics.utils.callbacks.dvc._log_confusion_matrix(validator)</code>","text":"<p>Logs the confusion matrix for the given validator using DVCLive.</p> Source code in <code>ultralytics/utils/callbacks/dvc.py</code> <pre><code>def _log_confusion_matrix(validator):\n    \"\"\"Logs the confusion matrix for the given validator using DVCLive.\"\"\"\n    targets = []\n    preds = []\n    matrix = validator.confusion_matrix.matrix\n    names = list(validator.names.values())\n    if validator.confusion_matrix.task == \"detect\":\n        names += [\"background\"]\n\n    for ti, pred in enumerate(matrix.T.astype(int)):\n        for pi, num in enumerate(pred):\n            targets.extend([names[ti]] * num)\n            preds.extend([names[pi]] * num)\n\n    live.log_sklearn_plot(\"confusion_matrix\", targets, preds, name=\"cf.json\", normalized=True)\n</code></pre>"},{"location":"reference/utils/callbacks/dvc/#ultralytics.utils.callbacks.dvc.on_pretrain_routine_start","title":"<code>ultralytics.utils.callbacks.dvc.on_pretrain_routine_start(trainer)</code>","text":"<p>Initializes DVCLive logger for training metadata during pre-training routine.</p> Source code in <code>ultralytics/utils/callbacks/dvc.py</code> <pre><code>def on_pretrain_routine_start(trainer):\n    \"\"\"Initializes DVCLive logger for training metadata during pre-training routine.\"\"\"\n    try:\n        global live\n        live = dvclive.Live(save_dvc_exp=True, cache_images=True)\n        LOGGER.info(\"DVCLive is detected and auto logging is enabled (run 'yolo settings dvc=False' to disable).\")\n    except Exception as e:\n        LOGGER.warning(f\"WARNING \u26a0\ufe0f DVCLive installed but not initialized correctly, not logging this run. {e}\")\n</code></pre>"},{"location":"reference/utils/callbacks/dvc/#ultralytics.utils.callbacks.dvc.on_pretrain_routine_end","title":"<code>ultralytics.utils.callbacks.dvc.on_pretrain_routine_end(trainer)</code>","text":"<p>Logs plots related to the training process at the end of the pretraining routine.</p> Source code in <code>ultralytics/utils/callbacks/dvc.py</code> <pre><code>def on_pretrain_routine_end(trainer):\n    \"\"\"Logs plots related to the training process at the end of the pretraining routine.\"\"\"\n    _log_plots(trainer.plots, \"train\")\n</code></pre>"},{"location":"reference/utils/callbacks/dvc/#ultralytics.utils.callbacks.dvc.on_train_start","title":"<code>ultralytics.utils.callbacks.dvc.on_train_start(trainer)</code>","text":"<p>Logs the training parameters if DVCLive logging is active.</p> Source code in <code>ultralytics/utils/callbacks/dvc.py</code> <pre><code>def on_train_start(trainer):\n    \"\"\"Logs the training parameters if DVCLive logging is active.\"\"\"\n    if live:\n        live.log_params(trainer.args)\n</code></pre>"},{"location":"reference/utils/callbacks/dvc/#ultralytics.utils.callbacks.dvc.on_train_epoch_start","title":"<code>ultralytics.utils.callbacks.dvc.on_train_epoch_start(trainer)</code>","text":"<p>Sets the global variable _training_epoch value to True at the start of training each epoch.</p> Source code in <code>ultralytics/utils/callbacks/dvc.py</code> <pre><code>def on_train_epoch_start(trainer):\n    \"\"\"Sets the global variable _training_epoch value to True at the start of training each epoch.\"\"\"\n    global _training_epoch\n    _training_epoch = True\n</code></pre>"},{"location":"reference/utils/callbacks/dvc/#ultralytics.utils.callbacks.dvc.on_fit_epoch_end","title":"<code>ultralytics.utils.callbacks.dvc.on_fit_epoch_end(trainer)</code>","text":"<p>Logs training metrics and model info, and advances to next step on the end of each fit epoch.</p> Source code in <code>ultralytics/utils/callbacks/dvc.py</code> <pre><code>def on_fit_epoch_end(trainer):\n    \"\"\"Logs training metrics and model info, and advances to next step on the end of each fit epoch.\"\"\"\n    global _training_epoch\n    if live and _training_epoch:\n        all_metrics = {**trainer.label_loss_items(trainer.tloss, prefix=\"train\"), **trainer.metrics, **trainer.lr}\n        for metric, value in all_metrics.items():\n            live.log_metric(metric, value)\n\n        if trainer.epoch == 0:\n            from ultralytics.utils.torch_utils import model_info_for_loggers\n\n            for metric, value in model_info_for_loggers(trainer).items():\n                live.log_metric(metric, value, plot=False)\n\n        _log_plots(trainer.plots, \"train\")\n        _log_plots(trainer.validator.plots, \"val\")\n\n        live.next_step()\n        _training_epoch = False\n</code></pre>"},{"location":"reference/utils/callbacks/dvc/#ultralytics.utils.callbacks.dvc.on_train_end","title":"<code>ultralytics.utils.callbacks.dvc.on_train_end(trainer)</code>","text":"<p>Logs the best metrics, plots, and confusion matrix at the end of training if DVCLive is active.</p> Source code in <code>ultralytics/utils/callbacks/dvc.py</code> <pre><code>def on_train_end(trainer):\n    \"\"\"Logs the best metrics, plots, and confusion matrix at the end of training if DVCLive is active.\"\"\"\n    if live:\n        # At the end log the best metrics. It runs validator on the best model internally.\n        all_metrics = {**trainer.label_loss_items(trainer.tloss, prefix=\"train\"), **trainer.metrics, **trainer.lr}\n        for metric, value in all_metrics.items():\n            live.log_metric(metric, value, plot=False)\n\n        _log_plots(trainer.plots, \"val\")\n        _log_plots(trainer.validator.plots, \"val\")\n        _log_confusion_matrix(trainer.validator)\n\n        if trainer.best.exists():\n            live.log_artifact(trainer.best, copy=True, type=\"model\")\n\n        live.end()\n</code></pre>"},{"location":"reference/utils/callbacks/hub/","title":"Reference for <code>ultralytics/utils/callbacks/hub.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/callbacks/hub.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/callbacks/hub/#ultralytics.utils.callbacks.hub.on_pretrain_routine_end","title":"<code>ultralytics.utils.callbacks.hub.on_pretrain_routine_end(trainer)</code>","text":"<p>Logs info before starting timer for upload rate limit.</p> Source code in <code>ultralytics/utils/callbacks/hub.py</code> <pre><code>def on_pretrain_routine_end(trainer):\n    \"\"\"Logs info before starting timer for upload rate limit.\"\"\"\n    session = getattr(trainer, \"hub_session\", None)\n    if session:\n        # Start timer for upload rate limit\n        session.timers = {\n            \"metrics\": time(),\n            \"ckpt\": time(),\n        }  # start timer on session.rate_limit\n</code></pre>"},{"location":"reference/utils/callbacks/hub/#ultralytics.utils.callbacks.hub.on_fit_epoch_end","title":"<code>ultralytics.utils.callbacks.hub.on_fit_epoch_end(trainer)</code>","text":"<p>Uploads training progress metrics at the end of each epoch.</p> Source code in <code>ultralytics/utils/callbacks/hub.py</code> <pre><code>def on_fit_epoch_end(trainer):\n    \"\"\"Uploads training progress metrics at the end of each epoch.\"\"\"\n    session = getattr(trainer, \"hub_session\", None)\n    if session:\n        # Upload metrics after val end\n        all_plots = {\n            **trainer.label_loss_items(trainer.tloss, prefix=\"train\"),\n            **trainer.metrics,\n        }\n        if trainer.epoch == 0:\n            from ultralytics.utils.torch_utils import model_info_for_loggers\n\n            all_plots = {**all_plots, **model_info_for_loggers(trainer)}\n\n        session.metrics_queue[trainer.epoch] = json.dumps(all_plots)\n        if time() - session.timers[\"metrics\"] &gt; session.rate_limits[\"metrics\"]:\n            session.upload_metrics()\n            session.timers[\"metrics\"] = time()  # reset timer\n            session.metrics_queue = {}  # reset queue\n</code></pre>"},{"location":"reference/utils/callbacks/hub/#ultralytics.utils.callbacks.hub.on_model_save","title":"<code>ultralytics.utils.callbacks.hub.on_model_save(trainer)</code>","text":"<p>Saves checkpoints to Ultralytics HUB with rate limiting.</p> Source code in <code>ultralytics/utils/callbacks/hub.py</code> <pre><code>def on_model_save(trainer):\n    \"\"\"Saves checkpoints to Ultralytics HUB with rate limiting.\"\"\"\n    session = getattr(trainer, \"hub_session\", None)\n    if session:\n        # Upload checkpoints with rate limiting\n        is_best = trainer.best_fitness == trainer.fitness\n        if time() - session.timers[\"ckpt\"] &gt; session.rate_limits[\"ckpt\"]:\n            LOGGER.info(f\"{PREFIX}Uploading checkpoint {HUB_WEB_ROOT}/models/{session.model_file}\")\n            session.upload_model(trainer.epoch, trainer.last, is_best)\n            session.timers[\"ckpt\"] = time()  # reset timer\n</code></pre>"},{"location":"reference/utils/callbacks/hub/#ultralytics.utils.callbacks.hub.on_train_end","title":"<code>ultralytics.utils.callbacks.hub.on_train_end(trainer)</code>","text":"<p>Upload final model and metrics to Ultralytics HUB at the end of training.</p> Source code in <code>ultralytics/utils/callbacks/hub.py</code> <pre><code>def on_train_end(trainer):\n    \"\"\"Upload final model and metrics to Ultralytics HUB at the end of training.\"\"\"\n    session = getattr(trainer, \"hub_session\", None)\n    if session:\n        # Upload final model and metrics with exponential standoff\n        LOGGER.info(f\"{PREFIX}Syncing final model...\")\n        session.upload_model(\n            trainer.epoch,\n            trainer.best,\n            map=trainer.metrics.get(\"metrics/mAP50-95(B)\", 0),\n            final=True,\n        )\n        session.alive = False  # stop heartbeats\n        LOGGER.info(f\"{PREFIX}Done \u2705\\n\" f\"{PREFIX}View model at {session.model_url} \ud83d\ude80\")\n</code></pre>"},{"location":"reference/utils/callbacks/hub/#ultralytics.utils.callbacks.hub.on_train_start","title":"<code>ultralytics.utils.callbacks.hub.on_train_start(trainer)</code>","text":"<p>Run events on train start.</p> Source code in <code>ultralytics/utils/callbacks/hub.py</code> <pre><code>def on_train_start(trainer):\n    \"\"\"Run events on train start.\"\"\"\n    events(trainer.args)\n</code></pre>"},{"location":"reference/utils/callbacks/hub/#ultralytics.utils.callbacks.hub.on_val_start","title":"<code>ultralytics.utils.callbacks.hub.on_val_start(validator)</code>","text":"<p>Runs events on validation start.</p> Source code in <code>ultralytics/utils/callbacks/hub.py</code> <pre><code>def on_val_start(validator):\n    \"\"\"Runs events on validation start.\"\"\"\n    events(validator.args)\n</code></pre>"},{"location":"reference/utils/callbacks/hub/#ultralytics.utils.callbacks.hub.on_predict_start","title":"<code>ultralytics.utils.callbacks.hub.on_predict_start(predictor)</code>","text":"<p>Run events on predict start.</p> Source code in <code>ultralytics/utils/callbacks/hub.py</code> <pre><code>def on_predict_start(predictor):\n    \"\"\"Run events on predict start.\"\"\"\n    events(predictor.args)\n</code></pre>"},{"location":"reference/utils/callbacks/hub/#ultralytics.utils.callbacks.hub.on_export_start","title":"<code>ultralytics.utils.callbacks.hub.on_export_start(exporter)</code>","text":"<p>Run events on export start.</p> Source code in <code>ultralytics/utils/callbacks/hub.py</code> <pre><code>def on_export_start(exporter):\n    \"\"\"Run events on export start.\"\"\"\n    events(exporter.args)\n</code></pre>"},{"location":"reference/utils/callbacks/mlflow/","title":"Reference for <code>ultralytics/utils/callbacks/mlflow.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/callbacks/mlflow.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/callbacks/mlflow/#ultralytics.utils.callbacks.mlflow.on_pretrain_routine_end","title":"<code>ultralytics.utils.callbacks.mlflow.on_pretrain_routine_end(trainer)</code>","text":"<p>Log training parameters to MLflow at the end of the pretraining routine.</p> <p>This function sets up MLflow logging based on environment variables and trainer arguments. It sets the tracking URI, experiment name, and run name, then starts the MLflow run if not already active. It finally logs the parameters from the trainer.</p> <p>Parameters:</p> Name Type Description Default <code>trainer</code> <code>BaseTrainer</code> <p>The training object with arguments and parameters to log.</p> required Global <p>mlflow: The imported mlflow module to use for logging.</p> Environment Variables <p>MLFLOW_TRACKING_URI: The URI for MLflow tracking. If not set, defaults to 'runs/mlflow'. MLFLOW_EXPERIMENT_NAME: The name of the MLflow experiment. If not set, defaults to trainer.args.project. MLFLOW_RUN: The name of the MLflow run. If not set, defaults to trainer.args.name.</p> Source code in <code>ultralytics/utils/callbacks/mlflow.py</code> <pre><code>def on_pretrain_routine_end(trainer):\n    \"\"\"\n    Log training parameters to MLflow at the end of the pretraining routine.\n\n    This function sets up MLflow logging based on environment variables and trainer arguments. It sets the tracking URI,\n    experiment name, and run name, then starts the MLflow run if not already active. It finally logs the parameters\n    from the trainer.\n\n    Args:\n        trainer (ultralytics.engine.trainer.BaseTrainer): The training object with arguments and parameters to log.\n\n    Global:\n        mlflow: The imported mlflow module to use for logging.\n\n    Environment Variables:\n        MLFLOW_TRACKING_URI: The URI for MLflow tracking. If not set, defaults to 'runs/mlflow'.\n        MLFLOW_EXPERIMENT_NAME: The name of the MLflow experiment. If not set, defaults to trainer.args.project.\n        MLFLOW_RUN: The name of the MLflow run. If not set, defaults to trainer.args.name.\n    \"\"\"\n    global mlflow\n\n    uri = os.environ.get(\"MLFLOW_TRACKING_URI\") or str(RUNS_DIR / \"mlflow\")\n    LOGGER.debug(f\"{PREFIX} tracking uri: {uri}\")\n    mlflow.set_tracking_uri(uri)\n\n    # Set experiment and run names\n    experiment_name = os.environ.get(\"MLFLOW_EXPERIMENT_NAME\") or trainer.args.project or \"/Shared/YOLOv8\"\n    run_name = os.environ.get(\"MLFLOW_RUN\") or trainer.args.name\n    mlflow.set_experiment(experiment_name)\n\n    mlflow.autolog()\n    try:\n        active_run = mlflow.active_run() or mlflow.start_run(run_name=run_name)\n        LOGGER.info(f\"{PREFIX}logging run_id({active_run.info.run_id}) to {uri}\")\n        if Path(uri).is_dir():\n            LOGGER.info(f\"{PREFIX}view at http://127.0.0.1:5000 with 'mlflow server --backend-store-uri {uri}'\")\n        LOGGER.info(f\"{PREFIX}disable with 'yolo settings mlflow=False'\")\n        mlflow.log_params(dict(trainer.args))\n    except Exception as e:\n        LOGGER.warning(f\"{PREFIX}WARNING \u26a0\ufe0f Failed to initialize: {e}\\n\" f\"{PREFIX}WARNING \u26a0\ufe0f Not tracking this run\")\n</code></pre>"},{"location":"reference/utils/callbacks/mlflow/#ultralytics.utils.callbacks.mlflow.on_train_epoch_end","title":"<code>ultralytics.utils.callbacks.mlflow.on_train_epoch_end(trainer)</code>","text":"<p>Log training metrics at the end of each train epoch to MLflow.</p> Source code in <code>ultralytics/utils/callbacks/mlflow.py</code> <pre><code>def on_train_epoch_end(trainer):\n    \"\"\"Log training metrics at the end of each train epoch to MLflow.\"\"\"\n    if mlflow:\n        mlflow.log_metrics(\n            metrics=SANITIZE(trainer.label_loss_items(trainer.tloss, prefix=\"train\")), step=trainer.epoch\n        )\n        mlflow.log_metrics(metrics=SANITIZE(trainer.lr), step=trainer.epoch)\n</code></pre>"},{"location":"reference/utils/callbacks/mlflow/#ultralytics.utils.callbacks.mlflow.on_fit_epoch_end","title":"<code>ultralytics.utils.callbacks.mlflow.on_fit_epoch_end(trainer)</code>","text":"<p>Log training metrics at the end of each fit epoch to MLflow.</p> Source code in <code>ultralytics/utils/callbacks/mlflow.py</code> <pre><code>def on_fit_epoch_end(trainer):\n    \"\"\"Log training metrics at the end of each fit epoch to MLflow.\"\"\"\n    if mlflow:\n        mlflow.log_metrics(metrics=SANITIZE(trainer.metrics), step=trainer.epoch)\n</code></pre>"},{"location":"reference/utils/callbacks/mlflow/#ultralytics.utils.callbacks.mlflow.on_train_end","title":"<code>ultralytics.utils.callbacks.mlflow.on_train_end(trainer)</code>","text":"<p>Log model artifacts at the end of the training.</p> Source code in <code>ultralytics/utils/callbacks/mlflow.py</code> <pre><code>def on_train_end(trainer):\n    \"\"\"Log model artifacts at the end of the training.\"\"\"\n    if mlflow:\n        mlflow.log_artifact(str(trainer.best.parent))  # log save_dir/weights directory with best.pt and last.pt\n        for f in trainer.save_dir.glob(\"*\"):  # log all other files in save_dir\n            if f.suffix in {\".png\", \".jpg\", \".csv\", \".pt\", \".yaml\"}:\n                mlflow.log_artifact(str(f))\n\n        mlflow.end_run()\n        LOGGER.info(\n            f\"{PREFIX}results logged to {mlflow.get_tracking_uri()}\\n\"\n            f\"{PREFIX}disable with 'yolo settings mlflow=False'\"\n        )\n</code></pre>"},{"location":"reference/utils/callbacks/neptune/","title":"Reference for <code>ultralytics/utils/callbacks/neptune.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/callbacks/neptune.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/callbacks/neptune/#ultralytics.utils.callbacks.neptune._log_scalars","title":"<code>ultralytics.utils.callbacks.neptune._log_scalars(scalars, step=0)</code>","text":"<p>Log scalars to the NeptuneAI experiment logger.</p> Source code in <code>ultralytics/utils/callbacks/neptune.py</code> <pre><code>def _log_scalars(scalars, step=0):\n    \"\"\"Log scalars to the NeptuneAI experiment logger.\"\"\"\n    if run:\n        for k, v in scalars.items():\n            run[k].append(value=v, step=step)\n</code></pre>"},{"location":"reference/utils/callbacks/neptune/#ultralytics.utils.callbacks.neptune._log_images","title":"<code>ultralytics.utils.callbacks.neptune._log_images(imgs_dict, group='')</code>","text":"<p>Log scalars to the NeptuneAI experiment logger.</p> Source code in <code>ultralytics/utils/callbacks/neptune.py</code> <pre><code>def _log_images(imgs_dict, group=\"\"):\n    \"\"\"Log scalars to the NeptuneAI experiment logger.\"\"\"\n    if run:\n        for k, v in imgs_dict.items():\n            run[f\"{group}/{k}\"].upload(File(v))\n</code></pre>"},{"location":"reference/utils/callbacks/neptune/#ultralytics.utils.callbacks.neptune._log_plot","title":"<code>ultralytics.utils.callbacks.neptune._log_plot(title, plot_path)</code>","text":"<p>Log plots to the NeptuneAI experiment logger.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the plot.</p> required <code>plot_path</code> <code>PosixPath | str</code> <p>Path to the saved image file.</p> required Source code in <code>ultralytics/utils/callbacks/neptune.py</code> <pre><code>def _log_plot(title, plot_path):\n    \"\"\"\n    Log plots to the NeptuneAI experiment logger.\n\n    Args:\n        title (str): Title of the plot.\n        plot_path (PosixPath | str): Path to the saved image file.\n    \"\"\"\n    import matplotlib.image as mpimg\n    import matplotlib.pyplot as plt\n\n    img = mpimg.imread(plot_path)\n    fig = plt.figure()\n    ax = fig.add_axes([0, 0, 1, 1], frameon=False, aspect=\"auto\", xticks=[], yticks=[])  # no ticks\n    ax.imshow(img)\n    run[f\"Plots/{title}\"].upload(fig)\n</code></pre>"},{"location":"reference/utils/callbacks/neptune/#ultralytics.utils.callbacks.neptune.on_pretrain_routine_start","title":"<code>ultralytics.utils.callbacks.neptune.on_pretrain_routine_start(trainer)</code>","text":"<p>Callback function called before the training routine starts.</p> Source code in <code>ultralytics/utils/callbacks/neptune.py</code> <pre><code>def on_pretrain_routine_start(trainer):\n    \"\"\"Callback function called before the training routine starts.\"\"\"\n    try:\n        global run\n        run = neptune.init_run(project=trainer.args.project or \"YOLOv8\", name=trainer.args.name, tags=[\"YOLOv8\"])\n        run[\"Configuration/Hyperparameters\"] = {k: \"\" if v is None else v for k, v in vars(trainer.args).items()}\n    except Exception as e:\n        LOGGER.warning(f\"WARNING \u26a0\ufe0f NeptuneAI installed but not initialized correctly, not logging this run. {e}\")\n</code></pre>"},{"location":"reference/utils/callbacks/neptune/#ultralytics.utils.callbacks.neptune.on_train_epoch_end","title":"<code>ultralytics.utils.callbacks.neptune.on_train_epoch_end(trainer)</code>","text":"<p>Callback function called at end of each training epoch.</p> Source code in <code>ultralytics/utils/callbacks/neptune.py</code> <pre><code>def on_train_epoch_end(trainer):\n    \"\"\"Callback function called at end of each training epoch.\"\"\"\n    _log_scalars(trainer.label_loss_items(trainer.tloss, prefix=\"train\"), trainer.epoch + 1)\n    _log_scalars(trainer.lr, trainer.epoch + 1)\n    if trainer.epoch == 1:\n        _log_images({f.stem: str(f) for f in trainer.save_dir.glob(\"train_batch*.jpg\")}, \"Mosaic\")\n</code></pre>"},{"location":"reference/utils/callbacks/neptune/#ultralytics.utils.callbacks.neptune.on_fit_epoch_end","title":"<code>ultralytics.utils.callbacks.neptune.on_fit_epoch_end(trainer)</code>","text":"<p>Callback function called at end of each fit (train+val) epoch.</p> Source code in <code>ultralytics/utils/callbacks/neptune.py</code> <pre><code>def on_fit_epoch_end(trainer):\n    \"\"\"Callback function called at end of each fit (train+val) epoch.\"\"\"\n    if run and trainer.epoch == 0:\n        from ultralytics.utils.torch_utils import model_info_for_loggers\n\n        run[\"Configuration/Model\"] = model_info_for_loggers(trainer)\n    _log_scalars(trainer.metrics, trainer.epoch + 1)\n</code></pre>"},{"location":"reference/utils/callbacks/neptune/#ultralytics.utils.callbacks.neptune.on_val_end","title":"<code>ultralytics.utils.callbacks.neptune.on_val_end(validator)</code>","text":"<p>Callback function called at end of each validation.</p> Source code in <code>ultralytics/utils/callbacks/neptune.py</code> <pre><code>def on_val_end(validator):\n    \"\"\"Callback function called at end of each validation.\"\"\"\n    if run:\n        # Log val_labels and val_pred\n        _log_images({f.stem: str(f) for f in validator.save_dir.glob(\"val*.jpg\")}, \"Validation\")\n</code></pre>"},{"location":"reference/utils/callbacks/neptune/#ultralytics.utils.callbacks.neptune.on_train_end","title":"<code>ultralytics.utils.callbacks.neptune.on_train_end(trainer)</code>","text":"<p>Callback function called at end of training.</p> Source code in <code>ultralytics/utils/callbacks/neptune.py</code> <pre><code>def on_train_end(trainer):\n    \"\"\"Callback function called at end of training.\"\"\"\n    if run:\n        # Log final results, CM matrix + PR plots\n        files = [\n            \"results.png\",\n            \"confusion_matrix.png\",\n            \"confusion_matrix_normalized.png\",\n            *(f\"{x}_curve.png\" for x in (\"F1\", \"PR\", \"P\", \"R\")),\n        ]\n        files = [(trainer.save_dir / f) for f in files if (trainer.save_dir / f).exists()]  # filter\n        for f in files:\n            _log_plot(title=f.stem, plot_path=f)\n        # Log the final model\n        run[f\"weights/{trainer.args.name or trainer.args.task}/{str(trainer.best.name)}\"].upload(\n            File(str(trainer.best))\n        )\n</code></pre>"},{"location":"reference/utils/callbacks/raytune/","title":"Reference for <code>ultralytics/utils/callbacks/raytune.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/callbacks/raytune.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p>"},{"location":"reference/utils/callbacks/raytune/#ultralytics.utils.callbacks.raytune.on_fit_epoch_end","title":"<code>ultralytics.utils.callbacks.raytune.on_fit_epoch_end(trainer)</code>","text":"<p>Sends training metrics to Ray Tune at end of each epoch.</p> Source code in <code>ultralytics/utils/callbacks/raytune.py</code> <pre><code>def on_fit_epoch_end(trainer):\n    \"\"\"Sends training metrics to Ray Tune at end of each epoch.\"\"\"\n    if ray.tune.is_session_enabled():\n        metrics = trainer.metrics\n        metrics[\"epoch\"] = trainer.epoch\n        session.report(metrics)\n</code></pre>"},{"location":"reference/utils/callbacks/tensorboard/","title":"Reference for <code>ultralytics/utils/callbacks/tensorboard.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/callbacks/tensorboard.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/callbacks/tensorboard/#ultralytics.utils.callbacks.tensorboard._log_scalars","title":"<code>ultralytics.utils.callbacks.tensorboard._log_scalars(scalars, step=0)</code>","text":"<p>Logs scalar values to TensorBoard.</p> Source code in <code>ultralytics/utils/callbacks/tensorboard.py</code> <pre><code>def _log_scalars(scalars, step=0):\n    \"\"\"Logs scalar values to TensorBoard.\"\"\"\n    if WRITER:\n        for k, v in scalars.items():\n            WRITER.add_scalar(k, v, step)\n</code></pre>"},{"location":"reference/utils/callbacks/tensorboard/#ultralytics.utils.callbacks.tensorboard._log_tensorboard_graph","title":"<code>ultralytics.utils.callbacks.tensorboard._log_tensorboard_graph(trainer)</code>","text":"<p>Log model graph to TensorBoard.</p> Source code in <code>ultralytics/utils/callbacks/tensorboard.py</code> <pre><code>def _log_tensorboard_graph(trainer):\n    \"\"\"Log model graph to TensorBoard.\"\"\"\n    try:\n        import warnings\n\n        from ultralytics.utils.torch_utils import de_parallel, torch\n\n        imgsz = trainer.args.imgsz\n        imgsz = (imgsz, imgsz) if isinstance(imgsz, int) else imgsz\n        p = next(trainer.model.parameters())  # for device, type\n        im = torch.zeros((1, 3, *imgsz), device=p.device, dtype=p.dtype)  # input image (must be zeros, not empty)\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\", category=UserWarning)  # suppress jit trace warning\n            WRITER.add_graph(torch.jit.trace(de_parallel(trainer.model), im, strict=False), [])\n    except Exception as e:\n        LOGGER.warning(f\"WARNING \u26a0\ufe0f TensorBoard graph visualization failure {e}\")\n</code></pre>"},{"location":"reference/utils/callbacks/tensorboard/#ultralytics.utils.callbacks.tensorboard.on_pretrain_routine_start","title":"<code>ultralytics.utils.callbacks.tensorboard.on_pretrain_routine_start(trainer)</code>","text":"<p>Initialize TensorBoard logging with SummaryWriter.</p> Source code in <code>ultralytics/utils/callbacks/tensorboard.py</code> <pre><code>def on_pretrain_routine_start(trainer):\n    \"\"\"Initialize TensorBoard logging with SummaryWriter.\"\"\"\n    if SummaryWriter:\n        try:\n            global WRITER\n            WRITER = SummaryWriter(str(trainer.save_dir))\n            prefix = colorstr(\"TensorBoard: \")\n            LOGGER.info(f\"{prefix}Start with 'tensorboard --logdir {trainer.save_dir}', view at http://localhost:6006/\")\n        except Exception as e:\n            LOGGER.warning(f\"WARNING \u26a0\ufe0f TensorBoard not initialized correctly, not logging this run. {e}\")\n</code></pre>"},{"location":"reference/utils/callbacks/tensorboard/#ultralytics.utils.callbacks.tensorboard.on_train_start","title":"<code>ultralytics.utils.callbacks.tensorboard.on_train_start(trainer)</code>","text":"<p>Log TensorBoard graph.</p> Source code in <code>ultralytics/utils/callbacks/tensorboard.py</code> <pre><code>def on_train_start(trainer):\n    \"\"\"Log TensorBoard graph.\"\"\"\n    if WRITER:\n        _log_tensorboard_graph(trainer)\n</code></pre>"},{"location":"reference/utils/callbacks/tensorboard/#ultralytics.utils.callbacks.tensorboard.on_train_epoch_end","title":"<code>ultralytics.utils.callbacks.tensorboard.on_train_epoch_end(trainer)</code>","text":"<p>Logs scalar statistics at the end of a training epoch.</p> Source code in <code>ultralytics/utils/callbacks/tensorboard.py</code> <pre><code>def on_train_epoch_end(trainer):\n    \"\"\"Logs scalar statistics at the end of a training epoch.\"\"\"\n    _log_scalars(trainer.label_loss_items(trainer.tloss, prefix=\"train\"), trainer.epoch + 1)\n    _log_scalars(trainer.lr, trainer.epoch + 1)\n</code></pre>"},{"location":"reference/utils/callbacks/tensorboard/#ultralytics.utils.callbacks.tensorboard.on_fit_epoch_end","title":"<code>ultralytics.utils.callbacks.tensorboard.on_fit_epoch_end(trainer)</code>","text":"<p>Logs epoch metrics at end of training epoch.</p> Source code in <code>ultralytics/utils/callbacks/tensorboard.py</code> <pre><code>def on_fit_epoch_end(trainer):\n    \"\"\"Logs epoch metrics at end of training epoch.\"\"\"\n    _log_scalars(trainer.metrics, trainer.epoch + 1)\n</code></pre>"},{"location":"reference/utils/callbacks/wb/","title":"Reference for <code>ultralytics/utils/callbacks/wb.py</code>","text":"<p>Note</p> <p>This file is available at https://github.com/ultralytics/ultralytics/blob/main/ultralytics/utils/callbacks/wb.py. If you spot a problem please help fix it by contributing a Pull Request \ud83d\udee0\ufe0f. Thank you \ud83d\ude4f!</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"reference/utils/callbacks/wb/#ultralytics.utils.callbacks.wb._custom_table","title":"<code>ultralytics.utils.callbacks.wb._custom_table(x, y, classes, title='Precision Recall Curve', x_title='Recall', y_title='Precision')</code>","text":"<p>Create and log a custom metric visualization to wandb.plot.pr_curve.</p> <p>This function crafts a custom metric visualization that mimics the behavior of wandb's default precision-recall curve while allowing for enhanced customization. The visual metric is useful for monitoring model performance across different classes.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>List</code> <p>Values for the x-axis; expected to have length N.</p> required <code>y</code> <code>List</code> <p>Corresponding values for the y-axis; also expected to have length N.</p> required <code>classes</code> <code>List</code> <p>Labels identifying the class of each point; length N.</p> required <code>title</code> <code>str</code> <p>Title for the plot; defaults to 'Precision Recall Curve'.</p> <code>'Precision Recall Curve'</code> <code>x_title</code> <code>str</code> <p>Label for the x-axis; defaults to 'Recall'.</p> <code>'Recall'</code> <code>y_title</code> <code>str</code> <p>Label for the y-axis; defaults to 'Precision'.</p> <code>'Precision'</code> <p>Returns:</p> Type Description <code>Object</code> <p>A wandb object suitable for logging, showcasing the crafted metric visualization.</p> Source code in <code>ultralytics/utils/callbacks/wb.py</code> <pre><code>def _custom_table(x, y, classes, title=\"Precision Recall Curve\", x_title=\"Recall\", y_title=\"Precision\"):\n    \"\"\"\n    Create and log a custom metric visualization to wandb.plot.pr_curve.\n\n    This function crafts a custom metric visualization that mimics the behavior of wandb's default precision-recall curve\n    while allowing for enhanced customization. The visual metric is useful for monitoring model performance across different classes.\n\n    Args:\n        x (List): Values for the x-axis; expected to have length N.\n        y (List): Corresponding values for the y-axis; also expected to have length N.\n        classes (List): Labels identifying the class of each point; length N.\n        title (str, optional): Title for the plot; defaults to 'Precision Recall Curve'.\n        x_title (str, optional): Label for the x-axis; defaults to 'Recall'.\n        y_title (str, optional): Label for the y-axis; defaults to 'Precision'.\n\n    Returns:\n        (wandb.Object): A wandb object suitable for logging, showcasing the crafted metric visualization.\n    \"\"\"\n    df = pd.DataFrame({\"class\": classes, \"y\": y, \"x\": x}).round(3)\n    fields = {\"x\": \"x\", \"y\": \"y\", \"class\": \"class\"}\n    string_fields = {\"title\": title, \"x-axis-title\": x_title, \"y-axis-title\": y_title}\n    return wb.plot_table(\n        \"wandb/area-under-curve/v0\", wb.Table(dataframe=df), fields=fields, string_fields=string_fields\n    )\n</code></pre>"},{"location":"reference/utils/callbacks/wb/#ultralytics.utils.callbacks.wb._plot_curve","title":"<code>ultralytics.utils.callbacks.wb._plot_curve(x, y, names=None, id='precision-recall', title='Precision Recall Curve', x_title='Recall', y_title='Precision', num_x=100, only_mean=False)</code>","text":"<p>Log a metric curve visualization.</p> <p>This function generates a metric curve based on input data and logs the visualization to wandb. The curve can represent aggregated data (mean) or individual class data, depending on the 'only_mean' flag.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Data points for the x-axis with length N.</p> required <code>y</code> <code>ndarray</code> <p>Corresponding data points for the y-axis with shape CxN, where C represents the number of classes.</p> required <code>names</code> <code>list</code> <p>Names of the classes corresponding to the y-axis data; length C. Defaults to an empty list.</p> <code>None</code> <code>id</code> <code>str</code> <p>Unique identifier for the logged data in wandb. Defaults to 'precision-recall'.</p> <code>'precision-recall'</code> <code>title</code> <code>str</code> <p>Title for the visualization plot. Defaults to 'Precision Recall Curve'.</p> <code>'Precision Recall Curve'</code> <code>x_title</code> <code>str</code> <p>Label for the x-axis. Defaults to 'Recall'.</p> <code>'Recall'</code> <code>y_title</code> <code>str</code> <p>Label for the y-axis. Defaults to 'Precision'.</p> <code>'Precision'</code> <code>num_x</code> <code>int</code> <p>Number of interpolated data points for visualization. Defaults to 100.</p> <code>100</code> <code>only_mean</code> <code>bool</code> <p>Flag to indicate if only the mean curve should be plotted. Defaults to True.</p> <code>False</code> Note <p>The function leverages the '_custom_table' function to generate the actual visualization.</p> Source code in <code>ultralytics/utils/callbacks/wb.py</code> <pre><code>def _plot_curve(\n    x,\n    y,\n    names=None,\n    id=\"precision-recall\",\n    title=\"Precision Recall Curve\",\n    x_title=\"Recall\",\n    y_title=\"Precision\",\n    num_x=100,\n    only_mean=False,\n):\n    \"\"\"\n    Log a metric curve visualization.\n\n    This function generates a metric curve based on input data and logs the visualization to wandb.\n    The curve can represent aggregated data (mean) or individual class data, depending on the 'only_mean' flag.\n\n    Args:\n        x (np.ndarray): Data points for the x-axis with length N.\n        y (np.ndarray): Corresponding data points for the y-axis with shape CxN, where C represents the number of classes.\n        names (list, optional): Names of the classes corresponding to the y-axis data; length C. Defaults to an empty list.\n        id (str, optional): Unique identifier for the logged data in wandb. Defaults to 'precision-recall'.\n        title (str, optional): Title for the visualization plot. Defaults to 'Precision Recall Curve'.\n        x_title (str, optional): Label for the x-axis. Defaults to 'Recall'.\n        y_title (str, optional): Label for the y-axis. Defaults to 'Precision'.\n        num_x (int, optional): Number of interpolated data points for visualization. Defaults to 100.\n        only_mean (bool, optional): Flag to indicate if only the mean curve should be plotted. Defaults to True.\n\n    Note:\n        The function leverages the '_custom_table' function to generate the actual visualization.\n    \"\"\"\n    # Create new x\n    if names is None:\n        names = []\n    x_new = np.linspace(x[0], x[-1], num_x).round(5)\n\n    # Create arrays for logging\n    x_log = x_new.tolist()\n    y_log = np.interp(x_new, x, np.mean(y, axis=0)).round(3).tolist()\n\n    if only_mean:\n        table = wb.Table(data=list(zip(x_log, y_log)), columns=[x_title, y_title])\n        wb.run.log({title: wb.plot.line(table, x_title, y_title, title=title)})\n    else:\n        classes = [\"mean\"] * len(x_log)\n        for i, yi in enumerate(y):\n            x_log.extend(x_new)  # add new x\n            y_log.extend(np.interp(x_new, x, yi))  # interpolate y to new x\n            classes.extend([names[i]] * len(x_new))  # add class names\n        wb.log({id: _custom_table(x_log, y_log, classes, title, x_title, y_title)}, commit=False)\n</code></pre>"},{"location":"reference/utils/callbacks/wb/#ultralytics.utils.callbacks.wb._log_plots","title":"<code>ultralytics.utils.callbacks.wb._log_plots(plots, step)</code>","text":"<p>Logs plots from the input dictionary if they haven't been logged already at the specified step.</p> Source code in <code>ultralytics/utils/callbacks/wb.py</code> <pre><code>def _log_plots(plots, step):\n    \"\"\"Logs plots from the input dictionary if they haven't been logged already at the specified step.\"\"\"\n    for name, params in plots.items():\n        timestamp = params[\"timestamp\"]\n        if _processed_plots.get(name) != timestamp:\n            wb.run.log({name.stem: wb.Image(str(name))}, step=step)\n            _processed_plots[name] = timestamp\n</code></pre>"},{"location":"reference/utils/callbacks/wb/#ultralytics.utils.callbacks.wb.on_pretrain_routine_start","title":"<code>ultralytics.utils.callbacks.wb.on_pretrain_routine_start(trainer)</code>","text":"<p>Initiate and start project if module is present.</p> Source code in <code>ultralytics/utils/callbacks/wb.py</code> <pre><code>def on_pretrain_routine_start(trainer):\n    \"\"\"Initiate and start project if module is present.\"\"\"\n    wb.run or wb.init(project=trainer.args.project or \"YOLOv8\", name=trainer.args.name, config=vars(trainer.args))\n</code></pre>"},{"location":"reference/utils/callbacks/wb/#ultralytics.utils.callbacks.wb.on_fit_epoch_end","title":"<code>ultralytics.utils.callbacks.wb.on_fit_epoch_end(trainer)</code>","text":"<p>Logs training metrics and model information at the end of an epoch.</p> Source code in <code>ultralytics/utils/callbacks/wb.py</code> <pre><code>def on_fit_epoch_end(trainer):\n    \"\"\"Logs training metrics and model information at the end of an epoch.\"\"\"\n    wb.run.log(trainer.metrics, step=trainer.epoch + 1)\n    _log_plots(trainer.plots, step=trainer.epoch + 1)\n    _log_plots(trainer.validator.plots, step=trainer.epoch + 1)\n    if trainer.epoch == 0:\n        wb.run.log(model_info_for_loggers(trainer), step=trainer.epoch + 1)\n</code></pre>"},{"location":"reference/utils/callbacks/wb/#ultralytics.utils.callbacks.wb.on_train_epoch_end","title":"<code>ultralytics.utils.callbacks.wb.on_train_epoch_end(trainer)</code>","text":"<p>Log metrics and save images at the end of each training epoch.</p> Source code in <code>ultralytics/utils/callbacks/wb.py</code> <pre><code>def on_train_epoch_end(trainer):\n    \"\"\"Log metrics and save images at the end of each training epoch.\"\"\"\n    wb.run.log(trainer.label_loss_items(trainer.tloss, prefix=\"train\"), step=trainer.epoch + 1)\n    wb.run.log(trainer.lr, step=trainer.epoch + 1)\n    if trainer.epoch == 1:\n        _log_plots(trainer.plots, step=trainer.epoch + 1)\n</code></pre>"},{"location":"reference/utils/callbacks/wb/#ultralytics.utils.callbacks.wb.on_train_end","title":"<code>ultralytics.utils.callbacks.wb.on_train_end(trainer)</code>","text":"<p>Save the best model as an artifact at end of training.</p> Source code in <code>ultralytics/utils/callbacks/wb.py</code> <pre><code>def on_train_end(trainer):\n    \"\"\"Save the best model as an artifact at end of training.\"\"\"\n    _log_plots(trainer.validator.plots, step=trainer.epoch + 1)\n    _log_plots(trainer.plots, step=trainer.epoch + 1)\n    art = wb.Artifact(type=\"model\", name=f\"run_{wb.run.id}_model\")\n    if trainer.best.exists():\n        art.add_file(trainer.best)\n        wb.run.log_artifact(art, aliases=[\"best\"])\n    for curve_name, curve_values in zip(trainer.validator.metrics.curves, trainer.validator.metrics.curves_results):\n        x, y, x_title, y_title = curve_values\n        _plot_curve(\n            x,\n            y,\n            names=list(trainer.validator.metrics.names.values()),\n            id=f\"curves/{curve_name}\",\n            title=curve_name,\n            x_title=x_title,\n            y_title=y_title,\n        )\n    wb.run.finish()  # required or run continues on dashboard\n</code></pre>"},{"location":"tasks/","title":"Ultralytics YOLOv8 Tasks","text":"<p>YOLOv8 is an AI framework that supports multiple computer vision tasks. The framework can be used to perform detection, segmentation, obb, classification, and pose estimation. Each of these tasks has a different objective and use case.</p> <p> Watch: Explore Ultralytics YOLO Tasks: Object Detection, Segmentation, OBB, Tracking, and Pose Estimation. </p>"},{"location":"tasks/#detection","title":"Detection","text":"<p>Detection is the primary task supported by YOLOv8. It involves detecting objects in an image or video frame and drawing bounding boxes around them. The detected objects are classified into different categories based on their features. YOLOv8 can detect multiple objects in a single image or video frame with high accuracy and speed.</p> <p>Detection Examples</p>"},{"location":"tasks/#segmentation","title":"Segmentation","text":"<p>Segmentation is a task that involves segmenting an image into different regions based on the content of the image. Each region is assigned a label based on its content. This task is useful in applications such as image segmentation and medical imaging. YOLOv8 uses a variant of the U-Net architecture to perform segmentation.</p> <p>Segmentation Examples</p>"},{"location":"tasks/#classification","title":"Classification","text":"<p>Classification is a task that involves classifying an image into different categories. YOLOv8 can be used to classify images based on their content. It uses a variant of the EfficientNet architecture to perform classification.</p> <p>Classification Examples</p>"},{"location":"tasks/#pose","title":"Pose","text":"<p>Pose/keypoint detection is a task that involves detecting specific points in an image or video frame. These points are referred to as keypoints and are used to track movement or pose estimation. YOLOv8 can detect keypoints in an image or video frame with high accuracy and speed.</p> <p>Pose Examples</p>"},{"location":"tasks/#obb","title":"OBB","text":"<p>Oriented object detection goes a step further than regular object detection with introducing an extra angle to locate objects more accurate in an image. YOLOv8 can detect rotated objects in an image or video frame with high accuracy and speed.</p> <p>Oriented Detection</p>"},{"location":"tasks/#conclusion","title":"Conclusion","text":"<p>YOLOv8 supports multiple tasks, including detection, segmentation, classification, oriented object detection and keypoints detection. Each of these tasks has different objectives and use cases. By understanding the differences between these tasks, you can choose the appropriate task for your computer vision application.</p>"},{"location":"tasks/classify/","title":"Image Classification","text":"<p>Image classification is the simplest of the three tasks and involves classifying an entire image into one of a set of predefined classes.</p> <p>The output of an image classifier is a single class label and a confidence score. Image classification is useful when you need to know only what class an image belongs to and don't need to know where objects of that class are located or what their exact shape is.</p> <p> Watch: Explore Ultralytics YOLO Tasks: Image Classification </p> <p>Tip</p> <p>YOLOv8 Classify models use the <code>-cls</code> suffix, i.e. <code>yolov8n-cls.pt</code> and are pretrained on ImageNet.</p>"},{"location":"tasks/classify/#models","title":"Models","text":"<p>YOLOv8 pretrained Classify models are shown here. Detect, Segment and Pose models are pretrained on the COCO dataset, while Classify models are pretrained on the ImageNet dataset.</p> <p>Models download automatically from the latest Ultralytics release on first use.</p> Model size<sup>(pixels) acc<sup>top1 acc<sup>top5 Speed<sup>CPU ONNX(ms) Speed<sup>A100 TensorRT(ms) params<sup>(M) FLOPs<sup>(B) at 640 YOLOv8n-cls 224 69.0 88.3 12.9 0.31 2.7 4.3 YOLOv8s-cls 224 73.8 91.7 23.4 0.35 6.4 13.5 YOLOv8m-cls 224 76.8 93.5 85.4 0.62 17.0 42.7 YOLOv8l-cls 224 76.8 93.5 163.0 0.87 37.5 99.7 YOLOv8x-cls 224 79.0 94.6 232.0 1.01 57.4 154.8 <ul> <li>acc values are model accuracies on the ImageNet dataset validation set. Reproduce by <code>yolo val classify data=path/to/ImageNet device=0</code></li> <li>Speed averaged over ImageNet val images using an Amazon EC2 P4d instance. Reproduce by <code>yolo val classify data=path/to/ImageNet batch=1 device=0|cpu</code></li> </ul>"},{"location":"tasks/classify/#train","title":"Train","text":"<p>Train YOLOv8n-cls on the MNIST160 dataset for 100 epochs at image size 64. For a full list of available arguments see the Configuration page.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-cls.yaml')  # build a new model from YAML\nmodel = YOLO('yolov8n-cls.pt')  # load a pretrained model (recommended for training)\nmodel = YOLO('yolov8n-cls.yaml').load('yolov8n-cls.pt')  # build from YAML and transfer weights\n\n# Train the model\nresults = model.train(data='mnist160', epochs=100, imgsz=64)\n</code></pre> <pre><code># Build a new model from YAML and start training from scratch\nyolo classify train data=mnist160 model=yolov8n-cls.yaml epochs=100 imgsz=64\n\n# Start training from a pretrained *.pt model\nyolo classify train data=mnist160 model=yolov8n-cls.pt epochs=100 imgsz=64\n\n# Build a new model from YAML, transfer pretrained weights to it and start training\nyolo classify train data=mnist160 model=yolov8n-cls.yaml pretrained=yolov8n-cls.pt epochs=100 imgsz=64\n</code></pre>"},{"location":"tasks/classify/#dataset-format","title":"Dataset format","text":"<p>YOLO classification dataset format can be found in detail in the Dataset Guide.</p>"},{"location":"tasks/classify/#val","title":"Val","text":"<p>Validate trained YOLOv8n-cls model accuracy on the MNIST160 dataset. No argument need to passed as the <code>model</code> retains it's training <code>data</code> and arguments as model attributes.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-cls.pt')  # load an official model\nmodel = YOLO('path/to/best.pt')  # load a custom model\n\n# Validate the model\nmetrics = model.val()  # no arguments needed, dataset and settings remembered\nmetrics.top1   # top1 accuracy\nmetrics.top5   # top5 accuracy\n</code></pre> <pre><code>yolo classify val model=yolov8n-cls.pt  # val official model\nyolo classify val model=path/to/best.pt  # val custom model\n</code></pre>"},{"location":"tasks/classify/#predict","title":"Predict","text":"<p>Use a trained YOLOv8n-cls model to run predictions on images.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-cls.pt')  # load an official model\nmodel = YOLO('path/to/best.pt')  # load a custom model\n\n# Predict with the model\nresults = model('https://ultralytics.com/images/bus.jpg')  # predict on an image\n</code></pre> <pre><code>yolo classify predict model=yolov8n-cls.pt source='https://ultralytics.com/images/bus.jpg'  # predict with official model\nyolo classify predict model=path/to/best.pt source='https://ultralytics.com/images/bus.jpg'  # predict with custom model\n</code></pre> <p>See full <code>predict</code> mode details in the Predict page.</p>"},{"location":"tasks/classify/#export","title":"Export","text":"<p>Export a YOLOv8n-cls model to a different format like ONNX, CoreML, etc.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-cls.pt')  # load an official model\nmodel = YOLO('path/to/best.pt')  # load a custom trained model\n\n# Export the model\nmodel.export(format='onnx')\n</code></pre> <pre><code>yolo export model=yolov8n-cls.pt format=onnx  # export official model\nyolo export model=path/to/best.pt format=onnx  # export custom trained model\n</code></pre> <p>Available YOLOv8-cls export formats are in the table below. You can predict or validate directly on exported models, i.e. <code>yolo predict model=yolov8n-cls.onnx</code>. Usage examples are shown for your model after export completes.</p> Format <code>format</code> Argument Model Metadata Arguments PyTorch - <code>yolov8n-cls.pt</code> \u2705 - TorchScript <code>torchscript</code> <code>yolov8n-cls.torchscript</code> \u2705 <code>imgsz</code>, <code>optimize</code> ONNX <code>onnx</code> <code>yolov8n-cls.onnx</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>dynamic</code>, <code>simplify</code>, <code>opset</code> OpenVINO <code>openvino</code> <code>yolov8n-cls_openvino_model/</code> \u2705 <code>imgsz</code>, <code>half</code> TensorRT <code>engine</code> <code>yolov8n-cls.engine</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>dynamic</code>, <code>simplify</code>, <code>workspace</code> CoreML <code>coreml</code> <code>yolov8n-cls.mlpackage</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code>, <code>nms</code> TF SavedModel <code>saved_model</code> <code>yolov8n-cls_saved_model/</code> \u2705 <code>imgsz</code>, <code>keras</code> TF GraphDef <code>pb</code> <code>yolov8n-cls.pb</code> \u274c <code>imgsz</code> TF Lite <code>tflite</code> <code>yolov8n-cls.tflite</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code> TF Edge TPU <code>edgetpu</code> <code>yolov8n-cls_edgetpu.tflite</code> \u2705 <code>imgsz</code> TF.js <code>tfjs</code> <code>yolov8n-cls_web_model/</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code> PaddlePaddle <code>paddle</code> <code>yolov8n-cls_paddle_model/</code> \u2705 <code>imgsz</code> ncnn <code>ncnn</code> <code>yolov8n-cls_ncnn_model/</code> \u2705 <code>imgsz</code>, <code>half</code> <p>See full <code>export</code> details in the Export page.</p>"},{"location":"tasks/detect/","title":"Object Detection","text":"<p>Object detection is a task that involves identifying the location and class of objects in an image or video stream.</p> <p>The output of an object detector is a set of bounding boxes that enclose the objects in the image, along with class labels and confidence scores for each box. Object detection is a good choice when you need to identify objects of interest in a scene, but don't need to know exactly where the object is or its exact shape.</p> <p> Watch: Object Detection with Pre-trained Ultralytics YOLOv8 Model. </p> <p>Tip</p> <p>YOLOv8 Detect models are the default YOLOv8 models, i.e. <code>yolov8n.pt</code> and are pretrained on COCO.</p>"},{"location":"tasks/detect/#models","title":"Models","text":"<p>YOLOv8 pretrained Detect models are shown here. Detect, Segment and Pose models are pretrained on the COCO dataset, while Classify models are pretrained on the ImageNet dataset.</p> <p>Models download automatically from the latest Ultralytics release on first use.</p> Model size<sup>(pixels) mAP<sup>val50-95 Speed<sup>CPU ONNX(ms) Speed<sup>A100 TensorRT(ms) params<sup>(M) FLOPs<sup>(B) YOLOv8n 640 37.3 80.4 0.99 3.2 8.7 YOLOv8s 640 44.9 128.4 1.20 11.2 28.6 YOLOv8m 640 50.2 234.7 1.83 25.9 78.9 YOLOv8l 640 52.9 375.2 2.39 43.7 165.2 YOLOv8x 640 53.9 479.1 3.53 68.2 257.8 <ul> <li>mAP<sup>val</sup> values are for single-model single-scale on COCO val2017 dataset. Reproduce by <code>yolo val detect data=coco.yaml device=0</code></li> <li>Speed averaged over COCO val images using an Amazon EC2 P4d instance. Reproduce by <code>yolo val detect data=coco128.yaml batch=1 device=0|cpu</code></li> </ul>"},{"location":"tasks/detect/#train","title":"Train","text":"<p>Train YOLOv8n on the COCO128 dataset for 100 epochs at image size 640. For a full list of available arguments see the Configuration page.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n.yaml')  # build a new model from YAML\nmodel = YOLO('yolov8n.pt')  # load a pretrained model (recommended for training)\nmodel = YOLO('yolov8n.yaml').load('yolov8n.pt')  # build from YAML and transfer weights\n\n# Train the model\nresults = model.train(data='coco128.yaml', epochs=100, imgsz=640)\n</code></pre> <pre><code># Build a new model from YAML and start training from scratch\nyolo detect train data=coco128.yaml model=yolov8n.yaml epochs=100 imgsz=640\n\n# Start training from a pretrained *.pt model\nyolo detect train data=coco128.yaml model=yolov8n.pt epochs=100 imgsz=640\n\n# Build a new model from YAML, transfer pretrained weights to it and start training\nyolo detect train data=coco128.yaml model=yolov8n.yaml pretrained=yolov8n.pt epochs=100 imgsz=640\n</code></pre>"},{"location":"tasks/detect/#dataset-format","title":"Dataset format","text":"<p>YOLO detection dataset format can be found in detail in the Dataset Guide. To convert your existing dataset from other formats (like COCO etc.) to YOLO format, please use JSON2YOLO tool by Ultralytics.</p>"},{"location":"tasks/detect/#val","title":"Val","text":"<p>Validate trained YOLOv8n model accuracy on the COCO128 dataset. No argument need to passed as the <code>model</code> retains it's training <code>data</code> and arguments as model attributes.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n.pt')  # load an official model\nmodel = YOLO('path/to/best.pt')  # load a custom model\n\n# Validate the model\nmetrics = model.val()  # no arguments needed, dataset and settings remembered\nmetrics.box.map    # map50-95\nmetrics.box.map50  # map50\nmetrics.box.map75  # map75\nmetrics.box.maps   # a list contains map50-95 of each category\n</code></pre> <pre><code>yolo detect val model=yolov8n.pt  # val official model\nyolo detect val model=path/to/best.pt  # val custom model\n</code></pre>"},{"location":"tasks/detect/#predict","title":"Predict","text":"<p>Use a trained YOLOv8n model to run predictions on images.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n.pt')  # load an official model\nmodel = YOLO('path/to/best.pt')  # load a custom model\n\n# Predict with the model\nresults = model('https://ultralytics.com/images/bus.jpg')  # predict on an image\n</code></pre> <pre><code>yolo detect predict model=yolov8n.pt source='https://ultralytics.com/images/bus.jpg'  # predict with official model\nyolo detect predict model=path/to/best.pt source='https://ultralytics.com/images/bus.jpg'  # predict with custom model\n</code></pre> <p>See full <code>predict</code> mode details in the Predict page.</p>"},{"location":"tasks/detect/#export","title":"Export","text":"<p>Export a YOLOv8n model to a different format like ONNX, CoreML, etc.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n.pt')  # load an official model\nmodel = YOLO('path/to/best.pt')  # load a custom trained model\n\n# Export the model\nmodel.export(format='onnx')\n</code></pre> <pre><code>yolo export model=yolov8n.pt format=onnx  # export official model\nyolo export model=path/to/best.pt format=onnx  # export custom trained model\n</code></pre> <p>Available YOLOv8 export formats are in the table below. You can predict or validate directly on exported models, i.e. <code>yolo predict model=yolov8n.onnx</code>. Usage examples are shown for your model after export completes.</p> Format <code>format</code> Argument Model Metadata Arguments PyTorch - <code>yolov8n.pt</code> \u2705 - TorchScript <code>torchscript</code> <code>yolov8n.torchscript</code> \u2705 <code>imgsz</code>, <code>optimize</code> ONNX <code>onnx</code> <code>yolov8n.onnx</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>dynamic</code>, <code>simplify</code>, <code>opset</code> OpenVINO <code>openvino</code> <code>yolov8n_openvino_model/</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code> TensorRT <code>engine</code> <code>yolov8n.engine</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>dynamic</code>, <code>simplify</code>, <code>workspace</code> CoreML <code>coreml</code> <code>yolov8n.mlpackage</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code>, <code>nms</code> TF SavedModel <code>saved_model</code> <code>yolov8n_saved_model/</code> \u2705 <code>imgsz</code>, <code>keras</code>, <code>int8</code> TF GraphDef <code>pb</code> <code>yolov8n.pb</code> \u274c <code>imgsz</code> TF Lite <code>tflite</code> <code>yolov8n.tflite</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code> TF Edge TPU <code>edgetpu</code> <code>yolov8n_edgetpu.tflite</code> \u2705 <code>imgsz</code> TF.js <code>tfjs</code> <code>yolov8n_web_model/</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code> PaddlePaddle <code>paddle</code> <code>yolov8n_paddle_model/</code> \u2705 <code>imgsz</code> ncnn <code>ncnn</code> <code>yolov8n_ncnn_model/</code> \u2705 <code>imgsz</code>, <code>half</code> <p>See full <code>export</code> details in the Export page.</p>"},{"location":"tasks/obb/","title":"Oriented Bounding Boxes Object Detection","text":"<p>Oriented object detection goes a step further than object detection and introduce an extra angle to locate objects more accurate in an image.</p> <p>The output of an oriented object detector is a set of rotated bounding boxes that exactly enclose the objects in the image, along with class labels and confidence scores for each box. Object detection is a good choice when you need to identify objects of interest in a scene, but don't need to know exactly where the object is or its exact shape.</p> <p>Tip</p> <p>YOLOv8 OBB models use the <code>-obb</code> suffix, i.e. <code>yolov8n-obb.pt</code> and are pretrained on DOTAv1.</p>"},{"location":"tasks/obb/#models","title":"Models","text":"<p>YOLOv8 pretrained OBB models are shown here, which are pretrained on the DOTAv1 dataset.</p> <p>Models download automatically from the latest Ultralytics release on first use.</p> Model size<sup>(pixels) mAP<sup>test50 Speed<sup>CPU ONNX(ms) Speed<sup>A100 TensorRT(ms) params<sup>(M) FLOPs<sup>(B) YOLOv8n-obb 1024 76.9 204.77 3.57 3.1 23.3 YOLOv8s-obb 1024 78.0 424.88 4.07 11.4 76.3 YOLOv8m-obb 1024 80.5 763.48 7.61 26.4 208.6 YOLOv8l-obb 1024 80.7 1278.42 11.83 44.5 433.8 YOLOv8x-obb 1024 81.36 1759.10 13.23 69.5 676.7 <ul> <li>mAP<sup>test</sup> values are for single-model multi-scale on DOTAv1 test dataset. Reproduce by <code>yolo val obb data=DOTAv1.yaml device=0 split=test</code> and submit merged results to DOTA evaluation.</li> <li>Speed averaged over DOTAv1 val images using an Amazon EC2 P4d instance. Reproduce by <code>yolo val obb data=DOTAv1.yaml batch=1 device=0|cpu</code></li> </ul>"},{"location":"tasks/obb/#train","title":"Train","text":"<p>Train YOLOv8n-obb on the dota8.yaml dataset for 100 epochs at image size 640. For a full list of available arguments see the Configuration page.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-obb.yaml')  # build a new model from YAML\nmodel = YOLO('yolov8n-obb.pt')  # load a pretrained model (recommended for training)\nmodel = YOLO('yolov8n-obb.yaml').load('yolov8n.pt')  # build from YAML and transfer weights\n\n# Train the model\nresults = model.train(data='dota8-obb.yaml', epochs=100, imgsz=640)\n</code></pre> <pre><code># Build a new model from YAML and start training from scratch\nyolo obb train data=dota8-obb.yaml model=yolov8n-obb.yaml epochs=100 imgsz=640\n\n# Start training from a pretrained *.pt model\nyolo obb train data=dota8-obb.yaml model=yolov8n-obb.pt epochs=100 imgsz=640\n\n# Build a new model from YAML, transfer pretrained weights to it and start training\nyolo obb train data=dota8-obb.yaml model=yolov8n-obb.yaml pretrained=yolov8n-obb.pt epochs=100 imgsz=640\n</code></pre>"},{"location":"tasks/obb/#dataset-format","title":"Dataset format","text":"<p>OBB dataset format can be found in detail in the Dataset Guide.</p>"},{"location":"tasks/obb/#val","title":"Val","text":"<p>Validate trained YOLOv8n-obb model accuracy on the dota8-obb dataset. No argument need to passed as the <code>model</code> retains it's training <code>data</code> and arguments as model attributes.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-obb.pt')  # load an official model\nmodel = YOLO('path/to/best.pt')  # load a custom model\n\n# Validate the model\nmetrics = model.val()  # no arguments needed, dataset and settings remembered\nmetrics.box.map    # map50-95(B)\nmetrics.box.map50  # map50(B)\nmetrics.box.map75  # map75(B)\nmetrics.box.maps   # a list contains map50-95(B) of each category\n</code></pre> <pre><code>yolo obb val model=yolov8n-obb.pt  # val official model\nyolo obb val model=path/to/best.pt  # val custom model\n</code></pre>"},{"location":"tasks/obb/#predict","title":"Predict","text":"<p>Use a trained YOLOv8n-obb model to run predictions on images.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-obb.pt')  # load an official model\nmodel = YOLO('path/to/best.pt')  # load a custom model\n\n# Predict with the model\nresults = model('https://ultralytics.com/images/bus.jpg')  # predict on an image\n</code></pre> <pre><code>yolo obb predict model=yolov8n-obb.pt source='https://ultralytics.com/images/bus.jpg'  # predict with official model\nyolo obb predict model=path/to/best.pt source='https://ultralytics.com/images/bus.jpg'  # predict with custom model\n</code></pre> <p>See full <code>predict</code> mode details in the Predict page.</p>"},{"location":"tasks/obb/#export","title":"Export","text":"<p>Export a YOLOv8n-obb model to a different format like ONNX, CoreML, etc.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-obb.pt')  # load an official model\nmodel = YOLO('path/to/best.pt')  # load a custom trained model\n\n# Export the model\nmodel.export(format='onnx')\n</code></pre> <pre><code>yolo export model=yolov8n-obb.pt format=onnx  # export official model\nyolo export model=path/to/best.pt format=onnx  # export custom trained model\n</code></pre> <p>Available YOLOv8-obb export formats are in the table below. You can predict or validate directly on exported models, i.e. <code>yolo predict model=yolov8n-obb.onnx</code>. Usage examples are shown for your model after export completes.</p> Format <code>format</code> Argument Model Metadata Arguments PyTorch - <code>yolov8n-obb.pt</code> \u2705 - TorchScript <code>torchscript</code> <code>yolov8n-obb.torchscript</code> \u2705 <code>imgsz</code>, <code>optimize</code> ONNX <code>onnx</code> <code>yolov8n-obb.onnx</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>dynamic</code>, <code>simplify</code>, <code>opset</code> OpenVINO <code>openvino</code> <code>yolov8n-obb_openvino_model/</code> \u2705 <code>imgsz</code>, <code>half</code> TensorRT <code>engine</code> <code>yolov8n-obb.engine</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>dynamic</code>, <code>simplify</code>, <code>workspace</code> CoreML <code>coreml</code> <code>yolov8n-obb.mlpackage</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code>, <code>nms</code> TF SavedModel <code>saved_model</code> <code>yolov8n-obb_saved_model/</code> \u2705 <code>imgsz</code>, <code>keras</code> TF GraphDef <code>pb</code> <code>yolov8n-obb.pb</code> \u274c <code>imgsz</code> TF Lite <code>tflite</code> <code>yolov8n-obb.tflite</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code> TF Edge TPU <code>edgetpu</code> <code>yolov8n-obb_edgetpu.tflite</code> \u2705 <code>imgsz</code> TF.js <code>tfjs</code> <code>yolov8n-obb_web_model/</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code> PaddlePaddle <code>paddle</code> <code>yolov8n-obb_paddle_model/</code> \u2705 <code>imgsz</code> ncnn <code>ncnn</code> <code>yolov8n-obb_ncnn_model/</code> \u2705 <code>imgsz</code>, <code>half</code> <p>See full <code>export</code> details in the Export page.</p>"},{"location":"tasks/pose/","title":"Pose Estimation","text":"<p>Pose estimation is a task that involves identifying the location of specific points in an image, usually referred to as keypoints. The keypoints can represent various parts of the object such as joints, landmarks, or other distinctive features. The locations of the keypoints are usually represented as a set of 2D <code>[x, y]</code> or 3D <code>[x, y, visible]</code> coordinates.</p> <p>The output of a pose estimation model is a set of points that represent the keypoints on an object in the image, usually along with the confidence scores for each point. Pose estimation is a good choice when you need to identify specific parts of an object in a scene, and their location in relation to each other.</p> <p> Watch: Pose Estimation with Ultralytics YOLOv8. </p> <p>Tip</p> <p>YOLOv8 pose models use the <code>-pose</code> suffix, i.e. <code>yolov8n-pose.pt</code>. These models are trained on the COCO keypoints dataset and are suitable for a variety of pose estimation tasks.</p>"},{"location":"tasks/pose/#models","title":"Models","text":"<p>YOLOv8 pretrained Pose models are shown here. Detect, Segment and Pose models are pretrained on the COCO dataset, while Classify models are pretrained on the ImageNet dataset.</p> <p>Models download automatically from the latest Ultralytics release on first use.</p> Model size<sup>(pixels) mAP<sup>pose50-95 mAP<sup>pose50 Speed<sup>CPU ONNX(ms) Speed<sup>A100 TensorRT(ms) params<sup>(M) FLOPs<sup>(B) YOLOv8n-pose 640 50.4 80.1 131.8 1.18 3.3 9.2 YOLOv8s-pose 640 60.0 86.2 233.2 1.42 11.6 30.2 YOLOv8m-pose 640 65.0 88.8 456.3 2.00 26.4 81.0 YOLOv8l-pose 640 67.6 90.0 784.5 2.59 44.4 168.6 YOLOv8x-pose 640 69.2 90.2 1607.1 3.73 69.4 263.2 YOLOv8x-pose-p6 1280 71.6 91.2 4088.7 10.04 99.1 1066.4 <ul> <li>mAP<sup>val</sup> values are for single-model single-scale on COCO Keypoints val2017 dataset. Reproduce by <code>yolo val pose data=coco-pose.yaml device=0</code></li> <li>Speed averaged over COCO val images using an Amazon EC2 P4d instance. Reproduce by <code>yolo val pose data=coco8-pose.yaml batch=1 device=0|cpu</code></li> </ul>"},{"location":"tasks/pose/#train","title":"Train","text":"<p>Train a YOLOv8-pose model on the COCO128-pose dataset.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-pose.yaml')  # build a new model from YAML\nmodel = YOLO('yolov8n-pose.pt')  # load a pretrained model (recommended for training)\nmodel = YOLO('yolov8n-pose.yaml').load('yolov8n-pose.pt')  # build from YAML and transfer weights\n\n# Train the model\nresults = model.train(data='coco8-pose.yaml', epochs=100, imgsz=640)\n</code></pre> <pre><code># Build a new model from YAML and start training from scratch\nyolo pose train data=coco8-pose.yaml model=yolov8n-pose.yaml epochs=100 imgsz=640\n\n# Start training from a pretrained *.pt model\nyolo pose train data=coco8-pose.yaml model=yolov8n-pose.pt epochs=100 imgsz=640\n\n# Build a new model from YAML, transfer pretrained weights to it and start training\nyolo pose train data=coco8-pose.yaml model=yolov8n-pose.yaml pretrained=yolov8n-pose.pt epochs=100 imgsz=640\n</code></pre>"},{"location":"tasks/pose/#dataset-format","title":"Dataset format","text":"<p>YOLO pose dataset format can be found in detail in the Dataset Guide. To convert your existing dataset from other formats (like COCO etc.) to YOLO format, please use JSON2YOLO tool by Ultralytics.</p>"},{"location":"tasks/pose/#val","title":"Val","text":"<p>Validate trained YOLOv8n-pose model accuracy on the COCO128-pose dataset. No argument need to passed as the <code>model</code> retains it's training <code>data</code> and arguments as model attributes.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-pose.pt')  # load an official model\nmodel = YOLO('path/to/best.pt')  # load a custom model\n\n# Validate the model\nmetrics = model.val()  # no arguments needed, dataset and settings remembered\nmetrics.box.map    # map50-95\nmetrics.box.map50  # map50\nmetrics.box.map75  # map75\nmetrics.box.maps   # a list contains map50-95 of each category\n</code></pre> <pre><code>yolo pose val model=yolov8n-pose.pt  # val official model\nyolo pose val model=path/to/best.pt  # val custom model\n</code></pre>"},{"location":"tasks/pose/#predict","title":"Predict","text":"<p>Use a trained YOLOv8n-pose model to run predictions on images.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-pose.pt')  # load an official model\nmodel = YOLO('path/to/best.pt')  # load a custom model\n\n# Predict with the model\nresults = model('https://ultralytics.com/images/bus.jpg')  # predict on an image\n</code></pre> <pre><code>yolo pose predict model=yolov8n-pose.pt source='https://ultralytics.com/images/bus.jpg'  # predict with official model\nyolo pose predict model=path/to/best.pt source='https://ultralytics.com/images/bus.jpg'  # predict with custom model\n</code></pre> <p>See full <code>predict</code> mode details in the Predict page.</p>"},{"location":"tasks/pose/#export","title":"Export","text":"<p>Export a YOLOv8n Pose model to a different format like ONNX, CoreML, etc.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-pose.pt')  # load an official model\nmodel = YOLO('path/to/best.pt')  # load a custom trained model\n\n# Export the model\nmodel.export(format='onnx')\n</code></pre> <pre><code>yolo export model=yolov8n-pose.pt format=onnx  # export official model\nyolo export model=path/to/best.pt format=onnx  # export custom trained model\n</code></pre> <p>Available YOLOv8-pose export formats are in the table below. You can predict or validate directly on exported models, i.e. <code>yolo predict model=yolov8n-pose.onnx</code>. Usage examples are shown for your model after export completes.</p> Format <code>format</code> Argument Model Metadata Arguments PyTorch - <code>yolov8n-pose.pt</code> \u2705 - TorchScript <code>torchscript</code> <code>yolov8n-pose.torchscript</code> \u2705 <code>imgsz</code>, <code>optimize</code> ONNX <code>onnx</code> <code>yolov8n-pose.onnx</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>dynamic</code>, <code>simplify</code>, <code>opset</code> OpenVINO <code>openvino</code> <code>yolov8n-pose_openvino_model/</code> \u2705 <code>imgsz</code>, <code>half</code> TensorRT <code>engine</code> <code>yolov8n-pose.engine</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>dynamic</code>, <code>simplify</code>, <code>workspace</code> CoreML <code>coreml</code> <code>yolov8n-pose.mlpackage</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code>, <code>nms</code> TF SavedModel <code>saved_model</code> <code>yolov8n-pose_saved_model/</code> \u2705 <code>imgsz</code>, <code>keras</code> TF GraphDef <code>pb</code> <code>yolov8n-pose.pb</code> \u274c <code>imgsz</code> TF Lite <code>tflite</code> <code>yolov8n-pose.tflite</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code> TF Edge TPU <code>edgetpu</code> <code>yolov8n-pose_edgetpu.tflite</code> \u2705 <code>imgsz</code> TF.js <code>tfjs</code> <code>yolov8n-pose_web_model/</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code> PaddlePaddle <code>paddle</code> <code>yolov8n-pose_paddle_model/</code> \u2705 <code>imgsz</code> ncnn <code>ncnn</code> <code>yolov8n-pose_ncnn_model/</code> \u2705 <code>imgsz</code>, <code>half</code> <p>See full <code>export</code> details in the Export page.</p>"},{"location":"tasks/segment/","title":"Instance Segmentation","text":"<p>Instance segmentation goes a step further than object detection and involves identifying individual objects in an image and segmenting them from the rest of the image.</p> <p>The output of an instance segmentation model is a set of masks or contours that outline each object in the image, along with class labels and confidence scores for each object. Instance segmentation is useful when you need to know not only where objects are in an image, but also what their exact shape is.</p> <p> Watch: Run Segmentation with Pre-Trained Ultralytics YOLOv8 Model in Python. </p> <p>Tip</p> <p>YOLOv8 Segment models use the <code>-seg</code> suffix, i.e. <code>yolov8n-seg.pt</code> and are pretrained on COCO.</p>"},{"location":"tasks/segment/#models","title":"Models","text":"<p>YOLOv8 pretrained Segment models are shown here. Detect, Segment and Pose models are pretrained on the COCO dataset, while Classify models are pretrained on the ImageNet dataset.</p> <p>Models download automatically from the latest Ultralytics release on first use.</p> Model size<sup>(pixels) mAP<sup>box50-95 mAP<sup>mask50-95 Speed<sup>CPU ONNX(ms) Speed<sup>A100 TensorRT(ms) params<sup>(M) FLOPs<sup>(B) YOLOv8n-seg 640 36.7 30.5 96.1 1.21 3.4 12.6 YOLOv8s-seg 640 44.6 36.8 155.7 1.47 11.8 42.6 YOLOv8m-seg 640 49.9 40.8 317.0 2.18 27.3 110.2 YOLOv8l-seg 640 52.3 42.6 572.4 2.79 46.0 220.5 YOLOv8x-seg 640 53.4 43.4 712.1 4.02 71.8 344.1 <ul> <li>mAP<sup>val</sup> values are for single-model single-scale on COCO val2017 dataset. Reproduce by <code>yolo val segment data=coco.yaml device=0</code></li> <li>Speed averaged over COCO val images using an Amazon EC2 P4d instance. Reproduce by <code>yolo val segment data=coco128-seg.yaml batch=1 device=0|cpu</code></li> </ul>"},{"location":"tasks/segment/#train","title":"Train","text":"<p>Train YOLOv8n-seg on the COCO128-seg dataset for 100 epochs at image size 640. For a full list of available arguments see the Configuration page.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-seg.yaml')  # build a new model from YAML\nmodel = YOLO('yolov8n-seg.pt')  # load a pretrained model (recommended for training)\nmodel = YOLO('yolov8n-seg.yaml').load('yolov8n.pt')  # build from YAML and transfer weights\n\n# Train the model\nresults = model.train(data='coco128-seg.yaml', epochs=100, imgsz=640)\n</code></pre> <pre><code># Build a new model from YAML and start training from scratch\nyolo segment train data=coco128-seg.yaml model=yolov8n-seg.yaml epochs=100 imgsz=640\n\n# Start training from a pretrained *.pt model\nyolo segment train data=coco128-seg.yaml model=yolov8n-seg.pt epochs=100 imgsz=640\n\n# Build a new model from YAML, transfer pretrained weights to it and start training\nyolo segment train data=coco128-seg.yaml model=yolov8n-seg.yaml pretrained=yolov8n-seg.pt epochs=100 imgsz=640\n</code></pre>"},{"location":"tasks/segment/#dataset-format","title":"Dataset format","text":"<p>YOLO segmentation dataset format can be found in detail in the Dataset Guide. To convert your existing dataset from other formats (like COCO etc.) to YOLO format, please use JSON2YOLO tool by Ultralytics.</p>"},{"location":"tasks/segment/#val","title":"Val","text":"<p>Validate trained YOLOv8n-seg model accuracy on the COCO128-seg dataset. No argument need to passed as the <code>model</code> retains it's training <code>data</code> and arguments as model attributes.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-seg.pt')  # load an official model\nmodel = YOLO('path/to/best.pt')  # load a custom model\n\n# Validate the model\nmetrics = model.val()  # no arguments needed, dataset and settings remembered\nmetrics.box.map    # map50-95(B)\nmetrics.box.map50  # map50(B)\nmetrics.box.map75  # map75(B)\nmetrics.box.maps   # a list contains map50-95(B) of each category\nmetrics.seg.map    # map50-95(M)\nmetrics.seg.map50  # map50(M)\nmetrics.seg.map75  # map75(M)\nmetrics.seg.maps   # a list contains map50-95(M) of each category\n</code></pre> <pre><code>yolo segment val model=yolov8n-seg.pt  # val official model\nyolo segment val model=path/to/best.pt  # val custom model\n</code></pre>"},{"location":"tasks/segment/#predict","title":"Predict","text":"<p>Use a trained YOLOv8n-seg model to run predictions on images.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-seg.pt')  # load an official model\nmodel = YOLO('path/to/best.pt')  # load a custom model\n\n# Predict with the model\nresults = model('https://ultralytics.com/images/bus.jpg')  # predict on an image\n</code></pre> <pre><code>yolo segment predict model=yolov8n-seg.pt source='https://ultralytics.com/images/bus.jpg'  # predict with official model\nyolo segment predict model=path/to/best.pt source='https://ultralytics.com/images/bus.jpg'  # predict with custom model\n</code></pre> <p>See full <code>predict</code> mode details in the Predict page.</p>"},{"location":"tasks/segment/#export","title":"Export","text":"<p>Export a YOLOv8n-seg model to a different format like ONNX, CoreML, etc.</p> <p>Example</p> PythonCLI <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n-seg.pt')  # load an official model\nmodel = YOLO('path/to/best.pt')  # load a custom trained model\n\n# Export the model\nmodel.export(format='onnx')\n</code></pre> <pre><code>yolo export model=yolov8n-seg.pt format=onnx  # export official model\nyolo export model=path/to/best.pt format=onnx  # export custom trained model\n</code></pre> <p>Available YOLOv8-seg export formats are in the table below. You can predict or validate directly on exported models, i.e. <code>yolo predict model=yolov8n-seg.onnx</code>. Usage examples are shown for your model after export completes.</p> Format <code>format</code> Argument Model Metadata Arguments PyTorch - <code>yolov8n-seg.pt</code> \u2705 - TorchScript <code>torchscript</code> <code>yolov8n-seg.torchscript</code> \u2705 <code>imgsz</code>, <code>optimize</code> ONNX <code>onnx</code> <code>yolov8n-seg.onnx</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>dynamic</code>, <code>simplify</code>, <code>opset</code> OpenVINO <code>openvino</code> <code>yolov8n-seg_openvino_model/</code> \u2705 <code>imgsz</code>, <code>half</code> TensorRT <code>engine</code> <code>yolov8n-seg.engine</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>dynamic</code>, <code>simplify</code>, <code>workspace</code> CoreML <code>coreml</code> <code>yolov8n-seg.mlpackage</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code>, <code>nms</code> TF SavedModel <code>saved_model</code> <code>yolov8n-seg_saved_model/</code> \u2705 <code>imgsz</code>, <code>keras</code> TF GraphDef <code>pb</code> <code>yolov8n-seg.pb</code> \u274c <code>imgsz</code> TF Lite <code>tflite</code> <code>yolov8n-seg.tflite</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code> TF Edge TPU <code>edgetpu</code> <code>yolov8n-seg_edgetpu.tflite</code> \u2705 <code>imgsz</code> TF.js <code>tfjs</code> <code>yolov8n-seg_web_model/</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code> PaddlePaddle <code>paddle</code> <code>yolov8n-seg_paddle_model/</code> \u2705 <code>imgsz</code> ncnn <code>ncnn</code> <code>yolov8n-seg_ncnn_model/</code> \u2705 <code>imgsz</code>, <code>half</code> <p>See full <code>export</code> details in the Export page.</p>"},{"location":"usage/callbacks/","title":"Callbacks","text":""},{"location":"usage/callbacks/#callbacks","title":"Callbacks","text":"<p>Ultralytics framework supports callbacks as entry points in strategic stages of train, val, export, and predict modes. Each callback accepts a <code>Trainer</code>, <code>Validator</code>, or <code>Predictor</code> object depending on the operation type. All properties of these objects can be found in Reference section of the docs.</p> <p> Watch: Mastering Ultralytics YOLOv8: Callbacks </p>"},{"location":"usage/callbacks/#examples","title":"Examples","text":""},{"location":"usage/callbacks/#returning-additional-information-with-prediction","title":"Returning additional information with Prediction","text":"<p>In this example, we want to return the original frame with each result object. Here's how we can do that</p> <pre><code>from ultralytics import YOLO\n\n\ndef on_predict_batch_end(predictor):\n    # Retrieve the batch data\n    _, image, _, _ = predictor.batch\n\n    # Ensure that image is a list\n    image = image if isinstance(image, list) else [image]\n\n    # Combine the prediction results with the corresponding frames\n    predictor.results = zip(predictor.results, image)\n\n\n# Create a YOLO model instance\nmodel = YOLO(f'yolov8n.pt')\n\n# Add the custom callback to the model\nmodel.add_callback(\"on_predict_batch_end\", on_predict_batch_end)\n\n# Iterate through the results and frames\nfor (result, frame) in model.predict():  # or model.track()\n    pass\n</code></pre>"},{"location":"usage/callbacks/#all-callbacks","title":"All callbacks","text":"<p>Here are all supported callbacks. See callbacks source code for additional details.</p>"},{"location":"usage/callbacks/#trainer-callbacks","title":"Trainer Callbacks","text":"Callback Description <code>on_pretrain_routine_start</code> Triggered at the beginning of pre-training routine <code>on_pretrain_routine_end</code> Triggered at the end of pre-training routine <code>on_train_start</code> Triggered when the training starts <code>on_train_epoch_start</code> Triggered at the start of each training epoch <code>on_train_batch_start</code> Triggered at the start of each training batch <code>optimizer_step</code> Triggered during the optimizer step <code>on_before_zero_grad</code> Triggered before gradients are zeroed <code>on_train_batch_end</code> Triggered at the end of each training batch <code>on_train_epoch_end</code> Triggered at the end of each training epoch <code>on_fit_epoch_end</code> Triggered at the end of each fit epoch <code>on_model_save</code> Triggered when the model is saved <code>on_train_end</code> Triggered when the training process ends <code>on_params_update</code> Triggered when model parameters are updated <code>teardown</code> Triggered when the training process is being cleaned up"},{"location":"usage/callbacks/#validator-callbacks","title":"Validator Callbacks","text":"Callback Description <code>on_val_start</code> Triggered when the validation starts <code>on_val_batch_start</code> Triggered at the start of each validation batch <code>on_val_batch_end</code> Triggered at the end of each validation batch <code>on_val_end</code> Triggered when the validation ends"},{"location":"usage/callbacks/#predictor-callbacks","title":"Predictor Callbacks","text":"Callback Description <code>on_predict_start</code> Triggered when the prediction process starts <code>on_predict_batch_start</code> Triggered at the start of each prediction batch <code>on_predict_postprocess_end</code> Triggered at the end of prediction postprocessing <code>on_predict_batch_end</code> Triggered at the end of each prediction batch <code>on_predict_end</code> Triggered when the prediction process ends"},{"location":"usage/callbacks/#exporter-callbacks","title":"Exporter Callbacks","text":"Callback Description <code>on_export_start</code> Triggered when the export process starts <code>on_export_end</code> Triggered when the export process ends"},{"location":"usage/cfg/","title":"Configuration","text":"<p>YOLO settings and hyperparameters play a critical role in the model's performance, speed, and accuracy. These settings and hyperparameters can affect the model's behavior at various stages of the model development process, including training, validation, and prediction.</p> <p> Watch: Mastering Ultralytics YOLOv8: Configuration </p> <p>Ultralytics commands use the following syntax:</p> <p>Example</p> CLIPython <pre><code>yolo TASK MODE ARGS\n</code></pre> <pre><code>from ultralytics import YOLO\n\n# Load a YOLOv8 model from a pre-trained weights file\nmodel = YOLO('yolov8n.pt')\n\n# Run MODE mode using the custom arguments ARGS (guess TASK)\nmodel.MODE(ARGS)\n</code></pre> <p>Where:</p> <ul> <li><code>TASK</code> (optional) is one of (detect, segment, classify, pose)</li> <li><code>MODE</code> (required) is one of (train, val, predict, export, track)</li> <li><code>ARGS</code> (optional) are <code>arg=value</code> pairs like <code>imgsz=640</code> that override defaults.</li> </ul> <p>Default <code>ARG</code> values are defined on this page from the <code>cfg/defaults.yaml</code> file.</p>"},{"location":"usage/cfg/#tasks","title":"Tasks","text":"<p>YOLO models can be used for a variety of tasks, including detection, segmentation, classification and pose. These tasks differ in the type of output they produce and the specific problem they are designed to solve.</p> <ul> <li>Detect: For identifying and localizing objects or regions of interest in an image or video.</li> <li>Segment: For dividing an image or video into regions or pixels that correspond to different objects or classes.</li> <li>Classify: For predicting the class label of an input image.</li> <li>Pose: For identifying objects and estimating their keypoints in an image or video.</li> </ul> Key Value Description <code>task</code> <code>'detect'</code> YOLO task, i.e. detect, segment, classify, pose <p>Tasks Guide</p>"},{"location":"usage/cfg/#modes","title":"Modes","text":"<p>YOLO models can be used in different modes depending on the specific problem you are trying to solve. These modes include:</p> <ul> <li>Train: For training a YOLOv8 model on a custom dataset.</li> <li>Val: For validating a YOLOv8 model after it has been trained.</li> <li>Predict: For making predictions using a trained YOLOv8 model on new images or videos.</li> <li>Export: For exporting a YOLOv8 model to a format that can be used for deployment.</li> <li>Track: For tracking objects in real-time using a YOLOv8 model.</li> <li>Benchmark: For benchmarking YOLOv8 exports (ONNX, TensorRT, etc.) speed and accuracy.</li> </ul> Key Value Description <code>mode</code> <code>'train'</code> YOLO mode, i.e. train, val, predict, export, track, benchmark <p>Modes Guide</p>"},{"location":"usage/cfg/#train","title":"Train","text":"<p>The training settings for YOLO models encompass various hyperparameters and configurations used during the training process. These settings influence the model's performance, speed, and accuracy. Key training settings include batch size, learning rate, momentum, and weight decay. Additionally, the choice of optimizer, loss function, and training dataset composition can impact the training process. Careful tuning and experimentation with these settings are crucial for optimizing performance.</p> Key Value Description <code>model</code> <code>None</code> path to model file, i.e. yolov8n.pt, yolov8n.yaml <code>data</code> <code>None</code> path to data file, i.e. coco128.yaml <code>epochs</code> <code>100</code> number of epochs to train for <code>time</code> <code>None</code> number of hours to train for, overrides epochs if supplied <code>patience</code> <code>50</code> epochs to wait for no observable improvement for early stopping of training <code>batch</code> <code>16</code> number of images per batch (-1 for AutoBatch) <code>imgsz</code> <code>640</code> size of input images as integer <code>save</code> <code>True</code> save train checkpoints and predict results <code>save_period</code> <code>-1</code> Save checkpoint every x epochs (disabled if &lt; 1) <code>cache</code> <code>False</code> True/ram, disk or False. Use cache for data loading <code>device</code> <code>None</code> device to run on, i.e. cuda device=0 or device=0,1,2,3 or device=cpu <code>workers</code> <code>8</code> number of worker threads for data loading (per RANK if DDP) <code>project</code> <code>None</code> project name <code>name</code> <code>None</code> experiment name <code>exist_ok</code> <code>False</code> whether to overwrite existing experiment <code>pretrained</code> <code>True</code> (bool or str) whether to use a pretrained model (bool) or a model to load weights from (str) <code>optimizer</code> <code>'auto'</code> optimizer to use, choices=[SGD, Adam, Adamax, AdamW, NAdam, RAdam, RMSProp, auto] <code>verbose</code> <code>False</code> whether to print verbose output <code>seed</code> <code>0</code> random seed for reproducibility <code>deterministic</code> <code>True</code> whether to enable deterministic mode <code>single_cls</code> <code>False</code> train multi-class data as single-class <code>rect</code> <code>False</code> rectangular training with each batch collated for minimum padding <code>cos_lr</code> <code>False</code> use cosine learning rate scheduler <code>close_mosaic</code> <code>10</code> (int) disable mosaic augmentation for final epochs (0 to disable) <code>resume</code> <code>False</code> resume training from last checkpoint <code>amp</code> <code>True</code> Automatic Mixed Precision (AMP) training, choices=[True, False] <code>fraction</code> <code>1.0</code> dataset fraction to train on (default is 1.0, all images in train set) <code>profile</code> <code>False</code> profile ONNX and TensorRT speeds during training for loggers <code>freeze</code> <code>None</code> (int or list, optional) freeze first n layers, or freeze list of layer indices during training <code>lr0</code> <code>0.01</code> initial learning rate (i.e. SGD=1E-2, Adam=1E-3) <code>lrf</code> <code>0.01</code> final learning rate (lr0 * lrf) <code>momentum</code> <code>0.937</code> SGD momentum/Adam beta1 <code>weight_decay</code> <code>0.0005</code> optimizer weight decay 5e-4 <code>warmup_epochs</code> <code>3.0</code> warmup epochs (fractions ok) <code>warmup_momentum</code> <code>0.8</code> warmup initial momentum <code>warmup_bias_lr</code> <code>0.1</code> warmup initial bias lr <code>box</code> <code>7.5</code> box loss gain <code>cls</code> <code>0.5</code> cls loss gain (scale with pixels) <code>dfl</code> <code>1.5</code> dfl loss gain <code>pose</code> <code>12.0</code> pose loss gain (pose-only) <code>kobj</code> <code>2.0</code> keypoint obj loss gain (pose-only) <code>label_smoothing</code> <code>0.0</code> label smoothing (fraction) <code>nbs</code> <code>64</code> nominal batch size <code>overlap_mask</code> <code>True</code> masks should overlap during training (segment train only) <code>mask_ratio</code> <code>4</code> mask downsample ratio (segment train only) <code>dropout</code> <code>0.0</code> use dropout regularization (classify train only) <code>val</code> <code>True</code> validate/test during training <code>plots</code> <code>False</code> save plots and images during train/val <p>Train Guide</p>"},{"location":"usage/cfg/#predict","title":"Predict","text":"<p>The prediction settings for YOLO models encompass a range of hyperparameters and configurations that influence the model's performance, speed, and accuracy during inference on new data. Careful tuning and experimentation with these settings are essential to achieve optimal performance for a specific task. Key settings include the confidence threshold, Non-Maximum Suppression (NMS) threshold, and the number of classes considered. Additional factors affecting the prediction process are input data size and format, the presence of supplementary features such as masks or multiple labels per box, and the particular task the model is employed for.</p> <p>Inference arguments:</p> Name Type Default Description <code>source</code> <code>str</code> <code>'ultralytics/assets'</code> source directory for images or videos <code>conf</code> <code>float</code> <code>0.25</code> object confidence threshold for detection <code>iou</code> <code>float</code> <code>0.7</code> intersection over union (IoU) threshold for NMS <code>imgsz</code> <code>int or tuple</code> <code>640</code> image size as scalar or (h, w) list, i.e. (640, 480) <code>half</code> <code>bool</code> <code>False</code> use half precision (FP16) <code>device</code> <code>None or str</code> <code>None</code> device to run on, i.e. cuda device=0/1/2/3 or device=cpu <code>max_det</code> <code>int</code> <code>300</code> maximum number of detections per image <code>vid_stride</code> <code>bool</code> <code>False</code> video frame-rate stride <code>stream_buffer</code> <code>bool</code> <code>False</code> buffer all streaming frames (True) or return the most recent frame (False) <code>visualize</code> <code>bool</code> <code>False</code> visualize model features <code>augment</code> <code>bool</code> <code>False</code> apply image augmentation to prediction sources <code>agnostic_nms</code> <code>bool</code> <code>False</code> class-agnostic NMS <code>classes</code> <code>list[int]</code> <code>None</code> filter results by class, i.e. classes=0, or classes=[0,2,3] <code>retina_masks</code> <code>bool</code> <code>False</code> use high-resolution segmentation masks <code>embed</code> <code>list[int]</code> <code>None</code> return feature vectors/embeddings from given layers <p>Visualization arguments:</p> Name Type Default Description <code>show</code> <code>bool</code> <code>False</code> show predicted images and videos if environment allows <code>save</code> <code>bool</code> <code>False</code> save predicted images and videos <code>save_frames</code> <code>bool</code> <code>False</code> save predicted individual video frames <code>save_txt</code> <code>bool</code> <code>False</code> save results as <code>.txt</code> file <code>save_conf</code> <code>bool</code> <code>False</code> save results with confidence scores <code>save_crop</code> <code>bool</code> <code>False</code> save cropped images with results <code>show_labels</code> <code>bool</code> <code>True</code> show prediction labels, i.e. 'person' <code>show_conf</code> <code>bool</code> <code>True</code> show prediction confidence, i.e. '0.99' <code>show_boxes</code> <code>bool</code> <code>True</code> show prediction boxes <code>line_width</code> <code>None or int</code> <code>None</code> line width of the bounding boxes. Scaled to image size if None. <p>Predict Guide</p>"},{"location":"usage/cfg/#val","title":"Val","text":"<p>The val (validation) settings for YOLO models involve various hyperparameters and configurations used to evaluate the model's performance on a validation dataset. These settings influence the model's performance, speed, and accuracy. Common YOLO validation settings include batch size, validation frequency during training, and performance evaluation metrics. Other factors affecting the validation process include the validation dataset's size and composition, as well as the specific task the model is employed for. Careful tuning and experimentation with these settings are crucial to ensure optimal performance on the validation dataset and detect and prevent overfitting.</p> Key Value Description <code>data</code> <code>None</code> path to data file, i.e. coco128.yaml <code>imgsz</code> <code>640</code> size of input images as integer <code>batch</code> <code>16</code> number of images per batch (-1 for AutoBatch) <code>save_json</code> <code>False</code> save results to JSON file <code>save_hybrid</code> <code>False</code> save hybrid version of labels (labels + additional predictions) <code>conf</code> <code>0.001</code> object confidence threshold for detection <code>iou</code> <code>0.6</code> intersection over union (IoU) threshold for NMS <code>max_det</code> <code>300</code> maximum number of detections per image <code>half</code> <code>True</code> use half precision (FP16) <code>device</code> <code>None</code> device to run on, i.e. cuda device=0/1/2/3 or device=cpu <code>dnn</code> <code>False</code> use OpenCV DNN for ONNX inference <code>plots</code> <code>False</code> save plots and images during train/val <code>rect</code> <code>False</code> rectangular val with each batch collated for minimum padding <code>split</code> <code>val</code> dataset split to use for validation, i.e. 'val', 'test' or 'train' <p>Val Guide</p>"},{"location":"usage/cfg/#export","title":"Export","text":"<p>Export settings for YOLO models encompass configurations and options related to saving or exporting the model for use in different environments or platforms. These settings can impact the model's performance, size, and compatibility with various systems. Key export settings include the exported model file format (e.g., ONNX, TensorFlow SavedModel), the target device (e.g., CPU, GPU), and additional features such as masks or multiple labels per box. The export process may also be affected by the model's specific task and the requirements or constraints of the destination environment or platform. It is crucial to thoughtfully configure these settings to ensure the exported model is optimized for the intended use case and functions effectively in the target environment.</p> Key Value Description <code>format</code> <code>'torchscript'</code> format to export to <code>imgsz</code> <code>640</code> image size as scalar or (h, w) list, i.e. (640, 480) <code>keras</code> <code>False</code> use Keras for TF SavedModel export <code>optimize</code> <code>False</code> TorchScript: optimize for mobile <code>half</code> <code>False</code> FP16 quantization <code>int8</code> <code>False</code> INT8 quantization <code>dynamic</code> <code>False</code> ONNX/TensorRT: dynamic axes <code>simplify</code> <code>False</code> ONNX/TensorRT: simplify model <code>opset</code> <code>None</code> ONNX: opset version (optional, defaults to latest) <code>workspace</code> <code>4</code> TensorRT: workspace size (GB) <code>nms</code> <code>False</code> CoreML: add NMS <p>Export Guide</p>"},{"location":"usage/cfg/#augmentation","title":"Augmentation","text":"<p>Augmentation settings for YOLO models refer to the various transformations and modifications applied to the training data to increase the diversity and size of the dataset. These settings can affect the model's performance, speed, and accuracy. Some common YOLO augmentation settings include the type and intensity of the transformations applied (e.g. random flips, rotations, cropping, color changes), the probability with which each transformation is applied, and the presence of additional features such as masks or multiple labels per box. Other factors that may affect the augmentation process include the size and composition of the original dataset and the specific task the model is being used for. It is important to carefully tune and experiment with these settings to ensure that the augmented dataset is diverse and representative enough to train a high-performing model.</p> Key Value Description <code>hsv_h</code> <code>0.015</code> image HSV-Hue augmentation (fraction) <code>hsv_s</code> <code>0.7</code> image HSV-Saturation augmentation (fraction) <code>hsv_v</code> <code>0.4</code> image HSV-Value augmentation (fraction) <code>degrees</code> <code>0.0</code> image rotation (+/- deg) <code>translate</code> <code>0.1</code> image translation (+/- fraction) <code>scale</code> <code>0.5</code> image scale (+/- gain) <code>shear</code> <code>0.0</code> image shear (+/- deg) <code>perspective</code> <code>0.0</code> image perspective (+/- fraction), range 0-0.001 <code>flipud</code> <code>0.0</code> image flip up-down (probability) <code>fliplr</code> <code>0.5</code> image flip left-right (probability) <code>mosaic</code> <code>1.0</code> image mosaic (probability) <code>mixup</code> <code>0.0</code> image mixup (probability) <code>copy_paste</code> <code>0.0</code> segment copy-paste (probability) <code>auto_augment</code> <code>'randaugment'</code> auto augmentation policy for classification (randaugment, autoaugment, augmix) <code>erasing</code> <code>0.4</code> probability o random erasing during classification training (0-1) training"},{"location":"usage/cfg/#logging-checkpoints-plotting-and-file-management","title":"Logging, checkpoints, plotting and file management","text":"<p>Logging, checkpoints, plotting, and file management are important considerations when training a YOLO model.</p> <ul> <li>Logging: It is often helpful to log various metrics and statistics during training to track the model's progress and diagnose any issues that may arise. This can be done using a logging library such as TensorBoard or by writing log messages to a file.</li> <li>Checkpoints: It is a good practice to save checkpoints of the model at regular intervals during training. This allows you to resume training from a previous point if the training process is interrupted or if you want to experiment with different training configurations.</li> <li>Plotting: Visualizing the model's performance and training progress can be helpful for understanding how the model is behaving and identifying potential issues. This can be done using a plotting library such as matplotlib or by generating plots using a logging library such as TensorBoard.</li> <li>File management: Managing the various files generated during the training process, such as model checkpoints, log files, and plots, can be challenging. It is important to have a clear and organized file structure to keep track of these files and make it easy to access and analyze them as needed.</li> </ul> <p>Effective logging, checkpointing, plotting, and file management can help you keep track of the model's progress and make it easier to debug and optimize the training process.</p> Key Value Description <code>project</code> <code>'runs'</code> project name <code>name</code> <code>'exp'</code> experiment name. <code>exp</code> gets automatically incremented if not specified, i.e, <code>exp</code>, <code>exp2</code> ... <code>exist_ok</code> <code>False</code> whether to overwrite existing experiment <code>plots</code> <code>False</code> save plots during train/val <code>save</code> <code>False</code> save train checkpoints and predict results"},{"location":"usage/cli/","title":"Command Line Interface Usage","text":"<p>The YOLO command line interface (CLI) allows for simple single-line commands without the need for a Python environment. CLI requires no customization or Python code. You can simply run all tasks from the terminal with the <code>yolo</code> command.</p> <p> Watch: Mastering Ultralytics YOLOv8: CLI </p> <p>Example</p> SyntaxTrainPredictValExportSpecial <p>Ultralytics <code>yolo</code> commands use the following syntax: <pre><code>yolo TASK MODE ARGS\n\nWhere   TASK (optional) is one of [detect, segment, classify]\n        MODE (required) is one of [train, val, predict, export, track]\n        ARGS (optional) are any number of custom 'arg=value' pairs like 'imgsz=320' that override defaults.\n</code></pre> See all ARGS in the full Configuration Guide or with <code>yolo cfg</code></p> <p>Train a detection model for 10 epochs with an initial learning_rate of 0.01 <pre><code>yolo train data=coco128.yaml model=yolov8n.pt epochs=10 lr0=0.01\n</code></pre></p> <p>Predict a YouTube video using a pretrained segmentation model at image size 320: <pre><code>yolo predict model=yolov8n-seg.pt source='https://youtu.be/LNwODJXcvt4' imgsz=320\n</code></pre></p> <p>Val a pretrained detection model at batch-size 1 and image size 640: <pre><code>yolo val model=yolov8n.pt data=coco128.yaml batch=1 imgsz=640\n</code></pre></p> <p>Export a YOLOv8n classification model to ONNX format at image size 224 by 128 (no TASK required) <pre><code>yolo export model=yolov8n-cls.pt format=onnx imgsz=224,128\n</code></pre></p> <p>Run special commands to see version, view settings, run checks and more: <pre><code>yolo help\nyolo checks\nyolo version\nyolo settings\nyolo copy-cfg\nyolo cfg\n</code></pre></p> <p>Where:</p> <ul> <li><code>TASK</code> (optional) is one of <code>[detect, segment, classify]</code>. If it is not passed explicitly YOLOv8 will try to guess the <code>TASK</code> from the model type.</li> <li><code>MODE</code> (required) is one of <code>[train, val, predict, export, track]</code></li> <li><code>ARGS</code> (optional) are any number of custom <code>arg=value</code> pairs like <code>imgsz=320</code> that override defaults. For a full list of available <code>ARGS</code> see the Configuration page and <code>defaults.yaml</code>   GitHub source.</li> </ul> <p>Warning</p> <p>Arguments must be passed as <code>arg=val</code> pairs, split by an equals <code>=</code> sign and delimited by spaces <code></code> between pairs. Do not use <code>--</code> argument prefixes or commas <code>,</code> between arguments.</p> <ul> <li><code>yolo predict model=yolov8n.pt imgsz=640 conf=0.25</code> \u00a0 \u2705</li> <li><code>yolo predict model yolov8n.pt imgsz 640 conf 0.25</code> \u00a0 \u274c</li> <li><code>yolo predict --model yolov8n.pt --imgsz 640 --conf 0.25</code> \u00a0 \u274c</li> </ul>"},{"location":"usage/cli/#train","title":"Train","text":"<p>Train YOLOv8n on the COCO128 dataset for 100 epochs at image size 640. For a full list of available arguments see the Configuration page.</p> <p>Example</p> TrainResume <p>Start training YOLOv8n on COCO128 for 100 epochs at image-size 640. <pre><code>yolo detect train data=coco128.yaml model=yolov8n.pt epochs=100 imgsz=640\n</code></pre></p> <p>Resume an interrupted training. <pre><code>yolo detect train resume model=last.pt\n</code></pre></p>"},{"location":"usage/cli/#val","title":"Val","text":"<p>Validate trained YOLOv8n model accuracy on the COCO128 dataset. No argument need to passed as the <code>model</code> retains it's training <code>data</code> and arguments as model attributes.</p> <p>Example</p> OfficialCustom <p>Validate an official YOLOv8n model. <pre><code>yolo detect val model=yolov8n.pt\n</code></pre></p> <p>Validate a custom-trained model. <pre><code>yolo detect val model=path/to/best.pt\n</code></pre></p>"},{"location":"usage/cli/#predict","title":"Predict","text":"<p>Use a trained YOLOv8n model to run predictions on images.</p> <p>Example</p> OfficialCustom <p>Predict with an official YOLOv8n model. <pre><code>yolo detect predict model=yolov8n.pt source='https://ultralytics.com/images/bus.jpg'\n</code></pre></p> <p>Predict with a custom model. <pre><code>yolo detect predict model=path/to/best.pt source='https://ultralytics.com/images/bus.jpg'\n</code></pre></p>"},{"location":"usage/cli/#export","title":"Export","text":"<p>Export a YOLOv8n model to a different format like ONNX, CoreML, etc.</p> <p>Example</p> OfficialCustom <p>Export an official YOLOv8n model to ONNX format. <pre><code>yolo export model=yolov8n.pt format=onnx\n</code></pre></p> <p>Export a custom-trained model to ONNX format. <pre><code>yolo export model=path/to/best.pt format=onnx\n</code></pre></p> <p>Available YOLOv8 export formats are in the table below. You can export to any format using the <code>format</code> argument, i.e. <code>format='onnx'</code> or <code>format='engine'</code>.</p> Format <code>format</code> Argument Model Metadata Arguments PyTorch - <code>yolov8n.pt</code> \u2705 - TorchScript <code>torchscript</code> <code>yolov8n.torchscript</code> \u2705 <code>imgsz</code>, <code>optimize</code> ONNX <code>onnx</code> <code>yolov8n.onnx</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>dynamic</code>, <code>simplify</code>, <code>opset</code> OpenVINO <code>openvino</code> <code>yolov8n_openvino_model/</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code> TensorRT <code>engine</code> <code>yolov8n.engine</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>dynamic</code>, <code>simplify</code>, <code>workspace</code> CoreML <code>coreml</code> <code>yolov8n.mlpackage</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code>, <code>nms</code> TF SavedModel <code>saved_model</code> <code>yolov8n_saved_model/</code> \u2705 <code>imgsz</code>, <code>keras</code>, <code>int8</code> TF GraphDef <code>pb</code> <code>yolov8n.pb</code> \u274c <code>imgsz</code> TF Lite <code>tflite</code> <code>yolov8n.tflite</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code> TF Edge TPU <code>edgetpu</code> <code>yolov8n_edgetpu.tflite</code> \u2705 <code>imgsz</code> TF.js <code>tfjs</code> <code>yolov8n_web_model/</code> \u2705 <code>imgsz</code>, <code>half</code>, <code>int8</code> PaddlePaddle <code>paddle</code> <code>yolov8n_paddle_model/</code> \u2705 <code>imgsz</code> ncnn <code>ncnn</code> <code>yolov8n_ncnn_model/</code> \u2705 <code>imgsz</code>, <code>half</code>"},{"location":"usage/cli/#overriding-default-arguments","title":"Overriding default arguments","text":"<p>Default arguments can be overridden by simply passing them as arguments in the CLI in <code>arg=value</code> pairs.</p> TrainPredictVal <p>Train a detection model for <code>10 epochs</code> with <code>learning_rate</code> of <code>0.01</code> <pre><code>yolo detect train data=coco128.yaml model=yolov8n.pt epochs=10 lr0=0.01\n</code></pre></p> <p>Predict a YouTube video using a pretrained segmentation model at image size 320: <pre><code>yolo segment predict model=yolov8n-seg.pt source='https://youtu.be/LNwODJXcvt4' imgsz=320\n</code></pre></p> <p>Validate a pretrained detection model at batch-size 1 and image size 640: <pre><code>yolo detect val model=yolov8n.pt data=coco128.yaml batch=1 imgsz=640\n</code></pre></p>"},{"location":"usage/cli/#overriding-default-config-file","title":"Overriding default config file","text":"<p>You can override the <code>default.yaml</code> config file entirely by passing a new file with the <code>cfg</code> arguments, i.e. <code>cfg=custom.yaml</code>.</p> <p>To do this first create a copy of <code>default.yaml</code> in your current working dir with the <code>yolo copy-cfg</code> command.</p> <p>This will create <code>default_copy.yaml</code>, which you can then pass as <code>cfg=default_copy.yaml</code> along with any additional args, like <code>imgsz=320</code> in this example:</p> <p>Example</p> CLI <pre><code>yolo copy-cfg\nyolo cfg=default_copy.yaml imgsz=320\n</code></pre>"},{"location":"usage/engine/","title":"Advanced Customization","text":"<p>Both the Ultralytics YOLO command-line and Python interfaces are simply a high-level abstraction on the base engine executors. Let's take a look at the Trainer engine.</p> <p> Watch: Mastering Ultralytics YOLOv8: Advanced Customization </p>"},{"location":"usage/engine/#basetrainer","title":"BaseTrainer","text":"<p>BaseTrainer contains the generic boilerplate training routine. It can be customized for any task based over overriding the required functions or operations as long the as correct formats are followed. For example, you can support your own custom model and dataloader by just overriding these functions:</p> <ul> <li><code>get_model(cfg, weights)</code> - The function that builds the model to be trained</li> <li><code>get_dataloader()</code> - The function that builds the dataloader More details and source code can be found in <code>BaseTrainer</code> Reference</li> </ul>"},{"location":"usage/engine/#detectiontrainer","title":"DetectionTrainer","text":"<p>Here's how you can use the YOLOv8 <code>DetectionTrainer</code> and customize it.</p> <pre><code>from ultralytics.models.yolo.detect import DetectionTrainer\n\ntrainer = DetectionTrainer(overrides={...})\ntrainer.train()\ntrained_model = trainer.best  # get best model\n</code></pre>"},{"location":"usage/engine/#customizing-the-detectiontrainer","title":"Customizing the DetectionTrainer","text":"<p>Let's customize the trainer to train a custom detection model that is not supported directly. You can do this by simply overloading the existing the <code>get_model</code> functionality:</p> <pre><code>from ultralytics.models.yolo.detect import DetectionTrainer\n\n\nclass CustomTrainer(DetectionTrainer):\n    def get_model(self, cfg, weights):\n        ...\n\n\ntrainer = CustomTrainer(overrides={...})\ntrainer.train()\n</code></pre> <p>You now realize that you need to customize the trainer further to:</p> <ul> <li>Customize the <code>loss function</code>.</li> <li>Add <code>callback</code> that uploads model to your Google Drive after every 10 <code>epochs</code> Here's how you can do it:</li> </ul> <pre><code>from ultralytics.models.yolo.detect import DetectionTrainer\nfrom ultralytics.nn.tasks import DetectionModel\n\n\nclass MyCustomModel(DetectionModel):\n    def init_criterion(self):\n        ...\n\n\nclass CustomTrainer(DetectionTrainer):\n    def get_model(self, cfg, weights):\n        return MyCustomModel(...)\n\n\n# callback to upload model weights\ndef log_model(trainer):\n    last_weight_path = trainer.last\n    print(last_weight_path)\n\n\ntrainer = CustomTrainer(overrides={...})\ntrainer.add_callback(\"on_train_epoch_end\", log_model)  # Adds to existing callback\ntrainer.train()\n</code></pre> <p>To know more about Callback triggering events and entry point, checkout our Callbacks Guide</p>"},{"location":"usage/engine/#other-engine-components","title":"Other engine components","text":"<p>There are other components that can be customized similarly like <code>Validators</code> and <code>Predictors</code>. See Reference section for more information on these.</p>"},{"location":"usage/python/","title":"Python Usage","text":"<p>Welcome to the YOLOv8 Python Usage documentation! This guide is designed to help you seamlessly integrate YOLOv8 into your Python projects for object detection, segmentation, and classification. Here, you'll learn how to load and use pretrained models, train new models, and perform predictions on images. The easy-to-use Python interface is a valuable resource for anyone looking to incorporate YOLOv8 into their Python projects, allowing you to quickly implement advanced object detection capabilities. Let's get started!</p> <p> Watch: Mastering Ultralytics YOLOv8: Python </p> <p>For example, users can load a model, train it, evaluate its performance on a validation set, and even export it to ONNX format with just a few lines of code.</p> <p>Python</p> <pre><code>from ultralytics import YOLO\n\n# Create a new YOLO model from scratch\nmodel = YOLO('yolov8n.yaml')\n\n# Load a pretrained YOLO model (recommended for training)\nmodel = YOLO('yolov8n.pt')\n\n# Train the model using the 'coco128.yaml' dataset for 3 epochs\nresults = model.train(data='coco128.yaml', epochs=3)\n\n# Evaluate the model's performance on the validation set\nresults = model.val()\n\n# Perform object detection on an image using the model\nresults = model('https://ultralytics.com/images/bus.jpg')\n\n# Export the model to ONNX format\nsuccess = model.export(format='onnx')\n</code></pre>"},{"location":"usage/python/#train","title":"Train","text":"<p>Train mode is used for training a YOLOv8 model on a custom dataset. In this mode, the model is trained using the specified dataset and hyperparameters. The training process involves optimizing the model's parameters so that it can accurately predict the classes and locations of objects in an image.</p> <p>Train</p> From pretrained(recommended)From scratchResume <pre><code>from ultralytics import YOLO\n\nmodel = YOLO('yolov8n.pt') # pass any model type\nresults = model.train(epochs=5)\n</code></pre> <pre><code>from ultralytics import YOLO\n\nmodel = YOLO('yolov8n.yaml')\nresults = model.train(data='coco128.yaml', epochs=5)\n</code></pre> <pre><code>model = YOLO(\"last.pt\")\nresults = model.train(resume=True)\n</code></pre> <p>Train Examples</p>"},{"location":"usage/python/#val","title":"Val","text":"<p>Val mode is used for validating a YOLOv8 model after it has been trained. In this mode, the model is evaluated on a validation set to measure its accuracy and generalization performance. This mode can be used to tune the hyperparameters of the model to improve its performance.</p> <p>Val</p> Val after trainingVal independently <pre><code>  from ultralytics import YOLO\n\n  model = YOLO('yolov8n.yaml')\n  model.train(data='coco128.yaml', epochs=5)\n  model.val()  # It'll automatically evaluate the data you trained.\n</code></pre> <pre><code>  from ultralytics import YOLO\n\n  model = YOLO(\"model.pt\")\n  # It'll use the data YAML file in model.pt if you don't set data.\n  model.val()\n  # or you can set the data you want to val\n  model.val(data='coco128.yaml')\n</code></pre> <p>Val Examples</p>"},{"location":"usage/python/#predict","title":"Predict","text":"<p>Predict mode is used for making predictions using a trained YOLOv8 model on new images or videos. In this mode, the model is loaded from a checkpoint file, and the user can provide images or videos to perform inference. The model predicts the classes and locations of objects in the input images or videos.</p> <p>Predict</p> From sourceResults usage <pre><code>from ultralytics import YOLO\nfrom PIL import Image\nimport cv2\n\nmodel = YOLO(\"model.pt\")\n# accepts all formats - image/dir/Path/URL/video/PIL/ndarray. 0 for webcam\nresults = model.predict(source=\"0\")\nresults = model.predict(source=\"folder\", show=True) # Display preds. Accepts all YOLO predict arguments\n\n# from PIL\nim1 = Image.open(\"bus.jpg\")\nresults = model.predict(source=im1, save=True)  # save plotted images\n\n# from ndarray\nim2 = cv2.imread(\"bus.jpg\")\nresults = model.predict(source=im2, save=True, save_txt=True)  # save predictions as labels\n\n# from list of PIL/ndarray\nresults = model.predict(source=[im1, im2])\n</code></pre> <pre><code># results would be a list of Results object including all the predictions by default\n# but be careful as it could occupy a lot memory when there're many images,\n# especially the task is segmentation.\n# 1. return as a list\nresults = model.predict(source=\"folder\")\n\n# results would be a generator which is more friendly to memory by setting stream=True\n# 2. return as a generator\nresults = model.predict(source=0, stream=True)\n\nfor result in results:\n    # Detection\n    result.boxes.xyxy   # box with xyxy format, (N, 4)\n    result.boxes.xywh   # box with xywh format, (N, 4)\n    result.boxes.xyxyn  # box with xyxy format but normalized, (N, 4)\n    result.boxes.xywhn  # box with xywh format but normalized, (N, 4)\n    result.boxes.conf   # confidence score, (N, 1)\n    result.boxes.cls    # cls, (N, 1)\n\n    # Segmentation\n    result.masks.data      # masks, (N, H, W)\n    result.masks.xy        # x,y segments (pixels), List[segment] * N\n    result.masks.xyn       # x,y segments (normalized), List[segment] * N\n\n    # Classification\n    result.probs     # cls prob, (num_class, )\n\n# Each result is composed of torch.Tensor by default,\n# in which you can easily use following functionality:\nresult = result.cuda()\nresult = result.cpu()\nresult = result.to(\"cpu\")\nresult = result.numpy()\n</code></pre> <p>Predict Examples</p>"},{"location":"usage/python/#export","title":"Export","text":"<p>Export mode is used for exporting a YOLOv8 model to a format that can be used for deployment. In this mode, the model is converted to a format that can be used by other software applications or hardware devices. This mode is useful when deploying the model to production environments.</p> <p>Export</p> Export to ONNXExport to TensorRT <p>Export an official YOLOv8n model to ONNX with dynamic batch-size and image-size. <pre><code>  from ultralytics import YOLO\n\n  model = YOLO('yolov8n.pt')\n  model.export(format='onnx', dynamic=True)\n</code></pre></p> <p>Export an official YOLOv8n model to TensorRT on <code>device=0</code> for acceleration on CUDA devices. <pre><code>  from ultralytics import YOLO\n\n  model = YOLO('yolov8n.pt')\n  model.export(format='onnx', device=0)\n</code></pre></p> <p>Export Examples</p>"},{"location":"usage/python/#track","title":"Track","text":"<p>Track mode is used for tracking objects in real-time using a YOLOv8 model. In this mode, the model is loaded from a checkpoint file, and the user can provide a live video stream to perform real-time object tracking. This mode is useful for applications such as surveillance systems or self-driving cars.</p> <p>Track</p> Python <pre><code>from ultralytics import YOLO\n\n# Load a model\nmodel = YOLO('yolov8n.pt')  # load an official detection model\nmodel = YOLO('yolov8n-seg.pt')  # load an official segmentation model\nmodel = YOLO('path/to/best.pt')  # load a custom model\n\n# Track with the model\nresults = model.track(source=\"https://youtu.be/LNwODJXcvt4\", show=True)\nresults = model.track(source=\"https://youtu.be/LNwODJXcvt4\", show=True, tracker=\"bytetrack.yaml\")\n</code></pre> <p>Track Examples</p>"},{"location":"usage/python/#benchmark","title":"Benchmark","text":"<p>Benchmark mode is used to profile the speed and accuracy of various export formats for YOLOv8. The benchmarks provide information on the size of the exported format, its <code>mAP50-95</code> metrics (for object detection and segmentation) or <code>accuracy_top5</code> metrics (for classification), and the inference time in milliseconds per image across various export formats like ONNX, OpenVINO, TensorRT and others. This information can help users choose the optimal export format for their specific use case based on their requirements for speed and accuracy.</p> <p>Benchmark</p> Python <p>Benchmark an official YOLOv8n model across all export formats. <pre><code>from ultralytics.utils.benchmarks import benchmark\n\n# Benchmark\nbenchmark(model='yolov8n.pt', data='coco8.yaml', imgsz=640, half=False, device=0)\n</code></pre></p> <p>Benchmark Examples</p>"},{"location":"usage/python/#explorer","title":"Explorer","text":"<p>Explorer API can be used to explore datasets with advanced semantic, vector-similarity and SQL search among other features. It also searching for images based on their content using natural language by utilizing the power of LLMs. The Explorer API allows you to write your own dataset exploration notebooks or scripts to get insights into your datasets.</p> <p>Semantic Search Using Explorer</p> Using ImagesUsing Dataset Indices <pre><code>from ultralytics import Explorer\n\n# create an Explorer object\nexp = Explorer(data='coco128.yaml', model='yolov8n.pt')\nexp.create_embeddings_table()\n\nsimilar = exp.get_similar(img='https://ultralytics.com/images/bus.jpg', limit=10)\nprint(similar.head())\n\n# Search using multiple indices\nsimilar = exp.get_similar(\n                        img=['https://ultralytics.com/images/bus.jpg',\n                             'https://ultralytics.com/images/bus.jpg'],\n                        limit=10\n                        )\nprint(similar.head())\n</code></pre> <pre><code>from ultralytics import Explorer\n\n# create an Explorer object\nexp = Explorer(data='coco128.yaml', model='yolov8n.pt')\nexp.create_embeddings_table()\n\nsimilar = exp.get_similar(idx=1, limit=10)\nprint(similar.head())\n\n# Search using multiple indices\nsimilar = exp.get_similar(idx=[1,10], limit=10)\nprint(similar.head())\n</code></pre> <p>Explorer</p>"},{"location":"usage/python/#using-trainers","title":"Using Trainers","text":"<p><code>YOLO</code> model class is a high-level wrapper on the Trainer classes. Each YOLO task has its own trainer that inherits from <code>BaseTrainer</code>.</p> <p>Detection Trainer Example</p> <pre><code>```python\nfrom ultralytics.models.yolo import DetectionTrainer, DetectionValidator, DetectionPredictor\n\n# trainer\ntrainer = DetectionTrainer(overrides={})\ntrainer.train()\ntrained_model = trainer.best\n\n# Validator\nval = DetectionValidator(args=...)\nval(model=trained_model)\n\n# predictor\npred = DetectionPredictor(overrides={})\npred(source=SOURCE, model=trained_model)\n\n# resume from last weight\noverrides[\"resume\"] = trainer.last\ntrainer = detect.DetectionTrainer(overrides=overrides)\n```\n</code></pre> <p>You can easily customize Trainers to support custom tasks or explore R&amp;D ideas. Learn more about Customizing <code>Trainers</code>, <code>Validators</code> and <code>Predictors</code> to suit your project needs in the Customization Section.</p> <p>Customization tutorials</p>"},{"location":"yolov5/","title":"Comprehensive Guide to Ultralytics YOLOv5","text":"Welcome to the Ultralytics' YOLOv5\ud83d\ude80 Documentation! YOLOv5, the fifth iteration of the revolutionary \"You Only Look Once\" object detection model, is designed to deliver high-speed, high-accuracy results in real-time.    Built on PyTorch, this powerful deep learning framework has garnered immense popularity for its versatility, ease of use, and high performance. Our documentation guides you through the installation process, explains the architectural nuances of the model, showcases various use-cases, and provides a series of detailed tutorials. These resources will help you harness the full potential of YOLOv5 for your computer vision projects. Let's get started!"},{"location":"yolov5/#explore-and-learn","title":"Explore and Learn","text":"<p>Here's a compilation of comprehensive tutorials that will guide you through different aspects of YOLOv5.</p> <ul> <li>Train Custom Data \ud83d\ude80 RECOMMENDED: Learn how to train the YOLOv5 model on your custom dataset.</li> <li>Tips for Best Training Results \u2618\ufe0f: Uncover practical tips to optimize your model training process.</li> <li>Multi-GPU Training: Understand how to leverage multiple GPUs to expedite your training.</li> <li>PyTorch Hub \ud83c\udf1f NEW: Learn to load pre-trained models via PyTorch Hub.</li> <li>TFLite, ONNX, CoreML, TensorRT Export \ud83d\ude80: Understand how to export your model to different formats.</li> <li>NVIDIA Jetson platform Deployment \ud83c\udf1f NEW: Learn how to deploy your YOLOv5 model on NVIDIA Jetson platform.</li> <li>Test-Time Augmentation (TTA): Explore how to use TTA to improve your model's prediction accuracy.</li> <li>Model Ensembling: Learn the strategy of combining multiple models for improved performance.</li> <li>Model Pruning/Sparsity: Understand pruning and sparsity concepts, and how to create a more efficient model.</li> <li>Hyperparameter Evolution: Discover the process of automated hyperparameter tuning for better model performance.</li> <li>Transfer Learning with Frozen Layers: Learn how to implement transfer learning by freezing layers in YOLOv5.</li> <li>Architecture Summary \ud83c\udf1f Delve into the structural details of the YOLOv5 model.</li> <li>Roboflow for Datasets: Understand how to utilize Roboflow for dataset management, labeling, and active learning.</li> <li>ClearML Logging \ud83c\udf1f Learn how to integrate ClearML for efficient logging during your model training.</li> <li>YOLOv5 with Neural Magic Discover how to use Neural Magic's Deepsparse to prune and quantize your YOLOv5 model.</li> <li>Comet Logging \ud83c\udf1f NEW: Explore how to utilize Comet for improved model training logging.</li> </ul>"},{"location":"yolov5/#supported-environments","title":"Supported Environments","text":"<p>Ultralytics provides a range of ready-to-use environments, each pre-installed with essential dependencies such as CUDA, CUDNN, Python, and PyTorch, to kickstart your projects.</p> <ul> <li>Free GPU Notebooks:  </li> <li>Google Cloud: GCP Quickstart Guide</li> <li>Amazon: AWS Quickstart Guide</li> <li>Azure: AzureML Quickstart Guide</li> <li>Docker: Docker Quickstart Guide </li> </ul>"},{"location":"yolov5/#project-status","title":"Project Status","text":"<p>This badge indicates that all YOLOv5 GitHub Actions Continuous Integration (CI) tests are successfully passing. These CI tests rigorously check the functionality and performance of YOLOv5 across various key aspects: training, validation, inference, export, and benchmarks. They ensure consistent and reliable operation on macOS, Windows, and Ubuntu, with tests conducted every 24 hours and upon each new commit.</p> <p></p>"},{"location":"yolov5/#connect-and-contribute","title":"Connect and Contribute","text":"<p>Your journey with YOLOv5 doesn't have to be a solitary one. Join our vibrant community on GitHub, connect with professionals on LinkedIn, share your results on Twitter, and find educational resources on YouTube. Follow us on TikTok and Instagram for more engaging content.</p> <p>Interested in contributing? We welcome contributions of all forms; from code improvements and bug reports to documentation updates. Check out our contributing guidelines for more information.</p> <p>We're excited to see the innovative ways you'll use YOLOv5. Dive in, experiment, and revolutionize your computer vision projects! \ud83d\ude80</p>"},{"location":"yolov5/quickstart_tutorial/","title":"YOLOv5 Quickstart \ud83d\ude80","text":"<p>Embark on your journey into the dynamic realm of real-time object detection with YOLOv5! This guide is crafted to serve as a comprehensive starting point for AI enthusiasts and professionals aiming to master YOLOv5. From initial setup to advanced training techniques, we've got you covered. By the end of this guide, you'll have the knowledge to implement YOLOv5 into your projects confidently. Let's ignite the engines and soar into YOLOv5!</p>"},{"location":"yolov5/quickstart_tutorial/#install","title":"Install","text":"<p>Prepare for launch by cloning the repository and establishing the environment. This ensures that all the necessary requirements are installed. Check that you have Python&gt;=3.8.0 and PyTorch&gt;=1.8 ready for takeoff.</p> <pre><code>git clone https://github.com/ultralytics/yolov5  # clone repository\ncd yolov5\npip install -r requirements.txt  # install dependencies\n</code></pre>"},{"location":"yolov5/quickstart_tutorial/#inference-with-pytorch-hub","title":"Inference with PyTorch Hub","text":"<p>Experience the simplicity of YOLOv5 PyTorch Hub inference, where models are seamlessly downloaded from the latest YOLOv5 release.</p> <pre><code>import torch\n\n# Model loading\nmodel = torch.hub.load(\"ultralytics/yolov5\", \"yolov5s\")  # Can be 'yolov5n' - 'yolov5x6', or 'custom'\n\n# Inference on images\nimg = \"https://ultralytics.com/images/zidane.jpg\"  # Can be a file, Path, PIL, OpenCV, numpy, or list of images\n\n# Run inference\nresults = model(img)\n\n# Display results\nresults.print()  # Other options: .show(), .save(), .crop(), .pandas(), etc.\n</code></pre>"},{"location":"yolov5/quickstart_tutorial/#inference-with-detectpy","title":"Inference with detect.py","text":"<p>Harness <code>detect.py</code> for versatile inference on various sources. It automatically fetches models from the latest YOLOv5 release and saves results with ease.</p> <pre><code>python detect.py --weights yolov5s.pt --source 0                               # webcam\n                                               img.jpg                         # image\n                                               vid.mp4                         # video\n                                               screen                          # screenshot\n                                               path/                           # directory\n                                               list.txt                        # list of images\n                                               list.streams                    # list of streams\n                                               'path/*.jpg'                    # glob\n                                               'https://youtu.be/LNwODJXcvt4'  # YouTube\n                                               'rtsp://example.com/media.mp4'  # RTSP, RTMP, HTTP stream\n</code></pre>"},{"location":"yolov5/quickstart_tutorial/#training","title":"Training","text":"<p>Replicate the YOLOv5 COCO benchmarks with the instructions below. The necessary models and datasets are pulled directly from the latest YOLOv5 release. Training YOLOv5n/s/m/l/x on a V100 GPU should typically take 1/2/4/6/8 days respectively (note that Multi-GPU setups work faster). Maximize performance by using the highest possible <code>--batch-size</code> or use <code>--batch-size -1</code> for the YOLOv5 AutoBatch feature. The following batch sizes are ideal for V100-16GB GPUs.</p> <pre><code>python train.py --data coco.yaml --epochs 300 --weights '' --cfg yolov5n.yaml  --batch-size 128\n                                                                 yolov5s                    64\n                                                                 yolov5m                    40\n                                                                 yolov5l                    24\n                                                                 yolov5x                    16\n</code></pre> <p></p> <p>To conclude, YOLOv5 is not only a state-of-the-art tool for object detection but also a testament to the power of machine learning in transforming the way we interact with the world through visual understanding. As you progress through this guide and begin applying YOLOv5 to your projects, remember that you are at the forefront of a technological revolution, capable of achieving remarkable feats. Should you need further insights or support from fellow visionaries, you're invited to our GitHub repository home to a thriving community of developers and researchers. Keep exploring, keep innovating, and enjoy the marvels of YOLOv5. Happy detecting! \ud83c\udf20\ud83d\udd0d</p>"},{"location":"yolov5/environments/aws_quickstart_tutorial/","title":"YOLOv5 \ud83d\ude80 on AWS Deep Learning Instance: Your Complete Guide","text":"<p>Setting up a high-performance deep learning environment can be daunting for newcomers, but fear not! \ud83d\udee0\ufe0f With this guide, we'll walk you through the process of getting YOLOv5 up and running on an AWS Deep Learning instance. By leveraging the power of Amazon Web Services (AWS), even those new to machine learning can get started quickly and cost-effectively. The AWS platform's scalability is perfect for both experimentation and production deployment.</p> <p>Other quickstart options for YOLOv5 include our Colab Notebook , GCP Deep Learning VM, and our Docker image at Docker Hub .</p>"},{"location":"yolov5/environments/aws_quickstart_tutorial/#step-1-aws-console-sign-in","title":"Step 1: AWS Console Sign-In","text":"<p>Start by creating an account or signing in to the AWS console at https://aws.amazon.com/console/. Once logged in, select the EC2 service to manage and set up your instances.</p> <p></p>"},{"location":"yolov5/environments/aws_quickstart_tutorial/#step-2-launch-your-instance","title":"Step 2: Launch Your Instance","text":"<p>In the EC2 dashboard, you'll find the Launch Instance button which is your gateway to creating a new virtual server.</p> <p></p>"},{"location":"yolov5/environments/aws_quickstart_tutorial/#selecting-the-right-amazon-machine-image-ami","title":"Selecting the Right Amazon Machine Image (AMI)","text":"<p>Here's where you choose the operating system and software stack for your instance. Type 'Deep Learning' into the search field and select the latest Ubuntu-based Deep Learning AMI, unless your needs dictate otherwise. Amazon's Deep Learning AMIs come pre-installed with popular frameworks and GPU drivers to streamline your setup process.</p> <p></p>"},{"location":"yolov5/environments/aws_quickstart_tutorial/#picking-an-instance-type","title":"Picking an Instance Type","text":"<p>For deep learning tasks, selecting a GPU instance type is generally recommended as it can vastly accelerate model training. For instance size considerations, remember that the model's memory requirements should never exceed what your instance can provide.</p> <p>Note: The size of your model should be a factor in selecting an instance. If your model exceeds an instance's available RAM, select a different instance type with enough memory for your application.</p> <p>For a list of available GPU instance types, visit EC2 Instance Types, specifically under Accelerated Computing.</p> <p></p> <p>For more information on GPU monitoring and optimization, see GPU Monitoring and Optimization. For pricing, see On-Demand Pricing and Spot Pricing.</p>"},{"location":"yolov5/environments/aws_quickstart_tutorial/#configuring-your-instance","title":"Configuring Your Instance","text":"<p>Amazon EC2 Spot Instances offer a cost-effective way to run applications as they allow you to bid for unused capacity at a fraction of the standard cost. For a persistent experience that retains data even when the Spot Instance goes down, opt for a persistent request.</p> <p></p> <p>Remember to adjust the rest of your instance settings and security configurations as needed in Steps 4-7 before launching.</p>"},{"location":"yolov5/environments/aws_quickstart_tutorial/#step-3-connect-to-your-instance","title":"Step 3: Connect to Your Instance","text":"<p>Once your instance is running, select its checkbox and click Connect to access the SSH information. Use the displayed SSH command in your preferred terminal to establish a connection to your instance.</p> <p></p>"},{"location":"yolov5/environments/aws_quickstart_tutorial/#step-4-running-yolov5","title":"Step 4: Running YOLOv5","text":"<p>Logged into your instance, you're now ready to clone the YOLOv5 repository and install dependencies within a Python 3.8 or later environment. YOLOv5's models and datasets will automatically download from the latest release.</p> <pre><code>git clone https://github.com/ultralytics/yolov5  # clone repository\ncd yolov5\npip install -r requirements.txt  # install dependencies\n</code></pre> <p>With your environment set up, you can begin training, validating, performing inference, and exporting your YOLOv5 models:</p> <pre><code># Train a model on your data\npython train.py\n\n# Validate the trained model for Precision, Recall, and mAP\npython val.py --weights yolov5s.pt\n\n# Run inference using the trained model on your images or videos\npython detect.py --weights yolov5s.pt --source path/to/images\n\n# Export the trained model to other formats for deployment\npython export.py --weights yolov5s.pt --include onnx coreml tflite\n</code></pre>"},{"location":"yolov5/environments/aws_quickstart_tutorial/#optional-extras","title":"Optional Extras","text":"<p>To add more swap memory, which can be a savior for large datasets, run:</p> <pre><code>sudo fallocate -l 64G /swapfile  # allocate 64GB swap file\nsudo chmod 600 /swapfile  # modify permissions\nsudo mkswap /swapfile  # set up a Linux swap area\nsudo swapon /swapfile  # activate swap file\nfree -h  # verify swap memory\n</code></pre> <p>And that's it! \ud83c\udf89 You've successfully created an AWS Deep Learning instance and run YOLOv5. Whether you're just starting with object detection or scaling up for production, this setup can help you achieve your machine learning goals. Happy training, validating, and deploying! If you encounter any hiccups along the way, the robust AWS documentation and the active Ultralytics community are here to support you.</p>"},{"location":"yolov5/environments/azureml_quickstart_tutorial/","title":"YOLOv5 \ud83d\ude80 on AzureML","text":"<p>This guide provides a quickstart to use YOLOv5 from an AzureML compute instance.</p> <p>Note that this guide is a quickstart for quick trials. If you want to unlock the full power AzureML, you can find the documentation to:</p> <ul> <li>Create a data asset</li> <li>Create an AzureML job</li> <li>Register a model</li> </ul>"},{"location":"yolov5/environments/azureml_quickstart_tutorial/#prerequisites","title":"Prerequisites","text":"<p>You need an AzureML workspace.</p>"},{"location":"yolov5/environments/azureml_quickstart_tutorial/#create-a-compute-instance","title":"Create a compute instance","text":"<p>From your AzureML workspace, select Compute &gt; Compute instances &gt; New, select the instance with the resources you need.</p> <p></p>"},{"location":"yolov5/environments/azureml_quickstart_tutorial/#open-a-terminal","title":"Open a Terminal","text":"<p>Now from the Notebooks view, open a Terminal and select your compute.</p> <p></p>"},{"location":"yolov5/environments/azureml_quickstart_tutorial/#setup-and-run-yolov5","title":"Setup and run YOLOv5","text":"<p>Now you can, create a virtual environment:</p> <pre><code>conda create --name yolov5env -y\nconda activate yolov5env\nconda install pip -y\n</code></pre> <p>Clone YOLOv5 repository with its submodules:</p> <pre><code>git clone https://github.com/ultralytics/yolov5\ncd yolov5\ngit submodule update --init --recursive # Note that you might have a message asking you to add your folder as a safe.directory just copy the recommended command\n</code></pre> <p>Install the required dependencies:</p> <pre><code>pip install -r yolov5/requirements.txt\npip install onnx&gt;=1.10.0\n</code></pre> <p>Train the YOLOv5 model:</p> <pre><code>python train.py\n</code></pre> <p>Validate the model for Precision, Recall, and mAP</p> <pre><code>python val.py --weights yolov5s.pt\n</code></pre> <p>Run inference on images and videos:</p> <pre><code>python detect.py --weights yolov5s.pt --source path/to/images\n</code></pre> <p>Export models to other formats:</p> <pre><code>python detect.py --weights yolov5s.pt --source path/to/images\n</code></pre>"},{"location":"yolov5/environments/azureml_quickstart_tutorial/#notes-on-using-a-notebook","title":"Notes on using a notebook","text":"<p>Note that if you want to run these commands from a Notebook, you need to create a new Kernel and select your new Kernel on the top of your Notebook.</p> <p>If you create Python cells it will automatically use your custom environment, but if you add bash cells, you will need to run <code>source activate &lt;your-env&gt;</code> on each of these cells to make sure it uses your custom environment.</p> <p>For example:</p> <pre><code>%%bash\nsource activate newenv\npython val.py --weights yolov5s.pt\n</code></pre>"},{"location":"yolov5/environments/docker_image_quickstart_tutorial/","title":"Get Started with YOLOv5 \ud83d\ude80 in Docker","text":"<p>This tutorial will guide you through the process of setting up and running YOLOv5 in a Docker container.</p> <p>You can also explore other quickstart options for YOLOv5, such as our Colab Notebook , GCP Deep Learning VM, and Amazon AWS.</p>"},{"location":"yolov5/environments/docker_image_quickstart_tutorial/#prerequisites","title":"Prerequisites","text":"<ol> <li>Nvidia Driver: Version 455.23 or higher. Download from Nvidia's website.</li> <li>Nvidia-Docker: Allows Docker to interact with your local GPU. Installation instructions are available on the Nvidia-Docker GitHub repository.</li> <li>Docker Engine - CE: Version 19.03 or higher. Download and installation instructions can be found on the Docker website.</li> </ol>"},{"location":"yolov5/environments/docker_image_quickstart_tutorial/#step-1-pull-the-yolov5-docker-image","title":"Step 1: Pull the YOLOv5 Docker Image","text":"<p>The Ultralytics YOLOv5 DockerHub repository is available at https://hub.docker.com/r/ultralytics/yolov5. Docker Autobuild ensures that the <code>ultralytics/yolov5:latest</code> image is always in sync with the most recent repository commit. To pull the latest image, run the following command:</p> <pre><code>sudo docker pull ultralytics/yolov5:latest\n</code></pre>"},{"location":"yolov5/environments/docker_image_quickstart_tutorial/#step-2-run-the-docker-container","title":"Step 2: Run the Docker Container","text":""},{"location":"yolov5/environments/docker_image_quickstart_tutorial/#basic-container","title":"Basic container:","text":"<p>Run an interactive instance of the YOLOv5 Docker image (called a \"container\") using the <code>-it</code> flag:</p> <pre><code>sudo docker run --ipc=host -it ultralytics/yolov5:latest\n</code></pre>"},{"location":"yolov5/environments/docker_image_quickstart_tutorial/#container-with-local-file-access","title":"Container with local file access:","text":"<p>To run a container with access to local files (e.g., COCO training data in <code>/datasets</code>), use the <code>-v</code> flag:</p> <pre><code>sudo docker run --ipc=host -it -v \"$(pwd)\"/datasets:/usr/src/datasets ultralytics/yolov5:latest\n</code></pre>"},{"location":"yolov5/environments/docker_image_quickstart_tutorial/#container-with-gpu-access","title":"Container with GPU access:","text":"<p>To run a container with GPU access, use the <code>--gpus all</code> flag:</p> <pre><code>sudo docker run --ipc=host -it --gpus all ultralytics/yolov5:latest\n</code></pre>"},{"location":"yolov5/environments/docker_image_quickstart_tutorial/#step-3-use-yolov5-within-the-docker-container","title":"Step 3: Use YOLOv5 \ud83d\ude80 within the Docker Container","text":"<p>Now you can train, test, detect, and export YOLOv5 models within the running Docker container:</p> <pre><code># Train a model on your data\npython train.py\n\n# Validate the trained model for Precision, Recall, and mAP\npython val.py --weights yolov5s.pt\n\n# Run inference using the trained model on your images or videos\npython detect.py --weights yolov5s.pt --source path/to/images\n\n# Export the trained model to other formats for deployment\npython export.py --weights yolov5s.pt --include onnx coreml tflite\n</code></pre> <p></p>"},{"location":"yolov5/environments/google_cloud_quickstart_tutorial/","title":"Mastering YOLOv5 \ud83d\ude80 Deployment on Google Cloud Platform (GCP) Deep Learning Virtual Machine (VM) \u2b50","text":"<p>Embarking on the journey of artificial intelligence and machine learning can be exhilarating, especially when you leverage the power and flexibility of a cloud platform. Google Cloud Platform (GCP) offers robust tools tailored for machine learning enthusiasts and professionals alike. One such tool is the Deep Learning VM that is preconfigured for data science and ML tasks. In this tutorial, we will navigate through the process of setting up YOLOv5 on a GCP Deep Learning VM. Whether you\u2019re taking your first steps in ML or you\u2019re a seasoned practitioner, this guide is designed to provide you with a clear pathway to implementing object detection models powered by YOLOv5.</p> <p>\ud83c\udd93 Plus, if you're a fresh GCP user, you\u2019re in luck with a $300 free credit offer to kickstart your projects.</p> <p>In addition to GCP, explore other accessible quickstart options for YOLOv5, like our Colab Notebook  for a browser-based experience, or the scalability of Amazon AWS. Furthermore, container aficionados can utilize our official Docker image at Docker Hub  for an encapsulated environment.</p>"},{"location":"yolov5/environments/google_cloud_quickstart_tutorial/#step-1-create-and-configure-your-deep-learning-vm","title":"Step 1: Create and Configure Your Deep Learning VM","text":"<p>Let\u2019s begin by creating a virtual machine that\u2019s tuned for deep learning:</p> <ol> <li>Head over to the GCP marketplace and select the Deep Learning VM.</li> <li>Opt for a n1-standard-8 instance; it offers a balance of 8 vCPUs and 30 GB of memory, ideally suited for our needs.</li> <li>Next, select a GPU. This depends on your workload; even a basic one like the Tesla T4 will markedly accelerate your model training.</li> <li>Tick the box for 'Install NVIDIA GPU driver automatically on first startup?' for hassle-free setup.</li> <li>Allocate a 300 GB SSD Persistent Disk to ensure you don't bottleneck on I/O operations.</li> <li>Hit 'Deploy' and let GCP do its magic in provisioning your custom Deep Learning VM.</li> </ol> <p>This VM comes loaded with a treasure trove of preinstalled tools and frameworks, including the Anaconda Python distribution, which conveniently bundles all the necessary dependencies for YOLOv5.</p> <p></p>"},{"location":"yolov5/environments/google_cloud_quickstart_tutorial/#step-2-ready-the-vm-for-yolov5","title":"Step 2: Ready the VM for YOLOv5","text":"<p>Following the environment setup, let's get YOLOv5 up and running:</p> <pre><code># Clone the YOLOv5 repository\ngit clone https://github.com/ultralytics/yolov5\n\n# Change the directory to the cloned repository\ncd yolov5\n\n# Install the necessary Python packages from requirements.txt\npip install -r requirements.txt\n</code></pre> <p>This setup process ensures you're working with a Python environment version 3.8.0 or newer and PyTorch 1.8 or above. Our scripts smoothly download models and datasets rending from the latest YOLOv5 release, making it hassle-free to start model training.</p>"},{"location":"yolov5/environments/google_cloud_quickstart_tutorial/#step-3-train-and-deploy-your-yolov5-models","title":"Step 3: Train and Deploy Your YOLOv5 Models \ud83c\udf10","text":"<p>With the setup complete, you're ready to delve into training and inference with YOLOv5 on your GCP VM:</p> <pre><code># Train a model on your data\npython train.py\n\n# Validate the trained model for Precision, Recall, and mAP\npython val.py --weights yolov5s.pt\n\n# Run inference using the trained model on your images or videos\npython detect.py --weights yolov5s.pt --source path/to/images\n\n# Export the trained model to other formats for deployment\npython export.py --weights yolov5s.pt --include onnx coreml tflite\n</code></pre> <p>With just a few commands, YOLOv5 allows you to train custom object detection models tailored to your specific needs or utilize pre-trained weights for quick results on a variety of tasks.</p> <p></p>"},{"location":"yolov5/environments/google_cloud_quickstart_tutorial/#allocate-swap-space-optional","title":"Allocate Swap Space (optional)","text":"<p>For those dealing with hefty datasets, consider amplifying your GCP instance with an additional 64GB of swap memory:</p> <pre><code>sudo fallocate -l 64G /swapfile\nsudo chmod 600 /swapfile\nsudo mkswap /swapfile\nsudo swapon /swapfile\nfree -h  # confirm the memory increment\n</code></pre>"},{"location":"yolov5/environments/google_cloud_quickstart_tutorial/#concluding-thoughts","title":"Concluding Thoughts","text":"<p>Congratulations! You are now empowered to harness the capabilities of YOLOv5 with the computational prowess of Google Cloud Platform. This combination provides scalability, efficiency, and versatility for your object detection tasks. Whether for personal projects, academic research, or industrial applications, you have taken a pivotal step into the world of AI and machine learning on the cloud.</p> <p>Do remember to document your journey, share insights with the Ultralytics community, and leverage the collaborative arenas such as GitHub discussions to grow further. Now, go forth and innovate with YOLOv5 and GCP! \ud83c\udf1f</p> <p>Want to keep improving your ML skills and knowledge? Dive into our documentation and tutorials for more resources. Let your AI adventure continue!</p>"},{"location":"yolov5/tutorials/architecture_description/","title":"Ultralytics YOLOv5 Architecture","text":"<p>YOLOv5 (v6.0/6.1) is a powerful object detection algorithm developed by Ultralytics. This article dives deep into the YOLOv5 architecture, data augmentation strategies, training methodologies, and loss computation techniques. This comprehensive understanding will help improve your practical application of object detection in various fields, including surveillance, autonomous vehicles, and image recognition.</p>"},{"location":"yolov5/tutorials/architecture_description/#1-model-structure","title":"1. Model Structure","text":"<p>YOLOv5's architecture consists of three main parts:</p> <ul> <li>Backbone: This is the main body of the network. For YOLOv5, the backbone is designed using the <code>New CSP-Darknet53</code> structure, a modification of the Darknet architecture used in previous versions.</li> <li>Neck: This part connects the backbone and the head. In YOLOv5, <code>SPPF</code> and <code>New CSP-PAN</code> structures are utilized.</li> <li>Head: This part is responsible for generating the final output. YOLOv5 uses the <code>YOLOv3 Head</code> for this purpose.</li> </ul> <p>The structure of the model is depicted in the image below. The model structure details can be found in <code>yolov5l.yaml</code>.</p> <p></p> <p>YOLOv5 introduces some minor changes compared to its predecessors:</p> <ol> <li>The <code>Focus</code> structure, found in earlier versions, is replaced with a <code>6x6 Conv2d</code> structure. This change boosts efficiency #4825.</li> <li>The <code>SPP</code> structure is replaced with <code>SPPF</code>. This alteration more than doubles the speed of processing.</li> </ol> <p>To test the speed of <code>SPP</code> and <code>SPPF</code>, the following code can be used:</p> SPP vs SPPF speed profiling example (click to open) <pre><code>import time\nimport torch\nimport torch.nn as nn\n\n\nclass SPP(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.maxpool1 = nn.MaxPool2d(5, 1, padding=2)\n        self.maxpool2 = nn.MaxPool2d(9, 1, padding=4)\n        self.maxpool3 = nn.MaxPool2d(13, 1, padding=6)\n\n    def forward(self, x):\n        o1 = self.maxpool1(x)\n        o2 = self.maxpool2(x)\n        o3 = self.maxpool3(x)\n        return torch.cat([x, o1, o2, o3], dim=1)\n\n\nclass SPPF(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.maxpool = nn.MaxPool2d(5, 1, padding=2)\n\n    def forward(self, x):\n        o1 = self.maxpool(x)\n        o2 = self.maxpool(o1)\n        o3 = self.maxpool(o2)\n        return torch.cat([x, o1, o2, o3], dim=1)\n\n\ndef main():\n    input_tensor = torch.rand(8, 32, 16, 16)\n    spp = SPP()\n    sppf = SPPF()\n    output1 = spp(input_tensor)\n    output2 = sppf(input_tensor)\n\n    print(torch.equal(output1, output2))\n\n    t_start = time.time()\n    for _ in range(100):\n        spp(input_tensor)\n    print(f\"SPP time: {time.time() - t_start}\")\n\n    t_start = time.time()\n    for _ in range(100):\n        sppf(input_tensor)\n    print(f\"SPPF time: {time.time() - t_start}\")\n\n\nif __name__ == '__main__':\n    main()\n</code></pre>  result:  <pre><code>True\nSPP time: 0.5373051166534424\nSPPF time: 0.20780706405639648\n</code></pre>"},{"location":"yolov5/tutorials/architecture_description/#2-data-augmentation-techniques","title":"2. Data Augmentation Techniques","text":"<p>YOLOv5 employs various data augmentation techniques to improve the model's ability to generalize and reduce overfitting. These techniques include:</p> <ul> <li>Mosaic Augmentation: An image processing technique that combines four training images into one in ways that encourage object detection models to better handle various object scales and translations.</li> </ul> <p></p> <ul> <li>Copy-Paste Augmentation: An innovative data augmentation method that copies random patches from an image and pastes them onto another randomly chosen image, effectively generating a new training sample.</li> </ul> <p></p> <ul> <li>Random Affine Transformations: This includes random rotation, scaling, translation, and shearing of the images.</li> </ul> <p></p> <ul> <li>MixUp Augmentation: A method that creates composite images by taking a linear combination of two images and their associated labels.</li> </ul> <p></p> <ul> <li> <p>Albumentations: A powerful library for image augmenting that supports a wide variety of augmentation techniques.</p> </li> <li> <p>HSV Augmentation: Random changes to the Hue, Saturation, and Value of the images.</p> </li> </ul> <p></p> <ul> <li>Random Horizontal Flip: An augmentation method that randomly flips images horizontally.</li> </ul> <p></p>"},{"location":"yolov5/tutorials/architecture_description/#3-training-strategies","title":"3. Training Strategies","text":"<p>YOLOv5 applies several sophisticated training strategies to enhance the model's performance. They include:</p> <ul> <li>Multiscale Training: The input images are randomly rescaled within a range of 0.5 to 1.5 times their original size during the training process.</li> <li>AutoAnchor: This strategy optimizes the prior anchor boxes to match the statistical characteristics of the ground truth boxes in your custom data.</li> <li>Warmup and Cosine LR Scheduler: A method to adjust the learning rate to enhance model performance.</li> <li>Exponential Moving Average (EMA): A strategy that uses the average of parameters over past steps to stabilize the training process and reduce generalization error.</li> <li>Mixed Precision Training: A method to perform operations in half-precision format, reducing memory usage and enhancing computational speed.</li> <li>Hyperparameter Evolution: A strategy to automatically tune hyperparameters to achieve optimal performance.</li> </ul>"},{"location":"yolov5/tutorials/architecture_description/#4-additional-features","title":"4. Additional Features","text":""},{"location":"yolov5/tutorials/architecture_description/#41-compute-losses","title":"4.1 Compute Losses","text":"<p>The loss in YOLOv5 is computed as a combination of three individual loss components:</p> <ul> <li>Classes Loss (BCE Loss): Binary Cross-Entropy loss, measures the error for the classification task.</li> <li>Objectness Loss (BCE Loss): Another Binary Cross-Entropy loss, calculates the error in detecting whether an object is present in a particular grid cell or not.</li> <li>Location Loss (CIoU Loss): Complete IoU loss, measures the error in localizing the object within the grid cell.</li> </ul> <p>The overall loss function is depicted by:</p> <p></p>"},{"location":"yolov5/tutorials/architecture_description/#42-balance-losses","title":"4.2 Balance Losses","text":"<p>The objectness losses of the three prediction layers (<code>P3</code>, <code>P4</code>, <code>P5</code>) are weighted differently. The balance weights are <code>[4.0, 1.0, 0.4]</code> respectively. This approach ensures that the predictions at different scales contribute appropriately to the total loss.</p> <p></p>"},{"location":"yolov5/tutorials/architecture_description/#43-eliminate-grid-sensitivity","title":"4.3 Eliminate Grid Sensitivity","text":"<p>The YOLOv5 architecture makes some important changes to the box prediction strategy compared to earlier versions of YOLO. In YOLOv2 and YOLOv3, the box coordinates were directly predicted using the activation of the last layer.</p> <p> </p> <p></p> <p>However, in YOLOv5, the formula for predicting the box coordinates has been updated to reduce grid sensitivity and prevent the model from predicting unbounded box dimensions.</p> <p>The revised formulas for calculating the predicted bounding box are as follows:</p> <p> </p> <p>Compare the center point offset before and after scaling. The center point offset range is adjusted from (0, 1) to (-0.5, 1.5). Therefore, offset can easily get 0 or 1.</p> <p></p> <p>Compare the height and width scaling ratio(relative to anchor) before and after adjustment. The original yolo/darknet box equations have a serious flaw. Width and Height are completely unbounded as they are simply out=exp(in), which is dangerous, as it can lead to runaway gradients, instabilities, NaN losses and ultimately a complete loss of training. refer this issue</p> <p></p>"},{"location":"yolov5/tutorials/architecture_description/#44-build-targets","title":"4.4 Build Targets","text":"<p>The build target process in YOLOv5 is critical for training efficiency and model accuracy. It involves assigning ground truth boxes to the appropriate grid cells in the output map and matching them with the appropriate anchor boxes.</p> <p>This process follows these steps:</p> <ul> <li>Calculate the ratio of the ground truth box dimensions and the dimensions of each anchor template.</li> </ul> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <ul> <li>If the calculated ratio is within the threshold, match the ground truth box with the corresponding anchor.</li> </ul> <p></p> <ul> <li>Assign the matched anchor to the appropriate cells, keeping in mind that due to the revised center point offset, a ground truth box can be assigned to more than one anchor. Because the center point offset range is adjusted from (0, 1) to (-0.5, 1.5). GT Box can be assigned to more anchors.</li> </ul> <p></p> <p>This way, the build targets process ensures that each ground truth object is properly assigned and matched during the training process, allowing YOLOv5 to learn the task of object detection more effectively.</p>"},{"location":"yolov5/tutorials/architecture_description/#conclusion","title":"Conclusion","text":"<p>In conclusion, YOLOv5 represents a significant step forward in the development of real-time object detection models. By incorporating various new features, enhancements, and training strategies, it surpasses previous versions of the YOLO family in performance and efficiency.</p> <p>The primary enhancements in YOLOv5 include the use of a dynamic architecture, an extensive range of data augmentation techniques, innovative training strategies, as well as important adjustments in computing losses and the process of building targets. All these innovations significantly improve the accuracy and efficiency of object detection while retaining a high degree of speed, which is the trademark of YOLO models.</p>"},{"location":"yolov5/tutorials/clearml_logging_integration/","title":"ClearML Integration","text":""},{"location":"yolov5/tutorials/clearml_logging_integration/#about-clearml","title":"About ClearML","text":"<p>ClearML is an open-source toolbox designed to save you time \u23f1\ufe0f.</p> <p>\ud83d\udd28 Track every YOLOv5 training run in the experiment manager</p> <p>\ud83d\udd27 Version and easily access your custom training data with the integrated ClearML Data Versioning Tool</p> <p>\ud83d\udd26 Remotely train and monitor your YOLOv5 training runs using ClearML Agent</p> <p>\ud83d\udd2c Get the very best mAP using ClearML Hyperparameter Optimization</p> <p>\ud83d\udd2d Turn your newly trained YOLOv5 model into an API with just a few commands using ClearML Serving</p> <p> And so much more. It's up to you how many of these tools you want to use, you can stick to the experiment manager, or chain them all together into an impressive pipeline!  </p> <p></p> <p> </p>"},{"location":"yolov5/tutorials/clearml_logging_integration/#setting-things-up","title":"\ud83e\uddbe Setting Things Up","text":"<p>To keep track of your experiments and/or data, ClearML needs to communicate to a server. You have 2 options to get one:</p> <p>Either sign up for free to the ClearML Hosted Service or you can set up your own server, see here. Even the server is open-source, so even if you're dealing with sensitive data, you should be good to go!</p> <ul> <li> <p>Install the <code>clearml</code> python package:</p> <pre><code>pip install clearml\n</code></pre> </li> <li> <p>Connect the ClearML SDK to the server by creating credentials (go right top to Settings -&gt; Workspace -&gt; Create new credentials), then execute the command below and follow the instructions:</p> <pre><code>clearml-init\n</code></pre> </li> </ul> <p>That's it! You're done \ud83d\ude0e</p> <p></p>"},{"location":"yolov5/tutorials/clearml_logging_integration/#training-yolov5-with-clearml","title":"\ud83d\ude80 Training YOLOv5 With ClearML","text":"<p>To enable ClearML experiment tracking, simply install the ClearML pip package.</p> <pre><code>pip install clearml&gt;=1.2.0\n</code></pre> <p>This will enable integration with the YOLOv5 training script. Every training run from now on, will be captured and stored by the ClearML experiment manager.</p> <p>If you want to change the <code>project_name</code> or <code>task_name</code>, use the <code>--project</code> and <code>--name</code> arguments of the <code>train.py</code> script, by default the project will be called <code>YOLOv5</code> and the task <code>Training</code>. PLEASE NOTE: ClearML uses <code>/</code> as a delimiter for subprojects, so be careful when using <code>/</code> in your project name!</p> <pre><code>python train.py --img 640 --batch 16 --epochs 3 --data coco128.yaml --weights yolov5s.pt --cache\n</code></pre> <p>or with custom project and task name:</p> <pre><code>python train.py --project my_project --name my_training --img 640 --batch 16 --epochs 3 --data coco128.yaml --weights yolov5s.pt --cache\n</code></pre> <p>This will capture:</p> <ul> <li>Source code + uncommitted changes</li> <li>Installed packages</li> <li>(Hyper)parameters</li> <li>Model files (use <code>--save-period n</code> to save a checkpoint every n epochs)</li> <li>Console output</li> <li>Scalars (mAP_0.5, mAP_0.5:0.95, precision, recall, losses, learning rates, ...)</li> <li>General info such as machine details, runtime, creation date etc.</li> <li>All produced plots such as label correlogram and confusion matrix</li> <li>Images with bounding boxes per epoch</li> <li>Mosaic per epoch</li> <li>Validation images per epoch</li> </ul> <p>That's a lot right? \ud83e\udd2f Now, we can visualize all of this information in the ClearML UI to get an overview of our training progress. Add custom columns to the table view (such as e.g. mAP_0.5) so you can easily sort on the best performing model. Or select multiple experiments and directly compare them!</p> <p>There even more we can do with all of this information, like hyperparameter optimization and remote execution, so keep reading if you want to see how that works!</p>"},{"location":"yolov5/tutorials/clearml_logging_integration/#dataset-version-management","title":"\ud83d\udd17 Dataset Version Management","text":"<p>Versioning your data separately from your code is generally a good idea and makes it easy to acquire the latest version too. This repository supports supplying a dataset version ID, and it will make sure to get the data if it's not there yet. Next to that, this workflow also saves the used dataset ID as part of the task parameters, so you will always know for sure which data was used in which experiment!</p> <p></p>"},{"location":"yolov5/tutorials/clearml_logging_integration/#prepare-your-dataset","title":"Prepare Your Dataset","text":"<p>The YOLOv5 repository supports a number of different datasets by using YAML files containing their information. By default datasets are downloaded to the <code>../datasets</code> folder in relation to the repository root folder. So if you downloaded the <code>coco128</code> dataset using the link in the YAML or with the scripts provided by yolov5, you get this folder structure:</p> <pre><code>..\n|_ yolov5\n|_ datasets\n    |_ coco128\n        |_ images\n        |_ labels\n        |_ LICENSE\n        |_ README.txt\n</code></pre> <p>But this can be any dataset you wish. Feel free to use your own, as long as you keep to this folder structure.</p> <p>Next, \u26a0\ufe0fcopy the corresponding YAML file to the root of the dataset folder\u26a0\ufe0f. This YAML files contains the information ClearML will need to properly use the dataset. You can make this yourself too, of course, just follow the structure of the example YAMLs.</p> <p>Basically we need the following keys: <code>path</code>, <code>train</code>, <code>test</code>, <code>val</code>, <code>nc</code>, <code>names</code>.</p> <pre><code>..\n|_ yolov5\n|_ datasets\n    |_ coco128\n        |_ images\n        |_ labels\n        |_ coco128.yaml  # &lt;---- HERE!\n        |_ LICENSE\n        |_ README.txt\n</code></pre>"},{"location":"yolov5/tutorials/clearml_logging_integration/#upload-your-dataset","title":"Upload Your Dataset","text":"<p>To get this dataset into ClearML as a versioned dataset, go to the dataset root folder and run the following command:</p> <pre><code>cd coco128\nclearml-data sync --project YOLOv5 --name coco128 --folder .\n</code></pre> <p>The command <code>clearml-data sync</code> is actually a shorthand command. You could also run these commands one after the other:</p> <pre><code># Optionally add --parent &lt;parent_dataset_id&gt; if you want to base\n# this version on another dataset version, so no duplicate files are uploaded!\nclearml-data create --name coco128 --project YOLOv5\nclearml-data add --files .\nclearml-data close\n</code></pre>"},{"location":"yolov5/tutorials/clearml_logging_integration/#run-training-using-a-clearml-dataset","title":"Run Training Using A ClearML Dataset","text":"<p>Now that you have a ClearML dataset, you can very simply use it to train custom YOLOv5 \ud83d\ude80 models!</p> <pre><code>python train.py --img 640 --batch 16 --epochs 3 --data clearml://&lt;your_dataset_id&gt; --weights yolov5s.pt --cache\n</code></pre> <p></p>"},{"location":"yolov5/tutorials/clearml_logging_integration/#hyperparameter-optimization","title":"\ud83d\udc40 Hyperparameter Optimization","text":"<p>Now that we have our experiments and data versioned, it's time to take a look at what we can build on top!</p> <p>Using the code information, installed packages and environment details, the experiment itself is now completely reproducible. In fact, ClearML allows you to clone an experiment and even change its parameters. We can then just rerun it with these new parameters automatically, this is basically what HPO does!</p> <p>To run hyperparameter optimization locally, we've included a pre-made script for you. Just make sure a training task has been run at least once, so it is in the ClearML experiment manager, we will essentially clone it and change its hyperparameters.</p> <p>You'll need to fill in the ID of this <code>template task</code> in the script found at <code>utils/loggers/clearml/hpo.py</code> and then just run it :) You can change <code>task.execute_locally()</code> to <code>task.execute()</code> to put it in a ClearML queue and have a remote agent work on it instead.</p> <pre><code># To use optuna, install it first, otherwise you can change the optimizer to just be RandomSearch\npip install optuna\npython utils/loggers/clearml/hpo.py\n</code></pre> <p></p>"},{"location":"yolov5/tutorials/clearml_logging_integration/#remote-execution-advanced","title":"\ud83e\udd2f Remote Execution (advanced)","text":"<p>Running HPO locally is really handy, but what if we want to run our experiments on a remote machine instead? Maybe you have access to a very powerful GPU machine on-site, or you have some budget to use cloud GPUs. This is where the ClearML Agent comes into play. Check out what the agent can do here:</p> <ul> <li>YouTube video</li> <li>Documentation</li> </ul> <p>In short: every experiment tracked by the experiment manager contains enough information to reproduce it on a different machine (installed packages, uncommitted changes etc.). So a ClearML agent does just that: it listens to a queue for incoming tasks and when it finds one, it recreates the environment and runs it while still reporting scalars, plots etc. to the experiment manager.</p> <p>You can turn any machine (a cloud VM, a local GPU machine, your own laptop ... ) into a ClearML agent by simply running:</p> <pre><code>clearml-agent daemon --queue &lt;queues_to_listen_to&gt; [--docker]\n</code></pre>"},{"location":"yolov5/tutorials/clearml_logging_integration/#cloning-editing-and-enqueuing","title":"Cloning, Editing And Enqueuing","text":"<p>With our agent running, we can give it some work. Remember from the HPO section that we can clone a task and edit the hyperparameters? We can do that from the interface too!</p> <p>\ud83e\ude84 Clone the experiment by right-clicking it</p> <p>\ud83c\udfaf Edit the hyperparameters to what you wish them to be</p> <p>\u23f3 Enqueue the task to any of the queues by right-clicking it</p> <p></p>"},{"location":"yolov5/tutorials/clearml_logging_integration/#executing-a-task-remotely","title":"Executing A Task Remotely","text":"<p>Now you can clone a task like we explained above, or simply mark your current script by adding <code>task.execute_remotely()</code> and on execution it will be put into a queue, for the agent to start working on!</p> <p>To run the YOLOv5 training script remotely, all you have to do is add this line to the training.py script after the clearml logger has been instantiated:</p> <pre><code># ...\n# Loggers\ndata_dict = None\nif RANK in {-1, 0}:\n    loggers = Loggers(save_dir, weights, opt, hyp, LOGGER)  # loggers instance\n    if loggers.clearml:\n        loggers.clearml.task.execute_remotely(queue=\"my_queue\")  # &lt;------ ADD THIS LINE\n        # Data_dict is either None is user did not choose for ClearML dataset or is filled in by ClearML\n        data_dict = loggers.clearml.data_dict\n# ...\n</code></pre> <p>When running the training script after this change, python will run the script up until that line, after which it will package the code and send it to the queue instead!</p>"},{"location":"yolov5/tutorials/clearml_logging_integration/#autoscaling-workers","title":"Autoscaling workers","text":"<p>ClearML comes with autoscalers too! This tool will automatically spin up new remote machines in the cloud of your choice (AWS, GCP, Azure) and turn them into ClearML agents for you whenever there are experiments detected in the queue. Once the tasks are processed, the autoscaler will automatically shut down the remote machines, and you stop paying!</p> <p>Check out the autoscalers getting started video below.</p> <p></p>"},{"location":"yolov5/tutorials/comet_logging_integration/","title":"Comet Logging","text":""},{"location":"yolov5/tutorials/comet_logging_integration/#yolov5-with-comet","title":"YOLOv5 with Comet","text":"<p>This guide will cover how to use YOLOv5 with Comet</p>"},{"location":"yolov5/tutorials/comet_logging_integration/#about-comet","title":"About Comet","text":"<p>Comet builds tools that help data scientists, engineers, and team leaders accelerate and optimize machine learning and deep learning models.</p> <p>Track and visualize model metrics in real time, save your hyperparameters, datasets, and model checkpoints, and visualize your model predictions with Comet Custom Panels! Comet makes sure you never lose track of your work and makes it easy to share results and collaborate across teams of all sizes!</p>"},{"location":"yolov5/tutorials/comet_logging_integration/#getting-started","title":"Getting Started","text":""},{"location":"yolov5/tutorials/comet_logging_integration/#install-comet","title":"Install Comet","text":"<pre><code>pip install comet_ml\n</code></pre>"},{"location":"yolov5/tutorials/comet_logging_integration/#configure-comet-credentials","title":"Configure Comet Credentials","text":"<p>There are two ways to configure Comet with YOLOv5.</p> <p>You can either set your credentials through environment variables</p> <p>Environment Variables</p> <pre><code>export COMET_API_KEY=&lt;Your Comet API Key&gt;\nexport COMET_PROJECT_NAME=&lt;Your Comet Project Name&gt; # This will default to 'yolov5'\n</code></pre> <p>Or create a <code>.comet.config</code> file in your working directory and set your credentials there.</p> <p>Comet Configuration File</p> <pre><code>[comet]\napi_key=&lt;Your Comet API Key&gt;\nproject_name=&lt;Your Comet Project Name&gt; # This will default to 'yolov5'\n</code></pre>"},{"location":"yolov5/tutorials/comet_logging_integration/#run-the-training-script","title":"Run the Training Script","text":"<pre><code># Train YOLOv5s on COCO128 for 5 epochs\npython train.py --img 640 --batch 16 --epochs 5 --data coco128.yaml --weights yolov5s.pt\n</code></pre> <p>That's it! Comet will automatically log your hyperparameters, command line arguments, training and validation metrics. You can visualize and analyze your runs in the Comet UI</p> <p></p>"},{"location":"yolov5/tutorials/comet_logging_integration/#try-out-an-example","title":"Try out an Example!","text":"<p>Check out an example of a completed run here</p> <p>Or better yet, try it out yourself in this Colab Notebook</p> <p></p>"},{"location":"yolov5/tutorials/comet_logging_integration/#log-automatically","title":"Log automatically","text":"<p>By default, Comet will log the following items</p>"},{"location":"yolov5/tutorials/comet_logging_integration/#metrics","title":"Metrics","text":"<ul> <li>Box Loss, Object Loss, Classification Loss for the training and validation data</li> <li>mAP_0.5, mAP_0.5:0.95 metrics for the validation data.</li> <li>Precision and Recall for the validation data</li> </ul>"},{"location":"yolov5/tutorials/comet_logging_integration/#parameters","title":"Parameters","text":"<ul> <li>Model Hyperparameters</li> <li>All parameters passed through the command line options</li> </ul>"},{"location":"yolov5/tutorials/comet_logging_integration/#visualizations","title":"Visualizations","text":"<ul> <li>Confusion Matrix of the model predictions on the validation data</li> <li>Plots for the PR and F1 curves across all classes</li> <li>Correlogram of the Class Labels</li> </ul>"},{"location":"yolov5/tutorials/comet_logging_integration/#configure-comet-logging","title":"Configure Comet Logging","text":"<p>Comet can be configured to log additional data either through command line flags passed to the training script or through environment variables.</p> <pre><code>export COMET_MODE=online # Set whether to run Comet in 'online' or 'offline' mode. Defaults to online\nexport COMET_MODEL_NAME=&lt;your model name&gt; #Set the name for the saved model. Defaults to yolov5\nexport COMET_LOG_CONFUSION_MATRIX=false # Set to disable logging a Comet Confusion Matrix. Defaults to true\nexport COMET_MAX_IMAGE_UPLOADS=&lt;number of allowed images to upload to Comet&gt; # Controls how many total image predictions to log to Comet. Defaults to 100.\nexport COMET_LOG_PER_CLASS_METRICS=true # Set to log evaluation metrics for each detected class at the end of training. Defaults to false\nexport COMET_DEFAULT_CHECKPOINT_FILENAME=&lt;your checkpoint filename&gt; # Set this if you would like to resume training from a different checkpoint. Defaults to 'last.pt'\nexport COMET_LOG_BATCH_LEVEL_METRICS=true # Set this if you would like to log training metrics at the batch level. Defaults to false.\nexport COMET_LOG_PREDICTIONS=true # Set this to false to disable logging model predictions\n</code></pre>"},{"location":"yolov5/tutorials/comet_logging_integration/#logging-checkpoints-with-comet","title":"Logging Checkpoints with Comet","text":"<p>Logging Models to Comet is disabled by default. To enable it, pass the <code>save-period</code> argument to the training script. This will save the logged checkpoints to Comet based on the interval value provided by <code>save-period</code></p> <pre><code>python train.py \\\n--img 640 \\\n--batch 16 \\\n--epochs 5 \\\n--data coco128.yaml \\\n--weights yolov5s.pt \\\n--save-period 1\n</code></pre>"},{"location":"yolov5/tutorials/comet_logging_integration/#logging-model-predictions","title":"Logging Model Predictions","text":"<p>By default, model predictions (images, ground truth labels and bounding boxes) will be logged to Comet.</p> <p>You can control the frequency of logged predictions and the associated images by passing the <code>bbox_interval</code> command line argument. Predictions can be visualized using Comet's Object Detection Custom Panel. This frequency corresponds to every Nth batch of data per epoch. In the example below, we are logging every 2nd batch of data for each epoch.</p> <p>Note: The YOLOv5 validation dataloader will default to a batch size of 32, so you will have to set the logging frequency accordingly.</p> <p>Here is an example project using the Panel</p> <pre><code>python train.py \\\n--img 640 \\\n--batch 16 \\\n--epochs 5 \\\n--data coco128.yaml \\\n--weights yolov5s.pt \\\n--bbox_interval 2\n</code></pre>"},{"location":"yolov5/tutorials/comet_logging_integration/#controlling-the-number-of-prediction-images-logged-to-comet","title":"Controlling the number of Prediction Images logged to Comet","text":"<p>When logging predictions from YOLOv5, Comet will log the images associated with each set of predictions. By default a maximum of 100 validation images are logged. You can increase or decrease this number using the <code>COMET_MAX_IMAGE_UPLOADS</code> environment variable.</p> <pre><code>env COMET_MAX_IMAGE_UPLOADS=200 python train.py \\\n--img 640 \\\n--batch 16 \\\n--epochs 5 \\\n--data coco128.yaml \\\n--weights yolov5s.pt \\\n--bbox_interval 1\n</code></pre>"},{"location":"yolov5/tutorials/comet_logging_integration/#logging-class-level-metrics","title":"Logging Class Level Metrics","text":"<p>Use the <code>COMET_LOG_PER_CLASS_METRICS</code> environment variable to log mAP, precision, recall, f1 for each class.</p> <pre><code>env COMET_LOG_PER_CLASS_METRICS=true python train.py \\\n--img 640 \\\n--batch 16 \\\n--epochs 5 \\\n--data coco128.yaml \\\n--weights yolov5s.pt\n</code></pre>"},{"location":"yolov5/tutorials/comet_logging_integration/#uploading-a-dataset-to-comet-artifacts","title":"Uploading a Dataset to Comet Artifacts","text":"<p>If you would like to store your data using Comet Artifacts, you can do so using the <code>upload_dataset</code> flag.</p> <p>The dataset be organized in the way described in the YOLOv5 documentation. The dataset config <code>yaml</code> file must follow the same format as that of the <code>coco128.yaml</code> file.</p> <pre><code>python train.py \\\n--img 640 \\\n--batch 16 \\\n--epochs 5 \\\n--data coco128.yaml \\\n--weights yolov5s.pt \\\n--upload_dataset\n</code></pre> <p>You can find the uploaded dataset in the Artifacts tab in your Comet Workspace </p> <p>You can preview the data directly in the Comet UI. </p> <p>Artifacts are versioned and also support adding metadata about the dataset. Comet will automatically log the metadata from your dataset <code>yaml</code> file </p>"},{"location":"yolov5/tutorials/comet_logging_integration/#using-a-saved-artifact","title":"Using a saved Artifact","text":"<p>If you would like to use a dataset from Comet Artifacts, set the <code>path</code> variable in your dataset <code>yaml</code> file to point to the following Artifact resource URL.</p> <pre><code># contents of artifact.yaml file\npath: \"comet://&lt;workspace name&gt;/&lt;artifact name&gt;:&lt;artifact version or alias&gt;\"\n</code></pre> <p>Then pass this file to your training script in the following way</p> <pre><code>python train.py \\\n--img 640 \\\n--batch 16 \\\n--epochs 5 \\\n--data artifact.yaml \\\n--weights yolov5s.pt\n</code></pre> <p>Artifacts also allow you to track the lineage of data as it flows through your Experimentation workflow. Here you can see a graph that shows you all the experiments that have used your uploaded dataset. </p>"},{"location":"yolov5/tutorials/comet_logging_integration/#resuming-a-training-run","title":"Resuming a Training Run","text":"<p>If your training run is interrupted for any reason, e.g. disrupted internet connection, you can resume the run using the <code>resume</code> flag and the Comet Run Path.</p> <p>The Run Path has the following format <code>comet://&lt;your workspace name&gt;/&lt;your project name&gt;/&lt;experiment id&gt;</code>.</p> <p>This will restore the run to its state before the interruption, which includes restoring the model from a checkpoint, restoring all hyperparameters and training arguments and downloading Comet dataset Artifacts if they were used in the original run. The resumed run will continue logging to the existing Experiment in the Comet UI</p> <pre><code>python train.py \\\n--resume \"comet://&lt;your run path&gt;\"\n</code></pre>"},{"location":"yolov5/tutorials/comet_logging_integration/#hyperparameter-search-with-the-comet-optimizer","title":"Hyperparameter Search with the Comet Optimizer","text":"<p>YOLOv5 is also integrated with Comet's Optimizer, making is simple to visualize hyperparameter sweeps in the Comet UI.</p>"},{"location":"yolov5/tutorials/comet_logging_integration/#configuring-an-optimizer-sweep","title":"Configuring an Optimizer Sweep","text":"<p>To configure the Comet Optimizer, you will have to create a JSON file with the information about the sweep. An example file has been provided in <code>utils/loggers/comet/optimizer_config.json</code></p> <pre><code>python utils/loggers/comet/hpo.py \\\n  --comet_optimizer_config \"utils/loggers/comet/optimizer_config.json\"\n</code></pre> <p>The <code>hpo.py</code> script accepts the same arguments as <code>train.py</code>. If you wish to pass additional arguments to your sweep simply add them after the script.</p> <pre><code>python utils/loggers/comet/hpo.py \\\n  --comet_optimizer_config \"utils/loggers/comet/optimizer_config.json\" \\\n  --save-period 1 \\\n  --bbox_interval 1\n</code></pre>"},{"location":"yolov5/tutorials/comet_logging_integration/#running-a-sweep-in-parallel","title":"Running a Sweep in Parallel","text":"<pre><code>comet optimizer -j &lt;set number of workers&gt; utils/loggers/comet/hpo.py \\\n  utils/loggers/comet/optimizer_config.json\"\n</code></pre>"},{"location":"yolov5/tutorials/comet_logging_integration/#visualizing-results","title":"Visualizing Results","text":"<p>Comet provides a number of ways to visualize the results of your sweep. Take a look at a project with a completed sweep here</p> <p></p>"},{"location":"yolov5/tutorials/hyperparameter_evolution/","title":"Hyperparameter evolution","text":"<p>\ud83d\udcda This guide explains hyperparameter evolution for YOLOv5 \ud83d\ude80. Hyperparameter evolution is a method of Hyperparameter Optimization using a Genetic Algorithm (GA) for optimization.</p> <p>Hyperparameters in ML control various aspects of training, and finding optimal values for them can be a challenge. Traditional methods like grid searches can quickly become intractable due to 1) the high dimensional search space 2) unknown correlations among the dimensions, and 3) expensive nature of evaluating the fitness at each point, making GA a suitable candidate for hyperparameter searches.</p>"},{"location":"yolov5/tutorials/hyperparameter_evolution/#before-you-start","title":"Before You Start","text":"<p>Clone repo and install requirements.txt in a Python&gt;=3.8.0 environment, including PyTorch&gt;=1.8. Models and datasets download automatically from the latest YOLOv5 release.</p> <pre><code>git clone https://github.com/ultralytics/yolov5  # clone\ncd yolov5\npip install -r requirements.txt  # install\n</code></pre>"},{"location":"yolov5/tutorials/hyperparameter_evolution/#1-initialize-hyperparameters","title":"1. Initialize Hyperparameters","text":"<p>YOLOv5 has about 30 hyperparameters used for various training settings. These are defined in <code>*.yaml</code> files in the <code>/data/hyps</code> directory. Better initial guesses will produce better final results, so it is important to initialize these values properly before evolving. If in doubt, simply use the default values, which are optimized for YOLOv5 COCO training from scratch.</p> <pre><code># YOLOv5 \ud83d\ude80 by Ultralytics, AGPL-3.0 license\n# Hyperparameters for low-augmentation COCO training from scratch\n# python train.py --batch 64 --cfg yolov5n6.yaml --weights '' --data coco.yaml --img 640 --epochs 300 --linear\n# See tutorials for hyperparameter evolution https://github.com/ultralytics/yolov5#tutorials\n\nlr0: 0.01  # initial learning rate (SGD=1E-2, Adam=1E-3)\nlrf: 0.01  # final OneCycleLR learning rate (lr0 * lrf)\nmomentum: 0.937  # SGD momentum/Adam beta1\nweight_decay: 0.0005  # optimizer weight decay 5e-4\nwarmup_epochs: 3.0  # warmup epochs (fractions ok)\nwarmup_momentum: 0.8  # warmup initial momentum\nwarmup_bias_lr: 0.1  # warmup initial bias lr\nbox: 0.05  # box loss gain\ncls: 0.5  # cls loss gain\ncls_pw: 1.0  # cls BCELoss positive_weight\nobj: 1.0  # obj loss gain (scale with pixels)\nobj_pw: 1.0  # obj BCELoss positive_weight\niou_t: 0.20  # IoU training threshold\nanchor_t: 4.0  # anchor-multiple threshold\n# anchors: 3  # anchors per output layer (0 to ignore)\nfl_gamma: 0.0  # focal loss gamma (efficientDet default gamma=1.5)\nhsv_h: 0.015  # image HSV-Hue augmentation (fraction)\nhsv_s: 0.7  # image HSV-Saturation augmentation (fraction)\nhsv_v: 0.4  # image HSV-Value augmentation (fraction)\ndegrees: 0.0  # image rotation (+/- deg)\ntranslate: 0.1  # image translation (+/- fraction)\nscale: 0.5  # image scale (+/- gain)\nshear: 0.0  # image shear (+/- deg)\nperspective: 0.0  # image perspective (+/- fraction), range 0-0.001\nflipud: 0.0  # image flip up-down (probability)\nfliplr: 0.5  # image flip left-right (probability)\nmosaic: 1.0  # image mosaic (probability)\nmixup: 0.0  # image mixup (probability)\ncopy_paste: 0.0  # segment copy-paste (probability)\n</code></pre>"},{"location":"yolov5/tutorials/hyperparameter_evolution/#2-define-fitness","title":"2. Define Fitness","text":"<p>Fitness is the value we seek to maximize. In YOLOv5 we define a default fitness function as a weighted combination of metrics: <code>mAP@0.5</code> contributes 10% of the weight and <code>mAP@0.5:0.95</code> contributes the remaining 90%, with Precision <code>P</code> and Recall <code>R</code> absent. You may adjust these as you see fit or use the default fitness definition in utils/metrics.py (recommended).</p> <pre><code>def fitness(x):\n    # Model fitness as a weighted combination of metrics\n    w = [0.0, 0.0, 0.1, 0.9]  # weights for [P, R, mAP@0.5, mAP@0.5:0.95]\n    return (x[:, :4] * w).sum(1)\n</code></pre>"},{"location":"yolov5/tutorials/hyperparameter_evolution/#3-evolve","title":"3. Evolve","text":"<p>Evolution is performed about a base scenario which we seek to improve upon. The base scenario in this example is finetuning COCO128 for 10 epochs using pretrained YOLOv5s. The base scenario training command is:</p> <pre><code>python train.py --epochs 10 --data coco128.yaml --weights yolov5s.pt --cache\n</code></pre> <p>To evolve hyperparameters specific to this scenario, starting from our initial values defined in Section 1., and maximizing the fitness defined in Section 2., append <code>--evolve</code>:</p> <pre><code># Single-GPU\npython train.py --epochs 10 --data coco128.yaml --weights yolov5s.pt --cache --evolve\n\n# Multi-GPU\nfor i in 0 1 2 3 4 5 6 7; do\n  sleep $(expr 30 \\* $i) &amp;&amp;  # 30-second delay (optional)\n  echo 'Starting GPU '$i'...' &amp;&amp;\n  nohup python train.py --epochs 10 --data coco128.yaml --weights yolov5s.pt --cache --device $i --evolve &gt; evolve_gpu_$i.log &amp;\ndone\n\n# Multi-GPU bash-while (not recommended)\nfor i in 0 1 2 3 4 5 6 7; do\n  sleep $(expr 30 \\* $i) &amp;&amp;  # 30-second delay (optional)\n  echo 'Starting GPU '$i'...' &amp;&amp;\n  \"$(while true; do nohup python train.py... --device $i --evolve 1 &gt; evolve_gpu_$i.log; done)\" &amp;\ndone\n</code></pre> <p>The default evolution settings will run the base scenario 300 times, i.e. for 300 generations. You can modify generations via the <code>--evolve</code> argument, i.e. <code>python train.py --evolve 1000</code>.</p> <p>The main genetic operators are crossover and mutation. In this work mutation is used, with an 80% probability and a 0.04 variance to create new offspring based on a combination of the best parents from all previous generations. Results are logged to <code>runs/evolve/exp/evolve.csv</code>, and the highest fitness offspring is saved every generation as <code>runs/evolve/hyp_evolved.yaml</code>:</p> <pre><code># YOLOv5 Hyperparameter Evolution Results\n# Best generation: 287\n# Last generation: 300\n#    metrics/precision,       metrics/recall,      metrics/mAP_0.5, metrics/mAP_0.5:0.95,         val/box_loss,         val/obj_loss,         val/cls_loss\n#              0.54634,              0.55625,              0.58201,              0.33665,             0.056451,             0.042892,             0.013441\n\nlr0: 0.01  # initial learning rate (SGD=1E-2, Adam=1E-3)\nlrf: 0.2  # final OneCycleLR learning rate (lr0 * lrf)\nmomentum: 0.937  # SGD momentum/Adam beta1\nweight_decay: 0.0005  # optimizer weight decay 5e-4\nwarmup_epochs: 3.0  # warmup epochs (fractions ok)\nwarmup_momentum: 0.8  # warmup initial momentum\nwarmup_bias_lr: 0.1  # warmup initial bias lr\nbox: 0.05  # box loss gain\ncls: 0.5  # cls loss gain\ncls_pw: 1.0  # cls BCELoss positive_weight\nobj: 1.0  # obj loss gain (scale with pixels)\nobj_pw: 1.0  # obj BCELoss positive_weight\niou_t: 0.20  # IoU training threshold\nanchor_t: 4.0  # anchor-multiple threshold\n# anchors: 3  # anchors per output layer (0 to ignore)\nfl_gamma: 0.0  # focal loss gamma (efficientDet default gamma=1.5)\nhsv_h: 0.015  # image HSV-Hue augmentation (fraction)\nhsv_s: 0.7  # image HSV-Saturation augmentation (fraction)\nhsv_v: 0.4  # image HSV-Value augmentation (fraction)\ndegrees: 0.0  # image rotation (+/- deg)\ntranslate: 0.1  # image translation (+/- fraction)\nscale: 0.5  # image scale (+/- gain)\nshear: 0.0  # image shear (+/- deg)\nperspective: 0.0  # image perspective (+/- fraction), range 0-0.001\nflipud: 0.0  # image flip up-down (probability)\nfliplr: 0.5  # image flip left-right (probability)\nmosaic: 1.0  # image mosaic (probability)\nmixup: 0.0  # image mixup (probability)\ncopy_paste: 0.0  # segment copy-paste (probability)\n</code></pre> <p>We recommend a minimum of 300 generations of evolution for best results. Note that evolution is generally expensive and time-consuming, as the base scenario is trained hundreds of times, possibly requiring hundreds or thousands of GPU hours.</p>"},{"location":"yolov5/tutorials/hyperparameter_evolution/#4-visualize","title":"4. Visualize","text":"<p><code>evolve.csv</code> is plotted as <code>evolve.png</code> by <code>utils.plots.plot_evolve()</code> after evolution finishes with one subplot per hyperparameter showing fitness (y-axis) vs hyperparameter values (x-axis). Yellow indicates higher concentrations. Vertical distributions indicate that a parameter has been disabled and does not mutate. This is user selectable in the <code>meta</code> dictionary in train.py, and is useful for fixing parameters and preventing them from evolving.</p> <p></p>"},{"location":"yolov5/tutorials/hyperparameter_evolution/#supported-environments","title":"Supported Environments","text":"<p>Ultralytics provides a range of ready-to-use environments, each pre-installed with essential dependencies such as CUDA, CUDNN, Python, and PyTorch, to kickstart your projects.</p> <ul> <li>Free GPU Notebooks:  </li> <li>Google Cloud: GCP Quickstart Guide</li> <li>Amazon: AWS Quickstart Guide</li> <li>Azure: AzureML Quickstart Guide</li> <li>Docker: Docker Quickstart Guide </li> </ul>"},{"location":"yolov5/tutorials/hyperparameter_evolution/#project-status","title":"Project Status","text":"<p>This badge indicates that all YOLOv5 GitHub Actions Continuous Integration (CI) tests are successfully passing. These CI tests rigorously check the functionality and performance of YOLOv5 across various key aspects: training, validation, inference, export, and benchmarks. They ensure consistent and reliable operation on macOS, Windows, and Ubuntu, with tests conducted every 24 hours and upon each new commit.</p>"},{"location":"yolov5/tutorials/model_ensembling/","title":"Model Ensembling","text":"<p>\ud83d\udcda This guide explains how to use YOLOv5 \ud83d\ude80 model ensembling during testing and inference for improved mAP and Recall.</p> <p>From https://en.wikipedia.org/wiki/Ensemble_learning:</p> <p>Ensemble modeling is a process where multiple diverse models are created to predict an outcome, either by using many different modeling algorithms or using different training data sets. The ensemble model then aggregates the prediction of each base model and results in once final prediction for the unseen data. The motivation for using ensemble models is to reduce the generalization error of the prediction. As long as the base models are diverse and independent, the prediction error of the model decreases when the ensemble approach is used. The approach seeks the wisdom of crowds in making a prediction. Even though the ensemble model has multiple base models within the model, it acts and performs as a single model.</p>"},{"location":"yolov5/tutorials/model_ensembling/#before-you-start","title":"Before You Start","text":"<p>Clone repo and install requirements.txt in a Python&gt;=3.8.0 environment, including PyTorch&gt;=1.8. Models and datasets download automatically from the latest YOLOv5 release.</p> <pre><code>git clone https://github.com/ultralytics/yolov5  # clone\ncd yolov5\npip install -r requirements.txt  # install\n</code></pre>"},{"location":"yolov5/tutorials/model_ensembling/#test-normally","title":"Test Normally","text":"<p>Before ensembling we want to establish the baseline performance of a single model. This command tests YOLOv5x on COCO val2017 at image size 640 pixels. <code>yolov5x.pt</code> is the largest and most accurate model available. Other options are <code>yolov5s.pt</code>, <code>yolov5m.pt</code> and <code>yolov5l.pt</code>, or you own checkpoint from training a custom dataset <code>./weights/best.pt</code>. For details on all available models please see our README table.</p> <pre><code>python val.py --weights yolov5x.pt --data coco.yaml --img 640 --half\n</code></pre> <p>Output:</p> <pre><code>val: data=./data/coco.yaml, weights=['yolov5x.pt'], batch_size=32, imgsz=640, conf_thres=0.001, iou_thres=0.65, task=val, device=, single_cls=False, augment=False, verbose=False, save_txt=False, save_hybrid=False, save_conf=False, save_json=True, project=runs/val, name=exp, exist_ok=False, half=True\nYOLOv5 \ud83d\ude80 v5.0-267-g6a3ee7c torch 1.9.0+cu102 CUDA:0 (Tesla P100-PCIE-16GB, 16280.875MB)\n\nFusing layers...\nModel Summary: 476 layers, 87730285 parameters, 0 gradients\n\nval: Scanning '../datasets/coco/val2017' images and labels...4952 found, 48 missing, 0 empty, 0 corrupted: 100% 5000/5000 [00:01&lt;00:00, 2846.03it/s]\nval: New cache created: ../datasets/coco/val2017.cache\n               Class     Images     Labels          P          R     mAP@.5 mAP@.5:.95: 100% 157/157 [02:30&lt;00:00,  1.05it/s]\n                 all       5000      36335      0.746      0.626       0.68       0.49\nSpeed: 0.1ms pre-process, 22.4ms inference, 1.4ms NMS per image at shape (32, 3, 640, 640)  # &lt;--- baseline speed\n\nEvaluating pycocotools mAP... saving runs/val/exp/yolov5x_predictions.json...\n...\n Average Precision  (AP) @[ IoU=0.50:0.95 | area=   all | maxDets=100 ] = 0.504  # &lt;--- baseline mAP\n Average Precision  (AP) @[ IoU=0.50      | area=   all | maxDets=100 ] = 0.688\n Average Precision  (AP) @[ IoU=0.75      | area=   all | maxDets=100 ] = 0.546\n Average Precision  (AP) @[ IoU=0.50:0.95 | area= small | maxDets=100 ] = 0.351\n Average Precision  (AP) @[ IoU=0.50:0.95 | area=medium | maxDets=100 ] = 0.551\n Average Precision  (AP) @[ IoU=0.50:0.95 | area= large | maxDets=100 ] = 0.644\n Average Recall     (AR) @[ IoU=0.50:0.95 | area=   all | maxDets=  1 ] = 0.382\n Average Recall     (AR) @[ IoU=0.50:0.95 | area=   all | maxDets= 10 ] = 0.628\n Average Recall     (AR) @[ IoU=0.50:0.95 | area=   all | maxDets=100 ] = 0.681  # &lt;--- baseline mAR\n Average Recall     (AR) @[ IoU=0.50:0.95 | area= small | maxDets=100 ] = 0.524\n Average Recall     (AR) @[ IoU=0.50:0.95 | area=medium | maxDets=100 ] = 0.735\n Average Recall     (AR) @[ IoU=0.50:0.95 | area= large | maxDets=100 ] = 0.826\n</code></pre>"},{"location":"yolov5/tutorials/model_ensembling/#ensemble-test","title":"Ensemble Test","text":"<p>Multiple pretrained models may be ensembled together at test and inference time by simply appending extra models to the <code>--weights</code> argument in any existing val.py or detect.py command. This example tests an ensemble of 2 models together:</p> <ul> <li>YOLOv5x</li> <li>YOLOv5l6</li> </ul> <pre><code>python val.py --weights yolov5x.pt yolov5l6.pt --data coco.yaml --img 640 --half\n</code></pre> <p>Output:</p> <pre><code>val: data=./data/coco.yaml, weights=['yolov5x.pt', 'yolov5l6.pt'], batch_size=32, imgsz=640, conf_thres=0.001, iou_thres=0.6, task=val, device=, single_cls=False, augment=False, verbose=False, save_txt=False, save_hybrid=False, save_conf=False, save_json=True, project=runs/val, name=exp, exist_ok=False, half=True\nYOLOv5 \ud83d\ude80 v5.0-267-g6a3ee7c torch 1.9.0+cu102 CUDA:0 (Tesla P100-PCIE-16GB, 16280.875MB)\n\nFusing layers...\nModel Summary: 476 layers, 87730285 parameters, 0 gradients  # Model 1\nFusing layers...\nModel Summary: 501 layers, 77218620 parameters, 0 gradients  # Model 2\nEnsemble created with ['yolov5x.pt', 'yolov5l6.pt']  # Ensemble notice\n\nval: Scanning '../datasets/coco/val2017.cache' images and labels... 4952 found, 48 missing, 0 empty, 0 corrupted: 100% 5000/5000 [00:00&lt;00:00, 49695545.02it/s]\n               Class     Images     Labels          P          R     mAP@.5 mAP@.5:.95: 100% 157/157 [03:58&lt;00:00,  1.52s/it]\n                 all       5000      36335      0.747      0.637      0.692      0.502\nSpeed: 0.1ms pre-process, 39.5ms inference, 2.0ms NMS per image at shape (32, 3, 640, 640)  # &lt;--- ensemble speed\n\nEvaluating pycocotools mAP... saving runs/val/exp3/yolov5x_predictions.json...\n...\n Average Precision  (AP) @[ IoU=0.50:0.95 | area=   all | maxDets=100 ] = 0.515  # &lt;--- ensemble mAP\n Average Precision  (AP) @[ IoU=0.50      | area=   all | maxDets=100 ] = 0.699\n Average Precision  (AP) @[ IoU=0.75      | area=   all | maxDets=100 ] = 0.557\n Average Precision  (AP) @[ IoU=0.50:0.95 | area= small | maxDets=100 ] = 0.356\n Average Precision  (AP) @[ IoU=0.50:0.95 | area=medium | maxDets=100 ] = 0.563\n Average Precision  (AP) @[ IoU=0.50:0.95 | area= large | maxDets=100 ] = 0.668\n Average Recall     (AR) @[ IoU=0.50:0.95 | area=   all | maxDets=  1 ] = 0.387\n Average Recall     (AR) @[ IoU=0.50:0.95 | area=   all | maxDets= 10 ] = 0.638\n Average Recall     (AR) @[ IoU=0.50:0.95 | area=   all | maxDets=100 ] = 0.689  # &lt;--- ensemble mAR\n Average Recall     (AR) @[ IoU=0.50:0.95 | area= small | maxDets=100 ] = 0.526\n Average Recall     (AR) @[ IoU=0.50:0.95 | area=medium | maxDets=100 ] = 0.743\n Average Recall     (AR) @[ IoU=0.50:0.95 | area= large | maxDets=100 ] = 0.844\n</code></pre>"},{"location":"yolov5/tutorials/model_ensembling/#ensemble-inference","title":"Ensemble Inference","text":"<p>Append extra models to the <code>--weights</code> argument to run ensemble inference:</p> <pre><code>python detect.py --weights yolov5x.pt yolov5l6.pt --img 640 --source data/images\n</code></pre> <p>Output:</p> <pre><code>YOLOv5 \ud83d\ude80 v5.0-267-g6a3ee7c torch 1.9.0+cu102 CUDA:0 (Tesla P100-PCIE-16GB, 16280.875MB)\n\nFusing layers...\nModel Summary: 476 layers, 87730285 parameters, 0 gradients\nFusing layers...\nModel Summary: 501 layers, 77218620 parameters, 0 gradients\nEnsemble created with ['yolov5x.pt', 'yolov5l6.pt']\n\nimage 1/2 /content/yolov5/data/images/bus.jpg: 640x512 4 persons, 1 bus, 1 tie, Done. (0.063s)\nimage 2/2 /content/yolov5/data/images/zidane.jpg: 384x640 3 persons, 2 ties, Done. (0.056s)\nResults saved to runs/detect/exp2\nDone. (0.223s)\n</code></pre> <p></p>"},{"location":"yolov5/tutorials/model_ensembling/#supported-environments","title":"Supported Environments","text":"<p>Ultralytics provides a range of ready-to-use environments, each pre-installed with essential dependencies such as CUDA, CUDNN, Python, and PyTorch, to kickstart your projects.</p> <ul> <li>Free GPU Notebooks:  </li> <li>Google Cloud: GCP Quickstart Guide</li> <li>Amazon: AWS Quickstart Guide</li> <li>Azure: AzureML Quickstart Guide</li> <li>Docker: Docker Quickstart Guide </li> </ul>"},{"location":"yolov5/tutorials/model_ensembling/#project-status","title":"Project Status","text":"<p>This badge indicates that all YOLOv5 GitHub Actions Continuous Integration (CI) tests are successfully passing. These CI tests rigorously check the functionality and performance of YOLOv5 across various key aspects: training, validation, inference, export, and benchmarks. They ensure consistent and reliable operation on macOS, Windows, and Ubuntu, with tests conducted every 24 hours and upon each new commit.</p>"},{"location":"yolov5/tutorials/model_export/","title":"TFLite, ONNX, CoreML, TensorRT Export","text":"<p>\ud83d\udcda This guide explains how to export a trained YOLOv5 \ud83d\ude80 model from PyTorch to ONNX and TorchScript formats.</p>"},{"location":"yolov5/tutorials/model_export/#before-you-start","title":"Before You Start","text":"<p>Clone repo and install requirements.txt in a Python&gt;=3.8.0 environment, including PyTorch&gt;=1.8. Models and datasets download automatically from the latest YOLOv5 release.</p> <pre><code>git clone https://github.com/ultralytics/yolov5  # clone\ncd yolov5\npip install -r requirements.txt  # install\n</code></pre> <p>For TensorRT export example (requires GPU) see our Colab notebook appendix section. </p>"},{"location":"yolov5/tutorials/model_export/#formats","title":"Formats","text":"<p>YOLOv5 inference is officially supported in 11 formats:</p> <p>\ud83d\udca1 ProTip: Export to ONNX or OpenVINO for up to 3x CPU speedup. See CPU Benchmarks. \ud83d\udca1 ProTip: Export to TensorRT for up to 5x GPU speedup. See GPU Benchmarks.</p> Format <code>export.py --include</code> Model PyTorch - <code>yolov5s.pt</code> TorchScript <code>torchscript</code> <code>yolov5s.torchscript</code> ONNX <code>onnx</code> <code>yolov5s.onnx</code> OpenVINO <code>openvino</code> <code>yolov5s_openvino_model/</code> TensorRT <code>engine</code> <code>yolov5s.engine</code> CoreML <code>coreml</code> <code>yolov5s.mlmodel</code> TensorFlow SavedModel <code>saved_model</code> <code>yolov5s_saved_model/</code> TensorFlow GraphDef <code>pb</code> <code>yolov5s.pb</code> TensorFlow Lite <code>tflite</code> <code>yolov5s.tflite</code> TensorFlow Edge TPU <code>edgetpu</code> <code>yolov5s_edgetpu.tflite</code> TensorFlow.js <code>tfjs</code> <code>yolov5s_web_model/</code> PaddlePaddle <code>paddle</code> <code>yolov5s_paddle_model/</code>"},{"location":"yolov5/tutorials/model_export/#benchmarks","title":"Benchmarks","text":"<p>Benchmarks below run on a Colab Pro with the YOLOv5 tutorial notebook . To reproduce:</p> <pre><code>python benchmarks.py --weights yolov5s.pt --imgsz 640 --device 0\n</code></pre>"},{"location":"yolov5/tutorials/model_export/#colab-pro-v100-gpu","title":"Colab Pro V100 GPU","text":"<pre><code>benchmarks: weights=/content/yolov5/yolov5s.pt, imgsz=640, batch_size=1, data=/content/yolov5/data/coco128.yaml, device=0, half=False, test=False\nChecking setup...\nYOLOv5 \ud83d\ude80 v6.1-135-g7926afc torch 1.10.0+cu111 CUDA:0 (Tesla V100-SXM2-16GB, 16160MiB)\nSetup complete \u2705 (8 CPUs, 51.0 GB RAM, 46.7/166.8 GB disk)\n\nBenchmarks complete (458.07s)\n                   Format  mAP@0.5:0.95  Inference time (ms)\n0                 PyTorch        0.4623                10.19\n1             TorchScript        0.4623                 6.85\n2                    ONNX        0.4623                14.63\n3                OpenVINO           NaN                  NaN\n4                TensorRT        0.4617                 1.89\n5                  CoreML           NaN                  NaN\n6   TensorFlow SavedModel        0.4623                21.28\n7     TensorFlow GraphDef        0.4623                21.22\n8         TensorFlow Lite           NaN                  NaN\n9     TensorFlow Edge TPU           NaN                  NaN\n10          TensorFlow.js           NaN                  NaN\n</code></pre>"},{"location":"yolov5/tutorials/model_export/#colab-pro-cpu","title":"Colab Pro CPU","text":"<pre><code>benchmarks: weights=/content/yolov5/yolov5s.pt, imgsz=640, batch_size=1, data=/content/yolov5/data/coco128.yaml, device=cpu, half=False, test=False\nChecking setup...\nYOLOv5 \ud83d\ude80 v6.1-135-g7926afc torch 1.10.0+cu111 CPU\nSetup complete \u2705 (8 CPUs, 51.0 GB RAM, 41.5/166.8 GB disk)\n\nBenchmarks complete (241.20s)\n                   Format  mAP@0.5:0.95  Inference time (ms)\n0                 PyTorch        0.4623               127.61\n1             TorchScript        0.4623               131.23\n2                    ONNX        0.4623                69.34\n3                OpenVINO        0.4623                66.52\n4                TensorRT           NaN                  NaN\n5                  CoreML           NaN                  NaN\n6   TensorFlow SavedModel        0.4623               123.79\n7     TensorFlow GraphDef        0.4623               121.57\n8         TensorFlow Lite        0.4623               316.61\n9     TensorFlow Edge TPU           NaN                  NaN\n10          TensorFlow.js           NaN                  NaN\n</code></pre>"},{"location":"yolov5/tutorials/model_export/#export-a-trained-yolov5-model","title":"Export a Trained YOLOv5 Model","text":"<p>This command exports a pretrained YOLOv5s model to TorchScript and ONNX formats. <code>yolov5s.pt</code> is the 'small' model, the second-smallest model available. Other options are <code>yolov5n.pt</code>, <code>yolov5m.pt</code>, <code>yolov5l.pt</code> and <code>yolov5x.pt</code>, along with their P6 counterparts i.e. <code>yolov5s6.pt</code> or you own custom training checkpoint i.e. <code>runs/exp/weights/best.pt</code>. For details on all available models please see our README table.</p> <pre><code>python export.py --weights yolov5s.pt --include torchscript onnx\n</code></pre> <p>\ud83d\udca1 ProTip: Add <code>--half</code> to export models at FP16 half precision for smaller file sizes</p> <p>Output:</p> <pre><code>export: data=data/coco128.yaml, weights=['yolov5s.pt'], imgsz=[640, 640], batch_size=1, device=cpu, half=False, inplace=False, train=False, keras=False, optimize=False, int8=False, dynamic=False, simplify=False, opset=12, verbose=False, workspace=4, nms=False, agnostic_nms=False, topk_per_class=100, topk_all=100, iou_thres=0.45, conf_thres=0.25, include=['torchscript', 'onnx']\nYOLOv5 \ud83d\ude80 v6.2-104-ge3e5122 Python-3.8.0 torch-1.12.1+cu113 CPU\n\nDownloading https://github.com/ultralytics/yolov5/releases/download/v6.2/yolov5s.pt to yolov5s.pt...\n100% 14.1M/14.1M [00:00&lt;00:00, 274MB/s]\n\nFusing layers...\nYOLOv5s summary: 213 layers, 7225885 parameters, 0 gradients\n\nPyTorch: starting from yolov5s.pt with output shape (1, 25200, 85) (14.1 MB)\n\nTorchScript: starting export with torch 1.12.1+cu113...\nTorchScript: export success \u2705 1.7s, saved as yolov5s.torchscript (28.1 MB)\n\nONNX: starting export with onnx 1.12.0...\nONNX: export success \u2705 2.3s, saved as yolov5s.onnx (28.0 MB)\n\nExport complete (5.5s)\nResults saved to /content/yolov5\nDetect:          python detect.py --weights yolov5s.onnx\nValidate:        python val.py --weights yolov5s.onnx\nPyTorch Hub:     model = torch.hub.load('ultralytics/yolov5', 'custom', 'yolov5s.onnx')\nVisualize:       https://netron.app/\n</code></pre> <p>The 3 exported models will be saved alongside the original PyTorch model:</p> <p></p> <p>Netron Viewer is recommended for visualizing exported models:</p> <p></p>"},{"location":"yolov5/tutorials/model_export/#exported-model-usage-examples","title":"Exported Model Usage Examples","text":"<p><code>detect.py</code> runs inference on exported models:</p> <pre><code>python detect.py --weights yolov5s.pt                 # PyTorch\n                           yolov5s.torchscript        # TorchScript\n                           yolov5s.onnx               # ONNX Runtime or OpenCV DNN with dnn=True\n                           yolov5s_openvino_model     # OpenVINO\n                           yolov5s.engine             # TensorRT\n                           yolov5s.mlmodel            # CoreML (macOS only)\n                           yolov5s_saved_model        # TensorFlow SavedModel\n                           yolov5s.pb                 # TensorFlow GraphDef\n                           yolov5s.tflite             # TensorFlow Lite\n                           yolov5s_edgetpu.tflite     # TensorFlow Edge TPU\n                           yolov5s_paddle_model       # PaddlePaddle\n</code></pre> <p><code>val.py</code> runs validation on exported models:</p> <pre><code>python val.py --weights yolov5s.pt                 # PyTorch\n                        yolov5s.torchscript        # TorchScript\n                        yolov5s.onnx               # ONNX Runtime or OpenCV DNN with dnn=True\n                        yolov5s_openvino_model     # OpenVINO\n                        yolov5s.engine             # TensorRT\n                        yolov5s.mlmodel            # CoreML (macOS Only)\n                        yolov5s_saved_model        # TensorFlow SavedModel\n                        yolov5s.pb                 # TensorFlow GraphDef\n                        yolov5s.tflite             # TensorFlow Lite\n                        yolov5s_edgetpu.tflite     # TensorFlow Edge TPU\n                        yolov5s_paddle_model       # PaddlePaddle\n</code></pre> <p>Use PyTorch Hub with exported YOLOv5 models:</p> <pre><code>import torch\n\n# Model\nmodel = torch.hub.load('ultralytics/yolov5', 'custom', 'yolov5s.pt')\n                                                       'yolov5s.torchscript ')       # TorchScript\n                                                       'yolov5s.onnx')               # ONNX Runtime\n                                                       'yolov5s_openvino_model')     # OpenVINO\n                                                       'yolov5s.engine')             # TensorRT\n                                                       'yolov5s.mlmodel')            # CoreML (macOS Only)\n                                                       'yolov5s_saved_model')        # TensorFlow SavedModel\n                                                       'yolov5s.pb')                 # TensorFlow GraphDef\n                                                       'yolov5s.tflite')             # TensorFlow Lite\n                                                       'yolov5s_edgetpu.tflite')     # TensorFlow Edge TPU\n                                                       'yolov5s_paddle_model')       # PaddlePaddle\n\n# Images\nimg = 'https://ultralytics.com/images/zidane.jpg'  # or file, Path, PIL, OpenCV, numpy, list\n\n# Inference\nresults = model(img)\n\n# Results\nresults.print()  # or .show(), .save(), .crop(), .pandas(), etc.\n</code></pre>"},{"location":"yolov5/tutorials/model_export/#opencv-dnn-inference","title":"OpenCV DNN inference","text":"<p>OpenCV inference with ONNX models:</p> <pre><code>python export.py --weights yolov5s.pt --include onnx\n\npython detect.py --weights yolov5s.onnx --dnn  # detect\npython val.py --weights yolov5s.onnx --dnn  # validate\n</code></pre>"},{"location":"yolov5/tutorials/model_export/#c-inference","title":"C++ Inference","text":"<p>YOLOv5 OpenCV DNN C++ inference on exported ONNX model examples:</p> <ul> <li>https://github.com/Hexmagic/ONNX-yolov5/blob/master/src/test.cpp</li> <li>https://github.com/doleron/yolov5-opencv-cpp-python</li> </ul> <p>YOLOv5 OpenVINO C++ inference examples:</p> <ul> <li>https://github.com/dacquaviva/yolov5-openvino-cpp-python</li> <li>https://github.com/UNeedCryDear/yolov5-seg-opencv-dnn-cpp</li> </ul>"},{"location":"yolov5/tutorials/model_export/#tensorflowjs-web-browser-inference","title":"TensorFlow.js Web Browser Inference","text":"<ul> <li>https://aukerul-shuvo.github.io/YOLOv5_TensorFlow-JS/</li> </ul>"},{"location":"yolov5/tutorials/model_export/#supported-environments","title":"Supported Environments","text":"<p>Ultralytics provides a range of ready-to-use environments, each pre-installed with essential dependencies such as CUDA, CUDNN, Python, and PyTorch, to kickstart your projects.</p> <ul> <li>Free GPU Notebooks:  </li> <li>Google Cloud: GCP Quickstart Guide</li> <li>Amazon: AWS Quickstart Guide</li> <li>Azure: AzureML Quickstart Guide</li> <li>Docker: Docker Quickstart Guide </li> </ul>"},{"location":"yolov5/tutorials/model_export/#project-status","title":"Project Status","text":"<p>This badge indicates that all YOLOv5 GitHub Actions Continuous Integration (CI) tests are successfully passing. These CI tests rigorously check the functionality and performance of YOLOv5 across various key aspects: training, validation, inference, export, and benchmarks. They ensure consistent and reliable operation on macOS, Windows, and Ubuntu, with tests conducted every 24 hours and upon each new commit.</p>"},{"location":"yolov5/tutorials/model_pruning_and_sparsity/","title":"Pruning/Sparsity Tutorial","text":"<p>\ud83d\udcda This guide explains how to apply pruning to YOLOv5 \ud83d\ude80 models.</p>"},{"location":"yolov5/tutorials/model_pruning_and_sparsity/#before-you-start","title":"Before You Start","text":"<p>Clone repo and install requirements.txt in a Python&gt;=3.8.0 environment, including PyTorch&gt;=1.8. Models and datasets download automatically from the latest YOLOv5 release.</p> <pre><code>git clone https://github.com/ultralytics/yolov5  # clone\ncd yolov5\npip install -r requirements.txt  # install\n</code></pre>"},{"location":"yolov5/tutorials/model_pruning_and_sparsity/#test-normally","title":"Test Normally","text":"<p>Before pruning we want to establish a baseline performance to compare to. This command tests YOLOv5x on COCO val2017 at image size 640 pixels. <code>yolov5x.pt</code> is the largest and most accurate model available. Other options are <code>yolov5s.pt</code>, <code>yolov5m.pt</code> and <code>yolov5l.pt</code>, or you own checkpoint from training a custom dataset <code>./weights/best.pt</code>. For details on all available models please see our README table.</p> <pre><code>python val.py --weights yolov5x.pt --data coco.yaml --img 640 --half\n</code></pre> <p>Output:</p> <pre><code>val: data=/content/yolov5/data/coco.yaml, weights=['yolov5x.pt'], batch_size=32, imgsz=640, conf_thres=0.001, iou_thres=0.65, task=val, device=, workers=8, single_cls=False, augment=False, verbose=False, save_txt=False, save_hybrid=False, save_conf=False, save_json=True, project=runs/val, name=exp, exist_ok=False, half=True, dnn=False\nYOLOv5 \ud83d\ude80 v6.0-224-g4c40933 torch 1.10.0+cu111 CUDA:0 (Tesla V100-SXM2-16GB, 16160MiB)\n\nFusing layers...\nModel Summary: 444 layers, 86705005 parameters, 0 gradients\nval: Scanning '/content/datasets/coco/val2017.cache' images and labels... 4952 found, 48 missing, 0 empty, 0 corrupt: 100% 5000/5000 [00:00&lt;?, ?it/s]\n               Class     Images     Labels          P          R     mAP@.5 mAP@.5:.95: 100% 157/157 [01:12&lt;00:00,  2.16it/s]\n                 all       5000      36335      0.732      0.628      0.683      0.496\nSpeed: 0.1ms pre-process, 5.2ms inference, 1.7ms NMS per image at shape (32, 3, 640, 640)  # &lt;--- base speed\n\nEvaluating pycocotools mAP... saving runs/val/exp2/yolov5x_predictions.json...\n...\n Average Precision  (AP) @[ IoU=0.50:0.95 | area=   all | maxDets=100 ] = 0.507  # &lt;--- base mAP\n Average Precision  (AP) @[ IoU=0.50      | area=   all | maxDets=100 ] = 0.689\n Average Precision  (AP) @[ IoU=0.75      | area=   all | maxDets=100 ] = 0.552\n Average Precision  (AP) @[ IoU=0.50:0.95 | area= small | maxDets=100 ] = 0.345\n Average Precision  (AP) @[ IoU=0.50:0.95 | area=medium | maxDets=100 ] = 0.559\n Average Precision  (AP) @[ IoU=0.50:0.95 | area= large | maxDets=100 ] = 0.652\n Average Recall     (AR) @[ IoU=0.50:0.95 | area=   all | maxDets=  1 ] = 0.381\n Average Recall     (AR) @[ IoU=0.50:0.95 | area=   all | maxDets= 10 ] = 0.630\n Average Recall     (AR) @[ IoU=0.50:0.95 | area=   all | maxDets=100 ] = 0.682\n Average Recall     (AR) @[ IoU=0.50:0.95 | area= small | maxDets=100 ] = 0.526\n Average Recall     (AR) @[ IoU=0.50:0.95 | area=medium | maxDets=100 ] = 0.731\n Average Recall     (AR) @[ IoU=0.50:0.95 | area= large | maxDets=100 ] = 0.829\nResults saved to runs/val/exp\n</code></pre>"},{"location":"yolov5/tutorials/model_pruning_and_sparsity/#test-yolov5x-on-coco-030-sparsity","title":"Test YOLOv5x on COCO (0.30 sparsity)","text":"<p>We repeat the above test with a pruned model by using the <code>torch_utils.prune()</code> command. We update <code>val.py</code> to prune YOLOv5x to 0.3 sparsity:</p> <p></p> <p>30% pruned output:</p> <pre><code>val: data=/content/yolov5/data/coco.yaml, weights=['yolov5x.pt'], batch_size=32, imgsz=640, conf_thres=0.001, iou_thres=0.65, task=val, device=, workers=8, single_cls=False, augment=False, verbose=False, save_txt=False, save_hybrid=False, save_conf=False, save_json=True, project=runs/val, name=exp, exist_ok=False, half=True, dnn=False\nYOLOv5 \ud83d\ude80 v6.0-224-g4c40933 torch 1.10.0+cu111 CUDA:0 (Tesla V100-SXM2-16GB, 16160MiB)\n\nFusing layers...\nModel Summary: 444 layers, 86705005 parameters, 0 gradients\nPruning model...  0.3 global sparsity\nval: Scanning '/content/datasets/coco/val2017.cache' images and labels... 4952 found, 48 missing, 0 empty, 0 corrupt: 100% 5000/5000 [00:00&lt;?, ?it/s]\n               Class     Images     Labels          P          R     mAP@.5 mAP@.5:.95: 100% 157/157 [01:11&lt;00:00,  2.19it/s]\n                 all       5000      36335      0.724      0.614      0.671      0.478\nSpeed: 0.1ms pre-process, 5.2ms inference, 1.7ms NMS per image at shape (32, 3, 640, 640)  # &lt;--- prune mAP\n\nEvaluating pycocotools mAP... saving runs/val/exp3/yolov5x_predictions.json...\n...\n Average Precision  (AP) @[ IoU=0.50:0.95 | area=   all | maxDets=100 ] = 0.489  # &lt;--- prune mAP\n Average Precision  (AP) @[ IoU=0.50      | area=   all | maxDets=100 ] = 0.677\n Average Precision  (AP) @[ IoU=0.75      | area=   all | maxDets=100 ] = 0.537\n Average Precision  (AP) @[ IoU=0.50:0.95 | area= small | maxDets=100 ] = 0.334\n Average Precision  (AP) @[ IoU=0.50:0.95 | area=medium | maxDets=100 ] = 0.542\n Average Precision  (AP) @[ IoU=0.50:0.95 | area= large | maxDets=100 ] = 0.635\n Average Recall     (AR) @[ IoU=0.50:0.95 | area=   all | maxDets=  1 ] = 0.370\n Average Recall     (AR) @[ IoU=0.50:0.95 | area=   all | maxDets= 10 ] = 0.612\n Average Recall     (AR) @[ IoU=0.50:0.95 | area=   all | maxDets=100 ] = 0.664\n Average Recall     (AR) @[ IoU=0.50:0.95 | area= small | maxDets=100 ] = 0.496\n Average Recall     (AR) @[ IoU=0.50:0.95 | area=medium | maxDets=100 ] = 0.722\n Average Recall     (AR) @[ IoU=0.50:0.95 | area= large | maxDets=100 ] = 0.803\nResults saved to runs/val/exp3\n</code></pre> <p>In the results we can observe that we have achieved a sparsity of 30% in our model after pruning, which means that 30% of the model's weight parameters in <code>nn.Conv2d</code> layers are equal to 0. Inference time is essentially unchanged, while the model's AP and AR scores a slightly reduced.</p>"},{"location":"yolov5/tutorials/model_pruning_and_sparsity/#supported-environments","title":"Supported Environments","text":"<p>Ultralytics provides a range of ready-to-use environments, each pre-installed with essential dependencies such as CUDA, CUDNN, Python, and PyTorch, to kickstart your projects.</p> <ul> <li>Free GPU Notebooks:  </li> <li>Google Cloud: GCP Quickstart Guide</li> <li>Amazon: AWS Quickstart Guide</li> <li>Azure: AzureML Quickstart Guide</li> <li>Docker: Docker Quickstart Guide </li> </ul>"},{"location":"yolov5/tutorials/model_pruning_and_sparsity/#project-status","title":"Project Status","text":"<p>This badge indicates that all YOLOv5 GitHub Actions Continuous Integration (CI) tests are successfully passing. These CI tests rigorously check the functionality and performance of YOLOv5 across various key aspects: training, validation, inference, export, and benchmarks. They ensure consistent and reliable operation on macOS, Windows, and Ubuntu, with tests conducted every 24 hours and upon each new commit.</p>"},{"location":"yolov5/tutorials/multi_gpu_training/","title":"Multi-GPU Training","text":"<p>\ud83d\udcda This guide explains how to properly use multiple GPUs to train a dataset with YOLOv5 \ud83d\ude80 on single or multiple machine(s).</p>"},{"location":"yolov5/tutorials/multi_gpu_training/#before-you-start","title":"Before You Start","text":"<p>Clone repo and install requirements.txt in a Python&gt;=3.8.0 environment, including PyTorch&gt;=1.8. Models and datasets download automatically from the latest YOLOv5 release.</p> <pre><code>git clone https://github.com/ultralytics/yolov5  # clone\ncd yolov5\npip install -r requirements.txt  # install\n</code></pre> <p>\ud83d\udca1 ProTip! Docker Image is recommended for all Multi-GPU trainings. See Docker Quickstart Guide </p> <p>\ud83d\udca1 ProTip! <code>torch.distributed.run</code> replaces <code>torch.distributed.launch</code> in PyTorch&gt;=1.9. See docs for details.</p>"},{"location":"yolov5/tutorials/multi_gpu_training/#training","title":"Training","text":"<p>Select a pretrained model to start training from. Here we select YOLOv5s, the smallest and fastest model available. See our README table for a full comparison of all models. We will train this model with Multi-GPU on the COCO dataset.</p> <p></p>"},{"location":"yolov5/tutorials/multi_gpu_training/#single-gpu","title":"Single GPU","text":"<pre><code>python train.py  --batch 64 --data coco.yaml --weights yolov5s.pt --device 0\n</code></pre>"},{"location":"yolov5/tutorials/multi_gpu_training/#multi-gpu-dataparallel-mode-not-recommended","title":"Multi-GPU DataParallel Mode (\u26a0\ufe0f not recommended)","text":"<p>You can increase the <code>device</code> to use Multiple GPUs in DataParallel mode.</p> <pre><code>python train.py  --batch 64 --data coco.yaml --weights yolov5s.pt --device 0,1\n</code></pre> <p>This method is slow and barely speeds up training compared to using just 1 GPU.</p>"},{"location":"yolov5/tutorials/multi_gpu_training/#multi-gpu-distributeddataparallel-mode-recommended","title":"Multi-GPU DistributedDataParallel Mode (\u2705 recommended)","text":"<p>You will have to pass <code>python -m torch.distributed.run --nproc_per_node</code>, followed by the usual arguments.</p> <pre><code>python -m torch.distributed.run --nproc_per_node 2 train.py --batch 64 --data coco.yaml --weights yolov5s.pt --device 0,1\n</code></pre> <p><code>--nproc_per_node</code> specifies how many GPUs you would like to use. In the example above, it is 2. <code>--batch</code> is the total batch-size. It will be divided evenly to each GPU. In the example above, it is 64/2=32 per GPU.</p> <p>The code above will use GPUs <code>0... (N-1)</code>.</p> Use specific GPUs (click to expand)  You can do so by simply passing `--device` followed by your specific GPUs. For example, in the code below, we will use GPUs `2,3`.  <pre><code>python -m torch.distributed.run --nproc_per_node 2 train.py --batch 64 --data coco.yaml --cfg yolov5s.yaml --weights '' --device 2,3\n</code></pre> Use SyncBatchNorm (click to expand)  [SyncBatchNorm](https://pytorch.org/docs/master/generated/torch.nn.SyncBatchNorm.html) could increase accuracy for multiple gpu training, however, it will slow down training by a significant factor. It is **only** available for Multiple GPU DistributedDataParallel training.  It is best used when the batch-size on **each** GPU is small (&lt;= 8).  To use SyncBatchNorm, simple pass `--sync-bn` to the command like below,  <pre><code>python -m torch.distributed.run --nproc_per_node 2 train.py --batch 64 --data coco.yaml --cfg yolov5s.yaml --weights '' --sync-bn\n</code></pre> Use Multiple machines (click to expand)  This is **only** available for Multiple GPU DistributedDataParallel training.  Before we continue, make sure the files on all machines are the same, dataset, codebase, etc. Afterward, make sure the machines can communicate to each other.  You will have to choose a master machine(the machine that the others will talk to). Note down its address(`master_addr`) and choose a port(`master_port`). I will use `master_addr = 192.168.1.1` and `master_port = 1234` for the example below.  To use it, you can do as the following,  <pre><code># On master machine 0\npython -m torch.distributed.run --nproc_per_node G --nnodes N --node_rank 0 --master_addr \"192.168.1.1\" --master_port 1234 train.py --batch 64 --data coco.yaml --cfg yolov5s.yaml --weights ''\n</code></pre> <pre><code># On machine R\npython -m torch.distributed.run --nproc_per_node G --nnodes N --node_rank R --master_addr \"192.168.1.1\" --master_port 1234 train.py --batch 64 --data coco.yaml --cfg yolov5s.yaml --weights ''\n</code></pre>  where `G` is number of GPU per machine, `N` is the number of machines, and `R` is the machine number from `0...(N-1)`. Let's say I have two machines with two GPUs each, it would be `G = 2` , `N = 2`, and `R = 1` for the above.  Training will not start until all  `N` machines are connected. Output will only be shown on master machine!"},{"location":"yolov5/tutorials/multi_gpu_training/#notes","title":"Notes","text":"<ul> <li>Windows support is untested, Linux is recommended.</li> <li><code>--batch</code> must be a multiple of the number of GPUs.</li> <li>GPU 0 will take slightly more memory than the other GPUs as it maintains EMA and is responsible for checkpointing etc.</li> <li>If you get <code>RuntimeError: Address already in use</code>, it could be because you are running multiple trainings at a time. To fix this, simply use a different port number by adding <code>--master_port</code> like below,</li> </ul> <pre><code>python -m torch.distributed.run --master_port 1234 --nproc_per_node 2 ...\n</code></pre>"},{"location":"yolov5/tutorials/multi_gpu_training/#results","title":"Results","text":"<p>DDP profiling results on an AWS EC2 P4d instance with 8x A100 SXM4-40GB for YOLOv5l for 1 COCO epoch.</p> Profiling code <pre><code># prepare\nt=ultralytics/yolov5:latest &amp;&amp; sudo docker pull $t &amp;&amp; sudo docker run -it --ipc=host --gpus all -v \"$(pwd)\"/coco:/usr/src/coco $t\npip3 install torch==1.9.0+cu111 torchvision==0.10.0+cu111 -f https://download.pytorch.org/whl/torch_stable.html\ncd .. &amp;&amp; rm -rf app &amp;&amp; git clone https://github.com/ultralytics/yolov5 -b master app &amp;&amp; cd app\ncp data/coco.yaml data/coco_profile.yaml\n\n# profile\npython train.py --batch-size 16 --data coco_profile.yaml --weights yolov5l.pt --epochs 1 --device 0\npython -m torch.distributed.run --nproc_per_node 2 train.py --batch-size 32 --data coco_profile.yaml --weights yolov5l.pt --epochs 1 --device 0,1\npython -m torch.distributed.run --nproc_per_node 4 train.py --batch-size 64 --data coco_profile.yaml --weights yolov5l.pt --epochs 1 --device 0,1,2,3\npython -m torch.distributed.run --nproc_per_node 8 train.py --batch-size 128 --data coco_profile.yaml --weights yolov5l.pt --epochs 1 --device 0,1,2,3,4,5,6,7\n</code></pre> GPUsA100 batch-size CUDA_mem<sup>device0 (G) COCO<sup>train COCO<sup>val 1x 16 26GB 20:39 0:55 2x 32 26GB 11:43 0:57 4x 64 26GB 5:57 0:55 8x 128 26GB 3:09 0:57"},{"location":"yolov5/tutorials/multi_gpu_training/#faq","title":"FAQ","text":"<p>If an error occurs, please read the checklist below first! (It could save your time)</p> Checklist (click to expand)  <ul> <li>Have you properly read this post?  </li> <li>Have you tried to re-clone the codebase? The code changes daily.</li> <li>Have you tried to search for your error? Someone may have already encountered it in this repo or in another and have the solution. </li> <li>Have you installed all the requirements listed on top (including the correct Python and Pytorch versions)? </li> <li>Have you tried in other environments listed in the \"Environments\" section below? </li> <li>Have you tried with another dataset like coco128 or coco2017? It will make it easier to find the root cause. </li> </ul>  If you went through all the above, feel free to raise an Issue by giving as much detail as possible following the template."},{"location":"yolov5/tutorials/multi_gpu_training/#supported-environments","title":"Supported Environments","text":"<p>Ultralytics provides a range of ready-to-use environments, each pre-installed with essential dependencies such as CUDA, CUDNN, Python, and PyTorch, to kickstart your projects.</p> <ul> <li>Free GPU Notebooks:  </li> <li>Google Cloud: GCP Quickstart Guide</li> <li>Amazon: AWS Quickstart Guide</li> <li>Azure: AzureML Quickstart Guide</li> <li>Docker: Docker Quickstart Guide </li> </ul>"},{"location":"yolov5/tutorials/multi_gpu_training/#project-status","title":"Project Status","text":"<p>This badge indicates that all YOLOv5 GitHub Actions Continuous Integration (CI) tests are successfully passing. These CI tests rigorously check the functionality and performance of YOLOv5 across various key aspects: training, validation, inference, export, and benchmarks. They ensure consistent and reliable operation on macOS, Windows, and Ubuntu, with tests conducted every 24 hours and upon each new commit.</p>"},{"location":"yolov5/tutorials/multi_gpu_training/#credits","title":"Credits","text":"<p>We would like to thank @MagicFrogSJTU, who did all the heavy lifting, and @glenn-jocher for guiding us along the way.</p>"},{"location":"yolov5/tutorials/neural_magic_pruning_quantization/","title":"Neural Magic's DeepSparse","text":"<p>Welcome to software-delivered AI.</p> <p>This guide explains how to deploy YOLOv5 with Neural Magic's DeepSparse.</p> <p>DeepSparse is an inference runtime with exceptional performance on CPUs. For instance, compared to the ONNX Runtime baseline, DeepSparse offers a 5.8x speed-up for YOLOv5s, running on the same machine!</p> <p> </p> <p>For the first time, your deep learning workloads can meet the performance demands of production without the complexity and costs of hardware accelerators. Put simply, DeepSparse gives you the performance of GPUs and the simplicity of software:</p> <ul> <li>Flexible Deployments: Run consistently across cloud, data center, and edge with any hardware provider from Intel to AMD to ARM</li> <li>Infinite Scalability: Scale vertically to 100s of cores, out with standard Kubernetes, or fully-abstracted with Serverless</li> <li>Easy Integration: Clean APIs for integrating your model into an application and monitoring it in production</li> </ul>"},{"location":"yolov5/tutorials/neural_magic_pruning_quantization/#how-does-deepsparse-achieve-gpu-class-performance","title":"How Does DeepSparse Achieve GPU-Class Performance?","text":"<p>DeepSparse takes advantage of model sparsity to gain its performance speedup.</p> <p>Sparsification through pruning and quantization is a broadly studied technique, allowing order-of-magnitude reductions in the size and compute needed to execute a network, while maintaining high accuracy. DeepSparse is sparsity-aware, meaning it skips the zeroed out parameters, shrinking amount of compute in a forward pass. Since the sparse computation is now memory bound, DeepSparse executes the network depth-wise, breaking the problem into Tensor Columns, vertical stripes of computation that fit in cache.</p> <p> </p> <p>Sparse networks with compressed computation, executed depth-wise in cache, allows DeepSparse to deliver GPU-class performance on CPUs!</p>"},{"location":"yolov5/tutorials/neural_magic_pruning_quantization/#how-do-i-create-a-sparse-version-of-yolov5-trained-on-my-data","title":"How Do I Create A Sparse Version of YOLOv5 Trained on My Data?","text":"<p>Neural Magic's open-source model repository, SparseZoo, contains pre-sparsified checkpoints of each YOLOv5 model. Using SparseML, which is integrated with Ultralytics, you can fine-tune a sparse checkpoint onto your data with a single CLI command.</p> <p>Checkout Neural Magic's YOLOv5 documentation for more details.</p>"},{"location":"yolov5/tutorials/neural_magic_pruning_quantization/#deepsparse-usage","title":"DeepSparse Usage","text":"<p>We will walk through an example benchmarking and deploying a sparse version of YOLOv5s with DeepSparse.</p>"},{"location":"yolov5/tutorials/neural_magic_pruning_quantization/#install-deepsparse","title":"Install DeepSparse","text":"<p>Run the following to install DeepSparse. We recommend you use a virtual environment with Python.</p> <pre><code>pip install \"deepsparse[server,yolo,onnxruntime]\"\n</code></pre>"},{"location":"yolov5/tutorials/neural_magic_pruning_quantization/#collect-an-onnx-file","title":"Collect an ONNX File","text":"<p>DeepSparse accepts a model in the ONNX format, passed either as:</p> <ul> <li>A SparseZoo stub which identifies an ONNX file in the SparseZoo</li> <li>A local path to an ONNX model in a filesystem</li> </ul> <p>The examples below use the standard dense and pruned-quantized YOLOv5s checkpoints, identified by the following SparseZoo stubs:</p> <pre><code>zoo:cv/detection/yolov5-s/pytorch/ultralytics/coco/base-none\nzoo:cv/detection/yolov5-s/pytorch/ultralytics/coco/pruned65_quant-none\n</code></pre>"},{"location":"yolov5/tutorials/neural_magic_pruning_quantization/#deploy-a-model","title":"Deploy a Model","text":"<p>DeepSparse offers convenient APIs for integrating your model into an application.</p> <p>To try the deployment examples below, pull down a sample image and save it as <code>basilica.jpg</code> with the following:</p> <pre><code>wget -O basilica.jpg https://raw.githubusercontent.com/neuralmagic/deepsparse/main/src/deepsparse/yolo/sample_images/basilica.jpg\n</code></pre>"},{"location":"yolov5/tutorials/neural_magic_pruning_quantization/#python-api","title":"Python API","text":"<p><code>Pipelines</code> wrap pre-processing and output post-processing around the runtime, providing a clean interface for adding DeepSparse to an application. The DeepSparse-Ultralytics integration includes an out-of-the-box <code>Pipeline</code> that accepts raw images and outputs the bounding boxes.</p> <p>Create a <code>Pipeline</code> and run inference:</p> <pre><code>from deepsparse import Pipeline\n\n# list of images in local filesystem\nimages = [\"basilica.jpg\"]\n\n# create Pipeline\nmodel_stub = \"zoo:cv/detection/yolov5-s/pytorch/ultralytics/coco/pruned65_quant-none\"\nyolo_pipeline = Pipeline.create(\n    task=\"yolo\",\n    model_path=model_stub,\n)\n\n# run inference on images, receive bounding boxes + classes\npipeline_outputs = yolo_pipeline(images=images, iou_thres=0.6, conf_thres=0.001)\nprint(pipeline_outputs)\n</code></pre> <p>If you are running in the cloud, you may get an error that open-cv cannot find <code>libGL.so.1</code>. Running the following on Ubuntu installs it:</p> <pre><code>apt-get install libgl1\n</code></pre>"},{"location":"yolov5/tutorials/neural_magic_pruning_quantization/#http-server","title":"HTTP Server","text":"<p>DeepSparse Server runs on top of the popular FastAPI web framework and Uvicorn web server. With just a single CLI command, you can easily setup a model service endpoint with DeepSparse. The Server supports any Pipeline from DeepSparse, including object detection with YOLOv5, enabling you to send raw images to the endpoint and receive the bounding boxes.</p> <p>Spin up the Server with the pruned-quantized YOLOv5s:</p> <pre><code>deepsparse.server \\\n    --task yolo \\\n    --model_path zoo:cv/detection/yolov5-s/pytorch/ultralytics/coco/pruned65_quant-none\n</code></pre> <p>An example request, using Python's <code>requests</code> package:</p> <pre><code>import requests, json\n\n# list of images for inference (local files on client side)\npath = ['basilica.jpg']\nfiles = [('request', open(img, 'rb')) for img in path]\n\n# send request over HTTP to /predict/from_files endpoint\nurl = 'http://0.0.0.0:5543/predict/from_files'\nresp = requests.post(url=url, files=files)\n\n# response is returned in JSON\nannotations = json.loads(resp.text)  # dictionary of annotation results\nbounding_boxes = annotations[\"boxes\"]\nlabels = annotations[\"labels\"]\n</code></pre>"},{"location":"yolov5/tutorials/neural_magic_pruning_quantization/#annotate-cli","title":"Annotate CLI","text":"<p>You can also use the annotate command to have the engine save an annotated photo on disk. Try --source 0 to annotate your live webcam feed!</p> <pre><code>deepsparse.object_detection.annotate --model_filepath zoo:cv/detection/yolov5-s/pytorch/ultralytics/coco/pruned65_quant-none --source basilica.jpg\n</code></pre> <p>Running the above command will create an <code>annotation-results</code> folder and save the annotated image inside.</p> <p> </p>"},{"location":"yolov5/tutorials/neural_magic_pruning_quantization/#benchmarking-performance","title":"Benchmarking Performance","text":"<p>We will compare DeepSparse's throughput to ONNX Runtime's throughput on YOLOv5s, using DeepSparse's benchmarking script.</p> <p>The benchmarks were run on an AWS <code>c6i.8xlarge</code> instance (16 cores).</p>"},{"location":"yolov5/tutorials/neural_magic_pruning_quantization/#batch-32-performance-comparison","title":"Batch 32 Performance Comparison","text":""},{"location":"yolov5/tutorials/neural_magic_pruning_quantization/#onnx-runtime-baseline","title":"ONNX Runtime Baseline","text":"<p>At batch 32, ONNX Runtime achieves 42 images/sec with the standard dense YOLOv5s:</p> <pre><code>deepsparse.benchmark zoo:cv/detection/yolov5-s/pytorch/ultralytics/coco/base-none -s sync -b 32 -nstreams 1 -e onnxruntime\n\n&gt; Original Model Path: zoo:cv/detection/yolov5-s/pytorch/ultralytics/coco/base-none\n&gt; Batch Size: 32\n&gt; Scenario: sync\n&gt; Throughput (items/sec): 41.9025\n</code></pre>"},{"location":"yolov5/tutorials/neural_magic_pruning_quantization/#deepsparse-dense-performance","title":"DeepSparse Dense Performance","text":"<p>While DeepSparse offers its best performance with optimized sparse models, it also performs well with the standard dense YOLOv5s.</p> <p>At batch 32, DeepSparse achieves 70 images/sec with the standard dense YOLOv5s, a 1.7x performance improvement over ORT!</p> <pre><code>deepsparse.benchmark zoo:cv/detection/yolov5-s/pytorch/ultralytics/coco/base-none -s sync -b 32 -nstreams 1\n\n&gt; Original Model Path: zoo:cv/detection/yolov5-s/pytorch/ultralytics/coco/base-none\n&gt; Batch Size: 32\n&gt; Scenario: sync\n&gt; Throughput (items/sec): 69.5546\n</code></pre>"},{"location":"yolov5/tutorials/neural_magic_pruning_quantization/#deepsparse-sparse-performance","title":"DeepSparse Sparse Performance","text":"<p>When sparsity is applied to the model, DeepSparse's performance gains over ONNX Runtime is even stronger.</p> <p>At batch 32, DeepSparse achieves 241 images/sec with the pruned-quantized YOLOv5s, a 5.8x performance improvement over ORT!</p> <pre><code>deepsparse.benchmark zoo:cv/detection/yolov5-s/pytorch/ultralytics/coco/pruned65_quant-none -s sync -b 32 -nstreams 1\n\n&gt; Original Model Path: zoo:cv/detection/yolov5-s/pytorch/ultralytics/coco/pruned65_quant-none\n&gt; Batch Size: 32\n&gt; Scenario: sync\n&gt; Throughput (items/sec): 241.2452\n</code></pre>"},{"location":"yolov5/tutorials/neural_magic_pruning_quantization/#batch-1-performance-comparison","title":"Batch 1 Performance Comparison","text":"<p>DeepSparse is also able to gain a speed-up over ONNX Runtime for the latency-sensitive, batch 1 scenario.</p>"},{"location":"yolov5/tutorials/neural_magic_pruning_quantization/#onnx-runtime-baseline_1","title":"ONNX Runtime Baseline","text":"<p>At batch 1, ONNX Runtime achieves 48 images/sec with the standard, dense YOLOv5s.</p> <pre><code>deepsparse.benchmark zoo:cv/detection/yolov5-s/pytorch/ultralytics/coco/base-none -s sync -b 1 -nstreams 1 -e onnxruntime\n\n&gt; Original Model Path: zoo:cv/detection/yolov5-s/pytorch/ultralytics/coco/base-none\n&gt; Batch Size: 1\n&gt; Scenario: sync\n&gt; Throughput (items/sec): 48.0921\n</code></pre>"},{"location":"yolov5/tutorials/neural_magic_pruning_quantization/#deepsparse-sparse-performance_1","title":"DeepSparse Sparse Performance","text":"<p>At batch 1, DeepSparse achieves 135 items/sec with a pruned-quantized YOLOv5s, a 2.8x performance gain over ONNX Runtime!</p> <pre><code>deepsparse.benchmark zoo:cv/detection/yolov5-s/pytorch/ultralytics/coco/pruned65_quant-none -s sync -b 1 -nstreams 1\n\n&gt; Original Model Path: zoo:cv/detection/yolov5-s/pytorch/ultralytics/coco/pruned65_quant-none\n&gt; Batch Size: 1\n&gt; Scenario: sync\n&gt; Throughput (items/sec): 134.9468\n</code></pre> <p>Since <code>c6i.8xlarge</code> instances have VNNI instructions, DeepSparse's throughput can be pushed further if weights are pruned in blocks of 4.</p> <p>At batch 1, DeepSparse achieves 180 items/sec with a 4-block pruned-quantized YOLOv5s, a 3.7x performance gain over ONNX Runtime!</p> <pre><code>deepsparse.benchmark zoo:cv/detection/yolov5-s/pytorch/ultralytics/coco/pruned35_quant-none-vnni -s sync -b 1 -nstreams 1\n\n&gt; Original Model Path: zoo:cv/detection/yolov5-s/pytorch/ultralytics/coco/pruned35_quant-none-vnni\n&gt; Batch Size: 1\n&gt; Scenario: sync\n&gt; Throughput (items/sec): 179.7375\n</code></pre>"},{"location":"yolov5/tutorials/neural_magic_pruning_quantization/#get-started-with-deepsparse","title":"Get Started With DeepSparse","text":"<p>Research or Testing? DeepSparse Community is free for research and testing. Get started with our Documentation.</p>"},{"location":"yolov5/tutorials/pytorch_hub_model_loading/","title":"PyTorch Hub","text":"<p>\ud83d\udcda This guide explains how to load YOLOv5 \ud83d\ude80 from PyTorch Hub at https://pytorch.org/hub/ultralytics_yolov5.</p>"},{"location":"yolov5/tutorials/pytorch_hub_model_loading/#before-you-start","title":"Before You Start","text":"<p>Install requirements.txt in a Python&gt;=3.8.0 environment, including PyTorch&gt;=1.8. Models and datasets download automatically from the latest YOLOv5 release.</p> <pre><code>pip install -r https://raw.githubusercontent.com/ultralytics/yolov5/master/requirements.txt\n</code></pre> <p>\ud83d\udca1 ProTip: Cloning https://github.com/ultralytics/yolov5 is not required \ud83d\ude03</p>"},{"location":"yolov5/tutorials/pytorch_hub_model_loading/#load-yolov5-with-pytorch-hub","title":"Load YOLOv5 with PyTorch Hub","text":""},{"location":"yolov5/tutorials/pytorch_hub_model_loading/#simple-example","title":"Simple Example","text":"<p>This example loads a pretrained YOLOv5s model from PyTorch Hub as <code>model</code> and passes an image for inference. <code>'yolov5s'</code> is the lightest and fastest YOLOv5 model. For details on all available models please see the README.</p> <pre><code>import torch\n\n# Model\nmodel = torch.hub.load('ultralytics/yolov5', 'yolov5s')\n\n# Image\nim = 'https://ultralytics.com/images/zidane.jpg'\n\n# Inference\nresults = model(im)\n\nresults.pandas().xyxy[0]\n#      xmin    ymin    xmax   ymax  confidence  class    name\n# 0  749.50   43.50  1148.0  704.5    0.874023      0  person\n# 1  433.50  433.50   517.5  714.5    0.687988     27     tie\n# 2  114.75  195.75  1095.0  708.0    0.624512      0  person\n# 3  986.00  304.00  1028.0  420.0    0.286865     27     tie\n</code></pre>"},{"location":"yolov5/tutorials/pytorch_hub_model_loading/#detailed-example","title":"Detailed Example","text":"<p>This example shows batched inference with PIL and OpenCV image sources. <code>results</code> can be printed to console, saved to <code>runs/hub</code>, showed to screen on supported environments, and returned as tensors or pandas dataframes.</p> <pre><code>import cv2\nimport torch\nfrom PIL import Image\n\n# Model\nmodel = torch.hub.load('ultralytics/yolov5', 'yolov5s')\n\n# Images\nfor f in 'zidane.jpg', 'bus.jpg':\n    torch.hub.download_url_to_file('https://ultralytics.com/images/' + f, f)  # download 2 images\nim1 = Image.open('zidane.jpg')  # PIL image\nim2 = cv2.imread('bus.jpg')[..., ::-1]  # OpenCV image (BGR to RGB)\n\n# Inference\nresults = model([im1, im2], size=640)  # batch of images\n\n# Results\nresults.print()\nresults.save()  # or .show()\n\nresults.xyxy[0]  # im1 predictions (tensor)\nresults.pandas().xyxy[0]  # im1 predictions (pandas)\n#      xmin    ymin    xmax   ymax  confidence  class    name\n# 0  749.50   43.50  1148.0  704.5    0.874023      0  person\n# 1  433.50  433.50   517.5  714.5    0.687988     27     tie\n# 2  114.75  195.75  1095.0  708.0    0.624512      0  person\n# 3  986.00  304.00  1028.0  420.0    0.286865     27     tie\n</code></pre> <p> </p> <p>For all inference options see YOLOv5 <code>AutoShape()</code> forward method.</p>"},{"location":"yolov5/tutorials/pytorch_hub_model_loading/#inference-settings","title":"Inference Settings","text":"<p>YOLOv5 models contain various inference attributes such as confidence threshold, IoU threshold, etc. which can be set by:</p> <pre><code>model.conf = 0.25  # NMS confidence threshold\niou = 0.45  # NMS IoU threshold\nagnostic = False  # NMS class-agnostic\nmulti_label = False  # NMS multiple labels per box\nclasses = None  # (optional list) filter by class, i.e. = [0, 15, 16] for COCO persons, cats and dogs\nmax_det = 1000  # maximum number of detections per image\namp = False  # Automatic Mixed Precision (AMP) inference\n\nresults = model(im, size=320)  # custom inference size\n</code></pre>"},{"location":"yolov5/tutorials/pytorch_hub_model_loading/#device","title":"Device","text":"<p>Models can be transferred to any device after creation:</p> <pre><code>model.cpu()  # CPU\nmodel.cuda()  # GPU\nmodel.to(device)  # i.e. device=torch.device(0)\n</code></pre> <p>Models can also be created directly on any <code>device</code>:</p> <pre><code>model = torch.hub.load('ultralytics/yolov5', 'yolov5s', device='cpu')  # load on CPU\n</code></pre> <p>\ud83d\udca1 ProTip: Input images are automatically transferred to the correct model device before inference.</p>"},{"location":"yolov5/tutorials/pytorch_hub_model_loading/#silence-outputs","title":"Silence Outputs","text":"<p>Models can be loaded silently with <code>_verbose=False</code>:</p> <pre><code>model = torch.hub.load('ultralytics/yolov5', 'yolov5s', _verbose=False)  # load silently\n</code></pre>"},{"location":"yolov5/tutorials/pytorch_hub_model_loading/#input-channels","title":"Input Channels","text":"<p>To load a pretrained YOLOv5s model with 4 input channels rather than the default 3:</p> <pre><code>model = torch.hub.load('ultralytics/yolov5', 'yolov5s', channels=4)\n</code></pre> <p>In this case the model will be composed of pretrained weights except for the very first input layer, which is no longer the same shape as the pretrained input layer. The input layer will remain initialized by random weights.</p>"},{"location":"yolov5/tutorials/pytorch_hub_model_loading/#number-of-classes","title":"Number of Classes","text":"<p>To load a pretrained YOLOv5s model with 10 output classes rather than the default 80:</p> <pre><code>model = torch.hub.load('ultralytics/yolov5', 'yolov5s', classes=10)\n</code></pre> <p>In this case the model will be composed of pretrained weights except for the output layers, which are no longer the same shape as the pretrained output layers. The output layers will remain initialized by random weights.</p>"},{"location":"yolov5/tutorials/pytorch_hub_model_loading/#force-reload","title":"Force Reload","text":"<p>If you run into problems with the above steps, setting <code>force_reload=True</code> may help by discarding the existing cache and force a fresh download of the latest YOLOv5 version from PyTorch Hub.</p> <pre><code>model = torch.hub.load('ultralytics/yolov5', 'yolov5s', force_reload=True)  # force reload\n</code></pre>"},{"location":"yolov5/tutorials/pytorch_hub_model_loading/#screenshot-inference","title":"Screenshot Inference","text":"<p>To run inference on your desktop screen:</p> <pre><code>import torch\nfrom PIL import ImageGrab\n\n# Model\nmodel = torch.hub.load('ultralytics/yolov5', 'yolov5s')\n\n# Image\nim = ImageGrab.grab()  # take a screenshot\n\n# Inference\nresults = model(im)\n</code></pre>"},{"location":"yolov5/tutorials/pytorch_hub_model_loading/#multi-gpu-inference","title":"Multi-GPU Inference","text":"<p>YOLOv5 models can be loaded to multiple GPUs in parallel with threaded inference:</p> <pre><code>import torch\nimport threading\n\n\ndef run(model, im):\n    results = model(im)\n    results.save()\n\n\n# Models\nmodel0 = torch.hub.load('ultralytics/yolov5', 'yolov5s', device=0)\nmodel1 = torch.hub.load('ultralytics/yolov5', 'yolov5s', device=1)\n\n# Inference\nthreading.Thread(target=run, args=[model0, 'https://ultralytics.com/images/zidane.jpg'], daemon=True).start()\nthreading.Thread(target=run, args=[model1, 'https://ultralytics.com/images/bus.jpg'], daemon=True).start()\n</code></pre>"},{"location":"yolov5/tutorials/pytorch_hub_model_loading/#training","title":"Training","text":"<p>To load a YOLOv5 model for training rather than inference, set <code>autoshape=False</code>. To load a model with randomly initialized weights (to train from scratch) use <code>pretrained=False</code>. You must provide your own training script in this case. Alternatively see our YOLOv5 Train Custom Data Tutorial for model training.</p> <pre><code>import torch\n\nmodel = torch.hub.load('ultralytics/yolov5', 'yolov5s', autoshape=False)  # load pretrained\nmodel = torch.hub.load('ultralytics/yolov5', 'yolov5s', autoshape=False, pretrained=False)  # load scratch\n</code></pre>"},{"location":"yolov5/tutorials/pytorch_hub_model_loading/#base64-results","title":"Base64 Results","text":"<p>For use with API services. See https://github.com/ultralytics/yolov5/pull/2291 and Flask REST API example for details.</p> <pre><code>results = model(im)  # inference\n\nresults.ims  # array of original images (as np array) passed to model for inference\nresults.render()  # updates results.ims with boxes and labels\nfor im in results.ims:\n    buffered = BytesIO()\n    im_base64 = Image.fromarray(im)\n    im_base64.save(buffered, format=\"JPEG\")\n    print(base64.b64encode(buffered.getvalue()).decode('utf-8'))  # base64 encoded image with results\n</code></pre>"},{"location":"yolov5/tutorials/pytorch_hub_model_loading/#cropped-results","title":"Cropped Results","text":"<p>Results can be returned and saved as detection crops:</p> <pre><code>results = model(im)  # inference\ncrops = results.crop(save=True)  # cropped detections dictionary\n</code></pre>"},{"location":"yolov5/tutorials/pytorch_hub_model_loading/#pandas-results","title":"Pandas Results","text":"<p>Results can be returned as Pandas DataFrames:</p> <pre><code>results = model(im)  # inference\nresults.pandas().xyxy[0]  # Pandas DataFrame\n</code></pre> Pandas Output (click to expand) <pre><code>print(results.pandas().xyxy[0])\n#      xmin    ymin    xmax   ymax  confidence  class    name\n# 0  749.50   43.50  1148.0  704.5    0.874023      0  person\n# 1  433.50  433.50   517.5  714.5    0.687988     27     tie\n# 2  114.75  195.75  1095.0  708.0    0.624512      0  person\n# 3  986.00  304.00  1028.0  420.0    0.286865     27     tie\n</code></pre>"},{"location":"yolov5/tutorials/pytorch_hub_model_loading/#sorted-results","title":"Sorted Results","text":"<p>Results can be sorted by column, i.e. to sort license plate digit detection left-to-right (x-axis):</p> <pre><code>results = model(im)  # inference\nresults.pandas().xyxy[0].sort_values('xmin')  # sorted left-right\n</code></pre>"},{"location":"yolov5/tutorials/pytorch_hub_model_loading/#box-cropped-results","title":"Box-Cropped Results","text":"<p>Results can be returned and saved as detection crops:</p> <pre><code>results = model(im)  # inference\ncrops = results.crop(save=True)  # cropped detections dictionary\n</code></pre>"},{"location":"yolov5/tutorials/pytorch_hub_model_loading/#json-results","title":"JSON Results","text":"<p>Results can be returned in JSON format once converted to <code>.pandas()</code> dataframes using the <code>.to_json()</code> method. The JSON format can be modified using the <code>orient</code> argument. See pandas <code>.to_json()</code> documentation for details.</p> <pre><code>results = model(ims)  # inference\nresults.pandas().xyxy[0].to_json(orient=\"records\")  # JSON img1 predictions\n</code></pre> JSON Output (click to expand) <pre><code>[\n  {\n    \"xmin\": 749.5,\n    \"ymin\": 43.5,\n    \"xmax\": 1148.0,\n    \"ymax\": 704.5,\n    \"confidence\": 0.8740234375,\n    \"class\": 0,\n    \"name\": \"person\"\n  },\n  {\n    \"xmin\": 433.5,\n    \"ymin\": 433.5,\n    \"xmax\": 517.5,\n    \"ymax\": 714.5,\n    \"confidence\": 0.6879882812,\n    \"class\": 27,\n    \"name\": \"tie\"\n  },\n  {\n    \"xmin\": 115.25,\n    \"ymin\": 195.75,\n    \"xmax\": 1096.0,\n    \"ymax\": 708.0,\n    \"confidence\": 0.6254882812,\n    \"class\": 0,\n    \"name\": \"person\"\n  },\n  {\n    \"xmin\": 986.0,\n    \"ymin\": 304.0,\n    \"xmax\": 1028.0,\n    \"ymax\": 420.0,\n    \"confidence\": 0.2873535156,\n    \"class\": 27,\n    \"name\": \"tie\"\n  }\n]\n</code></pre>"},{"location":"yolov5/tutorials/pytorch_hub_model_loading/#custom-models","title":"Custom Models","text":"<p>This example loads a custom 20-class VOC-trained YOLOv5s model <code>'best.pt'</code> with PyTorch Hub.</p> <pre><code>import torch\n\nmodel = torch.hub.load('ultralytics/yolov5', 'custom', path='path/to/best.pt')  # local model\nmodel = torch.hub.load('path/to/yolov5', 'custom', path='path/to/best.pt', source='local')  # local repo\n</code></pre>"},{"location":"yolov5/tutorials/pytorch_hub_model_loading/#tensorrt-onnx-and-openvino-models","title":"TensorRT, ONNX and OpenVINO Models","text":"<p>PyTorch Hub supports inference on most YOLOv5 export formats, including custom trained models. See TFLite, ONNX, CoreML, TensorRT Export tutorial for details on exporting models.</p> <p>\ud83d\udca1 ProTip: TensorRT may be up to 2-5X faster than PyTorch on GPU benchmarks \ud83d\udca1 ProTip: ONNX and OpenVINO may be up to 2-3X faster than PyTorch on CPU benchmarks</p> <pre><code>import torch\n\nmodel = torch.hub.load('ultralytics/yolov5', 'custom', path='yolov5s.pt')  # PyTorch\nmodel = torch.hub.load('ultralytics/yolov5', 'custom', path='yolov5s.torchscript')  # TorchScript\nmodel = torch.hub.load('ultralytics/yolov5', 'custom', path='yolov5s.onnx')  # ONNX\nmodel = torch.hub.load('ultralytics/yolov5', 'custom', path='yolov5s_openvino_model/')  # OpenVINO\nmodel = torch.hub.load('ultralytics/yolov5', 'custom', path='yolov5s.engine')  # TensorRT\nmodel = torch.hub.load('ultralytics/yolov5', 'custom', path='yolov5s.mlmodel')  # CoreML (macOS-only)\nmodel = torch.hub.load('ultralytics/yolov5', 'custom', path='yolov5s.tflite')  # TFLite\nmodel = torch.hub.load('ultralytics/yolov5', 'custom', path='yolov5s_paddle_model/')  # PaddlePaddle\n</code></pre>"},{"location":"yolov5/tutorials/pytorch_hub_model_loading/#supported-environments","title":"Supported Environments","text":"<p>Ultralytics provides a range of ready-to-use environments, each pre-installed with essential dependencies such as CUDA, CUDNN, Python, and PyTorch, to kickstart your projects.</p> <ul> <li>Free GPU Notebooks:  </li> <li>Google Cloud: GCP Quickstart Guide</li> <li>Amazon: AWS Quickstart Guide</li> <li>Azure: AzureML Quickstart Guide</li> <li>Docker: Docker Quickstart Guide </li> </ul>"},{"location":"yolov5/tutorials/pytorch_hub_model_loading/#project-status","title":"Project Status","text":"<p>This badge indicates that all YOLOv5 GitHub Actions Continuous Integration (CI) tests are successfully passing. These CI tests rigorously check the functionality and performance of YOLOv5 across various key aspects: training, validation, inference, export, and benchmarks. They ensure consistent and reliable operation on macOS, Windows, and Ubuntu, with tests conducted every 24 hours and upon each new commit.</p>"},{"location":"yolov5/tutorials/roboflow_datasets_integration/","title":"Roboflow Datasets","text":"<p>You can now use Roboflow to organize, label, prepare, version, and host your datasets for training YOLOv5 \ud83d\ude80 models. Roboflow is free to use with YOLOv5 if you make your workspace public.</p> <p>Licensing</p> <p>Ultralytics offers two licensing options:</p> <ul> <li>The AGPL-3.0 License, an OSI-approved open-source license ideal for students and enthusiasts.</li> <li>The Enterprise License for businesses seeking to incorporate our AI models into their products and services.</li> </ul> <p>For more details see Ultralytics Licensing.</p>"},{"location":"yolov5/tutorials/roboflow_datasets_integration/#upload","title":"Upload","text":"<p>You can upload your data to Roboflow via web UI, REST API, or Python.</p>"},{"location":"yolov5/tutorials/roboflow_datasets_integration/#labeling","title":"Labeling","text":"<p>After uploading data to Roboflow, you can label your data and review previous labels.</p> <p></p>"},{"location":"yolov5/tutorials/roboflow_datasets_integration/#versioning","title":"Versioning","text":"<p>You can make versions of your dataset with different preprocessing and offline augmentation options. YOLOv5 does online augmentations natively, so be intentional when layering Roboflow's offline augmentations on top.</p> <p></p>"},{"location":"yolov5/tutorials/roboflow_datasets_integration/#exporting-data","title":"Exporting Data","text":"<p>You can download your data in YOLOv5 format to quickly begin training.</p> <pre><code>from roboflow import Roboflow\nrf = Roboflow(api_key=\"YOUR API KEY HERE\")\nproject = rf.workspace().project(\"YOUR PROJECT\")\ndataset = project.version(\"YOUR VERSION\").download(\"yolov5\")\n</code></pre>"},{"location":"yolov5/tutorials/roboflow_datasets_integration/#custom-training","title":"Custom Training","text":"<p>We have released a custom training tutorial demonstrating all of the above capabilities. You can access the code here:</p> <p></p>"},{"location":"yolov5/tutorials/roboflow_datasets_integration/#active-learning","title":"Active Learning","text":"<p>The real world is messy and your model will invariably encounter situations your dataset didn't anticipate. Using active learning is an important strategy to iteratively improve your dataset and model. With the Roboflow and YOLOv5 integration, you can quickly make improvements on your model deployments by using a battle tested machine learning pipeline.</p> <p></p>"},{"location":"yolov5/tutorials/roboflow_datasets_integration/#supported-environments","title":"Supported Environments","text":"<p>Ultralytics provides a range of ready-to-use environments, each pre-installed with essential dependencies such as CUDA, CUDNN, Python, and PyTorch, to kickstart your projects.</p> <ul> <li>Free GPU Notebooks:  </li> <li>Google Cloud: GCP Quickstart Guide</li> <li>Amazon: AWS Quickstart Guide</li> <li>Azure: AzureML Quickstart Guide</li> <li>Docker: Docker Quickstart Guide </li> </ul>"},{"location":"yolov5/tutorials/roboflow_datasets_integration/#project-status","title":"Project Status","text":"<p>This badge indicates that all YOLOv5 GitHub Actions Continuous Integration (CI) tests are successfully passing. These CI tests rigorously check the functionality and performance of YOLOv5 across various key aspects: training, validation, inference, export, and benchmarks. They ensure consistent and reliable operation on macOS, Windows, and Ubuntu, with tests conducted every 24 hours and upon each new commit.</p>"},{"location":"yolov5/tutorials/running_on_jetson_nano/","title":"Deploy on NVIDIA Jetson using TensorRT and DeepStream SDK","text":"<p>\ud83d\udcda This guide explains how to deploy a trained model into NVIDIA Jetson Platform and perform inference using TensorRT and DeepStream SDK. Here we use TensorRT to maximize the inference performance on the Jetson platform.</p>"},{"location":"yolov5/tutorials/running_on_jetson_nano/#hardware-verification","title":"Hardware Verification","text":"<p>We have tested and verified this guide on the following Jetson devices</p> <ul> <li>Seeed reComputer J1010 built with Jetson Nano module</li> <li>Seeed reComputer J2021 built with Jetson Xavier NX module</li> </ul>"},{"location":"yolov5/tutorials/running_on_jetson_nano/#before-you-start","title":"Before You Start","text":"<p>Make sure you have properly installed JetPack SDK with all the SDK Components and DeepStream SDK on the Jetson device as this includes CUDA, TensorRT and DeepStream SDK which are needed for this guide.</p> <p>JetPack SDK provides a full development environment for hardware-accelerated AI-at-the-edge development. All Jetson modules and developer kits are supported by JetPack SDK.</p> <p>There are two major installation methods including,</p> <ol> <li>SD Card Image Method</li> <li>NVIDIA SDK Manager Method</li> </ol> <p>You can find a very detailed installation guide from NVIDIA official website. You can also find guides corresponding to the above-mentioned reComputer J1010 and reComputer J2021.</p>"},{"location":"yolov5/tutorials/running_on_jetson_nano/#install-necessary-packages","title":"Install Necessary Packages","text":"<ul> <li>Step 1. Access the terminal of Jetson device, install pip and upgrade it</li> </ul> <pre><code>sudo apt update\nsudo apt install -y python3-pip\npip3 install --upgrade pip\n</code></pre> <ul> <li>Step 2. Clone the following repo</li> </ul> <pre><code>git clone https://github.com/ultralytics/yolov5\n</code></pre> <ul> <li>Step 3. Open requirements.txt</li> </ul> <pre><code>cd yolov5\nvi requirements.txt\n</code></pre> <ul> <li>Step 5. Edit the following lines. Here you need to press i first to enter editing mode. Press ESC, then type :wq to save and quit</li> </ul> <pre><code># torch&gt;=1.8.0\n# torchvision&gt;=0.9.0\n</code></pre> <p>Note: torch and torchvision are excluded for now because they will be installed later.</p> <ul> <li>Step 6. install the below dependency</li> </ul> <pre><code>sudo apt install -y libfreetype6-dev\n</code></pre> <ul> <li>Step 7. Install the necessary packages</li> </ul> <pre><code>pip3 install -r requirements.txt\n</code></pre>"},{"location":"yolov5/tutorials/running_on_jetson_nano/#install-pytorch-and-torchvision","title":"Install PyTorch and Torchvision","text":"<p>We cannot install PyTorch and Torchvision from pip because they are not compatible to run on Jetson platform which is based on ARM aarch64 architecture. Therefore, we need to manually install pre-built PyTorch pip wheel and compile/ install Torchvision from source.</p> <p>Visit this page to access all the PyTorch and Torchvision links.</p> <p>Here are some of the versions supported by JetPack 4.6 and above.</p> <p>PyTorch v1.10.0</p> <p>Supported by JetPack 4.4 (L4T R32.4.3) / JetPack 4.4.1 (L4T R32.4.4) / JetPack 4.5 (L4T R32.5.0) / JetPack 4.5.1 (L4T R32.5.1) / JetPack 4.6 (L4T R32.6.1) with Python 3.6</p> <ul> <li>file_name: torch-1.10.0-cp36-cp36m-linux_aarch64.whl</li> <li>URL: https://nvidia.box.com/shared/static/fjtbno0vpo676a25cgvuqc1wty0fkkg6.whl</li> </ul> <p>PyTorch v1.12.0</p> <p>Supported by JetPack 5.0 (L4T R34.1.0) / JetPack 5.0.1 (L4T R34.1.1) / JetPack 5.0.2 (L4T R35.1.0) with Python 3.8</p> <ul> <li>file_name: torch-1.12.0a0+2c916ef.nv22.3-cp38-cp38-linux_aarch64.whl</li> <li> <p>URL: https://developer.download.nvidia.com/compute/redist/jp/v50/pytorch/torch-1.12.0a0+2c916ef.nv22.3-cp38-cp38-linux_aarch64.whl</p> </li> <li> <p>Step 1. Install torch according to your JetPack version in the following format</p> </li> </ul> <pre><code>wget &lt;URL&gt; -O &lt;file_name&gt;\npip3 install &lt;file_name&gt;\n</code></pre> <p>For example, here we are running JP4.6.1, and therefore we choose PyTorch v1.10.0</p> <pre><code>cd ~\nsudo apt-get install -y libopenblas-base libopenmpi-dev\nwget https://nvidia.box.com/shared/static/fjtbno0vpo676a25cgvuqc1wty0fkkg6.whl -O torch-1.10.0-cp36-cp36m-linux_aarch64.whl\npip3 install torch-1.10.0-cp36-cp36m-linux_aarch64.whl\n</code></pre> <ul> <li>Step 2. Install torchvision depending on the version of PyTorch that you have installed. For example, we chose PyTorch v1.10.0, which means, we need to choose Torchvision v0.11.1</li> </ul> <pre><code>sudo apt install -y libjpeg-dev zlib1g-dev\ngit clone --branch v0.11.1 https://github.com/pytorch/vision torchvision\ncd torchvision\nsudo python3 setup.py install\n</code></pre> <p>Here a list of the corresponding torchvision version that you need to install according to the PyTorch version:</p> <ul> <li>PyTorch v1.10 - torchvision v0.11.1</li> <li>PyTorch v1.12 - torchvision v0.13.0</li> </ul>"},{"location":"yolov5/tutorials/running_on_jetson_nano/#deepstream-configuration-for-yolov5","title":"DeepStream Configuration for YOLOv5","text":"<ul> <li>Step 1. Clone the following repo</li> </ul> <pre><code>cd ~\ngit clone https://github.com/marcoslucianops/DeepStream-Yolo\n</code></pre> <ul> <li>Step 2. Copy gen_wts_yoloV5.py from DeepStream-Yolo/utils into yolov5 directory</li> </ul> <pre><code>cp DeepStream-Yolo/utils/gen_wts_yoloV5.py yolov5\n</code></pre> <ul> <li>Step 3. Inside the yolov5 repo, download pt file from YOLOv5 releases (example for YOLOv5s 6.1)</li> </ul> <pre><code>cd yolov5\nwget https://github.com/ultralytics/yolov5/releases/download/v6.1/yolov5s.pt\n</code></pre> <ul> <li>Step 4. Generate the cfg and wts files</li> </ul> <pre><code>python3 gen_wts_yoloV5.py -w yolov5s.pt\n</code></pre> <p>Note: To change the inference size (default: 640)</p> <pre><code>-s SIZE\n--size SIZE\n-s HEIGHT WIDTH\n--size HEIGHT WIDTH\n\nExample for 1280:\n\n-s 1280\nor\n-s 1280 1280\n</code></pre> <ul> <li>Step 5. Copy the generated cfg and wts files into the DeepStream-Yolo folder</li> </ul> <pre><code>cp yolov5s.cfg ~/DeepStream-Yolo\ncp yolov5s.wts ~/DeepStream-Yolo\n</code></pre> <ul> <li>Step 6. Open the DeepStream-Yolo folder and compile the library</li> </ul> <pre><code>cd ~/DeepStream-Yolo\nCUDA_VER=11.4 make -C nvdsinfer_custom_impl_Yolo  # for DeepStream 6.1\nCUDA_VER=10.2 make -C nvdsinfer_custom_impl_Yolo  # for DeepStream 6.0.1 / 6.0\n</code></pre> <ul> <li>Step 7. Edit the config_infer_primary_yoloV5.txt file according to your model</li> </ul> <pre><code>[property]\n...\ncustom-network-config=yolov5s.cfg\nmodel-file=yolov5s.wts\n...\n</code></pre> <ul> <li>Step 8. Edit the deepstream_app_config file</li> </ul> <pre><code>...\n[primary-gie]\n...\nconfig-file=config_infer_primary_yoloV5.txt\n</code></pre> <ul> <li>Step 9. Change the video source in deepstream_app_config file. Here a default video file is loaded as you can see below</li> </ul> <pre><code>...\n[source0]\n...\nuri=file:///opt/nvidia/deepstream/deepstream/samples/streams/sample_1080p_h264.mp4\n</code></pre>"},{"location":"yolov5/tutorials/running_on_jetson_nano/#run-the-inference","title":"Run the Inference","text":"<pre><code>deepstream-app -c deepstream_app_config.txt\n</code></pre> <p>The above result is running on Jetson Xavier NX with FP32 and YOLOv5s 640x640. We can see that the FPS is around 30.</p>"},{"location":"yolov5/tutorials/running_on_jetson_nano/#int8-calibration","title":"INT8 Calibration","text":"<p>If you want to use INT8 precision for inference, you need to follow the steps below</p> <ul> <li>Step 1. Install OpenCV</li> </ul> <pre><code>sudo apt-get install libopencv-dev\n</code></pre> <ul> <li>Step 2. Compile/recompile the nvdsinfer_custom_impl_Yolo library with OpenCV support</li> </ul> <pre><code>cd ~/DeepStream-Yolo\nCUDA_VER=11.4 OPENCV=1 make -C nvdsinfer_custom_impl_Yolo  # for DeepStream 6.1\nCUDA_VER=10.2 OPENCV=1 make -C nvdsinfer_custom_impl_Yolo  # for DeepStream 6.0.1 / 6.0\n</code></pre> <ul> <li> <p>Step 3. For COCO dataset, download the val2017, extract, and move to DeepStream-Yolo folder</p> </li> <li> <p>Step 4. Make a new directory for calibration images</p> </li> </ul> <pre><code>mkdir calibration\n</code></pre> <ul> <li>Step 5. Run the following to select 1000 random images from COCO dataset to run calibration</li> </ul> <pre><code>for jpg in $(ls -1 val2017/*.jpg | sort -R | head -1000); do \\\n    cp ${jpg} calibration/; \\\ndone\n</code></pre> <p>Note: NVIDIA recommends at least 500 images to get a good accuracy. On this example, 1000 images are chosen to get better accuracy (more images = more accuracy). Higher INT8_CALIB_BATCH_SIZE values will result in more accuracy and faster calibration speed. Set it according to you GPU memory. You can set it from head -1000. For example, for 2000 images, head -2000. This process can take a long time.</p> <ul> <li>Step 6. Create the calibration.txt file with all selected images</li> </ul> <pre><code>realpath calibration/*jpg &gt; calibration.txt\n</code></pre> <ul> <li>Step 7. Set environment variables</li> </ul> <pre><code>export INT8_CALIB_IMG_PATH=calibration.txt\nexport INT8_CALIB_BATCH_SIZE=1\n</code></pre> <ul> <li>Step 8. Update the config_infer_primary_yoloV5.txt file</li> </ul> <p>From</p> <pre><code>...\nmodel-engine-file=model_b1_gpu0_fp32.engine\n#int8-calib-file=calib.table\n...\nnetwork-mode=0\n...\n</code></pre> <p>To</p> <pre><code>...\nmodel-engine-file=model_b1_gpu0_int8.engine\nint8-calib-file=calib.table\n...\nnetwork-mode=1\n...\n</code></pre> <ul> <li>Step 9. Run the inference</li> </ul> <pre><code>deepstream-app -c deepstream_app_config.txt\n</code></pre> <p>The above result is running on Jetson Xavier NX with INT8 and YOLOv5s 640x640. We can see that the FPS is around 60.</p>"},{"location":"yolov5/tutorials/running_on_jetson_nano/#benchmark-results","title":"Benchmark results","text":"<p>The following table summarizes how different models perform on Jetson Xavier NX.</p> Model Name Precision Inference Size Inference Time (ms) FPS YOLOv5s FP32 320x320 16.66 60 FP32 640x640 33.33 30 INT8 640x640 16.66 60 YOLOv5n FP32 640x640 16.66 60"},{"location":"yolov5/tutorials/running_on_jetson_nano/#additional","title":"Additional","text":"<p>This tutorial is written by our friends at seeed @lakshanthad and Elaine</p>"},{"location":"yolov5/tutorials/test_time_augmentation/","title":"Test-Time Augmentation (TTA)","text":"<p>\ud83d\udcda This guide explains how to use Test Time Augmentation (TTA) during testing and inference for improved mAP and Recall with YOLOv5 \ud83d\ude80.</p>"},{"location":"yolov5/tutorials/test_time_augmentation/#before-you-start","title":"Before You Start","text":"<p>Clone repo and install requirements.txt in a Python&gt;=3.8.0 environment, including PyTorch&gt;=1.8. Models and datasets download automatically from the latest YOLOv5 release.</p> <pre><code>git clone https://github.com/ultralytics/yolov5  # clone\ncd yolov5\npip install -r requirements.txt  # install\n</code></pre>"},{"location":"yolov5/tutorials/test_time_augmentation/#test-normally","title":"Test Normally","text":"<p>Before trying TTA we want to establish a baseline performance to compare to. This command tests YOLOv5x on COCO val2017 at image size 640 pixels. <code>yolov5x.pt</code> is the largest and most accurate model available. Other options are <code>yolov5s.pt</code>, <code>yolov5m.pt</code> and <code>yolov5l.pt</code>, or you own checkpoint from training a custom dataset <code>./weights/best.pt</code>. For details on all available models please see our README table.</p> <pre><code>python val.py --weights yolov5x.pt --data coco.yaml --img 640 --half\n</code></pre> <p>Output:</p> <pre><code>val: data=./data/coco.yaml, weights=['yolov5x.pt'], batch_size=32, imgsz=640, conf_thres=0.001, iou_thres=0.65, task=val, device=, single_cls=False, augment=False, verbose=False, save_txt=False, save_hybrid=False, save_conf=False, save_json=True, project=runs/val, name=exp, exist_ok=False, half=True\nYOLOv5 \ud83d\ude80 v5.0-267-g6a3ee7c torch 1.9.0+cu102 CUDA:0 (Tesla P100-PCIE-16GB, 16280.875MB)\n\nFusing layers...\nModel Summary: 476 layers, 87730285 parameters, 0 gradients\n\nval: Scanning '../datasets/coco/val2017' images and labels...4952 found, 48 missing, 0 empty, 0 corrupted: 100% 5000/5000 [00:01&lt;00:00, 2846.03it/s]\nval: New cache created: ../datasets/coco/val2017.cache\n               Class     Images     Labels          P          R     mAP@.5 mAP@.5:.95: 100% 157/157 [02:30&lt;00:00,  1.05it/s]\n                 all       5000      36335      0.746      0.626       0.68       0.49\nSpeed: 0.1ms pre-process, 22.4ms inference, 1.4ms NMS per image at shape (32, 3, 640, 640)  # &lt;--- baseline speed\n\nEvaluating pycocotools mAP... saving runs/val/exp/yolov5x_predictions.json...\n...\n Average Precision  (AP) @[ IoU=0.50:0.95 | area=   all | maxDets=100 ] = 0.504  # &lt;--- baseline mAP\n Average Precision  (AP) @[ IoU=0.50      | area=   all | maxDets=100 ] = 0.688\n Average Precision  (AP) @[ IoU=0.75      | area=   all | maxDets=100 ] = 0.546\n Average Precision  (AP) @[ IoU=0.50:0.95 | area= small | maxDets=100 ] = 0.351\n Average Precision  (AP) @[ IoU=0.50:0.95 | area=medium | maxDets=100 ] = 0.551\n Average Precision  (AP) @[ IoU=0.50:0.95 | area= large | maxDets=100 ] = 0.644\n Average Recall     (AR) @[ IoU=0.50:0.95 | area=   all | maxDets=  1 ] = 0.382\n Average Recall     (AR) @[ IoU=0.50:0.95 | area=   all | maxDets= 10 ] = 0.628\n Average Recall     (AR) @[ IoU=0.50:0.95 | area=   all | maxDets=100 ] = 0.681  # &lt;--- baseline mAR\n Average Recall     (AR) @[ IoU=0.50:0.95 | area= small | maxDets=100 ] = 0.524\n Average Recall     (AR) @[ IoU=0.50:0.95 | area=medium | maxDets=100 ] = 0.735\n Average Recall     (AR) @[ IoU=0.50:0.95 | area= large | maxDets=100 ] = 0.826\n</code></pre>"},{"location":"yolov5/tutorials/test_time_augmentation/#test-with-tta","title":"Test with TTA","text":"<p>Append <code>--augment</code> to any existing <code>val.py</code> command to enable TTA, and increase the image size by about 30% for improved results. Note that inference with TTA enabled will typically take about 2-3X the time of normal inference as the images are being left-right flipped and processed at 3 different resolutions, with the outputs merged before NMS. Part of the speed decrease is simply due to larger image sizes (832 vs 640), while part is due to the actual TTA operations.</p> <pre><code>python val.py --weights yolov5x.pt --data coco.yaml --img 832 --augment --half\n</code></pre> <p>Output:</p> <pre><code>val: data=./data/coco.yaml, weights=['yolov5x.pt'], batch_size=32, imgsz=832, conf_thres=0.001, iou_thres=0.6, task=val, device=, single_cls=False, augment=True, verbose=False, save_txt=False, save_hybrid=False, save_conf=False, save_json=True, project=runs/val, name=exp, exist_ok=False, half=True\nYOLOv5 \ud83d\ude80 v5.0-267-g6a3ee7c torch 1.9.0+cu102 CUDA:0 (Tesla P100-PCIE-16GB, 16280.875MB)\n\nFusing layers...\n/usr/local/lib/python3.7/dist-packages/torch/nn/functional.py:718: UserWarning: Named tensors and all their associated APIs are an experimental feature and subject to change. Please do not use them for anything important until they are released as stable. (Triggered internally at  /pytorch/c10/core/TensorImpl.h:1156.)\n  return torch.max_pool2d(input, kernel_size, stride, padding, dilation, ceil_mode)\nModel Summary: 476 layers, 87730285 parameters, 0 gradients\nval: Scanning '../datasets/coco/val2017' images and labels...4952 found, 48 missing, 0 empty, 0 corrupted: 100% 5000/5000 [00:01&lt;00:00, 2885.61it/s]\nval: New cache created: ../datasets/coco/val2017.cache\n               Class     Images     Labels          P          R     mAP@.5 mAP@.5:.95: 100% 157/157 [07:29&lt;00:00,  2.86s/it]\n                 all       5000      36335      0.718      0.656      0.695      0.503\nSpeed: 0.2ms pre-process, 80.6ms inference, 2.7ms NMS per image at shape (32, 3, 832, 832)  # &lt;--- TTA speed\n\nEvaluating pycocotools mAP... saving runs/val/exp2/yolov5x_predictions.json...\n...\n Average Precision  (AP) @[ IoU=0.50:0.95 | area=   all | maxDets=100 ] = 0.516  # &lt;--- TTA mAP\n Average Precision  (AP) @[ IoU=0.50      | area=   all | maxDets=100 ] = 0.701\n Average Precision  (AP) @[ IoU=0.75      | area=   all | maxDets=100 ] = 0.562\n Average Precision  (AP) @[ IoU=0.50:0.95 | area= small | maxDets=100 ] = 0.361\n Average Precision  (AP) @[ IoU=0.50:0.95 | area=medium | maxDets=100 ] = 0.564\n Average Precision  (AP) @[ IoU=0.50:0.95 | area= large | maxDets=100 ] = 0.656\n Average Recall     (AR) @[ IoU=0.50:0.95 | area=   all | maxDets=  1 ] = 0.388\n Average Recall     (AR) @[ IoU=0.50:0.95 | area=   all | maxDets= 10 ] = 0.640\n Average Recall     (AR) @[ IoU=0.50:0.95 | area=   all | maxDets=100 ] = 0.696  # &lt;--- TTA mAR\n Average Recall     (AR) @[ IoU=0.50:0.95 | area= small | maxDets=100 ] = 0.553\n Average Recall     (AR) @[ IoU=0.50:0.95 | area=medium | maxDets=100 ] = 0.744\n Average Recall     (AR) @[ IoU=0.50:0.95 | area= large | maxDets=100 ] = 0.833\n</code></pre>"},{"location":"yolov5/tutorials/test_time_augmentation/#inference-with-tta","title":"Inference with TTA","text":"<p><code>detect.py</code> TTA inference operates identically to <code>val.py</code> TTA: simply append <code>--augment</code> to any existing <code>detect.py</code> command:</p> <pre><code>python detect.py --weights yolov5s.pt --img 832 --source data/images --augment\n</code></pre> <p>Output:</p> <pre><code>YOLOv5 \ud83d\ude80 v5.0-267-g6a3ee7c torch 1.9.0+cu102 CUDA:0 (Tesla P100-PCIE-16GB, 16280.875MB)\n\nDownloading https://github.com/ultralytics/yolov5/releases/download/v5.0/yolov5s.pt to yolov5s.pt...\n100% 14.1M/14.1M [00:00&lt;00:00, 81.9MB/s]\n\nFusing layers...\nModel Summary: 224 layers, 7266973 parameters, 0 gradients\nimage 1/2 /content/yolov5/data/images/bus.jpg: 832x640 4 persons, 1 bus, 1 fire hydrant, Done. (0.029s)\nimage 2/2 /content/yolov5/data/images/zidane.jpg: 480x832 3 persons, 3 ties, Done. (0.024s)\nResults saved to runs/detect/exp\nDone. (0.156s)\n</code></pre> <p></p>"},{"location":"yolov5/tutorials/test_time_augmentation/#pytorch-hub-tta","title":"PyTorch Hub TTA","text":"<p>TTA is automatically integrated into all YOLOv5 PyTorch Hub models, and can be accessed by passing <code>augment=True</code> at inference time.</p> <pre><code>import torch\n\n# Model\nmodel = torch.hub.load('ultralytics/yolov5', 'yolov5s')  # or yolov5m, yolov5x, custom\n\n# Images\nimg = 'https://ultralytics.com/images/zidane.jpg'  # or file, PIL, OpenCV, numpy, multiple\n\n# Inference\nresults = model(img, augment=True)  # &lt;--- TTA inference\n\n# Results\nresults.print()  # or .show(), .save(), .crop(), .pandas(), etc.\n</code></pre>"},{"location":"yolov5/tutorials/test_time_augmentation/#customize","title":"Customize","text":"<p>You can customize the TTA ops applied in the YOLOv5 <code>forward_augment()</code> method here.</p>"},{"location":"yolov5/tutorials/test_time_augmentation/#supported-environments","title":"Supported Environments","text":"<p>Ultralytics provides a range of ready-to-use environments, each pre-installed with essential dependencies such as CUDA, CUDNN, Python, and PyTorch, to kickstart your projects.</p> <ul> <li>Free GPU Notebooks:  </li> <li>Google Cloud: GCP Quickstart Guide</li> <li>Amazon: AWS Quickstart Guide</li> <li>Azure: AzureML Quickstart Guide</li> <li>Docker: Docker Quickstart Guide </li> </ul>"},{"location":"yolov5/tutorials/test_time_augmentation/#project-status","title":"Project Status","text":"<p>This badge indicates that all YOLOv5 GitHub Actions Continuous Integration (CI) tests are successfully passing. These CI tests rigorously check the functionality and performance of YOLOv5 across various key aspects: training, validation, inference, export, and benchmarks. They ensure consistent and reliable operation on macOS, Windows, and Ubuntu, with tests conducted every 24 hours and upon each new commit.</p>"},{"location":"yolov5/tutorials/tips_for_best_training_results/","title":"Tips for Best Training Results","text":"<p>\ud83d\udcda This guide explains how to produce the best mAP and training results with YOLOv5 \ud83d\ude80.</p> <p>Most of the time good results can be obtained with no changes to the models or training settings, provided your dataset is sufficiently large and well labelled. If at first you don't get good results, there are steps you might be able to take to improve, but we always recommend users first train with all default settings before considering any changes. This helps establish a performance baseline and spot areas for improvement.</p> <p>If you have questions about your training results we recommend you provide the maximum amount of information possible if you expect a helpful response, including results plots (train losses, val losses, P, R, mAP), PR curve, confusion matrix, training mosaics, test results and dataset statistics images such as labels.png. All of these are located in your <code>project/name</code> directory, typically <code>yolov5/runs/train/exp</code>.</p> <p>We've put together a full guide for users looking to get the best results on their YOLOv5 trainings below.</p>"},{"location":"yolov5/tutorials/tips_for_best_training_results/#dataset","title":"Dataset","text":"<ul> <li>Images per class. \u2265 1500 images per class recommended</li> <li>Instances per class. \u2265 10000 instances (labeled objects) per class recommended</li> <li>Image variety. Must be representative of deployed environment. For real-world use cases we recommend images from different times of day, different seasons, different weather, different lighting, different angles, different sources (scraped online, collected locally, different cameras) etc.</li> <li>Label consistency. All instances of all classes in all images must be labelled. Partial labelling will not work.</li> <li>Label accuracy. Labels must closely enclose each object. No space should exist between an object and it's bounding box. No objects should be missing a label.</li> <li>Label verification. View <code>train_batch*.jpg</code> on train start to verify your labels appear correct, i.e. see example mosaic.</li> <li>Background images. Background images are images with no objects that are added to a dataset to reduce False Positives (FP). We recommend about 0-10% background images to help reduce FPs (COCO has 1000 background images for reference, 1% of the total). No labels are required for background images.</li> </ul>"},{"location":"yolov5/tutorials/tips_for_best_training_results/#model-selection","title":"Model Selection","text":"<p>Larger models like YOLOv5x and YOLOv5x6 will produce better results in nearly all cases, but have more parameters, require more CUDA memory to train, and are slower to run. For mobile deployments we recommend YOLOv5s/m, for cloud deployments we recommend YOLOv5l/x. See our README table for a full comparison of all models.</p> <p></p> <ul> <li>Start from Pretrained weights. Recommended for small to medium-sized datasets (i.e. VOC, VisDrone, GlobalWheat). Pass the name of the model to the <code>--weights</code> argument. Models download automatically from the latest YOLOv5 release.</li> </ul> <pre><code>python train.py --data custom.yaml --weights yolov5s.pt\n                                             yolov5m.pt\n                                             yolov5l.pt\n                                             yolov5x.pt\n                                             custom_pretrained.pt\n</code></pre> <ul> <li>Start from Scratch. Recommended for large datasets (i.e. COCO, Objects365, OIv6). Pass the model architecture YAML you are interested in, along with an empty <code>--weights ''</code> argument:</li> </ul> <pre><code>python train.py --data custom.yaml --weights '' --cfg yolov5s.yaml\n                                                      yolov5m.yaml\n                                                      yolov5l.yaml\n                                                      yolov5x.yaml\n</code></pre>"},{"location":"yolov5/tutorials/tips_for_best_training_results/#training-settings","title":"Training Settings","text":"<p>Before modifying anything, first train with default settings to establish a performance baseline. A full list of train.py settings can be found in the train.py argparser.</p> <ul> <li>Epochs. Start with 300 epochs. If this overfits early then you can reduce epochs. If overfitting does not occur after 300 epochs, train longer, i.e. 600, 1200 etc. epochs.</li> <li>Image size. COCO trains at native resolution of <code>--img 640</code>, though due to the high amount of small objects in the dataset it can benefit from training at higher resolutions such as <code>--img 1280</code>. If there are many small objects then custom datasets will benefit from training at native or higher resolution. Best inference results are obtained at the same <code>--img</code> as the training was run at, i.e. if you train at <code>--img 1280</code> you should also test and detect at <code>--img 1280</code>.</li> <li>Batch size. Use the largest <code>--batch-size</code> that your hardware allows for. Small batch sizes produce poor batchnorm statistics and should be avoided.</li> <li>Hyperparameters. Default hyperparameters are in hyp.scratch-low.yaml. We recommend you train with default hyperparameters first before thinking of modifying any. In general, increasing augmentation hyperparameters will reduce and delay overfitting, allowing for longer trainings and higher final mAP. Reduction in loss component gain hyperparameters like <code>hyp['obj']</code> will help reduce overfitting in those specific loss components. For an automated method of optimizing these hyperparameters, see our Hyperparameter Evolution Tutorial.</li> </ul>"},{"location":"yolov5/tutorials/tips_for_best_training_results/#further-reading","title":"Further Reading","text":"<p>If you'd like to know more, a good place to start is Karpathy's 'Recipe for Training Neural Networks', which has great ideas for training that apply broadly across all ML domains: http://karpathy.github.io/2019/04/25/recipe/</p> <p>Good luck \ud83c\udf40 and let us know if you have any other questions!</p>"},{"location":"yolov5/tutorials/train_custom_data/","title":"Train Custom Data","text":"<p>\ud83d\udcda This guide explains how to train your own custom dataset with YOLOv5 \ud83d\ude80.</p>"},{"location":"yolov5/tutorials/train_custom_data/#before-you-start","title":"Before You Start","text":"<p>Clone repo and install requirements.txt in a Python&gt;=3.8.0 environment, including PyTorch&gt;=1.8. Models and datasets download automatically from the latest YOLOv5 release.</p> <pre><code>git clone https://github.com/ultralytics/yolov5  # clone\ncd yolov5\npip install -r requirements.txt  # install\n</code></pre>"},{"location":"yolov5/tutorials/train_custom_data/#train-on-custom-data","title":"Train On Custom Data","text":"<p>Creating a custom model to detect your objects is an iterative process of collecting and organizing images, labeling your objects of interest, training a model, deploying it into the wild to make predictions, and then using that deployed model to collect examples of edge cases to repeat and improve.</p> <p>Licensing</p> <p>Ultralytics offers two licensing options:</p> <ul> <li>The AGPL-3.0 License, an OSI-approved open-source license ideal for students and enthusiasts.</li> <li>The Enterprise License for businesses seeking to incorporate our AI models into their products and services.</li> </ul> <p>For more details see Ultralytics Licensing.</p>"},{"location":"yolov5/tutorials/train_custom_data/#1-create-dataset","title":"1. Create Dataset","text":"<p>YOLOv5 models must be trained on labelled data in order to learn classes of objects in that data. There are two options for creating your dataset before you start training:</p> Use Roboflow to create your dataset in YOLO format \ud83c\udf1f  ### 1.1 Collect Images  Your model will learn by example. Training on images similar to the ones it will see in the wild is of the utmost importance. Ideally, you will collect a wide variety of images from the same configuration (camera, angle, lighting, etc.) as you will ultimately deploy your project.  If this is not possible, you can start from [a public dataset](https://universe.roboflow.com/?ref=ultralytics) to train your initial model and then [sample images from the wild during inference](https://blog.roboflow.com/computer-vision-active-learning-tips/?ref=ultralytics) to improve your dataset and model iteratively.  ### 1.2 Create Labels  Once you have collected images, you will need to annotate the objects of interest to create a ground truth for your model to learn from.  <p></p>  [Roboflow Annotate](https://roboflow.com/annotate?ref=ultralytics) is a simple web-based tool for managing and labeling your images with your team and exporting them in [YOLOv5's annotation format](https://roboflow.com/formats/yolov5-pytorch-txt?ref=ultralytics).  ### 1.3 Prepare Dataset for YOLOv5  Whether you [label your images with Roboflow](https://roboflow.com/annotate?ref=ultralytics) or not, you can use it to convert your dataset into YOLO format, create a YOLOv5 YAML configuration file, and host it for importing into your training script.  [Create a free Roboflow account](https://app.roboflow.com/?model=yolov5&amp;ref=ultralytics) and upload your dataset to a `Public` workspace, label any unannotated images, then generate and export a version of your dataset in `YOLOv5 Pytorch` format.  Note: YOLOv5 does online augmentation during training, so we do not recommend applying any augmentation steps in Roboflow for training with YOLOv5. But we recommend applying the following preprocessing steps:  <p></p>  - **Auto-Orient** - to strip EXIF orientation from your images. - **Resize (Stretch)** - to the square input size of your model (640x640 is the YOLOv5 default).  Generating a version will give you a point in time snapshot of your dataset so you can always go back and compare your future model training runs against it, even if you add more images or change its configuration later.  <p></p>  Export in `YOLOv5 Pytorch` format, then copy the snippet into your training script or notebook to download your dataset.  <p></p>  Now continue with `2. Select a Model`.   Or manually prepare your dataset  ### 1.1 Create dataset.yaml  [COCO128](https://www.kaggle.com/ultralytics/coco128) is an example small tutorial dataset composed of the first 128 images in [COCO](http://cocodataset.org/#home) train2017. These same 128 images are used for both training and validation to verify our training pipeline is capable of overfitting. [data/coco128.yaml](https://github.com/ultralytics/yolov5/blob/master/data/coco128.yaml), shown below, is the dataset config file that defines 1) the dataset root directory `path` and relative paths to `train` / `val` / `test` image directories (or *.txt files with image paths) and 2) a class `names` dictionary:  <pre><code># Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]\npath: ../datasets/coco128  # dataset root dir\ntrain: images/train2017  # train images (relative to 'path') 128 images\nval: images/train2017  # val images (relative to 'path') 128 images\ntest:  # test images (optional)\n\n# Classes (80 COCO classes)\nnames:\n  0: person\n  1: bicycle\n  2: car\n  # ...\n  77: teddy bear\n  78: hair drier\n  79: toothbrush\n</code></pre>  ### 1.2 Create Labels  After using an annotation tool to label your images, export your labels to **YOLO format**, with one `*.txt` file per image (if no objects in image, no `*.txt` file is required). The `*.txt` file specifications are:  - One row per object - Each row is `class x_center y_center width height` format. - Box coordinates must be in **normalized xywh** format (from 0 to 1). If your boxes are in pixels, divide `x_center` and `width` by image width, and `y_center` and `height` by image height. - Class numbers are zero-indexed (start from 0).  <p></p>  The label file corresponding to the above image contains 2 persons (class `0`) and a tie (class `27`):  <p></p>  ### 1.3 Organize Directories  Organize your train and val images and labels according to the example below. YOLOv5 assumes  `/coco128` is inside a `/datasets` directory **next to** the `/yolov5` directory. **YOLOv5 locates labels automatically for each image** by replacing the last instance of `/images/` in each image path with `/labels/`. For example:  <pre><code>../datasets/coco128/images/im0.jpg  # image\n../datasets/coco128/labels/im0.txt  # label\n</code></pre> <p></p>"},{"location":"yolov5/tutorials/train_custom_data/#2-select-a-model","title":"2. Select a Model","text":"<p>Select a pretrained model to start training from. Here we select YOLOv5s, the second-smallest and fastest model available. See our README table for a full comparison of all models.</p> <p></p>"},{"location":"yolov5/tutorials/train_custom_data/#3-train","title":"3. Train","text":"<p>Train a YOLOv5s model on COCO128 by specifying dataset, batch-size, image size and either pretrained <code>--weights yolov5s.pt</code> (recommended), or randomly initialized <code>--weights '' --cfg yolov5s.yaml</code> (not recommended). Pretrained weights are auto-downloaded from the latest YOLOv5 release.</p> <pre><code>python train.py --img 640 --epochs 3 --data coco128.yaml --weights yolov5s.pt\n</code></pre> <p>Tip</p> <p>\ud83d\udca1 Add <code>--cache ram</code> or <code>--cache disk</code> to speed up training (requires significant RAM/disk resources).</p> <p>Tip</p> <p>\ud83d\udca1 Always train from a local dataset. Mounted or network drives like Google Drive will be very slow.</p> <p>All training results are saved to <code>runs/train/</code> with incrementing run directories, i.e. <code>runs/train/exp2</code>, <code>runs/train/exp3</code> etc. For more details see the Training section of our tutorial notebook.  </p>"},{"location":"yolov5/tutorials/train_custom_data/#4-visualize","title":"4. Visualize","text":""},{"location":"yolov5/tutorials/train_custom_data/#comet-logging-and-visualization-new","title":"Comet Logging and Visualization \ud83c\udf1f NEW","text":"<p>Comet is now fully integrated with YOLOv5. Track and visualize model metrics in real time, save your hyperparameters, datasets, and model checkpoints, and visualize your model predictions with Comet Custom Panels! Comet makes sure you never lose track of your work and makes it easy to share results and collaborate across teams of all sizes!</p> <p>Getting started is easy:</p> <pre><code>pip install comet_ml  # 1. install\nexport COMET_API_KEY=&lt;Your API Key&gt;  # 2. paste API key\npython train.py --img 640 --epochs 3 --data coco128.yaml --weights yolov5s.pt  # 3. train\n</code></pre> <p>To learn more about all the supported Comet features for this integration, check out the Comet Tutorial. If you'd like to learn more about Comet, head over to our documentation. Get started by trying out the Comet Colab Notebook: </p> <p></p>"},{"location":"yolov5/tutorials/train_custom_data/#clearml-logging-and-automation-new","title":"ClearML Logging and Automation \ud83c\udf1f NEW","text":"<p>ClearML is completely integrated into YOLOv5 to track your experimentation, manage dataset versions and even remotely execute training runs. To enable ClearML:</p> <ul> <li><code>pip install clearml</code></li> <li>run <code>clearml-init</code> to connect to a ClearML server (deploy your own open-source server here, or use our free hosted server here)</li> </ul> <p>You'll get all the great expected features from an experiment manager: live updates, model upload, experiment comparison etc. but ClearML also tracks uncommitted changes and installed packages for example. Thanks to that ClearML Tasks (which is what we call experiments) are also reproducible on different machines! With only 1 extra line, we can schedule a YOLOv5 training task on a queue to be executed by any number of ClearML Agents (workers).</p> <p>You can use ClearML Data to version your dataset and then pass it to YOLOv5 simply using its unique ID. This will help you keep track of your data without adding extra hassle. Explore the ClearML Tutorial for details!</p> <p> </p>"},{"location":"yolov5/tutorials/train_custom_data/#local-logging","title":"Local Logging","text":"<p>Training results are automatically logged with Tensorboard and CSV loggers to <code>runs/train</code>, with a new experiment directory created for each new training as <code>runs/train/exp2</code>, <code>runs/train/exp3</code>, etc.</p> <p>This directory contains train and val statistics, mosaics, labels, predictions and augmented mosaics, as well as metrics and charts including precision-recall (PR) curves and confusion matrices.</p> <p></p> <p>Results file <code>results.csv</code> is updated after each epoch, and then plotted as <code>results.png</code> (below) after training completes. You can also plot any <code>results.csv</code> file manually:</p> <pre><code>from utils.plots import plot_results\n\nplot_results('path/to/results.csv')  # plot 'results.csv' as 'results.png'\n</code></pre> <p></p>"},{"location":"yolov5/tutorials/train_custom_data/#next-steps","title":"Next Steps","text":"<p>Once your model is trained you can use your best checkpoint <code>best.pt</code> to:</p> <ul> <li>Run CLI or Python inference on new images and videos</li> <li>Validate accuracy on train, val and test splits</li> <li>Export to TensorFlow, Keras, ONNX, TFlite, TF.js, CoreML and TensorRT formats</li> <li>Evolve hyperparameters to improve performance</li> <li>Improve your model by sampling real-world images and adding them to your dataset</li> </ul>"},{"location":"yolov5/tutorials/train_custom_data/#supported-environments","title":"Supported Environments","text":"<p>Ultralytics provides a range of ready-to-use environments, each pre-installed with essential dependencies such as CUDA, CUDNN, Python, and PyTorch, to kickstart your projects.</p> <ul> <li>Free GPU Notebooks:  </li> <li>Google Cloud: GCP Quickstart Guide</li> <li>Amazon: AWS Quickstart Guide</li> <li>Azure: AzureML Quickstart Guide</li> <li>Docker: Docker Quickstart Guide </li> </ul>"},{"location":"yolov5/tutorials/train_custom_data/#project-status","title":"Project Status","text":"<p>This badge indicates that all YOLOv5 GitHub Actions Continuous Integration (CI) tests are successfully passing. These CI tests rigorously check the functionality and performance of YOLOv5 across various key aspects: training, validation, inference, export, and benchmarks. They ensure consistent and reliable operation on macOS, Windows, and Ubuntu, with tests conducted every 24 hours and upon each new commit.</p>"},{"location":"yolov5/tutorials/transfer_learning_with_frozen_layers/","title":"Transfer learning with frozen layers","text":"<p>\ud83d\udcda This guide explains how to freeze YOLOv5 \ud83d\ude80 layers when transfer learning. Transfer learning is a useful way to quickly retrain a model on new data without having to retrain the entire network. Instead, part of the initial weights are frozen in place, and the rest of the weights are used to compute loss and are updated by the optimizer. This requires less resources than normal training and allows for faster training times, though it may also result in reductions to final trained accuracy.</p>"},{"location":"yolov5/tutorials/transfer_learning_with_frozen_layers/#before-you-start","title":"Before You Start","text":"<p>Clone repo and install requirements.txt in a Python&gt;=3.8.0 environment, including PyTorch&gt;=1.8. Models and datasets download automatically from the latest YOLOv5 release.</p> <pre><code>git clone https://github.com/ultralytics/yolov5  # clone\ncd yolov5\npip install -r requirements.txt  # install\n</code></pre>"},{"location":"yolov5/tutorials/transfer_learning_with_frozen_layers/#freeze-backbone","title":"Freeze Backbone","text":"<p>All layers that match the train.py <code>freeze</code> list in train.py will be frozen by setting their gradients to zero before training starts.</p> <pre><code># Freeze\nfreeze = [f'model.{x}.' for x in range(freeze)]  # layers to freeze\nfor k, v in model.named_parameters():\n    v.requires_grad = True  # train all layers\n    if any(x in k for x in freeze):\n        print(f'freezing {k}')\n        v.requires_grad = False\n</code></pre> <p>To see a list of module names:</p> <pre><code>for k, v in model.named_parameters():\n    print(k)\n\n\"\"\"Output:\nmodel.0.conv.conv.weight\nmodel.0.conv.bn.weight\nmodel.0.conv.bn.bias\nmodel.1.conv.weight\nmodel.1.bn.weight\nmodel.1.bn.bias\nmodel.2.cv1.conv.weight\nmodel.2.cv1.bn.weight\n...\nmodel.23.m.0.cv2.bn.weight\nmodel.23.m.0.cv2.bn.bias\nmodel.24.m.0.weight\nmodel.24.m.0.bias\nmodel.24.m.1.weight\nmodel.24.m.1.bias\nmodel.24.m.2.weight\nmodel.24.m.2.bias\n\"\"\"\n</code></pre> <p>Looking at the model architecture we can see that the model backbone is layers 0-9:</p> <pre><code># YOLOv5 backbone\nbackbone:\n  # [from, number, module, args]\n  [[-1, 1, Focus, [64, 3]],  # 0-P1/2\n   [-1, 1, Conv, [128, 3, 2]],  # 1-P2/4\n   [-1, 3, BottleneckCSP, [128]],\n   [-1, 1, Conv, [256, 3, 2]],  # 3-P3/8\n   [-1, 9, BottleneckCSP, [256]],\n   [-1, 1, Conv, [512, 3, 2]],  # 5-P4/16\n   [-1, 9, BottleneckCSP, [512]],\n   [-1, 1, Conv, [1024, 3, 2]],  # 7-P5/32\n   [-1, 1, SPP, [1024, [5, 9, 13]]],\n   [-1, 3, BottleneckCSP, [1024, False]],  # 9\n  ]\n\n# YOLOv5 head\nhead:\n  [[-1, 1, Conv, [512, 1, 1]],\n   [-1, 1, nn.Upsample, [None, 2, 'nearest']],\n   [[-1, 6], 1, Concat, [1]],  # cat backbone P4\n   [-1, 3, BottleneckCSP, [512, False]],  # 13\n\n   [-1, 1, Conv, [256, 1, 1]],\n   [-1, 1, nn.Upsample, [None, 2, 'nearest']],\n   [[-1, 4], 1, Concat, [1]],  # cat backbone P3\n   [-1, 3, BottleneckCSP, [256, False]],  # 17 (P3/8-small)\n\n   [-1, 1, Conv, [256, 3, 2]],\n   [[-1, 14], 1, Concat, [1]],  # cat head P4\n   [-1, 3, BottleneckCSP, [512, False]],  # 20 (P4/16-medium)\n\n   [-1, 1, Conv, [512, 3, 2]],\n   [[-1, 10], 1, Concat, [1]],  # cat head P5\n   [-1, 3, BottleneckCSP, [1024, False]],  # 23 (P5/32-large)\n\n   [[17, 20, 23], 1, Detect, [nc, anchors]],  # Detect(P3, P4, P5)\n  ]\n</code></pre> <p>so we can define the freeze list to contain all modules with 'model.0.' - 'model.9.' in their names:</p> <pre><code>python train.py --freeze 10\n</code></pre>"},{"location":"yolov5/tutorials/transfer_learning_with_frozen_layers/#freeze-all-layers","title":"Freeze All Layers","text":"<p>To freeze the full model except for the final output convolution layers in Detect(), we set freeze list to contain all modules with 'model.0.' - 'model.23.' in their names:</p> <pre><code>python train.py --freeze 24\n</code></pre>"},{"location":"yolov5/tutorials/transfer_learning_with_frozen_layers/#results","title":"Results","text":"<p>We train YOLOv5m on VOC on both of the above scenarios, along with a default model (no freezing), starting from the official COCO pretrained <code>--weights yolov5m.pt</code>:</p> <pre><code>train.py --batch 48 --weights yolov5m.pt --data voc.yaml --epochs 50 --cache --img 512 --hyp hyp.finetune.yaml\n</code></pre>"},{"location":"yolov5/tutorials/transfer_learning_with_frozen_layers/#accuracy-comparison","title":"Accuracy Comparison","text":"<p>The results show that freezing speeds up training, but reduces final accuracy slightly.</p> <p></p> <p></p> <p></p>"},{"location":"yolov5/tutorials/transfer_learning_with_frozen_layers/#gpu-utilization-comparison","title":"GPU Utilization Comparison","text":"<p>Interestingly, the more modules are frozen the less GPU memory is required to train, and the lower GPU utilization. This indicates that larger models, or models trained at larger --image-size may benefit from freezing in order to train faster.</p> <p></p> <p></p>"},{"location":"yolov5/tutorials/transfer_learning_with_frozen_layers/#supported-environments","title":"Supported Environments","text":"<p>Ultralytics provides a range of ready-to-use environments, each pre-installed with essential dependencies such as CUDA, CUDNN, Python, and PyTorch, to kickstart your projects.</p> <ul> <li>Free GPU Notebooks:  </li> <li>Google Cloud: GCP Quickstart Guide</li> <li>Amazon: AWS Quickstart Guide</li> <li>Azure: AzureML Quickstart Guide</li> <li>Docker: Docker Quickstart Guide </li> </ul>"},{"location":"yolov5/tutorials/transfer_learning_with_frozen_layers/#project-status","title":"Project Status","text":"<p>This badge indicates that all YOLOv5 GitHub Actions Continuous Integration (CI) tests are successfully passing. These CI tests rigorously check the functionality and performance of YOLOv5 across various key aspects: training, validation, inference, export, and benchmarks. They ensure consistent and reliable operation on macOS, Windows, and Ubuntu, with tests conducted every 24 hours and upon each new commit.</p>"}]}
 <!DOCTYPE html><html class="no-js" lang="en"><head><meta charset="utf-8"/><meta content="width=device-width,initial-scale=1" name="viewport"/><meta content="Explore Ultralytics image augmentation techniques like MixUp, Mosaic, and Random Perspective for enhancing model training. Improve your deep learning models now." name="description"/><meta content="Ultralytics" name="author"/><link href="https://docs.ultralytics.com/reference/data/augment/" rel="canonical"/><link href="../annotator/" rel="prev"/><link href="../base/" rel="next"/><link href="/" hreflang="en" rel="alternate"/><link href="/zh/" hreflang="zh" rel="alternate"/><link href="/ko/" hreflang="ko" rel="alternate"/><link href="/ja/" hreflang="ja" rel="alternate"/><link href="/ru/" hreflang="ru" rel="alternate"/><link href="/de/" hreflang="de" rel="alternate"/><link href="/fr/" hreflang="fr" rel="alternate"/><link href="/es/" hreflang="es" rel="alternate"/><link href="/pt/" hreflang="pt" rel="alternate"/><link href="/it/" hreflang="it" rel="alternate"/><link href="/tr/" hreflang="tr" rel="alternate"/><link href="/vi/" hreflang="vi" rel="alternate"/><link href="/ar/" hreflang="ar" rel="alternate"/><link href="https://raw.githubusercontent.com/ultralytics/assets/refs/heads/main/logo/favicon-yolo.png" rel="icon"/><meta content="zensical-0.0.11" name="generator"/><title>Reference for ultralytics/data/augment.py - Ultralytics YOLO Docs</title><link href="../../../assets/stylesheets/modern/main.bd6182e7.min.css" rel="stylesheet"/><link href="../../../assets/stylesheets/modern/palette.dfe2e883.min.css" rel="stylesheet"/><style>:root{}</style><link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/><link href="https://fonts.googleapis.com/css?family=Inter:300,300i,400,400i,500,500i,700,700i%7CJetBrains+Mono:400,400i,700,700i&amp;display=fallback" rel="stylesheet"/><style>:root{--md-text-font:"Inter";--md-code-font:"JetBrains Mono"}</style><link href="../../../stylesheets/style.css" rel="stylesheet"/>
<script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,t)=>(e<<5)-e+t.charCodeAt(0)),0),__md_get=(e,t=localStorage,a=__md_scope)=>JSON.parse(t.getItem(a.pathname+"."+e)),__md_set=(e,t,a=localStorage,_=__md_scope)=>{try{a.setItem(_.pathname+"."+e,JSON.stringify(t))}catch(e){}},document.documentElement.setAttribute("data-platform",navigator.platform)</script>
<script id="__analytics">function __md_analytics(){function e(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],e("js",new Date),e("config","G-2M5EHKC0BH"),document.addEventListener("DOMContentLoaded",(function(){document.forms.search&&document.forms.search.query.addEventListener("blur",(function(){this.value&&e("event","search",{search_term:this.value})}));document$.subscribe((function(){var t=document.forms.feedback;if(void 0!==t)for(var a of t.querySelectorAll("[type=submit]"))a.addEventListener("click",(function(a){a.preventDefault();var n=document.location.pathname,d=this.getAttribute("data-md-value");e("event","feedback",{page:n,data:d}),t.firstElementChild.disabled=!0;var r=t.querySelector(".md-feedback__note [data-md-value='"+d+"']");r&&(r.hidden=!1)})),t.hidden=!1})),location$.subscribe((function(t){e("config","G-2M5EHKC0BH",{page_path:t.pathname})}))}));var t=document.createElement("script");t.async=!0,t.src="https://www.googletagmanager.com/gtag/js?id=G-2M5EHKC0BH",document.getElementById("__analytics").insertAdjacentElement("afterEnd",t)}</script>
<script>"undefined"!=typeof __md_analytics&&__md_analytics()</script>
<style data-doc-kind="true">.doc-kind{display:inline-flex;align-items:center;gap:0.25em;padding:0.21em 0.59em;border-radius:999px;font-weight:700;font-size:0.81em;letter-spacing:0.06em;text-transform:uppercase;line-height:1;color:var(--doc-kind-color,#f8fafc);background:var(--doc-kind-bg,rgba(255,255,255,0.12));}.doc-kind-class{--doc-kind-color:#039dfc;--doc-kind-bg:rgba(3,157,252,0.22);}.doc-kind-function{--doc-kind-color:#fc9803;--doc-kind-bg:rgba(252,152,3,0.22);}.doc-kind-method{--doc-kind-color:#ef5eff;--doc-kind-bg:rgba(239,94,255,0.22);}.doc-kind-property{--doc-kind-color:#02e835;--doc-kind-bg:rgba(2,232,53,0.22);}</style><meta content="Reference for ultralytics/data/augment.py" name="title"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" rel="stylesheet"/><meta content="website" property="og:type"/><meta content="https://docs.ultralytics.com/reference/data/augment/" property="og:url"/><meta content="Reference for ultralytics/data/augment.py" property="og:title"/><meta content="" property="og:description"/><meta content="https://raw.githubusercontent.com/ultralytics/assets/main/yolov8/banner-yolov8.png" property="og:image"/><meta content="summary_large_image" property="twitter:card"/><meta content="https://docs.ultralytics.com/reference/data/augment/" property="twitter:url"/><meta content="Reference for ultralytics/data/augment.py" property="twitter:title"/><meta content="" property="twitter:description"/><meta content="https://raw.githubusercontent.com/ultralytics/assets/main/yolov8/banner-yolov8.png" property="twitter:image"/><script type="application/ld+json">{"@context": "https://schema.org", "@type": "Article", "headline": "Reference for ultralytics/data/augment.py", "image": ["https://raw.githubusercontent.com/ultralytics/assets/main/yolov8/banner-yolov8.png"], "datePublished": "2023-11-12 02:49:37 +0100", "dateModified": "2025-11-23 19:53:50 +0100", "author": [{"@type": "Organization", "name": "Ultralytics", "url": "https://ultralytics.com/"}], "abstract": ""}</script></head><body data-md-color-accent="indigo" data-md-color-primary="indigo" data-md-color-scheme="default" dir="ltr"><input autocomplete="off" class="md-toggle" data-md-toggle="drawer" id="__drawer" type="checkbox"/><input autocomplete="off" class="md-toggle" data-md-toggle="search" id="__search" type="checkbox"/><label class="md-overlay" for="__drawer"></label><div data-md-component="skip"><a class="md-skip" href="#reference-for-ultralyticsdataaugmentpy"> Skip to content </a></div><div data-md-component="announce"><aside class="md-banner"><div class="md-banner__inner md-grid md-typeset"><a class="banner-wrapper" href="https://www.ultralytics.com/news/ultralytics-raises-30m-series-a" target="_blank"><div class="banner-content-wrapper"><img alt="Ultralytics raises $30M Series A" height="40" src="https://cdn.prod.website-files.com/680a070c3b99253410dd3dcf/691dac336b5de2ae8b398bca_writting.svg"/><div class="vc-wrapper"><img alt="Elephant" height="28" src="https://cdn.prod.website-files.com/680a070c3b99253410dd3dcf/691dac33c95408144846afc7_image%201.png"/><img alt="SquareOne" height="28" src="https://cdn.prod.website-files.com/680a070c3b99253410dd3dcf/691dac3333068d9632cc6df8_image%202.png"/></div></div></a></div></aside></div><header class="md-header md-header--shadow md-header--lifted" data-md-component="header"><nav aria-label="Header" class="md-header__inner md-grid"><a aria-label="Ultralytics YOLO Docs" class="md-header__button md-logo" data-md-component="logo" href="https://www.ultralytics.com/" title="Ultralytics YOLO Docs"><img alt="logo" src="https://raw.githubusercontent.com/ultralytics/assets/main/logo/Ultralytics_Logotype_Reverse.svg"/></a><label class="md-header__button md-icon" for="__drawer"><svg class="lucide lucide-menu" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M4 5h16M4 12h16M4 19h16"></path></svg></label><div class="md-header__title" data-md-component="header-title"><div class="md-header__ellipsis"><div class="md-header__topic"><span class="md-ellipsis"> Ultralytics YOLO Docs </span></div><div class="md-header__topic" data-md-component="header-topic"><span class="md-ellipsis"> Reference for ultralytics/data/augment.py </span></div></div></div><form class="md-header__option" data-md-component="palette"><input aria-label="Switch to light mode" class="md-option" data-md-color-accent="indigo" data-md-color-media="(prefers-color-scheme)" data-md-color-primary="indigo" data-md-color-scheme="default" id="__palette_0" name="__palette" type="radio"/><label class="md-header__button md-icon" for="__palette_1" hidden="" title="Switch to light mode"><svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="m14.3 16-.7-2h-3.2l-.7 2H7.8L11 7h2l3.2 9zM20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12zm-9.15 3.96h2.3L12 9z"></path></svg></label><input aria-label="Switch to system preference" class="md-option" data-md-color-accent="indigo" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-primary="black" data-md-color-scheme="slate" id="__palette_1" name="__palette" type="radio"/><label class="md-header__button md-icon" for="__palette_2" hidden="" title="Switch to system preference"><svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"></path></svg></label><input aria-label="Switch to dark mode" class="md-option" data-md-color-accent="indigo" data-md-color-media="(prefers-color-scheme: light)" data-md-color-primary="indigo" data-md-color-scheme="default" id="__palette_2" name="__palette" type="radio"/><label class="md-header__button md-icon" for="__palette_0" hidden="" title="Switch to dark mode"><svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"></path></svg></label></form>
<script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
<div class="md-header__option"><div class="md-select"><button aria-label="Select language" class="md-header__button md-icon"><svg class="lucide lucide-languages" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="m5 8 6 6M4 14l6-6 2-3M2 5h12M7 2h1M22 22l-5-10-5 10M14 18h6"></path></svg></button><div class="md-select__inner"><ul class="md-select__list"><li class="md-select__item"><a class="md-select__link" href="/" hreflang="en"> ğŸ‡¬ğŸ‡§ English </a></li><li class="md-select__item"><a class="md-select__link" href="/zh/" hreflang="zh"> ğŸ‡¨ğŸ‡³ ç®€ä½“ä¸­æ–‡ </a></li><li class="md-select__item"><a class="md-select__link" href="/ko/" hreflang="ko"> ğŸ‡°ğŸ‡· í•œêµ­ì–´ </a></li><li class="md-select__item"><a class="md-select__link" href="/ja/" hreflang="ja"> ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª </a></li><li class="md-select__item"><a class="md-select__link" href="/ru/" hreflang="ru"> ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹ </a></li><li class="md-select__item"><a class="md-select__link" href="/de/" hreflang="de"> ğŸ‡©ğŸ‡ª Deutsch </a></li><li class="md-select__item"><a class="md-select__link" href="/fr/" hreflang="fr"> ğŸ‡«ğŸ‡· FranÃ§ais </a></li><li class="md-select__item"><a class="md-select__link" href="/es/" hreflang="es"> ğŸ‡ªğŸ‡¸ EspaÃ±ol </a></li><li class="md-select__item"><a class="md-select__link" href="/pt/" hreflang="pt"> ğŸ‡µğŸ‡¹ PortuguÃªs </a></li><li class="md-select__item"><a class="md-select__link" href="/it/" hreflang="it"> ğŸ‡®ğŸ‡¹ Italiano </a></li><li class="md-select__item"><a class="md-select__link" href="/tr/" hreflang="tr"> ğŸ‡¹ğŸ‡· TÃ¼rkÃ§e </a></li><li class="md-select__item"><a class="md-select__link" href="/vi/" hreflang="vi"> ğŸ‡»ğŸ‡³ Tiáº¿ng Viá»‡t </a></li><li class="md-select__item"><a class="md-select__link" href="/ar/" hreflang="ar"> ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© </a></li></ul></div></div></div><div class="md-header__source"><a class="md-source" data-md-component="source" href="https://github.com/ultralytics/ultralytics" title="Go to repository"><div class="md-source__icon md-icon"><svg viewbox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2" fill="currentColor"></path></svg></div><div class="md-source__repository"> ultralytics/ultralytics </div></a></div></nav><nav aria-label="Tabs" class="md-tabs" data-md-component="tabs"><div class="md-grid"><ul class="md-tabs__list"><li class="md-tabs__item"><a class="md-tabs__link" href="../../.."> Home </a></li><li class="md-tabs__item"><a class="md-tabs__link" href="../../../quickstart/"> Quickstart </a></li><li class="md-tabs__item"><a class="md-tabs__link" href="../../../modes/"> Modes </a></li><li class="md-tabs__item"><a class="md-tabs__link" href="../../../tasks/"> Tasks </a></li><li class="md-tabs__item"><a class="md-tabs__link" href="../../../models/"> Models </a></li><li class="md-tabs__item"><a class="md-tabs__link" href="../../../datasets/"> Datasets </a></li><li class="md-tabs__item"><a class="md-tabs__link" href="../../../solutions/"> Solutions </a></li><li class="md-tabs__item"><a class="md-tabs__link" href="../../../guides/"> Guides </a></li><li class="md-tabs__item"><a class="md-tabs__link" href="../../../integrations/"> Integrations </a></li><li class="md-tabs__item"><a class="md-tabs__link" href="../../../hub/"> HUB </a></li><li class="md-tabs__item md-tabs__item--active"><a class="md-tabs__link" href="../../__init__/"> Reference </a></li><li class="md-tabs__item"><a class="md-tabs__link" href="../../../help/"> Help </a></li></ul></div></nav></header><div class="md-container" data-md-component="container"><main class="md-main" data-md-component="main"><div class="md-main__inner md-grid"><div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation"><div class="md-sidebar__scrollwrap"><div class="md-sidebar__inner"><nav aria-label="Navigation" class="md-nav md-nav--primary md-nav--lifted" data-md-level="0"><label class="md-nav__title" for="__drawer"><a aria-label="Ultralytics YOLO Docs" class="md-nav__button md-logo" data-md-component="logo" href="https://www.ultralytics.com/" title="Ultralytics YOLO Docs"><img alt="logo" src="https://raw.githubusercontent.com/ultralytics/assets/main/logo/Ultralytics_Logotype_Reverse.svg"/></a> Ultralytics YOLO Docs </label><div class="md-nav__source"><a class="md-source" data-md-component="source" href="https://github.com/ultralytics/ultralytics" title="Go to repository"><div class="md-source__icon md-icon"><svg viewbox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2" fill="currentColor"></path></svg></div><div class="md-source__repository"> ultralytics/ultralytics </div></a></div><ul class="md-nav__list" data-md-scrollfix=""><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a class="md-nav__link" href="../../.."><span class="md-ellipsis"> Home </span><span class="md-nav__icon md-icon"></span></a></li><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a class="md-nav__link" href="../../../quickstart/"><span class="md-ellipsis"> Quickstart </span><span class="md-nav__icon md-icon"></span></a></li><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a class="md-nav__link" href="../../../modes/"><span class="md-ellipsis"> Modes </span><span class="md-nav__icon md-icon"></span></a></li><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a class="md-nav__link" href="../../../tasks/"><span class="md-ellipsis"> Tasks </span><span class="md-nav__icon md-icon"></span></a></li><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a class="md-nav__link" href="../../../models/"><span class="md-ellipsis"> Models </span><span class="md-nav__icon md-icon"></span></a></li><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a class="md-nav__link" href="../../../datasets/"><span class="md-ellipsis"> Datasets </span><span class="md-nav__icon md-icon"></span></a></li><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a class="md-nav__link" href="../../../solutions/"><span class="md-ellipsis"> Solutions </span><span class="md-nav__icon md-icon"></span></a></li><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a class="md-nav__link" href="../../../guides/"><span class="md-ellipsis"> Guides </span><span class="md-nav__icon md-icon"></span></a></li><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a class="md-nav__link" href="../../../integrations/"><span class="md-ellipsis"> Integrations </span><span class="md-nav__icon md-icon"></span></a></li><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a class="md-nav__link" href="../../../hub/"><span class="md-ellipsis"> HUB </span><span class="md-nav__icon md-icon"></span></a></li><li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested"><input checked="" class="md-nav__toggle md-toggle" id="__nav_11" type="checkbox"/><label class="md-nav__link" for="__nav_11" id="__nav_11_label" tabindex=""><span class="md-ellipsis"> Reference </span><span class="md-nav__icon md-icon"></span></label><nav aria-expanded="true" aria-labelledby="__nav_11_label" class="md-nav" data-md-level="1"><label class="md-nav__title" for="__nav_11"><span class="md-nav__icon md-icon"></span> Reference </label><ul class="md-nav__list" data-md-scrollfix=""><li class="md-nav__item"><a class="md-nav__link" href="../../__init__/"><span class="md-ellipsis"> __init__ </span></a></li><li class="md-nav__item md-nav__item--section md-nav__item--nested"><input class="md-nav__toggle md-toggle" id="__nav_11_2" type="checkbox"/><label class="md-nav__link" for="__nav_11_2" id="__nav_11_2_label" tabindex=""><span class="md-ellipsis"> cfg </span><span class="md-nav__icon md-icon"></span></label><nav aria-expanded="false" aria-labelledby="__nav_11_2_label" class="md-nav" data-md-level="2"><label class="md-nav__title" for="__nav_11_2"><span class="md-nav__icon md-icon"></span> cfg </label><ul class="md-nav__list" data-md-scrollfix=""><li class="md-nav__item"><a class="md-nav__link" href="../../cfg/__init__/"><span class="md-ellipsis"> __init__ </span></a></li></ul></nav></li><li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested"><input checked="" class="md-nav__toggle md-toggle" id="__nav_11_3" type="checkbox"/><label class="md-nav__link" for="__nav_11_3" id="__nav_11_3_label" tabindex=""><span class="md-ellipsis"> data </span><span class="md-nav__icon md-icon"></span></label><nav aria-expanded="true" aria-labelledby="__nav_11_3_label" class="md-nav" data-md-level="2"><label class="md-nav__title" for="__nav_11_3"><span class="md-nav__icon md-icon"></span> data </label><ul class="md-nav__list" data-md-scrollfix=""><li class="md-nav__item"><a class="md-nav__link" href="../annotator/"><span class="md-ellipsis"> annotator </span></a></li><li class="md-nav__item md-nav__item--active"><input class="md-nav__toggle md-toggle" id="__toc" type="checkbox"/><label class="md-nav__link md-nav__link--active" for="__toc"><span class="md-ellipsis"> augment </span><span class="md-nav__icon md-icon"></span></label><a class="md-nav__link md-nav__link--active" href="./"><span class="md-ellipsis"> augment </span></a><nav aria-label="On this page" class="md-nav md-nav--secondary"><label class="md-nav__title" for="__toc"><span class="md-nav__icon md-icon"></span> On this page </label><ul class="md-nav__list" data-md-component="toc" data-md-scrollfix=""><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.BaseTransform"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> BaseTransform</span></a><nav aria-label="Class ultralytics.data.augment.BaseTransform" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.BaseTransform.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.BaseTransform.apply_image"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> apply_image</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.BaseTransform.apply_instances"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> apply_instances</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.BaseTransform.apply_semantic"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> apply_semantic</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Compose"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> Compose</span></a><nav aria-label="Class ultralytics.data.augment.Compose" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Compose.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Compose.__getitem__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __getitem__</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Compose.__repr__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __repr__</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Compose.__setitem__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __setitem__</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Compose.append"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> append</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Compose.insert"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> insert</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Compose.tolist"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> tolist</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.BaseMixTransform"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> BaseMixTransform</span></a><nav aria-label="Class ultralytics.data.augment.BaseMixTransform" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.BaseMixTransform.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.BaseMixTransform._mix_transform"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _mix_transform</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.BaseMixTransform._update_label_text"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _update_label_text</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.BaseMixTransform.get_indexes"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> get_indexes</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Mosaic"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> Mosaic</span></a><nav aria-label="Class ultralytics.data.augment.Mosaic" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Mosaic._cat_labels"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _cat_labels</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Mosaic._mix_transform"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _mix_transform</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Mosaic._mosaic3"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _mosaic3</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Mosaic._mosaic4"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _mosaic4</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Mosaic._mosaic9"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _mosaic9</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Mosaic._update_labels"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _update_labels</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Mosaic.get_indexes"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> get_indexes</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.MixUp"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> MixUp</span></a><nav aria-label="Class ultralytics.data.augment.MixUp" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.MixUp._mix_transform"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _mix_transform</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.CutMix"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> CutMix</span></a><nav aria-label="Class ultralytics.data.augment.CutMix" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.CutMix._mix_transform"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _mix_transform</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.CutMix._rand_bbox"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _rand_bbox</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.RandomPerspective"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> RandomPerspective</span></a><nav aria-label="Class ultralytics.data.augment.RandomPerspective" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.RandomPerspective.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.RandomPerspective.affine_transform"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> affine_transform</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.RandomPerspective.apply_bboxes"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> apply_bboxes</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.RandomPerspective.apply_keypoints"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> apply_keypoints</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.RandomPerspective.apply_segments"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> apply_segments</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.RandomPerspective.box_candidates"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> box_candidates</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.RandomHSV"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> RandomHSV</span></a><nav aria-label="Class ultralytics.data.augment.RandomHSV" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.RandomHSV.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.RandomFlip"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> RandomFlip</span></a><nav aria-label="Class ultralytics.data.augment.RandomFlip" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.RandomFlip.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.LetterBox"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> LetterBox</span></a><nav aria-label="Class ultralytics.data.augment.LetterBox" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.LetterBox.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.LetterBox._update_labels"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _update_labels</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.CopyPaste"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> CopyPaste</span></a><nav aria-label="Class ultralytics.data.augment.CopyPaste" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.CopyPaste.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.CopyPaste._mix_transform"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _mix_transform</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.CopyPaste._transform"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _transform</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Albumentations"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> Albumentations</span></a><nav aria-label="Class ultralytics.data.augment.Albumentations" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Albumentations.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Format"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> Format</span></a><nav aria-label="Class ultralytics.data.augment.Format" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Format.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Format._format_img"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _format_img</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Format._format_segments"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _format_segments</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.LoadVisualPrompt"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> LoadVisualPrompt</span></a><nav aria-label="Class ultralytics.data.augment.LoadVisualPrompt" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.LoadVisualPrompt.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.LoadVisualPrompt.get_visuals"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> get_visuals</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.LoadVisualPrompt.make_mask"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> make_mask</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.RandomLoadText"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> RandomLoadText</span></a><nav aria-label="Class ultralytics.data.augment.RandomLoadText" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.RandomLoadText.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.ClassifyLetterBox"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> ClassifyLetterBox</span></a><nav aria-label="Class ultralytics.data.augment.ClassifyLetterBox" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.ClassifyLetterBox.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.CenterCrop"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> CenterCrop</span></a><nav aria-label="Class ultralytics.data.augment.CenterCrop" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.CenterCrop.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.ToTensor"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> ToTensor</span></a><nav aria-label="Class ultralytics.data.augment.ToTensor" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.ToTensor.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.v8_transforms"><span class="md-ellipsis"><span class="doc-kind doc-kind-function">function</span> v8_transforms</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.classify_transforms"><span class="md-ellipsis"><span class="doc-kind doc-kind-function">function</span> classify_transforms</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.classify_augmentations"><span class="md-ellipsis"><span class="doc-kind doc-kind-function">function</span> classify_augmentations</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="../base/"><span class="md-ellipsis"> base </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../build/"><span class="md-ellipsis"> build </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../converter/"><span class="md-ellipsis"> converter </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../dataset/"><span class="md-ellipsis"> dataset </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../loaders/"><span class="md-ellipsis"> loaders </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../split/"><span class="md-ellipsis"> split </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../split_dota/"><span class="md-ellipsis"> split_dota </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../utils/"><span class="md-ellipsis"> utils </span></a></li></ul></nav></li><li class="md-nav__item md-nav__item--section md-nav__item--nested"><input class="md-nav__toggle md-toggle" id="__nav_11_4" type="checkbox"/><label class="md-nav__link" for="__nav_11_4" id="__nav_11_4_label" tabindex=""><span class="md-ellipsis"> engine </span><span class="md-nav__icon md-icon"></span></label><nav aria-expanded="false" aria-labelledby="__nav_11_4_label" class="md-nav" data-md-level="2"><label class="md-nav__title" for="__nav_11_4"><span class="md-nav__icon md-icon"></span> engine </label><ul class="md-nav__list" data-md-scrollfix=""><li class="md-nav__item"><a class="md-nav__link" href="../../engine/exporter/"><span class="md-ellipsis"> exporter </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../engine/model/"><span class="md-ellipsis"> model </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../engine/predictor/"><span class="md-ellipsis"> predictor </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../engine/results/"><span class="md-ellipsis"> results </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../engine/trainer/"><span class="md-ellipsis"> trainer </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../engine/tuner/"><span class="md-ellipsis"> tuner </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../engine/validator/"><span class="md-ellipsis"> validator </span></a></li></ul></nav></li><li class="md-nav__item md-nav__item--section md-nav__item--nested"><input class="md-nav__toggle md-toggle" id="__nav_11_5" type="checkbox"/><label class="md-nav__link" for="__nav_11_5" id="__nav_11_5_label" tabindex=""><span class="md-ellipsis"> hub </span><span class="md-nav__icon md-icon"></span></label><nav aria-expanded="false" aria-labelledby="__nav_11_5_label" class="md-nav" data-md-level="2"><label class="md-nav__title" for="__nav_11_5"><span class="md-nav__icon md-icon"></span> hub </label><ul class="md-nav__list" data-md-scrollfix=""><li class="md-nav__item"><a class="md-nav__link" href="../../hub/__init__/"><span class="md-ellipsis"> __init__ </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../hub/auth/"><span class="md-ellipsis"> auth </span></a></li><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a class="md-nav__link" href="../../hub/google/__init__/"><span class="md-ellipsis"> google </span><span class="md-nav__icon md-icon"></span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../hub/session/"><span class="md-ellipsis"> session </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../hub/utils/"><span class="md-ellipsis"> utils </span></a></li></ul></nav></li><li class="md-nav__item md-nav__item--section md-nav__item--nested"><input class="md-nav__toggle md-toggle" id="__nav_11_6" type="checkbox"/><label class="md-nav__link" for="__nav_11_6" id="__nav_11_6_label" tabindex=""><span class="md-ellipsis"> models </span><span class="md-nav__icon md-icon"></span></label><nav aria-expanded="false" aria-labelledby="__nav_11_6_label" class="md-nav" data-md-level="2"><label class="md-nav__title" for="__nav_11_6"><span class="md-nav__icon md-icon"></span> models </label><ul class="md-nav__list" data-md-scrollfix=""><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a class="md-nav__link" href="../../models/fastsam/model/"><span class="md-ellipsis"> fastsam </span><span class="md-nav__icon md-icon"></span></a></li><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a class="md-nav__link" href="../../models/nas/model/"><span class="md-ellipsis"> nas </span><span class="md-nav__icon md-icon"></span></a></li><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a class="md-nav__link" href="../../models/rtdetr/model/"><span class="md-ellipsis"> rtdetr </span><span class="md-nav__icon md-icon"></span></a></li><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a class="md-nav__link" href="../../models/sam/amg/"><span class="md-ellipsis"> sam </span><span class="md-nav__icon md-icon"></span></a></li><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a class="md-nav__link" href="../../models/utils/loss/"><span class="md-ellipsis"> utils </span><span class="md-nav__icon md-icon"></span></a></li><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a class="md-nav__link" href="../../models/yolo/classify/predict/"><span class="md-ellipsis"> yolo </span><span class="md-nav__icon md-icon"></span></a></li></ul></nav></li><li class="md-nav__item md-nav__item--section md-nav__item--nested"><input class="md-nav__toggle md-toggle" id="__nav_11_7" type="checkbox"/><label class="md-nav__link" for="__nav_11_7" id="__nav_11_7_label" tabindex=""><span class="md-ellipsis"> nn </span><span class="md-nav__icon md-icon"></span></label><nav aria-expanded="false" aria-labelledby="__nav_11_7_label" class="md-nav" data-md-level="2"><label class="md-nav__title" for="__nav_11_7"><span class="md-nav__icon md-icon"></span> nn </label><ul class="md-nav__list" data-md-scrollfix=""><li class="md-nav__item"><a class="md-nav__link" href="../../nn/autobackend/"><span class="md-ellipsis"> autobackend </span></a></li><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a class="md-nav__link" href="../../nn/modules/activation/"><span class="md-ellipsis"> modules </span><span class="md-nav__icon md-icon"></span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../nn/tasks/"><span class="md-ellipsis"> tasks </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../nn/text_model/"><span class="md-ellipsis"> text_model </span></a></li></ul></nav></li><li class="md-nav__item md-nav__item--section md-nav__item--nested"><input class="md-nav__toggle md-toggle" id="__nav_11_8" type="checkbox"/><label class="md-nav__link" for="__nav_11_8" id="__nav_11_8_label" tabindex=""><span class="md-ellipsis"> solutions </span><span class="md-nav__icon md-icon"></span></label><nav aria-expanded="false" aria-labelledby="__nav_11_8_label" class="md-nav" data-md-level="2"><label class="md-nav__title" for="__nav_11_8"><span class="md-nav__icon md-icon"></span> solutions </label><ul class="md-nav__list" data-md-scrollfix=""><li class="md-nav__item"><a class="md-nav__link" href="../../solutions/ai_gym/"><span class="md-ellipsis"> ai_gym </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../solutions/analytics/"><span class="md-ellipsis"> analytics </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../solutions/config/"><span class="md-ellipsis"> config </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../solutions/distance_calculation/"><span class="md-ellipsis"> distance_calculation </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../solutions/heatmap/"><span class="md-ellipsis"> heatmap </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../solutions/instance_segmentation/"><span class="md-ellipsis"> instance_segmentation </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../solutions/object_blurrer/"><span class="md-ellipsis"> object_blurrer </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../solutions/object_counter/"><span class="md-ellipsis"> object_counter </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../solutions/object_cropper/"><span class="md-ellipsis"> object_cropper </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../solutions/parking_management/"><span class="md-ellipsis"> parking_management </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../solutions/queue_management/"><span class="md-ellipsis"> queue_management </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../solutions/region_counter/"><span class="md-ellipsis"> region_counter </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../solutions/security_alarm/"><span class="md-ellipsis"> security_alarm </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../solutions/similarity_search/"><span class="md-ellipsis"> similarity_search </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../solutions/solutions/"><span class="md-ellipsis"> solutions </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../solutions/speed_estimation/"><span class="md-ellipsis"> speed_estimation </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../solutions/streamlit_inference/"><span class="md-ellipsis"> streamlit_inference </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../solutions/trackzone/"><span class="md-ellipsis"> trackzone </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../solutions/vision_eye/"><span class="md-ellipsis"> vision_eye </span></a></li></ul></nav></li><li class="md-nav__item md-nav__item--section md-nav__item--nested"><input class="md-nav__toggle md-toggle" id="__nav_11_9" type="checkbox"/><label class="md-nav__link" for="__nav_11_9" id="__nav_11_9_label" tabindex=""><span class="md-ellipsis"> trackers </span><span class="md-nav__icon md-icon"></span></label><nav aria-expanded="false" aria-labelledby="__nav_11_9_label" class="md-nav" data-md-level="2"><label class="md-nav__title" for="__nav_11_9"><span class="md-nav__icon md-icon"></span> trackers </label><ul class="md-nav__list" data-md-scrollfix=""><li class="md-nav__item"><a class="md-nav__link" href="../../trackers/basetrack/"><span class="md-ellipsis"> basetrack </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../trackers/bot_sort/"><span class="md-ellipsis"> bot_sort </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../trackers/byte_tracker/"><span class="md-ellipsis"> byte_tracker </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../trackers/track/"><span class="md-ellipsis"> track </span></a></li><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a class="md-nav__link" href="../../trackers/utils/gmc/"><span class="md-ellipsis"> utils </span><span class="md-nav__icon md-icon"></span></a></li></ul></nav></li><li class="md-nav__item md-nav__item--section md-nav__item--nested"><input class="md-nav__toggle md-toggle" id="__nav_11_10" type="checkbox"/><label class="md-nav__link" for="__nav_11_10" id="__nav_11_10_label" tabindex=""><span class="md-ellipsis"> utils </span><span class="md-nav__icon md-icon"></span></label><nav aria-expanded="false" aria-labelledby="__nav_11_10_label" class="md-nav" data-md-level="2"><label class="md-nav__title" for="__nav_11_10"><span class="md-nav__icon md-icon"></span> utils </label><ul class="md-nav__list" data-md-scrollfix=""><li class="md-nav__item"><a class="md-nav__link" href="../../utils/__init__/"><span class="md-ellipsis"> __init__ </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../utils/autobatch/"><span class="md-ellipsis"> autobatch </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../utils/autodevice/"><span class="md-ellipsis"> autodevice </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../utils/benchmarks/"><span class="md-ellipsis"> benchmarks </span></a></li><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a class="md-nav__link" href="../../utils/callbacks/base/"><span class="md-ellipsis"> callbacks </span><span class="md-nav__icon md-icon"></span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../utils/checks/"><span class="md-ellipsis"> checks </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../utils/cpu/"><span class="md-ellipsis"> cpu </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../utils/dist/"><span class="md-ellipsis"> dist </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../utils/downloads/"><span class="md-ellipsis"> downloads </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../utils/errors/"><span class="md-ellipsis"> errors </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../utils/events/"><span class="md-ellipsis"> events </span></a></li><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a class="md-nav__link" href="../../utils/export/engine/"><span class="md-ellipsis"> export </span><span class="md-nav__icon md-icon"></span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../utils/files/"><span class="md-ellipsis"> files </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../utils/git/"><span class="md-ellipsis"> git </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../utils/instance/"><span class="md-ellipsis"> instance </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../utils/logger/"><span class="md-ellipsis"> logger </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../utils/loss/"><span class="md-ellipsis"> loss </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../utils/metrics/"><span class="md-ellipsis"> metrics </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../utils/nms/"><span class="md-ellipsis"> nms </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../utils/ops/"><span class="md-ellipsis"> ops </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../utils/patches/"><span class="md-ellipsis"> patches </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../utils/plotting/"><span class="md-ellipsis"> plotting </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../utils/tal/"><span class="md-ellipsis"> tal </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../utils/torch_utils/"><span class="md-ellipsis"> torch_utils </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../utils/tqdm/"><span class="md-ellipsis"> tqdm </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../utils/triton/"><span class="md-ellipsis"> triton </span></a></li><li class="md-nav__item"><a class="md-nav__link" href="../../utils/tuner/"><span class="md-ellipsis"> tuner </span></a></li></ul></nav></li></ul></nav></li><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a class="md-nav__link" href="../../../help/"><span class="md-ellipsis"> Help </span><span class="md-nav__icon md-icon"></span></a></li></ul></nav></div></div></div><div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc"><div class="md-sidebar__scrollwrap"><div class="md-sidebar__inner"><nav aria-label="On this page" class="md-nav md-nav--secondary"><label class="md-nav__title" for="__toc"><span class="md-nav__icon md-icon"></span> On this page </label><ul class="md-nav__list" data-md-component="toc" data-md-scrollfix=""><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.BaseTransform"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> BaseTransform</span></a><nav aria-label="Class ultralytics.data.augment.BaseTransform" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.BaseTransform.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.BaseTransform.apply_image"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> apply_image</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.BaseTransform.apply_instances"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> apply_instances</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.BaseTransform.apply_semantic"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> apply_semantic</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Compose"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> Compose</span></a><nav aria-label="Class ultralytics.data.augment.Compose" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Compose.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Compose.__getitem__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __getitem__</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Compose.__repr__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __repr__</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Compose.__setitem__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __setitem__</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Compose.append"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> append</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Compose.insert"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> insert</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Compose.tolist"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> tolist</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.BaseMixTransform"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> BaseMixTransform</span></a><nav aria-label="Class ultralytics.data.augment.BaseMixTransform" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.BaseMixTransform.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.BaseMixTransform._mix_transform"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _mix_transform</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.BaseMixTransform._update_label_text"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _update_label_text</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.BaseMixTransform.get_indexes"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> get_indexes</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Mosaic"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> Mosaic</span></a><nav aria-label="Class ultralytics.data.augment.Mosaic" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Mosaic._cat_labels"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _cat_labels</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Mosaic._mix_transform"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _mix_transform</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Mosaic._mosaic3"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _mosaic3</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Mosaic._mosaic4"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _mosaic4</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Mosaic._mosaic9"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _mosaic9</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Mosaic._update_labels"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _update_labels</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Mosaic.get_indexes"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> get_indexes</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.MixUp"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> MixUp</span></a><nav aria-label="Class ultralytics.data.augment.MixUp" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.MixUp._mix_transform"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _mix_transform</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.CutMix"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> CutMix</span></a><nav aria-label="Class ultralytics.data.augment.CutMix" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.CutMix._mix_transform"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _mix_transform</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.CutMix._rand_bbox"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _rand_bbox</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.RandomPerspective"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> RandomPerspective</span></a><nav aria-label="Class ultralytics.data.augment.RandomPerspective" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.RandomPerspective.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.RandomPerspective.affine_transform"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> affine_transform</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.RandomPerspective.apply_bboxes"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> apply_bboxes</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.RandomPerspective.apply_keypoints"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> apply_keypoints</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.RandomPerspective.apply_segments"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> apply_segments</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.RandomPerspective.box_candidates"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> box_candidates</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.RandomHSV"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> RandomHSV</span></a><nav aria-label="Class ultralytics.data.augment.RandomHSV" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.RandomHSV.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.RandomFlip"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> RandomFlip</span></a><nav aria-label="Class ultralytics.data.augment.RandomFlip" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.RandomFlip.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.LetterBox"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> LetterBox</span></a><nav aria-label="Class ultralytics.data.augment.LetterBox" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.LetterBox.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.LetterBox._update_labels"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _update_labels</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.CopyPaste"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> CopyPaste</span></a><nav aria-label="Class ultralytics.data.augment.CopyPaste" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.CopyPaste.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.CopyPaste._mix_transform"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _mix_transform</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.CopyPaste._transform"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _transform</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Albumentations"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> Albumentations</span></a><nav aria-label="Class ultralytics.data.augment.Albumentations" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Albumentations.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Format"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> Format</span></a><nav aria-label="Class ultralytics.data.augment.Format" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Format.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Format._format_img"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _format_img</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.Format._format_segments"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> _format_segments</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.LoadVisualPrompt"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> LoadVisualPrompt</span></a><nav aria-label="Class ultralytics.data.augment.LoadVisualPrompt" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.LoadVisualPrompt.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.LoadVisualPrompt.get_visuals"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> get_visuals</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.LoadVisualPrompt.make_mask"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> make_mask</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.RandomLoadText"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> RandomLoadText</span></a><nav aria-label="Class ultralytics.data.augment.RandomLoadText" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.RandomLoadText.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.ClassifyLetterBox"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> ClassifyLetterBox</span></a><nav aria-label="Class ultralytics.data.augment.ClassifyLetterBox" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.ClassifyLetterBox.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.CenterCrop"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> CenterCrop</span></a><nav aria-label="Class ultralytics.data.augment.CenterCrop" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.CenterCrop.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.ToTensor"><span class="md-ellipsis"><span class="doc-kind doc-kind-class">class</span> ToTensor</span></a><nav aria-label="Class ultralytics.data.augment.ToTensor" class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.ToTensor.__call__"><span class="md-ellipsis"><span class="doc-kind doc-kind-method">method</span> __call__</span></a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.v8_transforms"><span class="md-ellipsis"><span class="doc-kind doc-kind-function">function</span> v8_transforms</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.classify_transforms"><span class="md-ellipsis"><span class="doc-kind doc-kind-function">function</span> classify_transforms</span></a></li><li class="md-nav__item"><a class="md-nav__link" href="#ultralytics.data.augment.classify_augmentations"><span class="md-ellipsis"><span class="doc-kind doc-kind-function">function</span> classify_augmentations</span></a></li></ul></nav></div></div></div><div class="md-content" data-md-component="content"><article class="md-content__inner md-typeset"><a class="md-content__button md-icon" href="https://github.com/ultralytics/ultralytics/tree/main/docs/en/reference/data/augment.md" rel="edit" title="Edit this page"><svg class="lucide lucide-file-pen" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12.5 22H18a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v9.5"></path><path d="M14 2v4a2 2 0 0 0 2 2h4M13.378 15.626a1 1 0 1 0-3.004-3.004l-5.01 5.012a2 2 0 0 0-.506.854l-.837 2.87a.5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z"></path></svg></a><h1 id="reference-for-ultralyticsdataaugmentpy">Reference for <code>ultralytics/data/augment.py</code></h1><div class="admonition success"><p class="admonition-title">Improvements</p><p>This page is sourced from <a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py">https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py</a>. Have an improvement or example to add? Open a <a href="https://docs.ultralytics.com/help/contributing/">Pull Request</a> â€” thank you! ğŸ™</p></div><p><br/></p><div class="admonition abstract"><p class="admonition-title">Summary</p><div class="tabbed-set tabbed-alternate" data-tabs="1:3"><input checked="checked" id="classes" name="__tabbed_1" type="radio"/><input id="methods" name="__tabbed_1" type="radio"/><input id="functions" name="__tabbed_1" type="radio"/><div class="tabbed-labels"><label for="classes"><span class="doc-kind doc-kind-class">Classes</span></label><label for="methods"><span class="doc-kind doc-kind-method">Methods</span></label><label for="functions"><span class="doc-kind doc-kind-function">Functions</span></label></div><div class="tabbed-content"><div class="tabbed-block"><ul><li><a href="#ultralytics.data.augment.BaseTransform"><code>BaseTransform</code></a></li><li><a href="#ultralytics.data.augment.Compose"><code>Compose</code></a></li><li><a href="#ultralytics.data.augment.BaseMixTransform"><code>BaseMixTransform</code></a></li><li><a href="#ultralytics.data.augment.Mosaic"><code>Mosaic</code></a></li><li><a href="#ultralytics.data.augment.MixUp"><code>MixUp</code></a></li><li><a href="#ultralytics.data.augment.CutMix"><code>CutMix</code></a></li><li><a href="#ultralytics.data.augment.RandomPerspective"><code>RandomPerspective</code></a></li><li><a href="#ultralytics.data.augment.RandomHSV"><code>RandomHSV</code></a></li><li><a href="#ultralytics.data.augment.RandomFlip"><code>RandomFlip</code></a></li><li><a href="#ultralytics.data.augment.LetterBox"><code>LetterBox</code></a></li><li><a href="#ultralytics.data.augment.CopyPaste"><code>CopyPaste</code></a></li><li><a href="#ultralytics.data.augment.Albumentations"><code>Albumentations</code></a></li><li><a href="#ultralytics.data.augment.Format"><code>Format</code></a></li><li><a href="#ultralytics.data.augment.LoadVisualPrompt"><code>LoadVisualPrompt</code></a></li><li><a href="#ultralytics.data.augment.RandomLoadText"><code>RandomLoadText</code></a></li><li><a href="#ultralytics.data.augment.ClassifyLetterBox"><code>ClassifyLetterBox</code></a></li><li><a href="#ultralytics.data.augment.CenterCrop"><code>CenterCrop</code></a></li><li><a href="#ultralytics.data.augment.ToTensor"><code>ToTensor</code></a></li></ul></div><div class="tabbed-block"><ul><li><a href="#ultralytics.data.augment.BaseTransform.apply_image"><code>BaseTransform.apply_image</code></a></li><li><a href="#ultralytics.data.augment.BaseTransform.apply_instances"><code>BaseTransform.apply_instances</code></a></li><li><a href="#ultralytics.data.augment.BaseTransform.apply_semantic"><code>BaseTransform.apply_semantic</code></a></li><li><a href="#ultralytics.data.augment.BaseTransform.__call__"><code>BaseTransform.__call__</code></a></li><li><a href="#ultralytics.data.augment.Compose.__call__"><code>Compose.__call__</code></a></li><li><a href="#ultralytics.data.augment.Compose.append"><code>Compose.append</code></a></li><li><a href="#ultralytics.data.augment.Compose.insert"><code>Compose.insert</code></a></li><li><a href="#ultralytics.data.augment.Compose.__getitem__"><code>Compose.__getitem__</code></a></li><li><a href="#ultralytics.data.augment.Compose.__setitem__"><code>Compose.__setitem__</code></a></li><li><a href="#ultralytics.data.augment.Compose.tolist"><code>Compose.tolist</code></a></li><li><a href="#ultralytics.data.augment.Compose.__repr__"><code>Compose.__repr__</code></a></li><li><a href="#ultralytics.data.augment.BaseMixTransform.__call__"><code>BaseMixTransform.__call__</code></a></li><li><a href="#ultralytics.data.augment.BaseMixTransform._mix_transform"><code>BaseMixTransform._mix_transform</code></a></li><li><a href="#ultralytics.data.augment.BaseMixTransform.get_indexes"><code>BaseMixTransform.get_indexes</code></a></li><li><a href="#ultralytics.data.augment.BaseMixTransform._update_label_text"><code>BaseMixTransform._update_label_text</code></a></li><li><a href="#ultralytics.data.augment.Mosaic.get_indexes"><code>Mosaic.get_indexes</code></a></li><li><a href="#ultralytics.data.augment.Mosaic._mix_transform"><code>Mosaic._mix_transform</code></a></li><li><a href="#ultralytics.data.augment.Mosaic._mosaic3"><code>Mosaic._mosaic3</code></a></li><li><a href="#ultralytics.data.augment.Mosaic._mosaic4"><code>Mosaic._mosaic4</code></a></li><li><a href="#ultralytics.data.augment.Mosaic._mosaic9"><code>Mosaic._mosaic9</code></a></li><li><a href="#ultralytics.data.augment.Mosaic._update_labels"><code>Mosaic._update_labels</code></a></li><li><a href="#ultralytics.data.augment.Mosaic._cat_labels"><code>Mosaic._cat_labels</code></a></li><li><a href="#ultralytics.data.augment.MixUp._mix_transform"><code>MixUp._mix_transform</code></a></li><li><a href="#ultralytics.data.augment.CutMix._rand_bbox"><code>CutMix._rand_bbox</code></a></li><li><a href="#ultralytics.data.augment.CutMix._mix_transform"><code>CutMix._mix_transform</code></a></li><li><a href="#ultralytics.data.augment.RandomPerspective.affine_transform"><code>RandomPerspective.affine_transform</code></a></li><li><a href="#ultralytics.data.augment.RandomPerspective.apply_bboxes"><code>RandomPerspective.apply_bboxes</code></a></li><li><a href="#ultralytics.data.augment.RandomPerspective.apply_segments"><code>RandomPerspective.apply_segments</code></a></li><li><a href="#ultralytics.data.augment.RandomPerspective.apply_keypoints"><code>RandomPerspective.apply_keypoints</code></a></li><li><a href="#ultralytics.data.augment.RandomPerspective.__call__"><code>RandomPerspective.__call__</code></a></li><li><a href="#ultralytics.data.augment.RandomPerspective.box_candidates"><code>RandomPerspective.box_candidates</code></a></li><li><a href="#ultralytics.data.augment.RandomHSV.__call__"><code>RandomHSV.__call__</code></a></li><li><a href="#ultralytics.data.augment.RandomFlip.__call__"><code>RandomFlip.__call__</code></a></li><li><a href="#ultralytics.data.augment.LetterBox.__call__"><code>LetterBox.__call__</code></a></li><li><a href="#ultralytics.data.augment.LetterBox._update_labels"><code>LetterBox._update_labels</code></a></li><li><a href="#ultralytics.data.augment.CopyPaste._mix_transform"><code>CopyPaste._mix_transform</code></a></li><li><a href="#ultralytics.data.augment.CopyPaste.__call__"><code>CopyPaste.__call__</code></a></li><li><a href="#ultralytics.data.augment.CopyPaste._transform"><code>CopyPaste._transform</code></a></li><li><a href="#ultralytics.data.augment.Albumentations.__call__"><code>Albumentations.__call__</code></a></li><li><a href="#ultralytics.data.augment.Format.__call__"><code>Format.__call__</code></a></li><li><a href="#ultralytics.data.augment.Format._format_img"><code>Format._format_img</code></a></li><li><a href="#ultralytics.data.augment.Format._format_segments"><code>Format._format_segments</code></a></li><li><a href="#ultralytics.data.augment.LoadVisualPrompt.make_mask"><code>LoadVisualPrompt.make_mask</code></a></li><li><a href="#ultralytics.data.augment.LoadVisualPrompt.__call__"><code>LoadVisualPrompt.__call__</code></a></li><li><a href="#ultralytics.data.augment.LoadVisualPrompt.get_visuals"><code>LoadVisualPrompt.get_visuals</code></a></li><li><a href="#ultralytics.data.augment.RandomLoadText.__call__"><code>RandomLoadText.__call__</code></a></li><li><a href="#ultralytics.data.augment.ClassifyLetterBox.__call__"><code>ClassifyLetterBox.__call__</code></a></li><li><a href="#ultralytics.data.augment.CenterCrop.__call__"><code>CenterCrop.__call__</code></a></li><li><a href="#ultralytics.data.augment.ToTensor.__call__"><code>ToTensor.__call__</code></a></li></ul></div><div class="tabbed-block"><ul><li><a href="#ultralytics.data.augment.v8_transforms"><code>v8_transforms</code></a></li><li><a href="#ultralytics.data.augment.classify_transforms"><code>classify_transforms</code></a></li><li><a href="#ultralytics.data.augment.classify_augmentations"><code>classify_augmentations</code></a></li></ul></div></div></div></div><h2 id="ultralytics.data.augment.BaseTransform"><span class="doc-kind doc-kind-class">class</span> <code>ultralytics.data.augment.BaseTransform</code></h2><div class="highlight"><pre><span></span><code><span></span><span class="n">BaseTransform</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div><p>Base class for image transformations in the Ultralytics library.</p><p>This class serves as a foundation for implementing various image processing operations, designed to be compatible with both classification and semantic segmentation tasks.</p><p>This constructor sets up the base transformation object, which can be extended for specific image processing tasks. It is designed to be compatible with both classification and semantic segmentation.</p><p><strong>Methods</strong></p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="#ultralytics.data.augment.BaseTransform.__call__"><code>__call__</code></a></td><td>Apply all label transformations to an image, instances, and semantic masks.</td></tr><tr><td><a href="#ultralytics.data.augment.BaseTransform.apply_image"><code>apply_image</code></a></td><td>Apply image transformations to labels.</td></tr><tr><td><a href="#ultralytics.data.augment.BaseTransform.apply_instances"><code>apply_instances</code></a></td><td>Apply transformations to object instances in labels.</td></tr><tr><td><a href="#ultralytics.data.augment.BaseTransform.apply_semantic"><code>apply_semantic</code></a></td><td>Apply semantic segmentation transformations to an image.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">BaseTransform</span><span class="p">()</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">labels</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"image"</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="o">...</span><span class="p">),</span> <span class="s2">"instances"</span><span class="p">:</span> <span class="p">[</span><span class="o">...</span><span class="p">],</span> <span class="s2">"semantic"</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="o">...</span><span class="p">)}</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transformed_labels</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L28-L136"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">class</span><span class="w"> </span><span class="nc">BaseTransform</span><span class="p">:</span>
<span></span><span class="w">    </span><span class="sd">"""Base class for image transformations in the Ultralytics library.</span>
<span></span>
<span></span><span class="sd">    This class serves as a foundation for implementing various image processing operations, designed to be compatible</span>
<span></span><span class="sd">    with both classification and semantic segmentation tasks.</span>
<span></span>
<span></span><span class="sd">    Methods:</span>
<span></span><span class="sd">        apply_image: Apply image transformations to labels.</span>
<span></span><span class="sd">        apply_instances: Apply transformations to object instances in labels.</span>
<span></span><span class="sd">        apply_semantic: Apply semantic segmentation to an image.</span>
<span></span><span class="sd">        __call__: Apply all label transformations to an image, instances, and semantic masks.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; transform = BaseTransform()</span>
<span></span><span class="sd">        &gt;&gt;&gt; labels = {"image": np.array(...), "instances": [...], "semantic": np.array(...)}</span>
<span></span><span class="sd">        &gt;&gt;&gt; transformed_labels = transform(labels)</span>
<span></span><span class="sd">    """</span>
<span></span>
<span></span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span></span><span class="w">        </span><span class="sd">"""Initialize the BaseTransform object.</span>
<span></span>
<span></span><span class="sd">        This constructor sets up the base transformation object, which can be extended for specific image processing</span>
<span></span><span class="sd">        tasks. It is designed to be compatible with both classification and semantic segmentation.</span>
<span></span><span class="sd">        """</span>
<span></span>        <span class="k">pass</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.BaseTransform.__call__"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.BaseTransform.__call__</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
</code></pre></div><p>Apply all label transformations to an image, instances, and semantic masks.</p><p>This method orchestrates the application of various transformations defined in the BaseTransform class to the input labels. It sequentially calls the apply_image and apply_instances methods to process the image and object instances, respectively.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>labels</code></td><td><code>dict</code></td><td>A dictionary containing image data and annotations. Expected keys include 'img' for the image data, and 'instances' for object instances.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dict</code></td><td>The input labels dictionary with transformed image and instances.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">BaseTransform</span><span class="p">()</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">labels</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"img"</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">"instances"</span><span class="p">:</span> <span class="p">[]}</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transformed_labels</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L115-L136"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
<span></span><span class="w">    </span><span class="sd">"""Apply all label transformations to an image, instances, and semantic masks.</span>
<span></span>
<span></span><span class="sd">    This method orchestrates the application of various transformations defined in the BaseTransform class to the</span>
<span></span><span class="sd">    input labels. It sequentially calls the apply_image and apply_instances methods to process the image and object</span>
<span></span><span class="sd">    instances, respectively.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        labels (dict): A dictionary containing image data and annotations. Expected keys include 'img' for the image</span>
<span></span><span class="sd">            data, and 'instances' for object instances.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (dict): The input labels dictionary with transformed image and instances.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; transform = BaseTransform()</span>
<span></span><span class="sd">        &gt;&gt;&gt; labels = {"img": np.random.rand(640, 640, 3), "instances": []}</span>
<span></span><span class="sd">        &gt;&gt;&gt; transformed_labels = transform(labels)</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="bp">self</span><span class="o">.</span><span class="n">apply_image</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span></span>    <span class="bp">self</span><span class="o">.</span><span class="n">apply_instances</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span></span>    <span class="bp">self</span><span class="o">.</span><span class="n">apply_semantic</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.BaseTransform.apply_image"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.BaseTransform.apply_image</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">apply_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
</code></pre></div><p>Apply image transformations to labels.</p><p>This method is intended to be overridden by subclasses to implement specific image transformation logic. In its base form, it returns the input labels unchanged.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>labels</code></td><td><code>Any</code></td><td>The input labels to be transformed. The exact type and structure of labels may vary depending on the specific implementation.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>Any</code></td><td>The transformed labels. In the base implementation, this is identical to the input.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">BaseTransform</span><span class="p">()</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">original_labels</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transformed_labels</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">apply_image</span><span class="p">(</span><span class="n">original_labels</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">transformed_labels</span><span class="p">)</span>
<span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L54-L74"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">apply_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
<span></span><span class="w">    </span><span class="sd">"""Apply image transformations to labels.</span>
<span></span>
<span></span><span class="sd">    This method is intended to be overridden by subclasses to implement specific image transformation</span>
<span></span><span class="sd">    logic. In its base form, it returns the input labels unchanged.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        labels (Any): The input labels to be transformed. The exact type and structure of labels may vary depending</span>
<span></span><span class="sd">            on the specific implementation.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (Any): The transformed labels. In the base implementation, this is identical to the input.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; transform = BaseTransform()</span>
<span></span><span class="sd">        &gt;&gt;&gt; original_labels = [1, 2, 3]</span>
<span></span><span class="sd">        &gt;&gt;&gt; transformed_labels = transform.apply_image(original_labels)</span>
<span></span><span class="sd">        &gt;&gt;&gt; print(transformed_labels)</span>
<span></span><span class="sd">        [1, 2, 3]</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="k">pass</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.BaseTransform.apply_instances"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.BaseTransform.apply_instances</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">apply_instances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
</code></pre></div><p>Apply transformations to object instances in labels.</p><p>This method is responsible for applying various transformations to object instances within the given labels. It is designed to be overridden by subclasses to implement specific instance transformation logic.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>labels</code></td><td><code>dict</code></td><td>A dictionary containing label information, including object instances.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dict</code></td><td>The modified labels dictionary with transformed object instances.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">BaseTransform</span><span class="p">()</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">labels</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"instances"</span><span class="p">:</span> <span class="n">Instances</span><span class="p">(</span><span class="n">xyxy</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="bp">cls</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,)))}</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transformed_labels</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">apply_instances</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L76-L94"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">apply_instances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
<span></span><span class="w">    </span><span class="sd">"""Apply transformations to object instances in labels.</span>
<span></span>
<span></span><span class="sd">    This method is responsible for applying various transformations to object instances within the given</span>
<span></span><span class="sd">    labels. It is designed to be overridden by subclasses to implement specific instance transformation</span>
<span></span><span class="sd">    logic.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        labels (dict): A dictionary containing label information, including object instances.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (dict): The modified labels dictionary with transformed object instances.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; transform = BaseTransform()</span>
<span></span><span class="sd">        &gt;&gt;&gt; labels = {"instances": Instances(xyxy=torch.rand(5, 4), cls=torch.randint(0, 80, (5,)))}</span>
<span></span><span class="sd">        &gt;&gt;&gt; transformed_labels = transform.apply_instances(labels)</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="k">pass</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.BaseTransform.apply_semantic"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.BaseTransform.apply_semantic</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">apply_semantic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
</code></pre></div><p>Apply semantic segmentation transformations to an image.</p><p>This method is intended to be overridden by subclasses to implement specific semantic segmentation transformations. In its base form, it does not perform any operations.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>labels</code></td><td><code>Any</code></td><td>The input labels or semantic segmentation mask to be transformed.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>Any</code></td><td>The transformed semantic segmentation mask or labels.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">BaseTransform</span><span class="p">()</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">semantic_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transformed_mask</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">apply_semantic</span><span class="p">(</span><span class="n">semantic_mask</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L96-L113"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">apply_semantic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
<span></span><span class="w">    </span><span class="sd">"""Apply semantic segmentation transformations to an image.</span>
<span></span>
<span></span><span class="sd">    This method is intended to be overridden by subclasses to implement specific semantic segmentation</span>
<span></span><span class="sd">    transformations. In its base form, it does not perform any operations.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        labels (Any): The input labels or semantic segmentation mask to be transformed.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (Any): The transformed semantic segmentation mask or labels.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; transform = BaseTransform()</span>
<span></span><span class="sd">        &gt;&gt;&gt; semantic_mask = np.zeros((100, 100), dtype=np.uint8)</span>
<span></span><span class="sd">        &gt;&gt;&gt; transformed_mask = transform.apply_semantic(semantic_mask)</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="k">pass</span>
</code></pre></div></details><p><br/><br/><hr/><br/></p><h2 id="ultralytics.data.augment.Compose"><span class="doc-kind doc-kind-class">class</span> <code>ultralytics.data.augment.Compose</code></h2><div class="highlight"><pre><span></span><code><span></span><span class="n">Compose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transforms</span><span class="p">)</span>
</code></pre></div><p>A class for composing multiple image transformations.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>transforms</code></td><td><code>list[Callable]</code></td><td>A list of callable transform objects to be applied sequentially.</td><td><em>required</em></td></tr></tbody></table><p><strong>Attributes</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>transforms</code></td><td><code>list[Callable]</code></td><td>A list of transformation functions to be applied sequentially.</td></tr></tbody></table><p><strong>Methods</strong></p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="#ultralytics.data.augment.Compose.__call__"><code>__call__</code></a></td><td>Apply a series of transformations to input data.</td></tr><tr><td><a href="#ultralytics.data.augment.Compose.__getitem__"><code>__getitem__</code></a></td><td>Retrieve a specific transform or a set of transforms using indexing.</td></tr><tr><td><a href="#ultralytics.data.augment.Compose.__repr__"><code>__repr__</code></a></td><td>Return a string representation of the Compose object.</td></tr><tr><td><a href="#ultralytics.data.augment.Compose.__setitem__"><code>__setitem__</code></a></td><td>Set one or more transforms in the composition using indexing.</td></tr><tr><td><a href="#ultralytics.data.augment.Compose.append"><code>append</code></a></td><td>Append a new transform to the existing list of transforms.</td></tr><tr><td><a href="#ultralytics.data.augment.Compose.insert"><code>insert</code></a></td><td>Insert a new transform at a specified index in the existing list of transforms.</td></tr><tr><td><a href="#ultralytics.data.augment.Compose.tolist"><code>tolist</code></a></td><td>Convert the list of transforms to a standard Python list.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transforms</span> <span class="o">=</span> <span class="p">[</span><span class="n">RandomFlip</span><span class="p">(),</span> <span class="n">RandomPerspective</span><span class="p">(</span><span class="mi">30</span><span class="p">)]</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">compose</span> <span class="o">=</span> <span class="n">Compose</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transformed_data</span> <span class="o">=</span> <span class="n">compose</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">compose</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">CenterCrop</span><span class="p">((</span><span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">)))</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">compose</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">RandomFlip</span><span class="p">())</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L139-L294"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Compose</span><span class="p">:</span>
<span></span><span class="w">    </span><span class="sd">"""A class for composing multiple image transformations.</span>
<span></span>
<span></span><span class="sd">    Attributes:</span>
<span></span><span class="sd">        transforms (list[Callable]): A list of transformation functions to be applied sequentially.</span>
<span></span>
<span></span><span class="sd">    Methods:</span>
<span></span><span class="sd">        __call__: Apply a series of transformations to input data.</span>
<span></span><span class="sd">        append: Append a new transform to the existing list of transforms.</span>
<span></span><span class="sd">        insert: Insert a new transform at a specified index in the list of transforms.</span>
<span></span><span class="sd">        __getitem__: Retrieve a specific transform or a set of transforms using indexing.</span>
<span></span><span class="sd">        __setitem__: Set a specific transform or a set of transforms using indexing.</span>
<span></span><span class="sd">        tolist: Convert the list of transforms to a standard Python list.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; transforms = [RandomFlip(), RandomPerspective(30)]</span>
<span></span><span class="sd">        &gt;&gt;&gt; compose = Compose(transforms)</span>
<span></span><span class="sd">        &gt;&gt;&gt; transformed_data = compose(data)</span>
<span></span><span class="sd">        &gt;&gt;&gt; compose.append(CenterCrop((224, 224)))</span>
<span></span><span class="sd">        &gt;&gt;&gt; compose.insert(0, RandomFlip())</span>
<span></span><span class="sd">    """</span>
<span></span>
<span></span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transforms</span><span class="p">):</span>
<span></span><span class="w">        </span><span class="sd">"""Initialize the Compose object with a list of transforms.</span>
<span></span>
<span></span><span class="sd">        Args:</span>
<span></span><span class="sd">            transforms (list[Callable]): A list of callable transform objects to be applied sequentially.</span>
<span></span><span class="sd">        """</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span> <span class="o">=</span> <span class="n">transforms</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transforms</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">transforms</span><span class="p">]</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.Compose.__call__"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.Compose.__call__</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</code></pre></div><p>Apply a series of transformations to input data.</p><p>This method sequentially applies each transformation in the Compose object's transforms to the input data.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>data</code></td><td><code>Any</code></td><td>The input data to be transformed. This can be of any type, depending on the transformations in the list.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>Any</code></td><td>The transformed data after applying all transformations in sequence.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transforms</span> <span class="o">=</span> <span class="p">[</span><span class="n">Transform1</span><span class="p">(),</span> <span class="n">Transform2</span><span class="p">(),</span> <span class="n">Transform3</span><span class="p">()]</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">compose</span> <span class="o">=</span> <span class="n">Compose</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transformed_data</span> <span class="o">=</span> <span class="n">compose</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L169-L188"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span></span><span class="w">    </span><span class="sd">"""Apply a series of transformations to input data.</span>
<span></span>
<span></span><span class="sd">    This method sequentially applies each transformation in the Compose object's transforms to the input data.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        data (Any): The input data to be transformed. This can be of any type, depending on the transformations in</span>
<span></span><span class="sd">            the list.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (Any): The transformed data after applying all transformations in sequence.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; transforms = [Transform1(), Transform2(), Transform3()]</span>
<span></span><span class="sd">        &gt;&gt;&gt; compose = Compose(transforms)</span>
<span></span><span class="sd">        &gt;&gt;&gt; transformed_data = compose(input_data)</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span><span class="p">:</span>
<span></span>        <span class="n">data</span> <span class="o">=</span> <span class="n">t</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span></span>    <span class="k">return</span> <span class="n">data</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.Compose.__getitem__"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.Compose.__getitem__</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Compose</span>
</code></pre></div><p>Retrieve a specific transform or a set of transforms using indexing.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>index</code></td><td><code>int | list[int]</code></td><td>Index or list of indices of the transforms to retrieve.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>Compose</code></td><td>A new Compose object containing the selected transform(s).</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transforms</span> <span class="o">=</span> <span class="p">[</span><span class="n">RandomFlip</span><span class="p">(),</span> <span class="n">RandomPerspective</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">RandomHSV</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)]</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">compose</span> <span class="o">=</span> <span class="n">Compose</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">single_transform</span> <span class="o">=</span> <span class="n">compose</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Returns a Compose object with only RandomPerspective</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">multiple_transforms</span> <span class="o">=</span> <span class="n">compose</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># Returns a Compose object with RandomFlip and RandomPerspective</span>
</code></pre></div><p><strong>Raises</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>AssertionError</code></td><td>If the index is not of type int or list.</td></tr></tbody></table><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L217-L236"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Compose</span><span class="p">:</span>
<span></span><span class="w">    </span><span class="sd">"""Retrieve a specific transform or a set of transforms using indexing.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        index (int | list[int]): Index or list of indices of the transforms to retrieve.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (Compose): A new Compose object containing the selected transform(s).</span>
<span></span>
<span></span><span class="sd">    Raises:</span>
<span></span><span class="sd">        AssertionError: If the index is not of type int or list.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; transforms = [RandomFlip(), RandomPerspective(10), RandomHSV(0.5, 0.5, 0.5)]</span>
<span></span><span class="sd">        &gt;&gt;&gt; compose = Compose(transforms)</span>
<span></span><span class="sd">        &gt;&gt;&gt; single_transform = compose[1]  # Returns a Compose object with only RandomPerspective</span>
<span></span><span class="sd">        &gt;&gt;&gt; multiple_transforms = compose[0:2]  # Returns a Compose object with RandomFlip and RandomPerspective</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">)),</span> <span class="sa">f</span><span class="s2">"The indices should be either list or int type but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span>
<span></span>    <span class="k">return</span> <span class="n">Compose</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">transforms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">])</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.Compose.__repr__"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.Compose.__repr__</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</code></pre></div><p>Return a string representation of the Compose object.</p><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>str</code></td><td>A string representation of the Compose object, including the list of transforms.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transforms</span> <span class="o">=</span> <span class="p">[</span><span class="n">RandomFlip</span><span class="p">(),</span> <span class="n">RandomPerspective</span><span class="p">(</span><span class="n">degrees</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">translate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)]</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">compose</span> <span class="o">=</span> <span class="n">Compose</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">compose</span><span class="p">)</span>
<span></span><span class="n">Compose</span><span class="p">([</span>
<span></span>    <span class="n">RandomFlip</span><span class="p">(),</span>
<span></span>    <span class="n">RandomPerspective</span><span class="p">(</span><span class="n">degrees</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">translate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span></span><span class="p">])</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L279-L294"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span></span><span class="w">    </span><span class="sd">"""Return a string representation of the Compose object.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (str): A string representation of the Compose object, including the list of transforms.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; transforms = [RandomFlip(), RandomPerspective(degrees=10, translate=0.1, scale=0.1)]</span>
<span></span><span class="sd">        &gt;&gt;&gt; compose = Compose(transforms)</span>
<span></span><span class="sd">        &gt;&gt;&gt; print(compose)</span>
<span></span><span class="sd">        Compose([</span>
<span></span><span class="sd">            RandomFlip(),</span>
<span></span><span class="sd">            RandomPerspective(degrees=10, translate=0.1, scale=0.1)</span>
<span></span><span class="sd">        ])</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="k">return</span> <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="s1">', '</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s1">'</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s1">'</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">transforms</span><span class="p">])</span><span class="si">}</span><span class="s2">)"</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.Compose.__setitem__"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.Compose.__setitem__</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div><p>Set one or more transforms in the composition using indexing.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>index</code></td><td><code>int | list[int]</code></td><td>Index or list of indices to set transforms at.</td><td><em>required</em></td></tr><tr><td><code>value</code></td><td><code>Any | list[Any]</code></td><td>Transform or list of transforms to set at the specified index(es).</td><td><em>required</em></td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">compose</span> <span class="o">=</span> <span class="n">Compose</span><span class="p">([</span><span class="n">Transform1</span><span class="p">(),</span> <span class="n">Transform2</span><span class="p">(),</span> <span class="n">Transform3</span><span class="p">()])</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">compose</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">NewTransform</span><span class="p">()</span>  <span class="c1"># Replace second transform</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">compose</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">NewTransform1</span><span class="p">(),</span> <span class="n">NewTransform2</span><span class="p">()]</span>  <span class="c1"># Replace first two transforms</span>
</code></pre></div><p><strong>Raises</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>AssertionError</code></td><td>If index type is invalid, value type doesn't match index type, or index is out of range.</td></tr></tbody></table><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L238-L262"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span></span><span class="w">    </span><span class="sd">"""Set one or more transforms in the composition using indexing.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        index (int | list[int]): Index or list of indices to set transforms at.</span>
<span></span><span class="sd">        value (Any | list[Any]): Transform or list of transforms to set at the specified index(es).</span>
<span></span>
<span></span><span class="sd">    Raises:</span>
<span></span><span class="sd">        AssertionError: If index type is invalid, value type doesn't match index type, or index is out of range.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; compose = Compose([Transform1(), Transform2(), Transform3()])</span>
<span></span><span class="sd">        &gt;&gt;&gt; compose[1] = NewTransform()  # Replace second transform</span>
<span></span><span class="sd">        &gt;&gt;&gt; compose[0:2] = [NewTransform1(), NewTransform2()]  # Replace first two transforms</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">)),</span> <span class="sa">f</span><span class="s2">"The indices should be either list or int type but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span>
<span></span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
<span></span>        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="p">(</span>
<span></span>            <span class="sa">f</span><span class="s2">"The indices should be the same type as values, but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span>
<span></span>        <span class="p">)</span>
<span></span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
<span></span>        <span class="n">index</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>
<span></span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span></span>        <span class="k">assert</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transforms</span><span class="p">),</span> <span class="sa">f</span><span class="s2">"list index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> out of range </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transforms</span><span class="p">)</span><span class="si">}</span><span class="s2">."</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.Compose.append"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.Compose.append</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transform</span><span class="p">)</span>
</code></pre></div><p>Append a new transform to the existing list of transforms.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>transform</code></td><td><code>BaseTransform</code></td><td>The transformation to be added to the composition.</td><td><em>required</em></td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">compose</span> <span class="o">=</span> <span class="n">Compose</span><span class="p">([</span><span class="n">RandomFlip</span><span class="p">(),</span> <span class="n">RandomPerspective</span><span class="p">()])</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">compose</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">RandomHSV</span><span class="p">())</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L190-L200"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
<span></span><span class="w">    </span><span class="sd">"""Append a new transform to the existing list of transforms.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        transform (BaseTransform): The transformation to be added to the composition.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; compose = Compose([RandomFlip(), RandomPerspective()])</span>
<span></span><span class="sd">        &gt;&gt;&gt; compose.append(RandomHSV())</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.Compose.insert"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.Compose.insert</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">transform</span><span class="p">)</span>
</code></pre></div><p>Insert a new transform at a specified index in the existing list of transforms.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>index</code></td><td><code>int</code></td><td>The index at which to insert the new transform.</td><td><em>required</em></td></tr><tr><td><code>transform</code></td><td><code>BaseTransform</code></td><td>The transform object to be inserted.</td><td><em>required</em></td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">compose</span> <span class="o">=</span> <span class="n">Compose</span><span class="p">([</span><span class="n">Transform1</span><span class="p">(),</span> <span class="n">Transform2</span><span class="p">()])</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">compose</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Transform3</span><span class="p">())</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">compose</span><span class="o">.</span><span class="n">transforms</span><span class="p">)</span>
<span></span><span class="mi">3</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L202-L215"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
<span></span><span class="w">    </span><span class="sd">"""Insert a new transform at a specified index in the existing list of transforms.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        index (int): The index at which to insert the new transform.</span>
<span></span><span class="sd">        transform (BaseTransform): The transform object to be inserted.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; compose = Compose([Transform1(), Transform2()])</span>
<span></span><span class="sd">        &gt;&gt;&gt; compose.insert(1, Transform3())</span>
<span></span><span class="sd">        &gt;&gt;&gt; len(compose.transforms)</span>
<span></span><span class="sd">        3</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">transform</span><span class="p">)</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.Compose.tolist"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.Compose.tolist</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">tolist</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</code></pre></div><p>Convert the list of transforms to a standard Python list.</p><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>list</code></td><td>A list containing all the transform objects in the Compose instance.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transforms</span> <span class="o">=</span> <span class="p">[</span><span class="n">RandomFlip</span><span class="p">(),</span> <span class="n">RandomPerspective</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">CenterCrop</span><span class="p">()]</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">compose</span> <span class="o">=</span> <span class="n">Compose</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transform_list</span> <span class="o">=</span> <span class="n">compose</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">transform_list</span><span class="p">))</span>
<span></span><span class="mi">3</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L264-L277"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">tolist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span></span><span class="w">    </span><span class="sd">"""Convert the list of transforms to a standard Python list.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (list): A list containing all the transform objects in the Compose instance.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; transforms = [RandomFlip(), RandomPerspective(10), CenterCrop()]</span>
<span></span><span class="sd">        &gt;&gt;&gt; compose = Compose(transforms)</span>
<span></span><span class="sd">        &gt;&gt;&gt; transform_list = compose.tolist()</span>
<span></span><span class="sd">        &gt;&gt;&gt; print(len(transform_list))</span>
<span></span><span class="sd">        3</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span>
</code></pre></div></details><p><br/><br/><hr/><br/></p><h2 id="ultralytics.data.augment.BaseMixTransform"><span class="doc-kind doc-kind-class">class</span> <code>ultralytics.data.augment.BaseMixTransform</code></h2><div class="highlight"><pre><span></span><code><span></span><span class="n">BaseMixTransform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">pre_transform</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div><p>Base class for mix transformations like Cutmix, MixUp and Mosaic.</p><p>This class provides a foundation for implementing mix transformations on datasets. It handles the probability-based application of transforms and manages the mixing of multiple images and labels.</p><p>This class serves as a base for implementing mix transformations in image processing pipelines.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>dataset</code></td><td><code>Any</code></td><td>The dataset object containing images and labels for mixing.</td><td><em>required</em></td></tr><tr><td><code>pre_transform</code></td><td><code>Callable | None</code></td><td>Optional transform to apply before mixing.</td><td><code>None</code></td></tr><tr><td><code>p</code></td><td><code>float</code></td><td>Probability of applying the mix transformation. Should be in the range [0.0, 1.0].</td><td><code>0.0</code></td></tr></tbody></table><p><strong>Attributes</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dataset</code></td><td><code>Any</code></td><td>The dataset object containing images and labels.</td></tr><tr><td><code>pre_transform</code></td><td><code>Callable | None</code></td><td>Optional transform to apply before mixing.</td></tr><tr><td><code>p</code></td><td><code>float</code></td><td>Probability of applying the mix transformation.</td></tr></tbody></table><p><strong>Methods</strong></p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="#ultralytics.data.augment.BaseMixTransform.__call__"><code>__call__</code></a></td><td>Apply pre-processing transforms and cutmix/mixup/mosaic transforms to labels data.</td></tr><tr><td><a href="#ultralytics.data.augment.BaseMixTransform._mix_transform"><code>_mix_transform</code></a></td><td>Apply CutMix, MixUp or Mosaic augmentation to the label dictionary.</td></tr><tr><td><a href="#ultralytics.data.augment.BaseMixTransform._update_label_text"><code>_update_label_text</code></a></td><td>Update label text and class IDs for mixed labels in image augmentation.</td></tr><tr><td><a href="#ultralytics.data.augment.BaseMixTransform.get_indexes"><code>get_indexes</code></a></td><td>Get a list of shuffled indexes for mosaic augmentation.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span><span class="w"> </span><span class="nc">CustomMixTransform</span><span class="p">(</span><span class="n">BaseMixTransform</span><span class="p">):</span>
<span></span><span class="o">...</span>     <span class="k">def</span><span class="w"> </span><span class="nf">_mix_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
<span></span><span class="o">...</span>         <span class="c1"># Implement custom mix logic here</span>
<span></span><span class="o">...</span>         <span class="k">return</span> <span class="n">labels</span>
<span></span><span class="o">...</span>
<span></span><span class="o">...</span>     <span class="k">def</span><span class="w"> </span><span class="nf">get_indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span></span><span class="o">...</span>         <span class="k">return</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">dataset</span> <span class="o">=</span> <span class="n">YourDataset</span><span class="p">()</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">CustomMixTransform</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">mixed_labels</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">original_labels</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L297-L455"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">class</span><span class="w"> </span><span class="nc">BaseMixTransform</span><span class="p">:</span>
<span></span><span class="w">    </span><span class="sd">"""Base class for mix transformations like Cutmix, MixUp and Mosaic.</span>
<span></span>
<span></span><span class="sd">    This class provides a foundation for implementing mix transformations on datasets. It handles the probability-based</span>
<span></span><span class="sd">    application of transforms and manages the mixing of multiple images and labels.</span>
<span></span>
<span></span><span class="sd">    Attributes:</span>
<span></span><span class="sd">        dataset (Any): The dataset object containing images and labels.</span>
<span></span><span class="sd">        pre_transform (Callable | None): Optional transform to apply before mixing.</span>
<span></span><span class="sd">        p (float): Probability of applying the mix transformation.</span>
<span></span>
<span></span><span class="sd">    Methods:</span>
<span></span><span class="sd">        __call__: Apply the mix transformation to the input labels.</span>
<span></span><span class="sd">        _mix_transform: Abstract method to be implemented by subclasses for specific mix operations.</span>
<span></span><span class="sd">        get_indexes: Abstract method to get indexes of images to be mixed.</span>
<span></span><span class="sd">        _update_label_text: Update label text for mixed images.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; class CustomMixTransform(BaseMixTransform):</span>
<span></span><span class="sd">        ...     def _mix_transform(self, labels):</span>
<span></span><span class="sd">        ...         # Implement custom mix logic here</span>
<span></span><span class="sd">        ...         return labels</span>
<span></span><span class="sd">        ...</span>
<span></span><span class="sd">        ...     def get_indexes(self):</span>
<span></span><span class="sd">        ...         return [random.randint(0, len(self.dataset) - 1) for _ in range(3)]</span>
<span></span><span class="sd">        &gt;&gt;&gt; dataset = YourDataset()</span>
<span></span><span class="sd">        &gt;&gt;&gt; transform = CustomMixTransform(dataset, p=0.5)</span>
<span></span><span class="sd">        &gt;&gt;&gt; mixed_labels = transform(original_labels)</span>
<span></span><span class="sd">    """</span>
<span></span>
<span></span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">pre_transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span></span><span class="w">        </span><span class="sd">"""Initialize the BaseMixTransform object for mix transformations like CutMix, MixUp and Mosaic.</span>
<span></span>
<span></span><span class="sd">        This class serves as a base for implementing mix transformations in image processing pipelines.</span>
<span></span>
<span></span><span class="sd">        Args:</span>
<span></span><span class="sd">            dataset (Any): The dataset object containing images and labels for mixing.</span>
<span></span><span class="sd">            pre_transform (Callable | None): Optional transform to apply before mixing.</span>
<span></span><span class="sd">            p (float): Probability of applying the mix transformation. Should be in the range [0.0, 1.0].</span>
<span></span><span class="sd">        """</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">pre_transform</span> <span class="o">=</span> <span class="n">pre_transform</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.BaseMixTransform.__call__"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.BaseMixTransform.__call__</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
</code></pre></div><p>Apply pre-processing transforms and cutmix/mixup/mosaic transforms to labels data.</p><p>This method determines whether to apply the mix transform based on a probability factor. If applied, it selects additional images, applies pre-transforms if specified, and then performs the mix transform.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>labels</code></td><td><code>dict[str, Any]</code></td><td>A dictionary containing label data for an image.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dict[str, Any]</code></td><td>The transformed labels dictionary, which may include mixed data from other images.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">BaseMixTransform</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">pre_transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">transform</span><span class="p">({</span><span class="s2">"image"</span><span class="p">:</span> <span class="n">img</span><span class="p">,</span> <span class="s2">"bboxes"</span><span class="p">:</span> <span class="n">boxes</span><span class="p">,</span> <span class="s2">"cls"</span><span class="p">:</span> <span class="n">classes</span><span class="p">})</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L341-L378"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span></span><span class="w">    </span><span class="sd">"""Apply pre-processing transforms and cutmix/mixup/mosaic transforms to labels data.</span>
<span></span>
<span></span><span class="sd">    This method determines whether to apply the mix transform based on a probability factor. If applied, it selects</span>
<span></span><span class="sd">    additional images, applies pre-transforms if specified, and then performs the mix transform.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        labels (dict[str, Any]): A dictionary containing label data for an image.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (dict[str, Any]): The transformed labels dictionary, which may include mixed data from other images.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; transform = BaseMixTransform(dataset, pre_transform=None, p=0.5)</span>
<span></span><span class="sd">        &gt;&gt;&gt; result = transform({"image": img, "bboxes": boxes, "cls": classes})</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">:</span>
<span></span>        <span class="k">return</span> <span class="n">labels</span>
<span></span>
<span></span>    <span class="c1"># Get index of one or three other images</span>
<span></span>    <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexes</span><span class="p">()</span>
<span></span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
<span></span>        <span class="n">indexes</span> <span class="o">=</span> <span class="p">[</span><span class="n">indexes</span><span class="p">]</span>
<span></span>
<span></span>    <span class="c1"># Get images information will be used for Mosaic, CutMix or MixUp</span>
<span></span>    <span class="n">mix_labels</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">get_image_and_label</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">]</span>
<span></span>
<span></span>    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre_transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span></span>        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mix_labels</span><span class="p">):</span>
<span></span>            <span class="n">mix_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre_transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"mix_labels"</span><span class="p">]</span> <span class="o">=</span> <span class="n">mix_labels</span>
<span></span>
<span></span>    <span class="c1"># Update cls and texts</span>
<span></span>    <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_label_text</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span></span>    <span class="c1"># Mosaic, CutMix or MixUp</span>
<span></span>    <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mix_transform</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span></span>    <span class="n">labels</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"mix_labels"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span></span>    <span class="k">return</span> <span class="n">labels</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.BaseMixTransform._mix_transform"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.BaseMixTransform._mix_transform</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_mix_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span>
</code></pre></div><p>Apply CutMix, MixUp or Mosaic augmentation to the label dictionary.</p><p>This method should be implemented by subclasses to perform specific mix transformations like CutMix, MixUp or Mosaic. It modifies the input label dictionary in-place with the augmented data.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>labels</code></td><td><code>dict[str, Any]</code></td><td>A dictionary containing image and label data. Expected to have a 'mix_labels' key with a list of additional image and label data for mixing.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dict[str, Any]</code></td><td>The modified labels dictionary with augmented data after applying the mix transform.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">BaseMixTransform</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">labels</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"image"</span><span class="p">:</span> <span class="n">img</span><span class="p">,</span> <span class="s2">"bboxes"</span><span class="p">:</span> <span class="n">boxes</span><span class="p">,</span> <span class="s2">"mix_labels"</span><span class="p">:</span> <span class="p">[{</span><span class="s2">"image"</span><span class="p">:</span> <span class="n">img2</span><span class="p">,</span> <span class="s2">"bboxes"</span><span class="p">:</span> <span class="n">boxes2</span><span class="p">}]}</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">augmented_labels</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">_mix_transform</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L380-L398"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_mix_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]):</span>
<span></span><span class="w">    </span><span class="sd">"""Apply CutMix, MixUp or Mosaic augmentation to the label dictionary.</span>
<span></span>
<span></span><span class="sd">    This method should be implemented by subclasses to perform specific mix transformations like CutMix, MixUp or</span>
<span></span><span class="sd">    Mosaic. It modifies the input label dictionary in-place with the augmented data.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        labels (dict[str, Any]): A dictionary containing image and label data. Expected to have a 'mix_labels' key</span>
<span></span><span class="sd">            with a list of additional image and label data for mixing.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (dict[str, Any]): The modified labels dictionary with augmented data after applying the mix transform.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; transform = BaseMixTransform(dataset)</span>
<span></span><span class="sd">        &gt;&gt;&gt; labels = {"image": img, "bboxes": boxes, "mix_labels": [{"image": img2, "bboxes": boxes2}]}</span>
<span></span><span class="sd">        &gt;&gt;&gt; augmented_labels = transform._mix_transform(labels)</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.BaseMixTransform._update_label_text"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.BaseMixTransform._update_label_text</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_update_label_text</span><span class="p">(</span><span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
</code></pre></div><p>Update label text and class IDs for mixed labels in image augmentation.</p><p>This method processes the 'texts' and 'cls' fields of the input labels dictionary and any mixed labels, creating a unified set of text labels and updating class IDs accordingly.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>labels</code></td><td><code>dict[str, Any]</code></td><td>A dictionary containing label information, including 'texts' and 'cls' fields, and optionally a 'mix_labels' field with additional label dictionaries.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dict[str, Any]</code></td><td>The updated labels dictionary with unified text labels and updated class IDs.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">labels</span> <span class="o">=</span> <span class="p">{</span>
<span></span><span class="o">...</span>     <span class="s2">"texts"</span><span class="p">:</span> <span class="p">[[</span><span class="s2">"cat"</span><span class="p">],</span> <span class="p">[</span><span class="s2">"dog"</span><span class="p">]],</span>
<span></span><span class="o">...</span>     <span class="s2">"cls"</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]),</span>
<span></span><span class="o">...</span>     <span class="s2">"mix_labels"</span><span class="p">:</span> <span class="p">[{</span><span class="s2">"texts"</span><span class="p">:</span> <span class="p">[[</span><span class="s2">"bird"</span><span class="p">],</span> <span class="p">[</span><span class="s2">"fish"</span><span class="p">]],</span> <span class="s2">"cls"</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])}],</span>
<span></span><span class="o">...</span> <span class="p">}</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">updated_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_label_text</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">updated_labels</span><span class="p">[</span><span class="s2">"texts"</span><span class="p">])</span>
<span></span><span class="p">[[</span><span class="s1">'cat'</span><span class="p">],</span> <span class="p">[</span><span class="s1">'dog'</span><span class="p">],</span> <span class="p">[</span><span class="s1">'bird'</span><span class="p">],</span> <span class="p">[</span><span class="s1">'fish'</span><span class="p">]]</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">updated_labels</span><span class="p">[</span><span class="s2">"cls"</span><span class="p">])</span>
<span></span><span class="n">tensor</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span>
<span></span>        <span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">updated_labels</span><span class="p">[</span><span class="s2">"mix_labels"</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">"cls"</span><span class="p">])</span>
<span></span><span class="n">tensor</span><span class="p">([[</span><span class="mi">2</span><span class="p">],</span>
<span></span>        <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L414-L455"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="nd">@staticmethod</span>
<span></span><span class="k">def</span><span class="w"> </span><span class="nf">_update_label_text</span><span class="p">(</span><span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span></span><span class="w">    </span><span class="sd">"""Update label text and class IDs for mixed labels in image augmentation.</span>
<span></span>
<span></span><span class="sd">    This method processes the 'texts' and 'cls' fields of the input labels dictionary and any mixed labels, creating</span>
<span></span><span class="sd">    a unified set of text labels and updating class IDs accordingly.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        labels (dict[str, Any]): A dictionary containing label information, including 'texts' and 'cls' fields, and</span>
<span></span><span class="sd">            optionally a 'mix_labels' field with additional label dictionaries.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (dict[str, Any]): The updated labels dictionary with unified text labels and updated class IDs.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; labels = {</span>
<span></span><span class="sd">        ...     "texts": [["cat"], ["dog"]],</span>
<span></span><span class="sd">        ...     "cls": torch.tensor([[0], [1]]),</span>
<span></span><span class="sd">        ...     "mix_labels": [{"texts": [["bird"], ["fish"]], "cls": torch.tensor([[0], [1]])}],</span>
<span></span><span class="sd">        ... }</span>
<span></span><span class="sd">        &gt;&gt;&gt; updated_labels = self._update_label_text(labels)</span>
<span></span><span class="sd">        &gt;&gt;&gt; print(updated_labels["texts"])</span>
<span></span><span class="sd">        [['cat'], ['dog'], ['bird'], ['fish']]</span>
<span></span><span class="sd">        &gt;&gt;&gt; print(updated_labels["cls"])</span>
<span></span><span class="sd">        tensor([[0],</span>
<span></span><span class="sd">                [1]])</span>
<span></span><span class="sd">        &gt;&gt;&gt; print(updated_labels["mix_labels"][0]["cls"])</span>
<span></span><span class="sd">        tensor([[2],</span>
<span></span><span class="sd">                [3]])</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="k">if</span> <span class="s2">"texts"</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
<span></span>        <span class="k">return</span> <span class="n">labels</span>
<span></span>
<span></span>    <span class="n">mix_texts</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">labels</span><span class="p">[</span><span class="s2">"texts"</span><span class="p">],</span> <span class="o">*</span><span class="p">(</span><span class="n">item</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">[</span><span class="s2">"mix_labels"</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[</span><span class="s2">"texts"</span><span class="p">])]</span>
<span></span>    <span class="n">mix_texts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">({</span><span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mix_texts</span><span class="p">})</span>
<span></span>    <span class="n">text2id</span> <span class="o">=</span> <span class="p">{</span><span class="n">text</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">text</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mix_texts</span><span class="p">)}</span>
<span></span>
<span></span>    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="p">[</span><span class="n">labels</span><span class="p">]</span> <span class="o">+</span> <span class="n">labels</span><span class="p">[</span><span class="s2">"mix_labels"</span><span class="p">]:</span>
<span></span>        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">label</span><span class="p">[</span><span class="s2">"cls"</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()):</span>
<span></span>            <span class="n">text</span> <span class="o">=</span> <span class="n">label</span><span class="p">[</span><span class="s2">"texts"</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="bp">cls</span><span class="p">)]</span>
<span></span>            <span class="n">label</span><span class="p">[</span><span class="s2">"cls"</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">text2id</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">text</span><span class="p">)]</span>
<span></span>        <span class="n">label</span><span class="p">[</span><span class="s2">"texts"</span><span class="p">]</span> <span class="o">=</span> <span class="n">mix_texts</span>
<span></span>    <span class="k">return</span> <span class="n">labels</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.BaseMixTransform.get_indexes"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.BaseMixTransform.get_indexes</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</code></pre></div><p>Get a list of shuffled indexes for mosaic augmentation.</p><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>list[int]</code></td><td>A list of shuffled indexes from the dataset.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">BaseMixTransform</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">indexes</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">get_indexes</span><span class="p">()</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span>  <span class="c1"># [3, 18, 7, 2]</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L400-L411"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span></span><span class="w">    </span><span class="sd">"""Get a list of shuffled indexes for mosaic augmentation.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (list[int]): A list of shuffled indexes from the dataset.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; transform = BaseMixTransform(dataset)</span>
<span></span><span class="sd">        &gt;&gt;&gt; indexes = transform.get_indexes()</span>
<span></span><span class="sd">        &gt;&gt;&gt; print(indexes)  # [3, 18, 7, 2]</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></details><p><br/><br/><hr/><br/></p><h2 id="ultralytics.data.augment.Mosaic"><span class="doc-kind doc-kind-class">class</span> <code>ultralytics.data.augment.Mosaic</code></h2><div class="highlight"><pre><span></span><code><span></span><span class="n">Mosaic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">imgsz</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">640</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>
</code></pre></div><p><strong>Bases:</strong> <code>BaseMixTransform</code></p><p>Mosaic augmentation for image datasets.</p><p>This class performs mosaic augmentation by combining multiple (4 or 9) images into a single mosaic image. The augmentation is applied to a dataset with a given probability.</p><p>This class performs mosaic augmentation by combining multiple (4 or 9) images into a single mosaic image. The augmentation is applied to a dataset with a given probability.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>dataset</code></td><td><code>Any</code></td><td>The dataset on which the mosaic augmentation is applied.</td><td><em>required</em></td></tr><tr><td><code>imgsz</code></td><td><code>int</code></td><td>Image size (height and width) after mosaic pipeline of a single image.</td><td><code>640</code></td></tr><tr><td><code>p</code></td><td><code>float</code></td><td>Probability of applying the mosaic augmentation. Must be in the range 0-1.</td><td><code>1.0</code></td></tr><tr><td><code>n</code></td><td><code>int</code></td><td>The grid size, either 4 (for 2x2) or 9 (for 3x3).</td><td><code>4</code></td></tr></tbody></table><p><strong>Attributes</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dataset</code></td><td></td><td>The dataset on which the mosaic augmentation is applied.</td></tr><tr><td><code>imgsz</code></td><td><code>int</code></td><td>Image size (height and width) after mosaic pipeline of a single image.</td></tr><tr><td><code>p</code></td><td><code>float</code></td><td>Probability of applying the mosaic augmentation. Must be in the range 0-1.</td></tr><tr><td><code>n</code></td><td><code>int</code></td><td>The grid size, either 4 (for 2x2) or 9 (for 3x3).</td></tr><tr><td><code>border</code></td><td><code>tuple[int, int]</code></td><td>Border size for width and height.</td></tr></tbody></table><p><strong>Methods</strong></p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="#ultralytics.data.augment.Mosaic._cat_labels"><code>_cat_labels</code></a></td><td>Concatenate and process labels for mosaic augmentation.</td></tr><tr><td><a href="#ultralytics.data.augment.Mosaic._mix_transform"><code>_mix_transform</code></a></td><td>Apply mosaic augmentation to the input image and labels.</td></tr><tr><td><a href="#ultralytics.data.augment.Mosaic._mosaic3"><code>_mosaic3</code></a></td><td>Create a 1x3 image mosaic by combining three images.</td></tr><tr><td><a href="#ultralytics.data.augment.Mosaic._mosaic4"><code>_mosaic4</code></a></td><td>Create a 2x2 image mosaic from four input images.</td></tr><tr><td><a href="#ultralytics.data.augment.Mosaic._mosaic9"><code>_mosaic9</code></a></td><td>Create a 3x3 image mosaic from the input image and eight additional images.</td></tr><tr><td><a href="#ultralytics.data.augment.Mosaic._update_labels"><code>_update_labels</code></a></td><td>Update label coordinates with padding values.</td></tr><tr><td><a href="#ultralytics.data.augment.Mosaic.get_indexes"><code>get_indexes</code></a></td><td>Return a list of random indexes from the dataset for mosaic augmentation.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span><span class="w"> </span><span class="nn">ultralytics.data.augment</span><span class="w"> </span><span class="kn">import</span> <span class="n">Mosaic</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">dataset</span> <span class="o">=</span> <span class="n">YourDataset</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>  <span class="c1"># Your image dataset</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">mosaic_aug</span> <span class="o">=</span> <span class="n">Mosaic</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">imgsz</span><span class="o">=</span><span class="mi">640</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">augmented_labels</span> <span class="o">=</span> <span class="n">mosaic_aug</span><span class="p">(</span><span class="n">original_labels</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L458-L817"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Mosaic</span><span class="p">(</span><span class="n">BaseMixTransform</span><span class="p">):</span>
<span></span><span class="w">    </span><span class="sd">"""Mosaic augmentation for image datasets.</span>
<span></span>
<span></span><span class="sd">    This class performs mosaic augmentation by combining multiple (4 or 9) images into a single mosaic image. The</span>
<span></span><span class="sd">    augmentation is applied to a dataset with a given probability.</span>
<span></span>
<span></span><span class="sd">    Attributes:</span>
<span></span><span class="sd">        dataset: The dataset on which the mosaic augmentation is applied.</span>
<span></span><span class="sd">        imgsz (int): Image size (height and width) after mosaic pipeline of a single image.</span>
<span></span><span class="sd">        p (float): Probability of applying the mosaic augmentation. Must be in the range 0-1.</span>
<span></span><span class="sd">        n (int): The grid size, either 4 (for 2x2) or 9 (for 3x3).</span>
<span></span><span class="sd">        border (tuple[int, int]): Border size for width and height.</span>
<span></span>
<span></span><span class="sd">    Methods:</span>
<span></span><span class="sd">        get_indexes: Return a list of random indexes from the dataset.</span>
<span></span><span class="sd">        _mix_transform: Apply mixup transformation to the input image and labels.</span>
<span></span><span class="sd">        _mosaic3: Create a 1x3 image mosaic.</span>
<span></span><span class="sd">        _mosaic4: Create a 2x2 image mosaic.</span>
<span></span><span class="sd">        _mosaic9: Create a 3x3 image mosaic.</span>
<span></span><span class="sd">        _update_labels: Update labels with padding.</span>
<span></span><span class="sd">        _cat_labels: Concatenate labels and clips mosaic border instances.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; from ultralytics.data.augment import Mosaic</span>
<span></span><span class="sd">        &gt;&gt;&gt; dataset = YourDataset(...)  # Your image dataset</span>
<span></span><span class="sd">        &gt;&gt;&gt; mosaic_aug = Mosaic(dataset, imgsz=640, p=0.5, n=4)</span>
<span></span><span class="sd">        &gt;&gt;&gt; augmented_labels = mosaic_aug(original_labels)</span>
<span></span><span class="sd">    """</span>
<span></span>
<span></span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">imgsz</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">640</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">):</span>
<span></span><span class="w">        </span><span class="sd">"""Initialize the Mosaic augmentation object.</span>
<span></span>
<span></span><span class="sd">        This class performs mosaic augmentation by combining multiple (4 or 9) images into a single mosaic image. The</span>
<span></span><span class="sd">        augmentation is applied to a dataset with a given probability.</span>
<span></span>
<span></span><span class="sd">        Args:</span>
<span></span><span class="sd">            dataset (Any): The dataset on which the mosaic augmentation is applied.</span>
<span></span><span class="sd">            imgsz (int): Image size (height and width) after mosaic pipeline of a single image.</span>
<span></span><span class="sd">            p (float): Probability of applying the mosaic augmentation. Must be in the range 0-1.</span>
<span></span><span class="sd">            n (int): The grid size, either 4 (for 2x2) or 9 (for 3x3).</span>
<span></span><span class="sd">        """</span>
<span></span>        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">"The probability should be in range [0, 1], but got </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">."</span>
<span></span>        <span class="k">assert</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">},</span> <span class="s2">"grid must be equal to 4 or 9."</span>
<span></span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">imgsz</span> <span class="o">=</span> <span class="n">imgsz</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">border</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">imgsz</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">imgsz</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># width, height</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">buffer_enabled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">cache</span> <span class="o">!=</span> <span class="s2">"ram"</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.Mosaic._cat_labels"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.Mosaic._cat_labels</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_cat_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mosaic_labels</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
</code></pre></div><p>Concatenate and process labels for mosaic augmentation.</p><p>This method combines labels from multiple images used in mosaic augmentation, clips instances to the mosaic border, and removes zero-area boxes.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>mosaic_labels</code></td><td><code>list[dict[str, Any]]</code></td><td>A list of label dictionaries for each image in the mosaic.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dict[str, Any]</code></td><td>A dictionary containing concatenated and processed labels for the mosaic image, including:</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">mosaic</span> <span class="o">=</span> <span class="n">Mosaic</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">imgsz</span><span class="o">=</span><span class="mi">640</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">mosaic_labels</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">"cls"</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="s2">"instances"</span><span class="p">:</span> <span class="n">Instances</span><span class="p">(</span><span class="o">...</span><span class="p">)}</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">mosaic</span><span class="o">.</span><span class="n">_cat_labels</span><span class="p">(</span><span class="n">mosaic_labels</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span></span><span class="n">dict_keys</span><span class="p">([</span><span class="s1">'im_file'</span><span class="p">,</span> <span class="s1">'ori_shape'</span><span class="p">,</span> <span class="s1">'resized_shape'</span><span class="p">,</span> <span class="s1">'cls'</span><span class="p">,</span> <span class="s1">'instances'</span><span class="p">,</span> <span class="s1">'mosaic_border'</span><span class="p">])</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L769-L817"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_cat_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mosaic_labels</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span></span><span class="w">    </span><span class="sd">"""Concatenate and process labels for mosaic augmentation.</span>
<span></span>
<span></span><span class="sd">    This method combines labels from multiple images used in mosaic augmentation, clips instances to the mosaic</span>
<span></span><span class="sd">    border, and removes zero-area boxes.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        mosaic_labels (list[dict[str, Any]]): A list of label dictionaries for each image in the mosaic.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (dict[str, Any]): A dictionary containing concatenated and processed labels for the mosaic image, including:</span>
<span></span><span class="sd">            - im_file (str): File path of the first image in the mosaic.</span>
<span></span><span class="sd">            - ori_shape (tuple[int, int]): Original shape of the first image.</span>
<span></span><span class="sd">            - resized_shape (tuple[int, int]): Shape of the mosaic image (imgsz * 2, imgsz * 2).</span>
<span></span><span class="sd">            - cls (np.ndarray): Concatenated class labels.</span>
<span></span><span class="sd">            - instances (Instances): Concatenated instance annotations.</span>
<span></span><span class="sd">            - mosaic_border (tuple[int, int]): Mosaic border size.</span>
<span></span><span class="sd">            - texts (list[str], optional): Text labels if present in the original labels.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; mosaic = Mosaic(dataset, imgsz=640)</span>
<span></span><span class="sd">        &gt;&gt;&gt; mosaic_labels = [{"cls": np.array([0, 1]), "instances": Instances(...)} for _ in range(4)]</span>
<span></span><span class="sd">        &gt;&gt;&gt; result = mosaic._cat_labels(mosaic_labels)</span>
<span></span><span class="sd">        &gt;&gt;&gt; print(result.keys())</span>
<span></span><span class="sd">        dict_keys(['im_file', 'ori_shape', 'resized_shape', 'cls', 'instances', 'mosaic_border'])</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">mosaic_labels</span><span class="p">:</span>
<span></span>        <span class="k">return</span> <span class="p">{}</span>
<span></span>    <span class="bp">cls</span> <span class="o">=</span> <span class="p">[]</span>
<span></span>    <span class="n">instances</span> <span class="o">=</span> <span class="p">[]</span>
<span></span>    <span class="n">imgsz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imgsz</span> <span class="o">*</span> <span class="mi">2</span>  <span class="c1"># mosaic imgsz</span>
<span></span>    <span class="k">for</span> <span class="n">labels</span> <span class="ow">in</span> <span class="n">mosaic_labels</span><span class="p">:</span>
<span></span>        <span class="bp">cls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="s2">"cls"</span><span class="p">])</span>
<span></span>        <span class="n">instances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">])</span>
<span></span>    <span class="c1"># Final labels</span>
<span></span>    <span class="n">final_labels</span> <span class="o">=</span> <span class="p">{</span>
<span></span>        <span class="s2">"im_file"</span><span class="p">:</span> <span class="n">mosaic_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">"im_file"</span><span class="p">],</span>
<span></span>        <span class="s2">"ori_shape"</span><span class="p">:</span> <span class="n">mosaic_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">"ori_shape"</span><span class="p">],</span>
<span></span>        <span class="s2">"resized_shape"</span><span class="p">:</span> <span class="p">(</span><span class="n">imgsz</span><span class="p">,</span> <span class="n">imgsz</span><span class="p">),</span>
<span></span>        <span class="s2">"cls"</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span></span>        <span class="s2">"instances"</span><span class="p">:</span> <span class="n">Instances</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">instances</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
<span></span>        <span class="s2">"mosaic_border"</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">border</span><span class="p">,</span>
<span></span>    <span class="p">}</span>
<span></span>    <span class="n">final_labels</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">imgsz</span><span class="p">,</span> <span class="n">imgsz</span><span class="p">)</span>
<span></span>    <span class="n">good</span> <span class="o">=</span> <span class="n">final_labels</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]</span><span class="o">.</span><span class="n">remove_zero_area_boxes</span><span class="p">()</span>
<span></span>    <span class="n">final_labels</span><span class="p">[</span><span class="s2">"cls"</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_labels</span><span class="p">[</span><span class="s2">"cls"</span><span class="p">][</span><span class="n">good</span><span class="p">]</span>
<span></span>    <span class="k">if</span> <span class="s2">"texts"</span> <span class="ow">in</span> <span class="n">mosaic_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
<span></span>        <span class="n">final_labels</span><span class="p">[</span><span class="s2">"texts"</span><span class="p">]</span> <span class="o">=</span> <span class="n">mosaic_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">"texts"</span><span class="p">]</span>
<span></span>    <span class="k">return</span> <span class="n">final_labels</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.Mosaic._mix_transform"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.Mosaic._mix_transform</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_mix_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
</code></pre></div><p>Apply mosaic augmentation to the input image and labels.</p><p>This method combines multiple images (3, 4, or 9) into a single mosaic image based on the 'n' attribute. It ensures that rectangular annotations are not present and that there are other images available for mosaic augmentation.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>labels</code></td><td><code>dict[str, Any]</code></td><td>A dictionary containing image data and annotations. Expected keys include: - 'rect_shape': Should be None as rect and mosaic are mutually exclusive. - 'mix_labels': A list of dictionaries containing data for other images to be used in the mosaic.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dict[str, Any]</code></td><td>A dictionary containing the mosaic-augmented image and updated annotations.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">mosaic</span> <span class="o">=</span> <span class="n">Mosaic</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">imgsz</span><span class="o">=</span><span class="mi">640</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">augmented_data</span> <span class="o">=</span> <span class="n">mosaic</span><span class="o">.</span><span class="n">_mix_transform</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
</code></pre></div><p><strong>Raises</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>AssertionError</code></td><td>If 'rect_shape' is not None or if 'mix_labels' is empty.</td></tr></tbody></table><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L527-L553"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_mix_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span></span><span class="w">    </span><span class="sd">"""Apply mosaic augmentation to the input image and labels.</span>
<span></span>
<span></span><span class="sd">    This method combines multiple images (3, 4, or 9) into a single mosaic image based on the 'n' attribute. It</span>
<span></span><span class="sd">    ensures that rectangular annotations are not present and that there are other images available for mosaic</span>
<span></span><span class="sd">    augmentation.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        labels (dict[str, Any]): A dictionary containing image data and annotations. Expected keys include:</span>
<span></span><span class="sd">            - 'rect_shape': Should be None as rect and mosaic are mutually exclusive.</span>
<span></span><span class="sd">            - 'mix_labels': A list of dictionaries containing data for other images to be used in the mosaic.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (dict[str, Any]): A dictionary containing the mosaic-augmented image and updated annotations.</span>
<span></span>
<span></span><span class="sd">    Raises:</span>
<span></span><span class="sd">        AssertionError: If 'rect_shape' is not None or if 'mix_labels' is empty.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; mosaic = Mosaic(dataset, imgsz=640, p=1.0, n=4)</span>
<span></span><span class="sd">        &gt;&gt;&gt; augmented_data = mosaic._mix_transform(labels)</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="k">assert</span> <span class="n">labels</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"rect_shape"</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">"rect and mosaic are mutually exclusive."</span>
<span></span>    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"mix_labels"</span><span class="p">,</span> <span class="p">[])),</span> <span class="s2">"There are no other images for mosaic augment."</span>
<span></span>    <span class="k">return</span> <span class="p">(</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">_mosaic3</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mosaic4</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">==</span> <span class="mi">4</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mosaic9</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span></span>    <span class="p">)</span>  <span class="c1"># This code is modified for mosaic3 method.</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.Mosaic._mosaic3"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.Mosaic._mosaic3</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_mosaic3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
</code></pre></div><p>Create a 1x3 image mosaic by combining three images.</p><p>This method arranges three images in a horizontal layout, with the main image in the center and two additional images on either side. It's part of the Mosaic augmentation technique used in object detection.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>labels</code></td><td><code>dict[str, Any]</code></td><td>A dictionary containing image and label information for the main (center) image. Must include 'img' key with the image array, and 'mix_labels' key with a list of two dictionaries containing information for the side images.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dict[str, Any]</code></td><td>A dictionary with the mosaic image and updated labels. Keys include:</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">mosaic</span> <span class="o">=</span> <span class="n">Mosaic</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">imgsz</span><span class="o">=</span><span class="mi">640</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">labels</span> <span class="o">=</span> <span class="p">{</span>
<span></span><span class="o">...</span>     <span class="s2">"img"</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">480</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
<span></span><span class="o">...</span>     <span class="s2">"mix_labels"</span><span class="p">:</span> <span class="p">[{</span><span class="s2">"img"</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">480</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">3</span><span class="p">)}</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)],</span>
<span></span><span class="o">...</span> <span class="p">}</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">mosaic</span><span class="o">.</span><span class="n">_mosaic3</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span></span><span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L555-L611"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_mosaic3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span></span><span class="w">    </span><span class="sd">"""Create a 1x3 image mosaic by combining three images.</span>
<span></span>
<span></span><span class="sd">    This method arranges three images in a horizontal layout, with the main image in the center and two additional</span>
<span></span><span class="sd">    images on either side. It's part of the Mosaic augmentation technique used in object detection.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        labels (dict[str, Any]): A dictionary containing image and label information for the main (center) image.</span>
<span></span><span class="sd">            Must include 'img' key with the image array, and 'mix_labels' key with a list of two dictionaries</span>
<span></span><span class="sd">            containing information for the side images.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (dict[str, Any]): A dictionary with the mosaic image and updated labels. Keys include:</span>
<span></span><span class="sd">            - 'img' (np.ndarray): The mosaic image array with shape (H, W, C).</span>
<span></span><span class="sd">            - Other keys from the input labels, updated to reflect the new image dimensions.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; mosaic = Mosaic(dataset, imgsz=640, p=1.0, n=3)</span>
<span></span><span class="sd">        &gt;&gt;&gt; labels = {</span>
<span></span><span class="sd">        ...     "img": np.random.rand(480, 640, 3),</span>
<span></span><span class="sd">        ...     "mix_labels": [{"img": np.random.rand(480, 640, 3)} for _ in range(2)],</span>
<span></span><span class="sd">        ... }</span>
<span></span><span class="sd">        &gt;&gt;&gt; result = mosaic._mosaic3(labels)</span>
<span></span><span class="sd">        &gt;&gt;&gt; print(result["img"].shape)</span>
<span></span><span class="sd">        (640, 640, 3)</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="n">mosaic_labels</span> <span class="o">=</span> <span class="p">[]</span>
<span></span>    <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imgsz</span>
<span></span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span></span>        <span class="n">labels_patch</span> <span class="o">=</span> <span class="n">labels</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">labels</span><span class="p">[</span><span class="s2">"mix_labels"</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
<span></span>        <span class="c1"># Load image</span>
<span></span>        <span class="n">img</span> <span class="o">=</span> <span class="n">labels_patch</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span>
<span></span>        <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">labels_patch</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"resized_shape"</span><span class="p">)</span>
<span></span>
<span></span>        <span class="c1"># Place img in img3</span>
<span></span>        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># center</span>
<span></span>            <span class="n">img3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">s</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="n">s</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="mi">114</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>  <span class="c1"># base image with 3 tiles</span>
<span></span>            <span class="n">h0</span><span class="p">,</span> <span class="n">w0</span> <span class="o">=</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span>
<span></span>            <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">w</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">h</span>  <span class="c1"># xmin, ymin, xmax, ymax (base) coordinates</span>
<span></span>        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># right</span>
<span></span>            <span class="n">c</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">w0</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">w0</span> <span class="o">+</span> <span class="n">w</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">h</span>
<span></span>        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># left</span>
<span></span>            <span class="n">c</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-</span> <span class="n">w</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">h0</span> <span class="o">-</span> <span class="n">h</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">h0</span>
<span></span>
<span></span>        <span class="n">padw</span><span class="p">,</span> <span class="n">padh</span> <span class="o">=</span> <span class="n">c</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
<span></span>        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">c</span><span class="p">)</span>  <span class="c1"># allocate coordinates</span>
<span></span>
<span></span>        <span class="n">img3</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">]</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">y1</span> <span class="o">-</span> <span class="n">padh</span> <span class="p">:,</span> <span class="n">x1</span> <span class="o">-</span> <span class="n">padw</span> <span class="p">:]</span>  <span class="c1"># img3[ymin:ymax, xmin:xmax]</span>
<span></span>        <span class="c1"># hp, wp = h, w  # height, width previous for next iteration</span>
<span></span>
<span></span>        <span class="c1"># Labels assuming imgsz*2 mosaic size</span>
<span></span>        <span class="n">labels_patch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_labels</span><span class="p">(</span><span class="n">labels_patch</span><span class="p">,</span> <span class="n">padw</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">border</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">padh</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">border</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span></span>        <span class="n">mosaic_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">labels_patch</span><span class="p">)</span>
<span></span>    <span class="n">final_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cat_labels</span><span class="p">(</span><span class="n">mosaic_labels</span><span class="p">)</span>
<span></span>
<span></span>    <span class="n">final_labels</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span> <span class="o">=</span> <span class="n">img3</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">border</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">border</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">border</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">border</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
<span></span>    <span class="k">return</span> <span class="n">final_labels</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.Mosaic._mosaic4"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.Mosaic._mosaic4</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_mosaic4</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
</code></pre></div><p>Create a 2x2 image mosaic from four input images.</p><p>This method combines four images into a single mosaic image by placing them in a 2x2 grid. It also updates the corresponding labels for each image in the mosaic.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>labels</code></td><td><code>dict[str, Any]</code></td><td>A dictionary containing image data and labels for the base image (index 0) and three additional images (indices 1-3) in the 'mix_labels' key.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dict[str, Any]</code></td><td>A dictionary containing the mosaic image and updated labels. The 'img' key contains the</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">mosaic</span> <span class="o">=</span> <span class="n">Mosaic</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">imgsz</span><span class="o">=</span><span class="mi">640</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">labels</span> <span class="o">=</span> <span class="p">{</span>
<span></span><span class="o">...</span>     <span class="s2">"img"</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">480</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
<span></span><span class="o">...</span>     <span class="s2">"mix_labels"</span><span class="p">:</span> <span class="p">[{</span><span class="s2">"img"</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">480</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">3</span><span class="p">)}</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)],</span>
<span></span><span class="o">...</span> <span class="p">}</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">mosaic</span><span class="o">.</span><span class="n">_mosaic4</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="k">assert</span> <span class="n">result</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">1280</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L613-L669"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_mosaic4</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span></span><span class="w">    </span><span class="sd">"""Create a 2x2 image mosaic from four input images.</span>
<span></span>
<span></span><span class="sd">    This method combines four images into a single mosaic image by placing them in a 2x2 grid. It also updates the</span>
<span></span><span class="sd">    corresponding labels for each image in the mosaic.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        labels (dict[str, Any]): A dictionary containing image data and labels for the base image (index 0) and</span>
<span></span><span class="sd">            three additional images (indices 1-3) in the 'mix_labels' key.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (dict[str, Any]): A dictionary containing the mosaic image and updated labels. The 'img' key contains the</span>
<span></span><span class="sd">            mosaic image as a numpy array, and other keys contain the combined and adjusted labels for all</span>
<span></span><span class="sd">            four images.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; mosaic = Mosaic(dataset, imgsz=640, p=1.0, n=4)</span>
<span></span><span class="sd">        &gt;&gt;&gt; labels = {</span>
<span></span><span class="sd">        ...     "img": np.random.rand(480, 640, 3),</span>
<span></span><span class="sd">        ...     "mix_labels": [{"img": np.random.rand(480, 640, 3)} for _ in range(3)],</span>
<span></span><span class="sd">        ... }</span>
<span></span><span class="sd">        &gt;&gt;&gt; result = mosaic._mosaic4(labels)</span>
<span></span><span class="sd">        &gt;&gt;&gt; assert result["img"].shape == (1280, 1280, 3)</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="n">mosaic_labels</span> <span class="o">=</span> <span class="p">[]</span>
<span></span>    <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imgsz</span>
<span></span>    <span class="n">yc</span><span class="p">,</span> <span class="n">xc</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">border</span><span class="p">)</span>  <span class="c1"># mosaic center x, y</span>
<span></span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
<span></span>        <span class="n">labels_patch</span> <span class="o">=</span> <span class="n">labels</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">labels</span><span class="p">[</span><span class="s2">"mix_labels"</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
<span></span>        <span class="c1"># Load image</span>
<span></span>        <span class="n">img</span> <span class="o">=</span> <span class="n">labels_patch</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span>
<span></span>        <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">labels_patch</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"resized_shape"</span><span class="p">)</span>
<span></span>
<span></span>        <span class="c1"># Place img in img4</span>
<span></span>        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># top left</span>
<span></span>            <span class="n">img4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">s</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">s</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="mi">114</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>  <span class="c1"># base image with 4 tiles</span>
<span></span>            <span class="n">x1a</span><span class="p">,</span> <span class="n">y1a</span><span class="p">,</span> <span class="n">x2a</span><span class="p">,</span> <span class="n">y2a</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">xc</span> <span class="o">-</span> <span class="n">w</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">yc</span> <span class="o">-</span> <span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">xc</span><span class="p">,</span> <span class="n">yc</span>  <span class="c1"># xmin, ymin, xmax, ymax (large image)</span>
<span></span>            <span class="n">x1b</span><span class="p">,</span> <span class="n">y1b</span><span class="p">,</span> <span class="n">x2b</span><span class="p">,</span> <span class="n">y2b</span> <span class="o">=</span> <span class="n">w</span> <span class="o">-</span> <span class="p">(</span><span class="n">x2a</span> <span class="o">-</span> <span class="n">x1a</span><span class="p">),</span> <span class="n">h</span> <span class="o">-</span> <span class="p">(</span><span class="n">y2a</span> <span class="o">-</span> <span class="n">y1a</span><span class="p">),</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span>  <span class="c1"># xmin, ymin, xmax, ymax (small image)</span>
<span></span>        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># top right</span>
<span></span>            <span class="n">x1a</span><span class="p">,</span> <span class="n">y1a</span><span class="p">,</span> <span class="n">x2a</span><span class="p">,</span> <span class="n">y2a</span> <span class="o">=</span> <span class="n">xc</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">yc</span> <span class="o">-</span> <span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">xc</span> <span class="o">+</span> <span class="n">w</span><span class="p">,</span> <span class="n">s</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span> <span class="n">yc</span>
<span></span>            <span class="n">x1b</span><span class="p">,</span> <span class="n">y1b</span><span class="p">,</span> <span class="n">x2b</span><span class="p">,</span> <span class="n">y2b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">h</span> <span class="o">-</span> <span class="p">(</span><span class="n">y2a</span> <span class="o">-</span> <span class="n">y1a</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">x2a</span> <span class="o">-</span> <span class="n">x1a</span><span class="p">),</span> <span class="n">h</span>
<span></span>        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># bottom left</span>
<span></span>            <span class="n">x1a</span><span class="p">,</span> <span class="n">y1a</span><span class="p">,</span> <span class="n">x2a</span><span class="p">,</span> <span class="n">y2a</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">xc</span> <span class="o">-</span> <span class="n">w</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">yc</span><span class="p">,</span> <span class="n">xc</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">s</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">yc</span> <span class="o">+</span> <span class="n">h</span><span class="p">)</span>
<span></span>            <span class="n">x1b</span><span class="p">,</span> <span class="n">y1b</span><span class="p">,</span> <span class="n">x2b</span><span class="p">,</span> <span class="n">y2b</span> <span class="o">=</span> <span class="n">w</span> <span class="o">-</span> <span class="p">(</span><span class="n">x2a</span> <span class="o">-</span> <span class="n">x1a</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">y2a</span> <span class="o">-</span> <span class="n">y1a</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
<span></span>        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># bottom right</span>
<span></span>            <span class="n">x1a</span><span class="p">,</span> <span class="n">y1a</span><span class="p">,</span> <span class="n">x2a</span><span class="p">,</span> <span class="n">y2a</span> <span class="o">=</span> <span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">xc</span> <span class="o">+</span> <span class="n">w</span><span class="p">,</span> <span class="n">s</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">s</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">yc</span> <span class="o">+</span> <span class="n">h</span><span class="p">)</span>
<span></span>            <span class="n">x1b</span><span class="p">,</span> <span class="n">y1b</span><span class="p">,</span> <span class="n">x2b</span><span class="p">,</span> <span class="n">y2b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">x2a</span> <span class="o">-</span> <span class="n">x1a</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">y2a</span> <span class="o">-</span> <span class="n">y1a</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
<span></span>
<span></span>        <span class="n">img4</span><span class="p">[</span><span class="n">y1a</span><span class="p">:</span><span class="n">y2a</span><span class="p">,</span> <span class="n">x1a</span><span class="p">:</span><span class="n">x2a</span><span class="p">]</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">y1b</span><span class="p">:</span><span class="n">y2b</span><span class="p">,</span> <span class="n">x1b</span><span class="p">:</span><span class="n">x2b</span><span class="p">]</span>  <span class="c1"># img4[ymin:ymax, xmin:xmax]</span>
<span></span>        <span class="n">padw</span> <span class="o">=</span> <span class="n">x1a</span> <span class="o">-</span> <span class="n">x1b</span>
<span></span>        <span class="n">padh</span> <span class="o">=</span> <span class="n">y1a</span> <span class="o">-</span> <span class="n">y1b</span>
<span></span>
<span></span>        <span class="n">labels_patch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_labels</span><span class="p">(</span><span class="n">labels_patch</span><span class="p">,</span> <span class="n">padw</span><span class="p">,</span> <span class="n">padh</span><span class="p">)</span>
<span></span>        <span class="n">mosaic_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">labels_patch</span><span class="p">)</span>
<span></span>    <span class="n">final_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cat_labels</span><span class="p">(</span><span class="n">mosaic_labels</span><span class="p">)</span>
<span></span>    <span class="n">final_labels</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span> <span class="o">=</span> <span class="n">img4</span>
<span></span>    <span class="k">return</span> <span class="n">final_labels</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.Mosaic._mosaic9"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.Mosaic._mosaic9</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_mosaic9</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
</code></pre></div><p>Create a 3x3 image mosaic from the input image and eight additional images.</p><p>This method combines nine images into a single mosaic image. The input image is placed at the center, and eight additional images from the dataset are placed around it in a 3x3 grid pattern.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>labels</code></td><td><code>dict[str, Any]</code></td><td>A dictionary containing the input image and its associated labels. It should have</td><td><em>required</em></td></tr><tr><td><code>the following keys:&lt;br&gt;    - 'img' (np.ndarray): The input image.&lt;br&gt;    - 'resized_shape' (tuple[int, int]): The shape of the resized image (height, width).&lt;br&gt;    - 'mix_labels' (list[dict]): A list of dictionaries containing information for the additional</code></td><td></td><td></td><td><em>required</em></td></tr><tr><td><code>eight images, each with the same structure as the input labels.</code></td><td></td><td></td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dict[str, Any]</code></td><td>A dictionary containing the mosaic image and updated labels. It includes the following</td></tr><tr><td><code>keys</code></td><td>- 'img' (np.ndarray): The final mosaic image.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">mosaic</span> <span class="o">=</span> <span class="n">Mosaic</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">imgsz</span><span class="o">=</span><span class="mi">640</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">input_labels</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">mosaic_result</span> <span class="o">=</span> <span class="n">mosaic</span><span class="o">.</span><span class="n">_mosaic9</span><span class="p">(</span><span class="n">input_labels</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">mosaic_image</span> <span class="o">=</span> <span class="n">mosaic_result</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L671-L741"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_mosaic9</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span></span><span class="w">    </span><span class="sd">"""Create a 3x3 image mosaic from the input image and eight additional images.</span>
<span></span>
<span></span><span class="sd">    This method combines nine images into a single mosaic image. The input image is placed at the center, and eight</span>
<span></span><span class="sd">    additional images from the dataset are placed around it in a 3x3 grid pattern.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        labels (dict[str, Any]): A dictionary containing the input image and its associated labels. It should have</span>
<span></span><span class="sd">        the following keys:</span>
<span></span><span class="sd">            - 'img' (np.ndarray): The input image.</span>
<span></span><span class="sd">            - 'resized_shape' (tuple[int, int]): The shape of the resized image (height, width).</span>
<span></span><span class="sd">            - 'mix_labels' (list[dict]): A list of dictionaries containing information for the additional</span>
<span></span><span class="sd">        eight images, each with the same structure as the input labels.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (dict[str, Any]): A dictionary containing the mosaic image and updated labels. It includes the following</span>
<span></span><span class="sd">        keys:</span>
<span></span><span class="sd">            - 'img' (np.ndarray): The final mosaic image.</span>
<span></span><span class="sd">            - Other keys from the input labels, updated to reflect the new mosaic arrangement.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; mosaic = Mosaic(dataset, imgsz=640, p=1.0, n=9)</span>
<span></span><span class="sd">        &gt;&gt;&gt; input_labels = dataset[0]</span>
<span></span><span class="sd">        &gt;&gt;&gt; mosaic_result = mosaic._mosaic9(input_labels)</span>
<span></span><span class="sd">        &gt;&gt;&gt; mosaic_image = mosaic_result["img"]</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="n">mosaic_labels</span> <span class="o">=</span> <span class="p">[]</span>
<span></span>    <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imgsz</span>
<span></span>    <span class="n">hp</span><span class="p">,</span> <span class="n">wp</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># height, width previous</span>
<span></span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">):</span>
<span></span>        <span class="n">labels_patch</span> <span class="o">=</span> <span class="n">labels</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">labels</span><span class="p">[</span><span class="s2">"mix_labels"</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
<span></span>        <span class="c1"># Load image</span>
<span></span>        <span class="n">img</span> <span class="o">=</span> <span class="n">labels_patch</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span>
<span></span>        <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">labels_patch</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"resized_shape"</span><span class="p">)</span>
<span></span>
<span></span>        <span class="c1"># Place img in img9</span>
<span></span>        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># center</span>
<span></span>            <span class="n">img9</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">s</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="n">s</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="mi">114</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>  <span class="c1"># base image with 4 tiles</span>
<span></span>            <span class="n">h0</span><span class="p">,</span> <span class="n">w0</span> <span class="o">=</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span>
<span></span>            <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">w</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">h</span>  <span class="c1"># xmin, ymin, xmax, ymax (base) coordinates</span>
<span></span>        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># top</span>
<span></span>            <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span> <span class="o">-</span> <span class="n">h</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">w</span><span class="p">,</span> <span class="n">s</span>
<span></span>        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># top right</span>
<span></span>            <span class="n">c</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">wp</span><span class="p">,</span> <span class="n">s</span> <span class="o">-</span> <span class="n">h</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">wp</span> <span class="o">+</span> <span class="n">w</span><span class="p">,</span> <span class="n">s</span>
<span></span>        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># right</span>
<span></span>            <span class="n">c</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">w0</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">w0</span> <span class="o">+</span> <span class="n">w</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">h</span>
<span></span>        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>  <span class="c1"># bottom right</span>
<span></span>            <span class="n">c</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">w0</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">hp</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">w0</span> <span class="o">+</span> <span class="n">w</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">hp</span> <span class="o">+</span> <span class="n">h</span>
<span></span>        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>  <span class="c1"># bottom</span>
<span></span>            <span class="n">c</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">w0</span> <span class="o">-</span> <span class="n">w</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">h0</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">w0</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">h0</span> <span class="o">+</span> <span class="n">h</span>
<span></span>        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>  <span class="c1"># bottom left</span>
<span></span>            <span class="n">c</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">w0</span> <span class="o">-</span> <span class="n">wp</span> <span class="o">-</span> <span class="n">w</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">h0</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">w0</span> <span class="o">-</span> <span class="n">wp</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">h0</span> <span class="o">+</span> <span class="n">h</span>
<span></span>        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>  <span class="c1"># left</span>
<span></span>            <span class="n">c</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-</span> <span class="n">w</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">h0</span> <span class="o">-</span> <span class="n">h</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">h0</span>
<span></span>        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>  <span class="c1"># top left</span>
<span></span>            <span class="n">c</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-</span> <span class="n">w</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">h0</span> <span class="o">-</span> <span class="n">hp</span> <span class="o">-</span> <span class="n">h</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">h0</span> <span class="o">-</span> <span class="n">hp</span>
<span></span>
<span></span>        <span class="n">padw</span><span class="p">,</span> <span class="n">padh</span> <span class="o">=</span> <span class="n">c</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
<span></span>        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">c</span><span class="p">)</span>  <span class="c1"># allocate coordinates</span>
<span></span>
<span></span>        <span class="c1"># Image</span>
<span></span>        <span class="n">img9</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">]</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">y1</span> <span class="o">-</span> <span class="n">padh</span> <span class="p">:,</span> <span class="n">x1</span> <span class="o">-</span> <span class="n">padw</span> <span class="p">:]</span>  <span class="c1"># img9[ymin:ymax, xmin:xmax]</span>
<span></span>        <span class="n">hp</span><span class="p">,</span> <span class="n">wp</span> <span class="o">=</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span>  <span class="c1"># height, width previous for next iteration</span>
<span></span>
<span></span>        <span class="c1"># Labels assuming imgsz*2 mosaic size</span>
<span></span>        <span class="n">labels_patch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_labels</span><span class="p">(</span><span class="n">labels_patch</span><span class="p">,</span> <span class="n">padw</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">border</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">padh</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">border</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span></span>        <span class="n">mosaic_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">labels_patch</span><span class="p">)</span>
<span></span>    <span class="n">final_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cat_labels</span><span class="p">(</span><span class="n">mosaic_labels</span><span class="p">)</span>
<span></span>
<span></span>    <span class="n">final_labels</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span> <span class="o">=</span> <span class="n">img9</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">border</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">border</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">border</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">border</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
<span></span>    <span class="k">return</span> <span class="n">final_labels</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.Mosaic._update_labels"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.Mosaic._update_labels</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_update_labels</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">padw</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">padh</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
</code></pre></div><p>Update label coordinates with padding values.</p><p>This method adjusts the bounding box coordinates of object instances in the labels by adding padding values. It also denormalizes the coordinates if they were previously normalized.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>labels</code></td><td><code>dict[str, Any]</code></td><td>A dictionary containing image and instance information.</td><td><em>required</em></td></tr><tr><td><code>padw</code></td><td><code>int</code></td><td>Padding width to be added to the x-coordinates.</td><td><em>required</em></td></tr><tr><td><code>padh</code></td><td><code>int</code></td><td>Padding height to be added to the y-coordinates.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dict</code></td><td>Updated labels dictionary with adjusted instance coordinates.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">labels</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"img"</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="s2">"instances"</span><span class="p">:</span> <span class="n">Instances</span><span class="p">(</span><span class="o">...</span><span class="p">)}</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">padw</span><span class="p">,</span> <span class="n">padh</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">updated_labels</span> <span class="o">=</span> <span class="n">Mosaic</span><span class="o">.</span><span class="n">_update_labels</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">padw</span><span class="p">,</span> <span class="n">padh</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L744-L767"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="nd">@staticmethod</span>
<span></span><span class="k">def</span><span class="w"> </span><span class="nf">_update_labels</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">padw</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">padh</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span></span><span class="w">    </span><span class="sd">"""Update label coordinates with padding values.</span>
<span></span>
<span></span><span class="sd">    This method adjusts the bounding box coordinates of object instances in the labels by adding padding</span>
<span></span><span class="sd">    values. It also denormalizes the coordinates if they were previously normalized.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        labels (dict[str, Any]): A dictionary containing image and instance information.</span>
<span></span><span class="sd">        padw (int): Padding width to be added to the x-coordinates.</span>
<span></span><span class="sd">        padh (int): Padding height to be added to the y-coordinates.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (dict): Updated labels dictionary with adjusted instance coordinates.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; labels = {"img": np.zeros((100, 100, 3)), "instances": Instances(...)}</span>
<span></span><span class="sd">        &gt;&gt;&gt; padw, padh = 50, 50</span>
<span></span><span class="sd">        &gt;&gt;&gt; updated_labels = Mosaic._update_labels(labels, padw, padh)</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="n">nh</span><span class="p">,</span> <span class="n">nw</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]</span><span class="o">.</span><span class="n">convert_bbox</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s2">"xyxy"</span><span class="p">)</span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]</span><span class="o">.</span><span class="n">denormalize</span><span class="p">(</span><span class="n">nw</span><span class="p">,</span> <span class="n">nh</span><span class="p">)</span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]</span><span class="o">.</span><span class="n">add_padding</span><span class="p">(</span><span class="n">padw</span><span class="p">,</span> <span class="n">padh</span><span class="p">)</span>
<span></span>    <span class="k">return</span> <span class="n">labels</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.Mosaic.get_indexes"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.Mosaic.get_indexes</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</code></pre></div><p>Return a list of random indexes from the dataset for mosaic augmentation.</p><p>This method selects random image indexes either from a buffer or from the entire dataset, depending on the 'buffer' parameter. It is used to choose images for creating mosaic augmentations.</p><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>list[int]</code></td><td>A list of random image indexes. The length of the list is n-1, where n is the number of images</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">mosaic</span> <span class="o">=</span> <span class="n">Mosaic</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">imgsz</span><span class="o">=</span><span class="mi">640</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">indexes</span> <span class="o">=</span> <span class="n">mosaic</span><span class="o">.</span><span class="n">get_indexes</span><span class="p">()</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">))</span>  <span class="c1"># Output: 3</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L507-L525"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span></span><span class="w">    </span><span class="sd">"""Return a list of random indexes from the dataset for mosaic augmentation.</span>
<span></span>
<span></span><span class="sd">    This method selects random image indexes either from a buffer or from the entire dataset, depending on the</span>
<span></span><span class="sd">    'buffer' parameter. It is used to choose images for creating mosaic augmentations.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (list[int]): A list of random image indexes. The length of the list is n-1, where n is the number of images</span>
<span></span><span class="sd">            used in the mosaic (either 3 or 8, depending on whether n is 4 or 9).</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; mosaic = Mosaic(dataset, imgsz=640, p=1.0, n=4)</span>
<span></span><span class="sd">        &gt;&gt;&gt; indexes = mosaic.get_indexes()</span>
<span></span><span class="sd">        &gt;&gt;&gt; print(len(indexes))  # Output: 3</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer_enabled</span><span class="p">:</span>  <span class="c1"># select images from buffer</span>
<span></span>        <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">choices</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">buffer</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span></span>    <span class="k">else</span><span class="p">:</span>  <span class="c1"># select any images</span>
<span></span>        <span class="k">return</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
</code></pre></div></details><p><br/><br/><hr/><br/></p><h2 id="ultralytics.data.augment.MixUp"><span class="doc-kind doc-kind-class">class</span> <code>ultralytics.data.augment.MixUp</code></h2><div class="highlight"><pre><span></span><code><span></span><span class="n">MixUp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">pre_transform</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div><p><strong>Bases:</strong> <code>BaseMixTransform</code></p><p>Apply MixUp augmentation to image datasets.</p><p>This class implements the MixUp augmentation technique as described in the paper <a href="https://arxiv.org/abs/1710.09412">mixup: Beyond Empirical Risk Minimization</a>. MixUp combines two images and their labels using a random weight.</p><p>MixUp is an image augmentation technique that combines two images by taking a weighted sum of their pixel values and labels. This implementation is designed for use with the Ultralytics YOLO framework.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>dataset</code></td><td><code>Any</code></td><td>The dataset to which MixUp augmentation will be applied.</td><td><em>required</em></td></tr><tr><td><code>pre_transform</code></td><td><code>Callable | None</code></td><td>Optional transform to apply to images before MixUp.</td><td><code>None</code></td></tr><tr><td><code>p</code></td><td><code>float</code></td><td>Probability of applying MixUp augmentation to an image. Must be in the range [0, 1].</td><td><code>0.0</code></td></tr></tbody></table><p><strong>Attributes</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dataset</code></td><td><code>Any</code></td><td>The dataset to which MixUp augmentation will be applied.</td></tr><tr><td><code>pre_transform</code></td><td><code>Callable | None</code></td><td>Optional transform to apply before MixUp.</td></tr><tr><td><code>p</code></td><td><code>float</code></td><td>Probability of applying MixUp augmentation.</td></tr></tbody></table><p><strong>Methods</strong></p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="#ultralytics.data.augment.MixUp._mix_transform"><code>_mix_transform</code></a></td><td>Apply MixUp augmentation to the input labels.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span><span class="w"> </span><span class="nn">ultralytics.data.augment</span><span class="w"> </span><span class="kn">import</span> <span class="n">MixUp</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">dataset</span> <span class="o">=</span> <span class="n">YourDataset</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>  <span class="c1"># Your image dataset</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">mixup</span> <span class="o">=</span> <span class="n">MixUp</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">augmented_labels</span> <span class="o">=</span> <span class="n">mixup</span><span class="p">(</span><span class="n">original_labels</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L820-L875"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MixUp</span><span class="p">(</span><span class="n">BaseMixTransform</span><span class="p">):</span>
<span></span><span class="w">    </span><span class="sd">"""Apply MixUp augmentation to image datasets.</span>
<span></span>
<span></span><span class="sd">    This class implements the MixUp augmentation technique as described in the paper [mixup: Beyond Empirical Risk</span>
<span></span><span class="sd">    Minimization](https://arxiv.org/abs/1710.09412). MixUp combines two images and their labels using a random weight.</span>
<span></span>
<span></span><span class="sd">    Attributes:</span>
<span></span><span class="sd">        dataset (Any): The dataset to which MixUp augmentation will be applied.</span>
<span></span><span class="sd">        pre_transform (Callable | None): Optional transform to apply before MixUp.</span>
<span></span><span class="sd">        p (float): Probability of applying MixUp augmentation.</span>
<span></span>
<span></span><span class="sd">    Methods:</span>
<span></span><span class="sd">        _mix_transform: Apply MixUp augmentation to the input labels.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; from ultralytics.data.augment import MixUp</span>
<span></span><span class="sd">        &gt;&gt;&gt; dataset = YourDataset(...)  # Your image dataset</span>
<span></span><span class="sd">        &gt;&gt;&gt; mixup = MixUp(dataset, p=0.5)</span>
<span></span><span class="sd">        &gt;&gt;&gt; augmented_labels = mixup(original_labels)</span>
<span></span><span class="sd">    """</span>
<span></span>
<span></span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">pre_transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span></span><span class="w">        </span><span class="sd">"""Initialize the MixUp augmentation object.</span>
<span></span>
<span></span><span class="sd">        MixUp is an image augmentation technique that combines two images by taking a weighted sum of their pixel values</span>
<span></span><span class="sd">        and labels. This implementation is designed for use with the Ultralytics YOLO framework.</span>
<span></span>
<span></span><span class="sd">        Args:</span>
<span></span><span class="sd">            dataset (Any): The dataset to which MixUp augmentation will be applied.</span>
<span></span><span class="sd">            pre_transform (Callable | None): Optional transform to apply to images before MixUp.</span>
<span></span><span class="sd">            p (float): Probability of applying MixUp augmentation to an image. Must be in the range [0, 1].</span>
<span></span><span class="sd">        """</span>
<span></span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="n">pre_transform</span><span class="o">=</span><span class="n">pre_transform</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.MixUp._mix_transform"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.MixUp._mix_transform</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_mix_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
</code></pre></div><p>Apply MixUp augmentation to the input labels.</p><p>This method implements the MixUp augmentation technique as described in the paper "mixup: Beyond Empirical Risk Minimization" (<a href="https://arxiv.org/abs/1710.09412">https://arxiv.org/abs/1710.09412</a>).</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>labels</code></td><td><code>dict[str, Any]</code></td><td>A dictionary containing the original image and label information.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dict[str, Any]</code></td><td>A dictionary containing the mixed-up image and combined label information.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">mixer</span> <span class="o">=</span> <span class="n">MixUp</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">mixed_labels</span> <span class="o">=</span> <span class="n">mixer</span><span class="o">.</span><span class="n">_mix_transform</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L854-L875"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_mix_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span></span><span class="w">    </span><span class="sd">"""Apply MixUp augmentation to the input labels.</span>
<span></span>
<span></span><span class="sd">    This method implements the MixUp augmentation technique as described in the paper "mixup: Beyond Empirical Risk</span>
<span></span><span class="sd">    Minimization" (https://arxiv.org/abs/1710.09412).</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        labels (dict[str, Any]): A dictionary containing the original image and label information.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (dict[str, Any]): A dictionary containing the mixed-up image and combined label information.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; mixer = MixUp(dataset)</span>
<span></span><span class="sd">        &gt;&gt;&gt; mixed_labels = mixer._mix_transform(labels)</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">beta</span><span class="p">(</span><span class="mf">32.0</span><span class="p">,</span> <span class="mf">32.0</span><span class="p">)</span>  <span class="c1"># mixup ratio, alpha=beta=32.0</span>
<span></span>    <span class="n">labels2</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="s2">"mix_labels"</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="n">labels2</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">r</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]</span> <span class="o">=</span> <span class="n">Instances</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">labels</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">],</span> <span class="n">labels2</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"cls"</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">labels</span><span class="p">[</span><span class="s2">"cls"</span><span class="p">],</span> <span class="n">labels2</span><span class="p">[</span><span class="s2">"cls"</span><span class="p">]],</span> <span class="mi">0</span><span class="p">)</span>
<span></span>    <span class="k">return</span> <span class="n">labels</span>
</code></pre></div></details><p><br/><br/><hr/><br/></p><h2 id="ultralytics.data.augment.CutMix"><span class="doc-kind doc-kind-class">class</span> <code>ultralytics.data.augment.CutMix</code></h2><div class="highlight"><pre><span></span><code><span></span><span class="n">CutMix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">pre_transform</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">num_areas</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div><p><strong>Bases:</strong> <code>BaseMixTransform</code></p><p>Apply CutMix augmentation to image datasets as described in the paper <a href="https://arxiv.org/abs/1905.04899">https://arxiv.org/abs/1905.04899</a>.</p><p>CutMix combines two images by replacing a random rectangular region of one image with the corresponding region from another image, and adjusts the labels proportionally to the area of the mixed region.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>dataset</code></td><td><code>Any</code></td><td>The dataset to which CutMix augmentation will be applied.</td><td><em>required</em></td></tr><tr><td><code>pre_transform</code></td><td><code>Callable | None</code></td><td>Optional transform to apply before CutMix.</td><td><code>None</code></td></tr><tr><td><code>p</code></td><td><code>float</code></td><td>Probability of applying CutMix augmentation.</td><td><code>0.0</code></td></tr><tr><td><code>beta</code></td><td><code>float</code></td><td>Beta distribution parameter for sampling the mixing ratio.</td><td><code>1.0</code></td></tr><tr><td><code>num_areas</code></td><td><code>int</code></td><td>Number of areas to try to cut and mix.</td><td><code>3</code></td></tr></tbody></table><p><strong>Attributes</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dataset</code></td><td><code>Any</code></td><td>The dataset to which CutMix augmentation will be applied.</td></tr><tr><td><code>pre_transform</code></td><td><code>Callable | None</code></td><td>Optional transform to apply before CutMix.</td></tr><tr><td><code>p</code></td><td><code>float</code></td><td>Probability of applying CutMix augmentation.</td></tr><tr><td><code>beta</code></td><td><code>float</code></td><td>Beta distribution parameter for sampling the mixing ratio.</td></tr><tr><td><code>num_areas</code></td><td><code>int</code></td><td>Number of areas to try to cut and mix.</td></tr></tbody></table><p><strong>Methods</strong></p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="#ultralytics.data.augment.CutMix._mix_transform"><code>_mix_transform</code></a></td><td>Apply CutMix augmentation to the input labels.</td></tr><tr><td><a href="#ultralytics.data.augment.CutMix._rand_bbox"><code>_rand_bbox</code></a></td><td>Generate random bounding box coordinates for the cut region.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span><span class="w"> </span><span class="nn">ultralytics.data.augment</span><span class="w"> </span><span class="kn">import</span> <span class="n">CutMix</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">dataset</span> <span class="o">=</span> <span class="n">YourDataset</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>  <span class="c1"># Your image dataset</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">cutmix</span> <span class="o">=</span> <span class="n">CutMix</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">augmented_labels</span> <span class="o">=</span> <span class="n">cutmix</span><span class="p">(</span><span class="n">original_labels</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L878-L989"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">class</span><span class="w"> </span><span class="nc">CutMix</span><span class="p">(</span><span class="n">BaseMixTransform</span><span class="p">):</span>
<span></span><span class="w">    </span><span class="sd">"""Apply CutMix augmentation to image datasets as described in the paper https://arxiv.org/abs/1905.04899.</span>
<span></span>
<span></span><span class="sd">    CutMix combines two images by replacing a random rectangular region of one image with the corresponding region from</span>
<span></span><span class="sd">    another image, and adjusts the labels proportionally to the area of the mixed region.</span>
<span></span>
<span></span><span class="sd">    Attributes:</span>
<span></span><span class="sd">        dataset (Any): The dataset to which CutMix augmentation will be applied.</span>
<span></span><span class="sd">        pre_transform (Callable | None): Optional transform to apply before CutMix.</span>
<span></span><span class="sd">        p (float): Probability of applying CutMix augmentation.</span>
<span></span><span class="sd">        beta (float): Beta distribution parameter for sampling the mixing ratio.</span>
<span></span><span class="sd">        num_areas (int): Number of areas to try to cut and mix.</span>
<span></span>
<span></span><span class="sd">    Methods:</span>
<span></span><span class="sd">        _mix_transform: Apply CutMix augmentation to the input labels.</span>
<span></span><span class="sd">        _rand_bbox: Generate random bounding box coordinates for the cut region.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; from ultralytics.data.augment import CutMix</span>
<span></span><span class="sd">        &gt;&gt;&gt; dataset = YourDataset(...)  # Your image dataset</span>
<span></span><span class="sd">        &gt;&gt;&gt; cutmix = CutMix(dataset, p=0.5)</span>
<span></span><span class="sd">        &gt;&gt;&gt; augmented_labels = cutmix(original_labels)</span>
<span></span><span class="sd">    """</span>
<span></span>
<span></span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">pre_transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">num_areas</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span></span><span class="w">        </span><span class="sd">"""Initialize the CutMix augmentation object.</span>
<span></span>
<span></span><span class="sd">        Args:</span>
<span></span><span class="sd">            dataset (Any): The dataset to which CutMix augmentation will be applied.</span>
<span></span><span class="sd">            pre_transform (Callable | None): Optional transform to apply before CutMix.</span>
<span></span><span class="sd">            p (float): Probability of applying CutMix augmentation.</span>
<span></span><span class="sd">            beta (float): Beta distribution parameter for sampling the mixing ratio.</span>
<span></span><span class="sd">            num_areas (int): Number of areas to try to cut and mix.</span>
<span></span><span class="sd">        """</span>
<span></span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="n">pre_transform</span><span class="o">=</span><span class="n">pre_transform</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="n">beta</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">num_areas</span> <span class="o">=</span> <span class="n">num_areas</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.CutMix._mix_transform"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.CutMix._mix_transform</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_mix_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
</code></pre></div><p>Apply CutMix augmentation to the input labels.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>labels</code></td><td><code>dict[str, Any]</code></td><td>A dictionary containing the original image and label information.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dict[str, Any]</code></td><td>A dictionary containing the mixed image and adjusted labels.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">cutter</span> <span class="o">=</span> <span class="n">CutMix</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">mixed_labels</span> <span class="o">=</span> <span class="n">cutter</span><span class="o">.</span><span class="n">_mix_transform</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L945-L989"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_mix_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span></span><span class="w">    </span><span class="sd">"""Apply CutMix augmentation to the input labels.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        labels (dict[str, Any]): A dictionary containing the original image and label information.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (dict[str, Any]): A dictionary containing the mixed image and adjusted labels.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; cutter = CutMix(dataset)</span>
<span></span><span class="sd">        &gt;&gt;&gt; mixed_labels = cutter._mix_transform(labels)</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="c1"># Get a random second image</span>
<span></span>    <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
<span></span>
<span></span>    <span class="n">cut_areas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_rand_bbox</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_areas</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span></span>    <span class="n">ioa1</span> <span class="o">=</span> <span class="n">bbox_ioa</span><span class="p">(</span><span class="n">cut_areas</span><span class="p">,</span> <span class="n">labels</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]</span><span class="o">.</span><span class="n">bboxes</span><span class="p">)</span>  <span class="c1"># (self.num_areas, num_boxes)</span>
<span></span>    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">ioa1</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span></span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span></span>        <span class="k">return</span> <span class="n">labels</span>
<span></span>
<span></span>    <span class="n">labels2</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"mix_labels"</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span></span>    <span class="n">area</span> <span class="o">=</span> <span class="n">cut_areas</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span>  <span class="c1"># randomly select one</span>
<span></span>    <span class="n">ioa2</span> <span class="o">=</span> <span class="n">bbox_ioa</span><span class="p">(</span><span class="n">area</span><span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="n">labels2</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]</span><span class="o">.</span><span class="n">bboxes</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span></span>    <span class="n">indexes2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">ioa2</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mf">0.01</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span> <span class="k">else</span> <span class="mf">0.1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
<span></span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span></span>        <span class="k">return</span> <span class="n">labels</span>
<span></span>
<span></span>    <span class="n">instances2</span> <span class="o">=</span> <span class="n">labels2</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">][</span><span class="n">indexes2</span><span class="p">]</span>
<span></span>    <span class="n">instances2</span><span class="o">.</span><span class="n">convert_bbox</span><span class="p">(</span><span class="s2">"xyxy"</span><span class="p">)</span>
<span></span>    <span class="n">instances2</span><span class="o">.</span><span class="n">denormalize</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
<span></span>
<span></span>    <span class="c1"># Apply CutMix</span>
<span></span>    <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">area</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"img"</span><span class="p">][</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">]</span> <span class="o">=</span> <span class="n">labels2</span><span class="p">[</span><span class="s2">"img"</span><span class="p">][</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">]</span>
<span></span>
<span></span>    <span class="c1"># Restrain instances2 to the random bounding border</span>
<span></span>    <span class="n">instances2</span><span class="o">.</span><span class="n">add_padding</span><span class="p">(</span><span class="o">-</span><span class="n">x1</span><span class="p">,</span> <span class="o">-</span><span class="n">y1</span><span class="p">)</span>
<span></span>    <span class="n">instances2</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span>
<span></span>    <span class="n">instances2</span><span class="o">.</span><span class="n">add_padding</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span>
<span></span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"cls"</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">labels</span><span class="p">[</span><span class="s2">"cls"</span><span class="p">],</span> <span class="n">labels2</span><span class="p">[</span><span class="s2">"cls"</span><span class="p">][</span><span class="n">indexes2</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]</span> <span class="o">=</span> <span class="n">Instances</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">labels</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">],</span> <span class="n">instances2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span></span>    <span class="k">return</span> <span class="n">labels</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.CutMix._rand_bbox"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.CutMix._rand_bbox</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_rand_bbox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
</code></pre></div><p>Generate random bounding box coordinates for the cut region.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>width</code></td><td><code>int</code></td><td>Width of the image.</td><td><em>required</em></td></tr><tr><td><code>height</code></td><td><code>int</code></td><td>Height of the image.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>tuple[int]</code></td><td>(x1, y1, x2, y2) coordinates of the bounding box.</td></tr></tbody></table><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L916-L943"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_rand_bbox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span></span><span class="w">    </span><span class="sd">"""Generate random bounding box coordinates for the cut region.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        width (int): Width of the image.</span>
<span></span><span class="sd">        height (int): Height of the image.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (tuple[int]): (x1, y1, x2, y2) coordinates of the bounding box.</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="c1"># Sample mixing ratio from Beta distribution</span>
<span></span>    <span class="n">lam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">beta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="p">)</span>
<span></span>
<span></span>    <span class="n">cut_ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">lam</span><span class="p">)</span>
<span></span>    <span class="n">cut_w</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="n">cut_ratio</span><span class="p">)</span>
<span></span>    <span class="n">cut_h</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">height</span> <span class="o">*</span> <span class="n">cut_ratio</span><span class="p">)</span>
<span></span>
<span></span>    <span class="c1"># Random center</span>
<span></span>    <span class="n">cx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">width</span><span class="p">)</span>
<span></span>    <span class="n">cy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">height</span><span class="p">)</span>
<span></span>
<span></span>    <span class="c1"># Bounding box coordinates</span>
<span></span>    <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">cx</span> <span class="o">-</span> <span class="n">cut_w</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
<span></span>    <span class="n">y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">cy</span> <span class="o">-</span> <span class="n">cut_h</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
<span></span>    <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">cx</span> <span class="o">+</span> <span class="n">cut_w</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
<span></span>    <span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">cy</span> <span class="o">+</span> <span class="n">cut_h</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
<span></span>
<span></span>    <span class="k">return</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span>
</code></pre></div></details><p><br/><br/><hr/><br/></p><h2 id="ultralytics.data.augment.RandomPerspective"><span class="doc-kind doc-kind-class">class</span> <code>ultralytics.data.augment.RandomPerspective</code></h2><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
<span></span>    <span class="bp">self</span><span class="p">,</span>
<span></span>    <span class="n">degrees</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
<span></span>    <span class="n">translate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
<span></span>    <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
<span></span>    <span class="n">shear</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
<span></span>    <span class="n">perspective</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
<span></span>    <span class="n">border</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span></span>    <span class="n">pre_transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span></span><span class="p">)</span>
</code></pre></div><p>Implement random perspective and affine transformations on images and corresponding annotations.</p><p>This class applies random rotations, translations, scaling, shearing, and perspective transformations to images and their associated bounding boxes, segments, and keypoints. It can be used as part of an augmentation pipeline for object detection and instance segmentation tasks.</p><p>This class implements random perspective and affine transformations on images and corresponding bounding boxes, segments, and keypoints. Transformations include rotation, translation, scaling, and shearing.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>degrees</code></td><td><code>float</code></td><td>Degree range for random rotations.</td><td><code>0.0</code></td></tr><tr><td><code>translate</code></td><td><code>float</code></td><td>Fraction of total width and height for random translation.</td><td><code>0.1</code></td></tr><tr><td><code>scale</code></td><td><code>float</code></td><td>Scaling factor interval, e.g., a scale factor of 0.5 allows a resize between 50%-150%.</td><td><code>0.5</code></td></tr><tr><td><code>shear</code></td><td><code>float</code></td><td>Shear intensity (angle in degrees).</td><td><code>0.0</code></td></tr><tr><td><code>perspective</code></td><td><code>float</code></td><td>Perspective distortion factor.</td><td><code>0.0</code></td></tr><tr><td><code>border</code></td><td><code>tuple[int, int]</code></td><td>Tuple specifying mosaic border (top/bottom, left/right).</td><td><code>(0, 0)</code></td></tr><tr><td><code>pre_transform</code></td><td><code>Callable | None</code></td><td>Function/transform to apply to the image before starting the random transformation.</td><td><code>None</code></td></tr></tbody></table><p><strong>Attributes</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>degrees</code></td><td><code>float</code></td><td>Maximum absolute degree range for random rotations.</td></tr><tr><td><code>translate</code></td><td><code>float</code></td><td>Maximum translation as a fraction of the image size.</td></tr><tr><td><code>scale</code></td><td><code>float</code></td><td>Scaling factor range, e.g., scale=0.1 means 0.9-1.1.</td></tr><tr><td><code>shear</code></td><td><code>float</code></td><td>Maximum shear angle in degrees.</td></tr><tr><td><code>perspective</code></td><td><code>float</code></td><td>Perspective distortion factor.</td></tr><tr><td><code>border</code></td><td><code>tuple[int, int]</code></td><td>Mosaic border size as (x, y).</td></tr><tr><td><code>pre_transform</code></td><td><code>Callable | None</code></td><td>Optional transform to apply before the random perspective.</td></tr></tbody></table><p><strong>Methods</strong></p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="#ultralytics.data.augment.RandomPerspective.__call__"><code>__call__</code></a></td><td>Apply random perspective and affine transformations to an image and its associated labels.</td></tr><tr><td><a href="#ultralytics.data.augment.RandomPerspective.affine_transform"><code>affine_transform</code></a></td><td>Apply a sequence of affine transformations centered around the image center.</td></tr><tr><td><a href="#ultralytics.data.augment.RandomPerspective.apply_bboxes"><code>apply_bboxes</code></a></td><td>Apply affine transformation to bounding boxes.</td></tr><tr><td><a href="#ultralytics.data.augment.RandomPerspective.apply_keypoints"><code>apply_keypoints</code></a></td><td>Apply affine transformation to keypoints.</td></tr><tr><td><a href="#ultralytics.data.augment.RandomPerspective.apply_segments"><code>apply_segments</code></a></td><td>Apply affine transformations to segments and generate new bounding boxes.</td></tr><tr><td><a href="#ultralytics.data.augment.RandomPerspective.box_candidates"><code>box_candidates</code></a></td><td>Compute candidate boxes for further processing based on size and aspect ratio criteria.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">RandomPerspective</span><span class="p">(</span><span class="n">degrees</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">translate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">shear</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">labels</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"img"</span><span class="p">:</span> <span class="n">image</span><span class="p">,</span> <span class="s2">"cls"</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="s2">"instances"</span><span class="p">:</span> <span class="n">Instances</span><span class="p">(</span><span class="o">...</span><span class="p">)}</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transformed_image</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transformed_instances</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L992-L1343"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">class</span><span class="w"> </span><span class="nc">RandomPerspective</span><span class="p">:</span>
<span></span><span class="w">    </span><span class="sd">"""Implement random perspective and affine transformations on images and corresponding annotations.</span>
<span></span>
<span></span><span class="sd">    This class applies random rotations, translations, scaling, shearing, and perspective transformations to images and</span>
<span></span><span class="sd">    their associated bounding boxes, segments, and keypoints. It can be used as part of an augmentation pipeline for</span>
<span></span><span class="sd">    object detection and instance segmentation tasks.</span>
<span></span>
<span></span><span class="sd">    Attributes:</span>
<span></span><span class="sd">        degrees (float): Maximum absolute degree range for random rotations.</span>
<span></span><span class="sd">        translate (float): Maximum translation as a fraction of the image size.</span>
<span></span><span class="sd">        scale (float): Scaling factor range, e.g., scale=0.1 means 0.9-1.1.</span>
<span></span><span class="sd">        shear (float): Maximum shear angle in degrees.</span>
<span></span><span class="sd">        perspective (float): Perspective distortion factor.</span>
<span></span><span class="sd">        border (tuple[int, int]): Mosaic border size as (x, y).</span>
<span></span><span class="sd">        pre_transform (Callable | None): Optional transform to apply before the random perspective.</span>
<span></span>
<span></span><span class="sd">    Methods:</span>
<span></span><span class="sd">        affine_transform: Apply affine transformations to the input image.</span>
<span></span><span class="sd">        apply_bboxes: Transform bounding boxes using the affine matrix.</span>
<span></span><span class="sd">        apply_segments: Transform segments and generate new bounding boxes.</span>
<span></span><span class="sd">        apply_keypoints: Transform keypoints using the affine matrix.</span>
<span></span><span class="sd">        __call__: Apply the random perspective transformation to images and annotations.</span>
<span></span><span class="sd">        box_candidates: Filter transformed bounding boxes based on size and aspect ratio.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; transform = RandomPerspective(degrees=10, translate=0.1, scale=0.1, shear=10)</span>
<span></span><span class="sd">        &gt;&gt;&gt; image = np.random.randint(0, 255, (640, 640, 3), dtype=np.uint8)</span>
<span></span><span class="sd">        &gt;&gt;&gt; labels = {"img": image, "cls": np.array([0, 1]), "instances": Instances(...)}</span>
<span></span><span class="sd">        &gt;&gt;&gt; result = transform(labels)</span>
<span></span><span class="sd">        &gt;&gt;&gt; transformed_image = result["img"]</span>
<span></span><span class="sd">        &gt;&gt;&gt; transformed_instances = result["instances"]</span>
<span></span><span class="sd">    """</span>
<span></span>
<span></span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
<span></span>        <span class="bp">self</span><span class="p">,</span>
<span></span>        <span class="n">degrees</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
<span></span>        <span class="n">translate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
<span></span>        <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
<span></span>        <span class="n">shear</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
<span></span>        <span class="n">perspective</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
<span></span>        <span class="n">border</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span></span>        <span class="n">pre_transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span></span>    <span class="p">):</span>
<span></span><span class="w">        </span><span class="sd">"""Initialize RandomPerspective object with transformation parameters.</span>
<span></span>
<span></span><span class="sd">        This class implements random perspective and affine transformations on images and corresponding bounding boxes,</span>
<span></span><span class="sd">        segments, and keypoints. Transformations include rotation, translation, scaling, and shearing.</span>
<span></span>
<span></span><span class="sd">        Args:</span>
<span></span><span class="sd">            degrees (float): Degree range for random rotations.</span>
<span></span><span class="sd">            translate (float): Fraction of total width and height for random translation.</span>
<span></span><span class="sd">            scale (float): Scaling factor interval, e.g., a scale factor of 0.5 allows a resize between 50%-150%.</span>
<span></span><span class="sd">            shear (float): Shear intensity (angle in degrees).</span>
<span></span><span class="sd">            perspective (float): Perspective distortion factor.</span>
<span></span><span class="sd">            border (tuple[int, int]): Tuple specifying mosaic border (top/bottom, left/right).</span>
<span></span><span class="sd">            pre_transform (Callable | None): Function/transform to apply to the image before starting the random</span>
<span></span><span class="sd">                transformation.</span>
<span></span><span class="sd">        """</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span> <span class="o">=</span> <span class="n">degrees</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">translate</span> <span class="o">=</span> <span class="n">translate</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">shear</span> <span class="o">=</span> <span class="n">shear</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">perspective</span> <span class="o">=</span> <span class="n">perspective</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">border</span> <span class="o">=</span> <span class="n">border</span>  <span class="c1"># mosaic border</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">pre_transform</span> <span class="o">=</span> <span class="n">pre_transform</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.RandomPerspective.__call__"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.RandomPerspective.__call__</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
</code></pre></div><p>Apply random perspective and affine transformations to an image and its associated labels.</p><p>This method performs a series of transformations including rotation, translation, scaling, shearing, and perspective distortion on the input image and adjusts the corresponding bounding boxes, segments, and keypoints accordingly.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>labels</code></td><td><code>dict[str, Any]</code></td><td>A dictionary containing image data and annotations.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dict[str, Any]</code></td><td>Transformed labels dictionary containing:</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">RandomPerspective</span><span class="p">()</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">labels</span> <span class="o">=</span> <span class="p">{</span>
<span></span><span class="o">...</span>     <span class="s2">"img"</span><span class="p">:</span> <span class="n">image</span><span class="p">,</span>
<span></span><span class="o">...</span>     <span class="s2">"cls"</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span>
<span></span><span class="o">...</span>     <span class="s2">"instances"</span><span class="p">:</span> <span class="n">Instances</span><span class="p">(</span><span class="n">bboxes</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">],</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">150</span><span class="p">]])),</span>
<span></span><span class="o">...</span> <span class="p">}</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="k">assert</span> <span class="n">result</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">result</span><span class="p">[</span><span class="s2">"resized_shape"</span><span class="p">]</span>
</code></pre></div><div class="admonition note"><p class="admonition-title">Notes</p><p>'labels' arg must include: - 'img' (np.ndarray): The input image. - 'cls' (np.ndarray): Class labels. - 'instances' (Instances): Object instances with bounding boxes, segments, and keypoints.
May include: - 'mosaic_border' (tuple[int, int]): Border size for mosaic augmentation.</p></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L1222-L1299"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span></span><span class="w">    </span><span class="sd">"""Apply random perspective and affine transformations to an image and its associated labels.</span>
<span></span>
<span></span><span class="sd">    This method performs a series of transformations including rotation, translation, scaling, shearing, and</span>
<span></span><span class="sd">    perspective distortion on the input image and adjusts the corresponding bounding boxes, segments, and keypoints</span>
<span></span><span class="sd">    accordingly.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        labels (dict[str, Any]): A dictionary containing image data and annotations.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (dict[str, Any]): Transformed labels dictionary containing:</span>
<span></span><span class="sd">            - 'img' (np.ndarray): The transformed image.</span>
<span></span><span class="sd">            - 'cls' (np.ndarray): Updated class labels.</span>
<span></span><span class="sd">            - 'instances' (Instances): Updated object instances.</span>
<span></span><span class="sd">            - 'resized_shape' (tuple[int, int]): New image shape after transformation.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; transform = RandomPerspective()</span>
<span></span><span class="sd">        &gt;&gt;&gt; image = np.random.randint(0, 255, (640, 640, 3), dtype=np.uint8)</span>
<span></span><span class="sd">        &gt;&gt;&gt; labels = {</span>
<span></span><span class="sd">        ...     "img": image,</span>
<span></span><span class="sd">        ...     "cls": np.array([0, 1, 2]),</span>
<span></span><span class="sd">        ...     "instances": Instances(bboxes=np.array([[10, 10, 50, 50], [100, 100, 150, 150]])),</span>
<span></span><span class="sd">        ... }</span>
<span></span><span class="sd">        &gt;&gt;&gt; result = transform(labels)</span>
<span></span><span class="sd">        &gt;&gt;&gt; assert result["img"].shape[:2] == result["resized_shape"]</span>
<span></span>
<span></span><span class="sd">    Notes:</span>
<span></span><span class="sd">        'labels' arg must include:</span>
<span></span><span class="sd">            - 'img' (np.ndarray): The input image.</span>
<span></span><span class="sd">            - 'cls' (np.ndarray): Class labels.</span>
<span></span><span class="sd">            - 'instances' (Instances): Object instances with bounding boxes, segments, and keypoints.</span>
<span></span><span class="sd">        May include:</span>
<span></span><span class="sd">            - 'mosaic_border' (tuple[int, int]): Border size for mosaic augmentation.</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre_transform</span> <span class="ow">and</span> <span class="s2">"mosaic_border"</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
<span></span>        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre_transform</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span></span>    <span class="n">labels</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"ratio_pad"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># do not need ratio pad</span>
<span></span>
<span></span>    <span class="n">img</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span>
<span></span>    <span class="bp">cls</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="s2">"cls"</span><span class="p">]</span>
<span></span>    <span class="n">instances</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"instances"</span><span class="p">)</span>
<span></span>    <span class="c1"># Make sure the coord formats are right</span>
<span></span>    <span class="n">instances</span><span class="o">.</span><span class="n">convert_bbox</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s2">"xyxy"</span><span class="p">)</span>
<span></span>    <span class="n">instances</span><span class="o">.</span><span class="n">denormalize</span><span class="p">(</span><span class="o">*</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span></span>
<span></span>    <span class="n">border</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"mosaic_border"</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">border</span><span class="p">)</span>
<span></span>    <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">border</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">border</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>  <span class="c1"># w, h</span>
<span></span>    <span class="c1"># M is affine matrix</span>
<span></span>    <span class="c1"># Scale for func:`box_candidates`</span>
<span></span>    <span class="n">img</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">affine_transform</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">border</span><span class="p">)</span>
<span></span>
<span></span>    <span class="n">bboxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_bboxes</span><span class="p">(</span><span class="n">instances</span><span class="o">.</span><span class="n">bboxes</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
<span></span>
<span></span>    <span class="n">segments</span> <span class="o">=</span> <span class="n">instances</span><span class="o">.</span><span class="n">segments</span>
<span></span>    <span class="n">keypoints</span> <span class="o">=</span> <span class="n">instances</span><span class="o">.</span><span class="n">keypoints</span>
<span></span>    <span class="c1"># Update bboxes if there are segments.</span>
<span></span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">segments</span><span class="p">):</span>
<span></span>        <span class="n">bboxes</span><span class="p">,</span> <span class="n">segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_segments</span><span class="p">(</span><span class="n">segments</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
<span></span>
<span></span>    <span class="k">if</span> <span class="n">keypoints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span></span>        <span class="n">keypoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_keypoints</span><span class="p">(</span><span class="n">keypoints</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
<span></span>    <span class="n">new_instances</span> <span class="o">=</span> <span class="n">Instances</span><span class="p">(</span><span class="n">bboxes</span><span class="p">,</span> <span class="n">segments</span><span class="p">,</span> <span class="n">keypoints</span><span class="p">,</span> <span class="n">bbox_format</span><span class="o">=</span><span class="s2">"xyxy"</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span></span>    <span class="c1"># Clip</span>
<span></span>    <span class="n">new_instances</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span></span>
<span></span>    <span class="c1"># Filter instances</span>
<span></span>    <span class="n">instances</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">scale_w</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">scale_h</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">bbox_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span></span>    <span class="c1"># Make the bboxes have the same scale with new_bboxes</span>
<span></span>    <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">box_candidates</span><span class="p">(</span>
<span></span>        <span class="n">box1</span><span class="o">=</span><span class="n">instances</span><span class="o">.</span><span class="n">bboxes</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">box2</span><span class="o">=</span><span class="n">new_instances</span><span class="o">.</span><span class="n">bboxes</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">area_thr</span><span class="o">=</span><span class="mf">0.01</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span> <span class="k">else</span> <span class="mf">0.10</span>
<span></span>    <span class="p">)</span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_instances</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"cls"</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span> <span class="o">=</span> <span class="n">img</span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"resized_shape"</span><span class="p">]</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
<span></span>    <span class="k">return</span> <span class="n">labels</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.RandomPerspective.affine_transform"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.RandomPerspective.affine_transform</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">affine_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">border</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
</code></pre></div><p>Apply a sequence of affine transformations centered around the image center.</p><p>This function performs a series of geometric transformations on the input image, including translation, perspective change, rotation, scaling, and shearing. The transformations are applied in a specific order to maintain consistency.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>img</code></td><td><code>np.ndarray</code></td><td>Input image to be transformed.</td><td><em>required</em></td></tr><tr><td><code>border</code></td><td><code>tuple[int, int]</code></td><td>Border dimensions for the transformed image.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>img (np.ndarray)</code></td><td>Transformed image.</td></tr><tr><td><code>M (np.ndarray)</code></td><td>3x3 transformation matrix.</td></tr><tr><td><code>s (float)</code></td><td>Scale factor applied during the transformation.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">border</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transformed_img</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">affine_transform</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">border</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L1058-L1119"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">affine_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">border</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span></span><span class="w">    </span><span class="sd">"""Apply a sequence of affine transformations centered around the image center.</span>
<span></span>
<span></span><span class="sd">    This function performs a series of geometric transformations on the input image, including translation,</span>
<span></span><span class="sd">    perspective change, rotation, scaling, and shearing. The transformations are applied in a specific order to</span>
<span></span><span class="sd">    maintain consistency.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        img (np.ndarray): Input image to be transformed.</span>
<span></span><span class="sd">        border (tuple[int, int]): Border dimensions for the transformed image.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        img (np.ndarray): Transformed image.</span>
<span></span><span class="sd">        M (np.ndarray): 3x3 transformation matrix.</span>
<span></span><span class="sd">        s (float): Scale factor applied during the transformation.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span></span><span class="sd">        &gt;&gt;&gt; img = np.random.rand(100, 100, 3)</span>
<span></span><span class="sd">        &gt;&gt;&gt; border = (10, 10)</span>
<span></span><span class="sd">        &gt;&gt;&gt; transformed_img, matrix, scale = affine_transform(img, border)</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="c1"># Center</span>
<span></span>    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span></span>
<span></span>    <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>  <span class="c1"># x translation (pixels)</span>
<span></span>    <span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>  <span class="c1"># y translation (pixels)</span>
<span></span>
<span></span>    <span class="c1"># Perspective</span>
<span></span>    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span></span>    <span class="n">P</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">perspective</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">perspective</span><span class="p">)</span>  <span class="c1"># x perspective (about y)</span>
<span></span>    <span class="n">P</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">perspective</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">perspective</span><span class="p">)</span>  <span class="c1"># y perspective (about x)</span>
<span></span>
<span></span>    <span class="c1"># Rotation and Scale</span>
<span></span>    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span></span>    <span class="n">a</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">degrees</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span><span class="p">)</span>
<span></span>    <span class="c1"># a += random.choice([-180, -90, 0, 90])  # add 90deg rotations to small rotations</span>
<span></span>    <span class="n">s</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
<span></span>    <span class="c1"># s = 2 ** random.uniform(-scale, scale)</span>
<span></span>    <span class="n">R</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">getRotationMatrix2D</span><span class="p">(</span><span class="n">angle</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">scale</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
<span></span>
<span></span>    <span class="c1"># Shear</span>
<span></span>    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span></span>    <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">shear</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shear</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">)</span>  <span class="c1"># x shear (deg)</span>
<span></span>    <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">shear</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shear</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">)</span>  <span class="c1"># y shear (deg)</span>
<span></span>
<span></span>    <span class="c1"># Translation</span>
<span></span>    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span></span>    <span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># x translation (pixels)</span>
<span></span>    <span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># y translation (pixels)</span>
<span></span>
<span></span>    <span class="c1"># Combined rotation matrix</span>
<span></span>    <span class="n">M</span> <span class="o">=</span> <span class="n">T</span> <span class="o">@</span> <span class="n">S</span> <span class="o">@</span> <span class="n">R</span> <span class="o">@</span> <span class="n">P</span> <span class="o">@</span> <span class="n">C</span>  <span class="c1"># order of operations (right to left) is IMPORTANT</span>
<span></span>    <span class="c1"># Affine image</span>
<span></span>    <span class="k">if</span> <span class="p">(</span><span class="n">border</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">border</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">M</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>  <span class="c1"># image changed</span>
<span></span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">perspective</span><span class="p">:</span>
<span></span>            <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">warpPerspective</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">dsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">borderValue</span><span class="o">=</span><span class="p">(</span><span class="mi">114</span><span class="p">,</span> <span class="mi">114</span><span class="p">,</span> <span class="mi">114</span><span class="p">))</span>
<span></span>        <span class="k">else</span><span class="p">:</span>  <span class="c1"># affine</span>
<span></span>            <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">warpAffine</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">M</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">dsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">borderValue</span><span class="o">=</span><span class="p">(</span><span class="mi">114</span><span class="p">,</span> <span class="mi">114</span><span class="p">,</span> <span class="mi">114</span><span class="p">))</span>
<span></span>        <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
<span></span>            <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
<span></span>    <span class="k">return</span> <span class="n">img</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">s</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.RandomPerspective.apply_bboxes"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.RandomPerspective.apply_bboxes</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">apply_bboxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bboxes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">M</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
</code></pre></div><p>Apply affine transformation to bounding boxes.</p><p>This function applies an affine transformation to a set of bounding boxes using the provided transformation matrix.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>bboxes</code></td><td><code>np.ndarray</code></td><td>Bounding boxes in xyxy format with shape (N, 4), where N is the number of bounding boxes.</td><td><em>required</em></td></tr><tr><td><code>M</code></td><td><code>np.ndarray</code></td><td>Affine transformation matrix with shape (3, 3).</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>np.ndarray</code></td><td>Transformed bounding boxes in xyxy format with shape (N, 4).</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">bboxes</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">]])</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">M</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transformed_bboxes</span> <span class="o">=</span> <span class="n">apply_bboxes</span><span class="p">(</span><span class="n">bboxes</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L1121-L1152"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">apply_bboxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bboxes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">M</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span></span><span class="w">    </span><span class="sd">"""Apply affine transformation to bounding boxes.</span>
<span></span>
<span></span><span class="sd">    This function applies an affine transformation to a set of bounding boxes using the provided transformation</span>
<span></span><span class="sd">    matrix.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        bboxes (np.ndarray): Bounding boxes in xyxy format with shape (N, 4), where N is the number of bounding</span>
<span></span><span class="sd">            boxes.</span>
<span></span><span class="sd">        M (np.ndarray): Affine transformation matrix with shape (3, 3).</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (np.ndarray): Transformed bounding boxes in xyxy format with shape (N, 4).</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; bboxes = torch.tensor([[10, 10, 20, 20], [30, 30, 40, 40]])</span>
<span></span><span class="sd">        &gt;&gt;&gt; M = torch.eye(3)</span>
<span></span><span class="sd">        &gt;&gt;&gt; transformed_bboxes = apply_bboxes(bboxes, M)</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bboxes</span><span class="p">)</span>
<span></span>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span></span>        <span class="k">return</span> <span class="n">bboxes</span>
<span></span>
<span></span>    <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">bboxes</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span></span>    <span class="n">xy</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">bboxes</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># x1y1, x2y2, x1y2, x2y1</span>
<span></span>    <span class="n">xy</span> <span class="o">=</span> <span class="n">xy</span> <span class="o">@</span> <span class="n">M</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># transform</span>
<span></span>    <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">xy</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">xy</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">perspective</span> <span class="k">else</span> <span class="n">xy</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>  <span class="c1"># perspective rescale or affine</span>
<span></span>
<span></span>    <span class="c1"># Create new boxes</span>
<span></span>    <span class="n">x</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">]]</span>
<span></span>    <span class="n">y</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]]</span>
<span></span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">bboxes</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.RandomPerspective.apply_keypoints"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.RandomPerspective.apply_keypoints</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">apply_keypoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keypoints</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">M</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
</code></pre></div><p>Apply affine transformation to keypoints.</p><p>This method transforms the input keypoints using the provided affine transformation matrix. It handles perspective rescaling if necessary and updates the visibility of keypoints that fall outside the image boundaries after transformation.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>keypoints</code></td><td><code>np.ndarray</code></td><td>Array of keypoints with shape (N, 17, 3), where N is the number of instances, 17 is the number of keypoints per instance, and 3 represents (x, y, visibility).</td><td><em>required</em></td></tr><tr><td><code>M</code></td><td><code>np.ndarray</code></td><td>3x3 affine transformation matrix.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>np.ndarray</code></td><td>Transformed keypoints array with the same shape as input (N, 17, 3).</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">random_perspective</span> <span class="o">=</span> <span class="n">RandomPerspective</span><span class="p">()</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">keypoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># 5 instances, 17 keypoints each</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># Identity transformation</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transformed_keypoints</span> <span class="o">=</span> <span class="n">random_perspective</span><span class="o">.</span><span class="n">apply_keypoints</span><span class="p">(</span><span class="n">keypoints</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L1189-L1220"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">apply_keypoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keypoints</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">M</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span></span><span class="w">    </span><span class="sd">"""Apply affine transformation to keypoints.</span>
<span></span>
<span></span><span class="sd">    This method transforms the input keypoints using the provided affine transformation matrix. It handles</span>
<span></span><span class="sd">    perspective rescaling if necessary and updates the visibility of keypoints that fall outside the image</span>
<span></span><span class="sd">    boundaries after transformation.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        keypoints (np.ndarray): Array of keypoints with shape (N, 17, 3), where N is the number of instances, 17 is</span>
<span></span><span class="sd">            the number of keypoints per instance, and 3 represents (x, y, visibility).</span>
<span></span><span class="sd">        M (np.ndarray): 3x3 affine transformation matrix.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (np.ndarray): Transformed keypoints array with the same shape as input (N, 17, 3).</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; random_perspective = RandomPerspective()</span>
<span></span><span class="sd">        &gt;&gt;&gt; keypoints = np.random.rand(5, 17, 3)  # 5 instances, 17 keypoints each</span>
<span></span><span class="sd">        &gt;&gt;&gt; M = np.eye(3)  # Identity transformation</span>
<span></span><span class="sd">        &gt;&gt;&gt; transformed_keypoints = random_perspective.apply_keypoints(keypoints, M)</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="n">n</span><span class="p">,</span> <span class="n">nkpt</span> <span class="o">=</span> <span class="n">keypoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
<span></span>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span></span>        <span class="k">return</span> <span class="n">keypoints</span>
<span></span>    <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span> <span class="o">*</span> <span class="n">nkpt</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">keypoints</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span></span>    <span class="n">visible</span> <span class="o">=</span> <span class="n">keypoints</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">nkpt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span></span>    <span class="n">xy</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">keypoints</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">nkpt</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span></span>    <span class="n">xy</span> <span class="o">=</span> <span class="n">xy</span> <span class="o">@</span> <span class="n">M</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># transform</span>
<span></span>    <span class="n">xy</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">xy</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># perspective rescale or affine</span>
<span></span>    <span class="n">out_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span></span>    <span class="n">visible</span><span class="p">[</span><span class="n">out_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span></span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">xy</span><span class="p">,</span> <span class="n">visible</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nkpt</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.RandomPerspective.apply_segments"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.RandomPerspective.apply_segments</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">apply_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segments</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">M</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>
</code></pre></div><p>Apply affine transformations to segments and generate new bounding boxes.</p><p>This function applies affine transformations to input segments and generates new bounding boxes based on the transformed segments. It clips the transformed segments to fit within the new bounding boxes.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>segments</code></td><td><code>np.ndarray</code></td><td>Input segments with shape (N, M, 2), where N is the number of segments and M is the number of points in each segment.</td><td><em>required</em></td></tr><tr><td><code>M</code></td><td><code>np.ndarray</code></td><td>Affine transformation matrix with shape (3, 3).</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>bboxes (np.ndarray)</code></td><td>New bounding boxes with shape (N, 4) in xyxy format.</td></tr><tr><td><code>segments (np.ndarray)</code></td><td>Transformed and clipped segments with shape (N, M, 2).</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">segments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># 10 segments with 500 points each</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># Identity transformation matrix</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">new_bboxes</span><span class="p">,</span> <span class="n">new_segments</span> <span class="o">=</span> <span class="n">apply_segments</span><span class="p">(</span><span class="n">segments</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L1154-L1187"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">apply_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segments</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">M</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span></span><span class="w">    </span><span class="sd">"""Apply affine transformations to segments and generate new bounding boxes.</span>
<span></span>
<span></span><span class="sd">    This function applies affine transformations to input segments and generates new bounding boxes based on the</span>
<span></span><span class="sd">    transformed segments. It clips the transformed segments to fit within the new bounding boxes.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        segments (np.ndarray): Input segments with shape (N, M, 2), where N is the number of segments and M is the</span>
<span></span><span class="sd">            number of points in each segment.</span>
<span></span><span class="sd">        M (np.ndarray): Affine transformation matrix with shape (3, 3).</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        bboxes (np.ndarray): New bounding boxes with shape (N, 4) in xyxy format.</span>
<span></span><span class="sd">        segments (np.ndarray): Transformed and clipped segments with shape (N, M, 2).</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; segments = np.random.rand(10, 500, 2)  # 10 segments with 500 points each</span>
<span></span><span class="sd">        &gt;&gt;&gt; M = np.eye(3)  # Identity transformation matrix</span>
<span></span><span class="sd">        &gt;&gt;&gt; new_bboxes, new_segments = apply_segments(segments, M)</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="n">n</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="n">segments</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
<span></span>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span></span>        <span class="k">return</span> <span class="p">[],</span> <span class="n">segments</span>
<span></span>
<span></span>    <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span> <span class="o">*</span> <span class="n">num</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">segments</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span></span>    <span class="n">segments</span> <span class="o">=</span> <span class="n">segments</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span></span>    <span class="n">xy</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">segments</span>
<span></span>    <span class="n">xy</span> <span class="o">=</span> <span class="n">xy</span> <span class="o">@</span> <span class="n">M</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># transform</span>
<span></span>    <span class="n">xy</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">xy</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span></span>    <span class="n">segments</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span></span>    <span class="n">bboxes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">segment2box</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">xy</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
<span></span>    <span class="n">segments</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">bboxes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="n">bboxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
<span></span>    <span class="n">segments</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">bboxes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">bboxes</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>
<span></span>    <span class="k">return</span> <span class="n">bboxes</span><span class="p">,</span> <span class="n">segments</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.RandomPerspective.box_candidates"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.RandomPerspective.box_candidates</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">box_candidates</span><span class="p">(</span>
<span></span>    <span class="n">box1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
<span></span>    <span class="n">box2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
<span></span>    <span class="n">wh_thr</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span></span>    <span class="n">ar_thr</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
<span></span>    <span class="n">area_thr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
<span></span>    <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-16</span><span class="p">,</span>
<span></span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
</code></pre></div><p>Compute candidate boxes for further processing based on size and aspect ratio criteria.</p><p>This method compares boxes before and after augmentation to determine if they meet specified thresholds for width, height, aspect ratio, and area. It's used to filter out boxes that have been overly distorted or reduced by the augmentation process.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>box1</code></td><td><code>np.ndarray</code></td><td>Original boxes before augmentation, shape (4, N) where n is the number of boxes. Format is [x1, y1, x2, y2] in absolute coordinates.</td><td><em>required</em></td></tr><tr><td><code>box2</code></td><td><code>np.ndarray</code></td><td>Augmented boxes after transformation, shape (4, N). Format is [x1, y1, x2, y2] in absolute coordinates.</td><td><em>required</em></td></tr><tr><td><code>wh_thr</code></td><td><code>int</code></td><td>Width and height threshold in pixels. Boxes smaller than this in either dimension are rejected.</td><td><code>2</code></td></tr><tr><td><code>ar_thr</code></td><td><code>int</code></td><td>Aspect ratio threshold. Boxes with an aspect ratio greater than this value are rejected.</td><td><code>100</code></td></tr><tr><td><code>area_thr</code></td><td><code>float</code></td><td>Area ratio threshold. Boxes with an area ratio (new/old) less than this value are rejected.</td><td><code>0.1</code></td></tr><tr><td><code>eps</code></td><td><code>float</code></td><td>Small epsilon value to prevent division by zero.</td><td><code>1e-16</code></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>np.ndarray</code></td><td>Boolean array of shape (n) indicating which boxes are candidates. True values correspond to</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">random_perspective</span> <span class="o">=</span> <span class="n">RandomPerspective</span><span class="p">()</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">box1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">box2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">45</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">candidates</span> <span class="o">=</span> <span class="n">random_perspective</span><span class="o">.</span><span class="n">box_candidates</span><span class="p">(</span><span class="n">box1</span><span class="p">,</span> <span class="n">box2</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span>
<span></span><span class="p">[</span><span class="kc">True</span> <span class="kc">True</span><span class="p">]</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L1302-L1343"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="nd">@staticmethod</span>
<span></span><span class="k">def</span><span class="w"> </span><span class="nf">box_candidates</span><span class="p">(</span>
<span></span>    <span class="n">box1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
<span></span>    <span class="n">box2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
<span></span>    <span class="n">wh_thr</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span></span>    <span class="n">ar_thr</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
<span></span>    <span class="n">area_thr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
<span></span>    <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-16</span><span class="p">,</span>
<span></span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span></span><span class="w">    </span><span class="sd">"""Compute candidate boxes for further processing based on size and aspect ratio criteria.</span>
<span></span>
<span></span><span class="sd">    This method compares boxes before and after augmentation to determine if they meet specified thresholds for</span>
<span></span><span class="sd">    width, height, aspect ratio, and area. It's used to filter out boxes that have been overly distorted or reduced</span>
<span></span><span class="sd">    by the augmentation process.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        box1 (np.ndarray): Original boxes before augmentation, shape (4, N) where n is the number of boxes. Format</span>
<span></span><span class="sd">            is [x1, y1, x2, y2] in absolute coordinates.</span>
<span></span><span class="sd">        box2 (np.ndarray): Augmented boxes after transformation, shape (4, N). Format is [x1, y1, x2, y2] in</span>
<span></span><span class="sd">            absolute coordinates.</span>
<span></span><span class="sd">        wh_thr (int): Width and height threshold in pixels. Boxes smaller than this in either dimension are</span>
<span></span><span class="sd">            rejected.</span>
<span></span><span class="sd">        ar_thr (int): Aspect ratio threshold. Boxes with an aspect ratio greater than this value are rejected.</span>
<span></span><span class="sd">        area_thr (float): Area ratio threshold. Boxes with an area ratio (new/old) less than this value are</span>
<span></span><span class="sd">            rejected.</span>
<span></span><span class="sd">        eps (float): Small epsilon value to prevent division by zero.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (np.ndarray): Boolean array of shape (n) indicating which boxes are candidates. True values correspond to</span>
<span></span><span class="sd">            boxes that meet all criteria.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; random_perspective = RandomPerspective()</span>
<span></span><span class="sd">        &gt;&gt;&gt; box1 = np.array([[0, 0, 100, 100], [0, 0, 50, 50]]).T</span>
<span></span><span class="sd">        &gt;&gt;&gt; box2 = np.array([[10, 10, 90, 90], [5, 5, 45, 45]]).T</span>
<span></span><span class="sd">        &gt;&gt;&gt; candidates = random_perspective.box_candidates(box1, box2)</span>
<span></span><span class="sd">        &gt;&gt;&gt; print(candidates)</span>
<span></span><span class="sd">        [True True]</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="n">w1</span><span class="p">,</span> <span class="n">h1</span> <span class="o">=</span> <span class="n">box1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">box1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">box1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">box1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span></span>    <span class="n">w2</span><span class="p">,</span> <span class="n">h2</span> <span class="o">=</span> <span class="n">box2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">box2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">box2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">box2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span></span>    <span class="n">ar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">w2</span> <span class="o">/</span> <span class="p">(</span><span class="n">h2</span> <span class="o">+</span> <span class="n">eps</span><span class="p">),</span> <span class="n">h2</span> <span class="o">/</span> <span class="p">(</span><span class="n">w2</span> <span class="o">+</span> <span class="n">eps</span><span class="p">))</span>  <span class="c1"># aspect ratio</span>
<span></span>    <span class="k">return</span> <span class="p">(</span><span class="n">w2</span> <span class="o">&gt;</span> <span class="n">wh_thr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">h2</span> <span class="o">&gt;</span> <span class="n">wh_thr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">w2</span> <span class="o">*</span> <span class="n">h2</span> <span class="o">/</span> <span class="p">(</span><span class="n">w1</span> <span class="o">*</span> <span class="n">h1</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">area_thr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ar</span> <span class="o">&lt;</span> <span class="n">ar_thr</span><span class="p">)</span>  <span class="c1"># candidates</span>
</code></pre></div></details><p><br/><br/><hr/><br/></p><h2 id="ultralytics.data.augment.RandomHSV"><span class="doc-kind doc-kind-class">class</span> <code>ultralytics.data.augment.RandomHSV</code></h2><div class="highlight"><pre><span></span><code><span></span><span class="n">RandomHSV</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hgain</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">sgain</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">vgain</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div><p>Randomly adjust the Hue, Saturation, and Value (HSV) channels of an image.</p><p>This class applies random HSV augmentation to images within predefined limits set by hgain, sgain, and vgain.</p><p>This class applies random adjustments to the HSV channels of an image within specified limits.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>hgain</code></td><td><code>float</code></td><td>Maximum variation for hue. Should be in the range [0, 1].</td><td><code>0.5</code></td></tr><tr><td><code>sgain</code></td><td><code>float</code></td><td>Maximum variation for saturation. Should be in the range [0, 1].</td><td><code>0.5</code></td></tr><tr><td><code>vgain</code></td><td><code>float</code></td><td>Maximum variation for value. Should be in the range [0, 1].</td><td><code>0.5</code></td></tr></tbody></table><p><strong>Attributes</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>hgain</code></td><td><code>float</code></td><td>Maximum variation for hue. Range is typically [0, 1].</td></tr><tr><td><code>sgain</code></td><td><code>float</code></td><td>Maximum variation for saturation. Range is typically [0, 1].</td></tr><tr><td><code>vgain</code></td><td><code>float</code></td><td>Maximum variation for value. Range is typically [0, 1].</td></tr></tbody></table><p><strong>Methods</strong></p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="#ultralytics.data.augment.RandomHSV.__call__"><code>__call__</code></a></td><td>Apply random HSV augmentation to an image within predefined limits.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span><span class="w"> </span><span class="nn">ultralytics.data.augment</span><span class="w"> </span><span class="kn">import</span> <span class="n">RandomHSV</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">augmenter</span> <span class="o">=</span> <span class="n">RandomHSV</span><span class="p">(</span><span class="n">hgain</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">sgain</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">vgain</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">labels</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"img"</span><span class="p">:</span> <span class="n">image</span><span class="p">}</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">augmenter</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">augmented_image</span> <span class="o">=</span> <span class="n">augmented_labels</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L1346-L1419"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">class</span><span class="w"> </span><span class="nc">RandomHSV</span><span class="p">:</span>
<span></span><span class="w">    </span><span class="sd">"""Randomly adjust the Hue, Saturation, and Value (HSV) channels of an image.</span>
<span></span>
<span></span><span class="sd">    This class applies random HSV augmentation to images within predefined limits set by hgain, sgain, and vgain.</span>
<span></span>
<span></span><span class="sd">    Attributes:</span>
<span></span><span class="sd">        hgain (float): Maximum variation for hue. Range is typically [0, 1].</span>
<span></span><span class="sd">        sgain (float): Maximum variation for saturation. Range is typically [0, 1].</span>
<span></span><span class="sd">        vgain (float): Maximum variation for value. Range is typically [0, 1].</span>
<span></span>
<span></span><span class="sd">    Methods:</span>
<span></span><span class="sd">        __call__: Apply random HSV augmentation to an image.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span></span><span class="sd">        &gt;&gt;&gt; from ultralytics.data.augment import RandomHSV</span>
<span></span><span class="sd">        &gt;&gt;&gt; augmenter = RandomHSV(hgain=0.5, sgain=0.5, vgain=0.5)</span>
<span></span><span class="sd">        &gt;&gt;&gt; image = np.random.randint(0, 255, (100, 100, 3), dtype=np.uint8)</span>
<span></span><span class="sd">        &gt;&gt;&gt; labels = {"img": image}</span>
<span></span><span class="sd">        &gt;&gt;&gt; augmenter(labels)</span>
<span></span><span class="sd">        &gt;&gt;&gt; augmented_image = augmented_labels["img"]</span>
<span></span><span class="sd">    """</span>
<span></span>
<span></span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hgain</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">sgain</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">vgain</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span></span><span class="w">        </span><span class="sd">"""Initialize the RandomHSV object for random HSV (Hue, Saturation, Value) augmentation.</span>
<span></span>
<span></span><span class="sd">        This class applies random adjustments to the HSV channels of an image within specified limits.</span>
<span></span>
<span></span><span class="sd">        Args:</span>
<span></span><span class="sd">            hgain (float): Maximum variation for hue. Should be in the range [0, 1].</span>
<span></span><span class="sd">            sgain (float): Maximum variation for saturation. Should be in the range [0, 1].</span>
<span></span><span class="sd">            vgain (float): Maximum variation for value. Should be in the range [0, 1].</span>
<span></span><span class="sd">        """</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">hgain</span> <span class="o">=</span> <span class="n">hgain</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">sgain</span> <span class="o">=</span> <span class="n">sgain</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">vgain</span> <span class="o">=</span> <span class="n">vgain</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.RandomHSV.__call__"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.RandomHSV.__call__</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
</code></pre></div><p>Apply random HSV augmentation to an image within predefined limits.</p><p>This method modifies the input image by randomly adjusting its Hue, Saturation, and Value (HSV) channels. The adjustments are made within the limits set by hgain, sgain, and vgain during initialization.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>labels</code></td><td><code>dict[str, Any]</code></td><td>A dictionary containing image data and metadata. Must include an 'img' key with the image as a numpy array.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dict[str, Any]</code></td><td>A dictionary containing the mixed image and adjusted labels.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">hsv_augmenter</span> <span class="o">=</span> <span class="n">RandomHSV</span><span class="p">(</span><span class="n">hgain</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">sgain</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">vgain</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">labels</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"img"</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)}</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">hsv_augmenter</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">augmented_img</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L1383-L1419"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span></span><span class="w">    </span><span class="sd">"""Apply random HSV augmentation to an image within predefined limits.</span>
<span></span>
<span></span><span class="sd">    This method modifies the input image by randomly adjusting its Hue, Saturation, and Value (HSV) channels. The</span>
<span></span><span class="sd">    adjustments are made within the limits set by hgain, sgain, and vgain during initialization.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        labels (dict[str, Any]): A dictionary containing image data and metadata. Must include an 'img' key with the</span>
<span></span><span class="sd">            image as a numpy array.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (dict[str, Any]): A dictionary containing the mixed image and adjusted labels.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; hsv_augmenter = RandomHSV(hgain=0.5, sgain=0.5, vgain=0.5)</span>
<span></span><span class="sd">        &gt;&gt;&gt; labels = {"img": np.random.randint(0, 255, (100, 100, 3), dtype=np.uint8)}</span>
<span></span><span class="sd">        &gt;&gt;&gt; labels = hsv_augmenter(labels)</span>
<span></span><span class="sd">        &gt;&gt;&gt; augmented_img = labels["img"]</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="n">img</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span>
<span></span>    <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># only apply to RGB images</span>
<span></span>        <span class="k">return</span> <span class="n">labels</span>
<span></span>    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hgain</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sgain</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">vgain</span><span class="p">:</span>
<span></span>        <span class="n">dtype</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span>  <span class="c1"># uint8</span>
<span></span>
<span></span>        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">hgain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sgain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vgain</span><span class="p">]</span>  <span class="c1"># random gains</span>
<span></span>        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span></span>        <span class="c1"># lut_hue = ((x * (r[0] + 1)) % 180).astype(dtype)   # original hue implementation from ultralytics&lt;=8.3.78</span>
<span></span>        <span class="n">lut_hue</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">180</span><span class="p">)</span> <span class="o">%</span> <span class="mi">180</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
<span></span>        <span class="n">lut_sat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
<span></span>        <span class="n">lut_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
<span></span>        <span class="n">lut_sat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># prevent pure white changing color, introduced in 8.3.79</span>
<span></span>
<span></span>        <span class="n">hue</span><span class="p">,</span> <span class="n">sat</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2HSV</span><span class="p">))</span>
<span></span>        <span class="n">im_hsv</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">merge</span><span class="p">((</span><span class="n">cv2</span><span class="o">.</span><span class="n">LUT</span><span class="p">(</span><span class="n">hue</span><span class="p">,</span> <span class="n">lut_hue</span><span class="p">),</span> <span class="n">cv2</span><span class="o">.</span><span class="n">LUT</span><span class="p">(</span><span class="n">sat</span><span class="p">,</span> <span class="n">lut_sat</span><span class="p">),</span> <span class="n">cv2</span><span class="o">.</span><span class="n">LUT</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">lut_val</span><span class="p">)))</span>
<span></span>        <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">im_hsv</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_HSV2BGR</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">img</span><span class="p">)</span>  <span class="c1"># no return needed</span>
<span></span>    <span class="k">return</span> <span class="n">labels</span>
</code></pre></div></details><p><br/><br/><hr/><br/></p><h2 id="ultralytics.data.augment.RandomFlip"><span class="doc-kind doc-kind-class">class</span> <code>ultralytics.data.augment.RandomFlip</code></h2><div class="highlight"><pre><span></span><code><span></span><span class="n">RandomFlip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">"horizontal"</span><span class="p">,</span> <span class="n">flip_idx</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div><p>Apply a random horizontal or vertical flip to an image with a given probability.</p><p>This class performs random image flipping and updates corresponding instance annotations such as bounding boxes and keypoints.</p><p>This class applies a random horizontal or vertical flip to an image with a given probability. It also updates any instances (bounding boxes, keypoints, etc.) accordingly.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>p</code></td><td><code>float</code></td><td>The probability of applying the flip. Must be between 0 and 1.</td><td><code>0.5</code></td></tr><tr><td><code>direction</code></td><td><code>str</code></td><td>The direction to apply the flip. Must be 'horizontal' or 'vertical'.</td><td><code>"horizontal"</code></td></tr><tr><td><code>flip_idx</code></td><td><code>list[int] | None</code></td><td>Index mapping for flipping keypoints, if any.</td><td><code>None</code></td></tr></tbody></table><p><strong>Attributes</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>p</code></td><td><code>float</code></td><td>Probability of applying the flip. Must be between 0 and 1.</td></tr><tr><td><code>direction</code></td><td><code>str</code></td><td>Direction of flip, either 'horizontal' or 'vertical'.</td></tr><tr><td><code>flip_idx</code></td><td><code>array-like</code></td><td>Index mapping for flipping keypoints, if applicable.</td></tr></tbody></table><p><strong>Methods</strong></p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="#ultralytics.data.augment.RandomFlip.__call__"><code>__call__</code></a></td><td>Apply random flip to an image and update any instances like bounding boxes or keypoints accordingly.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">RandomFlip</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s2">"horizontal"</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">transform</span><span class="p">({</span><span class="s2">"img"</span><span class="p">:</span> <span class="n">image</span><span class="p">,</span> <span class="s2">"instances"</span><span class="p">:</span> <span class="n">instances</span><span class="p">})</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">flipped_image</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">flipped_instances</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]</span>
</code></pre></div><p><strong>Raises</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>AssertionError</code></td><td>If direction is not 'horizontal' or 'vertical', or if p is not between 0 and 1.</td></tr></tbody></table><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L1422-L1506"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">class</span><span class="w"> </span><span class="nc">RandomFlip</span><span class="p">:</span>
<span></span><span class="w">    </span><span class="sd">"""Apply a random horizontal or vertical flip to an image with a given probability.</span>
<span></span>
<span></span><span class="sd">    This class performs random image flipping and updates corresponding instance annotations such as bounding boxes and</span>
<span></span><span class="sd">    keypoints.</span>
<span></span>
<span></span><span class="sd">    Attributes:</span>
<span></span><span class="sd">        p (float): Probability of applying the flip. Must be between 0 and 1.</span>
<span></span><span class="sd">        direction (str): Direction of flip, either 'horizontal' or 'vertical'.</span>
<span></span><span class="sd">        flip_idx (array-like): Index mapping for flipping keypoints, if applicable.</span>
<span></span>
<span></span><span class="sd">    Methods:</span>
<span></span><span class="sd">        __call__: Apply the random flip transformation to an image and its annotations.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; transform = RandomFlip(p=0.5, direction="horizontal")</span>
<span></span><span class="sd">        &gt;&gt;&gt; result = transform({"img": image, "instances": instances})</span>
<span></span><span class="sd">        &gt;&gt;&gt; flipped_image = result["img"]</span>
<span></span><span class="sd">        &gt;&gt;&gt; flipped_instances = result["instances"]</span>
<span></span><span class="sd">    """</span>
<span></span>
<span></span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">"horizontal"</span><span class="p">,</span> <span class="n">flip_idx</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span></span><span class="w">        </span><span class="sd">"""Initialize the RandomFlip class with probability and direction.</span>
<span></span>
<span></span><span class="sd">        This class applies a random horizontal or vertical flip to an image with a given probability. It also updates</span>
<span></span><span class="sd">        any instances (bounding boxes, keypoints, etc.) accordingly.</span>
<span></span>
<span></span><span class="sd">        Args:</span>
<span></span><span class="sd">            p (float): The probability of applying the flip. Must be between 0 and 1.</span>
<span></span><span class="sd">            direction (str): The direction to apply the flip. Must be 'horizontal' or 'vertical'.</span>
<span></span><span class="sd">            flip_idx (list[int] | None): Index mapping for flipping keypoints, if any.</span>
<span></span>
<span></span><span class="sd">        Raises:</span>
<span></span><span class="sd">            AssertionError: If direction is not 'horizontal' or 'vertical', or if p is not between 0 and 1.</span>
<span></span><span class="sd">        """</span>
<span></span>        <span class="k">assert</span> <span class="n">direction</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">"horizontal"</span><span class="p">,</span> <span class="s2">"vertical"</span><span class="p">},</span> <span class="sa">f</span><span class="s2">"Support direction `horizontal` or `vertical`, got </span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s2">"</span>
<span></span>        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">"The probability should be in range [0, 1], but got </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">."</span>
<span></span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">flip_idx</span> <span class="o">=</span> <span class="n">flip_idx</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.RandomFlip.__call__"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.RandomFlip.__call__</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
</code></pre></div><p>Apply random flip to an image and update any instances like bounding boxes or keypoints accordingly.</p><p>This method randomly flips the input image either horizontally or vertically based on the initialized probability and direction. It also updates the corresponding instances (bounding boxes, keypoints) to match the flipped image.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>labels</code></td><td><code>dict[str, Any]</code></td><td>A dictionary containing the following keys: - 'img' (np.ndarray): The image to be flipped. - 'instances' (ultralytics.utils.instance.Instances): Object containing boxes and optionally keypoints.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dict[str, Any]</code></td><td>The same dictionary with the flipped image and updated instances:</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">labels</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"img"</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">"instances"</span><span class="p">:</span> <span class="n">Instances</span><span class="p">(</span><span class="o">...</span><span class="p">)}</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">random_flip</span> <span class="o">=</span> <span class="n">RandomFlip</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s2">"horizontal"</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">flipped_labels</span> <span class="o">=</span> <span class="n">random_flip</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L1464-L1506"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span></span><span class="w">    </span><span class="sd">"""Apply random flip to an image and update any instances like bounding boxes or keypoints accordingly.</span>
<span></span>
<span></span><span class="sd">    This method randomly flips the input image either horizontally or vertically based on the initialized</span>
<span></span><span class="sd">    probability and direction. It also updates the corresponding instances (bounding boxes, keypoints) to match the</span>
<span></span><span class="sd">    flipped image.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        labels (dict[str, Any]): A dictionary containing the following keys:</span>
<span></span><span class="sd">            - 'img' (np.ndarray): The image to be flipped.</span>
<span></span><span class="sd">            - 'instances' (ultralytics.utils.instance.Instances): Object containing boxes and optionally keypoints.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (dict[str, Any]): The same dictionary with the flipped image and updated instances:</span>
<span></span><span class="sd">            - 'img' (np.ndarray): The flipped image.</span>
<span></span><span class="sd">            - 'instances' (ultralytics.utils.instance.Instances): Updated instances matching the flipped image.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; labels = {"img": np.random.rand(640, 640, 3), "instances": Instances(...)}</span>
<span></span><span class="sd">        &gt;&gt;&gt; random_flip = RandomFlip(p=0.5, direction="horizontal")</span>
<span></span><span class="sd">        &gt;&gt;&gt; flipped_labels = random_flip(labels)</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="n">img</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span>
<span></span>    <span class="n">instances</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"instances"</span><span class="p">)</span>
<span></span>    <span class="n">instances</span><span class="o">.</span><span class="n">convert_bbox</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s2">"xywh"</span><span class="p">)</span>
<span></span>    <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
<span></span>    <span class="n">h</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">instances</span><span class="o">.</span><span class="n">normalized</span> <span class="k">else</span> <span class="n">h</span>
<span></span>    <span class="n">w</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">instances</span><span class="o">.</span><span class="n">normalized</span> <span class="k">else</span> <span class="n">w</span>
<span></span>
<span></span>    <span class="c1"># WARNING: two separate if and calls to random.random() intentional for reproducibility with older versions</span>
<span></span>    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="s2">"vertical"</span> <span class="ow">and</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">:</span>
<span></span>        <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span></span>        <span class="n">instances</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
<span></span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flip_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">instances</span><span class="o">.</span><span class="n">keypoints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span></span>            <span class="n">instances</span><span class="o">.</span><span class="n">keypoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">instances</span><span class="o">.</span><span class="n">keypoints</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flip_idx</span><span class="p">,</span> <span class="p">:])</span>
<span></span>    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="s2">"horizontal"</span> <span class="ow">and</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">:</span>
<span></span>        <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span></span>        <span class="n">instances</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span></span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flip_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">instances</span><span class="o">.</span><span class="n">keypoints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span></span>            <span class="n">instances</span><span class="o">.</span><span class="n">keypoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">instances</span><span class="o">.</span><span class="n">keypoints</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flip_idx</span><span class="p">,</span> <span class="p">:])</span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]</span> <span class="o">=</span> <span class="n">instances</span>
<span></span>    <span class="k">return</span> <span class="n">labels</span>
</code></pre></div></details><p><br/><br/><hr/><br/></p><h2 id="ultralytics.data.augment.LetterBox"><span class="doc-kind doc-kind-class">class</span> <code>ultralytics.data.augment.LetterBox</code></h2><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
<span></span>    <span class="bp">self</span><span class="p">,</span>
<span></span>    <span class="n">new_shape</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">),</span>
<span></span>    <span class="n">auto</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span></span>    <span class="n">scale_fill</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span></span>    <span class="n">scaleup</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span></span>    <span class="n">center</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span></span>    <span class="n">stride</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
<span></span>    <span class="n">padding_value</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">114</span><span class="p">,</span>
<span></span>    <span class="n">interpolation</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">INTER_LINEAR</span><span class="p">,</span>
<span></span><span class="p">)</span>
</code></pre></div><p>Resize image and padding for detection, instance segmentation, pose.</p><p>This class resizes and pads images to a specified shape while preserving aspect ratio. It also updates corresponding labels and bounding boxes.</p><p>This class is designed to resize and pad images for object detection, instance segmentation, and pose estimation tasks. It supports various resizing modes including auto-sizing, scale-fill, and letterboxing.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>new_shape</code></td><td><code>tuple[int, int]</code></td><td>Target size (height, width) for the resized image.</td><td><code>(640, 640)</code></td></tr><tr><td><code>auto</code></td><td><code>bool</code></td><td>If True, use minimum rectangle to resize. If False, use new_shape directly.</td><td><code>False</code></td></tr><tr><td><code>scale_fill</code></td><td><code>bool</code></td><td>If True, stretch the image to new_shape without padding.</td><td><code>False</code></td></tr><tr><td><code>scaleup</code></td><td><code>bool</code></td><td>If True, allow scaling up. If False, only scale down.</td><td><code>True</code></td></tr><tr><td><code>center</code></td><td><code>bool</code></td><td>If True, center the placed image. If False, place image in top-left corner.</td><td><code>True</code></td></tr><tr><td><code>stride</code></td><td><code>int</code></td><td>Stride of the model (e.g., 32 for YOLOv5).</td><td><code>32</code></td></tr><tr><td><code>padding_value</code></td><td><code>int</code></td><td>Value for padding the image. Default is 114.</td><td><code>114</code></td></tr><tr><td><code>interpolation</code></td><td><code>int</code></td><td>Interpolation method for resizing. Default is cv2.INTER_LINEAR.</td><td><code>cv2.INTER_LINEAR</code></td></tr></tbody></table><p><strong>Attributes</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>new_shape</code></td><td><code>tuple</code></td><td>Target shape (height, width) for resizing.</td></tr><tr><td><code>auto</code></td><td><code>bool</code></td><td>Whether to use minimum rectangle.</td></tr><tr><td><code>scale_fill</code></td><td><code>bool</code></td><td>Whether to stretch the image to new_shape.</td></tr><tr><td><code>scaleup</code></td><td><code>bool</code></td><td>Whether to allow scaling up. If False, only scale down.</td></tr><tr><td><code>stride</code></td><td><code>int</code></td><td>Stride for rounding padding.</td></tr><tr><td><code>center</code></td><td><code>bool</code></td><td>Whether to center the image or align to top-left.</td></tr></tbody></table><p><strong>Methods</strong></p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="#ultralytics.data.augment.LetterBox.__call__"><code>__call__</code></a></td><td>Resize and pad an image for object detection, instance segmentation, or pose estimation tasks.</td></tr><tr><td><a href="#ultralytics.data.augment.LetterBox._update_labels"><code>_update_labels</code></a></td><td>Update labels after applying letterboxing to an image.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">LetterBox</span><span class="p">(</span><span class="n">new_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">))</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">resized_img</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">updated_instances</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L1509-L1673"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">class</span><span class="w"> </span><span class="nc">LetterBox</span><span class="p">:</span>
<span></span><span class="w">    </span><span class="sd">"""Resize image and padding for detection, instance segmentation, pose.</span>
<span></span>
<span></span><span class="sd">    This class resizes and pads images to a specified shape while preserving aspect ratio. It also updates corresponding</span>
<span></span><span class="sd">    labels and bounding boxes.</span>
<span></span>
<span></span><span class="sd">    Attributes:</span>
<span></span><span class="sd">        new_shape (tuple): Target shape (height, width) for resizing.</span>
<span></span><span class="sd">        auto (bool): Whether to use minimum rectangle.</span>
<span></span><span class="sd">        scale_fill (bool): Whether to stretch the image to new_shape.</span>
<span></span><span class="sd">        scaleup (bool): Whether to allow scaling up. If False, only scale down.</span>
<span></span><span class="sd">        stride (int): Stride for rounding padding.</span>
<span></span><span class="sd">        center (bool): Whether to center the image or align to top-left.</span>
<span></span>
<span></span><span class="sd">    Methods:</span>
<span></span><span class="sd">        __call__: Resize and pad image, update labels and bounding boxes.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; transform = LetterBox(new_shape=(640, 640))</span>
<span></span><span class="sd">        &gt;&gt;&gt; result = transform(labels)</span>
<span></span><span class="sd">        &gt;&gt;&gt; resized_img = result["img"]</span>
<span></span><span class="sd">        &gt;&gt;&gt; updated_instances = result["instances"]</span>
<span></span><span class="sd">    """</span>
<span></span>
<span></span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
<span></span>        <span class="bp">self</span><span class="p">,</span>
<span></span>        <span class="n">new_shape</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">),</span>
<span></span>        <span class="n">auto</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span></span>        <span class="n">scale_fill</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span></span>        <span class="n">scaleup</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span></span>        <span class="n">center</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span></span>        <span class="n">stride</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
<span></span>        <span class="n">padding_value</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">114</span><span class="p">,</span>
<span></span>        <span class="n">interpolation</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">INTER_LINEAR</span><span class="p">,</span>
<span></span>    <span class="p">):</span>
<span></span><span class="w">        </span><span class="sd">"""Initialize LetterBox object for resizing and padding images.</span>
<span></span>
<span></span><span class="sd">        This class is designed to resize and pad images for object detection, instance segmentation, and pose estimation</span>
<span></span><span class="sd">        tasks. It supports various resizing modes including auto-sizing, scale-fill, and letterboxing.</span>
<span></span>
<span></span><span class="sd">        Args:</span>
<span></span><span class="sd">            new_shape (tuple[int, int]): Target size (height, width) for the resized image.</span>
<span></span><span class="sd">            auto (bool): If True, use minimum rectangle to resize. If False, use new_shape directly.</span>
<span></span><span class="sd">            scale_fill (bool): If True, stretch the image to new_shape without padding.</span>
<span></span><span class="sd">            scaleup (bool): If True, allow scaling up. If False, only scale down.</span>
<span></span><span class="sd">            center (bool): If True, center the placed image. If False, place image in top-left corner.</span>
<span></span><span class="sd">            stride (int): Stride of the model (e.g., 32 for YOLOv5).</span>
<span></span><span class="sd">            padding_value (int): Value for padding the image. Default is 114.</span>
<span></span><span class="sd">            interpolation (int): Interpolation method for resizing. Default is cv2.INTER_LINEAR.</span>
<span></span><span class="sd">        """</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">new_shape</span> <span class="o">=</span> <span class="n">new_shape</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">auto</span> <span class="o">=</span> <span class="n">auto</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">scale_fill</span> <span class="o">=</span> <span class="n">scale_fill</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">scaleup</span> <span class="o">=</span> <span class="n">scaleup</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">stride</span> <span class="o">=</span> <span class="n">stride</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span>  <span class="c1"># Put the image in the middle or top-left</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">padding_value</span> <span class="o">=</span> <span class="n">padding_value</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span> <span class="o">=</span> <span class="n">interpolation</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.LetterBox.__call__"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.LetterBox.__call__</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
</code></pre></div><p>Resize and pad an image for object detection, instance segmentation, or pose estimation tasks.</p><p>This method applies letterboxing to the input image, which involves resizing the image while maintaining its aspect ratio and adding padding to fit the new shape. It also updates any associated labels accordingly.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>labels</code></td><td><code>dict[str, Any] | None</code></td><td>A dictionary containing image data and associated labels, or empty dict if None.</td><td><code>None</code></td></tr><tr><td><code>image</code></td><td><code>np.ndarray | None</code></td><td>The input image as a numpy array. If None, the image is taken from 'labels'.</td><td><code>None</code></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dict[str, Any] | np.ndarray</code></td><td>If 'labels' is provided, returns an updated dictionary with the resized and</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">letterbox</span> <span class="o">=</span> <span class="n">LetterBox</span><span class="p">(</span><span class="n">new_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">))</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">letterbox</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="p">{</span><span class="s2">"img"</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">480</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="s2">"instances"</span><span class="p">:</span> <span class="n">Instances</span><span class="p">(</span><span class="o">...</span><span class="p">)})</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">resized_img</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">updated_instances</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L1568-L1644"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span></span><span class="w">    </span><span class="sd">"""Resize and pad an image for object detection, instance segmentation, or pose estimation tasks.</span>
<span></span>
<span></span><span class="sd">    This method applies letterboxing to the input image, which involves resizing the image while maintaining its</span>
<span></span><span class="sd">    aspect ratio and adding padding to fit the new shape. It also updates any associated labels accordingly.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        labels (dict[str, Any] | None): A dictionary containing image data and associated labels, or empty dict if</span>
<span></span><span class="sd">            None.</span>
<span></span><span class="sd">        image (np.ndarray | None): The input image as a numpy array. If None, the image is taken from 'labels'.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (dict[str, Any] | np.ndarray): If 'labels' is provided, returns an updated dictionary with the resized and</span>
<span></span><span class="sd">            padded image, updated labels, and additional metadata. If 'labels' is empty, returns the resized and</span>
<span></span><span class="sd">            padded image only.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; letterbox = LetterBox(new_shape=(640, 640))</span>
<span></span><span class="sd">        &gt;&gt;&gt; result = letterbox(labels={"img": np.zeros((480, 640, 3)), "instances": Instances(...)})</span>
<span></span><span class="sd">        &gt;&gt;&gt; resized_img = result["img"]</span>
<span></span><span class="sd">        &gt;&gt;&gt; updated_instances = result["instances"]</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span></span>        <span class="n">labels</span> <span class="o">=</span> <span class="p">{}</span>
<span></span>    <span class="n">img</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"img"</span><span class="p">)</span> <span class="k">if</span> <span class="n">image</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">image</span>
<span></span>    <span class="n">shape</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># current shape [height, width]</span>
<span></span>    <span class="n">new_shape</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"rect_shape"</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_shape</span><span class="p">)</span>
<span></span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_shape</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
<span></span>        <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_shape</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">)</span>
<span></span>
<span></span>    <span class="c1"># Scale ratio (new / old)</span>
<span></span>    <span class="n">r</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">new_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span></span>    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaleup</span><span class="p">:</span>  <span class="c1"># only scale down, do not scale up (for better val mAP)</span>
<span></span>        <span class="n">r</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
<span></span>
<span></span>    <span class="c1"># Compute padding</span>
<span></span>    <span class="n">ratio</span> <span class="o">=</span> <span class="n">r</span><span class="p">,</span> <span class="n">r</span>  <span class="c1"># width, height ratios</span>
<span></span>    <span class="n">new_unpad</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">r</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span>
<span></span>    <span class="n">dw</span><span class="p">,</span> <span class="n">dh</span> <span class="o">=</span> <span class="n">new_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">new_unpad</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">new_unpad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># wh padding</span>
<span></span>    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">auto</span><span class="p">:</span>  <span class="c1"># minimum rectangle</span>
<span></span>        <span class="n">dw</span><span class="p">,</span> <span class="n">dh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">dw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">dh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride</span><span class="p">)</span>  <span class="c1"># wh padding</span>
<span></span>    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_fill</span><span class="p">:</span>  <span class="c1"># stretch</span>
<span></span>        <span class="n">dw</span><span class="p">,</span> <span class="n">dh</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
<span></span>        <span class="n">new_unpad</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">new_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span></span>        <span class="n">ratio</span> <span class="o">=</span> <span class="n">new_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">new_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># width, height ratios</span>
<span></span>
<span></span>    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">:</span>
<span></span>        <span class="n">dw</span> <span class="o">/=</span> <span class="mi">2</span>  <span class="c1"># divide padding into 2 sides</span>
<span></span>        <span class="n">dh</span> <span class="o">/=</span> <span class="mi">2</span>
<span></span>
<span></span>    <span class="k">if</span> <span class="n">shape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">new_unpad</span><span class="p">:</span>  <span class="c1"># resize</span>
<span></span>        <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">new_unpad</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span><span class="p">)</span>
<span></span>        <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
<span></span>            <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
<span></span>
<span></span>    <span class="n">top</span><span class="p">,</span> <span class="n">bottom</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">dh</span> <span class="o">-</span> <span class="mf">0.1</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">dh</span> <span class="o">+</span> <span class="mf">0.1</span><span class="p">)</span>
<span></span>    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">dw</span> <span class="o">-</span> <span class="mf">0.1</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">dw</span> <span class="o">+</span> <span class="mf">0.1</span><span class="p">)</span>
<span></span>    <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span>
<span></span>    <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
<span></span>        <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">copyMakeBorder</span><span class="p">(</span>
<span></span>            <span class="n">img</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_CONSTANT</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">padding_value</span><span class="p">,)</span> <span class="o">*</span> <span class="mi">3</span>
<span></span>        <span class="p">)</span>
<span></span>    <span class="k">else</span><span class="p">:</span>  <span class="c1"># multispectral</span>
<span></span>        <span class="n">pad_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">h</span> <span class="o">+</span> <span class="n">top</span> <span class="o">+</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">w</span> <span class="o">+</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">padding_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span></span>        <span class="n">pad_img</span><span class="p">[</span><span class="n">top</span> <span class="p">:</span> <span class="n">top</span> <span class="o">+</span> <span class="n">h</span><span class="p">,</span> <span class="n">left</span> <span class="p">:</span> <span class="n">left</span> <span class="o">+</span> <span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">img</span>
<span></span>        <span class="n">img</span> <span class="o">=</span> <span class="n">pad_img</span>
<span></span>
<span></span>    <span class="k">if</span> <span class="n">labels</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"ratio_pad"</span><span class="p">):</span>
<span></span>        <span class="n">labels</span><span class="p">[</span><span class="s2">"ratio_pad"</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="s2">"ratio_pad"</span><span class="p">],</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">top</span><span class="p">))</span>  <span class="c1"># for evaluation</span>
<span></span>
<span></span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
<span></span>        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_labels</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">ratio</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">top</span><span class="p">)</span>
<span></span>        <span class="n">labels</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span> <span class="o">=</span> <span class="n">img</span>
<span></span>        <span class="n">labels</span><span class="p">[</span><span class="s2">"resized_shape"</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_shape</span>
<span></span>        <span class="k">return</span> <span class="n">labels</span>
<span></span>    <span class="k">else</span><span class="p">:</span>
<span></span>        <span class="k">return</span> <span class="n">img</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.LetterBox._update_labels"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.LetterBox._update_labels</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_update_labels</span><span class="p">(</span><span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">ratio</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">padw</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">padh</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
</code></pre></div><p>Update labels after applying letterboxing to an image.</p><p>This method modifies the bounding box coordinates of instances in the labels to account for resizing and padding applied during letterboxing.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>labels</code></td><td><code>dict[str, Any]</code></td><td>A dictionary containing image labels and instances.</td><td><em>required</em></td></tr><tr><td><code>ratio</code></td><td><code>tuple[float, float]</code></td><td>Scaling ratios (width, height) applied to the image.</td><td><em>required</em></td></tr><tr><td><code>padw</code></td><td><code>float</code></td><td>Padding width added to the image.</td><td><em>required</em></td></tr><tr><td><code>padh</code></td><td><code>float</code></td><td>Padding height added to the image.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dict[str, Any]</code></td><td>Updated labels dictionary with modified instance coordinates.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">letterbox</span> <span class="o">=</span> <span class="n">LetterBox</span><span class="p">(</span><span class="n">new_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">))</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">labels</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"instances"</span><span class="p">:</span> <span class="n">Instances</span><span class="p">(</span><span class="o">...</span><span class="p">)}</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">ratio</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">padw</span><span class="p">,</span> <span class="n">padh</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">updated_labels</span> <span class="o">=</span> <span class="n">letterbox</span><span class="o">.</span><span class="n">_update_labels</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">ratio</span><span class="p">,</span> <span class="n">padw</span><span class="p">,</span> <span class="n">padh</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L1647-L1673"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="nd">@staticmethod</span>
<span></span><span class="k">def</span><span class="w"> </span><span class="nf">_update_labels</span><span class="p">(</span><span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">ratio</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">padw</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">padh</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span></span><span class="w">    </span><span class="sd">"""Update labels after applying letterboxing to an image.</span>
<span></span>
<span></span><span class="sd">    This method modifies the bounding box coordinates of instances in the labels to account for resizing and padding</span>
<span></span><span class="sd">    applied during letterboxing.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        labels (dict[str, Any]): A dictionary containing image labels and instances.</span>
<span></span><span class="sd">        ratio (tuple[float, float]): Scaling ratios (width, height) applied to the image.</span>
<span></span><span class="sd">        padw (float): Padding width added to the image.</span>
<span></span><span class="sd">        padh (float): Padding height added to the image.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (dict[str, Any]): Updated labels dictionary with modified instance coordinates.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; letterbox = LetterBox(new_shape=(640, 640))</span>
<span></span><span class="sd">        &gt;&gt;&gt; labels = {"instances": Instances(...)}</span>
<span></span><span class="sd">        &gt;&gt;&gt; ratio = (0.5, 0.5)</span>
<span></span><span class="sd">        &gt;&gt;&gt; padw, padh = 10, 20</span>
<span></span><span class="sd">        &gt;&gt;&gt; updated_labels = letterbox._update_labels(labels, ratio, padw, padh)</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]</span><span class="o">.</span><span class="n">convert_bbox</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s2">"xyxy"</span><span class="p">)</span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]</span><span class="o">.</span><span class="n">denormalize</span><span class="p">(</span><span class="o">*</span><span class="n">labels</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="o">*</span><span class="n">ratio</span><span class="p">)</span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]</span><span class="o">.</span><span class="n">add_padding</span><span class="p">(</span><span class="n">padw</span><span class="p">,</span> <span class="n">padh</span><span class="p">)</span>
<span></span>    <span class="k">return</span> <span class="n">labels</span>
</code></pre></div></details><p><br/><br/><hr/><br/></p><h2 id="ultralytics.data.augment.CopyPaste"><span class="doc-kind doc-kind-class">class</span> <code>ultralytics.data.augment.CopyPaste</code></h2><div class="highlight"><pre><span></span><code><span></span><span class="n">CopyPaste</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">pre_transform</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">"flip"</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div><p><strong>Bases:</strong> <code>BaseMixTransform</code></p><p>CopyPaste class for applying Copy-Paste augmentation to image datasets.</p><p>This class implements the Copy-Paste augmentation technique as described in the paper "Simple Copy-Paste is a Strong Data Augmentation Method for Instance Segmentation" (<a href="https://arxiv.org/abs/2012.07177">https://arxiv.org/abs/2012.07177</a>). It combines objects from different images to create new training samples.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>dataset</code></td><td></td><td></td><td><code>None</code></td></tr><tr><td><code>pre_transform</code></td><td></td><td></td><td><code>None</code></td></tr><tr><td><code>p</code></td><td><code>float</code></td><td></td><td><code>0.5</code></td></tr><tr><td><code>mode</code></td><td><code>str</code></td><td></td><td><code>"flip"</code></td></tr></tbody></table><p><strong>Attributes</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dataset</code></td><td><code>Any</code></td><td>The dataset to which Copy-Paste augmentation will be applied.</td></tr><tr><td><code>pre_transform</code></td><td><code>Callable | None</code></td><td>Optional transform to apply before Copy-Paste.</td></tr><tr><td><code>p</code></td><td><code>float</code></td><td>Probability of applying Copy-Paste augmentation.</td></tr></tbody></table><p><strong>Methods</strong></p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="#ultralytics.data.augment.CopyPaste.__call__"><code>__call__</code></a></td><td>Apply Copy-Paste augmentation to an image and its labels.</td></tr><tr><td><a href="#ultralytics.data.augment.CopyPaste._mix_transform"><code>_mix_transform</code></a></td><td>Apply Copy-Paste augmentation to combine objects from another image into the current image.</td></tr><tr><td><a href="#ultralytics.data.augment.CopyPaste._transform"><code>_transform</code></a></td><td>Apply Copy-Paste augmentation to combine objects from another image into the current image.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span><span class="w"> </span><span class="nn">ultralytics.data.augment</span><span class="w"> </span><span class="kn">import</span> <span class="n">CopyPaste</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">dataset</span> <span class="o">=</span> <span class="n">YourDataset</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>  <span class="c1"># Your image dataset</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">copypaste</span> <span class="o">=</span> <span class="n">CopyPaste</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">augmented_labels</span> <span class="o">=</span> <span class="n">copypaste</span><span class="p">(</span><span class="n">original_labels</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L1676-L1772"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">class</span><span class="w"> </span><span class="nc">CopyPaste</span><span class="p">(</span><span class="n">BaseMixTransform</span><span class="p">):</span>
<span></span><span class="w">    </span><span class="sd">"""CopyPaste class for applying Copy-Paste augmentation to image datasets.</span>
<span></span>
<span></span><span class="sd">    This class implements the Copy-Paste augmentation technique as described in the paper "Simple Copy-Paste is a Strong</span>
<span></span><span class="sd">    Data Augmentation Method for Instance Segmentation" (https://arxiv.org/abs/2012.07177). It combines objects from</span>
<span></span><span class="sd">    different images to create new training samples.</span>
<span></span>
<span></span><span class="sd">    Attributes:</span>
<span></span><span class="sd">        dataset (Any): The dataset to which Copy-Paste augmentation will be applied.</span>
<span></span><span class="sd">        pre_transform (Callable | None): Optional transform to apply before Copy-Paste.</span>
<span></span><span class="sd">        p (float): Probability of applying Copy-Paste augmentation.</span>
<span></span>
<span></span><span class="sd">    Methods:</span>
<span></span><span class="sd">        _mix_transform: Apply Copy-Paste augmentation to the input labels.</span>
<span></span><span class="sd">        __call__: Apply the Copy-Paste transformation to images and annotations.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; from ultralytics.data.augment import CopyPaste</span>
<span></span><span class="sd">        &gt;&gt;&gt; dataset = YourDataset(...)  # Your image dataset</span>
<span></span><span class="sd">        &gt;&gt;&gt; copypaste = CopyPaste(dataset, p=0.5)</span>
<span></span><span class="sd">        &gt;&gt;&gt; augmented_labels = copypaste(original_labels)</span>
<span></span><span class="sd">    """</span>
<span></span>
<span></span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pre_transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">"flip"</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span></span><span class="w">        </span><span class="sd">"""Initialize CopyPaste object with dataset, pre_transform, and probability of applying CopyPaste."""</span>
<span></span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="n">pre_transform</span><span class="o">=</span><span class="n">pre_transform</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
<span></span>        <span class="k">assert</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">"flip"</span><span class="p">,</span> <span class="s2">"mixup"</span><span class="p">},</span> <span class="sa">f</span><span class="s2">"Expected `mode` to be `flip` or `mixup`, but got </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">."</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.CopyPaste.__call__"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.CopyPaste.__call__</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
</code></pre></div><p>Apply Copy-Paste augmentation to an image and its labels.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>labels</code></td><td><code>dict[str, Any]</code></td><td></td><td><em>required</em></td></tr></tbody></table><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L1710-L1735"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span></span><span class="w">    </span><span class="sd">"""Apply Copy-Paste augmentation to an image and its labels."""</span>
<span></span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span></span>        <span class="k">return</span> <span class="n">labels</span>
<span></span>    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">"flip"</span><span class="p">:</span>
<span></span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span></span>
<span></span>    <span class="c1"># Get index of one or three other images</span>
<span></span>    <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexes</span><span class="p">()</span>
<span></span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
<span></span>        <span class="n">indexes</span> <span class="o">=</span> <span class="p">[</span><span class="n">indexes</span><span class="p">]</span>
<span></span>
<span></span>    <span class="c1"># Get images information will be used for Mosaic or MixUp</span>
<span></span>    <span class="n">mix_labels</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">get_image_and_label</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">]</span>
<span></span>
<span></span>    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre_transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span></span>        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mix_labels</span><span class="p">):</span>
<span></span>            <span class="n">mix_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre_transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"mix_labels"</span><span class="p">]</span> <span class="o">=</span> <span class="n">mix_labels</span>
<span></span>
<span></span>    <span class="c1"># Update cls and texts</span>
<span></span>    <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_label_text</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span></span>    <span class="c1"># Mosaic or MixUp</span>
<span></span>    <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mix_transform</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span></span>    <span class="n">labels</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"mix_labels"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span></span>    <span class="k">return</span> <span class="n">labels</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.CopyPaste._mix_transform"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.CopyPaste._mix_transform</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_mix_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
</code></pre></div><p>Apply Copy-Paste augmentation to combine objects from another image into the current image.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>labels</code></td><td><code>dict[str, Any]</code></td><td></td><td><em>required</em></td></tr></tbody></table><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L1705-L1708"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_mix_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span></span><span class="w">    </span><span class="sd">"""Apply Copy-Paste augmentation to combine objects from another image into the current image."""</span>
<span></span>    <span class="n">labels2</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="s2">"mix_labels"</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span></span>    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">labels2</span><span class="p">)</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.CopyPaste._transform"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.CopyPaste._transform</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels1</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">labels2</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{})</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
</code></pre></div><p>Apply Copy-Paste augmentation to combine objects from another image into the current image.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>labels1</code></td><td><code>dict[str, Any]</code></td><td></td><td><em>required</em></td></tr><tr><td><code>labels2</code></td><td><code>dict[str, Any]</code></td><td></td><td><code>{}</code></td></tr></tbody></table><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L1737-L1772"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels1</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">labels2</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{})</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span></span><span class="w">    </span><span class="sd">"""Apply Copy-Paste augmentation to combine objects from another image into the current image."""</span>
<span></span>    <span class="n">im</span> <span class="o">=</span> <span class="n">labels1</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span>
<span></span>    <span class="k">if</span> <span class="s2">"mosaic_border"</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">labels1</span><span class="p">:</span>
<span></span>        <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># avoid modifying original non-mosaic image</span>
<span></span>    <span class="bp">cls</span> <span class="o">=</span> <span class="n">labels1</span><span class="p">[</span><span class="s2">"cls"</span><span class="p">]</span>
<span></span>    <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
<span></span>    <span class="n">instances</span> <span class="o">=</span> <span class="n">labels1</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"instances"</span><span class="p">)</span>
<span></span>    <span class="n">instances</span><span class="o">.</span><span class="n">convert_bbox</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s2">"xyxy"</span><span class="p">)</span>
<span></span>    <span class="n">instances</span><span class="o">.</span><span class="n">denormalize</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
<span></span>
<span></span>    <span class="n">im_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span></span>    <span class="n">instances2</span> <span class="o">=</span> <span class="n">labels2</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"instances"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span></span>    <span class="k">if</span> <span class="n">instances2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span></span>        <span class="n">instances2</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">instances</span><span class="p">)</span>
<span></span>        <span class="n">instances2</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span></span>    <span class="n">ioa</span> <span class="o">=</span> <span class="n">bbox_ioa</span><span class="p">(</span><span class="n">instances2</span><span class="o">.</span><span class="n">bboxes</span><span class="p">,</span> <span class="n">instances</span><span class="o">.</span><span class="n">bboxes</span><span class="p">)</span>  <span class="c1"># intersection over area, (N, M)</span>
<span></span>    <span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span><span class="n">ioa</span> <span class="o">&lt;</span> <span class="mf">0.30</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># (N, )</span>
<span></span>    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span>
<span></span>    <span class="n">sorted_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">ioa</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="n">indexes</span><span class="p">])</span>
<span></span>    <span class="n">indexes</span> <span class="o">=</span> <span class="n">indexes</span><span class="p">[</span><span class="n">sorted_idx</span><span class="p">]</span>
<span></span>    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">[:</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">*</span> <span class="n">n</span><span class="p">)]:</span>
<span></span>        <span class="bp">cls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">cls</span><span class="p">,</span> <span class="n">labels2</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"cls"</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)[[</span><span class="n">j</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span></span>        <span class="n">instances</span> <span class="o">=</span> <span class="n">Instances</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">instances</span><span class="p">,</span> <span class="n">instances2</span><span class="p">[[</span><span class="n">j</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span></span>        <span class="n">cv2</span><span class="o">.</span><span class="n">drawContours</span><span class="p">(</span><span class="n">im_new</span><span class="p">,</span> <span class="n">instances2</span><span class="o">.</span><span class="n">segments</span><span class="p">[[</span><span class="n">j</span><span class="p">]]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">cv2</span><span class="o">.</span><span class="n">FILLED</span><span class="p">)</span>
<span></span>
<span></span>    <span class="n">result</span> <span class="o">=</span> <span class="n">labels2</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"img"</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># augment segments</span>
<span></span>    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># cv2.flip would eliminate the last dimension for grayscale images</span>
<span></span>        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
<span></span>    <span class="n">i</span> <span class="o">=</span> <span class="n">im_new</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
<span></span>    <span class="n">im</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span></span>
<span></span>    <span class="n">labels1</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span> <span class="o">=</span> <span class="n">im</span>
<span></span>    <span class="n">labels1</span><span class="p">[</span><span class="s2">"cls"</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span>
<span></span>    <span class="n">labels1</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]</span> <span class="o">=</span> <span class="n">instances</span>
<span></span>    <span class="k">return</span> <span class="n">labels1</span>
</code></pre></div></details><p><br/><br/><hr/><br/></p><h2 id="ultralytics.data.augment.Albumentations"><span class="doc-kind doc-kind-class">class</span> <code>ultralytics.data.augment.Albumentations</code></h2><div class="highlight"><pre><span></span><code><span></span><span class="n">Albumentations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">transforms</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div><p>Albumentations transformations for image augmentation.</p><p>This class applies various image transformations using the Albumentations library. It includes operations such as Blur, Median Blur, conversion to grayscale, Contrast Limited Adaptive Histogram Equalization (CLAHE), random changes in brightness and contrast, RandomGamma, and image quality reduction through compression.</p><p>This class applies various image augmentations using the Albumentations library, including Blur, Median Blur, conversion to grayscale, Contrast Limited Adaptive Histogram Equalization, random changes of brightness and contrast, RandomGamma, and image quality reduction through compression.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>p</code></td><td><code>float</code></td><td>Probability of applying the augmentations. Must be between 0 and 1.</td><td><code>1.0</code></td></tr><tr><td><code>transforms</code></td><td><code>list, optional</code></td><td>List of custom Albumentations transforms. If None, uses default transforms.</td><td><code>None</code></td></tr></tbody></table><p><strong>Attributes</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>p</code></td><td><code>float</code></td><td>Probability of applying the transformations.</td></tr><tr><td><code>transform</code></td><td><code>albumentations.Compose</code></td><td>Composed Albumentations transforms.</td></tr><tr><td><code>contains_spatial</code></td><td><code>bool</code></td><td>Indicates if the transforms include spatial operations.</td></tr></tbody></table><p><strong>Methods</strong></p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="#ultralytics.data.augment.Albumentations.__call__"><code>__call__</code></a></td><td>Apply Albumentations transformations to input labels.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">Albumentations</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">augmented_labels</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
</code></pre></div><div class="admonition note"><p class="admonition-title">Notes</p><ul><li>Requires Albumentations version 1.0.3 or higher.</li><li>Spatial transforms are handled differently to ensure bbox compatibility.</li><li>Some transforms are applied with very low probability (0.01) by default.</li></ul></div><p><strong>Raises</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>ImportError</code></td><td>If the Albumentations package is not installed.</td></tr><tr><td><code>Exception</code></td><td>For any other errors during initialization.</td></tr></tbody></table><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L1775-L1955"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Albumentations</span><span class="p">:</span>
<span></span><span class="w">    </span><span class="sd">"""Albumentations transformations for image augmentation.</span>
<span></span>
<span></span><span class="sd">    This class applies various image transformations using the Albumentations library. It includes operations such as</span>
<span></span><span class="sd">    Blur, Median Blur, conversion to grayscale, Contrast Limited Adaptive Histogram Equalization (CLAHE), random changes</span>
<span></span><span class="sd">    in brightness and contrast, RandomGamma, and image quality reduction through compression.</span>
<span></span>
<span></span><span class="sd">    Attributes:</span>
<span></span><span class="sd">        p (float): Probability of applying the transformations.</span>
<span></span><span class="sd">        transform (albumentations.Compose): Composed Albumentations transforms.</span>
<span></span><span class="sd">        contains_spatial (bool): Indicates if the transforms include spatial operations.</span>
<span></span>
<span></span><span class="sd">    Methods:</span>
<span></span><span class="sd">        __call__: Apply the Albumentations transformations to the input labels.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; transform = Albumentations(p=0.5)</span>
<span></span><span class="sd">        &gt;&gt;&gt; augmented_labels = transform(labels)</span>
<span></span>
<span></span><span class="sd">    Notes:</span>
<span></span><span class="sd">        - Requires Albumentations version 1.0.3 or higher.</span>
<span></span><span class="sd">        - Spatial transforms are handled differently to ensure bbox compatibility.</span>
<span></span><span class="sd">        - Some transforms are applied with very low probability (0.01) by default.</span>
<span></span><span class="sd">    """</span>
<span></span>
<span></span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">transforms</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span></span><span class="w">        </span><span class="sd">"""Initialize the Albumentations transform object for YOLO bbox formatted parameters.</span>
<span></span>
<span></span><span class="sd">        This class applies various image augmentations using the Albumentations library, including Blur, Median Blur,</span>
<span></span><span class="sd">        conversion to grayscale, Contrast Limited Adaptive Histogram Equalization, random changes of brightness and</span>
<span></span><span class="sd">        contrast, RandomGamma, and image quality reduction through compression.</span>
<span></span>
<span></span><span class="sd">        Args:</span>
<span></span><span class="sd">            p (float): Probability of applying the augmentations. Must be between 0 and 1.</span>
<span></span><span class="sd">            transforms (list, optional): List of custom Albumentations transforms. If None, uses default transforms.</span>
<span></span>
<span></span><span class="sd">        Raises:</span>
<span></span><span class="sd">            ImportError: If the Albumentations package is not installed.</span>
<span></span><span class="sd">            Exception: For any other errors during initialization.</span>
<span></span><span class="sd">        """</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="kc">None</span>
<span></span>        <span class="n">prefix</span> <span class="o">=</span> <span class="n">colorstr</span><span class="p">(</span><span class="s2">"albumentations: "</span><span class="p">)</span>
<span></span>
<span></span>        <span class="k">try</span><span class="p">:</span>
<span></span>            <span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span></span>
<span></span>            <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">"NO_ALBUMENTATIONS_UPDATE"</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"1"</span>  <span class="c1"># suppress Albumentations upgrade message</span>
<span></span>            <span class="kn">import</span><span class="w"> </span><span class="nn">albumentations</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">A</span>
<span></span>
<span></span>            <span class="n">check_version</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">__version__</span><span class="p">,</span> <span class="s2">"1.0.3"</span><span class="p">,</span> <span class="n">hard</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># version requirement</span>
<span></span>
<span></span>            <span class="c1"># List of possible spatial transforms</span>
<span></span>            <span class="n">spatial_transforms</span> <span class="o">=</span> <span class="p">{</span>
<span></span>                <span class="s2">"Affine"</span><span class="p">,</span>
<span></span>                <span class="s2">"BBoxSafeRandomCrop"</span><span class="p">,</span>
<span></span>                <span class="s2">"CenterCrop"</span><span class="p">,</span>
<span></span>                <span class="s2">"CoarseDropout"</span><span class="p">,</span>
<span></span>                <span class="s2">"Crop"</span><span class="p">,</span>
<span></span>                <span class="s2">"CropAndPad"</span><span class="p">,</span>
<span></span>                <span class="s2">"CropNonEmptyMaskIfExists"</span><span class="p">,</span>
<span></span>                <span class="s2">"D4"</span><span class="p">,</span>
<span></span>                <span class="s2">"ElasticTransform"</span><span class="p">,</span>
<span></span>                <span class="s2">"Flip"</span><span class="p">,</span>
<span></span>                <span class="s2">"GridDistortion"</span><span class="p">,</span>
<span></span>                <span class="s2">"GridDropout"</span><span class="p">,</span>
<span></span>                <span class="s2">"HorizontalFlip"</span><span class="p">,</span>
<span></span>                <span class="s2">"Lambda"</span><span class="p">,</span>
<span></span>                <span class="s2">"LongestMaxSize"</span><span class="p">,</span>
<span></span>                <span class="s2">"MaskDropout"</span><span class="p">,</span>
<span></span>                <span class="s2">"MixUp"</span><span class="p">,</span>
<span></span>                <span class="s2">"Morphological"</span><span class="p">,</span>
<span></span>                <span class="s2">"NoOp"</span><span class="p">,</span>
<span></span>                <span class="s2">"OpticalDistortion"</span><span class="p">,</span>
<span></span>                <span class="s2">"PadIfNeeded"</span><span class="p">,</span>
<span></span>                <span class="s2">"Perspective"</span><span class="p">,</span>
<span></span>                <span class="s2">"PiecewiseAffine"</span><span class="p">,</span>
<span></span>                <span class="s2">"PixelDropout"</span><span class="p">,</span>
<span></span>                <span class="s2">"RandomCrop"</span><span class="p">,</span>
<span></span>                <span class="s2">"RandomCropFromBorders"</span><span class="p">,</span>
<span></span>                <span class="s2">"RandomGridShuffle"</span><span class="p">,</span>
<span></span>                <span class="s2">"RandomResizedCrop"</span><span class="p">,</span>
<span></span>                <span class="s2">"RandomRotate90"</span><span class="p">,</span>
<span></span>                <span class="s2">"RandomScale"</span><span class="p">,</span>
<span></span>                <span class="s2">"RandomSizedBBoxSafeCrop"</span><span class="p">,</span>
<span></span>                <span class="s2">"RandomSizedCrop"</span><span class="p">,</span>
<span></span>                <span class="s2">"Resize"</span><span class="p">,</span>
<span></span>                <span class="s2">"Rotate"</span><span class="p">,</span>
<span></span>                <span class="s2">"SafeRotate"</span><span class="p">,</span>
<span></span>                <span class="s2">"ShiftScaleRotate"</span><span class="p">,</span>
<span></span>                <span class="s2">"SmallestMaxSize"</span><span class="p">,</span>
<span></span>                <span class="s2">"Transpose"</span><span class="p">,</span>
<span></span>                <span class="s2">"VerticalFlip"</span><span class="p">,</span>
<span></span>                <span class="s2">"XYMasking"</span><span class="p">,</span>
<span></span>            <span class="p">}</span>  <span class="c1"># from https://albumentations.ai/docs/getting_started/transforms_and_targets/#spatial-level-transforms</span>
<span></span>
<span></span>            <span class="c1"># Transforms, use custom transforms if provided, otherwise use defaults</span>
<span></span>            <span class="n">T</span> <span class="o">=</span> <span class="p">(</span>
<span></span>                <span class="p">[</span>
<span></span>                    <span class="n">A</span><span class="o">.</span><span class="n">Blur</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.01</span><span class="p">),</span>
<span></span>                    <span class="n">A</span><span class="o">.</span><span class="n">MedianBlur</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.01</span><span class="p">),</span>
<span></span>                    <span class="n">A</span><span class="o">.</span><span class="n">ToGray</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.01</span><span class="p">),</span>
<span></span>                    <span class="n">A</span><span class="o">.</span><span class="n">CLAHE</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.01</span><span class="p">),</span>
<span></span>                    <span class="n">A</span><span class="o">.</span><span class="n">RandomBrightnessContrast</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.0</span><span class="p">),</span>
<span></span>                    <span class="n">A</span><span class="o">.</span><span class="n">RandomGamma</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.0</span><span class="p">),</span>
<span></span>                    <span class="n">A</span><span class="o">.</span><span class="n">ImageCompression</span><span class="p">(</span><span class="n">quality_range</span><span class="o">=</span><span class="p">(</span><span class="mi">75</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.0</span><span class="p">),</span>
<span></span>                <span class="p">]</span>
<span></span>                <span class="k">if</span> <span class="n">transforms</span> <span class="ow">is</span> <span class="kc">None</span>
<span></span>                <span class="k">else</span> <span class="n">transforms</span>
<span></span>            <span class="p">)</span>
<span></span>
<span></span>            <span class="c1"># Compose transforms</span>
<span></span>            <span class="bp">self</span><span class="o">.</span><span class="n">contains_spatial</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">transform</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="n">spatial_transforms</span> <span class="k">for</span> <span class="n">transform</span> <span class="ow">in</span> <span class="n">T</span><span class="p">)</span>
<span></span>            <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="p">(</span>
<span></span>                <span class="n">A</span><span class="o">.</span><span class="n">Compose</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">bbox_params</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">BboxParams</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s2">"yolo"</span><span class="p">,</span> <span class="n">label_fields</span><span class="o">=</span><span class="p">[</span><span class="s2">"class_labels"</span><span class="p">]))</span>
<span></span>                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_spatial</span>
<span></span>                <span class="k">else</span> <span class="n">A</span><span class="o">.</span><span class="n">Compose</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span></span>            <span class="p">)</span>
<span></span>            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">,</span> <span class="s2">"set_random_seed"</span><span class="p">):</span>
<span></span>                <span class="c1"># Required for deterministic transforms in albumentations&gt;=1.4.21</span>
<span></span>                <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">set_random_seed</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">initial_seed</span><span class="p">())</span>
<span></span>            <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">", "</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">"</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">"always_apply=False, "</span><span class="p">,</span> <span class="s2">""</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">T</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">p</span><span class="p">))</span>
<span></span>        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>  <span class="c1"># package not installed, skip</span>
<span></span>            <span class="k">pass</span>
<span></span>        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span></span>            <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">e</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.Albumentations.__call__"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.Albumentations.__call__</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
</code></pre></div><p>Apply Albumentations transformations to input labels.</p><p>This method applies a series of image augmentations using the Albumentations library. It can perform both spatial and non-spatial transformations on the input image and its corresponding labels.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>labels</code></td><td><code>dict[str, Any]</code></td><td>A dictionary containing image data and annotations. Expected keys are: - 'img': np.ndarray representing the image - 'cls': np.ndarray of class labels - 'instances': object containing bounding boxes and other instance information</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dict[str, Any]</code></td><td>The input dictionary with augmented image and updated annotations.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">Albumentations</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">labels</span> <span class="o">=</span> <span class="p">{</span>
<span></span><span class="o">...</span>     <span class="s2">"img"</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
<span></span><span class="o">...</span>     <span class="s2">"cls"</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
<span></span><span class="o">...</span>     <span class="s2">"instances"</span><span class="p">:</span> <span class="n">Instances</span><span class="p">(</span><span class="n">bboxes</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">]])),</span>
<span></span><span class="o">...</span> <span class="p">}</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">augmented</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="k">assert</span> <span class="n">augmented</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div><div class="admonition note"><p class="admonition-title">Notes</p><ul><li>The method applies transformations with probability self.p.</li><li>Spatial transforms update bounding boxes, while non-spatial transforms only modify the image.</li><li>Requires the Albumentations library to be installed.</li></ul></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L1902-L1955"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span></span><span class="w">    </span><span class="sd">"""Apply Albumentations transformations to input labels.</span>
<span></span>
<span></span><span class="sd">    This method applies a series of image augmentations using the Albumentations library. It can perform both</span>
<span></span><span class="sd">    spatial and non-spatial transformations on the input image and its corresponding labels.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        labels (dict[str, Any]): A dictionary containing image data and annotations. Expected keys are:</span>
<span></span><span class="sd">            - 'img': np.ndarray representing the image</span>
<span></span><span class="sd">            - 'cls': np.ndarray of class labels</span>
<span></span><span class="sd">            - 'instances': object containing bounding boxes and other instance information</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (dict[str, Any]): The input dictionary with augmented image and updated annotations.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; transform = Albumentations(p=0.5)</span>
<span></span><span class="sd">        &gt;&gt;&gt; labels = {</span>
<span></span><span class="sd">        ...     "img": np.random.rand(640, 640, 3),</span>
<span></span><span class="sd">        ...     "cls": np.array([0, 1]),</span>
<span></span><span class="sd">        ...     "instances": Instances(bboxes=np.array([[0, 0, 1, 1], [0.5, 0.5, 0.8, 0.8]])),</span>
<span></span><span class="sd">        ... }</span>
<span></span><span class="sd">        &gt;&gt;&gt; augmented = transform(labels)</span>
<span></span><span class="sd">        &gt;&gt;&gt; assert augmented["img"].shape == (640, 640, 3)</span>
<span></span>
<span></span><span class="sd">    Notes:</span>
<span></span><span class="sd">        - The method applies transformations with probability self.p.</span>
<span></span><span class="sd">        - Spatial transforms update bounding boxes, while non-spatial transforms only modify the image.</span>
<span></span><span class="sd">        - Requires the Albumentations library to be installed.</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">:</span>
<span></span>        <span class="k">return</span> <span class="n">labels</span>
<span></span>
<span></span>    <span class="n">im</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span>
<span></span>    <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># Only apply Albumentation on 3-channel images</span>
<span></span>        <span class="k">return</span> <span class="n">labels</span>
<span></span>
<span></span>    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_spatial</span><span class="p">:</span>
<span></span>        <span class="bp">cls</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="s2">"cls"</span><span class="p">]</span>
<span></span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span></span>            <span class="n">labels</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]</span><span class="o">.</span><span class="n">convert_bbox</span><span class="p">(</span><span class="s2">"xywh"</span><span class="p">)</span>
<span></span>            <span class="n">labels</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="o">*</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span></span>            <span class="n">bboxes</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]</span><span class="o">.</span><span class="n">bboxes</span>
<span></span>            <span class="c1"># TODO: add supports of segments and keypoints</span>
<span></span>            <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">im</span><span class="p">,</span> <span class="n">bboxes</span><span class="o">=</span><span class="n">bboxes</span><span class="p">,</span> <span class="n">class_labels</span><span class="o">=</span><span class="bp">cls</span><span class="p">)</span>  <span class="c1"># transformed</span>
<span></span>            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="p">[</span><span class="s2">"class_labels"</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># skip update if no bbox in new im</span>
<span></span>                <span class="n">labels</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span><span class="p">[</span><span class="s2">"image"</span><span class="p">]</span>
<span></span>                <span class="n">labels</span><span class="p">[</span><span class="s2">"cls"</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new</span><span class="p">[</span><span class="s2">"class_labels"</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span></span>                <span class="n">bboxes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new</span><span class="p">[</span><span class="s2">"bboxes"</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span></span>            <span class="n">labels</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">bboxes</span><span class="o">=</span><span class="n">bboxes</span><span class="p">)</span>
<span></span>    <span class="k">else</span><span class="p">:</span>
<span></span>        <span class="n">labels</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">labels</span><span class="p">[</span><span class="s2">"img"</span><span class="p">])[</span><span class="s2">"image"</span><span class="p">]</span>  <span class="c1"># transformed</span>
<span></span>
<span></span>    <span class="k">return</span> <span class="n">labels</span>
</code></pre></div></details><p><br/><br/><hr/><br/></p><h2 id="ultralytics.data.augment.Format"><span class="doc-kind doc-kind-class">class</span> <code>ultralytics.data.augment.Format</code></h2><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
<span></span>    <span class="bp">self</span><span class="p">,</span>
<span></span>    <span class="n">bbox_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">"xywh"</span><span class="p">,</span>
<span></span>    <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span></span>    <span class="n">return_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span></span>    <span class="n">return_keypoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span></span>    <span class="n">return_obb</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span></span>    <span class="n">mask_ratio</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span></span>    <span class="n">mask_overlap</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span></span>    <span class="n">batch_idx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span></span>    <span class="n">bgr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
<span></span><span class="p">)</span>
</code></pre></div><p>A class for formatting image annotations for object detection, instance segmentation, and pose estimation tasks.</p><p>This class standardizes image and instance annotations to be used by the <code>collate_fn</code> in PyTorch DataLoader.</p><p>This class standardizes image and instance annotations for object detection, instance segmentation, and pose estimation tasks, preparing them for use in PyTorch DataLoader's <code>collate_fn</code>.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>bbox_format</code></td><td><code>str</code></td><td>Format for bounding boxes. Options are 'xywh', 'xyxy', etc.</td><td><code>"xywh"</code></td></tr><tr><td><code>normalize</code></td><td><code>bool</code></td><td>Whether to normalize bounding boxes to [0,1].</td><td><code>True</code></td></tr><tr><td><code>return_mask</code></td><td><code>bool</code></td><td>If True, returns instance masks for segmentation tasks.</td><td><code>False</code></td></tr><tr><td><code>return_keypoint</code></td><td><code>bool</code></td><td>If True, returns keypoints for pose estimation tasks.</td><td><code>False</code></td></tr><tr><td><code>return_obb</code></td><td><code>bool</code></td><td>If True, returns oriented bounding boxes.</td><td><code>False</code></td></tr><tr><td><code>mask_ratio</code></td><td><code>int</code></td><td>Downsample ratio for masks.</td><td><code>4</code></td></tr><tr><td><code>mask_overlap</code></td><td><code>bool</code></td><td>If True, allows mask overlap.</td><td><code>True</code></td></tr><tr><td><code>batch_idx</code></td><td><code>bool</code></td><td>If True, keeps batch indexes.</td><td><code>True</code></td></tr><tr><td><code>bgr</code></td><td><code>float</code></td><td>Probability of returning BGR images instead of RGB.</td><td><code>0.0</code></td></tr></tbody></table><p><strong>Attributes</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>bbox_format</code></td><td><code>str</code></td><td>Format for bounding boxes. Options are 'xywh' or 'xyxy'.</td></tr><tr><td><code>normalize</code></td><td><code>bool</code></td><td>Whether to normalize bounding boxes.</td></tr><tr><td><code>return_mask</code></td><td><code>bool</code></td><td>Whether to return instance masks for segmentation.</td></tr><tr><td><code>return_keypoint</code></td><td><code>bool</code></td><td>Whether to return keypoints for pose estimation.</td></tr><tr><td><code>return_obb</code></td><td><code>bool</code></td><td>Whether to return oriented bounding boxes.</td></tr><tr><td><code>mask_ratio</code></td><td><code>int</code></td><td>Downsample ratio for masks.</td></tr><tr><td><code>mask_overlap</code></td><td><code>bool</code></td><td>Whether to overlap masks.</td></tr><tr><td><code>batch_idx</code></td><td><code>bool</code></td><td>Whether to keep batch indexes.</td></tr><tr><td><code>bgr</code></td><td><code>float</code></td><td>The probability to return BGR images.</td></tr></tbody></table><p><strong>Methods</strong></p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="#ultralytics.data.augment.Format.__call__"><code>__call__</code></a></td><td>Format image annotations for object detection, instance segmentation, and pose estimation tasks.</td></tr><tr><td><a href="#ultralytics.data.augment.Format._format_img"><code>_format_img</code></a></td><td>Format an image for YOLO from a Numpy array to a PyTorch tensor.</td></tr><tr><td><a href="#ultralytics.data.augment.Format._format_segments"><code>_format_segments</code></a></td><td>Convert polygon segments to bitmap masks.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">formatter</span> <span class="o">=</span> <span class="n">Format</span><span class="p">(</span><span class="n">bbox_format</span><span class="o">=</span><span class="s2">"xywh"</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">formatted_labels</span> <span class="o">=</span> <span class="n">formatter</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">img</span> <span class="o">=</span> <span class="n">formatted_labels</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">bboxes</span> <span class="o">=</span> <span class="n">formatted_labels</span><span class="p">[</span><span class="s2">"bboxes"</span><span class="p">]</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">masks</span> <span class="o">=</span> <span class="n">formatted_labels</span><span class="p">[</span><span class="s2">"masks"</span><span class="p">]</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L1958-L2153"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Format</span><span class="p">:</span>
<span></span><span class="w">    </span><span class="sd">"""A class for formatting image annotations for object detection, instance segmentation, and pose estimation tasks.</span>
<span></span>
<span></span><span class="sd">    This class standardizes image and instance annotations to be used by the `collate_fn` in PyTorch DataLoader.</span>
<span></span>
<span></span><span class="sd">    Attributes:</span>
<span></span><span class="sd">        bbox_format (str): Format for bounding boxes. Options are 'xywh' or 'xyxy'.</span>
<span></span><span class="sd">        normalize (bool): Whether to normalize bounding boxes.</span>
<span></span><span class="sd">        return_mask (bool): Whether to return instance masks for segmentation.</span>
<span></span><span class="sd">        return_keypoint (bool): Whether to return keypoints for pose estimation.</span>
<span></span><span class="sd">        return_obb (bool): Whether to return oriented bounding boxes.</span>
<span></span><span class="sd">        mask_ratio (int): Downsample ratio for masks.</span>
<span></span><span class="sd">        mask_overlap (bool): Whether to overlap masks.</span>
<span></span><span class="sd">        batch_idx (bool): Whether to keep batch indexes.</span>
<span></span><span class="sd">        bgr (float): The probability to return BGR images.</span>
<span></span>
<span></span><span class="sd">    Methods:</span>
<span></span><span class="sd">        __call__: Format labels dictionary with image, classes, bounding boxes, and optionally masks and keypoints.</span>
<span></span><span class="sd">        _format_img: Convert image from Numpy array to PyTorch tensor.</span>
<span></span><span class="sd">        _format_segments: Convert polygon points to bitmap masks.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; formatter = Format(bbox_format="xywh", normalize=True, return_mask=True)</span>
<span></span><span class="sd">        &gt;&gt;&gt; formatted_labels = formatter(labels)</span>
<span></span><span class="sd">        &gt;&gt;&gt; img = formatted_labels["img"]</span>
<span></span><span class="sd">        &gt;&gt;&gt; bboxes = formatted_labels["bboxes"]</span>
<span></span><span class="sd">        &gt;&gt;&gt; masks = formatted_labels["masks"]</span>
<span></span><span class="sd">    """</span>
<span></span>
<span></span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
<span></span>        <span class="bp">self</span><span class="p">,</span>
<span></span>        <span class="n">bbox_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">"xywh"</span><span class="p">,</span>
<span></span>        <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span></span>        <span class="n">return_mask</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span></span>        <span class="n">return_keypoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span></span>        <span class="n">return_obb</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span></span>        <span class="n">mask_ratio</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span></span>        <span class="n">mask_overlap</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span></span>        <span class="n">batch_idx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span></span>        <span class="n">bgr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
<span></span>    <span class="p">):</span>
<span></span><span class="w">        </span><span class="sd">"""Initialize the Format class with given parameters for image and instance annotation formatting.</span>
<span></span>
<span></span><span class="sd">        This class standardizes image and instance annotations for object detection, instance segmentation, and pose</span>
<span></span><span class="sd">        estimation tasks, preparing them for use in PyTorch DataLoader's `collate_fn`.</span>
<span></span>
<span></span><span class="sd">        Args:</span>
<span></span><span class="sd">            bbox_format (str): Format for bounding boxes. Options are 'xywh', 'xyxy', etc.</span>
<span></span><span class="sd">            normalize (bool): Whether to normalize bounding boxes to [0,1].</span>
<span></span><span class="sd">            return_mask (bool): If True, returns instance masks for segmentation tasks.</span>
<span></span><span class="sd">            return_keypoint (bool): If True, returns keypoints for pose estimation tasks.</span>
<span></span><span class="sd">            return_obb (bool): If True, returns oriented bounding boxes.</span>
<span></span><span class="sd">            mask_ratio (int): Downsample ratio for masks.</span>
<span></span><span class="sd">            mask_overlap (bool): If True, allows mask overlap.</span>
<span></span><span class="sd">            batch_idx (bool): If True, keeps batch indexes.</span>
<span></span><span class="sd">            bgr (float): Probability of returning BGR images instead of RGB.</span>
<span></span><span class="sd">        """</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">bbox_format</span> <span class="o">=</span> <span class="n">bbox_format</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span> <span class="o">=</span> <span class="n">normalize</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">return_mask</span> <span class="o">=</span> <span class="n">return_mask</span>  <span class="c1"># set False when training detection only</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">return_keypoint</span> <span class="o">=</span> <span class="n">return_keypoint</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">return_obb</span> <span class="o">=</span> <span class="n">return_obb</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">mask_ratio</span> <span class="o">=</span> <span class="n">mask_ratio</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">mask_overlap</span> <span class="o">=</span> <span class="n">mask_overlap</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">batch_idx</span> <span class="o">=</span> <span class="n">batch_idx</span>  <span class="c1"># keep the batch indexes</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">bgr</span> <span class="o">=</span> <span class="n">bgr</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.Format.__call__"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.Format.__call__</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
</code></pre></div><p>Format image annotations for object detection, instance segmentation, and pose estimation tasks.</p><p>This method standardizes the image and instance annotations to be used by the <code>collate_fn</code> in PyTorch DataLoader. It processes the input labels dictionary, converting annotations to the specified format and applying normalization if required.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>labels</code></td><td><code>dict[str, Any]</code></td><td>A dictionary containing image and annotation data with the following keys: - 'img': The input image as a numpy array. - 'cls': Class labels for instances. - 'instances': An Instances object containing bounding boxes, segments, and keypoints.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dict[str, Any]</code></td><td>A dictionary with formatted data, including:</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">formatter</span> <span class="o">=</span> <span class="n">Format</span><span class="p">(</span><span class="n">bbox_format</span><span class="o">=</span><span class="s2">"xywh"</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">labels</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"img"</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">"cls"</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="s2">"instances"</span><span class="p">:</span> <span class="n">Instances</span><span class="p">(</span><span class="o">...</span><span class="p">)}</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">formatted_labels</span> <span class="o">=</span> <span class="n">formatter</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">formatted_labels</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L2025-L2091"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span></span><span class="w">    </span><span class="sd">"""Format image annotations for object detection, instance segmentation, and pose estimation tasks.</span>
<span></span>
<span></span><span class="sd">    This method standardizes the image and instance annotations to be used by the `collate_fn` in PyTorch</span>
<span></span><span class="sd">    DataLoader. It processes the input labels dictionary, converting annotations to the specified format and</span>
<span></span><span class="sd">    applying normalization if required.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        labels (dict[str, Any]): A dictionary containing image and annotation data with the following keys:</span>
<span></span><span class="sd">            - 'img': The input image as a numpy array.</span>
<span></span><span class="sd">            - 'cls': Class labels for instances.</span>
<span></span><span class="sd">            - 'instances': An Instances object containing bounding boxes, segments, and keypoints.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (dict[str, Any]): A dictionary with formatted data, including:</span>
<span></span><span class="sd">            - 'img': Formatted image tensor.</span>
<span></span><span class="sd">            - 'cls': Class label's tensor.</span>
<span></span><span class="sd">            - 'bboxes': Bounding boxes tensor in the specified format.</span>
<span></span><span class="sd">            - 'masks': Instance masks tensor (if return_mask is True).</span>
<span></span><span class="sd">            - 'keypoints': Keypoints tensor (if return_keypoint is True).</span>
<span></span><span class="sd">            - 'batch_idx': Batch index tensor (if batch_idx is True).</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; formatter = Format(bbox_format="xywh", normalize=True, return_mask=True)</span>
<span></span><span class="sd">        &gt;&gt;&gt; labels = {"img": np.random.rand(640, 640, 3), "cls": np.array([0, 1]), "instances": Instances(...)}</span>
<span></span><span class="sd">        &gt;&gt;&gt; formatted_labels = formatter(labels)</span>
<span></span><span class="sd">        &gt;&gt;&gt; print(formatted_labels.keys())</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="n">img</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"img"</span><span class="p">)</span>
<span></span>    <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
<span></span>    <span class="bp">cls</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"cls"</span><span class="p">)</span>
<span></span>    <span class="n">instances</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"instances"</span><span class="p">)</span>
<span></span>    <span class="n">instances</span><span class="o">.</span><span class="n">convert_bbox</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bbox_format</span><span class="p">)</span>
<span></span>    <span class="n">instances</span><span class="o">.</span><span class="n">denormalize</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
<span></span>    <span class="n">nl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instances</span><span class="p">)</span>
<span></span>
<span></span>    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_mask</span><span class="p">:</span>
<span></span>        <span class="k">if</span> <span class="n">nl</span><span class="p">:</span>
<span></span>            <span class="n">masks</span><span class="p">,</span> <span class="n">instances</span><span class="p">,</span> <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_segments</span><span class="p">(</span><span class="n">instances</span><span class="p">,</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
<span></span>            <span class="n">masks</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">masks</span><span class="p">)</span>
<span></span>        <span class="k">else</span><span class="p">:</span>
<span></span>            <span class="n">masks</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
<span></span>                <span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_overlap</span> <span class="k">else</span> <span class="n">nl</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_ratio</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_ratio</span>
<span></span>            <span class="p">)</span>
<span></span>        <span class="n">labels</span><span class="p">[</span><span class="s2">"masks"</span><span class="p">]</span> <span class="o">=</span> <span class="n">masks</span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_img</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"cls"</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="k">if</span> <span class="n">nl</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nl</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"bboxes"</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">instances</span><span class="o">.</span><span class="n">bboxes</span><span class="p">)</span> <span class="k">if</span> <span class="n">nl</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nl</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span></span>    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_keypoint</span><span class="p">:</span>
<span></span>        <span class="n">labels</span><span class="p">[</span><span class="s2">"keypoints"</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
<span></span>            <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">if</span> <span class="n">instances</span><span class="o">.</span><span class="n">keypoints</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">instances</span><span class="o">.</span><span class="n">keypoints</span><span class="p">)</span>
<span></span>        <span class="p">)</span>
<span></span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span><span class="p">:</span>
<span></span>            <span class="n">labels</span><span class="p">[</span><span class="s2">"keypoints"</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">w</span>
<span></span>            <span class="n">labels</span><span class="p">[</span><span class="s2">"keypoints"</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="n">h</span>
<span></span>    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_obb</span><span class="p">:</span>
<span></span>        <span class="n">labels</span><span class="p">[</span><span class="s2">"bboxes"</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
<span></span>            <span class="n">xyxyxyxy2xywhr</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">instances</span><span class="o">.</span><span class="n">segments</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">instances</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span></span>        <span class="p">)</span>
<span></span>    <span class="c1"># NOTE: need to normalize obb in xywhr format for width-height consistency</span>
<span></span>    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span><span class="p">:</span>
<span></span>        <span class="n">labels</span><span class="p">[</span><span class="s2">"bboxes"</span><span class="p">][:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span> <span class="o">/=</span> <span class="n">w</span>
<span></span>        <span class="n">labels</span><span class="p">[</span><span class="s2">"bboxes"</span><span class="p">][:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span> <span class="o">/=</span> <span class="n">h</span>
<span></span>    <span class="c1"># Then we can use collate_fn</span>
<span></span>    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_idx</span><span class="p">:</span>
<span></span>        <span class="n">labels</span><span class="p">[</span><span class="s2">"batch_idx"</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nl</span><span class="p">)</span>
<span></span>    <span class="k">return</span> <span class="n">labels</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.Format._format_img"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.Format._format_img</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_format_img</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span>
</code></pre></div><p>Format an image for YOLO from a Numpy array to a PyTorch tensor.</p><p>This function performs the following operations: 1. Ensures the image has 3 dimensions (adds a channel dimension if needed). 2. Transposes the image from HWC to CHW format. 3. Optionally flips the color channels from RGB to BGR. 4. Converts the image to a contiguous array. 5. Converts the Numpy array to a PyTorch tensor.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>img</code></td><td><code>np.ndarray</code></td><td>Input image as a Numpy array with shape (H, W, C) or (H, W).</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>torch.Tensor</code></td><td>Formatted image as a PyTorch tensor with shape (C, H, W).</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">formatted_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_img</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">formatted_img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span></span><span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L2093-L2121"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_format_img</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span></span><span class="w">    </span><span class="sd">"""Format an image for YOLO from a Numpy array to a PyTorch tensor.</span>
<span></span>
<span></span><span class="sd">    This function performs the following operations:</span>
<span></span><span class="sd">    1. Ensures the image has 3 dimensions (adds a channel dimension if needed).</span>
<span></span><span class="sd">    2. Transposes the image from HWC to CHW format.</span>
<span></span><span class="sd">    3. Optionally flips the color channels from RGB to BGR.</span>
<span></span><span class="sd">    4. Converts the image to a contiguous array.</span>
<span></span><span class="sd">    5. Converts the Numpy array to a PyTorch tensor.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        img (np.ndarray): Input image as a Numpy array with shape (H, W, C) or (H, W).</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (torch.Tensor): Formatted image as a PyTorch tensor with shape (C, H, W).</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span></span><span class="sd">        &gt;&gt;&gt; img = np.random.rand(100, 100, 3)</span>
<span></span><span class="sd">        &gt;&gt;&gt; formatted_img = self._format_img(img)</span>
<span></span><span class="sd">        &gt;&gt;&gt; print(formatted_img.shape)</span>
<span></span><span class="sd">        torch.Size([3, 100, 100])</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
<span></span>        <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span></span>    <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span></span>    <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">img</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">bgr</span> <span class="ow">and</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">else</span> <span class="n">img</span><span class="p">)</span>
<span></span>    <span class="n">img</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span></span>    <span class="k">return</span> <span class="n">img</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.Format._format_segments"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.Format._format_segments</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_format_segments</span><span class="p">(</span>
<span></span>    <span class="bp">self</span><span class="p">,</span> <span class="n">instances</span><span class="p">:</span> <span class="n">Instances</span><span class="p">,</span> <span class="bp">cls</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="nb">int</span>
<span></span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Instances</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>
</code></pre></div><p>Convert polygon segments to bitmap masks.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>instances</code></td><td><code>Instances</code></td><td>Object containing segment information.</td><td><em>required</em></td></tr><tr><td><code>cls</code></td><td><code>np.ndarray</code></td><td>Class labels for each instance.</td><td><em>required</em></td></tr><tr><td><code>w</code></td><td><code>int</code></td><td>Width of the image.</td><td><em>required</em></td></tr><tr><td><code>h</code></td><td><code>int</code></td><td>Height of the image.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>masks (np.ndarray)</code></td><td>Bitmap masks with shape (N, H, W) or (1, H, W) if mask_overlap is True.</td></tr><tr><td><code>instances (Instances)</code></td><td>Updated instances object with sorted segments if mask_overlap is True.</td></tr><tr><td><code>cls (np.ndarray)</code></td><td>Updated class labels, sorted if mask_overlap is True.</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">Notes</p><ul><li>If self.mask_overlap is True, masks are overlapped and sorted by area.</li><li>If self.mask_overlap is False, each mask is represented separately.</li><li>Masks are downsampled according to self.mask_ratio.</li></ul></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L2123-L2153"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">_format_segments</span><span class="p">(</span>
<span></span>    <span class="bp">self</span><span class="p">,</span> <span class="n">instances</span><span class="p">:</span> <span class="n">Instances</span><span class="p">,</span> <span class="bp">cls</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="nb">int</span>
<span></span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Instances</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span></span><span class="w">    </span><span class="sd">"""Convert polygon segments to bitmap masks.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        instances (Instances): Object containing segment information.</span>
<span></span><span class="sd">        cls (np.ndarray): Class labels for each instance.</span>
<span></span><span class="sd">        w (int): Width of the image.</span>
<span></span><span class="sd">        h (int): Height of the image.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        masks (np.ndarray): Bitmap masks with shape (N, H, W) or (1, H, W) if mask_overlap is True.</span>
<span></span><span class="sd">        instances (Instances): Updated instances object with sorted segments if mask_overlap is True.</span>
<span></span><span class="sd">        cls (np.ndarray): Updated class labels, sorted if mask_overlap is True.</span>
<span></span>
<span></span><span class="sd">    Notes:</span>
<span></span><span class="sd">        - If self.mask_overlap is True, masks are overlapped and sorted by area.</span>
<span></span><span class="sd">        - If self.mask_overlap is False, each mask is represented separately.</span>
<span></span><span class="sd">        - Masks are downsampled according to self.mask_ratio.</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="n">segments</span> <span class="o">=</span> <span class="n">instances</span><span class="o">.</span><span class="n">segments</span>
<span></span>    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_overlap</span><span class="p">:</span>
<span></span>        <span class="n">masks</span><span class="p">,</span> <span class="n">sorted_idx</span> <span class="o">=</span> <span class="n">polygons2masks_overlap</span><span class="p">((</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="n">segments</span><span class="p">,</span> <span class="n">downsample_ratio</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_ratio</span><span class="p">)</span>
<span></span>        <span class="n">masks</span> <span class="o">=</span> <span class="n">masks</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>  <span class="c1"># (640, 640) -&gt; (1, 640, 640)</span>
<span></span>        <span class="n">instances</span> <span class="o">=</span> <span class="n">instances</span><span class="p">[</span><span class="n">sorted_idx</span><span class="p">]</span>
<span></span>        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">[</span><span class="n">sorted_idx</span><span class="p">]</span>
<span></span>    <span class="k">else</span><span class="p">:</span>
<span></span>        <span class="n">masks</span> <span class="o">=</span> <span class="n">polygons2masks</span><span class="p">((</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="n">segments</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">downsample_ratio</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_ratio</span><span class="p">)</span>
<span></span>
<span></span>    <span class="k">return</span> <span class="n">masks</span><span class="p">,</span> <span class="n">instances</span><span class="p">,</span> <span class="bp">cls</span>
</code></pre></div></details><p><br/><br/><hr/><br/></p><h2 id="ultralytics.data.augment.LoadVisualPrompt"><span class="doc-kind doc-kind-class">class</span> <code>ultralytics.data.augment.LoadVisualPrompt</code></h2><div class="highlight"><pre><span></span><code><span></span><span class="n">LoadVisualPrompt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div><p>Create visual prompts from bounding boxes or masks for model input.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>scale_factor</code></td><td><code>float</code></td><td>Factor to scale the input image dimensions.</td><td><code>1 / 8</code></td></tr></tbody></table><p><strong>Methods</strong></p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="#ultralytics.data.augment.LoadVisualPrompt.__call__"><code>__call__</code></a></td><td>Process labels to create visual prompts.</td></tr><tr><td><a href="#ultralytics.data.augment.LoadVisualPrompt.get_visuals"><code>get_visuals</code></a></td><td>Generate visual masks based on bounding boxes or masks.</td></tr><tr><td><a href="#ultralytics.data.augment.LoadVisualPrompt.make_mask"><code>make_mask</code></a></td><td>Create binary masks from bounding boxes.</td></tr></tbody></table><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L2156-L2248"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">class</span><span class="w"> </span><span class="nc">LoadVisualPrompt</span><span class="p">:</span>
<span></span><span class="w">    </span><span class="sd">"""Create visual prompts from bounding boxes or masks for model input."""</span>
<span></span>
<span></span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span></span><span class="w">        </span><span class="sd">"""Initialize the LoadVisualPrompt with a scale factor.</span>
<span></span>
<span></span><span class="sd">        Args:</span>
<span></span><span class="sd">            scale_factor (float): Factor to scale the input image dimensions.</span>
<span></span><span class="sd">        """</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor</span> <span class="o">=</span> <span class="n">scale_factor</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.LoadVisualPrompt.__call__"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.LoadVisualPrompt.__call__</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
</code></pre></div><p>Process labels to create visual prompts.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>labels</code></td><td><code>dict[str, Any]</code></td><td>Dictionary containing image data and annotations.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dict[str, Any]</code></td><td>Updated labels with visual prompts added.</td></tr></tbody></table><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L2184-L2202"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span></span><span class="w">    </span><span class="sd">"""Process labels to create visual prompts.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        labels (dict[str, Any]): Dictionary containing image data and annotations.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (dict[str, Any]): Updated labels with visual prompts added.</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="n">imgsz</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="s2">"img"</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span></span>    <span class="n">bboxes</span><span class="p">,</span> <span class="n">masks</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
<span></span>    <span class="k">if</span> <span class="s2">"bboxes"</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
<span></span>        <span class="n">bboxes</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="s2">"bboxes"</span><span class="p">]</span>
<span></span>        <span class="n">bboxes</span> <span class="o">=</span> <span class="n">xywh2xyxy</span><span class="p">(</span><span class="n">bboxes</span><span class="p">)</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">imgsz</span><span class="p">)[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>  <span class="c1"># denormalize boxes</span>
<span></span>
<span></span>    <span class="bp">cls</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="s2">"cls"</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
<span></span>    <span class="n">visuals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_visuals</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">imgsz</span><span class="p">,</span> <span class="n">bboxes</span><span class="o">=</span><span class="n">bboxes</span><span class="p">,</span> <span class="n">masks</span><span class="o">=</span><span class="n">masks</span><span class="p">)</span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"visuals"</span><span class="p">]</span> <span class="o">=</span> <span class="n">visuals</span>
<span></span>    <span class="k">return</span> <span class="n">labels</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.LoadVisualPrompt.get_visuals"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.LoadVisualPrompt.get_visuals</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_visuals</span><span class="p">(</span>
<span></span>    <span class="bp">self</span><span class="p">,</span>
<span></span>    <span class="n">category</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
<span></span>    <span class="n">shape</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span></span>    <span class="n">bboxes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span></span>    <span class="n">masks</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span></span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span>
</code></pre></div><p>Generate visual masks based on bounding boxes or masks.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>category</code></td><td><code>int | np.ndarray | torch.Tensor</code></td><td>The category labels for the objects.</td><td><em>required</em></td></tr><tr><td><code>shape</code></td><td><code>tuple[int, int]</code></td><td>The shape of the image (height, width).</td><td><em>required</em></td></tr><tr><td><code>bboxes</code></td><td><code>np.ndarray | torch.Tensor, optional</code></td><td>Bounding boxes for the objects, xyxy format.</td><td><code>None</code></td></tr><tr><td><code>masks</code></td><td><code>np.ndarray | torch.Tensor, optional</code></td><td>Masks for the objects.</td><td><code>None</code></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>torch.Tensor</code></td><td>A tensor containing the visual masks for each category.</td></tr></tbody></table><p><strong>Raises</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>ValueError</code></td><td>If neither bboxes nor masks are provided.</td></tr></tbody></table><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L2204-L2248"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_visuals</span><span class="p">(</span>
<span></span>    <span class="bp">self</span><span class="p">,</span>
<span></span>    <span class="n">category</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
<span></span>    <span class="n">shape</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span></span>    <span class="n">bboxes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span></span>    <span class="n">masks</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span></span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span></span><span class="w">    </span><span class="sd">"""Generate visual masks based on bounding boxes or masks.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        category (int | np.ndarray | torch.Tensor): The category labels for the objects.</span>
<span></span><span class="sd">        shape (tuple[int, int]): The shape of the image (height, width).</span>
<span></span><span class="sd">        bboxes (np.ndarray | torch.Tensor, optional): Bounding boxes for the objects, xyxy format.</span>
<span></span><span class="sd">        masks (np.ndarray | torch.Tensor, optional): Masks for the objects.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (torch.Tensor): A tensor containing the visual masks for each category.</span>
<span></span>
<span></span><span class="sd">    Raises:</span>
<span></span><span class="sd">        ValueError: If neither bboxes nor masks are provided.</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="n">masksz</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor</span><span class="p">))</span>
<span></span>    <span class="k">if</span> <span class="n">bboxes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span></span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bboxes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span></span>            <span class="n">bboxes</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">bboxes</span><span class="p">)</span>
<span></span>        <span class="n">bboxes</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor</span>
<span></span>        <span class="n">masks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_mask</span><span class="p">(</span><span class="n">bboxes</span><span class="p">,</span> <span class="o">*</span><span class="n">masksz</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
<span></span>    <span class="k">elif</span> <span class="n">masks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span></span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span></span>            <span class="n">masks</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">masks</span><span class="p">)</span>  <span class="c1"># (N, H, W)</span>
<span></span>        <span class="n">masks</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">masks</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">masksz</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">"nearest"</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
<span></span>    <span class="k">else</span><span class="p">:</span>
<span></span>        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"LoadVisualPrompt must have bboxes or masks in the label"</span><span class="p">)</span>
<span></span>    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
<span></span>        <span class="n">category</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
<span></span>    <span class="n">cls_unique</span><span class="p">,</span> <span class="n">inverse_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span></span>    <span class="c1"># NOTE: `cls` indices from RandomLoadText should be continuous.</span>
<span></span>    <span class="c1"># if len(cls_unique):</span>
<span></span>    <span class="c1">#     assert len(cls_unique) == cls_unique[-1] + 1, (</span>
<span></span>    <span class="c1">#         f"Expected a continuous range of class indices, but got {cls_unique}"</span>
<span></span>    <span class="c1">#     )</span>
<span></span>    <span class="n">visuals</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">cls_unique</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">masksz</span><span class="p">)</span>
<span></span>    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inverse_indices</span><span class="p">,</span> <span class="n">masks</span><span class="p">):</span>
<span></span>        <span class="n">visuals</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">visuals</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">mask</span><span class="p">)</span>
<span></span>    <span class="k">return</span> <span class="n">visuals</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.LoadVisualPrompt.make_mask"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.LoadVisualPrompt.make_mask</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">make_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boxes</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span>
</code></pre></div><p>Create binary masks from bounding boxes.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>boxes</code></td><td><code>torch.Tensor</code></td><td>Bounding boxes in xyxy format, shape: (N, 4).</td><td><em>required</em></td></tr><tr><td><code>h</code></td><td><code>int</code></td><td>Height of the mask.</td><td><em>required</em></td></tr><tr><td><code>w</code></td><td><code>int</code></td><td>Width of the mask.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>torch.Tensor</code></td><td>Binary masks with shape (N, h, w).</td></tr></tbody></table><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L2167-L2182"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">make_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boxes</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span></span><span class="w">    </span><span class="sd">"""Create binary masks from bounding boxes.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        boxes (torch.Tensor): Bounding boxes in xyxy format, shape: (N, 4).</span>
<span></span><span class="sd">        h (int): Height of the mask.</span>
<span></span><span class="sd">        w (int): Width of the mask.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (torch.Tensor): Binary masks with shape (N, h, w).</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="n">boxes</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">],</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># x1 shape(n,1,1)</span>
<span></span>    <span class="n">r</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">w</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># rows shape(1,1,w)</span>
<span></span>    <span class="n">c</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">h</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span>  <span class="c1"># cols shape(1,h,1)</span>
<span></span>
<span></span>    <span class="k">return</span> <span class="p">(</span><span class="n">r</span> <span class="o">&gt;=</span> <span class="n">x1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">x2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="n">y1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">y2</span><span class="p">)</span>
</code></pre></div></details><p><br/><br/><hr/><br/></p><h2 id="ultralytics.data.augment.RandomLoadText"><span class="doc-kind doc-kind-class">class</span> <code>ultralytics.data.augment.RandomLoadText</code></h2><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
<span></span>    <span class="bp">self</span><span class="p">,</span>
<span></span>    <span class="n">prompt_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">"</span><span class="si">{}</span><span class="s2">"</span><span class="p">,</span>
<span></span>    <span class="n">neg_samples</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">80</span><span class="p">,</span> <span class="mi">80</span><span class="p">),</span>
<span></span>    <span class="n">max_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span>
<span></span>    <span class="n">padding</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span></span>    <span class="n">padding_value</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">""</span><span class="p">],</span>
<span></span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div><p>Randomly sample positive and negative texts and update class indices accordingly.</p><p>This class is responsible for sampling texts from a given set of class texts, including both positive (present in the image) and negative (not present in the image) samples. It updates the class indices to reflect the sampled texts and can optionally pad the text list to a fixed length.</p><p>This class is designed to randomly sample positive texts and negative texts, and update the class indices accordingly to the number of samples. It can be used for text-based object detection tasks.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>prompt_format</code></td><td><code>str</code></td><td>Format string for the prompt. The format string should contain a single pair of curly braces {} where the text will be inserted.</td><td><code>"{}"</code></td></tr><tr><td><code>neg_samples</code></td><td><code>tuple[int, int]</code></td><td>A range to randomly sample negative texts. The first integer specifies the minimum number of negative samples, and the second integer specifies the maximum.</td><td><code>(80, 80)</code></td></tr><tr><td><code>max_samples</code></td><td><code>int</code></td><td>The maximum number of different text samples in one image.</td><td><code>80</code></td></tr><tr><td><code>padding</code></td><td><code>bool</code></td><td>Whether to pad texts to max_samples. If True, the number of texts will always be equal to max_samples.</td><td><code>False</code></td></tr><tr><td><code>padding_value</code></td><td><code>str</code></td><td>The padding text to use when padding is True.</td><td><code>[""]</code></td></tr></tbody></table><p><strong>Attributes</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>prompt_format</code></td><td><code>str</code></td><td>Format string for text prompts.</td></tr><tr><td><code>neg_samples</code></td><td><code>tuple[int, int]</code></td><td>Range for randomly sampling negative texts.</td></tr><tr><td><code>max_samples</code></td><td><code>int</code></td><td>Maximum number of different text samples in one image.</td></tr><tr><td><code>padding</code></td><td><code>bool</code></td><td>Whether to pad texts to max_samples.</td></tr><tr><td><code>padding_value</code></td><td><code>str</code></td><td>The text used for padding when padding is True.</td></tr></tbody></table><p><strong>Methods</strong></p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="#ultralytics.data.augment.RandomLoadText.__call__"><code>__call__</code></a></td><td>Randomly sample positive and negative texts and update class indices accordingly.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">loader</span> <span class="o">=</span> <span class="n">RandomLoadText</span><span class="p">(</span><span class="n">prompt_format</span><span class="o">=</span><span class="s2">"Object: </span><span class="si">{}</span><span class="s2">"</span><span class="p">,</span> <span class="n">neg_samples</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">max_samples</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">labels</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"cls"</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s2">"texts"</span><span class="p">:</span> <span class="p">[[</span><span class="s2">"cat"</span><span class="p">],</span> <span class="p">[</span><span class="s2">"dog"</span><span class="p">],</span> <span class="p">[</span><span class="s2">"bird"</span><span class="p">]],</span> <span class="s2">"instances"</span><span class="p">:</span> <span class="p">[</span><span class="o">...</span><span class="p">]}</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">updated_labels</span> <span class="o">=</span> <span class="n">loader</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">updated_labels</span><span class="p">[</span><span class="s2">"texts"</span><span class="p">])</span>
<span></span><span class="p">[</span><span class="s1">'Object: cat'</span><span class="p">,</span> <span class="s1">'Object: dog'</span><span class="p">,</span> <span class="s1">'Object: bird'</span><span class="p">,</span> <span class="s1">'Object: elephant'</span><span class="p">,</span> <span class="s1">'Object: car'</span><span class="p">]</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L2251-L2368"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">class</span><span class="w"> </span><span class="nc">RandomLoadText</span><span class="p">:</span>
<span></span><span class="w">    </span><span class="sd">"""Randomly sample positive and negative texts and update class indices accordingly.</span>
<span></span>
<span></span><span class="sd">    This class is responsible for sampling texts from a given set of class texts, including both positive (present in</span>
<span></span><span class="sd">    the image) and negative (not present in the image) samples. It updates the class indices to reflect the sampled</span>
<span></span><span class="sd">    texts and can optionally pad the text list to a fixed length.</span>
<span></span>
<span></span><span class="sd">    Attributes:</span>
<span></span><span class="sd">        prompt_format (str): Format string for text prompts.</span>
<span></span><span class="sd">        neg_samples (tuple[int, int]): Range for randomly sampling negative texts.</span>
<span></span><span class="sd">        max_samples (int): Maximum number of different text samples in one image.</span>
<span></span><span class="sd">        padding (bool): Whether to pad texts to max_samples.</span>
<span></span><span class="sd">        padding_value (str): The text used for padding when padding is True.</span>
<span></span>
<span></span><span class="sd">    Methods:</span>
<span></span><span class="sd">        __call__: Process the input labels and return updated classes and texts.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; loader = RandomLoadText(prompt_format="Object: {}", neg_samples=(5, 10), max_samples=20)</span>
<span></span><span class="sd">        &gt;&gt;&gt; labels = {"cls": [0, 1, 2], "texts": [["cat"], ["dog"], ["bird"]], "instances": [...]}</span>
<span></span><span class="sd">        &gt;&gt;&gt; updated_labels = loader(labels)</span>
<span></span><span class="sd">        &gt;&gt;&gt; print(updated_labels["texts"])</span>
<span></span><span class="sd">        ['Object: cat', 'Object: dog', 'Object: bird', 'Object: elephant', 'Object: car']</span>
<span></span><span class="sd">    """</span>
<span></span>
<span></span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
<span></span>        <span class="bp">self</span><span class="p">,</span>
<span></span>        <span class="n">prompt_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">"</span><span class="si">{}</span><span class="s2">"</span><span class="p">,</span>
<span></span>        <span class="n">neg_samples</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">80</span><span class="p">,</span> <span class="mi">80</span><span class="p">),</span>
<span></span>        <span class="n">max_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span>
<span></span>        <span class="n">padding</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span></span>        <span class="n">padding_value</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">""</span><span class="p">],</span>
<span></span>    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span></span><span class="w">        </span><span class="sd">"""Initialize the RandomLoadText class for randomly sampling positive and negative texts.</span>
<span></span>
<span></span><span class="sd">        This class is designed to randomly sample positive texts and negative texts, and update the class indices</span>
<span></span><span class="sd">        accordingly to the number of samples. It can be used for text-based object detection tasks.</span>
<span></span>
<span></span><span class="sd">        Args:</span>
<span></span><span class="sd">            prompt_format (str): Format string for the prompt. The format string should contain a single pair of curly</span>
<span></span><span class="sd">                braces {} where the text will be inserted.</span>
<span></span><span class="sd">            neg_samples (tuple[int, int]): A range to randomly sample negative texts. The first integer specifies the</span>
<span></span><span class="sd">                minimum number of negative samples, and the second integer specifies the maximum.</span>
<span></span><span class="sd">            max_samples (int): The maximum number of different text samples in one image.</span>
<span></span><span class="sd">            padding (bool): Whether to pad texts to max_samples. If True, the number of texts will always be equal to</span>
<span></span><span class="sd">                max_samples.</span>
<span></span><span class="sd">            padding_value (str): The padding text to use when padding is True.</span>
<span></span><span class="sd">        """</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">prompt_format</span> <span class="o">=</span> <span class="n">prompt_format</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">neg_samples</span> <span class="o">=</span> <span class="n">neg_samples</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">max_samples</span> <span class="o">=</span> <span class="n">max_samples</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">padding</span> <span class="o">=</span> <span class="n">padding</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">padding_value</span> <span class="o">=</span> <span class="n">padding_value</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.RandomLoadText.__call__"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.RandomLoadText.__call__</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
</code></pre></div><p>Randomly sample positive and negative texts and update class indices accordingly.</p><p>This method samples positive texts based on the existing class labels in the image, and randomly selects negative texts from the remaining classes. It then updates the class indices to match the new sampled text order.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>labels</code></td><td><code>dict[str, Any]</code></td><td>A dictionary containing image labels and metadata. Must include 'texts' and 'cls' keys.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>dict[str, Any]</code></td><td>Updated labels dictionary with new 'cls' and 'texts' entries.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">loader</span> <span class="o">=</span> <span class="n">RandomLoadText</span><span class="p">(</span><span class="n">prompt_format</span><span class="o">=</span><span class="s2">"A photo of </span><span class="si">{}</span><span class="s2">"</span><span class="p">,</span> <span class="n">neg_samples</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">max_samples</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">labels</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"cls"</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]]),</span> <span class="s2">"texts"</span><span class="p">:</span> <span class="p">[[</span><span class="s2">"dog"</span><span class="p">],</span> <span class="p">[</span><span class="s2">"cat"</span><span class="p">],</span> <span class="p">[</span><span class="s2">"bird"</span><span class="p">]]}</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">updated_labels</span> <span class="o">=</span> <span class="n">loader</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L2305-L2368"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span></span><span class="w">    </span><span class="sd">"""Randomly sample positive and negative texts and update class indices accordingly.</span>
<span></span>
<span></span><span class="sd">    This method samples positive texts based on the existing class labels in the image, and randomly selects</span>
<span></span><span class="sd">    negative texts from the remaining classes. It then updates the class indices to match the new sampled text</span>
<span></span><span class="sd">    order.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        labels (dict[str, Any]): A dictionary containing image labels and metadata. Must include 'texts' and 'cls'</span>
<span></span><span class="sd">            keys.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (dict[str, Any]): Updated labels dictionary with new 'cls' and 'texts' entries.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; loader = RandomLoadText(prompt_format="A photo of {}", neg_samples=(5, 10), max_samples=20)</span>
<span></span><span class="sd">        &gt;&gt;&gt; labels = {"cls": np.array([[0], [1], [2]]), "texts": [["dog"], ["cat"], ["bird"]]}</span>
<span></span><span class="sd">        &gt;&gt;&gt; updated_labels = loader(labels)</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="k">assert</span> <span class="s2">"texts"</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">,</span> <span class="s2">"No texts found in labels."</span>
<span></span>    <span class="n">class_texts</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="s2">"texts"</span><span class="p">]</span>
<span></span>    <span class="n">num_classes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">class_texts</span><span class="p">)</span>
<span></span>    <span class="bp">cls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"cls"</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span></span>    <span class="n">pos_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span></span>
<span></span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_labels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_samples</span><span class="p">:</span>
<span></span>        <span class="n">pos_labels</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">pos_labels</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_samples</span><span class="p">)</span>
<span></span>
<span></span>    <span class="n">neg_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">num_classes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_samples</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_labels</span><span class="p">),</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">neg_samples</span><span class="p">))</span>
<span></span>    <span class="n">neg_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_classes</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pos_labels</span><span class="p">]</span>
<span></span>    <span class="n">neg_labels</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">neg_labels</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">neg_samples</span><span class="p">)</span>
<span></span>
<span></span>    <span class="n">sampled_labels</span> <span class="o">=</span> <span class="n">pos_labels</span> <span class="o">+</span> <span class="n">neg_labels</span>
<span></span>    <span class="c1"># Randomness</span>
<span></span>    <span class="c1"># random.shuffle(sampled_labels)</span>
<span></span>
<span></span>    <span class="n">label2ids</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sampled_labels</span><span class="p">)}</span>
<span></span>    <span class="n">valid_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span></span>    <span class="n">new_cls</span> <span class="o">=</span> <span class="p">[]</span>
<span></span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()):</span>
<span></span>        <span class="k">if</span> <span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">label2ids</span><span class="p">:</span>
<span></span>            <span class="k">continue</span>
<span></span>        <span class="n">valid_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span></span>        <span class="n">new_cls</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">label2ids</span><span class="p">[</span><span class="n">label</span><span class="p">]])</span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">]</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="s2">"instances"</span><span class="p">][</span><span class="n">valid_idx</span><span class="p">]</span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"cls"</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_cls</span><span class="p">)</span>
<span></span>
<span></span>    <span class="c1"># Randomly select one prompt when there's more than one prompts</span>
<span></span>    <span class="n">texts</span> <span class="o">=</span> <span class="p">[]</span>
<span></span>    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">sampled_labels</span><span class="p">:</span>
<span></span>        <span class="n">prompts</span> <span class="o">=</span> <span class="n">class_texts</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
<span></span>        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">prompts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span></span>        <span class="n">prompt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prompt_format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prompts</span><span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">prompts</span><span class="p">))])</span>
<span></span>        <span class="n">texts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span>
<span></span>
<span></span>    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding</span><span class="p">:</span>
<span></span>        <span class="n">valid_labels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_labels</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">neg_labels</span><span class="p">)</span>
<span></span>        <span class="n">num_padding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_samples</span> <span class="o">-</span> <span class="n">valid_labels</span>
<span></span>        <span class="k">if</span> <span class="n">num_padding</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span></span>            <span class="n">texts</span> <span class="o">+=</span> <span class="n">random</span><span class="o">.</span><span class="n">choices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">padding_value</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">num_padding</span><span class="p">)</span>
<span></span>
<span></span>    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">texts</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_samples</span>
<span></span>    <span class="n">labels</span><span class="p">[</span><span class="s2">"texts"</span><span class="p">]</span> <span class="o">=</span> <span class="n">texts</span>
<span></span>    <span class="k">return</span> <span class="n">labels</span>
</code></pre></div></details><p><br/><br/><hr/><br/></p><h2 id="ultralytics.data.augment.ClassifyLetterBox"><span class="doc-kind doc-kind-class">class</span> <code>ultralytics.data.augment.ClassifyLetterBox</code></h2><div class="highlight"><pre><span></span><code><span></span><span class="n">ClassifyLetterBox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">),</span> <span class="n">auto</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">stride</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">32</span><span class="p">)</span>
</code></pre></div><p>A class for resizing and padding images for classification tasks.</p><p>This class is designed to be part of a transformation pipeline, e.g., T.Compose([LetterBox(size), ToTensor()]). It resizes and pads images to a specified size while maintaining the original aspect ratio.</p><p>This class is designed to be part of a transformation pipeline for image classification tasks. It resizes and pads images to a specified size while maintaining the original aspect ratio.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>size</code></td><td><code>int | tuple[int, int]</code></td><td>Target size for the letterboxed image. If an int, a square image of (size, size) is created. If a tuple, it should be (height, width).</td><td><code>(640, 640)</code></td></tr><tr><td><code>auto</code></td><td><code>bool</code></td><td>If True, automatically calculates the short side based on stride.</td><td><code>False</code></td></tr><tr><td><code>stride</code></td><td><code>int</code></td><td>The stride value, used when 'auto' is True.</td><td><code>32</code></td></tr></tbody></table><p><strong>Attributes</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>h</code></td><td><code>int</code></td><td>Target height of the image.</td></tr><tr><td><code>w</code></td><td><code>int</code></td><td>Target width of the image.</td></tr><tr><td><code>auto</code></td><td><code>bool</code></td><td>If True, automatically calculates the short side using stride.</td></tr><tr><td><code>stride</code></td><td><code>int</code></td><td>The stride value, used when 'auto' is True.</td></tr></tbody></table><p><strong>Methods</strong></p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="#ultralytics.data.augment.ClassifyLetterBox.__call__"><code>__call__</code></a></td><td>Resize and pad an image using the letterbox method.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">ClassifyLetterBox</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">),</span> <span class="n">auto</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">32</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="p">(</span><span class="mi">480</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span></span><span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L2599-L2670"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">class</span><span class="w"> </span><span class="nc">ClassifyLetterBox</span><span class="p">:</span>
<span></span><span class="w">    </span><span class="sd">"""A class for resizing and padding images for classification tasks.</span>
<span></span>
<span></span><span class="sd">    This class is designed to be part of a transformation pipeline, e.g., T.Compose([LetterBox(size), ToTensor()]). It</span>
<span></span><span class="sd">    resizes and pads images to a specified size while maintaining the original aspect ratio.</span>
<span></span>
<span></span><span class="sd">    Attributes:</span>
<span></span><span class="sd">        h (int): Target height of the image.</span>
<span></span><span class="sd">        w (int): Target width of the image.</span>
<span></span><span class="sd">        auto (bool): If True, automatically calculates the short side using stride.</span>
<span></span><span class="sd">        stride (int): The stride value, used when 'auto' is True.</span>
<span></span>
<span></span><span class="sd">    Methods:</span>
<span></span><span class="sd">        __call__: Apply the letterbox transformation to an input image.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; transform = ClassifyLetterBox(size=(640, 640), auto=False, stride=32)</span>
<span></span><span class="sd">        &gt;&gt;&gt; img = np.random.randint(0, 255, (480, 640, 3), dtype=np.uint8)</span>
<span></span><span class="sd">        &gt;&gt;&gt; result = transform(img)</span>
<span></span><span class="sd">        &gt;&gt;&gt; print(result.shape)</span>
<span></span><span class="sd">        (640, 640, 3)</span>
<span></span><span class="sd">    """</span>
<span></span>
<span></span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">),</span> <span class="n">auto</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">stride</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">32</span><span class="p">):</span>
<span></span><span class="w">        </span><span class="sd">"""Initialize the ClassifyLetterBox object for image preprocessing.</span>
<span></span>
<span></span><span class="sd">        This class is designed to be part of a transformation pipeline for image classification tasks. It resizes and</span>
<span></span><span class="sd">        pads images to a specified size while maintaining the original aspect ratio.</span>
<span></span>
<span></span><span class="sd">        Args:</span>
<span></span><span class="sd">            size (int | tuple[int, int]): Target size for the letterboxed image. If an int, a square image of (size,</span>
<span></span><span class="sd">                size) is created. If a tuple, it should be (height, width).</span>
<span></span><span class="sd">            auto (bool): If True, automatically calculates the short side based on stride.</span>
<span></span><span class="sd">            stride (int): The stride value, used when 'auto' is True.</span>
<span></span><span class="sd">        """</span>
<span></span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">else</span> <span class="n">size</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">auto</span> <span class="o">=</span> <span class="n">auto</span>  <span class="c1"># pass max size integer, automatically solve for short side using stride</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">stride</span> <span class="o">=</span> <span class="n">stride</span>  <span class="c1"># used with auto</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.ClassifyLetterBox.__call__"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.ClassifyLetterBox.__call__</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
</code></pre></div><p>Resize and pad an image using the letterbox method.</p><p>This method resizes the input image to fit within the specified dimensions while maintaining its aspect ratio, then pads the resized image to match the target size.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>im</code></td><td><code>np.ndarray</code></td><td>Input image as a numpy array with shape (H, W, C).</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>np.ndarray</code></td><td>Resized and padded image as a numpy array with shape (hs, ws, 3), where hs and ws are the</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">letterbox</span> <span class="o">=</span> <span class="n">ClassifyLetterBox</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">))</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="p">(</span><span class="mi">720</span><span class="p">,</span> <span class="mi">1280</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">resized_image</span> <span class="o">=</span> <span class="n">letterbox</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">resized_image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span></span><span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L2639-L2670"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span></span><span class="w">    </span><span class="sd">"""Resize and pad an image using the letterbox method.</span>
<span></span>
<span></span><span class="sd">    This method resizes the input image to fit within the specified dimensions while maintaining its aspect ratio,</span>
<span></span><span class="sd">    then pads the resized image to match the target size.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        im (np.ndarray): Input image as a numpy array with shape (H, W, C).</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (np.ndarray): Resized and padded image as a numpy array with shape (hs, ws, 3), where hs and ws are the</span>
<span></span><span class="sd">            target height and width respectively.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; letterbox = ClassifyLetterBox(size=(640, 640))</span>
<span></span><span class="sd">        &gt;&gt;&gt; image = np.random.randint(0, 255, (720, 1280, 3), dtype=np.uint8)</span>
<span></span><span class="sd">        &gt;&gt;&gt; resized_image = letterbox(image)</span>
<span></span><span class="sd">        &gt;&gt;&gt; print(resized_image.shape)</span>
<span></span><span class="sd">        (640, 640, 3)</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="n">imh</span><span class="p">,</span> <span class="n">imw</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
<span></span>    <span class="n">r</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">/</span> <span class="n">imh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">/</span> <span class="n">imw</span><span class="p">)</span>  <span class="c1"># ratio of new/old dimensions</span>
<span></span>    <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">imh</span> <span class="o">*</span> <span class="n">r</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">imw</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span>  <span class="c1"># resized image dimensions</span>
<span></span>
<span></span>    <span class="c1"># Calculate padding dimensions</span>
<span></span>    <span class="n">hs</span><span class="p">,</span> <span class="n">ws</span> <span class="o">=</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">auto</span> <span class="k">else</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">)</span>
<span></span>    <span class="n">top</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">hs</span> <span class="o">-</span> <span class="n">h</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">0.1</span><span class="p">),</span> <span class="nb">round</span><span class="p">((</span><span class="n">ws</span> <span class="o">-</span> <span class="n">w</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">0.1</span><span class="p">)</span>
<span></span>
<span></span>    <span class="c1"># Create padded image</span>
<span></span>    <span class="n">im_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">hs</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="mi">114</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">im</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span></span>    <span class="n">im_out</span><span class="p">[</span><span class="n">top</span> <span class="p">:</span> <span class="n">top</span> <span class="o">+</span> <span class="n">h</span><span class="p">,</span> <span class="n">left</span> <span class="p">:</span> <span class="n">left</span> <span class="o">+</span> <span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">INTER_LINEAR</span><span class="p">)</span>
<span></span>    <span class="k">return</span> <span class="n">im_out</span>
</code></pre></div></details><p><br/><br/><hr/><br/></p><h2 id="ultralytics.data.augment.CenterCrop"><span class="doc-kind doc-kind-class">class</span> <code>ultralytics.data.augment.CenterCrop</code></h2><div class="highlight"><pre><span></span><code><span></span><span class="n">CenterCrop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">))</span>
</code></pre></div><p>Apply center cropping to images for classification tasks.</p><p>This class performs center cropping on input images, resizing them to a specified size while maintaining the aspect ratio. It is designed to be part of a transformation pipeline, e.g., T.Compose([CenterCrop(size), ToTensor()]).</p><p>This class is designed to be part of a transformation pipeline, e.g., T.Compose([CenterCrop(size), ToTensor()]). It performs a center crop on input images to a specified size.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>size</code></td><td><code>int | tuple[int, int]</code></td><td>The desired output size of the crop. If size is an int, a square crop (size, size) is made. If size is a sequence like (h, w), it is used as the output size.</td><td><code>(640, 640)</code></td></tr></tbody></table><p><strong>Attributes</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>h</code></td><td><code>int</code></td><td>Target height of the cropped image.</td></tr><tr><td><code>w</code></td><td><code>int</code></td><td>Target width of the cropped image.</td></tr></tbody></table><p><strong>Methods</strong></p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="#ultralytics.data.augment.CenterCrop.__call__"><code>__call__</code></a></td><td>Apply center cropping to an input image.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">CenterCrop</span><span class="p">(</span><span class="mi">640</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="p">(</span><span class="mi">1080</span><span class="p">,</span> <span class="mi">1920</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">cropped_image</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">cropped_image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span></span><span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>None</code></td><td>This method initializes the object and does not return anything.</td></tr></tbody></table><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L2674-L2735"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">class</span><span class="w"> </span><span class="nc">CenterCrop</span><span class="p">:</span>
<span></span><span class="w">    </span><span class="sd">"""Apply center cropping to images for classification tasks.</span>
<span></span>
<span></span><span class="sd">    This class performs center cropping on input images, resizing them to a specified size while maintaining the aspect</span>
<span></span><span class="sd">    ratio. It is designed to be part of a transformation pipeline, e.g., T.Compose([CenterCrop(size), ToTensor()]).</span>
<span></span>
<span></span><span class="sd">    Attributes:</span>
<span></span><span class="sd">        h (int): Target height of the cropped image.</span>
<span></span><span class="sd">        w (int): Target width of the cropped image.</span>
<span></span>
<span></span><span class="sd">    Methods:</span>
<span></span><span class="sd">        __call__: Apply the center crop transformation to an input image.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; transform = CenterCrop(640)</span>
<span></span><span class="sd">        &gt;&gt;&gt; image = np.random.randint(0, 255, (1080, 1920, 3), dtype=np.uint8)</span>
<span></span><span class="sd">        &gt;&gt;&gt; cropped_image = transform(image)</span>
<span></span><span class="sd">        &gt;&gt;&gt; print(cropped_image.shape)</span>
<span></span><span class="sd">        (640, 640, 3)</span>
<span></span><span class="sd">    """</span>
<span></span>
<span></span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">)):</span>
<span></span><span class="w">        </span><span class="sd">"""Initialize the CenterCrop object for image preprocessing.</span>
<span></span>
<span></span><span class="sd">        This class is designed to be part of a transformation pipeline, e.g., T.Compose([CenterCrop(size), ToTensor()]).</span>
<span></span><span class="sd">        It performs a center crop on input images to a specified size.</span>
<span></span>
<span></span><span class="sd">        Args:</span>
<span></span><span class="sd">            size (int | tuple[int, int]): The desired output size of the crop. If size is an int, a square crop (size,</span>
<span></span><span class="sd">                size) is made. If size is a sequence like (h, w), it is used as the output size.</span>
<span></span>
<span></span><span class="sd">        Returns:</span>
<span></span><span class="sd">            (None): This method initializes the object and does not return anything.</span>
<span></span><span class="sd">        """</span>
<span></span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">else</span> <span class="n">size</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.CenterCrop.__call__"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.CenterCrop.__call__</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im</span><span class="p">:</span> <span class="n">Image</span><span class="o">.</span><span class="n">Image</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
</code></pre></div><p>Apply center cropping to an input image.</p><p>This method resizes and crops the center of the image using a letterbox method. It maintains the aspect ratio of the original image while fitting it into the specified dimensions.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>im</code></td><td><code>np.ndarray | PIL.Image.Image</code></td><td>The input image as a numpy array of shape (H, W, C) or a PIL Image object.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>np.ndarray</code></td><td>The center-cropped and resized image as a numpy array of shape (self.h, self.w, C).</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">CenterCrop</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">224</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">cropped_image</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="k">assert</span> <span class="n">cropped_image</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L2711-L2735"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im</span><span class="p">:</span> <span class="n">Image</span><span class="o">.</span><span class="n">Image</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span></span><span class="w">    </span><span class="sd">"""Apply center cropping to an input image.</span>
<span></span>
<span></span><span class="sd">    This method resizes and crops the center of the image using a letterbox method. It maintains the aspect ratio of</span>
<span></span><span class="sd">    the original image while fitting it into the specified dimensions.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        im (np.ndarray | PIL.Image.Image): The input image as a numpy array of shape (H, W, C) or a PIL Image</span>
<span></span><span class="sd">            object.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (np.ndarray): The center-cropped and resized image as a numpy array of shape (self.h, self.w, C).</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; transform = CenterCrop(size=224)</span>
<span></span><span class="sd">        &gt;&gt;&gt; image = np.random.randint(0, 255, (640, 480, 3), dtype=np.uint8)</span>
<span></span><span class="sd">        &gt;&gt;&gt; cropped_image = transform(image)</span>
<span></span><span class="sd">        &gt;&gt;&gt; assert cropped_image.shape == (224, 224, 3)</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">Image</span><span class="o">.</span><span class="n">Image</span><span class="p">):</span>  <span class="c1"># convert from PIL to numpy array if required</span>
<span></span>        <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
<span></span>    <span class="n">imh</span><span class="p">,</span> <span class="n">imw</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
<span></span>    <span class="n">m</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">imh</span><span class="p">,</span> <span class="n">imw</span><span class="p">)</span>  <span class="c1"># min dimension</span>
<span></span>    <span class="n">top</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="p">(</span><span class="n">imh</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">imw</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
<span></span>    <span class="k">return</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">im</span><span class="p">[</span><span class="n">top</span> <span class="p">:</span> <span class="n">top</span> <span class="o">+</span> <span class="n">m</span><span class="p">,</span> <span class="n">left</span> <span class="p">:</span> <span class="n">left</span> <span class="o">+</span> <span class="n">m</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">),</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">INTER_LINEAR</span><span class="p">)</span>
</code></pre></div></details><p><br/><br/><hr/><br/></p><h2 id="ultralytics.data.augment.ToTensor"><span class="doc-kind doc-kind-class">class</span> <code>ultralytics.data.augment.ToTensor</code></h2><div class="highlight"><pre><span></span><code><span></span><span class="n">ToTensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">half</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
</code></pre></div><p>Convert an image from a numpy array to a PyTorch tensor.</p><p>This class is designed to be part of a transformation pipeline, e.g., T.Compose([LetterBox(size), ToTensor()]).</p><p>This class is designed to be used as part of a transformation pipeline for image preprocessing in the Ultralytics YOLO framework. It converts numpy arrays or PIL Images to PyTorch tensors, with an option for half-precision (float16) conversion.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>half</code></td><td><code>bool</code></td><td>If True, converts the tensor to half precision (float16).</td><td><code>False</code></td></tr></tbody></table><p><strong>Attributes</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>half</code></td><td><code>bool</code></td><td>If True, converts the image to half precision (float16).</td></tr></tbody></table><p><strong>Methods</strong></p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="#ultralytics.data.augment.ToTensor.__call__"><code>__call__</code></a></td><td>Transform an image from a numpy array to a PyTorch tensor.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">ToTensor</span><span class="p">(</span><span class="n">half</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">tensor_img</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">tensor_img</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">tensor_img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span></span><span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">])</span> <span class="n">torch</span><span class="o">.</span><span class="n">float16</span>
</code></pre></div><div class="admonition note"><p class="admonition-title">Notes</p><p>The input image is expected to be in BGR format with shape (H, W, C).
The output tensor will be in RGB format with shape (C, H, W), normalized to [0, 1].</p></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L2739-L2800"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">class</span><span class="w"> </span><span class="nc">ToTensor</span><span class="p">:</span>
<span></span><span class="w">    </span><span class="sd">"""Convert an image from a numpy array to a PyTorch tensor.</span>
<span></span>
<span></span><span class="sd">    This class is designed to be part of a transformation pipeline, e.g., T.Compose([LetterBox(size), ToTensor()]).</span>
<span></span>
<span></span><span class="sd">    Attributes:</span>
<span></span><span class="sd">        half (bool): If True, converts the image to half precision (float16).</span>
<span></span>
<span></span><span class="sd">    Methods:</span>
<span></span><span class="sd">        __call__: Apply the tensor conversion to an input image.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; transform = ToTensor(half=True)</span>
<span></span><span class="sd">        &gt;&gt;&gt; img = np.random.randint(0, 255, (640, 640, 3), dtype=np.uint8)</span>
<span></span><span class="sd">        &gt;&gt;&gt; tensor_img = transform(img)</span>
<span></span><span class="sd">        &gt;&gt;&gt; print(tensor_img.shape, tensor_img.dtype)</span>
<span></span><span class="sd">        torch.Size([3, 640, 640]) torch.float16</span>
<span></span>
<span></span><span class="sd">    Notes:</span>
<span></span><span class="sd">        The input image is expected to be in BGR format with shape (H, W, C).</span>
<span></span><span class="sd">        The output tensor will be in RGB format with shape (C, H, W), normalized to [0, 1].</span>
<span></span><span class="sd">    """</span>
<span></span>
<span></span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">half</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span></span><span class="w">        </span><span class="sd">"""Initialize the ToTensor object for converting images to PyTorch tensors.</span>
<span></span>
<span></span><span class="sd">        This class is designed to be used as part of a transformation pipeline for image preprocessing in the</span>
<span></span><span class="sd">        Ultralytics YOLO framework. It converts numpy arrays or PIL Images to PyTorch tensors, with an option for</span>
<span></span><span class="sd">        half-precision (float16) conversion.</span>
<span></span>
<span></span><span class="sd">        Args:</span>
<span></span><span class="sd">            half (bool): If True, converts the tensor to half precision (float16).</span>
<span></span><span class="sd">        """</span>
<span></span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
<span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">half</span> <span class="o">=</span> <span class="n">half</span>
</code></pre></div></details><p><br/></p><h3 id="ultralytics.data.augment.ToTensor.__call__"><span class="doc-kind doc-kind-method">method</span> <code>ultralytics.data.augment.ToTensor.__call__</code></h3><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span>
</code></pre></div><p>Transform an image from a numpy array to a PyTorch tensor.</p><p>This method converts the input image from a numpy array to a PyTorch tensor, applying optional half-precision conversion and normalization. The image is transposed from HWC to CHW format and the color channels are reversed from BGR to RGB.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>im</code></td><td><code>np.ndarray</code></td><td>Input image as a numpy array with shape (H, W, C) in RGB order.</td><td><em>required</em></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>torch.Tensor</code></td><td>The transformed image as a PyTorch tensor in float32 or float16, normalized to [0, 1] with</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">ToTensor</span><span class="p">(</span><span class="n">half</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">tensor_img</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">tensor_img</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">tensor_img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span></span><span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">640</span><span class="p">])</span> <span class="n">torch</span><span class="o">.</span><span class="n">float16</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L2775-L2800"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span></span><span class="w">    </span><span class="sd">"""Transform an image from a numpy array to a PyTorch tensor.</span>
<span></span>
<span></span><span class="sd">    This method converts the input image from a numpy array to a PyTorch tensor, applying optional half-precision</span>
<span></span><span class="sd">    conversion and normalization. The image is transposed from HWC to CHW format and the color channels are reversed</span>
<span></span><span class="sd">    from BGR to RGB.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        im (np.ndarray): Input image as a numpy array with shape (H, W, C) in RGB order.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (torch.Tensor): The transformed image as a PyTorch tensor in float32 or float16, normalized to [0, 1] with</span>
<span></span><span class="sd">            shape (C, H, W) in RGB order.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; transform = ToTensor(half=True)</span>
<span></span><span class="sd">        &gt;&gt;&gt; img = np.random.randint(0, 255, (640, 640, 3), dtype=np.uint8)</span>
<span></span><span class="sd">        &gt;&gt;&gt; tensor_img = transform(img)</span>
<span></span><span class="sd">        &gt;&gt;&gt; print(tensor_img.shape, tensor_img.dtype)</span>
<span></span><span class="sd">        torch.Size([3, 640, 640]) torch.float16</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>  <span class="c1"># HWC to CHW -&gt; contiguous</span>
<span></span>    <span class="n">im</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>  <span class="c1"># to torch</span>
<span></span>    <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">half</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">half</span> <span class="k">else</span> <span class="n">im</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>  <span class="c1"># uint8 to fp16/32</span>
<span></span>    <span class="n">im</span> <span class="o">/=</span> <span class="mf">255.0</span>  <span class="c1"># 0-255 to 0.0-1.0</span>
<span></span>    <span class="k">return</span> <span class="n">im</span>
</code></pre></div></details><p><br/><br/><hr/><br/></p><h2 id="ultralytics.data.augment.v8_transforms"><span class="doc-kind doc-kind-function">function</span> <code>ultralytics.data.augment.v8_transforms</code></h2><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">v8_transforms</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">imgsz</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">hyp</span><span class="p">:</span> <span class="n">IterableSimpleNamespace</span><span class="p">,</span> <span class="n">stretch</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
</code></pre></div><p>Apply a series of image transformations for training.</p><p>This function creates a composition of image augmentation techniques to prepare images for YOLO training. It includes operations such as mosaic, copy-paste, random perspective, mixup, and various color adjustments.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>dataset</code></td><td><code>Dataset</code></td><td>The dataset object containing image data and annotations.</td><td><em>required</em></td></tr><tr><td><code>imgsz</code></td><td><code>int</code></td><td>The target image size for resizing.</td><td><em>required</em></td></tr><tr><td><code>hyp</code></td><td><code>IterableSimpleNamespace</code></td><td>A dictionary of hyperparameters controlling various aspects of the transformations.</td><td><em>required</em></td></tr><tr><td><code>stretch</code></td><td><code>bool</code></td><td>If True, applies stretching to the image. If False, uses LetterBox resizing.</td><td><code>False</code></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>Compose</code></td><td>A composition of image transformations to be applied to the dataset.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span><span class="w"> </span><span class="nn">ultralytics.data.dataset</span><span class="w"> </span><span class="kn">import</span> <span class="n">YOLODataset</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span><span class="w"> </span><span class="nn">ultralytics.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">IterableSimpleNamespace</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">dataset</span> <span class="o">=</span> <span class="n">YOLODataset</span><span class="p">(</span><span class="n">img_path</span><span class="o">=</span><span class="s2">"path/to/images"</span><span class="p">,</span> <span class="n">imgsz</span><span class="o">=</span><span class="mi">640</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">hyp</span> <span class="o">=</span> <span class="n">IterableSimpleNamespace</span><span class="p">(</span><span class="n">mosaic</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">copy_paste</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">translate</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transforms</span> <span class="o">=</span> <span class="n">v8_transforms</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">imgsz</span><span class="o">=</span><span class="mi">640</span><span class="p">,</span> <span class="n">hyp</span><span class="o">=</span><span class="n">hyp</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">augmented_data</span> <span class="o">=</span> <span class="n">transforms</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span></span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="c1"># With custom albumentations</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span><span class="w"> </span><span class="nn">albumentations</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">A</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">augmentations</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="o">.</span><span class="n">Blur</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.01</span><span class="p">),</span> <span class="n">A</span><span class="o">.</span><span class="n">CLAHE</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)]</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">hyp</span><span class="o">.</span><span class="n">augmentations</span> <span class="o">=</span> <span class="n">augmentations</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transforms</span> <span class="o">=</span> <span class="n">v8_transforms</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">imgsz</span><span class="o">=</span><span class="mi">640</span><span class="p">,</span> <span class="n">hyp</span><span class="o">=</span><span class="n">hyp</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L2371-L2442"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">v8_transforms</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">imgsz</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">hyp</span><span class="p">:</span> <span class="n">IterableSimpleNamespace</span><span class="p">,</span> <span class="n">stretch</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span></span><span class="w">    </span><span class="sd">"""Apply a series of image transformations for training.</span>
<span></span>
<span></span><span class="sd">    This function creates a composition of image augmentation techniques to prepare images for YOLO training. It</span>
<span></span><span class="sd">    includes operations such as mosaic, copy-paste, random perspective, mixup, and various color adjustments.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        dataset (Dataset): The dataset object containing image data and annotations.</span>
<span></span><span class="sd">        imgsz (int): The target image size for resizing.</span>
<span></span><span class="sd">        hyp (IterableSimpleNamespace): A dictionary of hyperparameters controlling various aspects of the</span>
<span></span><span class="sd">            transformations.</span>
<span></span><span class="sd">        stretch (bool): If True, applies stretching to the image. If False, uses LetterBox resizing.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (Compose): A composition of image transformations to be applied to the dataset.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; from ultralytics.data.dataset import YOLODataset</span>
<span></span><span class="sd">        &gt;&gt;&gt; from ultralytics.utils import IterableSimpleNamespace</span>
<span></span><span class="sd">        &gt;&gt;&gt; dataset = YOLODataset(img_path="path/to/images", imgsz=640)</span>
<span></span><span class="sd">        &gt;&gt;&gt; hyp = IterableSimpleNamespace(mosaic=1.0, copy_paste=0.5, degrees=10.0, translate=0.2, scale=0.9)</span>
<span></span><span class="sd">        &gt;&gt;&gt; transforms = v8_transforms(dataset, imgsz=640, hyp=hyp)</span>
<span></span><span class="sd">        &gt;&gt;&gt; augmented_data = transforms(dataset[0])</span>
<span></span>
<span></span><span class="sd">        &gt;&gt;&gt; # With custom albumentations</span>
<span></span><span class="sd">        &gt;&gt;&gt; import albumentations as A</span>
<span></span><span class="sd">        &gt;&gt;&gt; augmentations = [A.Blur(p=0.01), A.CLAHE(p=0.01)]</span>
<span></span><span class="sd">        &gt;&gt;&gt; hyp.augmentations = augmentations</span>
<span></span><span class="sd">        &gt;&gt;&gt; transforms = v8_transforms(dataset, imgsz=640, hyp=hyp)</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="n">mosaic</span> <span class="o">=</span> <span class="n">Mosaic</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">imgsz</span><span class="o">=</span><span class="n">imgsz</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">hyp</span><span class="o">.</span><span class="n">mosaic</span><span class="p">)</span>
<span></span>    <span class="n">affine</span> <span class="o">=</span> <span class="n">RandomPerspective</span><span class="p">(</span>
<span></span>        <span class="n">degrees</span><span class="o">=</span><span class="n">hyp</span><span class="o">.</span><span class="n">degrees</span><span class="p">,</span>
<span></span>        <span class="n">translate</span><span class="o">=</span><span class="n">hyp</span><span class="o">.</span><span class="n">translate</span><span class="p">,</span>
<span></span>        <span class="n">scale</span><span class="o">=</span><span class="n">hyp</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span>
<span></span>        <span class="n">shear</span><span class="o">=</span><span class="n">hyp</span><span class="o">.</span><span class="n">shear</span><span class="p">,</span>
<span></span>        <span class="n">perspective</span><span class="o">=</span><span class="n">hyp</span><span class="o">.</span><span class="n">perspective</span><span class="p">,</span>
<span></span>        <span class="n">pre_transform</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">stretch</span> <span class="k">else</span> <span class="n">LetterBox</span><span class="p">(</span><span class="n">new_shape</span><span class="o">=</span><span class="p">(</span><span class="n">imgsz</span><span class="p">,</span> <span class="n">imgsz</span><span class="p">)),</span>
<span></span>    <span class="p">)</span>
<span></span>
<span></span>    <span class="n">pre_transform</span> <span class="o">=</span> <span class="n">Compose</span><span class="p">([</span><span class="n">mosaic</span><span class="p">,</span> <span class="n">affine</span><span class="p">])</span>
<span></span>    <span class="k">if</span> <span class="n">hyp</span><span class="o">.</span><span class="n">copy_paste_mode</span> <span class="o">==</span> <span class="s2">"flip"</span><span class="p">:</span>
<span></span>        <span class="n">pre_transform</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">CopyPaste</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">hyp</span><span class="o">.</span><span class="n">copy_paste</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">hyp</span><span class="o">.</span><span class="n">copy_paste_mode</span><span class="p">))</span>
<span></span>    <span class="k">else</span><span class="p">:</span>
<span></span>        <span class="n">pre_transform</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
<span></span>            <span class="n">CopyPaste</span><span class="p">(</span>
<span></span>                <span class="n">dataset</span><span class="p">,</span>
<span></span>                <span class="n">pre_transform</span><span class="o">=</span><span class="n">Compose</span><span class="p">([</span><span class="n">Mosaic</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">imgsz</span><span class="o">=</span><span class="n">imgsz</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">hyp</span><span class="o">.</span><span class="n">mosaic</span><span class="p">),</span> <span class="n">affine</span><span class="p">]),</span>
<span></span>                <span class="n">p</span><span class="o">=</span><span class="n">hyp</span><span class="o">.</span><span class="n">copy_paste</span><span class="p">,</span>
<span></span>                <span class="n">mode</span><span class="o">=</span><span class="n">hyp</span><span class="o">.</span><span class="n">copy_paste_mode</span><span class="p">,</span>
<span></span>            <span class="p">)</span>
<span></span>        <span class="p">)</span>
<span></span>    <span class="n">flip_idx</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"flip_idx"</span><span class="p">,</span> <span class="p">[])</span>  <span class="c1"># for keypoints augmentation</span>
<span></span>    <span class="k">if</span> <span class="n">dataset</span><span class="o">.</span><span class="n">use_keypoints</span><span class="p">:</span>
<span></span>        <span class="n">kpt_shape</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"kpt_shape"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span></span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flip_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">hyp</span><span class="o">.</span><span class="n">fliplr</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">hyp</span><span class="o">.</span><span class="n">flipud</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">):</span>
<span></span>            <span class="n">hyp</span><span class="o">.</span><span class="n">fliplr</span> <span class="o">=</span> <span class="n">hyp</span><span class="o">.</span><span class="n">flipud</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># both fliplr and flipud require flip_idx</span>
<span></span>            <span class="n">LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">"No 'flip_idx' array defined in data.yaml, disabling 'fliplr' and 'flipud' augmentations."</span><span class="p">)</span>
<span></span>        <span class="k">elif</span> <span class="n">flip_idx</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flip_idx</span><span class="p">)</span> <span class="o">!=</span> <span class="n">kpt_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
<span></span>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"data.yaml flip_idx=</span><span class="si">{</span><span class="n">flip_idx</span><span class="si">}</span><span class="s2"> length must be equal to kpt_shape[0]=</span><span class="si">{</span><span class="n">kpt_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span></span>
<span></span>    <span class="k">return</span> <span class="n">Compose</span><span class="p">(</span>
<span></span>        <span class="p">[</span>
<span></span>            <span class="n">pre_transform</span><span class="p">,</span>
<span></span>            <span class="n">MixUp</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">pre_transform</span><span class="o">=</span><span class="n">pre_transform</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">hyp</span><span class="o">.</span><span class="n">mixup</span><span class="p">),</span>
<span></span>            <span class="n">CutMix</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">pre_transform</span><span class="o">=</span><span class="n">pre_transform</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">hyp</span><span class="o">.</span><span class="n">cutmix</span><span class="p">),</span>
<span></span>            <span class="n">Albumentations</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">transforms</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">hyp</span><span class="p">,</span> <span class="s2">"augmentations"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)),</span>
<span></span>            <span class="n">RandomHSV</span><span class="p">(</span><span class="n">hgain</span><span class="o">=</span><span class="n">hyp</span><span class="o">.</span><span class="n">hsv_h</span><span class="p">,</span> <span class="n">sgain</span><span class="o">=</span><span class="n">hyp</span><span class="o">.</span><span class="n">hsv_s</span><span class="p">,</span> <span class="n">vgain</span><span class="o">=</span><span class="n">hyp</span><span class="o">.</span><span class="n">hsv_v</span><span class="p">),</span>
<span></span>            <span class="n">RandomFlip</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="s2">"vertical"</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">hyp</span><span class="o">.</span><span class="n">flipud</span><span class="p">,</span> <span class="n">flip_idx</span><span class="o">=</span><span class="n">flip_idx</span><span class="p">),</span>
<span></span>            <span class="n">RandomFlip</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="s2">"horizontal"</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">hyp</span><span class="o">.</span><span class="n">fliplr</span><span class="p">,</span> <span class="n">flip_idx</span><span class="o">=</span><span class="n">flip_idx</span><span class="p">),</span>
<span></span>        <span class="p">]</span>
<span></span>    <span class="p">)</span>  <span class="c1"># transforms</span>
</code></pre></div></details><p><br/><br/><hr/><br/></p><h2 id="ultralytics.data.augment.classify_transforms"><span class="doc-kind doc-kind-function">function</span> <code>ultralytics.data.augment.classify_transforms</code></h2><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">classify_transforms</span><span class="p">(</span>
<span></span>    <span class="n">size</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">224</span><span class="p">,</span>
<span></span>    <span class="n">mean</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">DEFAULT_MEAN</span><span class="p">,</span>
<span></span>    <span class="n">std</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">DEFAULT_STD</span><span class="p">,</span>
<span></span>    <span class="n">interpolation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">"BILINEAR"</span><span class="p">,</span>
<span></span>    <span class="n">crop_fraction</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span></span><span class="p">)</span>
</code></pre></div><p>Create a composition of image transforms for classification tasks.</p><p>This function generates a sequence of torchvision transforms suitable for preprocessing images for classification models during evaluation or inference. The transforms include resizing, center cropping, conversion to tensor, and normalization.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>size</code></td><td><code>int | tuple</code></td><td>The target size for the transformed image. If an int, it defines the shortest edge. If a tuple, it defines (height, width).</td><td><code>224</code></td></tr><tr><td><code>mean</code></td><td><code>tuple[float, float, float]</code></td><td>Mean values for each RGB channel used in normalization.</td><td><code>DEFAULT_MEAN</code></td></tr><tr><td><code>std</code></td><td><code>tuple[float, float, float]</code></td><td>Standard deviation values for each RGB channel used in normalization.</td><td><code>DEFAULT_STD</code></td></tr><tr><td><code>interpolation</code></td><td><code>str</code></td><td>Interpolation method of either 'NEAREST', 'BILINEAR' or 'BICUBIC'.</td><td><code>"BILINEAR"</code></td></tr><tr><td><code>crop_fraction</code></td><td><code>float</code></td><td>Deprecated, will be removed in a future version.</td><td><code>None</code></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>torchvision.transforms.Compose</code></td><td>A composition of torchvision transforms.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transforms</span> <span class="o">=</span> <span class="n">classify_transforms</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">224</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">"path/to/image.jpg"</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transformed_img</span> <span class="o">=</span> <span class="n">transforms</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L2446-L2492"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">classify_transforms</span><span class="p">(</span>
<span></span>    <span class="n">size</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">224</span><span class="p">,</span>
<span></span>    <span class="n">mean</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">DEFAULT_MEAN</span><span class="p">,</span>
<span></span>    <span class="n">std</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">DEFAULT_STD</span><span class="p">,</span>
<span></span>    <span class="n">interpolation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">"BILINEAR"</span><span class="p">,</span>
<span></span>    <span class="n">crop_fraction</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span></span><span class="p">):</span>
<span></span><span class="w">    </span><span class="sd">"""Create a composition of image transforms for classification tasks.</span>
<span></span>
<span></span><span class="sd">    This function generates a sequence of torchvision transforms suitable for preprocessing images for classification</span>
<span></span><span class="sd">    models during evaluation or inference. The transforms include resizing, center cropping, conversion to tensor, and</span>
<span></span><span class="sd">    normalization.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        size (int | tuple): The target size for the transformed image. If an int, it defines the shortest edge. If a</span>
<span></span><span class="sd">            tuple, it defines (height, width).</span>
<span></span><span class="sd">        mean (tuple[float, float, float]): Mean values for each RGB channel used in normalization.</span>
<span></span><span class="sd">        std (tuple[float, float, float]): Standard deviation values for each RGB channel used in normalization.</span>
<span></span><span class="sd">        interpolation (str): Interpolation method of either 'NEAREST', 'BILINEAR' or 'BICUBIC'.</span>
<span></span><span class="sd">        crop_fraction (float): Deprecated, will be removed in a future version.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (torchvision.transforms.Compose): A composition of torchvision transforms.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; transforms = classify_transforms(size=224)</span>
<span></span><span class="sd">        &gt;&gt;&gt; img = Image.open("path/to/image.jpg")</span>
<span></span><span class="sd">        &gt;&gt;&gt; transformed_img = transforms(img)</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="kn">import</span><span class="w"> </span><span class="nn">torchvision.transforms</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">T</span>  <span class="c1"># scope for faster 'import ultralytics'</span>
<span></span>
<span></span>    <span class="n">scale_size</span> <span class="o">=</span> <span class="n">size</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
<span></span>
<span></span>    <span class="k">if</span> <span class="n">crop_fraction</span><span class="p">:</span>
<span></span>        <span class="k">raise</span> <span class="ne">DeprecationWarning</span><span class="p">(</span>
<span></span>            <span class="s2">"'crop_fraction' arg of classify_transforms is deprecated, will be removed in a future version."</span>
<span></span>        <span class="p">)</span>
<span></span>
<span></span>    <span class="c1"># Aspect ratio is preserved, crops center within image, no borders are added, image is lost</span>
<span></span>    <span class="k">if</span> <span class="n">scale_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">scale_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
<span></span>        <span class="c1"># Simple case, use torchvision built-in Resize with the shortest edge mode (scalar size arg)</span>
<span></span>        <span class="n">tfl</span> <span class="o">=</span> <span class="p">[</span><span class="n">T</span><span class="o">.</span><span class="n">Resize</span><span class="p">(</span><span class="n">scale_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">interpolation</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">InterpolationMode</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">))]</span>
<span></span>    <span class="k">else</span><span class="p">:</span>
<span></span>        <span class="c1"># Resize the shortest edge to matching target dim for non-square target</span>
<span></span>        <span class="n">tfl</span> <span class="o">=</span> <span class="p">[</span><span class="n">T</span><span class="o">.</span><span class="n">Resize</span><span class="p">(</span><span class="n">scale_size</span><span class="p">)]</span>
<span></span>    <span class="n">tfl</span> <span class="o">+=</span> <span class="p">[</span><span class="n">T</span><span class="o">.</span><span class="n">CenterCrop</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="n">T</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">(),</span> <span class="n">T</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">mean</span><span class="p">),</span> <span class="n">std</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">std</span><span class="p">))]</span>
<span></span>    <span class="k">return</span> <span class="n">T</span><span class="o">.</span><span class="n">Compose</span><span class="p">(</span><span class="n">tfl</span><span class="p">)</span>
</code></pre></div></details><p><br/><br/><hr/><br/></p><h2 id="ultralytics.data.augment.classify_augmentations"><span class="doc-kind doc-kind-function">function</span> <code>ultralytics.data.augment.classify_augmentations</code></h2><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">classify_augmentations</span><span class="p">(</span>
<span></span>    <span class="n">size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">224</span><span class="p">,</span>
<span></span>    <span class="n">mean</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">DEFAULT_MEAN</span><span class="p">,</span>
<span></span>    <span class="n">std</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">DEFAULT_STD</span><span class="p">,</span>
<span></span>    <span class="n">scale</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span></span>    <span class="n">ratio</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span></span>    <span class="n">hflip</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
<span></span>    <span class="n">vflip</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
<span></span>    <span class="n">auto_augment</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span></span>    <span class="n">hsv_h</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.015</span><span class="p">,</span>  <span class="c1"># image HSV-Hue augmentation (fraction)</span>
<span></span>    <span class="n">hsv_s</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span>  <span class="c1"># image HSV-Saturation augmentation (fraction)</span>
<span></span>    <span class="n">hsv_v</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span>  <span class="c1"># image HSV-Value augmentation (fraction)</span>
<span></span>    <span class="n">force_color_jitter</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span></span>    <span class="n">erasing</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
<span></span>    <span class="n">interpolation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">"BILINEAR"</span><span class="p">,</span>
<span></span><span class="p">)</span>
</code></pre></div><p>Create a composition of image augmentation transforms for classification tasks.</p><p>This function generates a set of image transformations suitable for training classification models. It includes options for resizing, flipping, color jittering, auto augmentation, and random erasing.</p><p><strong>Args</strong></p><table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>size</code></td><td><code>int</code></td><td>Target size for the image after transformations.</td><td><code>224</code></td></tr><tr><td><code>mean</code></td><td><code>tuple[float, float, float]</code></td><td>Mean values for each RGB channel used in normalization.</td><td><code>DEFAULT_MEAN</code></td></tr><tr><td><code>std</code></td><td><code>tuple[float, float, float]</code></td><td>Standard deviation values for each RGB channel used in normalization.</td><td><code>DEFAULT_STD</code></td></tr><tr><td><code>scale</code></td><td><code>tuple[float, float] | None</code></td><td>Range of size of the origin size cropped.</td><td><code>None</code></td></tr><tr><td><code>ratio</code></td><td><code>tuple[float, float] | None</code></td><td>Range of aspect ratio of the origin aspect ratio cropped.</td><td><code>None</code></td></tr><tr><td><code>hflip</code></td><td><code>float</code></td><td>Probability of horizontal flip.</td><td><code>0.5</code></td></tr><tr><td><code>vflip</code></td><td><code>float</code></td><td>Probability of vertical flip.</td><td><code>0.0</code></td></tr><tr><td><code>auto_augment</code></td><td><code>str | None</code></td><td>Auto augmentation policy. Can be 'randaugment', 'augmix', 'autoaugment' or None.</td><td><code>None</code></td></tr><tr><td><code>hsv_h</code></td><td><code>float</code></td><td>Image HSV-Hue augmentation factor.</td><td><code>0.015</code></td></tr><tr><td><code>hsv_s</code></td><td><code>float</code></td><td>Image HSV-Saturation augmentation factor.</td><td><code>0.4</code></td></tr><tr><td><code>hsv_v</code></td><td><code>float</code></td><td>Image HSV-Value augmentation factor.</td><td><code>0.4</code></td></tr><tr><td><code>force_color_jitter</code></td><td><code>bool</code></td><td>Whether to apply color jitter even if auto augment is enabled.</td><td><code>False</code></td></tr><tr><td><code>erasing</code></td><td><code>float</code></td><td>Probability of random erasing.</td><td><code>0.0</code></td></tr><tr><td><code>interpolation</code></td><td><code>str</code></td><td>Interpolation method of either 'NEAREST', 'BILINEAR' or 'BICUBIC'.</td><td><code>"BILINEAR"</code></td></tr></tbody></table><p><strong>Returns</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>torchvision.transforms.Compose</code></td><td>A composition of image augmentation transforms.</td></tr></tbody></table><p><strong>Examples</strong></p><div class="highlight"><pre><span></span><code><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">transforms</span> <span class="o">=</span> <span class="n">classify_augmentations</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">224</span><span class="p">,</span> <span class="n">auto_augment</span><span class="o">=</span><span class="s2">"randaugment"</span><span class="p">)</span>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">augmented_image</span> <span class="o">=</span> <span class="n">transforms</span><span class="p">(</span><span class="n">original_image</span><span class="p">)</span>
</code></pre></div><details><summary>Source code in <code>ultralytics/data/augment.py</code></summary><a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/augment.py#L2496-L2595"><i aria-hidden="true" class="fa-brands fa-github" style="margin-right:6px;"></i>View on GitHub</a><div class="highlight"><pre><span></span><code><span></span><span class="k">def</span><span class="w"> </span><span class="nf">classify_augmentations</span><span class="p">(</span>
<span></span>    <span class="n">size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">224</span><span class="p">,</span>
<span></span>    <span class="n">mean</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">DEFAULT_MEAN</span><span class="p">,</span>
<span></span>    <span class="n">std</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">DEFAULT_STD</span><span class="p">,</span>
<span></span>    <span class="n">scale</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span></span>    <span class="n">ratio</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span></span>    <span class="n">hflip</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
<span></span>    <span class="n">vflip</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
<span></span>    <span class="n">auto_augment</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span></span>    <span class="n">hsv_h</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.015</span><span class="p">,</span>  <span class="c1"># image HSV-Hue augmentation (fraction)</span>
<span></span>    <span class="n">hsv_s</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span>  <span class="c1"># image HSV-Saturation augmentation (fraction)</span>
<span></span>    <span class="n">hsv_v</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span>  <span class="c1"># image HSV-Value augmentation (fraction)</span>
<span></span>    <span class="n">force_color_jitter</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span></span>    <span class="n">erasing</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
<span></span>    <span class="n">interpolation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">"BILINEAR"</span><span class="p">,</span>
<span></span><span class="p">):</span>
<span></span><span class="w">    </span><span class="sd">"""Create a composition of image augmentation transforms for classification tasks.</span>
<span></span>
<span></span><span class="sd">    This function generates a set of image transformations suitable for training classification models. It includes</span>
<span></span><span class="sd">    options for resizing, flipping, color jittering, auto augmentation, and random erasing.</span>
<span></span>
<span></span><span class="sd">    Args:</span>
<span></span><span class="sd">        size (int): Target size for the image after transformations.</span>
<span></span><span class="sd">        mean (tuple[float, float, float]): Mean values for each RGB channel used in normalization.</span>
<span></span><span class="sd">        std (tuple[float, float, float]): Standard deviation values for each RGB channel used in normalization.</span>
<span></span><span class="sd">        scale (tuple[float, float] | None): Range of size of the origin size cropped.</span>
<span></span><span class="sd">        ratio (tuple[float, float] | None): Range of aspect ratio of the origin aspect ratio cropped.</span>
<span></span><span class="sd">        hflip (float): Probability of horizontal flip.</span>
<span></span><span class="sd">        vflip (float): Probability of vertical flip.</span>
<span></span><span class="sd">        auto_augment (str | None): Auto augmentation policy. Can be 'randaugment', 'augmix', 'autoaugment' or None.</span>
<span></span><span class="sd">        hsv_h (float): Image HSV-Hue augmentation factor.</span>
<span></span><span class="sd">        hsv_s (float): Image HSV-Saturation augmentation factor.</span>
<span></span><span class="sd">        hsv_v (float): Image HSV-Value augmentation factor.</span>
<span></span><span class="sd">        force_color_jitter (bool): Whether to apply color jitter even if auto augment is enabled.</span>
<span></span><span class="sd">        erasing (float): Probability of random erasing.</span>
<span></span><span class="sd">        interpolation (str): Interpolation method of either 'NEAREST', 'BILINEAR' or 'BICUBIC'.</span>
<span></span>
<span></span><span class="sd">    Returns:</span>
<span></span><span class="sd">        (torchvision.transforms.Compose): A composition of image augmentation transforms.</span>
<span></span>
<span></span><span class="sd">    Examples:</span>
<span></span><span class="sd">        &gt;&gt;&gt; transforms = classify_augmentations(size=224, auto_augment="randaugment")</span>
<span></span><span class="sd">        &gt;&gt;&gt; augmented_image = transforms(original_image)</span>
<span></span><span class="sd">    """</span>
<span></span>    <span class="c1"># Transforms to apply if Albumentations not installed</span>
<span></span>    <span class="kn">import</span><span class="w"> </span><span class="nn">torchvision.transforms</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">T</span>  <span class="c1"># scope for faster 'import ultralytics'</span>
<span></span>
<span></span>    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
<span></span>        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"classify_augmentations() size </span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s2"> must be integer, not (list, tuple)"</span><span class="p">)</span>
<span></span>    <span class="n">scale</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">scale</span> <span class="ow">or</span> <span class="p">(</span><span class="mf">0.08</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>  <span class="c1"># default imagenet scale range</span>
<span></span>    <span class="n">ratio</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ratio</span> <span class="ow">or</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">))</span>  <span class="c1"># default imagenet ratio range</span>
<span></span>    <span class="n">interpolation</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">InterpolationMode</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">)</span>
<span></span>    <span class="n">primary_tfl</span> <span class="o">=</span> <span class="p">[</span><span class="n">T</span><span class="o">.</span><span class="n">RandomResizedCrop</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="n">ratio</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">)]</span>
<span></span>    <span class="k">if</span> <span class="n">hflip</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
<span></span>        <span class="n">primary_tfl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">RandomHorizontalFlip</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">hflip</span><span class="p">))</span>
<span></span>    <span class="k">if</span> <span class="n">vflip</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
<span></span>        <span class="n">primary_tfl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">RandomVerticalFlip</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">vflip</span><span class="p">))</span>
<span></span>
<span></span>    <span class="n">secondary_tfl</span> <span class="o">=</span> <span class="p">[]</span>
<span></span>    <span class="n">disable_color_jitter</span> <span class="o">=</span> <span class="kc">False</span>
<span></span>    <span class="k">if</span> <span class="n">auto_augment</span><span class="p">:</span>
<span></span>        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">auto_augment</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="sa">f</span><span class="s2">"Provided argument should be string, but got type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">auto_augment</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span>
<span></span>        <span class="c1"># color jitter is typically disabled if AA/RA on,</span>
<span></span>        <span class="c1"># this allows override without breaking old hparm cfgs</span>
<span></span>        <span class="n">disable_color_jitter</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">force_color_jitter</span>
<span></span>
<span></span>        <span class="k">if</span> <span class="n">auto_augment</span> <span class="o">==</span> <span class="s2">"randaugment"</span><span class="p">:</span>
<span></span>            <span class="k">if</span> <span class="n">TORCHVISION_0_11</span><span class="p">:</span>
<span></span>                <span class="n">secondary_tfl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">RandAugment</span><span class="p">(</span><span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">))</span>
<span></span>            <span class="k">else</span><span class="p">:</span>
<span></span>                <span class="n">LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">'"auto_augment=randaugment" requires torchvision &gt;= 0.11.0. Disabling it.'</span><span class="p">)</span>
<span></span>
<span></span>        <span class="k">elif</span> <span class="n">auto_augment</span> <span class="o">==</span> <span class="s2">"augmix"</span><span class="p">:</span>
<span></span>            <span class="k">if</span> <span class="n">TORCHVISION_0_13</span><span class="p">:</span>
<span></span>                <span class="n">secondary_tfl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">AugMix</span><span class="p">(</span><span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">))</span>
<span></span>            <span class="k">else</span><span class="p">:</span>
<span></span>                <span class="n">LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">'"auto_augment=augmix" requires torchvision &gt;= 0.13.0. Disabling it.'</span><span class="p">)</span>
<span></span>
<span></span>        <span class="k">elif</span> <span class="n">auto_augment</span> <span class="o">==</span> <span class="s2">"autoaugment"</span><span class="p">:</span>
<span></span>            <span class="k">if</span> <span class="n">TORCHVISION_0_10</span><span class="p">:</span>
<span></span>                <span class="n">secondary_tfl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">AutoAugment</span><span class="p">(</span><span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">))</span>
<span></span>            <span class="k">else</span><span class="p">:</span>
<span></span>                <span class="n">LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">'"auto_augment=autoaugment" requires torchvision &gt;= 0.10.0. Disabling it.'</span><span class="p">)</span>
<span></span>
<span></span>        <span class="k">else</span><span class="p">:</span>
<span></span>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span></span>                <span class="sa">f</span><span class="s1">'Invalid auto_augment policy: </span><span class="si">{</span><span class="n">auto_augment</span><span class="si">}</span><span class="s1">. Should be one of "randaugment", '</span>
<span></span>                <span class="sa">f</span><span class="s1">'"augmix", "autoaugment" or None'</span>
<span></span>            <span class="p">)</span>
<span></span>
<span></span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">disable_color_jitter</span><span class="p">:</span>
<span></span>        <span class="n">secondary_tfl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">ColorJitter</span><span class="p">(</span><span class="n">brightness</span><span class="o">=</span><span class="n">hsv_v</span><span class="p">,</span> <span class="n">contrast</span><span class="o">=</span><span class="n">hsv_v</span><span class="p">,</span> <span class="n">saturation</span><span class="o">=</span><span class="n">hsv_s</span><span class="p">,</span> <span class="n">hue</span><span class="o">=</span><span class="n">hsv_h</span><span class="p">))</span>
<span></span>
<span></span>    <span class="n">final_tfl</span> <span class="o">=</span> <span class="p">[</span>
<span></span>        <span class="n">T</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">(),</span>
<span></span>        <span class="n">T</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">mean</span><span class="p">),</span> <span class="n">std</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">std</span><span class="p">)),</span>
<span></span>        <span class="n">T</span><span class="o">.</span><span class="n">RandomErasing</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">erasing</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
<span></span>    <span class="p">]</span>
<span></span>
<span></span>    <span class="k">return</span> <span class="n">T</span><span class="o">.</span><span class="n">Compose</span><span class="p">(</span><span class="n">primary_tfl</span> <span class="o">+</span> <span class="n">secondary_tfl</span> <span class="o">+</span> <span class="n">final_tfl</span><span class="p">)</span>
</code></pre></div></details><p><br/><br/></p><br/><br/><div class="git-info"><div class="dates-container"><span class="date-item" title="This page was first created on November 12, 2023"><span class="hover-item">ğŸ“…</span> Created 2 years ago </span><span class="date-item" title="This page was last updated on November 23, 2025"><span class="hover-item">âœï¸</span> Updated 21 days ago </span></div><div class="authors-container"><a class="author-link" href="https://github.com/ultralytics/ultralytics" title="glenn.jocher@ultralytics.com (8 changes)"><img alt="glenn.jocher@ultralytics.com" class="hover-item" loading="lazy" src="https://avatars.githubusercontent.com/u/9919?v=4&amp;s=96"/></a><a class="author-link" href="https://github.com/Laughing-q" title="Laughing-q (2 changes)"><img alt="Laughing-q" class="hover-item" loading="lazy" src="https://avatars.githubusercontent.com/u/61612323?v=4&amp;s=96"/></a><a class="author-link" href="https://github.com/ultralytics/ultralytics" title="muhammadrizwanmunawar123@gmail.com (1 change)"><img alt="muhammadrizwanmunawar123@gmail.com" class="hover-item" loading="lazy" src="https://avatars.githubusercontent.com/u/9919?v=4&amp;s=96"/></a><a class="author-link" href="https://github.com/jk4e" title="jk4e (1 change)"><img alt="jk4e" class="hover-item" loading="lazy" src="https://avatars.githubusercontent.com/u/116908874?v=4&amp;s=96"/></a><a class="author-link" href="https://github.com/Burhan-Q" title="Burhan-Q (1 change)"><img alt="Burhan-Q" class="hover-item" loading="lazy" src="https://avatars.githubusercontent.com/u/62214284?v=4&amp;s=96"/></a></div></div><div class="share-buttons"><button class="share-button hover-item" onclick="window.open('https://twitter.com/intent/tweet?url=https%3A%2F%2Fdocs.ultralytics.com%2Freference%2Fdata%2Faugment%2F', 'TwitterShare', 'width=550,height=680,menubar=no,toolbar=no'); return false;"><i class="fa-brands fa-x-twitter"></i> Tweet </button><button class="share-button hover-item linkedin" onclick="window.open('https://www.linkedin.com/shareArticle?url=https%3A%2F%2Fdocs.ultralytics.com%2Freference%2Fdata%2Faugment%2F', 'LinkedinShare', 'width=550,height=730,menubar=no,toolbar=no'); return false;"><i class="fa-brands fa-linkedin-in"></i> Share </button></div><br/></article></div>
<script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var labels=set.querySelector(".tabbed-labels");for(var tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
</div><button class="md-top md-icon" data-md-component="top" hidden="" type="button"><svg class="lucide lucide-circle-arrow-up" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="10"></circle><path d="m16 12-4-4-4 4M12 16V8"></path></svg> Back to top
</button></main><footer class="md-footer"><nav aria-label="Footer" class="md-footer__inner md-grid"><a aria-label="Previous: annotator" class="md-footer__link md-footer__link--prev" href="../annotator/"><div class="md-footer__button md-icon"><svg class="lucide lucide-arrow-left" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="m12 19-7-7 7-7M19 12H5"></path></svg></div><div class="md-footer__title"><span class="md-footer__direction"> Previous </span><div class="md-ellipsis"> annotator </div></div></a><a aria-label="Next: base" class="md-footer__link md-footer__link--next" href="../base/"><div class="md-footer__title"><span class="md-footer__direction"> Next </span><div class="md-ellipsis"> base </div></div><div class="md-footer__button md-icon"><svg class="lucide lucide-arrow-right" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M5 12h14M12 5l7 7-7 7"></path></svg></div></a></nav><div class="md-footer-meta md-typeset"><div class="md-footer-meta__inner md-grid"><div class="md-copyright"><div class="md-copyright__highlight"><a href="https://www.ultralytics.com/" target="_blank">Â© 2025 Ultralytics Inc.</a> All rights reserved. </div> Made with <a href="https://zensical.org/" rel="noopener" target="_blank"> Zensical </a></div><div class="md-social"><a class="md-social__link" href="https://github.com/ultralytics" rel="noopener" target="_blank" title="github.com"><svg viewbox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2" fill="currentColor"></path></svg></a><a class="md-social__link" href="https://www.linkedin.com/company/ultralytics/" rel="noopener" target="_blank" title="www.linkedin.com"><svg viewbox="0 0 448 512" xmlns="http://www.w3.org/2000/svg"><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3M135.4 416H69V202.2h66.5V416zM102.2 96a38.5 38.5 0 1 1 0 77 38.5 38.5 0 1 1 0-77m282.1 320h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9z" fill="currentColor"></path></svg></a><a class="md-social__link" href="https://x.com/ultralytics" rel="noopener" target="_blank" title="x.com"><svg viewbox="0 0 448 512" xmlns="http://www.w3.org/2000/svg"><path d="M357.2 48h70.6L273.6 224.2 455 464H313L201.7 318.6 74.5 464H3.8l164.9-188.5L-5.2 48h145.6l100.5 132.9zm-24.8 373.8h39.1L119.1 88h-42z" fill="currentColor"></path></svg></a><a class="md-social__link" href="https://youtube.com/ultralytics?sub_confirmation=1" rel="noopener" target="_blank" title="youtube.com"><svg viewbox="0 0 576 512" xmlns="http://www.w3.org/2000/svg"><path d="M549.7 124.1c-6.2-23.7-24.8-42.3-48.3-48.6C458.9 64 288.1 64 288.1 64S117.3 64 74.7 75.5c-23.5 6.3-42 24.9-48.3 48.6C15 167 15 256.4 15 256.4s0 89.4 11.4 132.3c6.3 23.6 24.8 41.5 48.3 47.8C117.3 448 288.1 448 288.1 448s170.8 0 213.4-11.5c23.5-6.3 42-24.2 48.3-47.8 11.4-42.9 11.4-132.3 11.4-132.3s0-89.4-11.4-132.3zM232.2 337.6V175.2l142.7 81.2z" fill="currentColor"></path></svg></a><a class="md-social__link" href="https://hub.docker.com/r/ultralytics/ultralytics/" rel="noopener" target="_blank" title="hub.docker.com"><svg viewbox="0 0 640 512" xmlns="http://www.w3.org/2000/svg"><path d="M349.9 236.3h-66.1v-59.4h66.1zm0-204.3h-66.1v60.7h66.1zm78.2 144.8H362v59.4h66.1zm-156.3-72.1h-66.1v60.1h66.1zm78.1 0h-66.1v60.1h66.1zm276.8 100c-14.4-9.7-47.6-13.2-73.1-8.4-3.3-24-16.7-44.9-41.1-63.7l-14-9.3-9.3 14c-18.4 27.8-23.4 73.6-3.7 103.8-8.7 4.7-25.8 11.1-48.4 10.7H2.4c-8.7 50.8 5.8 116.8 44 162.1 37.1 43.9 92.7 66.2 165.4 66.2 157.4 0 273.9-72.5 328.4-204.2 21.4.4 67.6.1 91.3-45.2 1.5-2.5 6.6-13.2 8.5-17.1zm-511.1-27.9h-66v59.4h66.1v-59.4zm78.1 0h-66.1v59.4h66.1zm78.1 0h-66.1v59.4h66.1zm-78.1-72.1h-66.1v60.1h66.1z" fill="currentColor"></path></svg></a><a class="md-social__link" href="https://pypi.org/project/ultralytics/" rel="noopener" target="_blank" title="pypi.org"><svg viewbox="0 0 448 512" xmlns="http://www.w3.org/2000/svg"><path d="M439.8 200.5c-7.7-30.9-22.3-54.2-53.4-54.2h-40.1v47.4c0 36.8-31.2 67.8-66.8 67.8H172.7c-29.2 0-53.4 25-53.4 54.3v101.8c0 29 25.2 46 53.4 54.3 33.8 9.9 66.3 11.7 106.8 0 26.9-7.8 53.4-23.5 53.4-54.3v-40.7H226.2v-13.6h160.2c31.1 0 42.6-21.7 53.4-54.2 11.2-33.5 10.7-65.7 0-108.6M286.2 444.7a20.4 20.4 0 1 1 0-40.7 20.4 20.4 0 1 1 0 40.7M167.8 248.1h106.8c29.7 0 53.4-24.5 53.4-54.3V91.9c0-29-24.4-50.7-53.4-55.6-35.8-5.9-74.7-5.6-106.8.1-45.2 8-53.4 24.7-53.4 55.6v40.7h106.9v13.6h-147c-31.1 0-58.3 18.7-66.8 54.2-9.8 40.7-10.2 66.1 0 108.6 7.6 31.6 25.7 54.2 56.8 54.2H101v-48.8c0-35.3 30.5-66.4 66.8-66.4m-6.6-183.4a20.4 20.4 0 1 1 0 40.8 20.4 20.4 0 1 1 0-40.8" fill="currentColor"></path></svg></a><a class="md-social__link" href="https://discord.com/invite/ultralytics" rel="noopener" target="_blank" title="discord.com"><svg viewbox="0 0 576 512" xmlns="http://www.w3.org/2000/svg"><path d="M492.5 69.8c-.2-.3-.4-.6-.8-.7-38.1-17.5-78.4-30-119.7-37.1-.4-.1-.8 0-1.1.1s-.6.4-.8.8c-5.5 9.9-10.5 20.2-14.9 30.6-44.6-6.8-89.9-6.8-134.4 0-4.5-10.5-9.5-20.7-15.1-30.6-.2-.3-.5-.6-.8-.8s-.7-.2-1.1-.2C162.5 39 122.2 51.5 84.1 69c-.3.1-.6.4-.8.7C7.1 183.5-13.8 294.6-3.6 404.2c0 .3.1.5.2.8s.3.4.5.6c44.4 32.9 94 58 146.8 74.2.4.1.8.1 1.1 0s.7-.4.9-.7c11.3-15.4 21.4-31.8 30-48.8.1-.2.2-.5.2-.8s0-.5-.1-.8-.2-.5-.4-.6-.4-.3-.7-.4c-15.8-6.1-31.2-13.4-45.9-21.9-.3-.2-.5-.4-.7-.6s-.3-.6-.3-.9 0-.6.2-.9.3-.5.6-.7c3.1-2.3 6.2-4.7 9.1-7.1.3-.2.6-.4.9-.4s.7 0 1 .1c96.2 43.9 200.4 43.9 295.5 0 .3-.1.7-.2 1-.2s.7.2.9.4c2.9 2.4 6 4.9 9.1 7.2.2.2.4.4.6.7s.2.6.2.9-.1.6-.3.9-.4.5-.6.6c-14.7 8.6-30 15.9-45.9 21.8-.2.1-.5.2-.7.4s-.3.4-.4.7-.1.5-.1.8.1.5.2.8c8.8 17 18.8 33.3 30 48.8.2.3.6.6.9.7s.8.1 1.1 0c52.9-16.2 102.6-41.3 147.1-74.2.2-.2.4-.4.5-.6s.2-.5.2-.8c12.3-126.8-20.5-236.9-86.9-334.5zm-302 267.7c-29 0-52.8-26.6-52.8-59.2s23.4-59.2 52.8-59.2c29.7 0 53.3 26.8 52.8 59.2 0 32.7-23.4 59.2-52.8 59.2m195.4 0c-29 0-52.8-26.6-52.8-59.2s23.4-59.2 52.8-59.2c29.7 0 53.3 26.8 52.8 59.2 0 32.7-23.2 59.2-52.8 59.2" fill="currentColor"></path></svg></a><a class="md-social__link" href="https://reddit.com/r/ultralytics" rel="noopener" target="_blank" title="reddit.com"><svg viewbox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="M0 256C0 114.6 114.6 0 256 0s256 114.6 256 256-114.6 256-256 256H37.1c-13.7 0-20.5-16.5-10.9-26.2L75 437C28.7 390.7 0 326.7 0 256m349.6-102.4c23.6 0 42.7-19.1 42.7-42.7s-19.1-42.7-42.7-42.7c-20.6 0-37.8 14.6-41.8 34-34.5 3.7-61.4 33-61.4 68.4v.2c-37.5 1.6-71.8 12.3-99 29.1-10.1-7.8-22.8-12.5-36.5-12.5-33 0-59.8 26.8-59.8 59.8 0 24 14.1 44.6 34.4 54.1 2 69.4 77.6 125.2 170.6 125.2s168.7-55.9 170.6-125.3c20.2-9.6 34.1-30.2 34.1-54 0-33-26.8-59.8-59.8-59.8-13.7 0-26.3 4.6-36.4 12.4-27.4-17-62.1-27.7-100-29.1v-.2c0-25.4 18.9-46.5 43.4-49.9 4.4 18.8 21.3 32.8 41.5 32.8zm-172.5 93.3c16.7 0 29.5 17.6 28.5 39.3s-13.5 29.6-30.3 29.6-31.4-8.8-30.4-30.5S160.3 247 177 247zm190.1 38.3c1 21.7-13.7 30.5-30.4 30.5s-29.3-7.9-30.3-29.6 11.8-39.3 28.5-39.3 31.2 16.6 32.1 38.3zm-48.1 56.7c-10.3 24.6-34.6 41.9-63 41.9s-52.7-17.3-63-41.9c-1.2-2.9.8-6.2 3.9-6.5 18.4-1.9 38.3-2.9 59.1-2.9s40.7 1 59.1 2.9c3.1.3 5.1 3.6 3.9 6.5" fill="currentColor"></path></svg></a><a class="md-social__link" href="https://weixin.qq.com/r/mp/LxckPDfEgWr_rXNf90I9" rel="noopener" target="_blank" title="weixin.qq.com"><svg viewbox="0 0 576 512" xmlns="http://www.w3.org/2000/svg"><path d="M385.2 167.6c6.4 0 12.6.3 18.8 1.1C387.4 90.3 303.3 32 207.7 32 100.5 32 13 104.8 13 197.4c0 53.4 29.3 97.5 77.9 131.6l-19.3 58.6 68-34.1c24.4 4.8 43.8 9.7 68.2 9.7 6.2 0 12.1-.3 18.3-.8-4-12.9-6.2-26.6-6.2-40.8-.1-84.9 72.9-154 165.3-154m-104.5-52.9c14.5 0 24.2 9.7 24.2 24.4 0 14.5-9.7 24.2-24.2 24.2-14.8 0-29.3-9.7-29.3-24.2.1-14.7 14.6-24.4 29.3-24.4m-136.4 48.6c-14.5 0-29.3-9.7-29.3-24.2 0-14.8 14.8-24.4 29.3-24.4 14.8 0 24.4 9.7 24.4 24.4 0 14.6-9.6 24.2-24.4 24.2M563 319.4c0-77.9-77.9-141.3-165.4-141.3-92.7 0-165.4 63.4-165.4 141.3S305 460.7 397.6 460.7c19.3 0 38.9-5.1 58.6-9.9l53.4 29.3-14.8-48.6C534 402.1 563 363.2 563 319.4m-219.1-24.5c-9.7 0-19.3-9.7-19.3-19.6 0-9.7 9.7-19.3 19.3-19.3 14.8 0 24.4 9.7 24.4 19.3 0 10-9.7 19.6-24.4 19.6m107.1 0c-9.7 0-19.3-9.7-19.3-19.6 0-9.7 9.7-19.3 19.3-19.3 14.5 0 24.4 9.7 24.4 19.3.1 10-9.9 19.6-24.4 19.6" fill="currentColor"></path></svg></a></div></div></div></footer></div><div class="md-dialog" data-md-component="dialog"><div class="md-dialog__inner md-typeset"></div></div><div class="md-progress" data-md-component="progress" role="progressbar"></div>
<script id="__config" type="application/json">{"annotate":null,"base":"../../..","features":["content.action.edit","content.code.annotate","content.code.copy","content.tooltips","toc.follow","navigation.top","navigation.tabs","navigation.tabs.sticky","navigation.prune","navigation.footer","navigation.tracking","navigation.instant","navigation.instant.progress","navigation.indexes","navigation.sections","content.tabs.link"],"search":"../../../assets/javascripts/workers/search.5df7522c.min.js","tags":null,"translations":{"clipboard.copied":"Copied to clipboard","clipboard.copy":"Copy to clipboard","search.result.more.one":"1 more on this page","search.result.more.other":"# more on this page","search.result.none":"No matching documents","search.result.one":"1 matching document","search.result.other":"# matching documents","search.result.placeholder":"Type to start searching","search.result.term.missing":"Missing","select.version":"Select version"},"version":null}</script>
<script src="../../../assets/javascripts/bundle.21aa498e.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/ultralytics/llm@v0.1.6/js/chat.min.js"></script>
<script src="https://unpkg.com/tablesort@5.6.0/dist/tablesort.min.js"></script>
<script src="../../../javascript/extra.js"></script>
<script src="../../../javascript/giscus.js"></script>
<script src="../../../javascript/tablesort.js"></script>
</body></html>